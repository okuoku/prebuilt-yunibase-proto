This is gambit.info, produced by makeinfo version 6.8 from gambit.txi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Gambit: (gambit).		A portable implementation of Scheme.
* gsi: (gambit) interpreter.	Gambit interpreter.
* gsc: (gambit) compiler.	Gambit compiler.
END-INFO-DIR-ENTRY

   This file documents Gambit, a portable implementation of Scheme.

   Copyright (C) 1994-2022 Marc Feeley.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the copyright holder.


File: gambit.info,  Node: Weak references,  Prev: Hashing,  Up: Hashing and weak references

8.10.2 Weak references
----------------------

The garbage collector is responsible for reclaiming objects that are no
longer needed by the program.  This is done by analyzing the
reachability graph of all objects from the roots (i.e.  the global
variables, the runnable threads, permanently allocated objects such as
procedures defined in a compiled file, nonexecutable wills, etc).  If a
root or a reachable object X contains a reference to an object Y then Y
is reachable.  As a general rule, unreachable objects are reclaimed by
the garbage collector.

   There are two types of references: strong references and weak
references.  Most objects, including pairs, vectors, records and
closures, contain strong references.  An object X is "strongly
reachable" if there is a path from the roots to X that traverses only
strong references.  Weak references only occur in wills and tables.
There are two types of weak references: will-weak references and
table-weak references.  If all paths from the roots to an object Y
traverse at least one table-weak reference, then Y will be reclaimed by
the garbage collector.  The will-weak references are used for
finalization and are explained in the next section.

* Menu:

* Wills::                           Wills
* Tables::                          Tables


File: gambit.info,  Node: Wills,  Next: Tables,  Prev: Weak references,  Up: Weak references

8.10.2.1 Wills
..............

The following procedures implement the "will" data type.  Will objects
provide support for finalization.  A will is an object that contains a
will-weak reference to a TESTATOR object (the object attached to the
will), and a strong reference to an ACTION procedure which is a one
parameter procedure which is called when the will is executed.

 -- procedure: make-will TESTATOR ACTION
 -- procedure: will? OBJ
 -- procedure: will-testator WILL
 -- procedure: will-execute! WILL

     The 'make-will' procedure creates a will object with the given
     TESTATOR object and ACTION procedure.  The 'will?' procedure tests
     if OBJ is a will object.  The 'will-testator' procedure gets the
     testator object attached to the WILL.  The 'will-execute!'
     procedure executes WILL.

     A will becomes "executable" when its TESTATOR object is not
     strongly reachable (i.e.  the TESTATOR object is either unreachable
     or only reachable using paths from the roots that traverse at least
     one weak reference).  Some objects, including symbols, small exact
     integers (fixnums), booleans and characters, are considered to be
     always strongly reachable.

     When the runtime system detects that a will has become executable
     the current computation is interrupted, the will's testator is set
     to '#f' and the will's action procedure is called with the will's
     testator as the sole argument.  Currently only the garbage
     collector detects when wills become executable but this may change
     in future versions of Gambit (for example the compiler could
     perform an analysis to infer will executability at compile time).
     The garbage collector builds a list of all executable wills.
     Shortly after a garbage collection, the action procedures of these
     wills will be called.  The link from the will to the action
     procedure is severed when the action procedure is called.

     Note that the testator object will not be reclaimed during the
     garbage collection that determined executability of the will.  It
     is only when an object is not reachable from the roots that it is
     reclaimed by the garbage collector.

     A remarkable feature of wills is that an action procedure can
     "resurrect" an object.  An action procedure could for example
     assign the testator object to a global variable or create a new
     will with the same testator object.

     For example:

          > (define a (list 123))
          > (set-cdr! a a) ; create a circular list
          > (define b (vector a))
          > (define c #f)
          > (define w
              (let ((obj a))
                (make-will obj
                           (lambda (x) ; x will be eq? to obj
                             (display "executing action procedure")
                             (newline)
                             (set! c x)))))
          > (will? w)
          #t
          > (car (will-testator w))
          123
          > (##gc)
          > (set! a #f)
          > (##gc)
          > (set! b #f)
          > (##gc)
          executing action procedure
          > (will-testator w)
          #f
          > (car c)
          123


File: gambit.info,  Node: Tables,  Prev: Wills,  Up: Weak references

8.10.3 Tables
-------------

The following procedures implement the "table" data type.  Tables are
heterogenous structures whose elements are indexed by keys which are
arbitrary objects.  Tables are similar to association lists but are
abstract and the access time for large tables is typically smaller.
Each key contained in the table is bound to a value.  The length of the
table is the number of key/value bindings it contains.  New key/value
bindings can be added to a table, the value bound to a key can be
changed, and existing key/value bindings can be removed.

   The references to the keys can either be all strong or all table-weak
and the references to the values can either be all strong or all
table-weak.  The garbage collector removes key/value bindings from a
table when 1) the key is a table-weak reference and the key is
unreachable or only reachable using paths from the roots that traverse
at least one table-weak reference, or 2) the value is a table-weak
reference and the value is unreachable or only reachable using paths
from the roots that traverse at least one table-weak reference.
Key/value bindings that are removed by the garbage collector are
reclaimed immediately.

   Although there are several possible ways of implementing tables, the
current implementation uses hashing with open-addressing.  This is space
efficient and provides constant-time access.  Hash tables are
automatically resized to maintain the load within specified bounds.  The
load is the number of active entries (the length of the table) divided
by the total number of entries in the hash table.

   Tables are parameterized with a key comparison procedure.  By default
the 'equal?' procedure is used, but 'eq?', 'eqv?', 'string=?',
'string-ci=?', or a user defined procedure can also be used.  To support
arbitrary key comparison procedures, tables are also parameterized with
a hashing procedure accepting a key as its single parameter and
returning a fixnum result.  The hashing procedure HASH must be
consistent with the key comparison procedure TEST, that is, for any two
keys K1 and K2 in the table, '(TEST K1 K2)' implies '(= (HASH K1) (HASH
K2))'.  A default hashing procedure consistent with the key comparison
procedure is provided by the system.  The default hashing procedure
generally gives good performance when the key comparison procedure is
'eq?', 'eqv?', 'equal?', 'string=?', and 'string-ci=?'.  However, for
user defined key comparison procedures, the default hashing procedure
always returns 0.  This degrades the performance of the table to a
linear search.

   Tables can be compared for equality using the 'equal?' procedure.
Two tables 'X' and 'Y' are considered equal by 'equal?' when they have
the same weakness attributes, the same key comparison procedure, the
same hashing procedure, the same length, and for all the keys 'K' in
'X', '(equal? (table-ref X K) (table-ref Y K))'.

 -- procedure: make-table [size: SIZE] [init: INIT] [weak-keys:
          WEAK-KEYS] [weak-values: WEAK-VALUES] [test: TEST] [hash:
          HASH] [min-load: MIN-LOAD] [max-load: MAX-LOAD]

     The procedure 'make-table' returns a new table.  The optional
     keyword parameters specify various parameters of the table.

     The SIZE parameter is a nonnegative exact integer indicating the
     expected length of the table.  The system uses SIZE to choose an
     appropriate initial size of the hash table so that it does not need
     to be resized too often.

     The INIT parameter indicates a value that is associated to keys
     that are not in the table.  When INIT is not specified, no value is
     associated to keys that are not in the table.

     The WEAK-KEYS and WEAK-VALUES parameters are extended booleans
     indicating respectively whether the keys and values are table-weak
     references (true) or strong references (false).  By default the
     keys and values are strong references.

     The TEST parameter indicates the key comparison procedure.  The
     default key comparison procedure is 'equal?'.  The key comparison
     procedures 'eq?', 'eqv?', 'equal?', 'string=?', and 'string-ci=?'
     are special because the system will use a reasonably good hash
     procedure when none is specified.

     The HASH parameter indicates the hash procedure.  This procedure
     must accept a single key parameter, return a fixnum, and be
     consistent with the key comparison procedure.  When HASH is not
     specified, a default hash procedure is used.  The default hash
     procedure is reasonably good when the key comparison procedure is
     'eq?', 'eqv?', 'equal?', 'string=?', or 'string-ci=?'.

     The MIN-LOAD and MAX-LOAD parameters are real numbers that indicate
     the minimum and maximum load of the table respectively.  The table
     is resized when adding or deleting a key/value binding would bring
     the table's load outside of this range.  The MIN-LOAD parameter
     must be no less than 0.05 and the MAX-LOAD parameter must be no
     greater than 0.95.  Moreover the difference between MIN-LOAD and
     MAX-LOAD must be at least 0.20.  When MIN-LOAD is not specified,
     the value 0.45 is used.  When MAX-LOAD is not specified, the value
     0.90 is used.

     For example:

          > (define t (make-table))
          > (table? t)
          #t
          > (table-length t)
          0
          > (table-set! t (list 1 2) 3)
          > (table-set! t (list 4 5) 6)
          > (table-ref t (list 1 2))
          3
          > (table-length t)
          2

 -- procedure: table? OBJ

     The procedure 'table?' returns '#t' when OBJ is a table and '#f'
     otherwise.

     For example:

          > (table? (make-table))
          #t
          > (table? 123)
          #f

 -- procedure: table-length TABLE

     The procedure 'table-length' returns the number of key/value
     bindings contained in the table TABLE.

     For example:

          > (define t (make-table weak-keys: #t))
          > (define x (list 1 2))
          > (define y (list 3 4))
          > (table-set! t x 111)
          > (table-set! t y 222)
          > (table-length t)
          2
          > (table-set! t x)
          > (table-length t)
          1
          > (##gc)
          > (table-length t)
          1
          > (set! y #f)
          > (##gc)
          > (table-length t)
          0

 -- procedure: table-ref TABLE KEY [DEFAULT]

     The procedure 'table-ref' returns the value bound to the object KEY
     in the table TABLE.  When KEY is not bound and DEFAULT is
     specified, DEFAULT is returned.  When DEFAULT is not specified but
     an INIT parameter was specified when TABLE was created, INIT is
     returned.  Otherwise an unbound-key-exception object is raised.

     For example:

          > (define t1 (make-table init: 999))
          > (table-set! t1 (list 1 2) 3)
          > (table-ref t1 (list 1 2))
          3
          > (table-ref t1 (list 4 5))
          999
          > (table-ref t1 (list 4 5) #f)
          #f
          > (define t2 (make-table))
          > (table-ref t2 (list 4 5))
          *** ERROR IN (console)@7.1 -- Unbound key
          (table-ref '#<table #2> '(4 5))

 -- procedure: table-set! TABLE KEY [VALUE]

     The procedure 'table-set!' binds the object KEY to VALUE in the
     table TABLE.  When VALUE is not specified, if TABLE contains a
     binding for KEY then the binding is removed from TABLE.  The
     procedure 'table-set!' returns an unspecified value.

     For example:

          > (define t (make-table))
          > (table-set! t (list 1 2) 3)
          > (table-set! t (list 4 5) 6)
          > (table-set! t (list 4 5))
          > (table-set! t (list 7 8))
          > (table-ref t (list 1 2))
          3
          > (table-ref t (list 4 5))
          *** ERROR IN (console)@7.1 -- Unbound key
          (table-ref '#<table #2> '(4 5))

 -- procedure: table-search PROC TABLE

     The procedure 'table-search' searches the table TABLE for a
     key/value binding for which the two parameter procedure PROC
     returns a non false result.  For each key/value binding visited by
     'table-search' the procedure PROC is called with the key as the
     first parameter and the value as the second parameter.  The
     procedure 'table-search' returns the first non false value returned
     by PROC, or '#f' if PROC returned '#f' for all key/value bindings
     in TABLE.

     The order in which the key/value bindings are visited is
     unspecified and may vary from one call of 'table-search' to the
     next.  While a call to 'table-search' is being performed on TABLE,
     it is an error to call any of the following procedures on TABLE:
     'table-ref', 'table-set!', 'table-search', 'table-for-each',
     'table-copy', 'table-merge', 'table-merge!', and 'table->list'.  It
     is also an error to compare with 'equal?' (directly or indirectly
     with 'member', 'assoc', 'table-ref', etc.)  an object that contains
     TABLE.  All these procedures may cause TABLE to be reordered and
     resized.  This restriction allows a more efficient iteration over
     the key/value bindings.

     For example:

          > (define square (make-table))
          > (table-set! square 2 4)
          > (table-set! square 3 9)
          > (table-search (lambda (k v) (and (odd? k) v)) square)
          9

 -- procedure: table-for-each PROC TABLE

     The procedure 'table-for-each' calls the two parameter procedure
     PROC for each key/value binding in the table TABLE.  The procedure
     PROC is called with the key as the first parameter and the value as
     the second parameter.  The procedure 'table-for-each' returns an
     unspecified value.

     The order in which the key/value bindings are visited is
     unspecified and may vary from one call of 'table-for-each' to the
     next.  While a call to 'table-for-each' is being performed on
     TABLE, it is an error to call any of the following procedures on
     TABLE: 'table-ref', 'table-set!', 'table-search', 'table-for-each',
     and 'table->list'.  It is also an error to compare with 'equal?'
     (directly or indirectly with 'member', 'assoc', 'table-ref', etc.)
     an object that contains TABLE.  All these procedures may cause
     TABLE to be reordered and resized.  This restriction allows a more
     efficient iteration over the key/value bindings.

     For example:

          > (define square (make-table))
          > (table-set! square 2 4)
          > (table-set! square 3 9)
          > (table-for-each (lambda (k v) (write (list k v)) (newline)) square)
          (2 4)
          (3 9)

 -- procedure: table->list TABLE

     The procedure 'table->list' returns an association list containing
     the key/value bindings in the table TABLE.  Each key/value binding
     yields a pair whose car field is the key and whose cdr field is the
     value bound to that key.  The order of the bindings in the list is
     unspecified.

     For example:

          > (define square (make-table))
          > (table-set! square 2 4)
          > (table-set! square 3 9)
          > (table->list square)
          ((3 . 9) (2 . 4))

 -- procedure: list->table LIST [size: SIZE] [init: INIT] [weak-keys:
          WEAK-KEYS] [weak-values: WEAK-VALUES] [test: TEST] [hash:
          HASH] [min-load: MIN-LOAD] [max-load: MAX-LOAD]

     The procedure 'list->table' returns a new table containing the
     key/value bindings in the association list LIST.  The optional
     keyword parameters specify various parameters of the table and have
     the same meaning as for the 'make-table' procedure.

     Each element of LIST is a pair whose car field is a key and whose
     cdr field is the value bound to that key.  If a key appears more
     than once in LIST (tested using the table's key comparison
     procedure) it is the first key/value binding in LIST that has
     precedence.

     For example:

          > (define t (list->table '((b . 2) (a . 1) (c . 3) (a . 4))))
          > (table->list t)
          ((a . 1) (b . 2) (c . 3))

 -- procedure: unbound-key-exception? OBJ
 -- procedure: unbound-key-exception-procedure EXC
 -- procedure: unbound-key-exception-arguments EXC

     Unbound-key-exception objects are raised by the procedure
     'table-ref' when the key does not have a binding in the table.  The
     parameter EXC must be an unbound-key-exception object.

     The procedure 'unbound-key-exception?' returns '#t' when OBJ is a
     unbound-key-exception object and '#f' otherwise.

     The procedure 'unbound-key-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'unbound-key-exception-arguments' returns the list of
     arguments of the procedure that raised EXC.

     For example:

          > (define t (make-table))
          > (define (handler exc)
              (if (unbound-key-exception? exc)
                  (list (unbound-key-exception-procedure exc)
                        (unbound-key-exception-arguments exc))
                  'not-unbound-key-exception))
          > (with-exception-catcher
              handler
              (lambda () (table-ref t '(1 2))))
          (#<procedure #2 table-ref> (#<table #3> (1 2)))

 -- procedure: table-copy TABLE

     The procedure 'table-copy' returns a new table containing the same
     key/value bindings as TABLE and the same table parameters (i.e.
     hash procedure, key comparison procedure, key and value weakness,
     etc).

     For example:

          > (define t (list->table '((b . 2) (a . 1) (c . 3))))
          > (define x (table-copy t))
          > (table-set! t 'b 99)
          > (table->list t)
          ((a . 1) (b . 99) (c . 3))
          > (table->list x)
          ((a . 1) (b . 2) (c . 3))

 -- procedure: table-merge! TABLE1 TABLE2 [TABLE2-TAKES-PRECEDENCE?]

     The procedure 'table-merge!' returns TABLE1 after the key/value
     bindings contained in TABLE2 have been added to it.  When a key
     exists both in TABLE1 and TABLE2, then the parameter
     TABLE2-TAKES-PRECEDENCE? indicates which binding will be kept (the
     one in TABLE1 if TABLE2-TAKES-PRECEDENCE? is false, and the one in
     TABLE2 otherwise).  If TABLE2-TAKES-PRECEDENCE? is not specified
     the binding in TABLE1 is kept.

     For example:

          > (define t1 (list->table '((a . 1) (b . 2) (c . 3))))
          > (define t2 (list->table '((a . 4) (b . 5) (z . 6))))
          > (table->list (table-merge! t1 t2))
          ((a . 1) (b . 2) (c . 3) (z . 6))
          > (define t1 (list->table '((a . 1) (b . 2) (c . 3))))
          > (define t2 (list->table '((a . 4) (b . 5) (z . 6))))
          > (table->list (table-merge! t1 t2 #t))
          ((a . 4) (b . 5) (c . 3) (z . 6))

 -- procedure: table-merge TABLE1 TABLE2 [TABLE2-TAKES-PRECEDENCE?]

     The procedure 'table-merge' returns a copy of TABLE1 (created with
     'table-copy') to which the key/value bindings contained in TABLE2
     have been added using 'table-merge!'.  When a key exists both in
     TABLE1 and TABLE2, then the parameter TABLE2-TAKES-PRECEDENCE?
     indicates which binding will be kept (the one in TABLE1 if
     TABLE2-TAKES-PRECEDENCE? is false, and the one in TABLE2
     otherwise).  If TABLE2-TAKES-PRECEDENCE? is not specified the
     binding in TABLE1 is kept.

     For example:

          > (define t1 (list->table '((a . 1) (b . 2) (c . 3))))
          > (define t2 (list->table '((a . 4) (b . 5) (z . 6))))
          > (table->list (table-merge t1 t2))
          ((a . 1) (b . 2) (c . 3) (z . 6))
          > (table->list (table-merge t1 t2 #t))
          ((a . 4) (b . 5) (c . 3) (z . 6))


File: gambit.info,  Node: Records,  Next: Threads,  Prev: Built-in data types,  Up: Top

9 Records
*********

 -- special form: define-structure name field...

     Record data types similar to Pascal records and C 'struct' types
     can be defined using the 'define-structure' special form.  The
     identifier name specifies the name of the new data type.  The
     structure name is followed by K identifiers naming each field of
     the record.  The 'define-structure' expands into a set of
     definitions of the following procedures:

        * 'make-name' - A K argument procedure which constructs a new
          record from the value of its K fields.

        * 'name?' - A procedure which tests if its single argument is of
          the given record type.

        * 'name-field' - For each field, a procedure taking as its
          single argument a value of the given record type and returning
          the content of the corresponding field of the record.

        * 'name-field-set!' - For each field, a two argument procedure
          taking as its first argument a value of the given record type.
          The second argument gets assigned to the corresponding field
          of the record and the void object is returned.

     Record data types have a printed representation that includes the
     name of the type and the name and value of each field.  Record data
     types can not be read by the 'read' procedure.

     For example:

          > (define-structure point x y color)
          > (define p (make-point 3 5 'red))
          > p
          #<point #2 x: 3 y: 5 color: red>
          > (point-x p)
          3
          > (point-color p)
          red
          > (point-color-set! p 'black)
          > p
          #<point #2 x: 3 y: 5 color: black>


File: gambit.info,  Node: Threads,  Next: Dynamic environment,  Prev: Records,  Up: Top

10 Threads
**********

Gambit supports the execution of multiple Scheme threads.  These threads
are managed entirely by Gambit's runtime and are not related to the host
operating system's threads.  Gambit's runtime does not currently take
advantage of multiprocessors (i.e.  at most one thread is running).

* Menu:

* Introduction::                  Introduction
* Thread objects::                Thread objects
* Mutex objects::                 Mutex objects
* Condition variable objects::    Condition variable objects
* Fairness::                      Fairness
* Memory coherency::              Memory coherency
* Timeouts::                      Timeouts
* Primordial thread::             Primordial thread
* Procedures::                    Procedures


File: gambit.info,  Node: Introduction,  Next: Thread objects,  Prev: Threads,  Up: Threads

10.1 Introduction
=================

Multithreading is a paradigm that is well suited for building complex
systems such as: servers, GUIs, and high-level operating systems.
Gambit's thread system offers mechanisms for creating threads of
execution and for synchronizing them.  The thread system also supports
features which are useful in a real-time context, such as priorities,
priority inheritance and timeouts.

   The thread system provides the following data types:

   * Thread (a virtual processor which shares object space with all
     other threads)

   * Mutex (a mutual exclusion device, also known as a lock and binary
     semaphore)

   * Condition variable (a set of blocked threads)


File: gambit.info,  Node: Thread objects,  Next: Mutex objects,  Prev: Introduction,  Up: Threads

10.2 Thread objects
===================

A "running thread" is a thread that is currently executing.  A "runnable
thread" is a thread that is ready to execute or running.  A thread is
"blocked" if it is waiting for a mutex to become unlocked, an I/O
operation to become possible, the end of a "sleep" period, etc.  A "new
thread" is a thread that has been allocated but has not yet been
initialized.  An "initialized thread" is a thread that can be made
runnable.  A new thread becomes runnable when it is started by calling
'thread-start!'.  A "terminated thread" is a thread that can no longer
become runnable (but "deadlocked threads" are not considered
terminated).  The only valid transitions between the thread states are
from new to initialized, from initialized to runnable, between runnable
and blocked, and from any state except new to terminated as indicated in
the following diagram:

                                                 unblock
                               start            <-------
     NEW -------> INITIALIZED -------> RUNNABLE -------> BLOCKED
                            \             |      block  /
                             \            v            /
                              +-----> TERMINATED <----+

   Each thread has a "base priority", which is a real number (where a
higher numerical value means a higher priority), a "priority boost",
which is a nonnegative real number representing the priority increase
applied to a thread when it blocks, and a "quantum", which is a
nonnegative real number representing a duration in seconds.

   Each thread has a "specific field" which can be used in an
application specific way to associate data with the thread (some thread
systems call this "thread local storage").

   Each thread has a "mailbox" which is used for inter-thread
communication.


File: gambit.info,  Node: Mutex objects,  Next: Condition variable objects,  Prev: Thread objects,  Up: Threads

10.3 Mutex objects
==================

A mutex can be in one of four states: "locked" (either "owned" or "not
owned") and "unlocked" (either "abandoned" or "not abandoned").

   An attempt to lock a mutex only succeeds if the mutex is in an
unlocked state, otherwise the current thread will wait.  A mutex in the
locked/owned state has an associated "owner thread", which by convention
is the thread that is responsible for unlocking the mutex (this case is
typical of critical sections implemented as "lock mutex, perform
operation, unlock mutex").  A mutex in the locked/not-owned state is not
linked to a particular thread.

   A mutex becomes locked when a thread locks it using the 'mutex-lock!'
primitive.  A mutex becomes unlocked/abandoned when the owner of a
locked/owned mutex terminates.  A mutex becomes unlocked/not-abandoned
when a thread unlocks it using the 'mutex-unlock!' primitive.

   The mutex primitives do not implement "recursive mutex semantics".
An attempt to lock a mutex that is locked implies that the current
thread waits even if the mutex is owned by the current thread (this can
lead to a deadlock if no other thread unlocks the mutex).

   Each mutex has a "specific field" which can be used in an application
specific way to associate data with the mutex.


File: gambit.info,  Node: Condition variable objects,  Next: Fairness,  Prev: Mutex objects,  Up: Threads

10.4 Condition variable objects
===============================

A condition variable represents a set of blocked threads.  These blocked
threads are waiting for a certain condition to become true.  When a
thread modifies some program state that might make the condition true,
the thread unblocks some number of threads (one or all depending on the
primitive used) so they can check if the condition is now true.  This
allows complex forms of interthread synchronization to be expressed more
conveniently than with mutexes alone.

   Each condition variable has a "specific field" which can be used in
an application specific way to associate data with the condition
variable.


File: gambit.info,  Node: Fairness,  Next: Memory coherency,  Prev: Condition variable objects,  Up: Threads

10.5 Fairness
=============

In various situations the scheduler must select one thread from a set of
threads (e.g.  which thread to run when a running thread blocks or
expires its quantum, which thread to unblock when a mutex becomes
unlocked or a condition variable is signaled).  The constraints on the
selection process determine the scheduler's "fairness".  The selection
depends on the order in which threads become runnable or blocked and on
the "priority" attached to the threads.

   The definition of fairness requires the notion of time ordering, i.e.
"event A occured before event B".  For the purpose of establishing time
ordering, the scheduler uses a clock with a discrete, usually variable,
resolution (a "tick").  Events occuring in a given tick can be
considered to be simultaneous (i.e.  if event A occured before event B
in real time, then the scheduler will claim that event A occured before
event B unless both events fall within the same tick, in which case the
scheduler arbitrarily chooses a time ordering).

   Each thread T has three priorities which affect fairness; the "base
priority", the "boosted priority", and the "effective priority".

   * The "base priority" is the value contained in T's "base priority"
     field (which is set with the 'thread-base-priority-set!'
     primitive).

   * T's "boosted flag" field contains a boolean that affects T's
     "boosted priority".  When the boosted flag field is false, the
     boosted priority is equal to the base priority, otherwise the
     boosted priority is equal to the base priority plus the value
     contained in T's "priority boost" field (which is set with the
     'thread-priority-boost-set!' primitive).  The boosted flag field is
     set to false when a thread is created, when its quantum expires,
     and when "thread-yield!"  is called.  The boosted flag field is set
     to true when a thread blocks.  By carefully choosing the base
     priority and priority boost, relatively to the other threads, it is
     possible to set up an interactive thread so that it has good I/O
     response time without being a CPU hog when it performs long
     computations.

   * The "effective priority" is equal to the maximum of T's boosted
     priority and the effective priority of all the threads that are
     blocked on a mutex owned by T.  This "priority inheritance" avoids
     priority inversion problems that would prevent a high priority
     thread blocked at the entry of a critical section to progress
     because a low priority thread inside the critical section is
     preempted for an arbitrary long time by a medium priority thread.

   Let P(T) be the effective priority of thread T and let R(T) be the
most recent time when one of the following events occurred for thread T,
thus making it runnable: T was started by calling 'thread-start!', T
called 'thread-yield!', T expired its quantum, or T became unblocked.
Let the relation NL(T1,T2), "T1 no later than T2", be true if
P(T1)<P(T2) or P(T1)=P(T2) and R(T1)>R(T2), and false otherwise.  The
scheduler will schedule the execution of threads in such a way that
whenever there is at least one runnable thread, 1) within a finite time
at least one thread will be running, and 2) there is never a pair of
runnable threads T1 and T2 for which NL(T1,T2) is true and T1 is not
running and T2 is running.

   A thread T expires its quantum when an amount of time equal to T's
quantum has elapsed since T entered the running state and T did not
block, terminate or call 'thread-yield!'.  At that point T exits the
running state to allow other threads to run.  A thread's quantum is thus
an indication of the rate of progress of the thread relative to the
other threads of the same priority.  Moreover, the resolution of the
timer measuring the running time may cause a certain deviation from the
quantum, so a thread's quantum should only be viewed as an approximation
of the time it can run before yielding to another thread.

   Threads blocked on a given mutex or condition variable will unblock
in an order which is consistent with decreasing priority and increasing
blocking time (i.e.  the highest priority thread unblocks first, and
among equal priority threads the one that blocked first unblocks first).


File: gambit.info,  Node: Memory coherency,  Next: Timeouts,  Prev: Fairness,  Up: Threads

10.6 Memory coherency
=====================

Read and write operations on the store (such as reading and writing a
variable, an element of a vector or a string) are not atomic.  It is an
error for a thread to write a location in the store while some other
thread reads or writes that same location.  It is the responsibility of
the application to avoid write/read and write/write races through
appropriate uses of the synchronization primitives.

   Concurrent reads and writes to ports are allowed.  It is the
responsibility of the implementation to serialize accesses to a given
port using the appropriate synchronization primitives.


File: gambit.info,  Node: Timeouts,  Next: Primordial thread,  Prev: Memory coherency,  Up: Threads

10.7 Timeouts
=============

All synchronization primitives which take a timeout parameter accept
three types of values as a timeout, with the following meaning:

   * a time object represents an absolute point in time

   * an exact or inexact real number represents a relative time in
     seconds from the moment the primitive was called

   * '#f' means that there is no timeout

   When a timeout denotes the current time or a time in the past, the
synchronization primitive claims that the timeout has been reached only
after the other synchronization conditions have been checked.  Moreover
the thread remains running (it does not enter the blocked state).  For
example, '(mutex-lock! m 0)' will lock mutex 'm' and return '#t' if 'm'
is currently unlocked, otherwise '#f' is returned because the timeout is
reached.


File: gambit.info,  Node: Primordial thread,  Next: Procedures,  Prev: Timeouts,  Up: Threads

10.8 Primordial thread
======================

The execution of a program is initially under the control of a single
thread known as the "primordial thread".  The primordial thread has an
unspecified base priority, priority boost, boosted flag, quantum, name,
specific field, dynamic environment, 'dynamic-wind' stack, and
exception-handler.  All threads are terminated when the primordial
thread terminates (normally or not).


File: gambit.info,  Node: Procedures,  Prev: Primordial thread,  Up: Threads

10.9 Procedures
===============

 -- procedure: current-thread

     This procedure returns the current thread.  For example:

          > (current-thread)
          #<thread #1 primordial>
          > (eq? (current-thread) (current-thread))
          #t

 -- procedure: thread? OBJ

     This procedure returns '#t' when OBJ is a thread object and '#f'
     otherwise.

     For example:

          > (thread? (current-thread))
          #t
          > (thread? 'foo)
          #f

 -- procedure: make-thread THUNK [NAME [THREAD-GROUP]]
 -- procedure: make-root-thread THUNK [NAME [THREAD-GROUP [INPUT-PORT
          [OUTPUT-PORT]]]]

     The 'make-thread' procedure creates and returns an initialized
     thread.  This thread is not automatically made runnable (the
     procedure 'thread-start!' must be used for this).  A thread has the
     following fields: base priority, priority boost, boosted flag,
     quantum, name, specific, end-result, end-exception, and a list of
     locked/owned mutexes it owns.  The thread's execution consists of a
     call to THUNK with the "initial continuation".  This continuation
     causes the (then) current thread to store the result in its
     end-result field, abandon all mutexes it owns, and finally
     terminate.  The 'dynamic-wind' stack of the initial continuation is
     empty.  The optional NAME is an arbitrary Scheme object which
     identifies the thread (useful for debugging); it defaults to an
     unspecified value.  The specific field is set to an unspecified
     value.  The optional THREAD-GROUP indicates which thread group this
     thread belongs to; it defaults to the thread group of the current
     thread.  The base priority, priority boost, and quantum of the
     thread are set to the same value as the current thread and the
     boosted flag is set to false.  The thread's mailbox is initially
     empty.  The thread inherits the dynamic environment from the
     current thread.  Moreover, in this dynamic environment the
     exception-handler is bound to the "initial exception-handler" which
     is a unary procedure which causes the (then) current thread to
     store in its end-exception field an uncaught-exception object whose
     "reason" is the argument of the handler, abandon all mutexes it
     owns, and finally terminate.

     The 'make-root-thread' procedure behaves like the 'make-thread'
     procedure except the created thread does not inherit the dynamic
     environment from the current thread and the base priority is set to
     0, the priority boost is set to 1.0e-6, and the quantum is set to
     0.02.  The dynamic environment of the thread has the global
     bindings of the parameter objects, except 'current-input-port'
     which is bound to INPUT-PORT, 'current-output-port' which is bound
     to OUTPUT-PORT, and 'current-directory' which is bound to the
     initial current working directory of the current process.  If
     INPUT-PORT is not specified it defaults to a port corresponding to
     the standard input ('stdin').  If OUTPUT-PORT is not specified it
     defaults to a port corresponding to the standard output ('stdout').

     For example:

          > (make-thread (lambda () (write 'hello)))
          #<thread #2>
          > (make-root-thread (lambda () (write 'world)) 'a-name)
          #<thread #3 a-name>

 -- procedure: thread THUNK

     The 'thread' procedure creates, starts and returns a new thread.
     The call '(thread THUNK)' is equivalent to '(thread-start!
     (make-thread THUNK))'.

     For example:

          > (define a (thread (lambda () (expt 2 1005))))
          > (define b (thread (lambda () (expt 2 1000))))
          > (/ (thread-join! a) (thread-join! b))
          32

 -- procedure: thread-name THREAD

     This procedure returns the name of the THREAD.  For example:

          > (thread-name (make-thread (lambda () #f) 'foo))
          foo

 -- procedure: thread-specific THREAD
 -- procedure: thread-specific-set! THREAD OBJ

     The 'thread-specific' procedure returns the content of the THREAD's
     specific field.

     The 'thread-specific-set!' procedure stores OBJ into the THREAD's
     specific field and returns an unspecified value.

     For example:

          > (thread-specific-set! (current-thread) "hello")
          > (thread-specific (current-thread))
          "hello"

 -- procedure: thread-base-priority THREAD
 -- procedure: thread-base-priority-set! THREAD PRIORITY

     The procedure 'thread-base-priority' returns a real number which
     corresponds to the base priority of the THREAD.

     The procedure 'thread-base-priority-set!' changes the base priority
     of the THREAD to PRIORITY and returns an unspecified value.  The
     PRIORITY must be a real number.

     For example:

          > (thread-base-priority-set! (current-thread) 12.3)
          > (thread-base-priority (current-thread))
          12.3

 -- procedure: thread-priority-boost THREAD
 -- procedure: thread-priority-boost-set! THREAD PRIORITY-BOOST

     The procedure 'thread-priority-boost' returns a real number which
     corresponds to the priority boost of the THREAD.

     The procedure 'thread-priority-boost-set!' changes the priority
     boost of the THREAD to PRIORITY-BOOST and returns an unspecified
     value.  The PRIORITY-BOOST must be a nonnegative real.

     For example:

          > (thread-priority-boost-set! (current-thread) 2.5)
          > (thread-priority-boost (current-thread))
          2.5

 -- procedure: thread-quantum THREAD
 -- procedure: thread-quantum-set! THREAD QUANTUM

     The procedure 'thread-quantum' returns a real number which
     corresponds to the quantum of the THREAD.

     The procedure 'thread-quantum-set!' changes the quantum of the
     THREAD to QUANTUM and returns an unspecified value.  The QUANTUM
     must be a nonnegative real.  A value of zero selects the smallest
     quantum supported by the implementation.

     For example:

          > (thread-quantum-set! (current-thread) 1.5)
          > (thread-quantum (current-thread))
          1.5
          > (thread-quantum-set! (current-thread) 0)
          > (thread-quantum (current-thread))
          0.

 -- procedure: thread-start! THREAD

     This procedure makes THREAD runnable and returns the THREAD.  The
     THREAD must be an initialized thread.

     For example:

          > (let ((t (thread-start! (make-thread (lambda () (write 'a))))))
              (write 'b)
              (thread-join! t))
          ab> or ba>

     NOTE: It is useful to separate thread creation and thread
     activation to avoid the race condition that would occur if the
     created thread tries to examine a table in which the current thread
     stores the created thread.  See the last example of the
     'thread-terminate!' procedure which contains mutually recursive
     threads.

 -- procedure: thread-yield!

     This procedure causes the current thread to exit the running state
     as if its quantum had expired and returns an unspecified value.

     For example:

          ; a busy loop that avoids being too wasteful of the CPU

          (let loop ()
            (if (mutex-lock! m 0) ; try to lock m but don't block
                (begin
                  (display "locked mutex m")
                  (mutex-unlock! m))
                (begin
                  (do-something-else)
                  (thread-yield!) ; relinquish rest of quantum
                  (loop))))

 -- procedure: thread-sleep! TIMEOUT

     This procedure causes the current thread to wait until the timeout
     is reached and returns an unspecified value.  This blocks the
     thread only if TIMEOUT represents a point in the future.  It is an
     error for TIMEOUT to be '#f'.

     For example:

          ; a clock with a gradual drift:

          (let loop ((x 1))
            (thread-sleep! 1)
            (write x)
            (loop (+ x 1)))

          ; a clock with no drift:

          (let ((start (time->seconds (current-time)))
            (let loop ((x 1))
              (thread-sleep! (seconds->time (+ x start)))
              (write x)
              (loop (+ x 1))))

 -- procedure: thread-terminate! THREAD

     This procedure causes an abnormal termination of the THREAD.  If
     the THREAD is not already terminated, all mutexes owned by the
     THREAD become unlocked/abandoned and a terminated-thread-exception
     object is stored in the THREAD's end-exception field.  If THREAD is
     the current thread, 'thread-terminate!' does not return.  Otherwise
     'thread-terminate!' returns an unspecified value; the termination
     of the THREAD will occur at some point between the calling of
     'thread-terminate!' and a finite time in the future (an explicit
     thread synchronization is needed to detect termination, see
     'thread-join!').

     For example:

          (define (amb thunk1 thunk2)
            (let ((result #f)
                  (result-mutex (make-mutex))
                  (done-mutex (make-mutex)))
              (letrec ((child1
                        (make-thread
                          (lambda ()
                            (let ((x (thunk1)))
                              (mutex-lock! result-mutex #f #f)
                              (set! result x)
                              (thread-terminate! child2)
                              (mutex-unlock! done-mutex)))))
                       (child2
                        (make-thread
                          (lambda ()
                            (let ((x (thunk2)))
                              (mutex-lock! result-mutex #f #f)
                              (set! result x)
                              (thread-terminate! child1)
                              (mutex-unlock! done-mutex))))))
                (mutex-lock! done-mutex #f #f)
                (thread-start! child1)
                (thread-start! child2)
                (mutex-lock! done-mutex #f #f)
                result)))

     NOTE: This operation must be used carefully because it terminates a
     thread abruptly and it is impossible for that thread to perform any
     kind of cleanup.  This may be a problem if the thread is in the
     middle of a critical section where some structure has been put in
     an inconsistent state.  However, another thread attempting to enter
     this critical section will raise an abandoned-mutex-exception
     object because the mutex is unlocked/abandoned.  This helps avoid
     observing an inconsistent state.  Clean termination can be obtained
     by polling, as shown in the example below.

     For example:

          (define (spawn thunk)
            (let ((t (make-thread thunk)))
              (thread-specific-set! t #t)
              (thread-start! t)
              t))

          (define (stop! thread)
            (thread-specific-set! thread #f)
            (thread-join! thread))

          (define (keep-going?)
            (thread-specific (current-thread)))

          (define count!
            (let ((m (make-mutex))
                  (i 0))
              (lambda ()
                (mutex-lock! m)
                (let ((x (+ i 1)))
                  (set! i x)
                  (mutex-unlock! m)
                  x))))

          (define (increment-forever!)
            (let loop () (count!) (if (keep-going?) (loop))))

          (let ((t1 (spawn increment-forever!))
                (t2 (spawn increment-forever!)))
            (thread-sleep! 1)
            (stop! t1)
            (stop! t2)
            (count!))  ==>  377290

 -- procedure: thread-join! thread [TIMEOUT [TIMEOUT-VAL]]

     This procedure causes the current thread to wait until the THREAD
     terminates (normally or not) or until the timeout is reached if
     TIMEOUT is supplied.  If the timeout is reached, THREAD-JOIN!
     returns TIMEOUT-VAL if it is supplied, otherwise a
     join-timeout-exception object is raised.  If the THREAD terminated
     normally, the content of the end-result field is returned,
     otherwise the content of the end-exception field is raised.

     For example:

          (let ((t (thread-start! (make-thread (lambda () (expt 2 100))))))
            (do-something-else)
            (thread-join! t))  ==>  1267650600228229401496703205376

          (let ((t (thread-start! (make-thread (lambda () (raise 123))))))
            (do-something-else)
            (with-exception-handler
              (lambda (exc)
                (if (uncaught-exception? exc)
                    (* 10 (uncaught-exception-reason exc))
                    99999))
              (lambda ()
                (+ 1 (thread-join! t)))))  ==>  1231

          (define thread-alive?
            (let ((unique (list 'unique)))
              (lambda (thread)
                ; Note: this procedure raises an exception if
                ; the thread terminated abnormally.
                (eq? (thread-join! thread 0 unique) unique))))

          (define (wait-for-termination! thread)
            (let ((eh (current-exception-handler)))
              (with-exception-handler
                (lambda (exc)
                  (if (not (or (terminated-thread-exception? exc)
                               (uncaught-exception? exc)))
                      (eh exc))) ; unexpected exceptions are handled by eh
                (lambda ()
                  ; The following call to thread-join! will wait until the
                  ; thread terminates.  If the thread terminated normally
                  ; thread-join! will return normally.  If the thread
                  ; terminated abnormally then one of these two exception
                  ; objects is raised by thread-join!:
                  ;   - terminated-thread-exception object
                  ;   - uncaught-exception object
                  (thread-join! thread)
                  #f)))) ; ignore result of thread-join!

 -- procedure: thread-send THREAD MSG

     Each thread has a mailbox which stores messages delivered to the
     thread in the order delivered.

     The procedure 'thread-send' adds the message MSG at the end of the
     mailbox of thread THREAD and returns an unspecified value.

     For example:

          > (thread-send (current-thread) 111)
          > (thread-send (current-thread) 222)
          > (thread-receive)
          111
          > (thread-receive)
          222

 -- procedure: thread-receive [TIMEOUT [DEFAULT]]
 -- procedure: thread-mailbox-next [TIMEOUT [DEFAULT]]
 -- procedure: thread-mailbox-rewind
 -- procedure: thread-mailbox-extract-and-rewind

     To allow a thread to examine the messages in its mailbox without
     removing them from the mailbox, each thread has a "mailbox cursor"
     which normally points to the last message accessed in the mailbox.
     When a mailbox cursor is rewound using the procedure
     'thread-mailbox-rewind' or 'thread-mailbox-extract-and-rewind' or
     'thread-receive', the cursor does not point to a message, but the
     next call to 'thread-receive' and 'thread-mailbox-next' will set
     the cursor to the oldest message in the mailbox.

     The procedure 'thread-receive' advances the mailbox cursor of the
     current thread to the next message, removes that message from the
     mailbox, rewinds the mailbox cursor, and returns the message.  When
     TIMEOUT is not specified, the current thread will wait until a
     message is available in the mailbox.  When TIMEOUT is specified and
     DEFAULT is not specified, a mailbox-receive-timeout-exception
     object is raised if the timeout is reached before a message is
     available.  When TIMEOUT is specified and DEFAULT is specified,
     DEFAULT is returned if the timeout is reached before a message is
     available.

     The procedure 'thread-mailbox-next' behaves like 'thread-receive'
     except that the message remains in the mailbox and the mailbox
     cursor is not rewound.

     The procedures 'thread-mailbox-rewind' or
     'thread-mailbox-extract-and-rewind' rewind the mailbox cursor of
     the current thread so that the next call to 'thread-mailbox-next'
     and 'thread-receive' will access the oldest message in the mailbox.
     Additionally the procedure 'thread-mailbox-extract-and-rewind' will
     remove from the mailbox the message most recently accessed by a
     call to 'thread-mailbox-next'.  When 'thread-mailbox-next' has not
     been called since the last call to 'thread-receive' or
     'thread-mailbox-rewind' or 'thread-mailbox-extract-and-rewind', a
     call to 'thread-mailbox-extract-and-rewind' only resets the mailbox
     cursor (no message is removed).

     For example:

          > (thread-send (current-thread) 111)
          > (thread-receive 1 999)
          111
          > (thread-send (current-thread) 222)
          > (thread-send (current-thread) 333)
          > (thread-mailbox-next 1 999)
          222
          > (thread-mailbox-next 1 999)
          333
          > (thread-mailbox-next 1 999)
          999
          > (thread-mailbox-extract-and-rewind)
          > (thread-receive 1 999)
          222
          > (thread-receive 1 999)
          999

 -- procedure: mailbox-receive-timeout-exception? OBJ
 -- procedure: mailbox-receive-timeout-exception-procedure EXC
 -- procedure: mailbox-receive-timeout-exception-arguments EXC

     Mailbox-receive-timeout-exception objects are raised by the
     procedures 'thread-receive' and 'thread-mailbox-next' when a
     timeout expires before a message is available and no default value
     is specified.  The parameter EXC must be a
     mailbox-receive-timeout-exception object.

     The procedure 'mailbox-receive-timeout-exception?' returns '#t'
     when OBJ is a mailbox-receive-timeout-exception object and '#f'
     otherwise.

     The procedure 'mailbox-receive-timeout-exception-procedure' returns
     the procedure that raised EXC.

     The procedure 'mailbox-receive-timeout-exception-arguments' returns
     the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (mailbox-receive-timeout-exception? exc)
                  (list (mailbox-receive-timeout-exception-procedure exc)
                        (mailbox-receive-timeout-exception-arguments exc))
                  'not-mailbox-receive-timeout-exception))
          > (with-exception-catcher
              handler
              (lambda () (thread-receive 1)))
          (#<procedure #2 thread-receive> (1))

 -- procedure: mutex? OBJ

     This procedure returns '#t' when OBJ is a mutex object and '#f'
     otherwise.

     For example:

          > (mutex? (make-mutex))
          #t
          > (mutex? 'foo)
          #f

 -- procedure: make-mutex [NAME]

     This procedure returns a new mutex in the unlocked/not-abandoned
     state.  The optional NAME is an arbitrary Scheme object which
     identifies the mutex (useful for debugging); it defaults to an
     unspecified value.  The mutex's specific field is set to an
     unspecified value.

     For example:

          > (make-mutex)
          #<mutex #2>
          > (make-mutex 'foo)
          #<mutex #3 foo>

 -- procedure: mutex-name MUTEX

     Returns the name of the MUTEX.  For example:

          > (mutex-name (make-mutex 'foo))
          foo

 -- procedure: mutex-specific MUTEX
 -- procedure: mutex-specific-set! MUTEX OBJ

     The 'mutex-specific' procedure returns the content of the MUTEX's
     specific field.

     The 'mutex-specific-set!' procedure stores OBJ into the MUTEX's
     specific field and returns an unspecified value.

     For example:

          > (define m (make-mutex))
          > (mutex-specific-set! m "hello")
          > (mutex-specific m)
          "hello"
          > (define (mutex-lock-recursively! mutex)
              (if (eq? (mutex-state mutex) (current-thread))
                  (let ((n (mutex-specific mutex)))
                    (mutex-specific-set! mutex (+ n 1)))
                  (begin
                    (mutex-lock! mutex)
                    (mutex-specific-set! mutex 0))))
          > (define (mutex-unlock-recursively! mutex)
              (let ((n (mutex-specific mutex)))
                (if (= n 0)
                    (mutex-unlock! mutex)
                    (mutex-specific-set! mutex (- n 1)))))
          > (mutex-lock-recursively! m)
          > (mutex-lock-recursively! m)
          > (mutex-lock-recursively! m)
          > (mutex-specific m)
          2

 -- procedure: mutex-state MUTEX

     Thos procedure returns information about the state of the MUTEX.
     The possible results are:

        * thread T: the MUTEX is in the locked/owned state and thread T
          is the owner of the MUTEX

        * symbol 'not-owned': the MUTEX is in the locked/not-owned state

        * symbol 'abandoned': the MUTEX is in the unlocked/abandoned
          state

        * symbol 'not-abandoned': the MUTEX is in the
          unlocked/not-abandoned state

     For example:

          (mutex-state (make-mutex))  ==>  not-abandoned

          (define (thread-alive? thread)
            (let ((mutex (make-mutex)))
              (mutex-lock! mutex #f thread)
              (let ((state (mutex-state mutex)))
                (mutex-unlock! mutex) ; avoid space leak
                (eq? state thread))))

 -- procedure: mutex-lock! MUTEX [TIMEOUT [THREAD]]

     This procedure locks MUTEX.  If the MUTEX is currently locked, the
     current thread waits until the MUTEX is unlocked, or until the
     timeout is reached if TIMEOUT is supplied.  If the timeout is
     reached, 'mutex-lock!' returns '#f'.  Otherwise, the state of the
     MUTEX is changed as follows:

        * if THREAD is '#f' the MUTEX becomes locked/not-owned,

        * otherwise, let T be THREAD (or the current thread if THREAD is
          not supplied),

             * if T is terminated the MUTEX becomes unlocked/abandoned,

             * otherwise MUTEX becomes locked/owned with T as the owner.

     After changing the state of the MUTEX, an abandoned-mutex-exception
     object is raised if the MUTEX was unlocked/abandoned before the
     state change, otherwise 'mutex-lock!' returns '#t'.  It is not an
     error if the MUTEX is owned by the current thread (but the current
     thread will have to wait).

     For example:

          ; an implementation of a mailbox object of depth one; this
          ; implementation does not behave well in the presence of forced
          ; thread terminations using thread-terminate! (deadlock can occur
          ; if a thread is terminated in the middle of a put! or get! operation)

          (define (make-empty-mailbox)
            (let ((put-mutex (make-mutex)) ; allow put! operation
                  (get-mutex (make-mutex))
                  (cell #f))

              (define (put! obj)
                (mutex-lock! put-mutex #f #f) ; prevent put! operation
                (set! cell obj)
                (mutex-unlock! get-mutex)) ; allow get! operation

              (define (get!)
                (mutex-lock! get-mutex #f #f) ; wait until object in mailbox
                (let ((result cell))
                  (set! cell #f) ; prevent space leaks
                  (mutex-unlock! put-mutex) ; allow put! operation
                  result))

              (mutex-lock! get-mutex #f #f) ; prevent get! operation

              (lambda (msg)
                (case msg
                  ((put!) put!)
                  ((get!) get!)
                  (else (error "unknown message"))))))

          (define (mailbox-put! m obj) ((m 'put!) obj))
          (define (mailbox-get! m) ((m 'get!)))

          ; an alternate implementation of thread-sleep!

          (define (sleep! timeout)
            (let ((m (make-mutex)))
              (mutex-lock! m #f #f)
              (mutex-lock! m timeout #f)))

          ; a procedure that waits for one of two mutexes to unlock

          (define (lock-one-of! mutex1 mutex2)
            ; this procedure assumes that neither mutex1 or mutex2
            ; are owned by the current thread
            (let ((ct (current-thread))
                  (done-mutex (make-mutex)))
              (mutex-lock! done-mutex #f #f)
              (let ((t1 (thread-start!
                         (make-thread
                          (lambda ()
                            (mutex-lock! mutex1 #f ct)
                            (mutex-unlock! done-mutex)))))
                    (t2 (thread-start!
                         (make-thread
                          (lambda ()
                            (mutex-lock! mutex2 #f ct)
                            (mutex-unlock! done-mutex))))))
                (mutex-lock! done-mutex #f #f)
                (thread-terminate! t1)
                (thread-terminate! t2)
                (if (eq? (mutex-state mutex1) ct)
                    (begin
                      (if (eq? (mutex-state mutex2) ct)
                          (mutex-unlock! mutex2)) ; don't lock both
                      mutex1)
                    mutex2))))

 -- procedure: mutex-unlock! MUTEX [CONDITION-VARIABLE [TIMEOUT]]

     This procedure unlocks the MUTEX by making it
     unlocked/not-abandoned.  It is not an error to unlock an unlocked
     mutex and a mutex that is owned by any thread.  If
     CONDITION-VARIABLE is supplied, the current thread is blocked and
     added to the CONDITION-VARIABLE before unlocking MUTEX; the thread
     can unblock at any time but no later than when an appropriate call
     to 'condition-variable-signal!' or 'condition-variable-broadcast!'
     is performed (see below), and no later than the timeout (if TIMEOUT
     is supplied).  If there are threads waiting to lock this MUTEX, the
     scheduler selects a thread, the mutex becomes locked/owned or
     locked/not-owned, and the thread is unblocked.  'mutex-unlock!'
     returns '#f' when the timeout is reached, otherwise it returns
     '#t'.

     NOTE: The reason the thread can unblock at any time (when
     CONDITION-VARIABLE is supplied) is that the scheduler, when it
     detects a serious problem such as a deadlock, must interrupt one of
     the blocked threads (such as the primordial thread) so that it can
     perform some appropriate action.  After a thread blocked on a
     condition-variable has handled such an interrupt it would be wrong
     for the scheduler to return the thread to the blocked state,
     because any calls to 'condition-variable-broadcast!' during the
     interrupt will have gone unnoticed.  It is necessary for the thread
     to remain runnable and return from the call to 'mutex-unlock!' with
     a result of '#t'.

     NOTE: 'mutex-unlock!' is related to the "wait" operation on
     condition variables available in other thread systems.  The main
     difference is that "wait" automatically locks MUTEX just after the
     thread is unblocked.  This operation is not performed by
     'mutex-unlock!' and so must be done by an explicit call to
     'mutex-lock!'.  This has the advantages that a different timeout
     and exception-handler can be specified on the 'mutex-lock!' and
     'mutex-unlock!' and the location of all the mutex operations is
     clearly apparent.

     For example:

          (let loop ()
            (mutex-lock! m)
            (if (condition-is-true?)
                (begin
                  (do-something-when-condition-is-true)
                  (mutex-unlock! m))
                (begin
                  (mutex-unlock! m cv)
                  (loop))))

 -- procedure: condition-variable? OBJ

     This procedure returns '#t' when OBJ is a condition-variable object
     and '#f' otherwise.

     For example:

          > (condition-variable? (make-condition-variable))
          #t
          > (condition-variable? 'foo)
          #f

 -- procedure: make-condition-variable [NAME]

     This procedure returns a new empty condition variable.  The
     optional NAME is an arbitrary Scheme object which identifies the
     condition variable (useful for debugging); it defaults to an
     unspecified value.  The condition variable's specific field is set
     to an unspecified value.

     For example:

          > (make-condition-variable)
          #<condition-variable #2>

 -- procedure: condition-variable-name CONDITION-VARIABLE

     This procedure returns the name of the CONDITION-VARIABLE.  For
     example:

          > (condition-variable-name (make-condition-variable 'foo))
          foo

 -- procedure: condition-variable-specific CONDITION-VARIABLE
 -- procedure: condition-variable-specific-set! CONDITION-VARIABLE OBJ

     The 'condition-variable-specific' procedure returns the content of
     the CONDITION-VARIABLE's specific field.

     The 'condition-variable-specific-set!' procedure stores OBJ into
     the CONDITION-VARIABLE's specific field and returns an unspecified
     value.

     For example:

          > (define cv (make-condition-variable))
          > (condition-variable-specific-set! cv "hello")
          > (condition-variable-specific cv)
          "hello"

 -- procedure: condition-variable-signal! CONDITION-VARIABLE

     This procedure unblocks a thread blocked on the CONDITION-VARIABLE
     (if there is at least one) and returns an unspecified value.

     For example:

          ; an implementation of a mailbox object of depth one; this
          ; implementation behaves gracefully when threads are forcibly
          ; terminated using thread-terminate! (an abandoned-mutex-exception
          ; object will be raised when a put! or get! operation is attempted
          ; after a thread is terminated in the middle of a put! or get!
          ; operation)

          (define (make-empty-mailbox)
            (let ((mutex (make-mutex))
                  (put-condvar (make-condition-variable))
                  (get-condvar (make-condition-variable))
                  (full? #f)
                  (cell #f))

              (define (put! obj)
                (mutex-lock! mutex)
                (if full?
                    (begin
                      (mutex-unlock! mutex put-condvar)
                      (put! obj))
                    (begin
                      (set! cell obj)
                      (set! full? #t)
                      (condition-variable-signal! get-condvar)
                      (mutex-unlock! mutex))))

              (define (get!)
                (mutex-lock! mutex)
                (if (not full?)
                    (begin
                      (mutex-unlock! mutex get-condvar)
                      (get!))
                    (let ((result cell))
                      (set! cell #f) ; avoid space leaks
                      (set! full? #f)
                      (condition-variable-signal! put-condvar)
                      (mutex-unlock! mutex)
                      result)))

              (lambda (msg)
                (case msg
                  ((put!) put!)
                  ((get!) get!)
                  (else (error "unknown message"))))))

          (define (mailbox-put! m obj) ((m 'put!) obj))
          (define (mailbox-get! m) ((m 'get!)))

 -- procedure: condition-variable-broadcast! CONDITION-VARIABLE

     This procedure unblocks all the thread blocked on the
     CONDITION-VARIABLE and returns an unspecified value.

     For example:

          (define (make-semaphore n)
            (vector n (make-mutex) (make-condition-variable)))

          (define (semaphore-wait! sema)
            (mutex-lock! (vector-ref sema 1))
            (let ((n (vector-ref sema 0)))
              (if (> n 0)
                  (begin
                    (vector-set! sema 0 (- n 1))
                    (mutex-unlock! (vector-ref sema 1)))
                  (begin
                    (mutex-unlock! (vector-ref sema 1) (vector-ref sema 2))
                    (semaphore-wait! sema))))

          (define (semaphore-signal-by! sema increment)
            (mutex-lock! (vector-ref sema 1))
            (let ((n (+ (vector-ref sema 0) increment)))
              (vector-set! sema 0 n)
              (if (> n 0)
                  (condition-variable-broadcast! (vector-ref sema 2)))
              (mutex-unlock! (vector-ref sema 1))))


File: gambit.info,  Node: Dynamic environment,  Next: Exceptions,  Prev: Threads,  Up: Top

11 Dynamic environment
**********************

The "dynamic environment" is the structure which allows the system to
find the value returned by the standard procedures 'current-input-port'
and 'current-output-port'.  The standard procedures
'with-input-from-file' and 'with-output-to-file' extend the dynamic
environment to produce a new dynamic environment which is in effect for
the dynamic extent of the call to the thunk passed as their last
argument.  These procedures are essentially special purpose dynamic
binding operations on hidden dynamic variables (one for
'current-input-port' and one for 'current-output-port').  Gambit
generalizes this dynamic binding mechanism to allow the user to
introduce new dynamic variables, called "parameter objects", and
dynamically bind them.  The parameter objects implemented by Gambit are
compatible with the specification of the "Parameter objects SRFI" (SRFI
39).

   One important issue is the relationship between the dynamic
environments of the parent and child threads when a thread is created.
Each thread has its own dynamic environment that is accessed when
looking up the value bound to a parameter object by that thread.  When a
thread's dynamic environment is extended it does not affect the dynamic
environment of other threads.  When a thread is created it is given a
dynamic environment whose bindings are inherited from the parent thread.
In this inherited dynamic environment the parameter objects are bound to
the same cells as the parent's dynamic environment (in other words an
assignment of a new value to a parameter object is visible in the other
thread).

   Another important issue is the interaction between the 'dynamic-wind'
procedure and dynamic environments.  When a thread creates a
continuation, the thread's dynamic environment and the 'dynamic-wind'
stack are saved within the continuation (an alternate but equivalent
point of view is that the 'dynamic-wind' stack is part of the dynamic
environment).  When this continuation is invoked the required
'dynamic-wind' before and after thunks are called and the saved dynamic
environment is reinstated as the dynamic environment of the current
thread.  During the call to each required 'dynamic-wind' before and
after thunk, the dynamic environment and the 'dynamic-wind' stack in
effect when the corresponding 'dynamic-wind' was executed are
reinstated.  Note that this specification precisely defines the
semantics of calling 'call-with-current-continuation' or invoking a
continuation within a before or after thunk.  The semantics are well
defined even when a continuation created by another thread is invoked.
Below is an example exercising the subtleties of this semantics.

     (with-output-to-file
      "foo"
      (lambda ()
        (let ((k (call-with-current-continuation
                  (lambda (exit)
                    (with-output-to-file
                     "bar"
                     (lambda ()
                       (dynamic-wind
                        (lambda ()
                          (write '(b1))
                          (force-output))
                        (lambda ()
                          (let ((x (call-with-current-continuation
                                    (lambda (cont) (exit cont)))))
                            (write '(t1))
                            (force-output)
                            x))
                        (lambda ()
                          (write '(a1))
                          (force-output)))))))))
          (if k
              (dynamic-wind
               (lambda ()
                 (write '(b2))
                 (force-output))
               (lambda ()
                 (with-output-to-file
                  "baz"
                  (lambda ()
                    (write '(t2))
                    (force-output)
                    ; go back inside (with-output-to-file "bar" ...)
                    (k #f))))
               (lambda ()
                 (write '(a2))
                 (force-output)))))))

   The following actions will occur when this code is executed:
'(b1)(a1)' is written to "bar", '(b2)' is then written to "foo", '(t2)'
is then written to "baz", '(a2)' is then written to "foo", and finally
'(b1)(t1)(a1)' is written to "bar".

 -- procedure: make-parameter OBJ [SET-FILTER [GET-FILTER]]

     The dynamic environment is composed of two parts: the "local
     dynamic environment" and the "global dynamic environment".  There
     is a single global dynamic environment, and it is used to lookup
     parameter objects that can't be found in the local dynamic
     environment.

     The 'make-parameter' procedure returns a new "parameter object".
     The SET-FILTER argument is a one argument "set" conversion
     procedure.  The GET-FILTER argument is a one argument "get"
     conversion procedure.  If they are not specified the conversion
     procedures default to the identity function.

     The global dynamic environment is updated to associate the
     parameter object to a new cell.  The initial content of the cell is
     the result of applying the "set" conversion procedure to OBJ.

     A parameter object is a procedure which accepts zero or one
     argument.  The cell bound to a particular parameter object in the
     dynamic environment is accessed by calling the parameter object.
     When no argument is passed, the value returned is the result of
     applying the "get" conversion procedure to the content of the cell.
     When one argument is passed the content of the cell is updated with
     the result of applying the parameter object's "set" conversion
     procedure to the argument.  Note that the conversion procedures can
     be used for guaranteeing the type of the parameter object's binding
     and/or to perform some conversion of the value.

     For example:

          > (define radix (make-parameter 10))
          > (radix)
          10
          > (radix 2)
          > (radix)
          2
          > (define prompt
              (make-parameter
                123
                (lambda (x)
                  (if (string? x)
                      x
                      (object->string x)))))
          > (prompt)
          "123"
          > (prompt "$")
          > (prompt)
          "$"
          > (define p
              (make-parameter
                100
                (lambda (val) ;; set filter
                  (pp (list val: val))
                  (list 0 val))
                (lambda (state) ;; get filter
                  (pp (list state: state))
                  (set-car! state (+ 1 (car state)))
                  (+ (car state) (cadr state)))))
          (val: 100)
          > (p)
          (state: (0 100))
          101
          > (p)
          (state: (1 100))
          102
          > (p)
          (state: (2 100))
          103
          > (p 555)
          (val: 555)
          > (p)
          (state: (0 555))
          556
          > (p)
          (state: (1 555))
          557
          > (define write-shared
              (make-parameter
                #f
                (lambda (x)
                  (if (boolean? x)
                      x
                      (error "only booleans are accepted by write-shared")))))
          > (write-shared 123)
          *** ERROR IN ##make-parameter -- only booleans are accepted by write-shared

 -- special form: parameterize ((procedure value)...) body

     The 'parameterize' form, evaluates all procedure and value
     expressions in an unspecified order.  All the procedure expressions
     must evaluate to procedures, either parameter objects or procedures
     accepting zero and one argument.  Then, for each procedure p and in
     an unspecified order:

        * If p is a parameter object a new cell is created, initialized,
          and bound to the parameter object in the local dynamic
          environment.  The value contained in the cell is the result of
          applying the parameter object's "set" conversion procedure to
          value.  The resulting dynamic environment is then used for
          processing the remaining bindings (or the evaluation of body
          if there are no other bindings).

        * Otherwise p will be used according to the following protocol:
          we say that the call '(p)' "gets p's value" and that the call
          '(p x)' "sets p's value to x".  First, the 'parameterize' form
          gets p's value and saves it in a local variable.  It then sets
          p's value to value.  It then processes the remaining bindings
          (or evaluates body if there are no other bindings).  Then it
          sets p's value to the saved value.  These steps are performed
          in a 'dynamic-wind' so that it is possible to use
          continuations to jump into and out of the body (i.e.  the
          'dynamic-wind''s before thunk sets p's value to value and the
          after thunk sets p's value to the saved value).

     The result(s) of the 'parameterize' form are the result(s) of the
     body.

     Note that using procedures instead of parameter objects may lead to
     unexpected results in multithreaded programs because the before and
     after thunks of the 'dynamic-wind' are not called when control
     switches between threads.

     For example:

          > (define radix (make-parameter 2))
          > (define prompt
              (make-parameter
                123
                (lambda (x)
                  (if (string? x)
                      x
                      (object->string x)))))
          > (radix)
          2
          > (parameterize ((radix 16)) (radix))
          16
          > (radix)
          2
          > (define (f n) (number->string n (radix)))
          > (f 10)
          "1010"
          > (parameterize ((radix 8)) (f 10))
          "12"
          > (parameterize ((radix 8) (prompt (f 10))) (prompt))
          "1010"
          > (define p
              (let ((x 1))
                (lambda args
                  (if (null? args) x (set! x (car args))))))
          > (let* ((a (p))
                   (b (parameterize ((p 2)) (list (p))))
                   (c (p)))
              (list a b c))
          (1 (2) 1)


File: gambit.info,  Node: Exceptions,  Next: Host environment,  Prev: Dynamic environment,  Up: Top

12 Exceptions
*************

* Menu:

* Exception-handling::                                      Exception-handling
* Exception objects related to memory management::          Exception objects related to memory management
* Exception objects related to the host environment::       Exception objects related to the host environment
* Exception objects related to threads::                    Exception objects related to threads
* Exception objects related to C-interface::                Exception objects related to C-interface
* Exception objects related to the reader::                 Exception objects related to the reader
* Exception objects related to evaluation and compilation:: Exception objects related to evaluation and compilation
* Exception objects related to type checking::              Exception objects related to type checking
* Exception objects related to procedure call::             Exception objects related to procedure call
* Other exception objects::                                 Other exception objects


File: gambit.info,  Node: Exception-handling,  Next: Exception objects related to memory management,  Prev: Exceptions,  Up: Exceptions

12.1 Exception-handling
=======================

Gambit's exception-handling model is inspired from the withdrawn
"Exception Handling SRFI" (SRFI 12), the "Multithreading support SRFI"
(SRFI 18), and the "Exception Handling for Programs SRFI" (SRFI 34).
The two fundamental operations are the dynamic binding of an exception
handler (i.e.  the procedure 'with-exception-handler') and the
invocation of the exception handler (i.e.  the procedure 'raise').

   All predefined procedures which check for errors (including type
errors, memory allocation errors, host operating-system errors, etc)
report these errors using the exception-handling system (i.e.  they
"raise" an exception that can be handled in a user-defined exception
handler).  When an exception is raised and the exception is not handled
by a user-defined exception handler, the predefined exception handler
will display an error message (if the primordial thread raised the
exception) or the thread will silently terminate with no error message
(if it is not the primordial thread that raised the exception).  This
default behavior can be changed through the '-:debug=...' runtime option
(*note Runtime options::).

   Predefined procedures normally raise exceptions by performing a
tail-call to the exception handler (the exceptions are "complex"
procedures such as 'eval', 'compile-file', 'read', 'write', etc).  This
means that the continuation of the exception handler and of the REPL
that may be started due to this is normally the continuation of the
predefined procedure that raised the exception.  By exiting the REPL
with the ',(c EXPRESSION)' command it is thus possible to resume the
program as though the call to the predefined procedure returned the
value of EXPRESSION.  For example:

     > (define (f x) (+ (car x) 1))
     > (f 2) ; typo... we meant to say (f '(2))
     *** ERROR IN f, (console)@1.18 -- (Argument 1) PAIR expected
     (car 2)
     1> ,(c 2)
     3

 -- procedure: current-exception-handler [NEW-EXCEPTION-HANDLER]

     The parameter object 'current-exception-handler' is bound to the
     current exception-handler.  Calling this procedure with no argument
     returns the current exception-handler and calling this procedure
     with one argument sets the current exception-handler to
     NEW-EXCEPTION-HANDLER.

     For example:

          > (current-exception-handler)
          #<procedure #2 primordial-exception-handler>
          > (current-exception-handler (lambda (exc) (pp exc) 999))
          > (/ 1 0)
          #<divide-by-zero-exception #3>
          999

 -- procedure: with-exception-handler HANDLER THUNK

     Returns the result(s) of calling THUNK with no arguments.  The
     HANDLER, which must be a procedure, is installed as the current
     exception-handler in the dynamic environment in effect during the
     call to THUNK.  Note that the dynamic environment in effect during
     the call to HANDLER has HANDLER as the exception-handler.
     Consequently, an exception raised during the call to HANDLER may
     lead to an infinite loop.

     For example:

          > (with-exception-handler
              (lambda (e) (write e) 5)
              (lambda () (+ 1 (* 2 3) 4)))
          11
          > (with-exception-handler
              (lambda (e) (write e) 5)
              (lambda () (+ 1 (* 'foo 3) 4)))
          #<type-exception #2>10
          > (with-exception-handler
              (lambda (e) (write e 9))
              (lambda () (+ 1 (* 'foo 3) 4)))
          INFINITE LOOP

 -- procedure: with-exception-catcher HANDLER THUNK

     Returns the result(s) of calling THUNK with no arguments.  A new
     exception-handler is installed as the current exception-handler in
     the dynamic environment in effect during the call to THUNK.  This
     new exception-handler will call the HANDLER, which must be a
     procedure, with the exception object as an argument and with the
     same continuation as the call to 'with-exception-catcher'.  This
     implies that the dynamic environment in effect during the call to
     HANDLER is the same as the one in effect at the call to
     'with-exception-catcher'.  Consequently, an exception raised during
     the call to HANDLER will not lead to an infinite loop.

     For example:

          > (with-exception-catcher
              (lambda (e) (write e) 5)
              (lambda () (+ 1 (* 2 3) 4)))
          11
          > (with-exception-catcher
              (lambda (e) (write e) 5)
              (lambda () (+ 1 (* 'foo 3) 4)))
          #<type-exception #2>5
          > (with-exception-catcher
              (lambda (e) (write e 9))
              (lambda () (+ 1 (* 'foo 3) 4)))
          *** ERROR IN (console)@7.1 -- (Argument 2) OUTPUT PORT expected
          (write '#<type-exception #3> 9)

 -- procedure: raise OBJ

     This procedure tail-calls the current exception-handler with OBJ as
     the sole argument.  If the exception-handler returns, the
     continuation of the call to 'raise' is invoked.

     For example:

          > (with-exception-handler
              (lambda (exc)
                (pp exc)
                100)
              (lambda ()
                (+ 1 (raise "hello"))))
          "hello"
          101

 -- procedure: abort OBJ
 -- procedure: noncontinuable-exception? OBJ
 -- procedure: noncontinuable-exception-reason EXC

     The procedure 'abort' calls the current exception-handler with OBJ
     as the sole argument.  If the exception-handler returns, the
     procedure 'abort' will be tail-called with a
     noncontinuable-exception object, whose reason field is OBJ, as sole
     argument.

     Noncontinuable-exception objects are raised by the 'abort'
     procedure when the exception-handler returns.  The parameter EXC
     must be a noncontinuable-exception object.

     The procedure 'noncontinuable-exception?' returns '#t' when OBJ is
     a noncontinuable-exception object and '#f' otherwise.

     The procedure 'noncontinuable-exception-reason' returns the
     argument of the call to 'abort' that raised EXC.

     For example:

          > (call-with-current-continuation
              (lambda (k)
                (with-exception-handler
                  (lambda (exc)
                    (pp exc)
                    (if (noncontinuable-exception? exc)
                        (k (list (noncontinuable-exception-reason exc)))
                        100))
                  (lambda ()
                    (+ 1 (abort "hello"))))))
          "hello"
          #<noncontinuable-exception #2>
          ("hello")


File: gambit.info,  Node: Exception objects related to memory management,  Next: Exception objects related to the host environment,  Prev: Exception-handling,  Up: Exceptions

12.2 Exception objects related to memory management
===================================================

 -- procedure: heap-overflow-exception? OBJ

     Heap-overflow-exception objects are raised when the allocation of
     an object would cause the heap to use more memory space than is
     available.

     The procedure 'heap-overflow-exception?' returns '#t' when OBJ is a
     heap-overflow-exception object and '#f' otherwise.

     For example:

          > (define (handler exc)
              (if (heap-overflow-exception? exc)
                  exc
                  'not-heap-overflow-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (define (f x) (f (cons 1 x)))
                (f '())))
          #<heap-overflow-exception #2>

 -- procedure: stack-overflow-exception? OBJ

     Stack-overflow-exception objects are raised when the allocation of
     a continuation frame would cause the heap to use more memory space
     than is available.

     The procedure 'stack-overflow-exception?' returns '#t' when OBJ is
     a stack-overflow-exception object and '#f' otherwise.

     For example:

          > (define (handler exc)
              (if (stack-overflow-exception? exc)
                  exc
                  'not-stack-overflow-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (define (f) (+ 1 (f)))
                (f)))
          #<stack-overflow-exception #2>


File: gambit.info,  Node: Exception objects related to the host environment,  Next: Exception objects related to threads,  Prev: Exception objects related to memory management,  Up: Exceptions

12.3 Exception objects related to the host environment
======================================================

 -- procedure: os-exception? OBJ
 -- procedure: os-exception-procedure EXC
 -- procedure: os-exception-arguments EXC
 -- procedure: os-exception-code EXC
 -- procedure: os-exception-message EXC

     Os-exception objects are raised by procedures which access the host
     operating-system's services when the requested operation fails.
     The parameter EXC must be a os-exception object.

     The procedure 'os-exception?' returns '#t' when OBJ is a
     os-exception object and '#f' otherwise.

     The procedure 'os-exception-procedure' returns the procedure that
     raised EXC.

     The procedure 'os-exception-arguments' returns the list of
     arguments of the procedure that raised EXC.

     The procedure 'os-exception-code' returns an exact integer error
     code that can be converted to a string by the 'err-code->string'
     procedure.  Note that the error code is operating-system dependent.

     The procedure 'os-exception-message' returns '#f' or a string
     giving details of the exception in a human-readable form.

     For example:

          > (define (handler exc)
              (if (os-exception? exc)
                  (list (os-exception-procedure exc)
                        (os-exception-arguments exc)
                        (err-code->string (os-exception-code exc))
                        (os-exception-message exc))
                  'not-os-exception))
          > (with-exception-catcher
              handler
              (lambda () (host-info "x.y.z")))
          (#<procedure #2 host-info> ("x.y.z") "Unknown host" #f)

 -- procedure: no-such-file-or-directory-exception? OBJ
 -- procedure: no-such-file-or-directory-exception-procedure EXC
 -- procedure: no-such-file-or-directory-exception-arguments EXC

     No-such-file-or-directory-exception objects are raised by
     procedures which access the filesystem (such as 'open-input-file'
     and 'directory-files') when the path specified can't be found on
     the filesystem.  The parameter EXC must be a
     no-such-file-or-directory-exception object.

     The procedure 'no-such-file-or-directory-exception?' returns '#t'
     when OBJ is a no-such-file-or-directory-exception object and '#f'
     otherwise.

     The procedure 'no-such-file-or-directory-exception-procedure'
     returns the procedure that raised EXC.

     The procedure 'no-such-file-or-directory-exception-arguments'
     returns the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (no-such-file-or-directory-exception? exc)
                  (list (no-such-file-or-directory-exception-procedure exc)
                        (no-such-file-or-directory-exception-arguments exc))
                  'not-no-such-file-or-directory-exception))
          > (with-exception-catcher
              handler
              (lambda () (with-input-from-file "nofile" read)))
          (#<procedure #2 with-input-from-file> ("nofile" #<procedure #3 read>))

 -- procedure: file-exists-exception? OBJ
 -- procedure: file-exists-exception-procedure EXC
 -- procedure: file-exists-exception-arguments EXC

     File-exists-exception objects are raised by procedures which access
     the filesystem (such as 'open-output-file' and 'create-directory')
     when the path specified is an existing file on the filesystem.  The
     parameter EXC must be a file-exists-exception object.

     The procedure 'file-exists-exception?' returns '#t' when OBJ is a
     file-exists-exception object and '#f' otherwise.

     The procedure 'file-exists-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'file-exists-exception-arguments' returns the list of
     arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (file-exists-exception? exc)
                  (list (file-exists-exception-procedure exc)
                        (file-exists-exception-arguments exc))
                  'not-file-exists-exception))
          > (with-exception-catcher
              handler
              (lambda () (with-output-to-file '(path: "foo" create: #t) newline)))
          > (with-exception-catcher
              handler
              (lambda () (with-output-to-file '(path: "foo" create: #t) newline)))
          (#<procedure #2 with-output-to-file>
           ((path: "foo" create: #t) #<procedure #3 newline>))

 -- procedure: permission-denied-exception? OBJ
 -- procedure: permission-denied-exception-procedure EXC
 -- procedure: permission-denied-exception-arguments EXC

     Permission-denied-exception objects are raised by procedures which
     access the filesystem (such as 'open-file' and 'open-directory')
     when the access to the specified path is not allowed, or search
     permission is denied for a directory in the path prefix, or write
     access to the parent directory isn't allowed for a file that
     doesn't exist yet on the filesystem.  The parameter EXC must be a
     permission-denied-exception object.

     The procedure 'permission-denied-exception?' returns '#t' when OBJ
     is a permission-denied-exception object and '#f' otherwise.

     The procedure 'permission-denied-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'permission-denied-exception-arguments' returns the
     list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (permission-denied-exception? exc)
                  (list (permission-denied-exception-procedure exc)
                        (permission-denied-exception-arguments exc))
                  'not-permission-denied-exception))
          > (with-exception-catcher
              handler
              (lambda () (with-input-from-file "empty" read)))
          #!eof
          > (with-exception-catcher
              handler
              (lambda () (with-input-from-file "noperm" read)))
          (#<procedure #2 with-input-from-file> ("noperm" #<procedure #3 read>))

 -- procedure: unbound-os-environment-variable-exception? OBJ
 -- procedure: unbound-os-environment-variable-exception-procedure EXC
 -- procedure: unbound-os-environment-variable-exception-arguments EXC

     Unbound-os-environment-variable-exception objects are raised when
     an unbound operating-system environment variable is accessed by the
     procedures 'getenv' and 'setenv'.  The parameter EXC must be an
     unbound-os-environment-variable-exception object.

     The procedure 'unbound-os-environment-variable-exception?' returns
     '#t' when OBJ is an unbound-os-environment-variable-exception
     object and '#f' otherwise.

     The procedure 'unbound-os-environment-variable-exception-procedure'
     returns the procedure that raised EXC.

     The procedure 'unbound-os-environment-variable-exception-arguments'
     returns the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (unbound-os-environment-variable-exception? exc)
                  (list (unbound-os-environment-variable-exception-procedure exc)
                        (unbound-os-environment-variable-exception-arguments exc))
                  'not-unbound-os-environment-variable-exception))
          > (with-exception-catcher
              handler
              (lambda () (getenv "DOES_NOT_EXIST")))
          (#<procedure #2 getenv> ("DOES_NOT_EXIST"))


File: gambit.info,  Node: Exception objects related to threads,  Next: Exception objects related to C-interface,  Prev: Exception objects related to the host environment,  Up: Exceptions

12.4 Exception objects related to threads
=========================================

 -- procedure: scheduler-exception? OBJ
 -- procedure: scheduler-exception-reason EXC

     Scheduler-exception objects are raised by the scheduler when some
     operation requested from the host operating system failed (e.g.
     checking the status of the devices in order to wake up threads
     waiting to perform I/O on these devices).  The parameter EXC must
     be a scheduler-exception object.

     The procedure 'scheduler-exception?' returns '#t' when OBJ is a
     scheduler-exception object and '#f' otherwise.

     The procedure 'scheduler-exception-reason' returns the os-exception
     object that describes the failure detected by the scheduler.

 -- procedure: deadlock-exception? OBJ

     Deadlock-exception objects are raised when the scheduler discovers
     that all threads are blocked and can make no further progress.  In
     that case the scheduler unblocks the primordial-thread and forces
     it to raise a deadlock-exception object.

     The procedure 'deadlock-exception?' returns '#t' when OBJ is a
     deadlock-exception object and '#f' otherwise.

     For example:

          > (define (handler exc)
              (if (deadlock-exception? exc)
                  exc
                  'not-deadlock-exception))
          > (with-exception-catcher
              handler
              (lambda () (read (open-vector))))
          #<deadlock-exception #2>

 -- procedure: abandoned-mutex-exception? OBJ

     Abandoned-mutex-exception objects are raised when the current
     thread locks a mutex that was owned by a thread which terminated
     (see 'mutex-lock!').

     The procedure 'abandoned-mutex-exception?' returns '#t' when OBJ is
     a abandoned-mutex-exception object and '#f' otherwise.

     For example:

          > (define (handler exc)
              (if (abandoned-mutex-exception? exc)
                  exc
                  'not-abandoned-mutex-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (let ((m (make-mutex)))
                  (thread-join!
                    (thread-start!
                      (make-thread
                        (lambda () (mutex-lock! m)))))
                  (mutex-lock! m))))
          #<abandoned-mutex-exception #2>

 -- procedure: join-timeout-exception? OBJ
 -- procedure: join-timeout-exception-procedure EXC
 -- procedure: join-timeout-exception-arguments EXC

     Join-timeout-exception objects are raised when a call to the
     'thread-join!' procedure reaches its timeout before the target
     thread terminates and a timeout-value parameter is not specified.
     The parameter EXC must be a join-timeout-exception object.

     The procedure 'join-timeout-exception?' returns '#t' when OBJ is a
     join-timeout-exception object and '#f' otherwise.

     The procedure 'join-timeout-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'join-timeout-exception-arguments' returns the list
     of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (join-timeout-exception? exc)
                  (list (join-timeout-exception-procedure exc)
                        (join-timeout-exception-arguments exc))
                  'not-join-timeout-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (thread-join!
                  (thread-start!
                    (make-thread
                      (lambda () (thread-sleep! 10))))
                  5)))
          (#<procedure #2 thread-join!> (#<thread #3> 5))

 -- procedure: started-thread-exception? OBJ
 -- procedure: started-thread-exception-procedure EXC
 -- procedure: started-thread-exception-arguments EXC

     Started-thread-exception objects are raised when the target thread
     of a call to the procedure 'thread-start!' is already started.  The
     parameter EXC must be a started-thread-exception object.

     The procedure 'started-thread-exception?' returns '#t' when OBJ is
     a started-thread-exception object and '#f' otherwise.

     The procedure 'started-thread-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'started-thread-exception-arguments' returns the list
     of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (started-thread-exception? exc)
                  (list (started-thread-exception-procedure exc)
                        (started-thread-exception-arguments exc))
                  'not-started-thread-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (let ((t (make-thread (lambda () (expt 2 1000)))))
                  (thread-start! t)
                  (thread-start! t))))
          (#<procedure #2 thread-start!> (#<thread #3>))

 -- procedure: terminated-thread-exception? OBJ
 -- procedure: terminated-thread-exception-procedure EXC
 -- procedure: terminated-thread-exception-arguments EXC

     Terminated-thread-exception objects are raised when the
     'thread-join!' procedure is called and the target thread has
     terminated as a result of a call to the 'thread-terminate!'
     procedure.  The parameter EXC must be a terminated-thread-exception
     object.

     The procedure 'terminated-thread-exception?' returns '#t' when OBJ
     is a terminated-thread-exception object and '#f' otherwise.

     The procedure 'terminated-thread-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'terminated-thread-exception-arguments' returns the
     list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (terminated-thread-exception? exc)
                  (list (terminated-thread-exception-procedure exc)
                        (terminated-thread-exception-arguments exc))
                  'not-terminated-thread-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (thread-join!
                  (thread-start!
                    (make-thread
                      (lambda () (thread-terminate! (current-thread))))))))
          (#<procedure #2 thread-join!> (#<thread #3>))

 -- procedure: uncaught-exception? OBJ
 -- procedure: uncaught-exception-procedure EXC
 -- procedure: uncaught-exception-arguments EXC
 -- procedure: uncaught-exception-reason EXC

     Uncaught-exception objects are raised when an object is raised in a
     thread and that thread does not handle it (i.e.  the thread
     terminated because it did not catch an exception it raised).  The
     parameter EXC must be an uncaught-exception object.

     The procedure 'uncaught-exception?' returns '#t' when OBJ is an
     uncaught-exception object and '#f' otherwise.

     The procedure 'uncaught-exception-procedure' returns the procedure
     that raised EXC.

     The procedure 'uncaught-exception-arguments' returns the list of
     arguments of the procedure that raised EXC.

     The procedure 'uncaught-exception-reason' returns the object that
     was raised by the thread and not handled by that thread.

     For example:

          > (define (handler exc)
              (if (uncaught-exception? exc)
                  (list (uncaught-exception-procedure exc)
                        (uncaught-exception-arguments exc)
                        (uncaught-exception-reason exc))
                  'not-uncaught-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (thread-join!
                  (thread-start!
                    (make-thread
                      (lambda () (open-input-file "data" 99)))))))
          (#<procedure #2 thread-join!>
           (#<thread #3>)
           #<wrong-number-of-arguments-exception #4>)


File: gambit.info,  Node: Exception objects related to C-interface,  Next: Exception objects related to the reader,  Prev: Exception objects related to threads,  Up: Exceptions

12.5 Exception objects related to C-interface
=============================================

 -- procedure: cfun-conversion-exception? OBJ
 -- procedure: cfun-conversion-exception-procedure EXC
 -- procedure: cfun-conversion-exception-arguments EXC
 -- procedure: cfun-conversion-exception-code EXC
 -- procedure: cfun-conversion-exception-message EXC

     Cfun-conversion-exception objects are raised by the C-interface
     when converting between the Scheme representation and the C
     representation of a value during a call from Scheme to C. The
     parameter EXC must be a cfun-conversion-exception object.

     The procedure 'cfun-conversion-exception?' returns '#t' when OBJ is
     a cfun-conversion-exception object and '#f' otherwise.

     The procedure 'cfun-conversion-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'cfun-conversion-exception-arguments' returns the
     list of arguments of the procedure that raised EXC.

     The procedure 'cfun-conversion-exception-code' returns an exact
     integer error code that can be converted to a string by the
     'err-code->string' procedure.

     The procedure 'cfun-conversion-exception-message' returns '#f' or a
     string giving details of the exception in a human-readable form.

     For example:

          $ cat test1.scm
          (define weird
            (c-lambda (char-string) nonnull-char-string
              "___return(___arg1);"))
          $ gsc test1.scm
          $ gsi
          Gambit v4.9.4

          > (load "test1")
          "/Users/feeley/gambit/doc/test1.o1"
          > (weird "hello")
          "hello"
          > (define (handler exc)
              (if (cfun-conversion-exception? exc)
                  (list (cfun-conversion-exception-procedure exc)
                        (cfun-conversion-exception-arguments exc)
                        (err-code->string (cfun-conversion-exception-code exc))
                        (cfun-conversion-exception-message exc))
                  'not-cfun-conversion-exception))
          > (with-exception-catcher
              handler
              (lambda () (weird 'not-a-string)))
          (#<procedure #2 weird>
           (not-a-string)
           "(Argument 1) Can't convert to C char-string"
           #f)
          > (with-exception-catcher
              handler
              (lambda () (weird #f)))
          (#<procedure #2 weird>
           (#f)
           "Can't convert result from C nonnull-char-string"
           #f)

 -- procedure: sfun-conversion-exception? OBJ
 -- procedure: sfun-conversion-exception-procedure EXC
 -- procedure: sfun-conversion-exception-arguments EXC
 -- procedure: sfun-conversion-exception-code EXC
 -- procedure: sfun-conversion-exception-message EXC

     Sfun-conversion-exception objects are raised by the C-interface
     when converting between the Scheme representation and the C
     representation of a value during a call from C to Scheme.  The
     parameter EXC must be a sfun-conversion-exception object.

     The procedure 'sfun-conversion-exception?' returns '#t' when OBJ is
     a sfun-conversion-exception object and '#f' otherwise.

     The procedure 'sfun-conversion-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'sfun-conversion-exception-arguments' returns the
     list of arguments of the procedure that raised EXC.

     The procedure 'sfun-conversion-exception-code' returns an exact
     integer error code that can be converted to a string by the
     'err-code->string' procedure.

     The procedure 'sfun-conversion-exception-message' returns '#f' or a
     string giving details of the exception in a human-readable form.

     For example:

          $ cat test2.scm
          (c-define (f str) (nonnull-char-string) int "f" ""
            (string->number str))
          (define t1 (c-lambda () int "___return(f (\"123\"));"))
          (define t2 (c-lambda () int "___return(f (0));"))
          (define t3 (c-lambda () int "___return(f (\"1.5\"));"))
          $ gsc test2.scm
          $ gsi
          Gambit v4.9.4

          > (load "test2")
          "/u/feeley/test2.o1"
          > (t1)
          123
          > (define (handler exc)
              (if (sfun-conversion-exception? exc)
                  (list (sfun-conversion-exception-procedure exc)
                        (sfun-conversion-exception-arguments exc)
                        (err-code->string (sfun-conversion-exception-code exc))
                        (sfun-conversion-exception-message exc))
                  'not-sfun-conversion-exception))
          > (with-exception-catcher handler t2)
          (#<procedure #2 f>
           ()
           "(Argument 1) Can't convert from C nonnull-char-string"
           #f)
          > (with-exception-catcher handler t3)
          (#<procedure #2 f> () "Can't convert result to C int" #f)

 -- procedure: multiple-c-return-exception? OBJ

     Multiple-c-return-exception objects are raised by the C-interface
     when a C to Scheme procedure call returns and that call's stack
     frame is no longer on the C stack because the call has already
     returned, or has been removed from the C stack by a 'longjump'.

     The procedure 'multiple-c-return-exception?' returns '#t' when OBJ
     is a multiple-c-return-exception object and '#f' otherwise.

     For example:

          $ cat test3.scm
          (c-define (f str) (char-string) scheme-object "f" ""
            (pp (list 'entry 'str= str))
            (let ((k (call-with-current-continuation (lambda (k) k))))
              (pp (list 'exit 'k= k))
              k))
          (define scheme-to-c-to-scheme-and-back
            (c-lambda (char-string) scheme-object
              "___return(f (___arg1));"))
          $ gsc test3.scm
          $ gsi
          Gambit v4.9.4

          > (load "test3")
          "/Users/feeley/gambit/doc/test3.o1"
          > (define (handler exc)
              (if (multiple-c-return-exception? exc)
                  exc
                  'not-multiple-c-return-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (let ((c (scheme-to-c-to-scheme-and-back "hello")))
                  (pp c)
                  (c 999))))
          (entry str= "hello")
          (exit k= #<procedure #2>)
          #<procedure #2>
          (exit k= 999)
          #<multiple-c-return-exception #3>

 -- procedure: wrong-processor-c-return-exception? OBJ

     Wrong-processor-c-return-exception objects are raised by the
     runtime system when a C to Scheme procedure call returns and that
     call's stack frame was created by another processor.

     The procedure 'wrong-processor-c-return-exception?' returns '#t'
     when OBJ is a wrong-processor-c-return-exception object and '#f'
     otherwise.


File: gambit.info,  Node: Exception objects related to the reader,  Next: Exception objects related to evaluation and compilation,  Prev: Exception objects related to C-interface,  Up: Exceptions

12.6 Exception objects related to the reader
============================================

 -- procedure: datum-parsing-exception? OBJ
 -- procedure: datum-parsing-exception-kind EXC
 -- procedure: datum-parsing-exception-parameters EXC
 -- procedure: datum-parsing-exception-readenv EXC

     Datum-parsing-exception objects are raised by the reader (i.e.  the
     'read' procedure) when the input does not conform to the grammar
     for datum.  The parameter EXC must be a datum-parsing-exception
     object.

     The procedure 'datum-parsing-exception?' returns '#t' when OBJ is a
     datum-parsing-exception object and '#f' otherwise.

     The procedure 'datum-parsing-exception-kind' returns a symbol
     denoting the kind of parsing error that was encountered by the
     reader when it raised EXC.  Here is a table of the possible return
     values:

     'datum-or-eof-expected'              Datum or EOF expected
     'datum-expected'                     Datum expected
     'improperly-placed-dot'              Improperly placed dot
     'incomplete-form-eof-reached'        Incomplete form, EOF reached
     'incomplete-form'                    Incomplete form
     'character-out-of-range'             Character out of range
     'invalid-character-name'             Invalid '#\' name
     'illegal-character'                  Illegal character
     's8-expected'                        Signed 8 bit exact integer
                                          expected
     'u8-expected'                        Unsigned 8 bit exact integer
                                          expected
     's16-expected'                       Signed 16 bit exact integer
                                          expected
     'u16-expected'                       Unsigned 16 bit exact integer
                                          expected
     's32-expected'                       Signed 32 bit exact integer
                                          expected
     'u32-expected'                       Unsigned 32 bit exact integer
                                          expected
     's64-expected'                       Signed 64 bit exact integer
                                          expected
     'u64-expected'                       Unsigned 64 bit exact integer
                                          expected
     'inexact-real-expected'              Inexact real expected
     'invalid-hex-escape'                 Invalid hexadecimal escape
     'invalid-escaped-character'          Invalid escaped character
     'open-paren-expected'                '(' expected
     'invalid-token'                      Invalid token
     'invalid-sharp-bang-name'            Invalid '#!'  name
     'duplicate-label-definition'         Duplicate definition for label
     'missing-label-definition'           Missing definition for label
     'illegal-label-definition'           Illegal definition of label
     'invalid-infix-syntax-character'     Invalid infix syntax character
     'invalid-infix-syntax-number'        Invalid infix syntax number
     'invalid-infix-syntax'               Invalid infix syntax
                                          

     The procedure 'datum-parsing-exception-parameters' returns a list
     of the parameters associated with the parsing error that was
     encountered by the reader when it raised EXC.

     For example:

          > (define (handler exc)
              (if (datum-parsing-exception? exc)
                  (list (datum-parsing-exception-kind exc)
                        (datum-parsing-exception-parameters exc))
                  'not-datum-parsing-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (with-input-from-string "(s #\\pace)" read)))
          (invalid-character-name ("pace"))


File: gambit.info,  Node: Exception objects related to evaluation and compilation,  Next: Exception objects related to type checking,  Prev: Exception objects related to the reader,  Up: Exceptions

12.7 Exception objects related to evaluation and compilation
============================================================

 -- procedure: expression-parsing-exception? OBJ
 -- procedure: expression-parsing-exception-kind EXC
 -- procedure: expression-parsing-exception-parameters EXC
 -- procedure: expression-parsing-exception-source EXC

     Expression-parsing-exception objects are raised by the evaluator
     and compiler (i.e.  the procedures 'eval', 'compile-file', etc)
     when the input does not conform to the grammar for expression.  The
     parameter EXC must be a expression-parsing-exception object.

     The procedure 'expression-parsing-exception?' returns '#t' when OBJ
     is a expression-parsing-exception object and '#f' otherwise.

     The procedure 'expression-parsing-exception-kind' returns a symbol
     denoting the kind of parsing error that was encountered by the
     evaluator or compiler when it raised EXC.  Here is a table of the
     possible return values:

     'id-expected'                        Identifier expected
     'ill-formed-namespace'               Ill-formed namespace
     'ill-formed-namespace-prefix'        Ill-formed namespace prefix
     'namespace-prefix-must-be-string'    Namespace prefix must be a string
     'macro-used-as-variable'             Macro name can't be used as a
                                          variable
     'variable-is-immutable'              Variable is immutable
     'ill-formed-macro-transformer'       Macro transformer must be a lambda
                                          expression
     'reserved-used-as-variable'          Reserved identifier can't be used
                                          as a variable
     'ill-formed-special-form'            Ill-formed special form
     'cannot-open-file'                   Can't open file
     'filename-expected'                  Filename expected
     'ill-placed-define'                  Ill-placed 'define'
     'ill-placed-**include'               Ill-placed '##include'
     'ill-placed-**define-macro'          Ill-placed '##define-macro'
     'ill-placed-**declare'               Ill-placed '##declare'
     'ill-placed-**namespace'             Ill-placed '##namespace'
     'ill-formed-expression'              Ill-formed expression
     'unsupported-special-form'           Interpreter does not support
     'ill-placed-unquote'                 Ill-placed 'unquote'
     'ill-placed-unquote-splicing'        Ill-placed 'unquote-splicing'
     'parameter-must-be-id'               Parameter must be an identifier
     'parameter-must-be-id-or-default'    Parameter must be an identifier or
                                          default binding
     'duplicate-parameter'                Duplicate parameter in parameter
                                          list
     'ill-placed-dotted-rest-parameter'   Ill-placed dotted rest parameter
     'parameter-expected-after-rest'      #!rest must be followed by a
                                          parameter
     'ill-formed-default'                 Ill-formed default binding
     'ill-placed-optional'                Ill-placed #!optional
     'ill-placed-rest'                    Ill-placed #!rest
     'ill-placed-key'                     Ill-placed #!key
     'key-expected-after-rest'            #!key expected after rest
                                          parameter
     'ill-placed-default'                 Ill-placed default binding
     'duplicate-variable-definition'      Duplicate definition of a variable
     'empty-body'                         Body must contain at least one
                                          expression
     'variable-must-be-id'                Defined variable must be an
                                          identifier
     'else-clause-not-last'               Else clause must be last
     'ill-formed-selector-list'           Ill-formed selector list
     'duplicate-variable-binding'         Duplicate variable in bindings
     'ill-formed-binding-list'            Ill-formed binding list
     'ill-formed-call'                    Ill-formed procedure call
     'ill-formed-cond-expand'             Ill-formed 'cond-expand'
     'unfulfilled-cond-expand'            Unfulfilled 'cond-expand'
                                          

     The procedure 'expression-parsing-exception-parameters' returns a
     list of the parameters associated with the parsing error that was
     encountered by the evaluator or compiler when it raised EXC.

     For example:

          > (define (handler exc)
              (if (expression-parsing-exception? exc)
                  (list (expression-parsing-exception-kind exc)
                        (expression-parsing-exception-parameters exc))
                  'not-expression-parsing-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (eval '(+ do 1))))
          (reserved-used-as-variable (do))

 -- procedure: unbound-global-exception? OBJ
 -- procedure: unbound-global-exception-variable EXC
 -- procedure: unbound-global-exception-code EXC
 -- procedure: unbound-global-exception-rte EXC

     Unbound-global-exception objects are raised when an unbound global
     variable is accessed.  The parameter EXC must be an
     unbound-global-exception object.

     The procedure 'unbound-global-exception?' returns '#t' when OBJ is
     an unbound-global-exception object and '#f' otherwise.

     The procedure 'unbound-global-exception-variable' returns a symbol
     identifying the unbound global variable.

     For example:

          > (define (handler exc)
              (if (unbound-global-exception? exc)
                  (list 'variable= (unbound-global-exception-variable exc))
                  'not-unbound-global-exception))
          > (with-exception-catcher
              handler
              (lambda () foo))
          (variable= foo)

 -- procedure: not-in-compilation-context-exception? OBJ
 -- procedure: not-in-compilation-context-exception-procedure EXC
 -- procedure: not-in-compilation-context-exception-arguments EXC

     Not-in-compilation-context-exception objects are raised by the
     procedure 'compilation-target' when it is executed outside of a
     compilation context.  The parameter EXC must be a
     not-in-compilation-context-exception object.

     The procedure 'not-in-compilation-context-exception?' returns '#t'
     when OBJ is a not-in-compilation-context-exception object and '#f'
     otherwise.

     The procedure 'not-in-compilation-context-exception-procedure'
     returns the procedure that raised EXC.

     The procedure 'not-in-compilation-context-exception-arguments'
     returns the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (not-in-compilation-context-exception? exc)
                  (list (not-in-compilation-context-exception-procedure exc)
                        (not-in-compilation-context-exception-arguments exc))
                  'not-not-in-compilation-context-exception))
          > (with-exception-catcher
              handler
              (lambda () (compilation-target)))
          (#<procedure #2 compilation-target> ())


File: gambit.info,  Node: Exception objects related to type checking,  Next: Exception objects related to procedure call,  Prev: Exception objects related to evaluation and compilation,  Up: Exceptions

12.8 Exception objects related to type checking
===============================================

 -- procedure: type-exception? OBJ
 -- procedure: type-exception-procedure EXC
 -- procedure: type-exception-arguments EXC
 -- procedure: type-exception-arg-id EXC
 -- procedure: type-exception-type-id EXC

     Type-exception objects are raised when a primitive procedure is
     called with an argument of incorrect type (i.e.  when a run time
     type-check fails).  The parameter EXC must be a type-exception
     object.

     The procedure 'type-exception?' returns '#t' when OBJ is a
     type-exception object and '#f' otherwise.

     The procedure 'type-exception-procedure' returns the procedure that
     raised EXC.

     The procedure 'type-exception-arguments' returns the list of
     arguments of the procedure that raised EXC.

     The procedure 'type-exception-arg-id' returns the identity of the
     argument whose type is incorrect, which can be an exact integer
     position (1 for the first argument) or a pair whose 'car' is the
     position and the 'cdr' is the parameter name as a symbol.

     The procedure 'type-exception-type-id' returns an identifier of the
     type expected.  The type-id can be a symbol, such as 'number' and
     'string-or-nonnegative-fixnum', or a record type descriptor.

     For example:

          > (define (handler exc)
              (if (type-exception? exc)
                  (list (type-exception-procedure exc)
                        (type-exception-arguments exc)
                        (type-exception-arg-id exc)
                        (type-exception-type-id exc))
                  'not-type-exception))
          > (with-exception-catcher
              handler
              (lambda () (vector-ref '#(a b c) 'foo)))
          (#<procedure #2 vector-ref> (#(a b c) foo) 2 exact-integer)
          > (with-exception-catcher
              handler
              (lambda () (time->seconds 'foo)))
          (#<procedure #3 time->seconds> (foo) 1 #<type #4 time>)

 -- procedure: range-exception? OBJ
 -- procedure: range-exception-procedure EXC
 -- procedure: range-exception-arguments EXC
 -- procedure: range-exception-arg-id EXC

     Range-exception objects are raised when a numeric parameter is not
     in the allowed range.  The parameter EXC must be a range-exception
     object.

     The procedure 'range-exception?' returns '#t' when OBJ is a
     range-exception object and '#f' otherwise.

     The procedure 'range-exception-procedure' returns the procedure
     that raised EXC.

     The procedure 'range-exception-arguments' returns the list of
     arguments of the procedure that raised EXC.

     The procedure 'range-exception-arg-id' returns the identity of the
     argument which is not in the allowed range, which can be an exact
     integer position (1 for the first argument) or a pair whose 'car'
     is the position and the 'cdr' is the parameter name as a symbol.

     For example:

          > (define (handler exc)
              (if (range-exception? exc)
                  (list (range-exception-procedure exc)
                        (range-exception-arguments exc)
                        (range-exception-arg-id exc))
                  'not-range-exception))
          > (with-exception-catcher
              handler
              (lambda () (string-ref "abcde" 10)))
          (#<procedure #2 string-ref> ("abcde" 10) 2)

 -- procedure: divide-by-zero-exception? OBJ
 -- procedure: divide-by-zero-exception-procedure EXC
 -- procedure: divide-by-zero-exception-arguments EXC

     Divide-by-zero-exception objects are raised when a division by zero
     is attempted.  The parameter EXC must be a divide-by-zero-exception
     object.

     The procedure 'divide-by-zero-exception?' returns '#t' when OBJ is
     a divide-by-zero-exception object and '#f' otherwise.

     The procedure 'divide-by-zero-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'divide-by-zero-exception-arguments' returns the list
     of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (divide-by-zero-exception? exc)
                  (list (divide-by-zero-exception-procedure exc)
                        (divide-by-zero-exception-arguments exc))
                  'not-divide-by-zero-exception))
          > (with-exception-catcher
              handler
              (lambda () (/ 5 0 7)))
          (#<procedure #2 /> (5 0 7))

 -- procedure: length-mismatch-exception? OBJ
 -- procedure: length-mismatch-exception-procedure EXC
 -- procedure: length-mismatch-exception-arguments EXC
 -- procedure: length-mismatch-exception-arg-id EXC

     Length-mismatch-exception objects are raised by some procedures
     when they are called with two or more list arguments and the lists
     are not of the same length.  The parameter EXC must be a
     length-mismatch-exception object.

     The procedure 'length-mismatch-exception?' returns '#t' when OBJ is
     an length-mismatch-exception object and '#f' otherwise.

     The procedure 'length-mismatch-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'length-mismatch-exception-arguments' returns the
     list of arguments of the procedure that raised EXC.

     The procedure 'length-mismatch-exception-arg-id' returns the
     identity of the argument whose length is the shortest, which can be
     an exact integer position (1 for the first argument) or a pair
     whose 'car' is the position and the 'cdr' is the parameter name as
     a symbol.


File: gambit.info,  Node: Exception objects related to procedure call,  Next: Other exception objects,  Prev: Exception objects related to type checking,  Up: Exceptions

12.9 Exception objects related to procedure call
================================================

 -- procedure: wrong-number-of-arguments-exception? OBJ
 -- procedure: wrong-number-of-arguments-exception-procedure EXC
 -- procedure: wrong-number-of-arguments-exception-arguments EXC

     Wrong-number-of-arguments-exception objects are raised when a
     procedure is called with the wrong number of arguments.  The
     parameter EXC must be a wrong-number-of-arguments-exception object.

     The procedure 'wrong-number-of-arguments-exception?' returns '#t'
     when OBJ is a wrong-number-of-arguments-exception object and '#f'
     otherwise.

     The procedure 'wrong-number-of-arguments-exception-procedure'
     returns the procedure that raised EXC.

     The procedure 'wrong-number-of-arguments-exception-arguments'
     returns the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (wrong-number-of-arguments-exception? exc)
                  (list (wrong-number-of-arguments-exception-procedure exc)
                        (wrong-number-of-arguments-exception-arguments exc))
                  'not-wrong-number-of-arguments-exception))
          > (with-exception-catcher
              handler
              (lambda () (open-input-file "data" 99)))
          (#<procedure #2 open-input-file> ("data" 99))

 -- procedure: number-of-arguments-limit-exception? OBJ
 -- procedure: number-of-arguments-limit-exception-procedure EXC
 -- procedure: number-of-arguments-limit-exception-arguments EXC

     Number-of-arguments-limit-exception objects are raised by the
     'apply' procedure when the procedure being called is passed more
     than 8192 arguments.  The parameter EXC must be a
     number-of-arguments-limit-exception object.

     The procedure 'number-of-arguments-limit-exception?' returns '#t'
     when OBJ is a number-of-arguments-limit-exception object and '#f'
     otherwise.

     The procedure 'number-of-arguments-limit-exception-procedure'
     returns the target procedure of the call to 'apply' that raised
     EXC.

     The procedure 'number-of-arguments-limit-exception-arguments'
     returns the list of arguments of the target procedure of the call
     to 'apply' that raised EXC.

     For example:

          > (define (iota n) (if (= n 0) '() (cons n (iota (- n 1)))))
          > (define (handler exc)
              (if (number-of-arguments-limit-exception? exc)
                  (list (number-of-arguments-limit-exception-procedure exc)
                        (length (number-of-arguments-limit-exception-arguments exc)))
                  'not-number-of-arguments-limit-exception))
          > (with-exception-catcher
              handler
              (lambda () (apply + 1 2 3 (iota 8190))))
          (#<procedure #2 +> 8193)

 -- procedure: nonprocedure-operator-exception? OBJ
 -- procedure: nonprocedure-operator-exception-operator EXC
 -- procedure: nonprocedure-operator-exception-arguments EXC
 -- procedure: nonprocedure-operator-exception-code EXC
 -- procedure: nonprocedure-operator-exception-rte EXC

     Nonprocedure-operator-exception objects are raised when a procedure
     call is executed and the operator position is not a procedure.  The
     parameter EXC must be an nonprocedure-operator-exception object.

     The procedure 'nonprocedure-operator-exception?' returns '#t' when
     OBJ is an nonprocedure-operator-exception object and '#f'
     otherwise.

     The procedure 'nonprocedure-operator-exception-operator' returns
     the value in operator position of the procedure call that raised
     EXC.

     The procedure 'nonprocedure-operator-exception-arguments' returns
     the list of arguments of the procedure call that raised EXC.

     For example:

          > (define (handler exc)
              (if (nonprocedure-operator-exception? exc)
                  (list (nonprocedure-operator-exception-operator exc)
                        (nonprocedure-operator-exception-arguments exc))
                  'not-nonprocedure-operator-exception))
          > (with-exception-catcher
              handler
              (lambda () (11 22 33)))
          (11 (22 33))

 -- procedure: wrong-number-of-values-exception? OBJ
 -- procedure: wrong-number-of-values-exception-vals EXC
 -- procedure: wrong-number-of-values-exception-code EXC
 -- procedure: wrong-number-of-values-exception-rte EXC

     Wrong-number-of-values-exception objects are raised by the
     'let-values' and 'define-values' forms when the number of values
     does not conform to the number of variables to be bound.  The
     parameter EXC must be an wrong-number-of-values-exception object.

     The procedure 'wrong-number-of-values-exception?' returns '#t' when
     OBJ is an wrong-number-of-values-exception object and '#f'
     otherwise.

     The procedure 'wrong-number-of-values-exception-vals' returns the
     values that were to be bound.

     For example:

          > (define (handler exc)
              (if (wrong-number-of-values-exception? exc)
                  (call-with-values
                   (lambda () (wrong-number-of-values-exception-vals exc))
                   list)
                  'not-wrong-number-of-values-exception))
          > (with-exception-catcher
              handler
              (lambda () (let-values (((a b) (values 11 22 33))) (* a b))))
          (11 22 33)

 -- procedure: unknown-keyword-argument-exception? OBJ
 -- procedure: unknown-keyword-argument-exception-procedure EXC
 -- procedure: unknown-keyword-argument-exception-arguments EXC

     Unknown-keyword-argument-exception objects are raised when a
     procedure accepting keyword arguments is called and one of the
     keywords supplied is not among those that are expected.  The
     parameter EXC must be an unknown-keyword-argument-exception object.

     The procedure 'unknown-keyword-argument-exception?' returns '#t'
     when OBJ is an unknown-keyword-argument-exception object and '#f'
     otherwise.

     The procedure 'unknown-keyword-argument-exception-procedure'
     returns the procedure that raised EXC.

     The procedure 'unknown-keyword-argument-exception-arguments'
     returns the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (unknown-keyword-argument-exception? exc)
                  (list (unknown-keyword-argument-exception-procedure exc)
                        (unknown-keyword-argument-exception-arguments exc))
                  'not-unknown-keyword-argument-exception))
          > (with-exception-catcher
              handler
              (lambda () ((lambda (#!key (foo 5)) foo) bar: 11)))
          (#<procedure #2> (bar: 11))

 -- procedure: keyword-expected-exception? OBJ
 -- procedure: keyword-expected-exception-procedure EXC
 -- procedure: keyword-expected-exception-arguments EXC

     Keyword-expected-exception objects are raised when a procedure
     accepting keyword arguments is called and a nonkeyword was supplied
     where a keyword was expected.  The parameter EXC must be an
     keyword-expected-exception object.

     The procedure 'keyword-expected-exception?' returns '#t' when OBJ
     is an keyword-expected-exception object and '#f' otherwise.

     The procedure 'keyword-expected-exception-procedure' returns the
     procedure that raised EXC.

     The procedure 'keyword-expected-exception-arguments' returns the
     list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (keyword-expected-exception? exc)
                  (list (keyword-expected-exception-procedure exc)
                        (keyword-expected-exception-arguments exc))
                  'not-keyword-expected-exception))
          > (with-exception-catcher
              handler
              (lambda () ((lambda (#!key (foo 5)) foo) 11 22)))
          (#<procedure #2> (11 22))


File: gambit.info,  Node: Other exception objects,  Prev: Exception objects related to procedure call,  Up: Exceptions

12.10 Other exception objects
=============================

 -- procedure: error-exception? OBJ
 -- procedure: error-exception-message EXC
 -- procedure: error-exception-parameters EXC
 -- procedure: error MESSAGE OBJ...

     Error-exception objects are raised when the 'error' procedure is
     called.  The parameter EXC must be an error-exception object.

     The procedure 'error-exception?' returns '#t' when OBJ is an
     error-exception object and '#f' otherwise.

     The procedure 'error-exception-message' returns the first argument
     of the call to 'error' that raised EXC.

     The procedure 'error-exception-parameters' returns the list of
     arguments, starting with the second argument, of the call to
     'error' that raised EXC.

     The 'error' procedure raises an error-exception object whose
     message field is MESSAGE and parameters field is the list of values
     OBJ....

     For example:

          > (define (handler exc)
              (if (error-exception? exc)
                  (list (error-exception-message exc)
                        (error-exception-parameters exc))
                  'not-error-exception))
          > (with-exception-catcher
              handler
              (lambda () (error "unexpected object:" 123)))
          ("unexpected object:" (123))


File: gambit.info,  Node: Host environment,  Next: I/O and ports,  Prev: Exceptions,  Up: Top

13 Host environment
*******************

The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system within
which the Scheme program is executing.  This chapter specifies how the
host environment can be accessed from within the Scheme program.

   In this chapter we say that the Scheme program being executed is a
process, even though the concept of process does not exist in some
operating systems supported by Gambit (e.g.  MSDOS).

* Menu:

* Handling of file names::                  Handling of file names
* Filesystem operations::                   Filesystem operations
* Shell command execution::                 Shell command execution
* Process termination::                     Process termination
* Command line arguments::                  Command line arguments
* Environment variables::                   Environment variables
* Measuring time::                          Measuring time
* File information::                        File information
* Group information::                       Group information
* User information::                        User information   .
* Host information::                        Host information
* Service information::                     Service information
* Protocol information::                    Protocol information
* Network information::                     Network information


File: gambit.info,  Node: Handling of file names,  Next: Filesystem operations,  Prev: Host environment,  Up: Host environment

13.1 Handling of file names
===========================

Gambit uses a naming convention for files that is compatible with the
one used by the host environment but extended to allow referring to the
"home directory" of the current user or some specific user and the
"installation directories".

   A "path" is a string that denotes a file, for example
'"src/readme.txt"'.  Each component of a path is separated by a '/'
under UNIX and macOS and by a '/' or '\' under MSDOS and Microsoft
Windows.  A leading separator indicates an absolute path under UNIX,
macOS, MSDOS and Microsoft Windows.  A path which does not contain a
path separator is relative to the "current working directory" on all
operating systems.  A volume specifier such as 'C:' may prefix a file
name under MSDOS and Microsoft Windows.

   A path which starts with the characters '~~' denotes a file in an
installation directory.  If nothing follows the '~~' then the directory
denoted is the central installation directory.  Otherwise what follows
the '~~' is the name of the installation directory, for example '~~lib'
denotes the 'lib' installation directory.  Note that the location of the
installation directories may be overridden by using the
'-:~~NAME=DIRECTORY' runtime option or by defining the 'GAMBOPT'
environment variable.  Unless explicitly overridden, '~~execdir' denotes
the directory containing the current executable program.

   A path which starts with the character '~' not followed by '~'
denotes a file in the user's home directory.  The user's home directory
is contained in the 'HOME' environment variable under UNIX, macOS, MSDOS
and Microsoft Windows.  Under MSDOS and Microsoft Windows, if the 'HOME'
environment variable is not defined, the environment variables
'HOMEDRIVE' and 'HOMEPATH' are concatenated if they are defined.  If
this fails to yield a home directory, the central installation directory
is used instead.

   A path which starts with the characters '~USERNAME' denotes a file in
the home directory of the given user.  Under UNIX and macOS this is
found using the password file.  There is no equivalent under MSDOS and
Microsoft Windows.

 -- procedure: initial-current-directory
 -- procedure: current-directory [NEW-CURRENT-DIRECTORY]

     The procedure 'initial-current-directory' returns the absolute
     "normalized path" of the current working directory of the current
     process when it was started.

     The parameter object 'current-directory' is bound to the current
     working directory.  Calling this procedure with no argument returns
     the absolute "normalized path" of the directory and calling this
     procedure with one argument sets the directory to
     NEW-CURRENT-DIRECTORY.  The initial binding of this parameter
     object is the path returned by 'initial-current-directory'.  The
     path returned by 'current-directory' always contains a trailing
     directory separator.  Modifications of the parameter object do not
     change the current working directory of the current process (i.e.
     that is accessible with the UNIX 'getcwd()' function and the
     Microsoft Windows 'GetCurrentDirectory' function).  It is an error
     to mutate the string returned by 'current-directory'.

     For example under UNIX:

          > (current-directory)
          "/Users/feeley/gambit/doc/"
          > (current-directory "..")
          > (current-directory)
          "/Users/feeley/gambit/"
          > (initial-current-directory)
          "/Users/feeley/gambit/doc/"
          > (path-expand "foo" "~~")
          "/usr/local/Gambit/foo"
          > (parameterize ((current-directory "~~")) (path-expand "foo"))
          "/usr/local/Gambit/foo"

 -- procedure: path-expand PATH [ORIGIN-DIRECTORY]

     The procedure 'path-expand' takes the path of a file or directory
     and returns an expanded path, which is an absolute path when PATH
     or ORIGIN-DIRECTORY are absolute paths.  The optional
     ORIGIN-DIRECTORY parameter, which defaults to the current working
     directory, is the directory used to resolve relative paths.
     Components of the paths PATH and ORIGIN-DIRECTORY need not exist.

     For example under UNIX:

          > (path-expand "foo")
          "/Users/feeley/gambit/doc/foo"
          > (path-expand "~/foo")
          "/Users/feeley/foo"
          > (path-expand "~~lib/foo")
          "/usr/local/Gambit/lib/foo"
          > (path-expand "../foo")
          "/Users/feeley/gambit/doc/../foo"
          > (path-expand "foo" "")
          "foo"
          > (path-expand "foo" "/tmp")
          "/tmp/foo"
          > (path-expand "this/file/does/not/exist")
          "/Users/feeley/gambit/doc/this/file/does/not/exist"
          > (path-expand "")
          "/Users/feeley/gambit/doc/"

 -- procedure: path-normalize PATH [ALLOW-RELATIVE? [ORIGIN-DIRECTORY]]

     The procedure 'path-normalize' takes a path of a file or directory
     and returns its normalized path.  The optional ORIGIN-DIRECTORY
     parameter, which defaults to the current working directory, is the
     directory used to resolve relative paths.  All components of the
     paths PATH and ORIGIN-DIRECTORY must exist, except possibly the
     last component of PATH.  A normalized path is a path containing no
     redundant parts and which is consistent with the current structure
     of the filesystem.  A normalized path of a directory will always
     end with a path separator (i.e.  '/', '\', or ':' depending on the
     operating system).  The optional ALLOW-RELATIVE? parameter, which
     defaults to '#f', indicates if the path returned can be expressed
     relatively to ORIGIN-DIRECTORY: a '#f' requests an absolute path,
     the symbol 'shortest' requests the shortest of the absolute and
     relative paths, and any other value requests the relative path.
     The shortest path is useful for interaction with the user because
     short relative paths are typically easier to read than long
     absolute paths.

     For example under UNIX:

          > (path-expand "../foo")
          "/Users/feeley/gambit/doc/../foo"
          > (path-normalize "../foo")
          "/Users/feeley/gambit/foo"
          > (path-normalize "this/file/does/not/exist")
          *** ERROR IN (console)@3.1 -- No such file or directory
          (path-normalize "this/file/does/not/exist")

 -- procedure: path-extension PATH
 -- procedure: path-strip-extension PATH
 -- procedure: path-directory PATH
 -- procedure: path-strip-directory PATH
 -- procedure: path-strip-trailing-directory-separator PATH
 -- procedure: path-volume PATH
 -- procedure: path-strip-volume PATH

     These procedures extract various parts of a path, which need not be
     a normalized path.  The procedure 'path-extension' returns the file
     extension (including the period) or the empty string if there is no
     extension.  The procedure 'path-strip-extension' returns the path
     with the extension stripped off.  The procedure 'path-directory'
     returns the file's directory (including the last path separator) or
     the empty string if no directory is specified in the path.  The
     procedure 'path-strip-directory' returns the path with the
     directory stripped off.  The procedure
     'path-strip-trailing-directory-separator' returns the path with the
     directory separator stripped off if one is at the end of the path.
     The procedure 'path-volume' returns the file's volume (including
     the last path separator) or the empty string if no volume is
     specified in the path.  The procedure 'path-strip-volume' returns
     the path with the volume stripped off.

     For example under UNIX:

          > (path-extension "/tmp/foo")
          ""
          > (path-extension "/tmp/foo.txt")
          ".txt"
          > (path-strip-extension "/tmp/foo.txt")
          "/tmp/foo"
          > (path-directory "/tmp/foo.txt")
          "/tmp/"
          > (path-strip-directory "/tmp/foo.txt")
          "foo.txt"
          > (path-strip-trailing-directory-separator "/usr/local/bin/")
          "/usr/local/bin"
          > (path-strip-trailing-directory-separator "/usr/local/bin")
          "/usr/local/bin"
          > (path-volume "/tmp/foo.txt")
          ""
          > (path-volume "C:/tmp/foo.txt")
          "" ; result is "C:" under Microsoft Windows
          > (path-strip-volume "C:/tmp/foo.txt")
          "C:/tmp/foo.txt" ; result is "/tmp/foo.txt" under Microsoft Windows


File: gambit.info,  Node: Filesystem operations,  Next: Shell command execution,  Prev: Handling of file names,  Up: Host environment

13.2 Filesystem operations
==========================

 -- procedure: create-directory PATH-OR-SETTINGS
 -- procedure: create-temporary-directory [PATH-OR-SETTINGS]

     These procedures create directories.  The argument PATH-OR-SETTINGS
     is either a string denoting a filesystem path or a list of port
     settings which must contain a 'path:' setting in the case the
     procedure 'create-directory'.  The procedure 'create-directory'
     returns an unspecified value.  In the case of
     'create-temporary-directory' the path is used as a prefix to
     generate new directory paths until the path of a directory not
     currently existing is generated and that path is returned.  When a
     path is not specified it defaults to a unique name in the operating
     system's temporary directory.  Here are the settings allowed:

        * 'path:' STRING

          This setting indicates the location of the directory to create
          in the filesystem.  There is no default value for this
          setting.

        * 'permissions:' 12-BIT-EXACT-INTEGER

          This setting controls the UNIX permissions that will be
          attached to the file if it is created.  The default value of
          this setting is '#o777'.

     For example:

          > (create-directory "newdir")
          > (create-temporary-directory "~/foo")
          "/Users/feeley/foo91992"
          > (create-temporary-directory)
          "/tmp/gsi-temp91992"
          > (create-directory "newdir")
          *** ERROR IN (console)@2.1 -- File exists
          (create-directory "newdir")

 -- procedure: create-fifo PATH-OR-SETTINGS

     This procedure creates a FIFO. The argument PATH-OR-SETTINGS is
     either a string denoting a filesystem path or a list of port
     settings which must contain a 'path:' setting.  Here are the
     settings allowed:

        * 'path:' STRING

          This setting indicates the location of the FIFO to create in
          the filesystem.  There is no default value for this setting.

        * 'permissions:' 12-BIT-EXACT-INTEGER

          This setting controls the UNIX permissions that will be
          attached to the file if it is created.  The default value of
          this setting is '#o666'.

     For example:

          > (create-fifo "fifo")
          > (define a (open-input-file "fifo"))
          > (define b (open-output-file "fifo"))
          > (display "1 22 333" b)
          > (force-output b)
          > (read a)
          1
          > (read a)
          22

 -- procedure: create-link SOURCE-PATH DESTINATION-PATH

     This procedure creates a hard link between SOURCE-PATH and
     DESTINATION-PATH.  The argument SOURCE-PATH must be a string
     denoting the path of an existing file.  The argument
     DESTINATION-PATH must be a string denoting the path of the link to
     create.

 -- procedure: create-symbolic-link SOURCE-PATH DESTINATION-PATH

     This procedure creates a symbolic link between SOURCE-PATH and
     DESTINATION-PATH.  The argument SOURCE-PATH must be a string
     denoting the path of an existing file.  The argument
     DESTINATION-PATH must be a string denoting the path of the symbolic
     link to create.

 -- procedure: rename-file SOURCE-PATH DESTINATION-PATH [REPLACE?]

     This procedure renames the file SOURCE-PATH to DESTINATION-PATH.
     The argument SOURCE-PATH must be a string denoting the path of an
     existing file.  The argument DESTINATION-PATH must be a string
     denoting the new path of the file.  If REPLACE? is absent or true,
     an existing DESTINATION-PATH will be replaced by SOURCE-PATH.
     Otherwise, the rename operation will fail if DESTINATION-PATH
     exists.  Not all filesystems support atomic renaming and existence
     testing.

 -- procedure: copy-file SOURCE-PATH DESTINATION-PATH

     This procedure copies the file SOURCE-PATH to DESTINATION-PATH.
     The argument SOURCE-PATH must be a string denoting the path of an
     existing file.  The argument DESTINATION-PATH must be a string
     denoting the path of the file to create.

 -- procedure: delete-file PATH

     This procedure deletes the file PATH.  The argument PATH must be a
     string denoting the path of an existing file.

 -- procedure: delete-directory PATH

     This procedure deletes the directory PATH.  The argument PATH must
     be a string denoting the path of an existing empty directory.

 -- procedure: delete-file-or-directory PATH [RECURSIVE?]

     This procedure deletes the file or directory PATH.  The argument
     PATH must be a string denoting the path of an existing file or
     directory.  If RECURSIVE? is specified and is true, directories are
     recursively deleted.  Otherwise only empty directories can be
     deleted.

 -- procedure: directory-files [PATH-OR-SETTINGS]

     This procedure returns the list of the files in a directory.  The
     argument PATH-OR-SETTINGS is either a string denoting a filesystem
     path to a directory or a list of settings which must contain a
     'path:' setting.  If it is not specified, PATH-OR-SETTINGS defaults
     to the current directory (the value bound to the
     'current-directory' parameter object).  Here are the settings
     allowed:

        * 'path:' STRING

          This setting indicates the location of the directory in the
          filesystem.  There is no default value for this setting.

        * 'ignore-hidden:' ( '#f' | '#t' | 'dot-and-dot-dot' )

          This setting controls whether hidden-files will be returned.
          Under UNIX and macOS hidden-files are those that start with a
          period (such as '.', '..', and '.profile').  Under Microsoft
          Windows hidden files are the '.' and '..' entries and the
          files whose "hidden file" attribute is set.  A setting of '#f'
          will enumerate all the files.  A setting of '#t' will only
          enumerate the files that are not hidden.  A setting of
          'dot-and-dot-dot' will enumerate all the files except for the
          '.' and '..' hidden files.  The default value of this setting
          is '#t'.

     For example:

          > (directory-files)
          ("complex" "README" "simple")
          > (directory-files "../include")
          ("config.h" "config.h.in" "gambit.h" "makefile" "makefile.in")
          > (directory-files (list path: "../include" ignore-hidden: #f))
          ("." ".." "config.h" "config.h.in" "gambit.h" "makefile" "makefile.in")


File: gambit.info,  Node: Shell command execution,  Next: Process termination,  Prev: Filesystem operations,  Up: Host environment

13.3 Shell command execution
============================

 -- procedure: shell-command COMMAND [CAPTURE?]

     The procedure 'shell-command' calls up the shell to execute COMMAND
     which must be a string.  The argument CAPTURE?, which defaults to
     '#f', indicates if the output of the command is captured as a
     string.  If CAPTURE? is '#f', this procedure returns the exit
     status of the shell in the form that the C library's 'system'
     routine returns.  If CAPTURE? is not '#f', this procedure returns a
     pair consisting of the exit status of the shell in the 'car' field,
     and the captured output in the 'cdr' field.  Be advised that the
     shell that is used, and consequently the syntax of COMMAND, depends
     on the operating system.  On Unix, the shell '/bin/sh' is usually
     invoked.  On Windows, the shell 'cmd.exe' is usually invoked.

     For example under UNIX:

          > (shell-command "ls -sk f*.scm")
          4 fact.scm   4 fib.scm
          0
          > (shell-command "ls -sk f*.scm" #t)
          (0 . "4 fact.scm   4 fib.scm\n")
          > (shell-command "echo x\\\\\\\\y $HOME" #t)
          (0 . "x\\y /Users/feeley\n")

     For example under Windows:

          > (shell-command "echo x\\\\\\\\y %HOME%" #t)
          (0 . "x\\\\\\\\y C:\\Users\\feeley\r\n")


File: gambit.info,  Node: Process termination,  Next: Command line arguments,  Prev: Shell command execution,  Up: Host environment

13.4 Process termination
========================

 -- procedure: exit [STATUS]

     The procedure 'exit' causes the process to terminate with the
     status STATUS which must be an exact integer in the range 0 to 255
     or '#f'.  If it is not specified, STATUS defaults to 0.  When
     STATUS is '#f' the process terminates with an error status.

     For example under UNIX:

          $ gsi
          Gambit v4.9.4

          > (exit #f)
          $ echo $?
          70


File: gambit.info,  Node: Command line arguments,  Next: Environment variables,  Prev: Process termination,  Up: Host environment

13.5 Command line arguments
===========================

 -- procedure: command-line

     This procedure returns a list of strings corresponding to the
     command line arguments, including the program file name as the
     first element of the list.  When the interpreter executes a Scheme
     script, the list returned by 'command-line' contains the script's
     absolute path followed by the remaining command line arguments.

     For example under UNIX:

          $ gsi -:debug -e "(pretty-print (command-line))"
          ("gsi" "-e" "(pretty-print (command-line))")
          $ cat foo
          #!/usr/local/Gambit/bin/gsi-script
          (pretty-print (command-line))
          $ ./foo 1 2 "3 4"
          ("/u/feeley/./foo" "1" "2" "3 4")


File: gambit.info,  Node: Environment variables,  Next: Measuring time,  Prev: Command line arguments,  Up: Host environment

13.6 Environment variables
==========================

 -- procedure: getenv NAME [DEFAULT]
 -- procedure: setenv NAME [NEW-VALUE]

     The procedure 'getenv' returns the value of the environment
     variable NAME of the current process.  Variable names are denoted
     with strings.  A string is returned if the environment variable is
     bound, otherwise DEFAULT is returned if it is specified, otherwise
     an exception is raised.

     The procedure 'setenv' changes the binding of the environment
     variable NAME to NEW-VALUE which must be a string.  If NEW-VALUE is
     not specified the binding is removed.

     For example under UNIX:

          > (getenv "HOME")
          "/Users/feeley"
          > (getenv "DOES_NOT_EXIST" #f)
          #f
          > (setenv "DOES_NOT_EXIST" "it does now")
          > (getenv "DOES_NOT_EXIST" #f)
          "it does now"
          > (setenv "DOES_NOT_EXIST")
          > (getenv "DOES_NOT_EXIST" #f)
          #f
          > (getenv "DOES_NOT_EXIST")
          *** ERROR IN (console)@7.1 -- Unbound OS environment variable
          (getenv "DOES_NOT_EXIST")


File: gambit.info,  Node: Measuring time,  Next: File information,  Prev: Environment variables,  Up: Host environment

13.7 Measuring time
===================

Procedures are available for measuring real time (aka "wall" time) and
cpu time (the amount of time the cpu has been executing the process).
The resolution of the real time and cpu time clock is operating system
dependent.  Typically the resolution of the cpu time clock is rather
coarse (measured in "ticks" of 1/60th or 1/100th of a second).  Real
time is internally computed relative to some arbitrary point in time
using floating point numbers, which means that there is a gradual loss
of resolution as time elapses.  Moreover, some operating systems report
time in number of ticks using a 32 bit integer so the value returned by
the time related procedures may wraparound much before any significant
loss of resolution occurs (for example 2.7 years if ticks are 1/50th of
a second).

 -- procedure: current-time
 -- procedure: time? OBJ
 -- procedure: time->seconds TIME
 -- procedure: seconds->time X

     The procedure 'current-time' returns a "time object" representing
     the current point in real time.

     The procedure 'time?' returns '#t' when OBJ is a time object and
     '#f' otherwise.

     The procedure 'time->seconds' converts the time object TIME into an
     inexact real number representing the number of seconds elapsed
     since the "epoch" (which is 00:00:00 Coordinated Universal Time
     01-01-1970).

     The procedure 'seconds->time' converts the real number X
     representing the number of seconds elapsed since the "epoch" into a
     time object.

     For example:

          > (current-time)
          #<time #2>
          > (time? (current-time))
          #t
          > (time? 123)
          #f
          > (time->seconds (current-time))
          1083118758.63973
          > (time->seconds (current-time))
          1083118759.909163
          > (seconds->time (+ 10 (time->seconds (current-time))
          #<time #3>  ; a time object representing 10 seconds in the future

 -- procedure: process-times
 -- procedure: cpu-time
 -- procedure: real-time

     The procedure 'process-times' returns a three element f64vector
     containing the cpu time that has been used by the program and the
     real time that has elapsed since it was started.  The first element
     corresponds to "user" time in seconds, the second element
     corresponds to "system" time in seconds and the third element is
     the elapsed real time in seconds.  On operating systems that can't
     differentiate user and system time, the system time is zero.  On
     operating systems that can't measure cpu time, the user time is
     equal to the elapsed real time and the system time is zero.

     The procedure 'cpu-time' returns the cpu time in seconds that has
     been used by the program (user time plus system time).

     The procedure 'real-time' returns the real time that has elapsed
     since the program was started.

     For example:

          > (process-times)
          #f64(.02794 .021754 .159926176071167)
          > (cpu-time)
          .051223
          > (real-time)
          .40660619735717773

 -- special form: time expr [PORT]

     The 'time' special form evaluates expr and returns the result.  As
     a side effect it displays a message on the port PORT which
     indicates various statistics about the evaluation of expr including
     how long the evaluation took (in real time and cpu time), how much
     time was spent in the garbage collector, how much memory was
     allocated during the evaluation and how many minor and major page
     faults occured (0 is reported if not running under UNIX). If it is
     not specified, PORT defaults to the interaction channel (i.e.  the
     output will appear at the REPL).

     For example:

          > (define (f x)
              (let loop ((x x) (lst '()))
                (if (= x 0)
                    lst
                    (loop (- x 1) (cons x lst)))))
          > (length (time (f 100000)))
          (time (f 100000))
              683 ms real time
              558 ms cpu time (535 user, 23 system)
              8 collections accounting for 102 ms real time (70 user, 5 system)
              6400160 bytes allocated
              no minor faults
              no major faults
          100000


File: gambit.info,  Node: File information,  Next: Group information,  Prev: Measuring time,  Up: Host environment

13.8 File information
=====================

 -- procedure: file-exists? PATH [CHASE?]

     The PATH argument must be a string.  This procedure returns '#t'
     when a file by that name exists, and returns '#f' otherwise.

     When CHASE? is present and '#f', symbolic links will not be chased,
     in other words if PATH refers to a symbolic link, 'file-exists?'
     will return '#t' whether or not it points to an existing file.

     For example:

          > (file-exists? "nofile")
          #f

 -- procedure: file-info PATH [CHASE?]

     This procedure accesses the filesystem to get information about the
     file whose location is given by the string PATH.  A
     file-information record is returned that contains the file's type,
     the device number, the inode number, the mode (permission bits),
     the number of links, the file's user id, the file's group id, the
     file's size in bytes, the times of last-access, last-modification
     and last-change, the attributes, and the creation time.

     When CHASE? is present and '#f', symbolic links will not be chased,
     in other words if PATH refers to a symbolic link the 'file-info'
     procedure will return information about the link rather than the
     file it links to.

     For example:

          > (file-info "/dev/tty")
          #<file-info #2
             type: character-special
             device: 19513156
             inode: 20728196
             mode: 438
             number-of-links: 1
             owner: 0
             group: 0
             size: 0
             last-access-time: #<time #3>
             last-modification-time: #<time #4>
             last-change-time: #<time #5>
             attributes: 128
             creation-time: #<time #6>>

 -- procedure: file-info? OBJ

     This procedure returns '#t' when OBJ is a file-information record
     and '#f' otherwise.

     For example:

          > (file-info? (file-info "/dev/tty"))
          #t
          > (file-info? 123)
          #f

 -- procedure: file-info-type FILE-INFO

     Returns the type field of the file-information record FILE-INFO.
     The type is denoted by a symbol.  The following types are possible:

     'regular'
          Regular file
     'directory'
          Directory
     'character-special'
          Character special device
     'block-special'
          Block special device
     'fifo'
          FIFO
     'symbolic-link'
          Symbolic link
     'socket'
          Socket
     'unknown'
          File is of an unknown type

     For example:

          > (file-info-type (file-info "/dev/tty"))
          character-special
          > (file-info-type (file-info "/dev"))
          directory

 -- procedure: file-info-device FILE-INFO

     Returns the device field of the file-information record FILE-INFO.

     For example:

          > (file-info-device (file-info "/dev/tty"))
          19513156

 -- procedure: file-info-inode FILE-INFO

     Returns the inode field of the file-information record FILE-INFO.

     For example:

          > (file-info-inode (file-info "/dev/tty"))
          20728196

 -- procedure: file-info-mode FILE-INFO

     Returns the mode field of the file-information record FILE-INFO.

     For example:

          > (file-info-mode (file-info "/dev/tty"))
          438

 -- procedure: file-info-number-of-links FILE-INFO

     Returns the number-of-links field of the file-information record
     FILE-INFO.

     For example:

          > (file-info-number-of-links (file-info "/dev/tty"))
          1

 -- procedure: file-info-owner FILE-INFO

     Returns the owner field of the file-information record FILE-INFO.

     For example:

          > (file-info-owner (file-info "/dev/tty"))
          0

 -- procedure: file-info-group FILE-INFO

     Returns the group field of the file-information record FILE-INFO.

     For example:

          > (file-info-group (file-info "/dev/tty"))
          0

 -- procedure: file-info-size FILE-INFO

     Returns the size field of the file-information record FILE-INFO.

     For example:

          > (file-info-size (file-info "/dev/tty"))
          0

 -- procedure: file-info-last-access-time FILE-INFO

     Returns the last-access-time field of the file-information record
     FILE-INFO.

     For example:

          > (file-info-last-access-time (file-info "/dev/tty"))
          #<time #2>

 -- procedure: file-info-last-modification-time FILE-INFO

     Returns the last-modification-time field of the file-information
     record FILE-INFO.

     For example:

          > (file-info-last-modification-time (file-info "/dev/tty"))
          #<time #2>

 -- procedure: file-info-last-change-time FILE-INFO

     Returns the last-change-time field of the file-information record
     FILE-INFO.

     For example:

          > (file-info-last-change-time (file-info "/dev/tty"))
          #<time #2>

 -- procedure: file-info-attributes FILE-INFO

     Returns the attributes field of the file-information record
     FILE-INFO.

     For example:

          > (file-info-attributes (file-info "/dev/tty"))
          128

 -- procedure: file-info-creation-time FILE-INFO

     Returns the creation-time field of the file-information record
     FILE-INFO.

     For example:

          > (file-info-creation-time (file-info "/dev/tty"))
          #<time #2>

 -- procedure: file-type PATH
 -- procedure: file-device PATH
 -- procedure: file-inode PATH
 -- procedure: file-mode PATH
 -- procedure: file-number-of-links PATH
 -- procedure: file-owner PATH
 -- procedure: file-group PATH
 -- procedure: file-size PATH
 -- procedure: file-last-access-time PATH
 -- procedure: file-last-modification-time PATH
 -- procedure: file-last-change-time PATH
 -- procedure: file-attributes PATH
 -- procedure: file-creation-time PATH

     These procedures combine a call to the 'file-info' procedure and a
     call to a file-information record field accessor.  For instance
     '(file-type PATH)' is equivalent to '(file-info-type (file-info
     PATH))'.

 -- procedure: file-last-access-and-modification-times-set! PATH [ATIME
          [MTIME]]

     This procedure changes the last-access and last-modification times
     of the file whose location is given by the string PATH.  Time is
     specified either with a time object indicating an absolute point in
     time or a real number indicating the number of seconds relative to
     the moment the procedure is called.  When ATIME and MTIME are not
     specified, the last-access and last-modification times are set to
     the current time.  When MTIME is not specified, the last-access and
     last-modification times are set to ATIME.  Otherwise the
     last-access time is set to ATIME and the last-modification time is
     set to MTIME.

     For example:

          > (define (t path)
              (list (time->seconds (file-last-access-time path))
                    (time->seconds (file-last-modification-time path))))
          > (with-output-to-file "nl.txt" newline)
          > (t "nl.txt")
          (1429547027. 1429547027.)
          > (t "nl.txt")
          (1429547027. 1429547027.)
          > (file-last-access-and-modification-times-set! "nl.txt")
          > (t "nl.txt")
          (1429547039. 1429547039.)
          > (file-last-access-and-modification-times-set! "nl.txt" -60)
          > (t "nl.txt")
          (1429547006. 1429547006.)
          > (file-last-access-and-modification-times-set! "nl.txt" -60 0)
          > (t "nl.txt")
          (1429547049. 1429547109.)


File: gambit.info,  Node: Group information,  Next: User information,  Prev: File information,  Up: Host environment

13.9 Group information
======================

 -- procedure: group-info GROUP-NAME-OR-ID

     This procedure accesses the group database to get information about
     the group identified by GROUP-NAME-OR-ID, which is the group's
     symbolic name (string) or the group's GID (exact integer).  A
     group-information record is returned that contains the group's
     symbolic name, the group's id (GID), and the group's members (list
     of symbolic user names).

     For example:

          > (group-info "staff")
          #<group-info #2 name: "staff" gid: 20 members: ("root")>
          > (group-info 29)
          #<group-info #3
             name: "certusers"
             gid: 29
             members: ("root" "jabber" "postfix" "cyrusimap")>
          > (group-info 5000)
          *** ERROR IN (console)@3.1 -- Resource temporarily unavailable
          (group-info 5000)

 -- procedure: group-info? OBJ

     This procedure returns '#t' when OBJ is a group-information record
     and '#f' otherwise.

     For example:

          > (group-info? (group-info "daemon"))
          #t
          > (group-info? 123)
          #f

 -- procedure: group-info-name GROUP-INFO

     Returns the symbolic name field of the group-information record
     GROUP-INFO.

     For example:

          > (group-info-name (group-info 29))
          "certusers"

 -- procedure: group-info-gid GROUP-INFO

     Returns the group id field of the group-information record
     GROUP-INFO.

     For example:

          > (group-info-gid (group-info "staff"))
          20

 -- procedure: group-info-members GROUP-INFO

     Returns the members field of the group-information record
     GROUP-INFO.

     For example:

          > (group-info-members (group-info "staff"))
          ("root")


File: gambit.info,  Node: User information,  Next: Host information,  Prev: Group information,  Up: Host environment

13.10 User information
======================

 -- procedure: user-name

     This procedure returns the user's name as a string.

     For example:

          > (user-name)
          "feeley"

 -- procedure: user-info USER-NAME-OR-ID

     This procedure accesses the user database to get information about
     the user identified by USER-NAME-OR-ID, which is the user's
     symbolic name (string) or the user's UID (exact integer).  A
     user-information record is returned that contains the user's
     symbolic name, the user's id (UID), the user's group id (GID), the
     path to the user's home directory, and the user's login shell.

     For example:

          > (user-info "feeley")
          #<user-info #2
             name: "feeley"
             uid: 506
             gid: 506
             home: "/Users/feeley"
             shell: "/bin/bash">
          > (user-info 0)
          #<user-info #3 name: "root" uid: 0 gid: 0 home: "/var/root" shell: "/bin/sh">
          > (user-info 5000)
          *** ERROR IN (console)@3.1 -- Resource temporarily unavailable
          (user-info 5000)

 -- procedure: user-info? OBJ

     This procedure returns '#t' when OBJ is a user-information record
     and '#f' otherwise.

     For example:

          > (user-info? (user-info "feeley"))
          #t
          > (user-info? 123)
          #f

 -- procedure: user-info-name USER-INFO

     Returns the symbolic name field of the user-information record
     USER-INFO.

     For example:

          > (user-info-name (user-info 0))
          "root"

 -- procedure: user-info-uid USER-INFO

     Returns the user id field of the user-information record USER-INFO.

     For example:

          > (user-info-uid (user-info "feeley"))
          506

 -- procedure: user-info-gid USER-INFO

     Returns the group id field of the user-information record
     USER-INFO.

     For example:

          > (user-info-gid (user-info "feeley"))
          506

 -- procedure: user-info-home USER-INFO

     Returns the home directory field of the user-information record
     USER-INFO.

     For example:

          > (user-info-home (user-info 0))
          "/var/root"

 -- procedure: user-info-shell USER-INFO

     Returns the shell field of the user-information record USER-INFO.

     For example:

          > (user-info-shell (user-info 0))
          "/bin/sh"


File: gambit.info,  Node: Host information,  Next: Service information,  Prev: User information,  Up: Host environment

13.11 Host information
======================

 -- procedure: host-name

     This procedure returns the machine's host name as a string.

     For example:

          > (host-name)
          "mega.iro.umontreal.ca"

 -- procedure: host-info HOST-NAME

     This procedure accesses the internet host database to get
     information about the machine whose name is denoted by the string
     HOST-NAME.  A host-information record is returned that contains the
     official name of the machine, a list of aliases (alternative
     names), and a non-empty list of IP addresses for this machine.  An
     exception is raised when HOST-NAME does not appear in the database.

     For example:

          > (host-info "www.google.com")
          #<host-info #2
             name: "www.l.google.com"
             aliases: ("www.google.com")
             addresses: (#u8(66 249 85 99) #u8(66 249 85 104))>
          > (host-info "unknown.domain")
          *** ERROR IN (console)@2.1 -- Unknown host
          (host-info "unknown.domain")

 -- procedure: host-info? OBJ

     This procedure returns '#t' when OBJ is a host-information record
     and '#f' otherwise.

     For example:

          > (host-info? (host-info "www.google.com"))
          #t
          > (host-info? 123)
          #f

 -- procedure: host-info-name HOST-INFO

     Returns the official name field of the host-information record
     HOST-INFO.

     For example:

          > (host-info-name (host-info "www.google.com"))
          "www.l.google.com"

 -- procedure: host-info-aliases HOST-INFO

     Returns the aliases field of the host-information record HOST-INFO.
     This field is a possibly empty list of strings.

     For example:

          > (host-info-aliases (host-info "www.google.com"))
          ("www.google.com")

 -- procedure: host-info-addresses HOST-INFO

     Returns the addresses field of the host-information record
     HOST-INFO.  This field is a non-empty list of u8vectors denoting IP
     addresses.

     For example:

          > (host-info-addresses (host-info "www.google.com"))
          (#u8(66 249 85 99) #u8(66 249 85 104))

 -- procedure: address-infos [host: HOST] [service: SERVICE] [family:
          FAMILY] [socket-type: SOCKET-TYPE] [protocol: PROTOCOL]

     This procedure is an interface to the 'getaddrinfo' system call.
     It accesses the internet host database to get information about the
     machine whose name is denoted by the string HOST and service is
     denoted by the string SERVICE and network address family is FAMILY
     ('INET' or 'INET6') and network socket-type is SOCKET-TYPE
     ('STREAM' or 'DGRAM' or 'RAW') and network protocol is SOCKET-TYPE
     ('TCP' or 'UDP').  A list of address-information records is
     returned.

     For example:

          > (address-infos host: "ftp.at.debian.org")
          (#<address-info #2
              family: INET6
              socket-type: DGRAM
              protocol: UDP
              socket-info:
               #<socket-info #3
                  family: INET6
                  port-number: 0
                  address: #u16(8193 2136 2 1 0 0 0 16)>>
           #<address-info #4
              family: INET6
              socket-type: STREAM
              protocol: TCP
              socket-info:
               #<socket-info #5
                  family: INET6
                  port-number: 0
                  address: #u16(8193 2136 2 1 0 0 0 16)>>
           #<address-info #6
              family: INET
              socket-type: DGRAM
              protocol: UDP
              socket-info:
               #<socket-info #7
                  family: INET
                  port-number: 0
                  address: #u8(213 129 232 18)>>
           #<address-info #8
              family: INET
              socket-type: STREAM
              protocol: TCP
              socket-info:
               #<socket-info #9
                  family: INET
                  port-number: 0
                  address: #u8(213 129 232 18)>>)
          > (address-infos host: "ftp.at.debian.org"
                           family: 'INET
                           protocol: 'TCP)
          (#<address-info #10
              family: INET
              socket-type: STREAM
              protocol: TCP
              socket-info:
               #<socket-info #11
                  family: INET
                  port-number: 0
                  address: #u8(213 129 232 18)>>)
          > (address-infos host: "unknown.domain")
          *** ERROR IN (console)@5.1 -- nodename nor servname provided, or not known
          (address-infos host: "unknown.domain")

 -- procedure: address-info? OBJ

     This procedure returns '#t' when OBJ is an address-information
     record and '#f' otherwise.

     For example:

          > (map address-info?
                 (address-infos host: "ftp.at.debian.org"))
          (#t #t #t #t)
          > (address-info? 123)
          #f

 -- procedure: address-info-family ADDRESS-INFO

     Returns the family field of the address-information record
     ADDRESS-INFO.

     For example:

          > (map address-info-family
                 (address-infos host: "ftp.at.debian.org"))
          (INET6 INET6 INET INET)

 -- procedure: address-info-socket-type ADDRESS-INFO

     Returns the socket-type field of the address-information record
     ADDRESS-INFO.

     For example:

          > (map address-info-socket-type
                 (address-infos host: "ftp.at.debian.org"))
          (DGRAM STREAM DGRAM STREAM)

 -- procedure: address-info-protocol ADDRESS-INFO

     Returns the protocol field of the address-information record
     ADDRESS-INFO.

     For example:

          > (map address-info-protocol
                 (address-infos host: "ftp.at.debian.org"))
          (UDP TCP UDP TCP)

 -- procedure: address-info-socket-info ADDRESS-INFO

     Returns the socket-info field of the address-information record
     ADDRESS-INFO.

     For example:

          > (map address-info-socket-info
                 (address-infos host: "ftp.at.debian.org"))
          (#<socket-info #2
              family: INET6
              port-number: 0
              address: #u16(8193 2136 2 1 0 0 0 16)>
           #<socket-info #3
              family: INET6
              port-number: 0
              address: #u16(8193 2136 2 1 0 0 0 16)>
           #<socket-info #4
              family: INET
              port-number: 0
              address: #u8(213 129 232 18)>
           #<socket-info #5
              family: INET
              port-number: 0
              address: #u8(213 129 232 18)>)


File: gambit.info,  Node: Service information,  Next: Protocol information,  Prev: Host information,  Up: Host environment

13.12 Service information
=========================

 -- procedure: service-info SERVICE-NAME-OR-ID

     This procedure accesses the service database to get information
     about the service identified by SERVICE-NAME-OR-ID, which is the
     service's symbolic name (string) or the service's port number
     (exact integer).  A service-information record is returned that
     contains the service's symbolic name, a list of aliases
     (alternative names), the port number (exact integer), and the
     protocol name (string).  An exception is raised when
     SERVICE-NAME-OR-ID does not appear in the database.

     For example:

          > (service-info "http")
          #<service-info #2
             name: "http"
             aliases: ("www" "www-http")
             port-number: 80
             protocol: "udp">
          > (service-info 80)
          #<service-info #3
             name: "http"
             aliases: ("www" "www-http")
             port-number: 80
             protocol: "udp">

 -- procedure: service-info? OBJ

     This procedure returns '#t' when OBJ is a service-information
     record and '#f' otherwise.

     For example:

          > (service-info? (service-info "http"))
          #t
          > (service-info? 123)
          #f

 -- procedure: service-info-name SERVICE-INFO

     Returns the symbolic name field of the service-information record
     SERVICE-INFO.

     For example:

          > (service-info-name (service-info 80))
          "http"

 -- procedure: service-info-aliases SERVICE-INFO

     Returns the aliases field of the service-information record
     SERVICE-INFO.  This field is a possibly empty list of strings.

     For example:

          > (service-info-aliases (service-info "http"))
          ("www" "www-http")

 -- procedure: service-info-port-number SERVICE-INFO

     Returns the service port number field of the service-information
     record SERVICE-INFO.

     For example:

          > (service-info-port-number (service-info "http"))
          80

 -- procedure: service-info-protocol SERVICE-INFO

     Returns the service protocol name field of the service-information
     record SERVICE-INFO.

     For example:

          > (service-info-protocol (service-info "http"))
          "udp"


File: gambit.info,  Node: Protocol information,  Next: Network information,  Prev: Service information,  Up: Host environment

13.13 Protocol information
==========================

 -- procedure: protocol-info PROTOCOL-NAME-OR-ID

     This procedure accesses the protocol database to get information
     about the protocol identified by PROTOCOL-NAME-OR-ID, which is the
     protocol's symbolic name (string) or the protocol's number (exact
     integer).  A protocol-information record is returned that contains
     the protocol's symbolic name, a list of aliases (alternative
     names), and the protocol number (32 bit unsigned exact integer).
     An exception is raised when PROTOCOL-NAME-OR-ID does not appear in
     the database.

     For example:

          > (protocol-info "tcp")
          #<protocol-info #2 name: "tcp" aliases: ("TCP") number: 6>
          > (protocol-info 6)
          #<protocol-info #2 name: "tcp" aliases: ("TCP") number: 6>

 -- procedure: protocol-info? OBJ

     This procedure returns '#t' when OBJ is a protocol-information
     record and '#f' otherwise.

     For example:

          > (protocol-info? (protocol-info "tcp"))
          #t
          > (protocol-info? 123)
          #f

 -- procedure: protocol-info-name PROTOCOL-INFO

     Returns the symbolic name field of the protocol-information record
     PROTOCOL-INFO.

     For example:

          > (protocol-info-name (protocol-info 6))
          "tcp"

 -- procedure: protocol-info-aliases PROTOCOL-INFO

     Returns the aliases field of the protocol-information record
     PROTOCOL-INFO.  This field is a possibly empty list of strings.

     For example:

          > (protocol-info-aliases (protocol-info "tcp"))
          ("TCP")

 -- procedure: protocol-info-number PROTOCOL-INFO

     Returns the protocol number field of the protocol-information
     record PROTOCOL-INFO.

     For example:

          > (protocol-info-number (protocol-info "tcp"))
          6


File: gambit.info,  Node: Network information,  Prev: Protocol information,  Up: Host environment

13.14 Network information
=========================

 -- procedure: network-info NETWORK-NAME-OR-ID

     This procedure accesses the network database to get information
     about the network identified by NETWORK-NAME-OR-ID, which is the
     network's symbolic name (string) or the network's number (exact
     integer).  A network-information record is returned that contains
     the network's symbolic name, a list of aliases (alternative names),
     and the network number (32 bit unsigned exact integer).  An
     exception is raised when NETWORK-NAME-OR-ID does not appear in the
     database.

     For example:

          > (network-info "loopback")
          #<network-info #2
             name: "loopback"
             aliases: ("loopback-net")
             number: 127>
          > (network-info 127)
          #<network-info #3
             name: "loopback"
             aliases: ("loopback-net")
             number: 127>

 -- procedure: network-info? OBJ

     This procedure returns '#t' when OBJ is a network-information
     record and '#f' otherwise.

     For example:

          > (network-info? (network-info "loopback"))
          #t
          > (network-info? 123)
          #f

 -- procedure: network-info-name NETWORK-INFO

     Returns the symbolic name field of the network-information record
     NETWORK-INFO.

     For example:

          > (network-info-name (network-info 127))
          "loopback"

 -- procedure: network-info-aliases NETWORK-INFO

     Returns the aliases field of the network-information record
     NETWORK-INFO.  This field is a possibly empty list of strings.

     For example:

          > (network-info-aliases (network-info "loopback"))
          ("loopback-net")

 -- procedure: network-info-number NETWORK-INFO

     Returns the network number field of the network-information record
     NETWORK-INFO.

     For example:

          > (network-info-number (network-info "loopback"))
          127


File: gambit.info,  Node: I/O and ports,  Next: Lexical syntax and readtables,  Prev: Host environment,  Up: Top

14 I/O and ports
****************

* Menu:

* Unidirectional and bidirectional ports::  Unidirectional and bidirectional ports
* Port classes::                            Port classes
* Port settings::                           Port settings
* Object-ports::                            Object-ports
* Character-ports::                         Character-ports
* Byte-ports::                              Byte-ports
* Device-ports::                            Device-ports
* Directory-ports::                         Directory-ports
* Vector-ports::                            Vector-ports
* String-ports::                            String-ports
* U8vector-ports::                          U8vector-ports
* Other procedures related to I/O::         Other procedures related to I/O


File: gambit.info,  Node: Unidirectional and bidirectional ports,  Next: Port classes,  Prev: I/O and ports,  Up: I/O and ports

14.1 Unidirectional and bidirectional ports
===========================================

Unidirectional ports allow communication between a producer of
information and a consumer.  An input-port's producer is typically a
resource managed by the operating system (such as a file, a process or a
network connection) and the consumer is the Scheme program.  The roles
are reversed for an output-port.

   Associated with each port are settings that affect I/O operations on
that port (encoding of characters to bytes, end-of-line encoding, type
of buffering, etc).  Port settings are specified when the port is
created.  Some port settings can be changed after a port is created.

   Bidirectional ports, also called input-output-ports, allow
communication in both directions.  They are best viewed as an object
that groups two separate unidirectional ports (one in each direction).
Each direction has its own port settings and can be closed independently
from the other direction.


File: gambit.info,  Node: Port classes,  Next: Port settings,  Prev: Unidirectional and bidirectional ports,  Up: I/O and ports

14.2 Port classes
=================

The four classes of ports listed below form an inheritance hierarchy.
Operations possible for a certain class of port are also possible for
the subclasses.  Only device-ports are connected to a device managed by
the operating system.  For instance it is possible to create ports that
behave as a FIFO where the Scheme program is both the producer and
consumer of information (possibly one thread is the producer and another
thread is the consumer).

  1. An "object-port" (or simply a port) provides operations to read and
     write Scheme data (i.e.  any Scheme object) to/from the port.  It
     also provides operations to force output to occur, to change the
     way threads block on the port, and to close the port.  Note that
     the class of objects for which write/read invariance is guaranteed
     depends on the particular class of port.

  2. A "character-port" provides all the operations of an object-port,
     and also operations to read and write individual characters to/from
     the port.  When a Scheme object is written to a character-port, it
     is converted into the sequence of characters that corresponds to
     its external-representation.  When reading a Scheme object, an
     inverse conversion occurs.  Note that some Scheme objects do not
     have an external textual representation that can be read back.

  3. A "byte-port" provides all the operations of a character-port, and
     also operations to read and write individual bytes to/from the
     port.  When a character is written to a byte-port, some encoding of
     that character into a sequence of bytes will occur (for example,
     '#\newline' will be encoded as the 2 bytes CR-LF when using
     ISO-8859-1 character encoding and 'cr-lf' end-of-line encoding, and
     a non-ASCII character will generate more than 1 byte when using
     UTF-8 character encoding).  When reading a character, a similar
     decoding occurs.

  4. A "device-port" provides all the operations of a byte-port, and
     also operations to control the operating system managed device
     (file, network connection, terminal, etc) that is connected to the
     port.


File: gambit.info,  Node: Port settings,  Next: Object-ports,  Prev: Port classes,  Up: I/O and ports

14.3 Port settings
==================

Some port settings are only valid for specific port classes whereas some
others are valid for all ports.  Port settings are specified when a port
is created.  The settings that are not specified will default to some
reasonable values.  Keyword objects are used to name the settings to be
set.  As a simple example, a device-port connected to the file '"foo"'
can be created using the call

     (open-input-file "foo")

   This will use default settings for the character encoding, buffering,
etc.  When a specific character encoding is desired, such as UTF-16BE,
the port can be opened using the call

     (open-input-file (list path: "foo" char-encoding: 'UTF-16BE))

   Here the argument of the procedure 'open-input-file' has been
replaced by a "port settings list" which specifies the value of each
port setting that should not be set to the default value.  Note that
some port settings have no useful default and it is therefore required
to specify a value for them, such as the 'path:' in the case of the file
opening procedures.  All port creation procedures (i.e.  named
'open-...') take a single argument that can either be a port settings
list or a value of a type that depends on the kind of port being created
(a path string for files, an IP port number for socket servers, etc).


File: gambit.info,  Node: Object-ports,  Next: Character-ports,  Prev: Port settings,  Up: I/O and ports

14.4 Object-ports
=================

* Menu:

* Object-port settings::             Object-port settings
* Object-port operations::           Object-port operations


File: gambit.info,  Node: Object-port settings,  Next: Object-port operations,  Prev: Object-ports,  Up: Object-ports

14.4.1 Object-port settings
---------------------------

The following is a list of port settings that are valid for all types of
ports.

   * 'direction:' ( 'input' | 'output' | 'input-output' )

     This setting controls the direction of the port.  The symbol
     'input' indicates a unidirectional input-port, the symbol 'output'
     indicates a unidirectional output-port, and the symbol
     'input-output' indicates a bidirectional port.  The default value
     of this setting depends on the port creation procedure.

   * 'buffering:' ( '#f' | '#t' | 'line' )

     This setting controls the buffering of the port.  To set each
     direction separately the keywords 'input-buffering:' and
     'output-buffering:' must be used instead of 'buffering:'.  The
     value '#f' selects unbuffered I/O, the value '#t' selects fully
     buffered I/O, and the symbol 'line' selects line buffered I/O (the
     output buffer is drained when a '#\newline' character is written).
     Line buffered I/O only applies to character-ports.  The default
     value of this setting is operating system dependent except consoles
     which are unbuffered.


File: gambit.info,  Node: Object-port operations,  Prev: Object-port settings,  Up: Object-ports

14.4.2 Object-port operations
-----------------------------

 -- procedure: input-port? OBJ
 -- procedure: output-port? OBJ
 -- procedure: port? OBJ

     The procedure 'input-port?' returns '#t' when OBJ is a
     unidirectional input-port or a bidirectional port and '#f'
     otherwise.

     The procedure 'output-port?' returns '#t' when OBJ is a
     unidirectional output-port or a bidirectional port and '#f'
     otherwise.

     The procedure 'port?' returns '#t' when OBJ is a port (either
     unidirectional or bidirectional) and '#f' otherwise.

     For example:

          > (input-port? (current-input-port))
          #t
          > (call-with-input-string "some text" output-port?)
          #f
          > (port? (current-output-port))
          #t

 -- procedure: read [PORT]

     This procedure reads and returns the next Scheme datum from the
     input-port PORT.  The end-of-file object is returned when the end
     of the stream is reached.  If it is not specified, PORT defaults to
     the current input-port.

     For example:

          > (call-with-input-string "some text" read)
          some
          > (call-with-input-string "" read)
          #!eof

 -- procedure: read-all [PORT [READER]]

     This procedure repeatedly calls the procedure READER with PORT as
     the sole argument and accumulates a list of each value returned up
     to the end-of-file object.  The procedure 'read-all' returns the
     accumulated list without the end-of-file object.  If it is not
     specified, PORT defaults to the current input-port.  If it is not
     specified, READER defaults to the procedure 'read'.

     For example:

          > (call-with-input-string "3,2,1\ngo!" read-all)
          (3 ,2 ,1 go!)
          > (call-with-input-string "3,2,1\ngo!"
                                    (lambda (p) (read-all p read-char)))
          (#\3 #\, #\2 #\, #\1 #\newline #\g #\o #\!)
          > (call-with-input-string "3,2,1\ngo!"
                                    (lambda (p) (read-all p read-line)))
          ("3,2,1" "go!")

 -- procedure: write OBJ [PORT]

     This procedure writes the Scheme datum OBJ to the output-port PORT
     and the value returned is unspecified.  If it is not specified,
     PORT defaults to the current output-port.

     For example:

          > (write (list 'compare (list 'quote '@x) 'and (list 'unquote '@x)))
          (compare '@x and , @x)>

 -- procedure: newline [PORT]

     This procedure writes an "object separator" to the output-port PORT
     and the value returned is unspecified.  The separator ensures that
     the next Scheme datum written with the 'write' procedure will not
     be confused with the latest datum that was written.  On
     character-ports this is done by writing the character '#\newline'.
     On ports where successive objects are implicitly distinct (such as
     "vector ports") this procedure does nothing.

     Regardless of the class of a port P and assuming that the external
     textual representation of the object X is readable, the expression
     '(begin (write X P) (newline P))' will write to P a representation
     of X that can be read back with the procedure 'read'.  If it is not
     specified, PORT defaults to the current output-port.

     For example:

          > (begin (write 123) (newline) (write 456) (newline))
          123
          456

 -- procedure: force-output [PORT [LEVEL]]

     The procedure 'force-output' causes the data that was written to
     the output-port PORT to be moved closer to its destination
     according to LEVEL, an exact integer in the range 0 to 2.  If PORT
     is not specified, the current output-port is used.  If LEVEL is not
     specified, it defaults to 0.  Values of LEVEL above 0 are
     equivalent to LEVEL = 0 except for device ports as explained below.

     When LEVEL is 0, the output buffers of PORT which are managed in
     the Scheme process are drained (i.e.  the output operation that was
     delayed due to buffering is actually performed).  In the case of a
     device port the data is passed to the operating system and it
     becomes its responsibility to transmit the data to the device.  The
     operating system may implement its own buffering approach which
     delays the transmission of the data to the device.

     When LEVEL is 1, in addition to the operations for LEVEL = 0 and if
     the operating system supports the functionality, the operating
     system is requested to transmit the data to the device.  On UNIX
     this corresponds to a 'fsync' system call.

     When LEVEL is 2, in addition to the operations for LEVEL = 1 and if
     the operating system supports the functionality, the operating
     system is requested to wait until the device reports that the data
     was saved by the device (e.g.  actually written to disk in the case
     of a file).  This operation can take a long time on some operating
     systems.  On macOS this corresponds to a 'fcntl' system call with
     operation 'F_FULLFSYNC'.

     For example:

          > (define p (open-tcp-client "www.iro.umontreal.ca:80"))
          > (display "GET /\n" p)
          > (force-output p)
          > (read-line p)
          "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\""

 -- procedure: close-input-port PORT
 -- procedure: close-output-port PORT
 -- procedure: close-port PORT

     The PORT argument of these procedures must be a unidirectional or a
     bidirectional port.  For all three procedures the value returned is
     unspecified.

     The procedure 'close-input-port' closes the input-port side of
     PORT, which must not be a unidirectional output-port.

     The procedure 'close-output-port' closes the output-port side of
     PORT, which must not be a unidirectional input-port.  The ouput
     buffers are drained before PORT is closed.

     The procedure 'close-port' closes all sides of the PORT.  Unless
     PORT is a unidirectional input-port, the output buffers are drained
     before PORT is closed.

     For example:

          > (define p (open-tcp-client "www.iro.umontreal.ca:80"))
          > (display "GET /\n" p)
          > (close-output-port p)
          > (read-line p)
          "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\""

 -- procedure: input-port-timeout-set! PORT TIMEOUT [THUNK]
 -- procedure: output-port-timeout-set! PORT TIMEOUT [THUNK]

     When a thread tries to perform an I/O operation on a port, the
     requested operation may not be immediately possible and the thread
     must wait.  For example, the thread may be trying to read a line of
     text from the console and the user has not typed anything yet, or
     the thread may be trying to write to a network connection faster
     than the network can handle.  In such situations the thread
     normally blocks until the operation becomes possible.

     It is sometimes necessary to guarantee that the thread will not
     block too long.  For this purpose, to each input-port and
     output-port is attached a "timeout" and "timeout-thunk".  The
     timeout indicates the point in time beyond which the thread should
     stop waiting on an input and output operation respectively.  When
     the timeout is reached, the thread calls the port's timeout-thunk.
     If the timeout-thunk returns '#f' the thread abandons trying to
     perform the operation (in the case of an input operation an
     end-of-file is read and in the case of an output operation an
     exception is raised).  Otherwise, the thread will block again
     waiting for the operation to become possible (note that if the
     port's timeout has not changed the thread will immediately call the
     timeout-thunk again).

     The procedure 'input-port-timeout-set!' sets the timeout of the
     input-port PORT to TIMEOUT and the timeout-thunk to THUNK.  The
     procedure 'output-port-timeout-set!' sets the timeout of the
     output-port PORT to TIMEOUT and the timeout-thunk to THUNK.  If it
     is not specified, the THUNK defaults to a thunk that returns '#f'.
     The TIMEOUT is either a time object indicating an absolute point in
     time, or it is a real number which indicates the number of seconds
     relative to the moment the procedure is called.  For both
     procedures the value returned is unspecified.

     When a port is created the timeout is set to infinity ('+inf.0').
     This causes the thread to wait as long as needed for the operation
     to become possible.  Setting the timeout to a point in the past
     ('-inf.0') will cause the thread to attempt the I/O operation and
     never block (i.e.  the timeout-thunk is called if the operation is
     not immediately possible).

     The following example shows how to cause the REPL to terminate when
     the user does not enter an expression within the next 60 seconds.

          > (input-port-timeout-set! (repl-input-port) 60)
          >
          *** EOF again to exit


File: gambit.info,  Node: Character-ports,  Next: Byte-ports,  Prev: Object-ports,  Up: I/O and ports

14.5 Character-ports
====================

* Menu:

* Character-port settings::          Character-port settings
* Character-port operations::        Character-port operations


File: gambit.info,  Node: Character-port settings,  Next: Character-port operations,  Prev: Character-ports,  Up: Character-ports

14.5.1 Character-port settings
------------------------------

The following is a list of port settings that are valid for
character-ports.

   * 'readtable:' READTABLE

     This setting determines the readtable attached to the
     character-port.  To set each direction separately the keywords
     'input-readtable:' and 'output-readtable:' must be used instead of
     'readtable:'.  Readtables control the external textual
     representation of Scheme objects, that is the encoding of Scheme
     objects using characters.  The behavior of the 'read' procedure
     depends on the port's input-readtable and the behavior of the
     procedures 'write', 'pretty-print', and related procedures is
     affected by the port's output-readtable.  The default value of this
     setting is the value bound to the parameter object
     'current-readtable'.

   * 'output-width:' POSITIVE-INTEGER

     This setting indicates the width of the character output-port in
     number of characters.  This information is used by the
     pretty-printer.  The default value of this setting is 80.


File: gambit.info,  Node: Character-port operations,  Prev: Character-port settings,  Up: Character-ports

14.5.2 Character-port operations
--------------------------------

 -- procedure: input-port-line PORT
 -- procedure: input-port-column PORT
 -- procedure: output-port-line PORT
 -- procedure: output-port-column PORT

     The current character location of a character input-port is the
     location of the next character to read.  The current character
     location of a character output-port is the location of the next
     character to write.  Location is denoted by a line number (the
     first line is line 1) and a column number, that is the location on
     the current line (the first column is column 1).  The procedures
     'input-port-line' and 'input-port-column' return the line location
     and the column location respectively of the character input-port
     PORT.  The procedures 'output-port-line' and 'output-port-column'
     return the line location and the column location respectively of
     the character output-port PORT.

     For example:

          > (call-with-output-string
              (lambda (p)
                (display "abc\n123def" p)
                (write (list (output-port-line p) (output-port-column p))
                       p)))
          "abc\n123def(2 7)"

 -- procedure: output-port-width PORT

     This procedure returns the width, in characters, of the character
     output-port PORT.  The value returned is the port's output-width
     setting.

     For example:

          > (output-port-width (repl-output-port))
          80

 -- procedure: read-char [PORT]

     This procedure reads the character input-port PORT and returns the
     character at the current character location and advances the
     current character location to the next character, unless the PORT
     is already at end-of-file in which case 'read-char' returns the
     end-of-file object.  If it is not specified, PORT defaults to the
     current input-port.

     For example:

          > (call-with-input-string
              "some text"
              (lambda (p)
                (let ((a (read-char p))) (list a (read-char p)))))
          (#\s #\o)
          > (call-with-input-string "" read-char)
          #!eof

 -- procedure: peek-char [PORT]

     This procedure returns the same result as 'read-char' but it does
     not advance the current character location of the input-port PORT.
     If it is not specified, PORT defaults to the current input-port.

     For example:

          > (call-with-input-string
              "some text"
              (lambda (p)
                (let ((a (peek-char p))) (list a (read-char p)))))
          (#\s #\s)
          > (call-with-input-string "" peek-char)
          #!eof

 -- procedure: write-char CHAR [PORT]

     This procedure writes the character CHAR to the character
     output-port PORT and advances the current character location of
     that output-port.  The value returned is unspecified.  If it is not
     specified, PORT defaults to the current output-port.

     For example:

          > (write-char #\=)
          =>

 -- procedure: read-line [PORT [SEPARATOR [INCLUDE-SEPARATOR?
          [MAX-LENGTH]]]]

     This procedure reads characters from the character input-port PORT
     until a specific SEPARATOR or the end-of-file is encountered and
     returns a string containing the sequence of characters read.  If it
     is specified, MAX-LENGTH must be a nonnegative exact integer and it
     places an upper limit on the number of characters that are read.

     The SEPARATOR is included at the end of the string only if it was
     the last character read and INCLUDE-SEPARATOR? is not '#f'.  The
     SEPARATOR must be a character or '#f' (in which case all the
     characters until the end-of-file are read).  If it is not
     specified, PORT defaults to the current input-port.  If it is not
     specified, SEPARATOR defaults to '#\newline'.  If it is not
     specified, INCLUDE-SEPARATOR? defaults to '#f'.

     For example:

          > (define (split sep)
              (lambda (str)
                (call-with-input-string
                  str
                  (lambda (p)
                    (read-all p (lambda (p) (read-line p sep)))))))
          > ((split #\,) "a,b,c")
          ("a" "b" "c")
          > (map (split #\,)
                 (call-with-input-string "1,2,3\n4,5"
                                         (lambda (p) (read-all p read-line))))
          (("1" "2" "3") ("4" "5"))
          > (read-line (current-input-port) #\newline #f 2)1234
          "12"
          > 34

 -- procedure: read-substring STRING START END [PORT [NEED]]
 -- procedure: write-substring STRING START END [PORT]

     These procedures support bulk character I/O. The part of the string
     STRING starting at index START and ending just before index END is
     used as a character buffer that will be the target of
     'read-substring' or the source of the 'write-substring'.  The
     'read-substring' also accepts a NEED parameter which must be a
     nonnegative fixnum.  Up to END-START characters will be
     transferred.  The number of characters transferred, possibly zero,
     is returned by these procedures.  Fewer characters will be read by
     'read-substring' if an end-of-file is read, or a timeout occurs
     before all the requested characters are transferred and the timeout
     thunk returns '#f' (see the procedure 'input-port-timeout-set!'),
     or NEED is specified and at least that many characters have been
     read (in other words the procedure does not block for more
     characters but may transfer more characters if they are immediately
     available).  Fewer characters will be written by 'write-substring'
     if a timeout occurs before all the requested characters are
     transferred and the timeout thunk returns '#f' (see the procedure
     'output-port-timeout-set!').  If it is not specified, PORT defaults
     to the current input-port and current output-port respectively.

     For example:

          > (define s (make-string 10 #\x))
          > (read-substring s 2 5)123456789
          3
          > 456789
          > s
          "xx123xxxxx"
          > (read-substring s 2 10 (current-input-port) 3)abcd
          5
          > s
          "xxabcd\nxxx"

 -- procedure: input-port-readtable PORT
 -- procedure: output-port-readtable PORT

     These procedures return the readtable attached to the
     character-port PORT.  The PORT parameter of 'input-port-readtable'
     must be an input-port.  The PORT parameter of
     'output-port-readtable' must be an output-port.

 -- procedure: input-port-readtable-set! PORT READTABLE
 -- procedure: output-port-readtable-set! PORT READTABLE

     These procedures change the readtable attached to the
     character-port PORT to the readtable READTABLE.  The PORT parameter
     of 'input-port-readtable-set!' must be an input-port.  The PORT
     parameter of 'output-port-readtable-set!' must be an output-port.
     The value returned is unspecified.


File: gambit.info,  Node: Byte-ports,  Next: Device-ports,  Prev: Character-ports,  Up: I/O and ports

14.6 Byte-ports
===============

* Menu:

* Byte-port settings::               Byte-port settings
* Byte-port operations::             Byte-port operations


File: gambit.info,  Node: Byte-port settings,  Next: Byte-port operations,  Prev: Byte-ports,  Up: Byte-ports

14.6.1 Byte-port settings
-------------------------

The following is a list of port settings that are valid for byte-ports.

   * 'char-encoding:' ENCODING

     This setting controls the character encoding of the byte-port.  For
     bidirectional byte-ports, the character encoding for input and
     output is set.  To set each direction separately the keywords
     'input-char-encoding:' and 'output-char-encoding:' must be used
     instead of 'char-encoding:'.  The default value of this setting
     depends on how the runtime system was configured but typically
     UTF-8 is used.  The default can be overridden through various
     runtime options (*note Runtime options::), such as
     '-:file-settings=...' and '-:io-settings=...'.  The following
     encodings are supported:

     'ISO-8859-1'
          ISO-8859-1 character encoding.  Each character is encoded by a
          single byte.  Only Unicode characters with a code in the range
          0 to 255 are allowed.

     'ASCII'
          ASCII character encoding.  Each character is encoded by a
          single byte.  In principle only Unicode characters with a code
          in the range 0 to 127 are allowed but most types of ports
          treat this exactly like 'ISO-8859-1'.

     'UTF-8'
          UTF-8 character encoding.  Each character is encoded by a
          sequence of one to four bytes.  The minimum length UTF-8
          encoding is used.  If a BOM is needed at the beginning of the
          stream then it must be explicitly written.

     'UTF-16'
          UTF-16 character encoding.  Each character is encoded by one
          or two 16 bit integers (2 or 4 bytes).  The 16 bit integers
          may be encoded using little-endian encoding or big-endian
          encoding.  If the port is an input-port and the first two
          bytes read are a BOM ("Byte Order Mark" character with
          hexadecimal code FEFF) then the BOM will be discarded and the
          endianness will be set accordingly, otherwise the endianness
          depends on the operating system and how the Gambit runtime was
          compiled.  If the port is an output-port then a BOM will be
          output at the beginning of the stream and the endianness
          depends on the operating system and how the Gambit runtime was
          compiled.

     'UTF-16LE'
          UTF-16 character encoding with little-endian endianness.  It
          is like 'UTF-16' except the endianness is set to little-endian
          and there is no BOM processing.  If a BOM is needed at the
          beginning of the stream then it must be explicitly written.

     'UTF-16BE'
          UTF-16 character encoding with big-endian endianness.  It is
          like 'UTF-16LE' except the endianness is set to big-endian.

     'UTF / UTF-fallback-ASCII / UTF-fallback-ISO-8859-1 / UTF-fallback-UTF-16 / UTF-fallback-UTF-16LE / UTF-fallback-UTF-16BE'
          These encodings combine the UTF-8 and UTF-16 encodings.  When
          one of these character encodings is used for an output port,
          characters will be encoded using the UTF-8 encoding.  The
          first character, if there is one, is prefixed with a UTF-8 BOM
          (the three byte sequence EF BB BF in hexadecimal).  When one
          of these character encodings is used for an input port, the
          character encoding depends on the first few bytes.  If the
          first bytes of the stream are a UTF-16LE BOM (FF FE in
          hexadecimal), or a UTF-16BE BOM (FE FF in hexadecimal), or a
          UTF-8 BOM (EF BB BF in hexadecimal), then the BOM is discarded
          and the remaining bytes of the stream are decoded using the
          corresponding character encoding.  If a BOM is not present,
          then the stream is decoded using the fallback encoding
          specified.  The encoding 'UTF' is a synonym for
          'UTF-fallback-UTF-8'.  Note that the 'UTF' character encoding
          for input will correctly handle streams produced using the
          encodings 'UTF', 'UTF-8', 'UTF-16', 'ASCII', and if an
          explicit BOM is output, the encodings 'UTF-16LE', and
          'UTF-16BE'.

     'UCS-2'
          UCS-2 character encoding.  Each character is encoded by a 16
          bit integer (2 bytes).  The 16 bit integers may be encoded
          using little-endian encoding or big-endian encoding.  If the
          port is an input-port and the first two bytes read are a BOM
          ("Byte Order Mark" character with hexadecimal code FEFF) then
          the BOM will be discarded and the endianness will be set
          accordingly, otherwise the endianness depends on the operating
          system and how the Gambit runtime was compiled.  If the port
          is an output-port then a BOM will be output at the beginning
          of the stream and the endianness depends on the operating
          system and how the Gambit runtime was compiled.

     'UCS-2LE'
          UCS-2 character encoding with little-endian endianness.  It is
          like 'UCS-2' except the endianness is set to little-endian and
          there is no BOM processing.  If a BOM is needed at the
          beginning of the stream then it must be explicitly written.

     'UCS-2BE'
          UCS-2 character encoding with big-endian endianness.  It is
          like 'UCS-2LE' except the endianness is set to big-endian.

     'UCS-4'
          UCS-4 character encoding.  Each character is encoded by a 32
          integer (4 bytes).  The 32 bit integers may be encoded using
          little-endian encoding or big-endian encoding.  If the port is
          an input-port and the first four bytes read are a BOM ("Byte
          Order Mark" character with hexadecimal code 0000FEFF) then the
          BOM will be discarded and the endianness will be set
          accordingly, otherwise the endianness depends on the operating
          system and how the Gambit runtime was compiled.  If the port
          is an output-port then a BOM will be output at the beginning
          of the stream and the endianness depends on the operating
          system and how the Gambit runtime was compiled.

     'UCS-4LE'
          UCS-4 character encoding with little-endian endianness.  It is
          like 'UCS-4' except the endianness is set to little-endian and
          there is no BOM processing.  If a BOM is needed at the
          beginning of the stream then it must be explicitly written.

     'UCS-4BE'
          UCS-4 character encoding with big-endian endianness.  It is
          like 'UCS-4LE' except the endianness is set to big-endian.

   * 'char-encoding-errors:' ( '#f' | '#t' )

     This setting controls whether illegal character encodings are
     silently replaced with the Unicode character #xfffd (replacement
     character) or raise an error.  To set each direction separately the
     keywords 'input-char-encoding-errors:' and
     'output-char-encoding-errors:' must be used instead of
     'char-encoding-errors:'.  The default value of this setting is
     '#t'.

   * 'eol-encoding:' ENCODING

     This setting controls the end-of-line encoding of the byte-port.
     To set each direction separately the keywords 'input-eol-encoding:'
     and 'output-eol-encoding:' must be used instead of 'eol-encoding:'.
     The default value of this setting is operating system dependent,
     but this can be overridden through the runtime options (*note
     Runtime options::).  Note that for output-ports the end-of-line
     encoding is applied before the character encoding, and for
     input-ports it is applied after.  The following encodings are
     supported:

     'lf'
          For an output-port, writing a '#\newline' character outputs a
          '#\linefeed' character to the stream (Unicode character code
          10).  For an input-port, a '#\newline' character is read when
          a '#\linefeed' character is encountered on the stream.  Note
          that '#\linefeed' and '#\newline' are two names for the same
          character, so this end-of-line encoding is actually the
          identity function.  Text files created by UNIX applications
          typically use this end-of-line encoding.

     'cr'
          For an output-port, writing a '#\newline' character outputs a
          '#\return' character to the stream (Unicode character code
          13).  For an input-port, a '#\newline' character is read when
          a '#\linefeed' character or a '#\return' character is
          encountered on the stream.  Text files created by Classic Mac
          OS applications typically use this end-of-line encoding.

     'cr-lf'
          For an output-port, writing a '#\newline' character outputs to
          the stream a '#\return' character followed by a '#\linefeed'
          character.  For an input-port, a '#\newline' character is read
          when a '#\linefeed' character or a '#\return' character is
          encountered on the stream.  Moreover, if this character is
          immediately followed by the opposite character ('#\linefeed'
          followed by '#\return' or '#\return' followed by '#\linefeed')
          then the second character is ignored.  In other words, all
          four possible end-of-line encodings are read as a single
          '#\newline' character.  Text files created by DOS and
          Microsoft Windows applications typically use this end-of-line
          encoding.


File: gambit.info,  Node: Byte-port operations,  Prev: Byte-port settings,  Up: Byte-ports

14.6.2 Byte-port operations
---------------------------

 -- procedure: read-u8 [PORT]
 -- procedure: peek-u8 [PORT]

     These procedures read the byte input-port PORT and return the byte
     at the current byte location unless the PORT is already at
     end-of-file in which case the end-of-file object is returned.  If
     the end-of-file is not reached then the procedure 'read-u8'
     advances the current byte location to the next byte.  The procedure
     'peek-u8' does not advance the port's current byte location.  If it
     is not specified, PORT defaults to the current input-port.

     One way to ensure that the port's input character buffer is empty
     is to call 'peek-u8' strictly before any use of the port in a
     character input operation (i.e.  a call to the procedures 'read',
     'read-char', 'peek-char', etc).  Alternatively
     'input-port-characters-buffered' can be used to get the number of
     characters in the port's input character buffer, and to empty the
     buffer with calls to 'read-char' or 'read-substring'.

     For example:

          > (call-with-input-u8vector
              '#u8(11 22 33 44)
              (lambda (p)
                (let ((a (read-u8 p))) (list a (read-u8 p)))))
          (11 22)
          > (call-with-input-u8vector '#u8() read-u8)
          #!eof
          > (with-input-from-u8vector '#u8(1 5) (lambda () (+ (peek-u8) (peek-u8))))
          2

 -- procedure: write-u8 N [PORT]

     This procedure writes the byte N to the byte output-port PORT and
     advances the current byte location of that output-port.  The value
     returned is unspecified.  If it is not specified, PORT defaults to
     the current output-port.

     For example:

          > (call-with-output-u8vector (lambda (p) (write-u8 33 p)))
          #u8(33)

 -- procedure: read-subu8vector U8VECTOR START END [PORT [NEED]]
 -- procedure: write-subu8vector U8VECTOR START END [PORT]

     These procedures support bulk byte I/O. The part of the u8vector
     U8VECTOR starting at index START and ending just before index END
     is used as a byte buffer that will be the target of
     'read-subu8vector' or the source of the 'write-subu8vector'.  The
     'read-subu8vector' also accepts a NEED parameter which must be a
     nonnegative fixnum.  Up to END-START bytes will be transferred.
     The number of bytes transferred, possibly zero, is returned by
     these procedures.  Fewer bytes will be read by 'read-subu8vector'
     if an end-of-file is read, or a timeout occurs before all the
     requested bytes are transferred and the timeout thunk returns '#f'
     (see the procedure 'input-port-timeout-set!'), or NEED is specified
     and at least that many bytes have been read (in other words the
     procedure does not block for more bytes but may transfer more bytes
     if they are immediately available).  Fewer bytes will be written by
     'write-subu8vector' if a timeout occurs before all the requested
     bytes are transferred and the timeout thunk returns '#f' (see the
     procedure 'output-port-timeout-set!').  If it is not specified,
     PORT defaults to the current input-port and current output-port
     respectively.

     The procedure 'read-subu8vector' must be called before any use of
     the port in a character input operation (i.e.  a call to the
     procedures 'read', 'read-char', 'peek-char', etc) because otherwise
     the character-stream and byte-stream may be out of sync due to the
     port buffering.

     For example:

          > (define v (make-u8vector 10))
          > (read-subu8vector v 2 5)123456789
          3
          > 456789
          > v
          #u8(0 0 49 50 51 0 0 0 0 0)
          > (read-subu8vector v 2 10 (current-input-port) 3)abcd
          5
          > v
          #u8(0 0 97 98 99 100 10 0 0 0)


File: gambit.info,  Node: Device-ports,  Next: Directory-ports,  Prev: Byte-ports,  Up: I/O and ports

14.7 Device-ports
=================

* Menu:

* Filesystem devices::            Filesystem devices
* Process devices::               Process devices
* Network devices::               Network devices


File: gambit.info,  Node: Filesystem devices,  Next: Process devices,  Prev: Device-ports,  Up: Device-ports

14.7.1 Filesystem devices
-------------------------

 -- procedure: open-file PATH-OR-SETTINGS
 -- procedure: open-input-file PATH-OR-SETTINGS
 -- procedure: open-output-file PATH-OR-SETTINGS
 -- procedure: call-with-input-file PATH-OR-SETTINGS PROC
 -- procedure: call-with-output-file PATH-OR-SETTINGS PROC
 -- procedure: with-input-from-file PATH-OR-SETTINGS THUNK
 -- procedure: with-output-to-file PATH-OR-SETTINGS THUNK

     All of these procedures create a port to interface to a byte-stream
     device (such as a file, console, serial port, named pipe, etc)
     whose name is given by a path of the filesystem.  The 'direction:'
     setting will default to the value 'input' for the procedures
     'open-input-file', 'call-with-input-file' and
     'with-input-from-file', to the value 'output' for the procedures
     'open-output-file', 'call-with-output-file' and
     'with-output-to-file', and to the value 'input-output' for the
     procedure 'open-file'.

     The procedures 'open-file', 'open-input-file' and
     'open-output-file' return the port that is created.  The procedures
     'call-with-input-file' and 'call-with-output-file' call the
     procedure PROC with the port as single argument, and then return
     the value(s) of this call after closing the port.  The procedures
     'with-input-from-file' and 'with-output-to-file' dynamically bind
     the current input-port and current output-port respectively to the
     port created for the duration of a call to the procedure THUNK with
     no argument.  The value(s) of the call to THUNK are returned after
     closing the port.

     The first argument of these procedures is either a string denoting
     a filesystem path or a list of port settings which must contain a
     'path:' setting.  Here are the settings allowed in addition to the
     generic settings of byte-ports:

        * 'path:' STRING

          This setting indicates the location of the file in the
          filesystem.  There is no default value for this setting.

        * 'append:' ( '#f' | '#t' )

          This setting controls whether output will be added to the end
          of the file.  This is useful for writing to log files that
          might be open by more than one process.  The default value of
          this setting is '#f'.

        * 'create:' ( '#f' | '#t' | 'maybe' )

          This setting controls whether the file will be created when it
          is opened.  A setting of '#f' requires that the file exist
          (otherwise an exception is raised).  A setting of '#t'
          requires that the file does not exist (otherwise an exception
          is raised).  A setting of 'maybe' will create the file if it
          does not exist.  The default value of this setting is 'maybe'
          for output-ports and '#f' for input-ports and bidirectional
          ports.

        * 'permissions:' 12-BIT-EXACT-INTEGER

          This setting controls the UNIX permissions that will be
          attached to the file if it is created.  The default value of
          this setting is '#o666'.

        * 'truncate:' ( '#f' | '#t' )

          This setting controls whether the file will be truncated when
          it is opened.  For input-ports and bidirectional ports, the
          default value of this setting is '#f'.  For output-ports, the
          default value of this setting is '#t' when the 'append:'
          setting is '#f', and '#f' otherwise.

     For example:

          > (with-output-to-file
              (list path: "nofile"
                    create: #f)
              (lambda ()
                (display "hello world!\n")))
          *** ERROR IN (console)@1.1 -- No such file or directory
          (with-output-to-file '(path: "nofile" create: #f) '#<procedure #2>)

 -- procedure: input-port-byte-position PORT [POSITION [WHENCE]]
 -- procedure: output-port-byte-position PORT [POSITION [WHENCE]]

     When called with a single argument these procedures return the byte
     position where the next I/O operation would take place in the file
     attached to the given PORT (relative to the beginning of the file).
     When called with two or three arguments, the byte position for
     subsequent I/O operations on the given PORT is changed to POSITION,
     which must be an exact integer.  When WHENCE is omitted or is 0,
     the POSITION is relative to the beginning of the file.  When WHENCE
     is 1, the POSITION is relative to the current byte position of the
     file.  When WHENCE is 2, the POSITION is relative to the end of the
     file.  The return value is the new byte position.  On most
     operating systems the byte position for reading and writing of a
     given bidirectional port are the same.

     When 'input-port-byte-position' is called to change the byte
     position of an input-port, all input buffers will be flushed so
     that the next byte read will be the one at the given position.

     When 'output-port-byte-position' is called to change the byte
     position of an output-port, there is an implicit call to
     'force-output' before the position is changed.

     For example:

          > (define p  ; p is an input-output-port
              (open-file '(path: "test" char-encoding: ISO-8859-1 create: maybe)))
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (0 0)
          > (display "abcdefghij\n" p)
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (0 0)
          > (force-output p)
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (11 11)
          > (input-port-byte-position p 2)
          2
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (2 2)
          > (peek-char p)
          #\c
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (11 11)
          > (output-port-byte-position p -7 2)
          4
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (4 4)
          > (write-char #\! p)
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (4 4)
          > (force-output p)
          > (list (input-port-byte-position p) (output-port-byte-position p))
          (5 5)
          > (input-port-byte-position p 1)
          1
          > (read p)
          bcd!fghij


File: gambit.info,  Node: Process devices,  Next: Network devices,  Prev: Filesystem devices,  Up: Device-ports

14.7.2 Process devices
----------------------

 -- procedure: open-process PATH-OR-SETTINGS
 -- procedure: open-input-process PATH-OR-SETTINGS
 -- procedure: open-output-process PATH-OR-SETTINGS
 -- procedure: call-with-input-process PATH-OR-SETTINGS PROC
 -- procedure: call-with-output-process PATH-OR-SETTINGS PROC
 -- procedure: with-input-from-process PATH-OR-SETTINGS THUNK
 -- procedure: with-output-to-process PATH-OR-SETTINGS THUNK

     All of these procedures start a new operating system process and
     create a bidirectional port which allows communication with that
     process on its standard input and standard output.  The
     'direction:' setting will default to the value 'input' for the
     procedures 'open-input-process', 'call-with-input-process' and
     'with-input-from-process', to the value 'output' for the procedures
     'open-output-process', 'call-with-output-process' and
     'with-output-to-process', and to the value 'input-output' for the
     procedure 'open-process'.  If the 'direction:' setting is 'input',
     the output-port side is closed.  If the 'direction:' setting is
     'output', the input-port side is closed.

     The procedures 'open-process', 'open-input-process' and
     'open-output-process' return the port that is created.  The
     procedures 'call-with-input-process' and 'call-with-output-process'
     call the procedure PROC with the port as single argument, and then
     return the value(s) of this call after closing the port and waiting
     for the process to terminate.  The procedures
     'with-input-from-process' and 'with-output-to-process' dynamically
     bind the current input-port and current output-port respectively to
     the port created for the duration of a call to the procedure THUNK
     with no argument.  The value(s) of the call to THUNK are returned
     after closing the port and waiting for the process to terminate.

     The first argument of this procedure is either a string denoting a
     filesystem path of an executable program or a list of port settings
     which must contain a 'path:' setting.  Here are the settings
     allowed in addition to the generic settings of byte-ports:

        * 'path:' STRING

          This setting indicates the location of the executable program
          in the filesystem.  There is no default value for this
          setting.

        * 'arguments:' LIST-OF-STRINGS

          This setting indicates the string arguments that are passed to
          the program.  The default value of this setting is the empty
          list (i.e.  no arguments).

        * 'environment:' LIST-OF-STRINGS

          This setting indicates the set of environment variable
          bindings that the process receives.  Each element of the list
          is a string of the form "'VAR=VALUE'", where 'VAR' is the name
          of the variable and 'VALUE' is its binding.  When
          LIST-OF-STRINGS is '#f', the process inherits the environment
          variable bindings of the Scheme program.  The default value of
          this setting is '#f'.

        * 'directory:' DIR

          This setting indicates the current working directory of the
          process.  When DIR is '#f', the process uses the value of
          '(current-directory)'.  The default value of this setting is
          '#f'.

        * 'stdin-redirection:' ( '#f' | '#t' )

          This setting indicates how the standard input of the process
          is redirected.  A setting of '#t' will redirect the standard
          input from the process-port (i.e.  what is written to the
          process-port will be available on the standard input).  A
          setting of '#f' will leave the standard input as-is, which
          typically results in input coming from the console.  The
          default value of this setting is '#t'.

        * 'stdout-redirection:' ( '#f' | '#t' )

          This setting indicates how the standard output of the process
          is redirected.  A setting of '#t' will redirect the standard
          output to the process-port (i.e.  all output to standard
          output can be read from the process-port).  A setting of '#f'
          will leave the standard output as-is, which typically results
          in the output going to the console.  The default value of this
          setting is '#t'.

        * 'stderr-redirection:' ( '#f' | '#t' )

          This setting indicates how the standard error of the process
          is redirected.  A setting of '#t' will redirect the standard
          error to the process-port (i.e.  all output to standard error
          can be read from the process-port).  A setting of '#f' will
          leave the standard error as-is, which typically results in
          error messages being output to the console.  The default value
          of this setting is '#f'.

        * 'pseudo-terminal:' ( '#f' | '#t' )

          This setting applies to UNIX. It indicates what type of device
          will be bound to the process' standard input and standard
          output.  A setting of '#t' will use a pseudo-terminal device
          (this is a device that behaves like a tty device even though
          there is no real terminal or user directly involved).  A
          setting of '#f' will use a pair of pipes.  The difference is
          important for programs which behave differently when they are
          used interactively, for example shells.  The default value of
          this setting is '#f'.

        * 'show-console:' ( '#f' | '#t' )

          This setting applies to Microsoft Windows.  It controls
          whether the process' console window will be hidden or visible.
          The default value of this setting is '#t' (i.e.  show the
          console window).

     For example:

          > (with-input-from-process "date" read-line)
          "Sun Jun 14 15:06:41 EDT 2009"
          > (define p (open-process (list path: "ls"
                                          arguments: '("../examples"))))
          > (read-line p)
          "README"
          > (read-line p)
          "Xlib-simple"
          > (close-port p)
          > (define p (open-process "/usr/bin/dc"))
          > (display "2 100 ^ p\n" p)
          > (force-output p)
          > (read-line p)
          "1267650600228229401496703205376"

 -- procedure: process-pid PROCESS-PORT

     This procedure returns the PID (Process Identifier) of the process
     of PROCESS-PORT.  The PID is a small exact integer.

     For example:

          > (let ((p (open-process "sort")))
              (process-pid p))
          318

 -- procedure: process-status PROCESS-PORT [TIMEOUT [TIMEOUT-VAL]]

     This procedure causes the current thread to wait until the process
     of PROCESS-PORT terminates (normally or not) or until the timeout
     is reached if TIMEOUT is supplied.  If the timeout is reached,
     PROCESS-STATUS returns TIMEOUT-VAL if it is supplied, otherwise an
     unterminated-process-exception object is raised.  The procedure
     returns the process exit status as encoded by the operating system.
     Typically, if the process exited normally the return value is the
     process exit status multiplied by 256.

     For example:

          > (let ((p (open-process "sort")))
              (for-each (lambda (x) (pretty-print x p))
                        '(22 11 33))
              (close-output-port p)
              (let ((r (read-all p)))
                (close-input-port p)
                (list (process-status p) r)))
          (0 (11 22 33))

 -- procedure: unterminated-process-exception? OBJ
 -- procedure: unterminated-process-exception-procedure EXC
 -- procedure: unterminated-process-exception-arguments EXC

     Unterminated-process-exception objects are raised when a call to
     the 'process-status' procedure reaches its timeout before the
     target process terminates and a timeout-value parameter is not
     specified.  The parameter EXC must be an
     unterminated-process-exception object.

     The procedure 'unterminated-process-exception?' returns '#t' when
     OBJ is an unterminated-process-exception object and '#f' otherwise.

     The procedure 'unterminated-process-exception-procedure' returns
     the procedure that raised EXC.

     The procedure 'unterminated-process-exception-arguments' returns
     the list of arguments of the procedure that raised EXC.

     For example:

          > (define (handler exc)
              (if (unterminated-process-exception? exc)
                  (list (unterminated-process-exception-procedure exc)
                        (unterminated-process-exception-arguments exc))
                  'not-unterminated-process-exception))
          > (with-exception-catcher
              handler
              (lambda ()
                (let ((p (open-process "sort")))
                  (process-status p 1))))
          (#<procedure #2 process-status> (#<input-output-port #3 (process "sort")>))


File: gambit.info,  Node: Network devices,  Prev: Process devices,  Up: Device-ports

14.7.3 Network devices
----------------------

 -- procedure: open-tcp-client PORT-NUMBER-OR-ADDRESS-OR-SETTINGS

     This procedure opens a network connection to a socket server and
     returns a tcp-client-port (a subtype of device-port) that
     represents this connection and allows communication with that
     server.  The default value of the 'direction:' setting is
     'input-output', i.e.  the Scheme program can send information to
     the server and receive information from the server.  The sending
     direction can be "shutdown" using the 'close-output-port' procedure
     and the receiving direction can be "shutdown" using the
     'close-input-port' procedure.  The 'close-port' procedure closes
     both directions of the connection.

     The parameter of this procedure is an IP port number (16-bit
     nonnegative exact integer), a string of the form '"HOST:PORT"' or a
     list of port settings.  When the parameter is the number PORT it is
     handled as if it was the setting 'port-number:' PORT.  When the
     parameter is the string '"HOST:PORT"' it is handled as if it was
     the setting 'address:' '"HOST:PORT"'.

     Here are the settings allowed in addition to the generic settings
     of byte-ports:

        * 'address:' STRING-OR-IP-ADDRESS

          This setting indicates the internet address of the server, and
          possibly the IP port number.  When this parameter is not
          specified or is '""', the connection requests are sent to the
          loopback interface (with IP address 127.0.0.1).  The parameter
          can be a string denoting a host name, which will be translated
          to an IP address by the 'host-info' procedure, or a 4 element
          u8vector which contains the 32-bit IPv4 address or an 8
          element u16vector which contains the 128-bit IPv6 address.  A
          string of the form '"HOST:PORT"' is handled as if it was the
          combination of settings 'address:' '"HOST"' 'port-number:'
          PORT.

        * 'port-number:' 16-BIT-EXACT-INTEGER

          This setting indicates the IP port number of the server to
          connect to (e.g.  80 for the standard HTTP server, 23 for the
          standard telnet server).  There is no default value for this
          setting.

        * 'local-address:' STRING-OR-IP-ADDRESS

          This setting indicates the internet address of the local
          network interface on which connections requests are initiated,
          and possibly the IP port number.  When this parameter is not
          specified or is '"*"', the connection requests are initiated
          on any network interface (i.e.  address INADDR_ANY). When this
          parameter is '""', the connection requests are initiated only
          on the loopback interface (with IP address 127.0.0.1).  The
          parameter can be a string denoting a host name, which will be
          translated to an IP address by the 'host-info' procedure, or a
          4 element u8vector which contains the 32-bit IPv4 address or
          an 8 element u16vector which contains the 128-bit IPv6
          address.  A string of the form '"INTF:PORT"' is handled as if
          it was the combination of settings 'local-address:' '"INTF"'
          'local-port-number:' PORT.

        * 'local-port-number:' 16-BIT-EXACT-INTEGER

          This setting indicates the IP port number assigned to the
          socket which initiates connection requests.  The special value
          0 requests that a currently unused port number be assigned to
          the socket.  This is the default value for this setting.

        * 'keep-alive:' ( '#f' | '#t' )

          This setting controls the use of the "keep alive" option on
          the connection.  The "keep alive" option will periodically
          send control packets on otherwise idle network connections to
          ensure that the server host is active and reachable.  The
          default value of this setting is '#f'.

        * 'coalesce:' ( '#f' | '#t' )

          This setting controls the use of TCP's "Nagle algorithm" which
          reduces the number of small packets by delaying their
          transmission and coalescing them into larger packets.  A
          setting of '#t' will coalesce small packets into larger ones.
          A setting of '#f' will transmit packets as soon as possible.
          The default value of this setting is '#t'.  Note that this
          setting does not affect the buffering of the port.

        * 'tls-context:' ( '#f' | TLS-CONTEXT )

          This setting controls the use of TLS encryption.  If provided,
          the client will use this configuration for setting up a TCP
          connection with TLS encryption, otherwise it will use a plain
          TCP connection as usual.  Please note that Gambit must be
          compiled with TLS support for this option to be implemented.
          See 'make-tls-context' for futher information.  The default
          value of this setting is '#f'.

     Below is an example of the client-side code that opens a connection
     to an HTTP server on port 8080 of the loopback interface (with IP
     address 127.0.0.1).  For the server-side code see the example for
     the procedure 'open-tcp-server'.

          > (define p (open-tcp-client (list port-number: 8080
                                             eol-encoding: 'cr-lf)))
          > p
          #<input-output-port #2 (tcp-client #u8(127 0 0 1) 8080)>
          > (display "GET /\n" p)
          > (force-output p)
          > (read-line p)
          "<HTML>"

 -- procedure: open-tcp-server PORT-NUMBER-OR-ADDRESS-OR-SETTINGS

     This procedure sets up a socket to accept network connection
     requests from clients and returns a tcp-server-port from which
     network connections to clients are obtained.  Tcp-server-ports are
     a direct subtype of object-ports (i.e.  they are not
     character-ports) and are input-ports.  Reading from a
     tcp-server-port with the 'read' procedure will block until a
     network connection request is received from a client.  The 'read'
     procedure will then return a tcp-client-port (a subtype of
     device-port) that represents this connection and allows
     communication with that client.  Closing a tcp-server-port with
     either the 'close-input-port' or 'close-port' procedures will cause
     the network subsystem to stop accepting connections on that socket.

     The parameter of this procedure is an IP port number (16-bit
     nonnegative exact integer), a string of the form '"INTF:PORT"' or a
     list of port settings which must contain a 'local-port-number:'
     setting.  When the parameter is the number PORT it is handled as if
     it was the setting 'local-port-number:' PORT.  When the parameter
     is the string '"INTF:PORT"' it is handled as if it was the setting
     'local-address:' '"INTF:PORT"'.

     Below is a list of the settings allowed in addition to the settings
     'keep-alive:' and 'coalesce:' allowed by the 'open-tcp-client'
     procedure and the generic settings of byte-ports.  The settings
     which are not listed below apply to the tcp-client-port that is
     returned by 'read' when a connection is accepted and have the same
     meaning as if they were used in a call to the 'open-tcp-client'
     procedure.

        * 'local-address:' STRING-OR-IP-ADDRESS

          This setting indicates the internet address of the local
          network interface on which connections requests are accepted,
          and possibly the IP port number.  When this parameter is not
          specified or is '""', the connection requests are accepted
          only on the loopback interface (with IP address 127.0.0.1).
          When this parameter is '"*"', the connection requests are
          accepted on all network interfaces (i.e.  address INADDR_ANY).
          The parameter can be a string denoting a host name, which will
          be translated to an IP address by the 'host-info' procedure,
          or a 4 element u8vector which contains the 32-bit IPv4 address
          or an 8 element u16vector which contains the 128-bit IPv6
          address.  A string of the form '"INTF:PORT"' is handled as if
          it was the combination of settings 'local-address:' '"INTF"'
          'local-port-number:' PORT.

        * 'local-port-number:' 16-BIT-EXACT-INTEGER

          This setting indicates the IP port number assigned to the
          socket which accepts connection requests from clients.  So
          called "well-known ports", which are reserved for standard
          services, have a port number below 1024 and can only be
          assigned to a socket by a process with superuser priviledges
          (e.g.  80 for the HTTP service, 23 for the telnet service).
          No special priviledges are needed to assign higher port
          numbers to a socket.  The special value 0 requests that a
          currently unused port number be assigned to the socket (the
          port number assigned can be retrieved using the procedure
          'tcp-server-socket-info').  There is no default value for this
          setting.

        * 'backlog:' POSITIVE-EXACT-INTEGER

          This setting indicates the maximum number of connection
          requests that can be waiting to be accepted by a call to
          'read' (technically it is the value passed as the second
          argument of the UNIX 'listen()' function).  The default value
          of this setting is 128.

        * 'reuse-address:' ( '#f' | '#t' )

          This setting controls whether it is possible to assign a port
          number that is currently active.  Note that when a server
          process terminates, the socket it was using to accept
          connection requests does not become inactive immediately.
          Instead it remains active for a few minutes to ensure clean
          termination of the connections.  A setting of '#f' will cause
          an exception to be raised in that case.  A setting of '#t'
          will allow a port number to be used even if it is active.  The
          default value of this setting is '#t'.

        * 'tls-context:' ( '#f' | TLS-CONTEXT )

          This setting controls the use of TLS encryption.  If provided,
          the server will use this configuration for accepting TCP
          connections with TLS encryption, otherwise it will accept
          plain TCP connections as usual.  Please note that Gambit must
          be compiled with TLS support for this option to be
          implemented.  See 'make-tls-context' for futher information.
          The default value of this setting is '#f'.

     Below is an example of the server-side code that accepts
     connections on port 8080 of any network interface.  For the
     client-side code see the example for the procedure
     'open-tcp-client'.

          > (define s (open-tcp-server (list local-address: "*"
                                             local-port-number: 8080
                                             eol-encoding: 'cr-lf)))
          > (define p (read s))  ; blocks until client connects
          > p
          #<input-output-port #2 (tcp-client 8080)>
          > (read-line p)
          "GET /"
          > (display "<HTML>\n" p)
          > (force-output p)

 -- procedure: tcp-service-register! PORT-NUMBER-OR-ADDRESS-OR-SETTINGS
          THUNK [THREAD-GROUP]
 -- procedure: tcp-service-unregister!
          PORT-NUMBER-OR-ADDRESS-OR-SETTINGS

     The procedure 'tcp-service-register!' sets up a socket to accept
     network connection requests from clients and creates a "service"
     thread which processes the incoming connections and returns this
     thread.  The parameter PORT-NUMBER-OR-ADDRESS-OR-SETTINGS has the
     same meaning as for the procedure 'open-tcp-server'.

     For each connection established the service thread creates a
     "handler" thread which executes a call to the procedure THUNK with
     no argument.  The handler thread's current input-port and current
     output-port are both set to the tcp-client-port created for the
     connection.  There is no need for the THUNK to close the
     tcp-client-port, as this is done by the handler thread when the
     THUNK returns normally.

     The procedure 'tcp-service-unregister!' terminates the service
     thread which was registered by 'tcp-service-register!' with the
     same network interface and port number (if a service thread is
     still registered).  The procedure 'tcp-service-register!'
     implicitly calls 'tcp-service-unregister!' before registering the
     new service thread.

          > (tcp-service-register!
             8000
             (lambda () (display "hello\n")))
          > (define p (open-tcp-client 8000))
          > (read-line p)
          "hello"
          > (tcp-service-unregister! 8000)

 -- procedure: make-tls-context [OPTIONS]

     This procedure requires Gambit to be compiled with TLS support,
     which is currently provided by OpenSSL. The '--enable-openssl' flag
     of the configure script will activate it, provided that you have
     the OpenSSL library and headers installed.  It is strongly
     recommended that versions above 1.x are used.  On OSX, this means
     updating the OpenSSL bundled by default.  This can be achieved
     using Homebrew, but manual installation or any other package
     manager will do.  Some notes on Windows with MinGW are also
     relevant here.  Once you have a sane MinGW environment, remember to
     decompress the OpenSSL tarball with the tar utility, otherwise
     links to files won't work during the compilation process.  The
     recommended build procedure for MinGW is as follows.

     Configure OpenSSL on MinGW 32 bits:

          perl Configure mingw no-asm --prefix=/usr/local --openssldir=/usr/local/openssl

     Configure OpenSSL on MinGW 64 bits:

          perl Configure mingw64 no-asm --prefix=/usr/local --openssldir=/usr/local/openssl

     Build and install with the following commands:

          make depend
          make
          make install

     A TLS context describes the options that will be used for setting
     up a TLS connection.  If no TLS context is provided to
     'open-tcp-client' or 'open-tcp-server', regular TCP connections
     without encryption will be used instead.  The result of this
     procedure is a 'SSL_CTX' pointer, which can be further manipulated
     with custom OpenSSL bindings.  The configuration options are:

        * 'min-version:' SYMBOL

          Establish a minimum TLS version for the connection.  If the
          other peer doesn't support or agree with it, the connection
          will fail.  Possible options (support depends on linked
          OpenSSL version): 'ssl-v2', 'ssl-v3', 'tls-v1', 'tls-v1.1',
          'tls-v1.2'.

        * 'options:' LIST-OF-SYMBOLS

          A list of flags enabling/disabling TLS options.  'server-mode'
          is required for using the TLS context with 'open-tcp-server'.
          'use-diffie-hellman' enables the Diffie-Hellman key exchange.
          'use-elliptic-curves' enables Elliptic Curves.  If no curve
          name is provided (with 'elliptic-curve:'), 'prime256v1' will
          be used.  'request-client-authentication' is used by a server
          to enable request of authentication to clients.
          'insert-empty-fragments' enables a countermeasure against a
          SSL 3.0/TLS 1.0 protocol vulnerability affecting CBC ciphers.
          If used, the resulting connection may not be handled by some
          broken SSL implementations.  This option has no effect for
          connections using other ciphers.

        * 'certificate:' PATH

          Path to PEM Certificate file.  This is a recommended option.
          If not provided OpenSSL will try to use anonymous cipher
          suites.

        * 'private-key:' PATH

          Path to PEM Private Key file.  If not provided, the
          Certificate path will be used instead.

        * 'client-ca:' PATH

          Path to PEM file containing Certificate Authorities allowed
          for client authentication.  Used only if
          'request-client-authentication' option is enabled.

        * 'elliptic-curve:' STRING

          Name of the Elliptic Curve to use, according to RFC 4492.
          Used only if 'use-elliptic-curves' option is enabled.

     TCP Client example with TLS encryption.

          (define (https-get host document)
            (let* ((ctx (make-tls-context))
                   (conn (open-tcp-client (list address: host
                                                port-number: 443
                                                tls-context: ctx))))
              (print port: conn
                     "GET " document " HTTP/1.1\n"
                     "Host: " host "\n"
                     "Connection: close\n"
                     "\n")
              (force-output conn)
              (let ((string (read-line conn #f)))
                (close-port conn)
                string)))

          (display (https-get "example.com" "/"))

     TCP Server example with several options.  These are not mandatory,
     except for 'server-mode'.

          (define ctx (make-tls-context options: '(server-mode
                                                   use-diffie-hellman
                                                   use-elliptic-curves)
                                        certificate: "server.pem"
                                        diffie-hellman-parameters: "dh_param_1024.pem"
                                        elliptic-curve: "prime256v1"))

          (define s (open-tcp-server (list local-address: "localhost"
                                           local-port-number: 1443
                                           tls-context: ctx)))
          (define p (read s))
          (display "<HTML></HTML>\n" p)
          (force-output p)

     A practical way of testing TLS options are the 's_server' and
     's_client' commands of the 'openssl' tool.

 -- procedure: open-udp PORT-NUMBER-OR-ADDRESS-OR-SETTINGS

     This procedure opens a socket for doing network communication with
     the UDP protocol.  The default value of the 'direction:' setting is
     'input-output', i.e.  the Scheme program can send information and
     receive information on the socket.  The sending direction can be
     closed using the 'close-output-port' procedure and the receiving
     direction can be closed using the 'close-input-port' procedure.
     The 'close-port' procedure closes both directions.

     The resulting port designates a UDP socket.  Each call to 'read'
     and 'udp-read-subu8vector' causes the reception of a single
     datagram on the designated UDP socket, and each call to 'write' and
     'udp-write-subu8vector' sends a single datagram.  UDP ports are a
     direct subtype of object-ports (i.e.  they are not character-ports)
     and 'read' and 'write' transfer u8vectors.  If 'read' is called and
     a timeout occurs before a datagram is transferred and the timeout
     thunk returns '#f' (see the procedure 'input-port-timeout-set!')
     then the end-of-file object is returned.

     The parameter of this procedure is an IP port number (16-bit
     nonnegative exact integer), a string of the form '"HOST:PORT"' or a
     list of port settings.  When the parameter is the number PORT it is
     handled as if it was the setting 'local-port-number:' PORT.  When
     the parameter is the string '"HOST:PORT"' it is handled as if it
     was the setting 'local-address:' '"HOST:PORT"'.

     Here are the settings allowed:

        * 'direction:' ( 'input' | 'output' | 'input-output' )

          This setting controls the direction of the port.  The symbol
          'input' indicates a unidirectional input-port, the symbol
          'output' indicates a unidirectional output-port, and the
          symbol 'input-output' indicates a bidirectional port.  The
          default value of this setting is 'input-output'.

        * 'local-address:' STRING-OR-IP-ADDRESS

          This setting indicates the internet address of the local
          network interface on which the socket is open and possibly the
          IP port number.  When this parameter is not specified or is
          '""', the socket is open on the loopback interface (with IP
          address 127.0.0.1).  When this parameter is '"*"' the socket
          is open on all network interfaces (i.e.  address INADDR_ANY).
          The parameter can be a string denoting a host name, which will
          be translated to an IP address by the 'host-info' procedure,
          or a 4 element u8vector which contains the 32-bit IPv4 address
          or an 8 element u16vector which contains the 128-bit IPv6
          address.  A string of the form '"INTF:PORT"' is handled as if
          it was the combination of settings 'local-address:' '"INTF"'
          'local-port-number:' PORT.

        * 'local-port-number:' 16-BIT-EXACT-INTEGER

          This setting indicates the IP port number assigned to the
          socket.  The special value 0 requests that a currently unused
          port number be assigned to the socket.  This is the default
          value for this setting.

        * 'address:' STRING-OR-IP-ADDRESS

          This setting indicates the initial destination internet
          address of the datagrams, and possibly the IP port number.
          When this parameter is not specified the destination is set to
          the local address if it is not all network interfaces (i.e.
          '"*"' = address INADDR_ANY). When this parameter is '""' or
          this parameter is not specified and the local address is all
          network interfaces, the destination is set to the loopback
          interface (with IP address 127.0.0.1).  The parameter can be a
          string denoting a host name, which will be translated to an IP
          address by the 'host-info' procedure, or a 4 element u8vector
          which contains the 32-bit IPv4 address or an 8 element
          u16vector which contains the 128-bit IPv6 address.  A string
          of the form '"HOST:PORT"' is handled as if it was the
          combination of settings 'address:' '"HOST"' 'port-number:'
          PORT.

        * 'port-number:' 16-BIT-EXACT-INTEGER

          This setting indicates the initial destination IP port number
          of the datagrams.  It defaults to the local port number.

 -- procedure: udp-destination-set! ADDRESS PORT-NUMBER [UDP-PORT]

     This procedure sets the destination address and port-number for the
     next datagram sent on the UDP socket designated by UDP-PORT,
     obtained with a call to 'open-udp'.  If it is not specified,
     UDP-PORT defaults to the current output-port.

 -- procedure: udp-read-u8vector [UDP-PORT]
 -- procedure: udp-write-u8vector U8VECTOR [UDP-PORT]
 -- procedure: udp-read-subu8vector U8VECTOR START END [UDP-PORT]
 -- procedure: udp-write-subu8vector U8VECTOR START END [UDP-PORT]

     These procedures receive and send datagrams on the UDP socket
     designated by UDP-PORT, obtained with a call to 'open-udp'.  If it
     is not specified, UDP-PORT defaults to the current input-port for
     'udp-read-u8vector' and 'udp-read-subu8vector' and to the current
     output-port for 'udp-write-u8vector' and 'udp-write-subu8vector'.

     These procedures are similar in function to 'read-subu8vector' and
     'write-subu8vector', but because they read or write a group of
     bytes at a time rather than a stream of bytes, they are distinct
     procedures with slightly different APIs.

     The procedure 'udp-read-u8vector' receives the next datagram and
     returns it in a fresh u8vector.  If a timeout occurs before a
     datagram is transferred and the timeout thunk returns '#f' (see the
     procedure 'input-port-timeout-set!') then '#f' is returned.

     The procedure 'udp-write-u8vector' sends as a datagram the u8vector
     U8VECTOR.

     For the procedures 'udp-read-subu8vector' and
     'udp-write-subu8vector', the part of the u8vector U8VECTOR starting
     at index START and ending just before index END is used as a byte
     buffer that will be the target of 'udp-read-subu8vector' or the
     source of the 'udp-write-subu8vector'.  Up to END-START bytes will
     be transferred.  The number of bytes transferred, possibly zero, is
     returned by these procedures, unless a timeout occurs (see below).
     Fewer bytes will be read by 'udp-read-subu8vector' if the received
     datagram's length is less than END-START.  'udp-write-subu8vector'
     always transfers END-START bytes, but note that this must be less
     than 65536 bytes, and some operating systems have a lower limit
     (for example macOS limits the number of bytes to 9216 by default).
     If a timeout occurs before a datagram is transferred and the
     timeout thunk returns '#f' (see the procedure
     'input-port-timeout-set!') then '#f' is returned by these
     procedures (this is different from the procedures
     'read-subu8vector' and 'write-subu8vector' which return 0).

     For 'udp-write-u8vector' and 'udp-write-subu8vector' the datagram's
     destination is the address initially supplied when 'open-udp' was
     called, or the latest address set when 'udp-destination-set!' was
     called.

     Here is an example of sending a 3 byte datagram to port 5678 of the
     loopback interface (with IP address 127.0.0.1):

          > (define p (open-udp (list address: '#u8(127 0 0 1) port-number: 5678)))
          > (write '#u8(11 22 33) p)

     An alternative approach is to use 'udp-destination-set!':

          > (define p (open-udp))
          > (udp-destination-set! '#u8(127 0 0 1) 5678 p)
          > (write '#u8(11 22 33) p)

     Another approach is to use 'udp-write-subu8vector':

          > (define p (open-udp))
          > (udp-destination-set! '#u8(127 0 0 1) 5678 p)
          > (define v '#u8(11 22 33))
          > (udp-write-subu8vector v 0 3 p)
          3

     Note that by default the internet address of the local network
     interface is the loopback interface, which is not connected to the
     internet.  To contact an external socket the address of the local
     network interface must be specified, for example '"*"' will select
     all interfaces.  The following example shows how to connect to a
     Time Protocol server to get the current time:

          > (define p (open-udp (list local-address: "*" address: "time.nist.gov:37")))
          > (write '#u8() p)
          > (read p)
          #u8(222 27 158 226)

     Here is an example of receiving a 3 byte datagram on port 5678 of
     the loopback interface:

          > (define p (open-udp 5678))
          > (read p)
          #u8(11 22 33)

     An alternative approach is to use 'udp-read-subu8vector':

          > (define p (open-udp 5678))
          > (define v (make-u8vector 10000))
          > (udp-read-subu8vector v 0 10000 p)
          3
          > (subu8vector v 0 3)
          #u8(11 22 33)

     Note that using 'udp-read-subu8vector' and 'udp-write-subu8vector'
     is typically more efficient than 'read' and 'write' because it
     avoids having to construct a new u8vector for each datagram
     transferred.

 -- procedure: udp-local-socket-info UDP-PORT
 -- procedure: udp-source-socket-info UDP-PORT

     The procedure 'udp-local-socket-info' returns the local socket-info
     of the UDP socket designated by UDP-PORT.

     The procedure 'udp-source-socket-info' returns the socket-info of
     the source of the latest datagram received on the UDP socket
     designated by UDP-PORT.  When a datagram hasn't been received yet,
     '#f' is returned.

     For example:

          > (define p (open-udp (list local-address: "*" address: "time.nist.gov:37")))
          > (udp-local-socket-info p)
          #<socket-info #2 family: INET port-number: 64716 address: #f>
          > (udp-source-socket-info p)
          #f
          > (write '#u8() p)
          > (read p)
          #u8(222 27 162 109)
          > (udp-source-socket-info p)
          #<socket-info #3 family: INET port-number: 37 address: #u8(132 163 97 4)>


File: gambit.info,  Node: Directory-ports,  Next: Vector-ports,  Prev: Device-ports,  Up: I/O and ports

14.8 Directory-ports
====================

 -- procedure: open-directory PATH-OR-SETTINGS

     This procedure opens a directory of the filesystem for reading its
     entries and returns a directory-port from which the entries can be
     enumerated.  Directory-ports are a direct subtype of object-ports
     (i.e.  they are not character-ports) and are input-ports.  Reading
     from a directory-port with the 'read' procedure returns the next
     file name in the directory as a string.  The end-of-file object is
     returned when all the file names have been enumerated.  Another way
     to get the list of all files in a directory is the
     'directory-files' procedure which returns a list of the files in
     the directory.  The advantage of using directory-ports is that it
     allows iterating over the files in a directory in constant space,
     which is interesting when the number of files in the directory is
     not known in advance and may be large.  Note that the order in
     which the names are returned is operating-system dependent.

     The parameter of this procedure is either a string denoting a
     filesystem path to a directory or a list of port settings which
     must contain a 'path:' setting.  Here are the settings allowed in
     addition to the generic settings of object-ports:

        * 'path:' STRING

          This setting indicates the location of the directory in the
          filesystem.  There is no default value for this setting.

        * 'ignore-hidden:' ( '#f' | '#t' | 'dot-and-dot-dot' )

          This setting controls whether hidden-files will be returned.
          Under UNIX and macOS hidden-files are those that start with a
          period (such as '.', '..', and '.profile').  Under Microsoft
          Windows hidden files are the '.' and '..' entries and the
          files whose "hidden file" attribute is set.  A setting of '#f'
          will enumerate all the files.  A setting of '#t' will only
          enumerate the files that are not hidden.  A setting of
          'dot-and-dot-dot' will enumerate all the files except for the
          '.' and '..' hidden files.  The default value of this setting
          is '#t'.

     For example:

          > (let ((p (open-directory (list path: "../examples"
                                           ignore-hidden: #f))))
              (let loop ()
                (let ((fn (read p)))
                  (if (string? fn)
                      (begin
                        (pp (path-expand fn))
                        (loop)))))
              (close-input-port p))
          "/u/feeley/examples/."
          "/u/feeley/examples/.."
          "/u/feeley/examples/complex"
          "/u/feeley/examples/README"
          "/u/feeley/examples/simple"
          > (define x (open-directory "../examples"))
          > (read-all x)
          ("complex" "README" "simple")


File: gambit.info,  Node: Vector-ports,  Next: String-ports,  Prev: Directory-ports,  Up: I/O and ports

14.9 Vector-ports
=================

 -- procedure: open-vector [VECTOR-OR-SETTINGS]
 -- procedure: open-input-vector [VECTOR-OR-SETTINGS]
 -- procedure: open-output-vector [VECTOR-OR-SETTINGS]
 -- procedure: call-with-input-vector VECTOR-OR-SETTINGS PROC
 -- procedure: call-with-output-vector [VECTOR-OR-SETTINGS] PROC
 -- procedure: with-input-from-vector VECTOR-OR-SETTINGS THUNK
 -- procedure: with-output-to-vector [VECTOR-OR-SETTINGS] THUNK

     Vector-ports represent streams of Scheme objects.  They are a
     direct subtype of object-ports (i.e.  they are not
     character-ports).  All of these procedures create vector-ports that
     are either unidirectional or bidirectional.  The 'direction:'
     setting will default to the value 'input' for the procedures
     'open-input-vector', 'call-with-input-vector' and
     'with-input-from-vector', to the value 'output' for the procedures
     'open-output-vector', 'call-with-output-vector' and
     'with-output-to-vector', and to the value 'input-output' for the
     procedure 'open-vector'.  Bidirectional vector-ports behave like
     FIFOs: data written to the port is added to the end of the stream
     that is read.  It is only when a bidirectional vector-port's
     output-side is closed with a call to the 'close-output-port'
     procedure that the stream's end is known (when the stream's end is
     reached, reading the port returns the end-of-file object).

     The procedures 'open-vector', 'open-input-vector' and
     'open-output-vector' return the port that is created.  The
     procedures 'call-with-input-vector' and 'call-with-output-vector'
     create a vector port, call the procedure PROC with the port as
     single argument and then close the port.  The procedures
     'with-input-from-vector' and 'with-output-to-vector' create a
     vector port, dynamically bind the current input-port and current
     output-port respectively to the port created for the duration of a
     call to the procedure THUNK with no argument, and then close the
     port.  The procedures 'call-with-input-vector' and
     'with-input-from-vector' return the value returned by the
     procedures PROC and THUNK respectively.  The procedures
     'call-with-output-vector' and 'with-output-to-vector' return the
     vector accumulated in the port (see 'get-output-vector').

     The VECTOR-OR-SETTINGS parameter of these procedures is either a
     vector of the elements used to initialize the stream or a list of
     port settings.  If it is not specified, the parameter of the
     'open-vector', 'open-input-vector', 'open-output-vector',
     'with-output-to-vector', and 'call-with-output-vector' procedures
     defaults to an empty list of port settings.  Here are the settings
     allowed in addition to the generic settings of object-ports:

        * 'init:' VECTOR

          This setting indicates the initial content of the stream.  The
          default value of this setting is an empty vector.

        * 'permanent-close:' ( '#f' | '#t' )

          This setting controls whether a call to the procedures
          'close-output-port' will close the output-side of a
          bidirectional vector-port permanently or not.  A permanently
          closed bidirectional vector-port whose end-of-file has been
          reached on the input-side will return the end-of-file object
          for all subsequent calls to the 'read' procedure.  A
          non-permanently closed bidirectional vector-port will return
          to its opened state when its end-of-file is read.  The default
          value of this setting is '#t'.

     For example:

          > (define p (open-vector))
          > (write 1 p)
          > (write 2 p)
          > (write 3 p)
          > (force-output p)
          > (read p)
          1
          > (read p)
          2
          > (close-output-port p)
          > (read p)
          3
          > (read p)
          #!eof
          > (with-output-to-vector (lambda () (write 1) (write 2)))
          #(1 2)

 -- procedure: open-vector-pipe [VECTOR-OR-SETTINGS1
          [VECTOR-OR-SETTINGS2]]

     The procedure 'open-vector-pipe' creates two vector-ports and
     returns these two ports.  The two ports are interrelated as
     follows: the first port's output-side is connected to the second
     port's input-side and the first port's input-side is connected to
     the second port's output-side.  The value VECTOR-OR-SETTINGS1 is
     used to setup the first vector-port and VECTOR-OR-SETTINGS2 is used
     to setup the second vector-port.  The same settings as for
     'open-vector' are allowed.  The default 'direction:' setting is
     'input-output' (i.e.  a bidirectional port is created).  If it is
     not specified VECTOR-OR-SETTINGS1 defaults to the empty list.  If
     it is not specified VECTOR-OR-SETTINGS2 defaults to
     VECTOR-OR-SETTINGS1 but with the 'init:' setting set to the empty
     vector and with the input and output settings exchanged (e.g.  if
     the first port is an input-port then the second port is an
     output-port, if the first port's input-side is non-buffered then
     the second port's output-side is non-buffered).

     For example:

          > (define (server op)
              (receive (c s) (open-vector-pipe)  ; client-side and server-side ports
                (thread-start!
                  (make-thread
                    (lambda ()
                      (let loop ()
                        (let ((request (read s)))
                          (if (not (eof-object? request))
                              (begin
                                (write (op request) s)
                                (newline s)
                                (force-output s)
                                (loop))))))))
                c))
          > (define a (server (lambda (x) (expt 2 x))))
          > (define b (server (lambda (x) (expt 10 x))))
          > (write 100 a)
          > (write 30 b)
          > (read a)
          1267650600228229401496703205376
          > (read b)
          1000000000000000000000000000000

 -- procedure: get-output-vector VECTOR-PORT

     The procedure 'get-output-vector' takes an output vector-port or a
     bidirectional vector-port as parameter and removes all the objects
     currently on the output-side, returning them in a vector.  The port
     remains open and subsequent output to the port and calls to the
     procedure 'get-output-vector' are possible.

     For example:

          > (define p (open-vector '#(1 2 3)))
          > (write 4 p)
          > (get-output-vector p)
          #(1 2 3 4)
          > (write 5 p)
          > (write 6 p)
          > (get-output-vector p)
          #(5 6)


File: gambit.info,  Node: String-ports,  Next: U8vector-ports,  Prev: Vector-ports,  Up: I/O and ports

14.10 String-ports
==================

 -- procedure: open-string [STRING-OR-SETTINGS]
 -- procedure: open-input-string [STRING-OR-SETTINGS]
 -- procedure: open-output-string [STRING-OR-SETTINGS]
 -- procedure: call-with-input-string STRING-OR-SETTINGS PROC
 -- procedure: call-with-output-string [STRING-OR-SETTINGS] PROC
 -- procedure: with-input-from-string STRING-OR-SETTINGS THUNK
 -- procedure: with-output-to-string [STRING-OR-SETTINGS] THUNK
 -- procedure: open-string-pipe [STRING-OR-SETTINGS1
          [STRING-OR-SETTINGS2]]
 -- procedure: get-output-string STRING-PORT

     String-ports represent streams of characters.  They are a direct
     subtype of character-ports.  These procedures are the string-port
     analog of the procedures specified in the vector-ports section.
     Note that these procedures are a superset of the procedures
     specified in the "Basic String Ports SRFI" (SRFI 6).

     For example:

          > (define p (open-string))
          > (write 1 p)
          > (write 2 p)
          > (write 3 p)
          > (force-output p)
          > (read-char p)
          #\1
          > (read-char p)
          #\2
          > (close-output-port p)
          > (read-char p)
          #\3
          > (read-char p)
          #!eof
          > (with-output-to-string (lambda () (write 1) (write 2)))
          "12"

 -- procedure: object->string OBJ [N]

     This procedure converts the object OBJ to its external
     representation and returns it in a string.  The parameter N
     specifies the maximal width of the resulting string.  If the
     external representation is wider than N, the resulting string will
     be truncated to N characters and the last 3 characters will be set
     to periods.  Note that the current readtable is used.

     For example:

          > (object->string (expt 2 100))
          "1267650600228229401496703205376"
          > (object->string (expt 2 100) 30)
          "126765060022822940149670320..."
          > (object->string (cons car cdr))
          "(#<procedure #2 car> . #<procedure #3 cdr>)"


File: gambit.info,  Node: U8vector-ports,  Next: Other procedures related to I/O,  Prev: String-ports,  Up: I/O and ports

14.11 U8vector-ports
====================

 -- procedure: open-u8vector [U8VECTOR-OR-SETTINGS]
 -- procedure: open-input-u8vector [U8VECTOR-OR-SETTINGS]
 -- procedure: open-output-u8vector [U8VECTOR-OR-SETTINGS]
 -- procedure: call-with-input-u8vector U8VECTOR-OR-SETTINGS PROC
 -- procedure: call-with-output-u8vector [U8VECTOR-OR-SETTINGS] PROC
 -- procedure: with-input-from-u8vector U8VECTOR-OR-SETTINGS THUNK
 -- procedure: with-output-to-u8vector [U8VECTOR-OR-SETTINGS] THUNK
 -- procedure: open-u8vector-pipe [U8VECTOR-OR-SETTINGS1
          [U8VECTOR-OR-SETTINGS2]]
 -- procedure: get-output-u8vector U8VECTOR-PORT

     U8vector-ports represent streams of bytes.  They are a direct
     subtype of byte-ports.  These procedures are the u8vector-port
     analog of the procedures specified in the vector-ports section.

     For example:

          > (define p (open-u8vector))
          > (write 1 p)
          > (write 2 p)
          > (write 3 p)
          > (force-output p)
          > (read-u8 p)
          49
          > (read-u8 p)
          50
          > (close-output-port p)
          > (read-u8 p)
          51
          > (read-u8 p)
          #!eof
          > (with-output-to-u8vector (lambda () (write 1) (write 2)))
          #u8(49 50)


File: gambit.info,  Node: Other procedures related to I/O,  Prev: U8vector-ports,  Up: I/O and ports

14.12 Other procedures related to I/O
=====================================

 -- procedure: current-input-port [NEW-VALUE]
 -- procedure: current-output-port [NEW-VALUE]
 -- procedure: current-error-port [NEW-VALUE]
 -- procedure: current-readtable [NEW-VALUE]

     These procedures are parameter objects which represent
     respectively: the current input-port, the current output-port, the
     current error-port, and the current readtable.

 -- procedure: print [port: PORT] OBJ...
 -- procedure: println [port: PORT] OBJ...

     The 'print' procedure writes a representation of each OBJ, from
     left to right, to PORT.  When a compound object is encountered
     (pair, list, vector, box) the elements of that object are
     recursively written without the surrounding tokens (parentheses,
     spaces, dots, etc).  Strings, symbols, keywords and characters are
     written like the 'display' procedure.  If there are more than one
     OBJ, the first OBJ must not be a keyword object.  If it is not
     specified, PORT defaults to the current output-port.  The procedure
     'print' returns an unspecified value.

     The 'println' procedure does the same thing as the 'print'
     procedure and then writes an end of line to PORT.

     For example:

          > (println "2*2 is " (* 2 2) " and 2+2 is " (+ 2 2))
          2*2 is 4 and 2+2 is 4
          > (define x (list "<i>" (list "<tt>" 123 "</tt>") "</i>"))
          > (println x)
          <i><tt>123</tt></i>
          > (define p (open-output-string))
          > (print port: p 1 #\2 "345")
          > (get-output-string p)
          "12345"

 -- procedure: read-file-string PATH-OR-SETTINGS
 -- procedure: read-file-string-list PATH-OR-SETTINGS
 -- procedure: read-file-u8vector PATH-OR-SETTINGS

     These procedures open the file designated by PATH-OR-SETTINGS and
     read the whole content.  They respectively return a string (the
     characters in the file), a list of strings (the lines in the file),
     and a u8vector (the bytes in the file).

     The PATH-OR-SETTINGS parameter is either a string denoting a
     filesystem path or a list of port settings which must contain a
     'path:' setting.  The same settings as 'open-input-file' are
     allowed, and the same default settings are used.  The default value
     of the 'char-encoding:' setting (which is relevant for
     'read-file-string' and 'read-file-string-list') depends on how the
     runtime system was configured but typically UTF-8 is used.  The
     default can be overridden through various runtime options (*note
     Runtime options::), such as '-:file-settings=...' and
     '-:io-settings=...'.

     For example:

          > (with-output-to-file
              "test"
              (lambda () (for-each pretty-print (map square (iota 5)))))
          > (read-file-string "test")
          "0\n1\n4\n9\n16\n"
          > (read-file-string-list "test")
          ("0" "1" "4" "9" "16")
          > (read-file-u8vector "test")
          #u8(48 10 49 10 52 10 57 10 49 54 10)
          > (utf8->string (read-file-u8vector "test"))
          "0\n1\n4\n9\n16\n"

 -- procedure: write-file-string PATH-OR-SETTINGS STRING
 -- procedure: write-file-string-list PATH-OR-SETTINGS STRING-LIST
 -- procedure: write-file-u8vector PATH-OR-SETTINGS U8VECTOR

     These procedures open the file designated by PATH-OR-SETTINGS and
     write the data specified by the second parameter.  They
     respectively write a string (the characters to write to the file),
     a list of strings (the lines to write to the file), and a u8vector
     (the bytes to write to the file).  These procedures return the void
     object.

     The PATH-OR-SETTINGS parameter is either a string denoting a
     filesystem path or a list of port settings which must contain a
     'path:' setting.  The same settings as 'open-output-file' are
     allowed, and the same default settings are used.  The default value
     of the 'char-encoding:' setting (which is relevant for
     'write-file-string' and 'write-file-string-list') depends on how
     the runtime system was configured but typically UTF-8 is used.  The
     default can be overridden through various runtime options (*note
     Runtime options::), such as '-:file-settings=...' and
     '-:io-settings=...'.

     For example:

          > (write-file-string "test" "1\n2\n3\n")
          > (read-file-u8vector "test")
          #u8(49 10 50 10 51 10)
          > (write-file-string-list "test" (list "1" "2" "3"))
          > (read-file-u8vector "test")
          #u8(49 10 50 10 51 10)
          > (write-file-u8vector "test" (u8vector 97 98 99))
          > (read-file-string "test")
          "abc"


File: gambit.info,  Node: Lexical syntax and readtables,  Next: C-interface,  Prev: I/O and ports,  Up: Top

15 Lexical syntax and readtables
********************************

* Menu:

* Readtables::                        Readtables
* Boolean syntax::                    Boolean syntax
* Character syntax::                  Character syntax
* String syntax::                     String syntax
* Symbol syntax::                     Symbol syntax
* Keyword syntax::                    Keyword syntax
* Box syntax::                        Box syntax
* Number syntax::                     Number syntax
* Homogeneous vector syntax::         Homogeneous vector syntax
* Special #! syntax::                 Special #! syntax
* Multiline comment syntax::          Multiline comment syntax
* Scheme infix syntax extension::     Scheme infix syntax extension


File: gambit.info,  Node: Readtables,  Next: Boolean syntax,  Prev: Lexical syntax and readtables,  Up: Lexical syntax and readtables

15.1 Readtables
===============

Readtables control the external textual representation of Scheme
objects, that is the encoding of Scheme objects using characters.
Readtables affect the behavior of the reader (i.e.  the 'read' procedure
and the parser used by the 'load' procedure and the interpreter and
compiler) and the printer (i.e.  the procedures 'write', 'display',
'print', 'println', 'pretty-print', and 'pp', and the procedure used by
the REPL to print results).  To preserve write/read invariance the
printer and reader must be using compatible readtables.  For example a
symbol which contains upper case letters will be printed with special
escapes if the readtable indicates that the reader is case-insensitive.

   Readtables are immutable records whose fields specify various textual
representation aspects.  There are accessor procedures to retrieve the
content of specific fields.  There are also functional update procedures
that create a copy of a readtable, with a specific field set to a new
value.

 -- procedure: readtable? OBJ

     This procedure returns '#t' when OBJ is a readtable and '#f'
     otherwise.

     For example:

          > (readtable? (current-readtable))
          #t
          > (readtable? 123)
          #f

 -- procedure: readtable-case-conversion? READTABLE
 -- procedure: readtable-case-conversion?-set READTABLE NEW-VALUE

     The procedure 'readtable-case-conversion?' returns the content of
     the 'case-conversion?' field of READTABLE.  When the content of
     this field is '#f', the reader preserves the case of symbols,
     keyword and named characters that are read (i.e.  'Ice' and 'ice'
     are distinct symbols).  When the content of this field is the
     symbol 'upcase', the reader converts to uppercase (i.e.  'Ice' is
     read as the symbol '(string->symbol "ICE")').  Otherwise the reader
     converts using 'string-foldcase', which for many letters converts
     them to lowercase (i.e.  'Ice' is read as the symbol
     '(string->symbol "ice")').

     The procedure 'readtable-case-conversion?-set' returns a copy of
     READTABLE where only the 'case-conversion?' field has been changed
     to NEW-VALUE.

     For example:

          > (output-port-readtable-set!
              (repl-output-port)
              (readtable-case-conversion?-set
                (output-port-readtable (repl-output-port))
                #f))
          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-case-conversion?-set
                (input-port-readtable (repl-input-port))
                #f))
          > 'Ice
          Ice
          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-case-conversion?-set
                (input-port-readtable (repl-input-port))
                #t))
          > 'Ice
          ice
          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-case-conversion?-set
                (input-port-readtable (repl-input-port))
                'upcase))
          > 'Ice
          ICE

 -- procedure: readtable-keywords-allowed? READTABLE
 -- procedure: readtable-keywords-allowed?-set READTABLE NEW-VALUE

     The procedure 'readtable-keywords-allowed?' returns the content of
     the 'keywords-allowed?' field of READTABLE.  When the content of
     this field is '#f', the reader does not recognize keyword objects
     (i.e.  ':foo' and 'foo:' are read as the symbols '(string->symbol
     ":foo")' and '(string->symbol "foo:")' respectively).  When the
     content of this field is the symbol 'prefix', the reader recognizes
     keyword objects that start with a colon, as in Common Lisp (i.e.
     ':foo' is read as the keyword '(string->keyword "foo")').
     Otherwise the reader recognizes keyword objects that end with a
     colon, as in DSSSL (i.e.  'foo:' is read as the symbol
     '(string->symbol "foo")').

     The procedure 'readtable-keywords-allowed?-set' returns a copy of
     READTABLE where only the 'keywords-allowed?' field has been changed
     to NEW-VALUE.

     For example:

          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-keywords-allowed?-set
                (input-port-readtable (repl-input-port))
                #f))
          > (map keyword? '(foo :foo foo:))
          (#f #f #f)
          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-keywords-allowed?-set
                (input-port-readtable (repl-input-port))
                #t))
          > (map keyword? '(foo :foo foo:))
          (#f #f #t)
          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-keywords-allowed?-set
                (input-port-readtable (repl-input-port))
                'prefix))
          > (map keyword? '(foo :foo foo:))
          (#f #t #f)

 -- procedure: readtable-sharing-allowed? READTABLE
 -- procedure: readtable-sharing-allowed?-set READTABLE NEW-VALUE

     The procedure 'readtable-sharing-allowed?' returns the content of
     the 'sharing-allowed?' field of READTABLE.  The reader recognizes
     the '#N#' and '#N=DATUM' notation for shared and circular
     structures and the printer uses this notation depending on the
     content of the 'sharing-allowed?' field and the printing primitive
     used.  When the content of the 'sharing-allowed?' field is the
     symbol 'default', the procedure 'write-shared' will use this
     notation for shared and circular structures, the procedures
     'write', 'display', 'pp', 'pretty-print', 'print', and 'println'
     will use this notation for circular structures, and the procedure
     'write-simple' does not use this notation.  When the content of the
     'sharing-allowed?' field is '#f', the printing procedures will not
     use this notation.  When the content of the 'sharing-allowed?'
     field is '#t', the printing procedures will use this notation for
     shared and circular structures.  Finally, when the content of the
     'sharing-allowed?' field is the symbol 'serialize', the printer
     uses a special external representation that the reader understands
     and that extends write/read invariance to the following types:
     records, procedures and continuations.  Note that an object can be
     serialized and deserialized if and only if all of its components
     are serializable.

     The procedure 'readtable-sharing-allowed?-set' returns a copy of
     READTABLE where only the 'sharing-allowed?' field has been changed
     to NEW-VALUE.

     Here is a simple example:

          > (define (wr obj allow?)
              (call-with-output-string
                (lambda (p)
                  (output-port-readtable-set!
                    p
                    (readtable-sharing-allowed?-set
                      (output-port-readtable p)
                      allow?))
                  (write obj p))))
          > (define (rd str allow?)
              (call-with-input-string
                str
                (lambda (p)
                  (input-port-readtable-set!
                    p
                    (readtable-sharing-allowed?-set
                      (input-port-readtable p)
                      allow?))
                  (read p))))
          > (define x (list 1 2 3))
          > (set-car! (cdr x) (cddr x))
          > (wr x #f)
          "(1 (3) 3)"
          > (wr x #t)
          "(1 #0=(3) . #0#)"
          > (define y (rd (wr x #t) #t))
          > y
          (1 (3) 3)
          > (eq? (cadr y) (cddr y))
          #t
          > (define f #f)
          > (let ((free (expt 2 10)))
            (set! f (lambda (x) (+ x free))))
          > (define s (wr f 'serialize))
          > (string-length s)
          4196
          > (define g (rd s 'serialize))
          > (eq? f g)
          #f
          > (g 4)
          1028

     Continuations are tricky to serialize because they contain a
     dynamic environment and this dynamic environment may contain
     non-serializable objects, in particular ports attached to
     operating-system streams such as files, the console or standard
     input/output.  Indeed, all dynamic environments contain a binding
     for the 'current-input-port' and 'current-output-port'.  Moreover,
     any thread that has started a REPL has a continuation which refers
     to the "repl-context" object in its dynamic environment.  A
     repl-context object contains the interaction channel, which is
     typically connected to a non-serializable port, such as the
     console.  Another problem is that the 'parameterize' form saves the
     old binding of the parameter in the continuation, so it is not
     possible to eliminate the references to these ports in the
     continuation by using the 'parameterize' form alone.

     Serialization of continuations can be achieved dependably by taking
     advantage of string-ports, which are serializable objects (unless
     there is a blocked thread), and the following features of threads:
     they inherit the dynamic environment of the parent thread and they
     start with an initial continuation that contains only serializable
     objects.  So a thread created in a dynamic environment where
     'current-input-port' and 'current-output-port' are bound to a dummy
     string-port has a serializable continuation.

     Here is an example where continuations are serialized:

          > (define (wr obj)
              (call-with-output-string
               (lambda (p)
                 (output-port-readtable-set!
                  p
                  (readtable-sharing-allowed?-set
                   (output-port-readtable p)
                   'serialize))
                 (write obj p))))
          > (define (rd str)
              (call-with-input-string
               str
               (lambda (p)
                 (input-port-readtable-set!
                  p
                  (readtable-sharing-allowed?-set
                   (input-port-readtable p)
                   'serialize))
                 (read p))))
          > (define fifo (open-vector))
          > (define (suspend-and-die!)
              (call-with-current-continuation
               (lambda (k)
                 (write (wr k) fifo)
                 (newline fifo)
                 (force-output fifo)
                 (thread-terminate! (current-thread)))))
          > (let ((dummy-port (open-string)))
              (parameterize ((current-input-port dummy-port)
                             (current-output-port dummy-port))
                (thread-start!
                 (make-thread
                  (lambda ()
                    (* 100
                       (suspend-and-die!)))))))
          #<thread #2>
          > (define s (read fifo))
          > (thread-join!
              (thread-start!
                (make-thread
                  (lambda ()
                    ((rd s) 111)))))
          11100
          > (thread-join!
              (thread-start!
                (make-thread
                  (lambda ()
                    ((rd s) 222)))))
          22200
          > (string-length s)
          13114

 -- procedure: readtable-eval-allowed? READTABLE
 -- procedure: readtable-eval-allowed?-set READTABLE NEW-VALUE

     The procedure 'readtable-eval-allowed?' returns the content of the
     'eval-allowed?' field of READTABLE.  The reader recognizes the
     '#.EXPRESSION' notation for read-time evaluation if and only if the
     content of the 'eval-allowed?' field is not '#f'.

     The procedure 'readtable-eval-allowed?-set' returns a copy of
     READTABLE where only the 'eval-allowed?' field has been changed to
     NEW-VALUE.

     For example:

          > (input-port-readtable-set!
              (repl-input-port)
              (readtable-eval-allowed?-set
                (input-port-readtable (repl-input-port))
                #t))
          > '(5 plus 7 is #.(+ 5 7))
          (5 plus 7 is 12)
          > '(buf = #.(make-u8vector 25))
          (buf = #u8(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))

 -- procedure: readtable-write-cdr-read-macros? READTABLE
 -- procedure: readtable-write-cdr-read-macros?-set READTABLE NEW-VALUE
 -- procedure: readtable-write-extended-read-macros? READTABLE
 -- procedure: readtable-write-extended-read-macros?-set READTABLE
          NEW-VALUE

     The procedure 'readtable-write-cdr-read-macros?' returns the
     content of the 'write-cdr-read-macros?' field of READTABLE.  The
     procedure 'readtable-write-extended-read-macros?' returns the
     content of the 'write-extended-read-macros?' field of READTABLE.

     At all times the printer uses read-macros in its output for datums
     of the form '(quote DATUM)', '(quasiquote DATUM)', '(unquote
     DATUM)', and '(unquote-splicing DATUM)'.  That is the following
     read-macro notations will be used respectively: ''DATUM', '`DATUM',
     ',DATUM', and ',@DATUM'.  Moreover, normally the read-macros will
     not be used when the form appears in the cdr of a list, for example
     '(foo quote bar)', '(foo . (quote bar))' and '(foo . 'bar)' will
     all be printed as '(foo quote bar)'.

     When the content of the 'write-cdr-read-macros?' field is not '#f',
     the printer will use read-macros when the forms appear in the cdr
     of a list.  For example '(foo quote bar)' will be printed as '(foo
     . 'bar)'.  When the content of the 'write-extended-read-macros?'
     field is not '#f', the printer will also use extended read-macros,
     for example '#'DATUM' in place of '(syntax DATUM)'.

     The procedure 'readtable-write-cdr-read-macros?-set' returns a copy
     of READTABLE where only the 'write-cdr-read-macros?' field has been
     changed to NEW-VALUE.  The procedure
     'readtable-write-extended-read-macros?-set' returns a copy of
     READTABLE where only the 'write-extended-read-macros?' field has
     been changed to NEW-VALUE.

     For example:

          > (output-port-readtable-set!
              (repl-output-port)
              (readtable-write-extended-read-macros?-set
                (output-port-readtable (repl-output-port))
                #t))
          > '(foo (syntax bar))
          (foo #'bar)
          > '(foo syntax bar)
          (foo syntax bar)
          > (output-port-readtable-set!
              (repl-output-port)
              (readtable-write-cdr-read-macros?-set
                (output-port-readtable (repl-output-port))
                #t))
          > '(foo syntax bar)
          (foo . #'bar)

 -- procedure: readtable-max-write-level READTABLE
 -- procedure: readtable-max-write-level-set READTABLE NEW-VALUE

     The procedure 'readtable-max-write-level' returns the content of
     the 'max-write-level' field of READTABLE.  The printer will display
     an ellipsis for the elements of lists and vectors that are nested
     deeper than this level.

     The procedure 'readtable-max-write-level-set' returns a copy of
     READTABLE where only the 'max-write-level' field has been changed
     to NEW-VALUE, which must be an nonnegative fixnum.

     For example:

          > (define (wr obj n)
              (call-with-output-string
                (lambda (p)
                  (output-port-readtable-set!
                    p
                    (readtable-max-write-level-set
                      (output-port-readtable p)
                      n))
                  (write obj p))))
          > (wr '(a #(b (c c) #u8(9 9 9) b) a) 3)
          "(a #(b (c c) #u8(9 9 9) b) a)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) a) 2)
          "(a #(b (...) #u8(...) b) a)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) a) 1)
          "(a #(...) a)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) a) 0)
          "(...)"
          > (wr 'hello 0)
          "hello"

 -- procedure: readtable-max-write-length READTABLE
 -- procedure: readtable-max-write-length-set READTABLE NEW-VALUE
     The procedure 'readtable-max-write-length' returns the content of
     the 'max-write-length' field of READTABLE.  The printer will
     display an ellipsis for the elements of lists and vectors that are
     at an index beyond that length.

     The procedure 'readtable-max-write-length-set' returns a copy of
     READTABLE where only the 'max-write-length' field has been changed
     to NEW-VALUE, which must be an nonnegative fixnum.

     For example:

          > (define (wr obj n)
              (call-with-output-string
                (lambda (p)
                  (output-port-readtable-set!
                    p
                    (readtable-max-write-length-set
                      (output-port-readtable p)
                      n))
                  (write obj p))))
          > (wr '(a #(b (c c) #u8(9 9 9) b) . a) 4)
          "(a #(b (c c) #u8(9 9 9) b) . a)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) . a) 3)
          "(a #(b (c c) #u8(9 9 9) ...) . a)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) . a) 2)
          "(a #(b (c c) ...) . a)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) . a) 1)
          "(a ...)"
          > (wr '(a #(b (c c) #u8(9 9 9) b) . a) 0)
          "(...)"

 -- procedure: readtable-max-unescaped-char READTABLE
 -- procedure: readtable-max-unescaped-char-set READTABLE NEW-VALUE

     The procedure 'readtable-max-unescaped-char' returns the content of
     the 'max-unescaped-char' field of READTABLE.  The printer will
     display using an escape sequence any character within symbols,
     strings and character objects greater than 'max-unescaped-char'.
     When 'max-unescaped-char' is '#f', the default value, the printer
     will take into account the output port and use an escape sequence
     for any character that isn't supported by the port's character
     encoding.

     The procedure 'readtable-max-unescaped-char-set' returns a copy of
     READTABLE where only the 'max-unescaped-char' field has been
     changed to NEW-VALUE, which must be a character or '#f'.

     For example:

          > (define rt (output-port-readtable (repl-output-port)))
          > (readtable-max-unescaped-char rt)
          #\delete
          > (string (integer->char 233))
          "\351"
          > (define (f c)
              (with-output-to-string
               (list readtable: (readtable-max-unescaped-char-set rt c))
               (lambda () (write (string (integer->char 233))))))
          > (f #\delete)
          "\"\\351\""
          > (string-length (f #\delete))
          6
          > (f #\U0010ffff)
          "\"\351\""
          > (string-length (f #\U0010ffff))
          3
          > (output-port-readtable-set!
             (repl-output-port)
             (readtable-max-unescaped-char-set rt #\U0010ffff))
          > (string (integer->char 233))
          "é"

 -- procedure: readtable-start-syntax READTABLE
 -- procedure: readtable-start-syntax-set READTABLE NEW-VALUE

     The procedure 'readtable-start-syntax' returns the content of the
     'start-syntax' field of READTABLE.  The reader uses this field to
     determine in which syntax to start parsing the input.  When the
     content of this field is the symbol 'six', the reader starts in the
     infix syntax.  Otherwise the reader starts in the prefix syntax.

     The procedure 'readtable-start-syntax-set' returns a copy of
     READTABLE where only the 'start-syntax' field has been changed to
     NEW-VALUE.

     For example:

          > (+ 2 3)
          5
          > (input-port-readtable-set!
             (repl-input-port)
             (readtable-start-syntax-set
               (input-port-readtable (repl-input-port))
               'six))
          > 2+3;
          5
          > exit();

