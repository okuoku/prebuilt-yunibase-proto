#!/usr/bin/env stklos
; A -*- Scheme -*- generated file *DO NOT EDIT**
STklos (#:version "1.70" #:globals (%define-here ... => _ and begin case cond define define-record-type do else if lambda let let* letrec or quasiquote quote syntax-rules unquote unquote-splicing) #:macros (((cond-expand . cond-expand) scheme/base (lambda clauses (%srfi-0-expand clauses))) ((define-syntax . define-syntax) scheme/base (lambda (macro-name syn-rules) (if (or (not (pair? syn-rules)) (not (eq? (car syn-rules) 'syntax-rules))) (error 'define-syntax "in `~S', bad syntax-rules ~S" macro-name syn-rules) (let ((keywords (cons macro-name (cadr syn-rules))) (clauses (cddr syn-rules)) (find-clause (symbol-value 'find-clause (find-module 'MBE)))) `(define-macro (,macro-name . args) (%find-macro-clause ',macro-name args ',keywords ',clauses)))))) ((define-values . define-values) scheme/base (lambda (formals expr) (define (flat lst) (cond ((null? lst) lst) ((pair? lst) (cons (car lst) (flat (cdr lst)))) (else (list lst)))) (if (null? formals) `(call-with-values (lambda () ,expr) void) (let* ((tmps (map* (lambda (x) (gensym)) formals)) (ff (flat formals)) (ft (flat tmps))) `(begin ,@(map (lambda (x) `(define ,x #void)) ff) (call-with-values (lambda () ,expr) (lambda ,tmps ,@(map (lambda (x y) `(set! ,x ,y)) ff ft))) (values (void) ',formals)))))) ((guard . guard) scheme/base (lambda (clauses . body) (let* ((var (car clauses)) (last (last-pair clauses)) (ex (gensym)) (old-hdlr (gensym)) (reraised (gensym)) (res (gensym))) `(let ((,old-hdlr (current-exception-handler))) (with-handler (lambda (,ex) (let* ((,var (if (%continuable-exception? ,ex) (%continuable-exception-value ,ex) ,ex)) (,reraised #f) (,res (cond ,@(cdr clauses) ,@(if (and (pair? last) (pair? (car last)) (eq? (caar last) 'else)) '() `((else (set! ,reraised #t) (,old-hdlr ,ex))))))) (if ,reraised ,res (if (%continuable-exception? ,ex) (raise ,res) ,res)))) ,@body))))) ((include . include) scheme/base (lambda files `(%do-include include ,files))) ((include-ci . include-ci) scheme/base (lambda files `(%do-include include-ci ,files))) ((let*-values . let*-values) scheme/base (lambda (bindings . body) (if (> (length bindings) 1) `(let-values (,(car bindings)) (let*-values ,(cdr bindings) ,@body)) `(let-values ,bindings ,@body)))) ((let-values . let-values) scheme/base (lambda (bindings . body) (let ((tmps '())) (define (expand-once bindings tmps) (let ((first (car bindings))) `(call-with-values (lambda () ,(cadr first)) (lambda ,(map* (lambda (x) (cadr (assoc x tmps))) (car first)) ,(if (= (length bindings) 1) `(let ,tmps ,@body) (expand-once (cdr bindings) tmps)))))) (define (parse-binding binding) (unless (and (list? binding) (= (length binding) 2) (or (pair? (car binding)) (symbol? (car binding)))) (error 'let-values "incorrect binding ~S" binding)) (for-each* (lambda (x) (if (assoc x tmps) (error 'let-values "duplicate binding ~s" x) (set! tmps (cons (list x (gensym)) tmps)))) (car binding))) (for-each parse-binding bindings) (if (null? tmps) `(let () ,@body) (expand-once bindings tmps))))) ((letrec* . letrec*) scheme/base (lambda (bindings . body) (if (list? bindings) (for-each (lambda (x) (unless (and (list? x) (= (length x) 2)) (error 'letrec* "incorrect binding ~S" x))) bindings) (error 'letrec* "incorrect bindings ~S" bindings)) `(let ,(map (lambda (x) (list (car x) #f)) bindings) ,@(map (lambda (x) `(set! ,@x)) bindings) (let () ,@body)))) ((parameterize . parameterize) scheme/base (lambda (bindings . body) (let ((tmp1 (map (lambda (_) (gensym)) bindings)) (tmp2 (map (lambda (_) (gensym)) bindings))) `(let (,@(map (lambda (x y) (list y (cadr x))) bindings tmp1) ,@(map (lambda (x y) (list y (list (car x)))) bindings tmp2)) (dynamic-wind (lambda () ,@(map (lambda (x y) `(,(car x) ,y)) bindings tmp1)) (lambda () ,@body) (lambda () ,@(map (lambda (x y) `(,(car x) ,y)) bindings tmp2))))))) ((set! . set!) scheme/base (lambda args `(%%set! ,@args))) ((syntax-error . syntax-error) scheme/base (lambda args (if (zero? (length args)) (error 'syntax-error "needs at least one argument") `(%syntax-error ,@args)))) ((unless . unless) scheme/base (lambda args (if (<= (length args) 1) (syntax-error 'unless "bad syntax in ~S" `(unless ,@args)) `(if (not ,(car args)) (begin ,@(cdr args)))))) ((when . when) scheme/base (lambda args (if (<= (length args) 1) (syntax-error 'when "bad syntax in ~S" `(when ,@args)) `(if ,(car args) (begin ,@(cdr args))))))))
#(%module-handler scheme/base %module-create current-module ((SCHEME)) list-copy %do-imports %define-here (lambda lst `(begin ,@(map (lambda (symb) `(define ,symb #void)) lst))) begin define map %make-syntax ... => _ and case cond define-record-type do else if lambda let let* letrec let-syntax letrec-syntax or quasiquote quote syntax-rules unquote unquote-splicing * %symbol-define + - / < <= = > >= abs append apply assoc assq assv binary-port? boolean=? boolean? bytevector bytevector-append bytevector-copy bytevector-copy! bytevector-length bytevector-u8-ref bytevector-u8-set! bytevector? caar cadr call-with-current-continuation call-with-port call-with-values call/cc car cdar cddr cdr ceiling char->integer char-ready? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port close-port complex? cond-expand cons current-error-port current-input-port current-output-port define-syntax define-values denominator dynamic-wind eof-object eof-object? eq? equal? eqv? error error-object-irritants error-object-message error-object? even? exact exact-integer-sqrt exact-integer? exact? expt features file-error? floor floor-quotient floor-remainder floor/ flush-output-port for-each gcd get-output-bytevector get-output-string guard include include-ci inexact inexact? input-port-open? input-port? integer->char integer? lcm length let*-values let-values letrec* list list->string list->vector list-ref list-set! list-tail list? make-bytevector make-list make-parameter make-string make-vector max member memq memv min modulo negative? newline not null? number->string number? numerator odd? open-input-bytevector open-input-string open-output-bytevector open-output-string output-port-open? output-port? pair? parameterize peek-char peek-u8 port? positive? procedure? quotient raise raise-continuable rational? rationalize read-bytevector read-bytevector! read-char read-error? read-line read-string read-u8 real? remainder reverse round set! set-car! set-cdr! square string string->list string->number string->symbol string->utf8 string->vector string-append string-copy string-copy! string-fill! string-for-each string-length string-map string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol=? symbol? syntax-error textual-port? truncate truncate-quotient truncate-remainder truncate/ u8-ready? unless utf8->string values vector vector->list vector->string vector-append vector-copy vector-copy! vector-fill! vector-for-each vector-length vector-map vector-ref vector-set! vector? when with-exception-handler write-bytevector write-char write-string write-u8 zero? ((* . *) (+ . +) (- . -) (... . ...) (/ . /) (< . <) (<= . <=) (= . =) (=> . =>) (> . >) (>= . >=) (_ . _) (abs . abs) (and . and) (append . append) (apply . apply) (assoc . assoc) (assq . assq) (assv . assv) (begin . begin) (binary-port? . binary-port?) (boolean=? . boolean=?) (boolean? . boolean?) (bytevector . bytevector) (bytevector-append . bytevector-append) (bytevector-copy . bytevector-copy) (bytevector-copy! . bytevector-copy!) (bytevector-length . bytevector-length) (bytevector-u8-ref . bytevector-u8-ref) (bytevector-u8-set! . bytevector-u8-set!) (bytevector? . bytevector?) (caar . caar) (cadr . cadr) (call-with-current-continuation . call-with-current-continuation) (call-with-port . call-with-port) (call-with-values . call-with-values) (call/cc . call/cc) (car . car) (case . case) (cdar . cdar) (cddr . cddr) (cdr . cdr) (ceiling . ceiling) (char->integer . char->integer) (char-ready? . char-ready?) (char<=? . char<=?) (char<? . char<?) (char=? . char=?) (char>=? . char>=?) (char>? . char>?) (char? . char?) (close-input-port . close-input-port) (close-output-port . close-output-port) (close-port . close-port) (complex? . complex?) (cond . cond) (cond-expand . cond-expand) (cons . cons) (current-error-port . current-error-port) (current-input-port . current-input-port) (current-output-port . current-output-port) (define . define) (define-record-type . define-record-type) (define-syntax . define-syntax) (define-values . define-values) (denominator . denominator) (do . do) (dynamic-wind . dynamic-wind) (else . else) (eof-object . eof-object) (eof-object? . eof-object?) (eq? . eq?) (equal? . equal?) (eqv? . eqv?) (error . error) (error-object-irritants . error-object-irritants) (error-object-message . error-object-message) (error-object? . error-object?) (even? . even?) (exact . exact) (exact-integer-sqrt . exact-integer-sqrt) (exact-integer? . exact-integer?) (exact? . exact?) (expt . expt) (features . features) (file-error? . file-error?) (floor . floor) (floor-quotient . floor-quotient) (floor-remainder . floor-remainder) (floor/ . floor/) (flush-output-port . flush-output-port) (for-each . for-each) (gcd . gcd) (get-output-bytevector . get-output-bytevector) (get-output-string . get-output-string) (guard . guard) (if . if) (include . include) (include-ci . include-ci) (inexact . inexact) (inexact? . inexact?) (input-port-open? . input-port-open?) (input-port? . input-port?) (integer->char . integer->char) (integer? . integer?) (lambda . lambda) (lcm . lcm) (length . length) (let . let) (let* . let*) (let*-values . let*-values) (let-syntax . let-syntax) (let-values . let-values) (letrec . letrec) (letrec* . letrec*) (letrec-syntax . letrec-syntax) (list . list) (list->string . list->string) (list->vector . list->vector) (list-copy . list-copy) (list-ref . list-ref) (list-set! . list-set!) (list-tail . list-tail) (list? . list?) (make-bytevector . make-bytevector) (make-list . make-list) (make-parameter . make-parameter) (make-string . make-string) (make-vector . make-vector) (map . map) (max . max) (member . member) (memq . memq) (memv . memv) (min . min) (modulo . modulo) (negative? . negative?) (newline . newline) (not . not) (null? . null?) (number->string . number->string) (number? . number?) (numerator . numerator) (odd? . odd?) (open-input-bytevector . open-input-bytevector) (open-input-string . open-input-string) (open-output-bytevector . open-output-bytevector) (open-output-string . open-output-string) (or . or) (output-port-open? . output-port-open?) (output-port? . output-port?) (pair? . pair?) (parameterize . parameterize) (peek-char . peek-char) (peek-u8 . peek-u8) (port? . port?) (positive? . positive?) (procedure? . procedure?) (quasiquote . quasiquote) (quote . quote) (quotient . quotient) (raise . raise) (raise-continuable . raise-continuable) (rational? . rational?) (rationalize . rationalize) (read-bytevector . read-bytevector) (read-bytevector! . read-bytevector!) (read-char . read-char) (read-error? . read-error?) (read-line . read-line) (read-string . read-string) (read-u8 . read-u8) (real? . real?) (remainder . remainder) (reverse . reverse) (round . round) (set! . set!) (set-car! . set-car!) (set-cdr! . set-cdr!) (square . square) (string . string) (string->list . string->list) (string->number . string->number) (string->symbol . string->symbol) (string->utf8 . string->utf8) (string->vector . string->vector) (string-append . string-append) (string-copy . string-copy) (string-copy! . string-copy!) (string-fill! . string-fill!) (string-for-each . string-for-each) (string-length . string-length) (string-map . string-map) (string-ref . string-ref) (string-set! . string-set!) (string<=? . string<=?) (string<? . string<?) (string=? . string=?) (string>=? . string>=?) (string>? . string>?) (string? . string?) (substring . substring) (symbol->string . symbol->string) (symbol=? . symbol=?) (symbol? . symbol?) (syntax-error . syntax-error) (syntax-rules . syntax-rules) (textual-port? . textual-port?) (truncate . truncate) (truncate-quotient . truncate-quotient) (truncate-remainder . truncate-remainder) (truncate/ . truncate/) (u8-ready? . u8-ready?) (unless . unless) (unquote . unquote) (unquote-splicing . unquote-splicing) (utf8->string . utf8->string) (values . values) (vector . vector) (vector->list . vector->list) (vector->string . vector->string) (vector-append . vector-append) (vector-copy . vector-copy) (vector-copy! . vector-copy!) (vector-fill! . vector-fill!) (vector-for-each . vector-for-each) (vector-length . vector-length) (vector-map . vector-map) (vector-ref . vector-ref) (vector-set! . vector-set!) (vector? . vector?) (when . when) (with-exception-handler . with-exception-handler) (write-bytevector . write-bytevector) (write-char . write-char) (write-string . write-string) (write-u8 . write-u8) (zero? . zero?)) %do-exports %module-restore "scheme/base" provide)
2073
  
   - % U  V   J % % V    n U  V   ! M V   % U  U  # ˇˇ U 	 % # 
  U 
 e S  ; ; ; $ ! e V   ; $ ! U  V                   	         
                                              !   " % U # j # V $  % U % j % V $  % U & j & V $  % U  j  V $  % U ' j ' V $  % U ( j ( V $  % U ) j ) V $  % U * j * V $  % U  j  V $  % U + j + V $  % U , j , V $  % U  j  V $  % U - j - V $  % U  j  V $  % U . j . V $  % U / j / V $  % U 0 j 0 V $  % U 1 j 1 V $  % U 2 j 2 V $  % U 	 j 	 V $  % U 3 j 3 V $  % U 4 j 4 V $  % U 5 j 5 V $  % U 6 j 6 V $  % U 7 j 7 V $  % U 8 j 8 V $  % U 9 j 9 V $  % U : j : V $  % U ; j ; V $  % U < j < V $  % U = j = V $  % U > j > V $  % U ? j ? V $  % U @ j @ V $  % U A j A V $  % U B j B V $  % U C j C V $  % U D j D V $  % U  j  V $  % U E j E V $  % U F j F V $  % U G j G V $  % U H j H V $  % U I j I V $  % U J j J V $  % U K j K V $  % U L j L V $  % U M j M V $  % U N j N V $  % U O j O V $  % U P j P V $  % U Q j Q V $  % U R j R V $  % U S j S V $  % U T j T V $  % U  j  V $  % U U j U V $  % U V j V V $  % U W j W V $  % U X j X V $  % U Y j Y V $  % U 
 j 
 V $  % U  j  V $  % U Z j Z V $  % U [ j [ V $  % U \ j \ V $  % U  j  V $  % U ] j ] V $  % U  j  V $  % U ^ j ^ V $  % U _ j _ V $  % U ` j ` V $  % U a j a V $  % U b j b V $  % U c j c V $  % U d j d V $  % U e j e V $  % U f j f V $  % U g j g V $  % U h j h V $  % U i j i V $  % U j j j V $  % U k j k V $  % U l j l V $  % U m j m V $  % U n j n V $  % U o j o V $  % U p j p V $  % U q j q V $  % U r j r V $  % U s j s V $  % U t j t V $  % U u j u V $  % U v j v V $  % U w j w V $  % U x j x V $  % U  j  V $  % U y j y V $  % U z j z V $  % U { j { V $  % U | j | V $  % U } j } V $  % U ~ j ~ V $  % U  j  V $  % U Ä j Ä V $  % U  j  V $  % U Å j Å V $  % U Ç j Ç V $  % U  j  V $  % U  j  V $  % U É j É V $  % U  j  V $  % U Ñ j Ñ V $  % U  j  V $  % U Ö j Ö V $  % U  j  V $  % U Ü j Ü V $  % U á j á V $  % U à j à V $  % U  j  V $  % U â j â V $  % U ä j ä V $  % U ã j ã V $  % U å j å V $  % U ç j ç V $  % U é j é V $  % U è j è V $  % U ê j ê V $  % U ë j ë V $  % U  j  V $  % U í j í V $  % U ì j ì V $  % U î j î V $  % U ï j ï V $  % U ñ j ñ V $  % U ó j ó V $  % U ò j ò V $  % U ô j ô V $  % U ö j ö V $  % U õ j õ V $  % U ú j ú V $  % U ù j ù V $  % U û j û V $  % U ü j ü V $  % U † j † V $  % U ° j ° V $  % U ¢ j ¢ V $  % U £ j £ V $  % U  j  V $  % U § j § V $  % U • j • V $  % U ¶ j ¶ V $  % U ß j ß V $  % U ® j ® V $  % U © j © V $  % U ™ j ™ V $  % U ´ j ´ V $  % U ¨ j ¨ V $  % U  j  V $  % U  j  V $  % U ≠ j ≠ V $  % U Æ j Æ V $  % U Ø j Ø V $  % U ∞ j ∞ V $  % U ± j ± V $  % U ≤ j ≤ V $  % U ≥ j ≥ V $  % U ¥ j ¥ V $  % U µ j µ V $  % U ∂ j ∂ V $  % U ∑ j ∑ V $  % U ∏ j ∏ V $  % U π j π V $  % U ∫ j ∫ V $  % U ª j ª V $  % U º j º V $  % U Ω j Ω V $  % U æ j æ V $  % U ø j ø V $  % U ¿ j ¿ V $  % U ¡ j ¡ V $  % U ¬ j ¬ V $  % U √ j √ V $  % U ƒ j ƒ V $  % U ≈ j ≈ V $  % U ∆ j ∆ V $  % U « j « V $  % U » j » V $  % U … j … V $  % U   j   V $  % U À j À V $  % U Ã j Ã V $  % U Õ j Õ V $  % U Œ j Œ V $  % U œ j œ V $  % U – j – V $  % U — j — V $  % U “ j “ V $  % U ” j ” V $  % U ‘ j ‘ V $  % U ’ j ’ V $  % U ÷ j ÷ V $  % U ◊ j ◊ V $  % U ÿ j ÿ V $  % U Ÿ j Ÿ V $  % U ⁄ j ⁄ V $  % U   j   V $  % U € j € V $  % U ‹ j ‹ V $  % U › j › V $  % U ﬁ j ﬁ V $  % U ﬂ j ﬂ V $  % U ‡ j ‡ V $  % U · j · V $  % U ! j ! V $  % U " j " V $  % U ‚ j ‚ V $  % U „ j „ V $  % U ‰ j ‰ V $  % U Â j Â V $  % U Ê j Ê V $  % U Á j Á V $  % U Ë j Ë V $  % U È j È V $  % U Í j Í V $  % U Î j Î V $  % U Ï j Ï V $  % U Ì j Ì V $  % U Ó j Ó V $  % U Ô j Ô V $  % U  j  V $  % U Ò j Ò V $  % U Ú j Ú V $  % U Û j Û V $  % U Ù j Ù V $  % U ı j ı V $  % U ˆ j ˆ V $  % U ˜ j ˜ V $  % % V    ! U ¯ V ˘  % V ˙   J % S U  V „  . % U ˚ V ¸  /
