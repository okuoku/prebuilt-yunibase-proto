;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Sat Mar 25 05:01:47 2023


;; Source file "base64.c"

(base64-encode :type extended :synopsis "(base64-encode in)\n(base64-encode in out)" :description "Encode in Base64 the characters from input port |in| to the output port\n|out|. If |out| is not specified, it defaults to the current output port.\n@lisp\n(with-input-from-string \"Hello\"\n  (lambda ()\n    (with-output-to-string\n      (lambda ()\n        (base64-encode (current-input-port)))))) => \"SGVsbG8=\"\n@end lisp" :similar ())

(base64-decode :type extended :synopsis "(base64-decode in)\n(base64-decode in out)" :description "Decode the Base64 characters from input port |in| to the output port\n|out|. If |out| is not specified, it defaults to the current output port.\n\n@lisp\n(with-input-from-string \"SGVsbG8=\"\n  (lambda ()\n    (with-output-to-string\n      (lambda ()\n        (base64-decode (current-input-port))))))  => \"Hello\"\n@end lisp" :similar ())


;; Source file "boolean.c"

(not :type procedure :synopsis "(not obj)" :description "Not returns |#t| if |obj| is false, and returns |#f| otherwise.\n\n@lisp\n  (not #t)         =>  #f\n  (not 3)          =>  #f\n  (not (list 3))   =>  #f\n  (not #f)         =>  #t\n  (not '())        =>  #f\n  (not (list))     =>  #f\n  (not 'nil)       =>  #f\n@end lisp" :similar ())

(boolean? :type procedure :synopsis "(boolean? obj)" :description "|Boolean?| returns |#t| if |obj| is either |#t| or |#f| and returns\n|#f| otherwise.\n@lisp\n  (boolean? #f)         =>  #t\n  (boolean? 0)          =>  #f\n  (boolean? '())        =>  #f\n@end lisp" :similar ())

(eqv? :type procedure :synopsis "(eqv? obj1 obj2)" :description "The |eqv?| procedure defines a useful equivalence relation on objects.\nBriefly, it returns |#t| if |obj1| and |obj2| should normally be regarded\nas the same object. This relation is left slightly open to interpretation,\nbut the following partial specification of |eqv?| holds for all\nimplementations of Scheme.\n\nThe |eqv?| procedure returns |#t| if:\n\n- |obj1| and |obj2| are both |#t| or both |#f|.\n\n- |obj1| and |obj2| are both symbols and\n+\n```scheme\n(string=? (symbol->string obj1)\n          (symbol->string obj2))     =>  #t\n```\n+\nNOTE: This assumes that neither |obj1| nor |obj2| is an\n\"uninterned symbol\".\n\n- |obj1| and |obj2| are both keywords and\n+\n```scheme\n(string=? (keyword->string obj1)\n          (keyword->string obj2))    =>  #t\n```\n\n- |obj1| and |obj2| are both numbers, are _<<numeq,numerically equal>>_,\n and are either both exact or both inexact.\n\n- |obj1| and |obj2| are both characters and are the same character\n  according to the _<<chareq, `char=?` procedure>>`_.\n\n-  both |obj1| and |obj2| are the empty list.\n\n- |obj1| and |obj2| are pairs, vectors, or strings that denote\n  the same locations in the store.\n\n- |obj1| and |obj2| are procedures whose location tags are equal.\n\nSTklos extends R5RS |eqv?| to take into account\nthe keyword type. Here are some examples:\n@lisp\n(eqv? 'a 'a)                     =>  #t\n(eqv? 'a 'b)                     =>  #f\n(eqv? 2 2)                       =>  #t\n(eqv? :foo :foo)                 =>  #t\n(eqv? #:foo :foo)                =>  #t\n(eqv? :foo :bar)                 =>  #f\n(eqv? '() '())                   =>  #t\n(eqv? 100000000 100000000)       =>  #t\n(eqv? (cons 1 2) (cons 1 2))     =>  #f\n(eqv? (lambda () 1)\n      (lambda () 2))             =>  #f\n(eqv? #f 'nil)                   =>  #f\n(let ((p (lambda (x) x)))\n  (eqv? p p))                    =>  #t\n@end lisp\n\nThe following examples illustrate cases in which the above rules do\nnot fully specify the behavior of |eqv?|. All that can be said about\nsuch cases is that the value returned by eqv? must be a boolean.\n@lisp\n(eqv? \"\" \"\")             =>  unspecified\n(eqv? '#() '#())         =>  unspecified\n(eqv? (lambda (x) x)\n      (lambda (x) x))    =>  unspecified\n(eqv? (lambda (x) x)\n      (lambda (y) y))    =>  unspecified\n@end lisp\n\nNOTE: In fact, the value returned by STklos depends on\nthe way code is entered and can yield |#t| in some cases and |#f|\nin others.\n\nSee R5RS for more details on |eqv?|." :similar ())

(eq? :type procedure :synopsis "(eq? obj1 obj2)" :description "|Eq?| is similar to |eqv?| except that in some cases it is capable of\ndiscerning distinctions finer than those detectable by |eqv?|.\n\n|Eq?| and |eqv?| are guaranteed to have the same behavior on symbols,\nkeywords, booleans, the empty list, pairs, procedures, and non-empty strings\nand vectors. `|Eq?|`'s behavior on numbers and characters is\nimplementation-dependent, but it will always return either true or false,\nand will return true only when |eqv?| would also return true.\n|Eq?| may also behave differently from |eqv?| on empty vectors\nand empty strings. +\nNote that:\n\n  - STklos extends R5RS |eq?| to take into account  the keyword type.\n  - In STklos, comparison of character returns |#t| for identical\n    characters and |#f| otherwise.\n\n\n@lisp\n(eq? 'a 'a)                     =>  #t\n(eq? '(a) '(a))                 =>  unspecified\n(eq? (list 'a) (list 'a))       =>  #f\n(eq? \"a\" \"a\")                   =>  unspecified\n(eq? \"\" \"\")                     =>  unspecified\n(eq? :foo :foo)                 =>  #t\n(eq? :foo :bar)                 =>  #f\n(eq? '() '())                   =>  #t\n(eq? 2 2)                       =>  unspecified\n(eq? #A #A)                     =>  #t (unspecified in r5rs)\n(eq? car car)                   =>  #t\n(let ((n (+ 2 3)))\n  (eq? n n))                    =>  #t (unspecified in r5rs)\n(let ((x '(a)))\n  (eq? x x))                    =>  #t\n(let ((x '#()))\n  (eq? x x))                    =>  #t\n(let ((p (lambda (x) x)))\n  (eq? p p))                    =>  #t\n(eq? :foo :foo)                 =>  #t\n(eq? :bar bar:)                 =>  #t\n(eq? :bar :foo)                 =>  #f\n@end lisp\n" :similar ())

(equal? :type procedure :synopsis "(equal? obj1 obj2)" :description "|Equal?| recursively compares the contents of pairs, vectors, and\nstrings, applying |eqv?| on other objects such as numbers and symbols.\nA rule of thumb is that objects are generally |equal?| if they print the\nsame. |Equal?| always terminates even if its arguments are circular\ndata structures.\n@lisp\n(equal? 'a 'a)                  =>  #t\n(equal? '(a) '(a))              =>  #t\n(equal? '(a (b) c)\n        '(a (b) c))             =>  #t\n(equal? \"abc\" \"abc\")            =>  #t\n(equal? 2 2)                    =>  #t\n(equal? (make-vector 5 'a)\n        (make-vector 5 'a))     =>  #t\n(equal? '#1=(a b . #1#)\n        '#2=(a b a b . #2#))    =>  #t\n@end lisp\n\nNOTE: A rule of thumb is that objects are generally\n|equal?| if they print the same." :similar ())


;; Source file "boot.c"


;; Source file "box.c"

(box :type extended :synopsis "(box value ...)\n(make-box value ...)" :description "Returns a new box that contains all the given |value|s.\nThe box is mutable.\n@lisp\n(let ((x (box 10)))\n  (list 10 x))        => (10 #&10)\n@end lisp\n\nNOTE: The name |make-box| is now obsolete and kept only for compatibility." :similar (make-box))

(make-box :see box)
(constant-box :type extended :synopsis "(constant-box value ...)\n(make-constant-box value ...)" :description "Returns a new box that contains all the given |value|s. The box is immutable.\n\nNOTE: The name |make-constant-box| is now obsolete and kept only for compatibility." :similar (make-constant-box))

(make-constant-box :see constant-box)
(box? :type extended :synopsis "(box? obj)" :description "Returns |#t| if |obj| is a box, |#f| otherwise." :similar ())

(box-mutable? :type extended :synopsis "(box-mutable? obj)" :description "Returns |#t| if |obj| is a mutable box, |#f| otherwise." :similar ())

(unbox :type extended :synopsis "(unbox box)" :description "Returns the values currently in |box|." :similar ())

(set-box! :type extended :synopsis "(set-box! box value ...)\n(box-set! box value ...)" :description "Changes |box| to hold |value|s. It is an error if |set-box!| is called\nwith a number of values that differs from the number of values in the box\nbeing set. (In other words, |set-box!| does not allocate memory.)\nIt is also an error to call |set-box!| on a box which is not mutable.\n\nThe name |box-set!| is now obsolete and kept only for compatibility." :similar (box-set!))

(box-set! :see set-box!)
(box-arity :type extended :synopsis "(box-arity box)" :description "Returns the number of values in |box|." :similar ())

(unbox-value :type extended :synopsis "(unbox-value box i)" :description "Returns the `|i|`th value of |box|. It is an error if |i| is not an exact integer\nbetween 0 and `|n|`-1, when |n| is the number of values in |box|." :similar ())

(set-box-value! :type extended :synopsis "(set-box-value! box i obj)" :description "Changes the `|i|`th value of |box| to |obj|. It is an error if |i| is not an\nexact integer between 0 and `|n|`-1, when |n| is the number of values in |box|." :similar ())


;; Source file "char.c"

(char? :type procedure :synopsis "(char? obj)" :description "Returns |#t| if |obj| is a character, otherwise returns |#f|." :similar ())

(char>=? :type procedure :synopsis "(char=? char1 char2 ...)\n(char<? char1 char2 ...)\n(char>? char1 char2 ...)\n(char<=? char1 char2 ...)\n(char>=? char1 char2 ...)" :description "These procedures impose a total ordering on the set of characters.\nIt is guaranteed that under this ordering:\n\n- The upper case characters are in order.\n- The lower case characters are in order.\n- The digits are in order.\n- Either all the digits precede all the upper case letters, or vice versa.\n- Either all the digits precede all the lower case letters, or vice versa.\n)" :similar (char<=? char>? char<? char=?))

(char<=? :see char>=?)
(char>? :see char>=?)
(char<? :see char>=?)
(char=? :see char>=?)
(char-ci>=? :type procedure :synopsis "(char-ci=? char1 char2 ...)\n(char-ci<? char1 char2 ...)\n(char-ci>? char1 char2 ...)\n(char-ci<=? char1 char2 ...)\n(char-ci>=? char1 char2 ...)" :description "These procedures are similar to |char=?| et cetera, but they treat\nupper case and lower case letters as the same. For example,\n|(char-ci=? #\\A #\\a)| returns |#t|." :similar (char-ci<=? char-ci>? char-ci<? char-ci=?))

(char-ci<=? :see char-ci>=?)
(char-ci>? :see char-ci>=?)
(char-ci<? :see char-ci>=?)
(char-ci=? :see char-ci>=?)
(char-lower-case? :type procedure :synopsis "(char-alphabetic? char)\n(char-numeric? char)\n(char-whitespace? char)\n(char-upper-case? letter)\n(char-lower-case? letter)" :description "These procedures return |#t| if their arguments are alphabetic, numeric,\nwhitespace, upper case, or lower case characters, respectively, otherwise they\nreturn |#f|. The following remarks, which are specific to the ASCII character\nset, are intended only as a guide: The alphabetic characters are the 52\nupper and lower case letters. The numeric characters are the ten decimal\ndigits. The whitespace characters are space, tab, line feed, form feed,\nand carriage return." :similar (char-upper-case? char-whitespace? char-numeric? char-alphabetic?))

(char-upper-case? :see char-lower-case?)
(char-whitespace? :see char-lower-case?)
(char-numeric? :see char-lower-case?)
(char-alphabetic? :see char-lower-case?)
(digit-value :type r7rs-procedure :synopsis "(digit-value char)" :description "This procedure returns the numeric value (0 to 9) of its\nargument if it is a numeric digit (that is, if char-numeric?\nreturns #t), or #f on any other character.\n@lisp\n(digit-value\n(digit-value #\\3)        => 3\n(digit-value #\\x0664)    => 4\n(digit-value #\\x0AE6)    => 0\n(digit-value #\\x0EA6)    => #f\n@end lisp" :similar ())

(integer->char :type procedure :synopsis "(char->integer char)\n(integer->char n)" :description "Given a character, |char->integer| returns an exact integer\nrepresentation of the character. Given an exact integer that is the\nimage of a character under |char->integer|, |integer->char| returns\nthat character. These procedures implement order-preserving\nisomorphisms between the set of characters under the |char<=?|\nordering and some subset of the integers under the |<=|\nordering. That is, if\n@lisp\n   (char<=? a b) => #t  and  (<= x y) => #t\n@end lisp\nand x and y are in the domain of |integer->char|, then\n@lisp\n   (<= (char->integer a)\n       (char->integer b))         =>  #t\n\n  (char<=? (integer->char x)\n           (integer->char y))     =>  #t\n@end lisp\n|integer->char| accepts an exact number between 0 and #xD7FFF or between\n#xE000 and #x10FFFF, if UTF8 encoding is used. Otherwise, it accepts a\nnumber between 0 and #xFF." :similar (char->integer))

(char->integer :see integer->char)
(char-downcase :type procedure :synopsis "(char-upcase char)\n(char-downcase char)" :description "These procedures return a character |char2| such that\n|(char-ci=? char char2)|. In addition, if char is alphabetic, then the\nresult of |char-upcase| is upper case and the result of |char-downcase| is\nlower case." :similar (char-upcase))

(char-upcase :see char-downcase)
(char-foldcase :type extended :synopsis "(char-foldcase char)" :description "This procedure applies the Unicode simple case folding algorithm and returns\nthe result. Note that language-sensitive folding is not used. If\nthe argument is an uppercase letter, the result will be either a\nlowercase letter or the same as the argument if the lowercase letter\ndoes not exist." :similar ())


;; Source file "cond.c"

(make-condition-type :type extended :synopsis "(make-condition-type id  parent  slot-names)" :description "|Make-condition-type| returns a new condition type. |Id| must be a symbol\nthat serves as a symbolic name for the condition type. |Parent| must itself\nbe a condition type. |Slot-names| must be a list of symbols. It identifies\nthe slots of the conditions associated with the condition type.\n" :similar ())

(make-compound-condition-type :type extended :synopsis "(make-compound-condition-type id ct~1~ ...)" :description "|Make-compound-condition-type| returns a new condition type, built\nfrom the condition types |ct~1~|, ...\n|Id| must be a symbol that serves as a symbolic name for the\ncondition type. The slots names of the new condition type is the\nunion of the slots of conditions |ct~1~| ...\n\nNOTE: This function is not defined in {{link-srfi 34}}." :similar ())

(condition-type? :type extended :synopsis "(condition-type? obj)" :description "Returns |#t| if |obj| is a condition type, and |#f| otherwise" :similar ())

(make-condition :type extended :synopsis "(make-condition type slot-name value  ...)" :description "|Make-condition| creates a condition value belonging condition type\n|type|. The following arguments must be, in turn, a slot name and an\narbitrary value. There must be such a pair for each slot of |type| and\nits direct and indirect supertypes. |Make-condition| returns the\ncondition value, with the argument values associated with their\nrespective slots.\n@lisp\n(let* ((ct (make-condition-type 'ct1 &condition '(a b)))\n       (c  (make-condition ct 'b 2 'a 1)))\n  (struct->list c))\n     => ((a . 1) (b . 2))\n@end lisp" :similar ())

(condition? :type extended :synopsis "(condition? obj)" :description "Returns |#t| if |obj| is a condition, and |#f| otherwise" :similar ())

(make-compound-condition :type extended :synopsis "(make-compound-condition condition~0~ condition~1~ ...)" :description "|Make-compound-condition| returns a compound condition belonging to\nall condition types that the |condition~i~| belong to.\n\n|Condition-ref|, when applied to a compound condition will return\n the value from the first of the |conditioni| that has such a slot." :similar ())

(condition-ref :type extended :synopsis "(condition-ref condition slot-name)" :description "|Condition| must be a condition, and |slot-name| a symbol. Moreover,\n|condition| must belong to a condition type which has a slot name called\n|slot-name|, or one of its (direct or indirect) supertypes must have the\nslot. |Condition-ref| returns the value associated with |slot-name|.\n@lisp\n(let* ((ct (make-condition-type 'ct1 &condition '(a b)))\n       (c  (make-condition ct 'b 2 'a 1)))\n  (condition-ref c 'b))\n     => 2\n@end lisp" :similar ())

(condition-set! :type extended :synopsis "(condition-set! condition slot-name obj)" :description "|Condition| must be a condition, and |slot-name| a symbol. Moreover,\n|condition| must belong to a condition type which has a slot name called\n|slot-name|, or one of its (direct or indirect) supertypes must have the\nslot. |Condition-set!| change the value associated with |slot-name| to |obj|.\n@l\nNOTE: Whereas |condition-ref| is defined in ,(srfi 35),\n|confition-set!| is not." :similar ())

(condition-has-type? :type extended :synopsis "(condition-has-type? condition condition-type)" :description "|Condition-has-type?| tests if |condition| belongs to |condition-type|.\nIt returns |#t| if any of condition 's types includes |condition-type|\neither directly or as an ancestor and |#f| otherwise.\n@lisp\n (let* ((ct1 (make-condition-type 'ct1 &condition '(a b)))\n        (ct2 (make-condition-type 'ct2 ct1 '(c)))\n        (ct3 (make-condition-type 'ct3 &condition '(x y z)))\n        (c   (make-condition ct2 'a 1 'b 2 'c 3)))\n  (list (condition-has-type? c ct1)\n     (condition-has-type? c ct2)\n     (condition-has-type? c ct3)))\n    => (#t #t #f)\n@end lisp" :similar ())

(extract-condition :type extended :synopsis "(extract-condition condition  condition-type)" :description "|Condition| must be a condition belonging to |condition-type|.\n|Extract-condition| returns a condition of |condition-type|\nwith the slot values specified by |condition|. The new condition\nis always allocated.\n@lisp\n(let* ((ct1 (make-condition-type 'ct1 &condition '(a b)))\n       (ct2 (make-condition-type 'ct2 ct1 '(c)))\n       (c2  (make-condition ct2 'a 1 ' b 2 'c 3))\n       (c1  (extract-condition c2 ct1)))\n  (list (condition-has-type? c1 ct2)\n     (condition-has-type? c1 ct1)))\n      => (#f #t)\n@end lisp" :similar ())

(raise :type r7rs-procedure :synopsis "(raise obj)" :description "Invokes the current exception handler on |obj|. The handler is called in\nthe dynamic environment of the call to |raise|, except that the current\nexception handler is that in place for the call to |with-handler|\nthat installed the handler being called.\n\n@lisp\n(with-handler (lambda (c)\n             (format \"value ~A was raised\" c))\n   (raise 'foo)\n   (format #t \"never printed\\\\n\"))\n          => \"value foo was raised\"\n@end lisp" :similar ())


;; Source file "cpointer.c"

(cpointer? :type extended :synopsis "(cpointer? obj)" :description "Returns `#t` is |obj| is a cpointer (a Scheme object which encapsulate\na pointer to a C object), and `#f` otherwise." :similar ())

(cpointer-null? :type extended :synopsis "(cpointer-null? obj)" :description "Returns `#t` is |obj| is a cpointer and its value is the C NULL value.\nReturnd `#f` otherwise." :similar ())

(cpointer-type-set! :type extended :synopsis "(cpointer-type obj)\n(cpointer-type-set! obj tag)" :description "|cpointer-type| returns the tag type associated to a cpointer. The C\nruntime or an extension can associate * a tag to a cpointer to make\n some controls  (for instance, verify that |obj| is a cpointer  on a\n`widget` structure). This function returns *void* if a type has not\nbeen set before. The semantic associated to this tag is completely\nleft to the extension writer.\n\n|cpointer-type-set!| permits to set the tag of the |obj| cpointer to\n|tag| (which can be of any type)." :similar (cpointer-type))

(cpointer-type :see cpointer-type-set!)
(cpointer-data-set! :type extended :synopsis "(cpointer-data obj)\n(cpointer-data-set! obj adr)" :description "|cpointer-data| returns the value associated to cpointer |obj|\n(that is the value of the pointer itself: an address).\n\n|cpointer-data-set!| permits to change the pointer stored in the |obj|\ncpointer to |adr|. This is of course very dangerous and could lead to\nfatal errors." :similar (cpointer-data))

(cpointer-data :see cpointer-data-set!)
(cpointer->string :type extended :synopsis "(cpointer->string str)" :description "Returns the C (null terminated) string |str| as a Scheme string.\nIf |str| doesn't contain a C string, the result will probably result\nin a fatal error.\n\n@lisp\n(define-external c-ghn ((s :pointer) (size :int))\n                 :entry-name \"gethostname\"\n                 :return-type :int)\n(define name (allocate-bytes 10))\n\nname                    => #[C-pointer 7fd830820f80 @ 7fd8305bee40]\n(c-ghn name 9)          => 0\n(cpointer->string name) => \"socrates\"\n@end lisp" :similar ())

(allocate-bytes :type extended :synopsis "(allocate-bytes n)" :description "|Allocate-bytes| will allocate |n| consecutive bytes using\nthe standard STklos allocation function (which uses the\nBoehmâ\x80;\x93;Demersâ\x80;\x93;Weiser garbage collector <<BoehmGC>>).\nIt returns a |cpointer| Scheme object that points to the first byte\nallocated. This pointer is managed by the  standard GC and doesn't need\nto be freed." :similar ())

(free-bytes :type extended :synopsis "(free-bytes obj)" :description "|Obj| must be a |cpointer| to allocated data. When |Free-bytes| is called\non |obj|, it will deallocate its data calling\n- the C function |free| (if it  was allocated by the standard C |malloc|\n  function), or\n- the Boehm GC free  function (if the pointer was allocated using\n  |allocate-bytes| primitive).\n\n@lisp\n(define a (allocate-bytes 10))\na   => #[C-pointer 7fd91e8e0f80 @ 7fd91e897b70]\n(cpointer-type-set! a 'myadress)\na   => #[myadress-pointer 7fd91e8e0f80 @ 7fd91e897b70]\n(free-bytes a)\na   => #[myadress-pointer 0 @ 7fd91e897b70]\n@end lisp\n\nAfter the call to |free-bytes|, when |a| is printed, the first number\nshown is zero, indicating that its data pointer does not point to\nallocated memory (a NULL value for C)." :similar ())


;; Source file "dynload.c"


;; Source file "env.c"

(module? :type extended :synopsis "(module? object)" :description "Returns |#t| if |object| is a module and |#f| otherwise.\n@lisp\n(module? (find-module 'STklos))   => #t\n(module? 'STklos)                 => #f\n(module? 123 'no)                 => no\n@end lisp" :similar ())

(library? :type extended :synopsis "(library? object)" :description "Returns |#t| if |object| is a module defined as a R7RS library and |#f| otherwise.\nNote that R7RS libraries, since they are implemented using {{stklos}} modules, are\nalso modules.\n@lisp\n(define-module a)\n(define-library b)\n\n(module? (find-module 'a))   => #t\n(module? (find-module 'b))   => #t\n(library? (find-module 'a))  => #f\n(library? (find-module 'b))  => #t\n@end lisp" :similar ())

(find-module :type extended :synopsis "(find-module name)\n(find-module name default)" :description "STklos modules are first class objects and |find-module| returns the\nmodule associated to |name| if it exists. If there is no module\nassociated to |name|, an error is signaled if no |default| is\nprovided, otherwise |find-module| returns |default|." :similar ())

(current-module :type extended :synopsis "(current-module)" :description "Returns the current module.\n@lisp\n(define-module M\n  (display\n      (cons (eq? (current-module) (find-module 'M))\n            (eq? (current-module) (find-module 'STklos)))))  @print{} (#t . #f)\n@end lisp" :similar ())

(module-name :type extended :synopsis "(module-name module)" :description "Returns the name (a symbol) associated to a |module|." :similar ())

(module-imports :type extended :synopsis "(module-imports module)" :description "Returns the list of modules that |module| (fully) imports." :similar ())

(module-exports :type extended :synopsis "(module-exports module)" :description "Returns the list of symbols exported by |module|. Note that this function\nreturns the list of symbols given in the module |export| clause and that\nsome of these symbols can be not yet defined." :similar ())

(module-symbols :type extended :synopsis "(module-symbols module)" :description "Returns the list of symbols already defined in |module|." :similar ())

(all-modules :type extended :synopsis "(all-modules)" :description "Returns the list of all the living modules." :similar ())

(module-immutable! :type extended :synopsis "(module-immutable! module)" :description "Makes the module |module| immutable, so that it will be impossible\nto define new symbols in it or change the value of already defined ones.\n" :similar ())

(module-mutable? :type extended :synopsis "(module-mutable? mod)" :description "Returns |#t| if |mod| is an immutable module and |#f|  otherwise.  Note that the\n|SCHEME| module, which contains the original bindings of the STklos at boot\ntime, is immutable.\n\n@lisp\n(module-mutable? (find-module 'STklos)) => #t\n(module-mutable? (find-module 'SCHEME)) => #f\n@end lisp" :similar ())

(symbol-mutable? :type extended :synopsis "(symbol-mutable? symb)\n(symbol-mutable? symb module)" :description "Returns |#t| if |symb| is mutable in |module| and |#f| otherwise. If |module|\nis omitted it defaults to the current module. Note that imported symbols are\nalways not mutable.\n@lisp\n(define-module M\n   (export x)\n   (define x 1))\n\n(symbol-mutable? 'x (find-module 'M)) => #t\n(symbol-mutable? 'x)                  => error, if not defined in current module\n(import M)\n(symbol-mutable? 'x)                  => #f\n@end lisp" :similar ())

(symbol-immutable! :type extended :synopsis "(symbol-immutable! symb)\n(symbol-immutable! symb mod)" :description "Makes the symbol |symb| in module |mod| immutable. If |mod| is not specified,\nthe current module is used.\n\n@lisp\n(define a 1)\n(symbol-mutable? 'a)     => #t\n(symbol-immutable! 'a)\n(symbol-mutable? 'a)     => #f\n(set! a 10)              => error\n@end lisp" :similar ())

(symbol-value :type extended :synopsis "(symbol-value symbol module)\n(symbol-value symbol module default)" :description "Returns the value bound to |symbol| in |module|. If |symbol| is not bound,\nan error is signaled if no |default| is provided, otherwise |symbol-value|\nreturns |default|." :similar ())

(symbol-value* :type extended :synopsis "(symbol-value+++*+++ symbol module)\n(symbol-value+++*+++ symbol module default)" :description "Returns the value bound to |symbol| in |module|. If |symbol| is not bound,\nan error is signaled if no |default| is provided, otherwise |symbol-value|\nreturns |default|.\n\nNote that this function searches the value of |symbol| in |module|\n*and* in the STklos module if module is not a R7RS library." :similar ())

(symbol-bound? :type extended :synopsis "(symbol-bound? symb)\n(symbol-bound? symb module)" :description "Returns #t is |symb| is bound in |module| and #f otherwise. If |module| is\nomitted it defaults to the current module." :similar ())


;; Source file "error.c"


;; Source file "extend.c"


;; Source file "ffi.c"


;; Source file "fixnum.c"

(fixnum? :type extended :synopsis "(fixnum? obj)" :description "Returns |#t| if obj is an exact integer within the fixnum range,\n|#f| otherwise." :similar ())

(fixnum-width :type extended :synopsis "(fixnum-width)" :description "Returns the number of bits used to represent a fixnum number." :similar ())

(greatest-fixnum :type extended :synopsis "(least-fixnum)\n(greatest-fixnum)" :description "These procedures return the minimum value and the maximum value of\nthe fixnum range." :similar (least-fixnum))

(least-fixnum :see greatest-fixnum)
(fxzero? :type extended :synopsis "(fxzero? obj)" :description "|fxzero?| returns |#t| if |obj| is the fixnum zero and returns\n|#f| if it is a non-zero fixnum.\n@lisp\n  (fxzero? #f)             =>  error\n  (fxzero? (expt 100 100)) =>  error\n  (fxzero? 0)              =>  #t\n  (fxzero? 1)              =>  #f\n@end lisp" :similar ())

(fxnegative? :type extended :synopsis "(fxpositive? obj)\n(fxnegative? obj)" :description "|fxpositive?| returns |#t| if |obj| is a positive fixnum and returns\n|#f| if it is a non-positive fixnum. |fxnegative?| can be used to test\nif a fixnum is negative.\n@lisp\n  (fxpositive? #f)             =>  error\n  (fxpositive? (expt 100 100)) =>  error\n  (fxpositive? 0)              =>  #f\n  (fxpositive? 1)              =>  #t\n  (fxpositive? -1)             =>  #f\n  (fxnegative? 0)              =>  #f\n  (fxnegative? 1)              =>  #f\n  (fxnegative? -1)             =>  #t\n@end lisp" :similar (fxpositive?))

(fxpositive? :see fxnegative?)
(fxeven? :type extended :synopsis "(fxodd? obj)" :description "|fxodd?| returns |#t| if |obj| is a odd fixnum and returns\n|#f| if it is an even fixnum.\n@lisp\n  (fxodd? #f)             =>  error\n  (fxodd? (expt 100 100)) =>  error\n  (fxodd? 0)              =>  #f\n  (fxodd? 1)              =>  #t\n  (fxodd? 4)              =>  #f\n  (fxeven? 0)             =>  #t\n  (fxeven? 1)             =>  #f\n  (fxeven? 4)             =>  #t\n@end lisp" :similar (fxodd?))

(fxodd? :see fxeven?)
(fxneg :type extended :synopsis "(fx+ fx1 fx2)\n(fx- fx1 fx2)\n(fx* fx1 fx2)\n(fxquotient fx1 fx2)\n(fxremainder fx1 fx2)\n(fxmodulo fx1 fx2)\n(fxabs fx)\n(fxneg fx)" :description "These procedures compute (respectively) the sum, the difference, the product,\nthe quotient and the remainder and modulo of the fixnums |fx1| and |fx2|.\nThe call of  |fx-| with one parameter |fx| computes the opposite of |fx|, and\nis equivalent in a call of |fxneg| with this parameter. |fxabs|\ncomputes the absolute value of |fx|." :similar (fxabs fxmodulo fxremainder fxquotient fx* fx- fx+))

(fxabs :see fxneg)
(fxmodulo :see fxneg)
(fxremainder :see fxneg)
(fxquotient :see fxneg)
(fx* :see fxneg)
(fx- :see fxneg)
(fx+ :see fxneg)
(fxsqrt :type extended :synopsis "(fxsquare fx1)\n(fxsqrt fx1)" :description "These procedures compute (respectively) the square and the square root\nof the fixnum |fx1|.\n|fxsqrt| id semantically equivalent to exact-integer-sqrt (not sqrt), so\nthat |(fxsqrt n)| returns two values |a|, |b|, such that |a*a+b|=|n|.\n@lisp\n  (fxsqrt #f)             =>  error\n  (fxsqrt (expt 100 100)) =>  error\n  (fxsqrt -1)             =>  error\n  (fxsqrt 0)              =>  0, 0\n  (fxsqrt 1)              =>  1, 0\n  (fxsqrt 6)              =>  2, 2\n@end lisp" :similar (fxsquare))

(fxsquare :see fxsqrt)
(fxmin :type extended :synopsis "(fxmax fx1 fx2 ...)\n(fxmin fx1 fx2 ...)" :description "These procedures return the maximum or minimum of their fixnum arguments.\n@lisp\n(fxmax 3 4)              =>  4\n(fxmax 3.9 4)            =>  error\n(fxmax)                  =>  error\n(fxmax 2 -1 3)           =>  3\n@end lisp" :similar (fxmax))

(fxmax :see fxmin)
(fx=? :type extended :synopsis "(fx<? fx1 fx2 ...)\n(fx<=? fx1 fx2 ...)\n(fx>? fx1 fx2 ...)\n(fx>=? fx1 fx2 ...)\n(fx=? fx1 fx2 ...)" :description "These are SRFI-143 procedures that compare the fixnums |fx1|, |fx2|, and so on.\n|fx<?| and |fx>?| return |#t| if the arguments are in strictly\nincreasing/decreasing order;\n|fx<=?| and |fx>=?| do the same, but admit equal neighbors;\n|fx=?| returns |#t| if the arguments are all equal." :similar (fx>=? fx>? fx<=? fx<?))

(fx>=? :see fx=?)
(fx>? :see fx=?)
(fx<=? :see fx=?)
(fx<? :see fx=?)
(fxxor :type extended :synopsis "(fxnot fx1)\n(fxand fx ...)\n(fxior fx ...)\n(fxxor fx ...)" :description "These procedures are specified in SRFI-143, and they return\n(respectively) the bitwise not, and, inclusive or and exclusive\nor of their arguments, which must be fixnums.\n@lisp\n(fxnot 1)              => -2\n(fxnot 0)              => -1\n(fxand #x1010 #x1011)  => 4112  ; = #x1010\n(fxior #x1010 #x1011)  => 4113  ; = #x1011\n(fxxor #x1010 #x1011)  => 1     ; = #x0001\n@end lisp" :similar (fxior fxand fxnot))

(fxior :see fxxor)
(fxand :see fxxor)
(fxnot :see fxxor)
(fxarithmetic-shift :type extended :synopsis "(fxarithmetic-shift-right fx count)\n(fxarithmetic-shift-left fx count)\n(fxarithmetic-shift fx count)" :description "These procedures are specified in SRFI-143, and they perform\nbitwise right-shift, left-shft and shift with arbitrary direction\non fixnums. The strictly left and right shifts are more efficient.\n@lisp\n(fxarithmetic-shift-right #b100110 3) =>   4 ; = #b100\n(fxarithmetic-shift-left  #b100110 3) => 304 ; = #b100110000\n(fxarithmetic-shift #b101 2)          => 20  ; = #b10100\n(fxarithmetic-shift #b101 -2)         =>  1  ; =#b1\n@end lisp" :similar (fxarithmetic-shift-left fxarithmetic-shift-right))

(fxarithmetic-shift-left :see fxarithmetic-shift)
(fxarithmetic-shift-right :see fxarithmetic-shift)
(fxlength :type extended :synopsis "(fxlength fx)" :description "This is a SRFI-143 procedure that returns the length of the fixnum in\nbits (that is, the number of bits necessary to represent the number).\n@lisp\n(fxlength #b101)          =>  3\n(fxlength #b1101)         =>  4\n(fxlength #b0101)         =>  3\n@end lisp" :similar ())

(fxif :type extended :synopsis "(fxif mask fx1 fx2)" :description "This is a SRFI-143 procedure that merge the fixnum bitstrings |fx1| and |fx2|, with\nbitstring  mask determining from which string to take each bit. That is, if the kth bit\nof mask is 1, then the kth bit of the result is the kth bit of |fx1|, otherwise the kth\nbit of |fx2|.\n@lisp\n(fxif 3 1 8)                            => 9\n(fxif 3 8 1)                            => 0\n(fxif 1 1 2)                            => 3\n(fxif #b00111100 #b11110000 #b00001111) => #b00110011\n@end lisp" :similar ())

(fxbit-set? :type extended :synopsis "(fxbit-set? index fx)" :description "This is a SRFI-143 procedure that returns |#t| if the |index|-th bit of\n|fx|.\n@lisp\n(fxbit-set? 1 3)          => #t\n(fxbit-set? 2 7)          => #t\n(fxbit-set? 3 6)          => #f\n(fxbit-set? 5 #b00111100) => #t\n@end lisp" :similar ())

(fxcopy-bit :type extended :synopsis "(fxcopy-bit index fx value)" :description "This is a SRFI-143 procedure that sets the |index|-th bit if |fx|\nto one if |value| is |#t|, and to zero if |value| is |#f|.\n@lisp\n(fxcopy-bit 2 3 #t)          =>  7\n(fxcopy-bit 2 7 #f)          =>  3\n(fxcopy-bit 5 #b00111100 #f) => 28 ; = #b00011100\n@end lisp" :similar ())

(fxbit-count :type extended :synopsis "(fxbit-count fx1)" :description "This is a SRFI-143 procedure that returns the quantity of bits equal to one in\nthe fixnum |fx| (that is, computes its Hamming weight).\n@lisp\n(fxbit-count 8)                         => 1\n(fxbit-count 3)                         => 2\n(fxbit-count 7)                         => 3\n(fxbit-count #b00111010)                => 4\n@end lisp" :similar ())

(fxfirst-set-bit :type extended :synopsis "(fxfirst-set-bit fx1)" :description "This is a SRFI-143 procedure that returns the index of the first (smallest index)\n1 bit in bitstring |fx|. Returns -1 if |fx| contains no 1 bits (i.e., if |fx|\nis zero).\n@lisp\n(fxfirst-set-bit  8)                         => 3\n(fxfirst-set-bit  3)                         => 0\n(fxfirst-set-bit  7)                         => 0\n(fxfirst-set-bit  #b10110000)                => 4\n@end lisp" :similar ())

(fxbit-field :type extended :synopsis "(fxbit-field fx1 start end)" :description "This is a SRFI-143 procedure that extracts a bit field from the fixnum |fx1|.\nThe bit field is the sequence of bits between |start| (including) and |end|\n(excluding)\n@lisp\n(fxbit-field  #b10110000 3 5)  => 6 ; = #b110\n@end lisp" :similar ())

(fxbit-field-rotate :type extended :synopsis "(fxbit-field-rotate fx)" :description "This is a SRFI-143 procedure that returns fx with the field cyclically permuted\nby count bits towards high-order.\n@lisp\n(fxbit-field-rotate #b101011100 -2 1 5)     => 342  = #b101010110\n(fxbit-field-rotate #b101011011110 -3 2 10) => 3034 = #b101111011010\n(fxbit-field-rotate #b101011011110 3 2 10)  => 2806 = #b101011110110\n@end lisp" :similar ())

(fxbit-field-reverse :type extended :synopsis "(fxbit-field-reverse fx)" :description "This is a SRFI-143 procedure that returns fx with the order of the bits in the\nfield reversed.\n@lisp\n(fxbit-field-reverse #b101011100 1 5)     => #b101001110\n(fxbit-field-reverse #b101011011110 2 10) => #b101110110110\n@end lisp" :similar ())

(fx+/carry :type extended :synopsis "(fx+/carry i j k)" :description "Returns two values: |i|+|j|+|k|, and carry: it is the value of the computation\n@lisp\n(let*-values (((s) (+ i j k))\n              ((q r) (balanced/ s (expt 2 fx-width))))\n  (values r q))\n@end lisp" :similar ())

(fx-/carry :type extended :synopsis "(fx-/carry i j k)" :description "Returns two values: |i|-|j|-|k|, and carry: it is the value of the computation\n@lisp\n(let*-values (((s) (- i j k))\n              ((q r) (balanced/ s (expt 2 fx-width))))\n  (values r q))\n@end lisp" :similar ())


;; Source file "fport.c"

(open-input-file :type procedure :synopsis "(open-input-file filename)" :description "Takes a string naming an existing file and returns an input port capable\nof delivering characters from the file. If the file cannot be opened,\nan error is signalled.\n\nNOTE: if |filename| starts with the string `\"| \"`, this procedure returns a pipe port.\nConsequently, it is not possible to open a file whose name starts with those two\ncharacters." :similar ())

(open-output-file :type procedure :synopsis "(open-output-file filename)" :description "Takes a string naming an output file to be created and returns an output\nport capable of writing characters to a new file by that name. If the file\ncannot be opened, an error is signalled. If a file with the given name\nalready exists, it is rewritten.\n\nNOTE: if |filename| starts with the string `\"| \"`, this procedure returns a pipe port.\nConsequently, it is not possible to open a file whose name starts with those two\ncharacters." :similar ())

(output-file-port? :type extended :synopsis "(input-file-port? obj)\n(output-file-port? obj)" :description "Returns |#t| if |obj| is a file input port or a file output port respectively,\notherwise returns |#f|." :similar (input-file-port?))

(input-file-port? :see output-file-port?)
(open-file :type extended :synopsis "(open-file filename mode)" :description "Opens the file whose name is |filename| with the specified string\n|mode| which can be:\n\n- |\"r\"| to open the file for reading. The stream is positioned at\n  the beginning of the file.\n\n- |\"r+\"| to open the file for reading and writing. The stream is\n  positioned at the beginning of the file.\n\n- |\"w\"| to truncate the file to zero length or create the file for writing.\n  The stream is positioned at the beginning of the file.\n\n- |\"w+\"| to open the file for reading and writing. The file is created\n  if it does not exist, otherwise it is truncated. The stream is positioned\n  at the beginning of the file.\n\n- |\"a\"| to open the file for writing. The file is created if it does\n  not exist. The stream is positioned at the end of the file.\n\n- |\"a+\"| to open the file for reading and writing. The file is created\n  if it does not exist. The stream is positioned at the end of the file.\n\nIf the file can be opened, |open-file| returns the textual port associated\nwith the given file, otherwise it returns |#f|. Here again, the *_magic_*\nstring \"@pipe \" permits to open a pipe port. (In this case mode can only be\n|\"r\"| or |\"w\"|.)" :similar ())

(port-file-name :type extended :synopsis "(port-file-name port)" :description "Returns the file name used to open |port|; |port| must be a file port." :similar ())

(load :type procedure :synopsis "(load filename)" :description "(((load-path)))\n(((load-suffixes)))\n|Filename| should be a string naming an existing file containing Scheme\nexpressions. |Load| has been extended in STklos to allow loading of\nfiles containing Scheme compiled code as well as object files (_aka_\nshared objects). The loading of object files is not available on\nall architectures. The value returned by |load| is *_void_*.\n\nIf the file whose name is |filename| cannot be located, |load| will try\nto find it in one of the directories given by `\"load-path\"`\nwith the suffixes given by `\"load-suffixes\"`." :similar ())

(try-load :type extended :synopsis "(try-load filename)" :description "|try-load| tries to load the file named |filename|. As with |load|,\n|try-load| tries to find the file given the current load path\nand a set of suffixes if |filename| cannot be loaded. If |try-load|\nis able to find a readable file, it is loaded, and |try-load| returns\n|#t|. Otherwise, |try-load| retuns |#f|." :similar ())


;; Source file "gnu-getopt.c"


;; Source file "hash.c"

(hash-immutable! :type extended :synopsis "(hash-immutable! obj)" :description "If |obj| is a hash table, makes it immutable. Otherwise, raises\nan error." :similar ())

(hash-mutable? :type extended :synopsis "(hash-mutable? obj)" :description "Returns |#t| if |obj| is an immutable hash table, |#f| if it\nis a mutable hash table, and raises an error if |obj| is not a\nhash table." :similar ())

(hash-table? :type extended :synopsis "(hash-table? obj)" :description "Returns |#t| if |obj| is a hash table, returns |#f| otherwise." :similar ())

(hash-table-size :type extended :synopsis "(hash-table-size hash)" :description "Returns the number of entries in the |hash|." :similar ())

(hash-table-equivalence-function :type extended :synopsis "(hash-table-equivalence-function hash)" :description "Returns the equivalence predicate used for keys in |hash|." :similar ())

(hash-table-hash-function :type extended :synopsis "(hash-table-hash-function hash)" :description "Returns the hash function used for keys in |hash|." :similar ())

(hash-table-set! :type extended :synopsis "(hash-table-set! hash key value)" :description "Enters an association between |key| and |value| in the|hash| table.\nThe value returned by |hash-table-set!| is *_void_*." :similar ())

(hash-table-ref :type extended :synopsis "(hash-table-ref hash key)\n(hash-table-ref hash key thunk)" :description "Returns the value associated with |key| in the given |hash| table. If no\nvalue has been associated with |key| in |hash|, the specified |thunk| is\ncalled and its value is returned; otherwise an error is raised.\n@lisp\n(define h1 (make-hash-table))\n(hash-table-set! h1 'foo (list 1 2 3))\n(hash-table-ref  h1 'foo)                 =>  (1 2 3)\n(hash-table-ref  h1 'bar\n                    (lambda () 'absent))  =>  absent\n(hash-table-ref  h1 'bar)                 =>  error\n(hash-table-set! h1 '(a b c) 'present)\n(hash-table-ref  h1 '(a b c)\n                     (lambda () 'absent)) => absent\n\n(define h2 (make-hash-table equal?))\n(hash-table-set! h2 '(a b c) 'present)\n(hash-table-ref  h2 '(a b c))             => present\n@end lisp" :similar ())

(hash-table-ref/default :type extended :synopsis "(hash-table-ref/default hash key default)" :description "This function is equivalent to\n@lisp\n(hash-table-ref hash key (lambda () default))\n@end lisp" :similar ())

(hash-table-exists? :type extended :synopsis "(hash-table-exists? hash key)" :description "Returns |#t| if there is any association of |key| in\n|hash|. Returns |#f| otherwise." :similar ())

(hash-table-delete! :type extended :synopsis "(hash-table-delete! hash key)" :description "Deletes the entry for |key| in |hash|, if it exists. Result of\n|hash-table-delete!| is *_void_*.\n\n@lisp\n(define h (make-hash-table))\n(hash-table-set! h 'foo (list 1 2 3))\n(hash-table-ref h 'foo)                => (1 2 3)\n(hash-table-delete! h 'foo)\n(hash-table-ref h 'foo\n                  (lambda () 'absent)  => absent\n@end lisp" :similar ())

(hash-table-for-each :type extended :synopsis "(hash-table-for-each hash proc)\n(hash-table-walk hash proc)" :description "|Proc| must be a procedure taking two arguments. |Hash-table-for-each|\ncalls |proc| on each key/value association in |hash|, with the key as\nthe first argument and the value as the second.  The value returned by\n|hash-table-for-each| is *_void_*.\n\nNOTE: The order of application of |proc| is unspecified.\n\nNOTE: |hash-table-walk| is another name for |hash-table-for-each|\n(this is the name used in {{link-srfi 69}}.\n\n@lisp\n(let ((h   (make-hash-table))\n      (sum 0))\n  (hash-table-set! h 'foo 2)\n  (hash-table-set! h 'bar 3)\n  (hash-table-for-each h (lambda (key value)\n                           (set! sum (+ sum value))))\n  sum)           =>  5\n@end lisp" :similar (hash-table-walk))

(hash-table-walk :see hash-table-for-each)
(hash-table-map :type extended :synopsis "(hash-table-map hash proc)" :description "|Proc| must be a procedure taking two arguments. |Hash-table-map|\ncalls |proc| on each key/value association in |hash|, with the key as\nthe first argument and the value as the second.  The result of\n|hash-table-map| is a list of the values returned by |proc|, in an\nunspecified order.\n\nNOTE: The order of application of |proc| is unspecified.\n@lisp\n(let ((h (make-hash-table)))\n  (dotimes (i 5)\n    (hash-table-set! h i (number->string i)))\n  (hash-table-map h (lambda (key value)\n                       (cons key value))))\n             => ((3 . \"3\") (4 . \"4\") (0 . \"0\") (1 . \"1\") (2 . \"2\"))\n@end lisp" :similar ())

(hash-table-hash :type extended :synopsis "(hash-table-hash obj)" :description "Computes a hash code for an object and returns this hash code as a\nnon-negative integer. A property of |hash-table-hash| is that\n@lisp\n(equal? x y) => (equal? (hash-table-hash x) (hash-table-hash y)\n@end lisp\n\nas the Common Lisp |sxhash| function from which this procedure is\nmodeled." :similar ())

(hash-table-stats :type extended :synopsis "(hash-table-stats hash)\n(hash-table-stats hash port)" :description "Prints  overall information about |hash|, such as the number of entries\nit contains, the number of buckets in its hash array, and the utilization\nof the buckets. Informations are printed on |port|. If no |port| is given\nto |hash-table-stats|, information are printed on the current output port\n(see _<<curroport,`current-output-port` primitive>>_)." :similar ())


;; Source file "keyword.c"

(make-keyword :type extended :synopsis "(make-keyword s)" :description "Builds a keyword from the given |s|. The parameter |s| must be a symbol\nor a string.\n@lisp\n(make-keyword \"test\")    => #:test\n(make-keyword 'test)     => #:test\n(make-keyword \":hello\")  => #::hello\n@end lisp" :similar ())

(keyword? :type extended :synopsis "(keyword obj)" :description "Returns |#t| if |obj| is a keyword, otherwise returns |#f|.\n@lisp\n(keyword? 'foo)     => #f\n(keyword? ':foo)    => #t  ; depends of keyword-colon-position\n(keyword? 'foo:)    => #t  ; depends of keyword-colon-position\n(keyword? '#:foo)   => #t  ; always\n(keyword? :foo)     => #t  ; depends of keyword-colon-position\n(keyword? foo:)     => #t  ; depends of keyword-colon-position\n(keyword? #:foo)    => #t  ; always \n@end lisp" :similar ())

(keyword->string :type extended :synopsis "(keyword->string key)" :description "Returns the name of |key| as a string. The result does not contain a colon." :similar ())

(key-get :type extended :synopsis "(key-get list key)\n(key-get list key default)" :description "|List| must be a list of keywords and their respective values.\n|key-get| scans the |list| and returns the value\nassociated with the given |key|. If  |key| does\nnot appear in an odd position in |list|, the specified\n|default| is returned, or an error is raised if no |default| was\nspecified.\n@lisp\n(key-get '(#:one 1 #:two 2) #:one)     => 1\n(key-get '(#:one 1 #:two 2) #:four #f) => #f\n(key-get '(#:one 1 #:two 2) #:four)    => error\n@end lisp" :similar ())

(key-set! :type extended :synopsis "(key-set! list key value)" :description "|List| must be a list of keywords and their respective values.\n|key-set!| sets the value associated to |key| in the keyword list.\nIf the key is already present in |list|, the keyword list is\n,(emph \"physically\") changed.\n@lisp\n(let ((l (list #:one 1 #:two 2)))\n  (set! l (key-set! l #:three 3))\n  (cons (key-get l #:one)\n        (key-get l #:three)))            => (1 . 3)\n@end lisp" :similar ())

(key-delete! :type extended :synopsis "(key-delete  list key)\n(key-delete! list key)" :description "|List| must be a list of keywords and their respective values.\n|key-delete| remove the |key| and its associated value of the keyword\nlist. The key can be absent of the list.\n\n|key-delete!| does the same job as |key-delete| by physically\nmodifying its |list| argument.\n@lisp\n(key-delete '(:one 1 :two 2) :two)    => (:one 1)\n(key-delete '(:one 1 :two 2) :three)  => (:one 1 :two 2)\n(let ((l (list :one 1 :two 2)))\n   (key-delete! l :two)\n   l)                                 =>  (:one 1)\n@end lisp" :similar (key-delete))

(key-delete :see key-delete!)

;; Source file "lib.c"


;; Source file "list.c"

(pair? :type procedure :synopsis "(pair? obj)" :description "|Pair?| returns |#t| if |obj| is a pair, and otherwise returns |#f|." :similar ())

(cons :type procedure :synopsis "(cons obj1 obj2)" :description "Returns a newly allocated pair whose car is obj1 and whose cdr is obj2.\nThe pair is guaranteed to be different (in the sense of eqv?) from every\nexisting object.\n@lisp\n    (cons 'a '())           =>  (a)\n    (cons '(a) '(b c d))    =>  ((a) b c d)\n    (cons \"a\" '(b c))       =>  (\"a\" b c)\n    (cons 'a 3)             =>  (a . 3)\n    (cons '(a b) 'c)        =>  ((a b) . c)\n@end lisp" :similar ())

(car :type procedure :synopsis "(car pair)" :description "Returns the contents of the car field of pair.\nNote that it is an error to take the |car| of the empty list.\n@lisp\n    (car '(a b c))          =>  a\n    (car '((a) b c d))      =>  (a)\n    (car '(1 . 2))          =>  1\n    (car '())               =>  error\n@end lisp" :similar ())

(cdr :type procedure :synopsis "(cdr pair)" :description "Returns the contents of the cdr field of pair.\nNote that it is an error to take the |cdr| of the empty list.\n@lisp\n    (cdr '((a) b c d))      =>  (b c d)\n    (cdr '(1 . 2))          =>  2\n    (cdr '())               =>  error\n@end lisp" :similar ())

(set-car! :type procedure :synopsis "(set-car! pair obj)" :description "Stores |obj| in the car field of |pair|.\nThe value returned by |set-car!| is *_void_*.\n@lisp\n   (define (f) (list 'not-a-constant-list))\n   (define (g) '(constant-list))\n   (set-car! (f) 3)\n   (set-car! (g) 3)             =>  error\n@end lisp" :similar ())

(set-cdr! :type procedure :synopsis "(set-cdr! pair obj)" :description "Stores |obj| in the cdr field of |pair|.\nThe value returned by |set-cdr!| is *_void_*.\n" :similar ())

(null? :type procedure :synopsis "(null? obj)" :description "Returns |#t| if |obj| is the empty list, otherwise returns |#f|." :similar ())

(list? :type procedure :synopsis "(list? obj)" :description "Returns |#t| if |obj| is a list, otherwise returns |#f|. By definition,\nall lists have finite length and are terminated by the empty list.\n@lisp\n   (list? '(a b c))     =>  #t\n   (list? '())          =>  #t\n   (list? '(a . b))     =>  #f\n   (let ((x (list 'a)))\n     (set-cdr! x x)\n     (list? x))         =>  #f\n@end lisp" :similar ())

(list :type procedure :synopsis "(list obj ...)" :description "Returns a newly allocated list of its arguments.\n@lisp\n   (list 'a (+ 3 4) 'c)            =>  (a 7 c)\n   (list)                          =>  ()\n@end lisp" :similar ())

(length :type procedure :synopsis "(length list)" :description "Returns the length of |list|.\n\n@lisp\n   (length '(a b c))               =>  3\n   (length '(a (b) (c d e)))       =>  3\n   (length '())                    =>  0\n@end lisp" :similar ())

(append :type procedure :synopsis "(append list ...)" :description "Returns a list consisting of the elements of the first list\nfollowed by the elements of the other lists.\n\n@lisp\n   (append '(x) '(y))              =>  (x y)\n   (append '(a) '(b c d))          =>  (a b c d)\n   (append '(a (b)) '((c)))        =>  (a (b) (c))\n@end lisp\n\nThe resulting list is always newly allocated, except that it shares\nstructure with the last list argument. The last argument may actually\nbe any object; an improper list results if the last argument is not a\nproper list.\n\n@lisp\n   (append '(a b) '(c . d))        =>  (a b c . d)\n   (append '() 'a)                 =>  a\n@end lisp" :similar ())

(reverse :type procedure :synopsis "(reverse list)" :description "Returns a newly allocated list consisting of the elements of |list| in\nreverse order.\n\n@lisp\n   (reverse '(a b c))              =>  (c b a)\n   (reverse '(a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)\n@end lisp" :similar ())

(list-tail :type procedure :synopsis "(list-tail list k)" :description "Returns the sublist of |list| obtained by omitting the first |k| elements.\nIt is an error if list has fewer than |k| elements. List-tail could\nbe defined by\n@lisp\n   (define list-tail\n      (lambda (x k)\n         (if (zero? k)\n            x\n            (list-tail (cdr x) (- k 1)))))\n@end lisp" :similar ())

(list-ref :type procedure :synopsis "(list-ref list k)" :description "Returns the |k|th element of |list|. (This is the same as the car\nof |(list-tail list k)|.) It is an error if list has fewer than |k|\nelements.\n\n@lisp\n   (list-ref '(a b c d) 2)                 =>  c\n   (list-ref '(a b c d)\n             (inexact->exact (round 1.8))) =>  c\n@end lisp" :similar ())

(list-set! :type r7rs-procedure :synopsis "(list-set! list k obj)" :description "The |list-set!| procedure stores |obj| in element |k| of |list|.\nIt is an error if |k| is not a valid index of |list|.\n@lisp\n(let ((ls (list 'one 'two 'five!)))\n   (list-set! ls 2 'three)\n   ls)                              => (one two three)\n(list-set! '(0 1 2) 1 \"oops\")       => error (constant list)\n@end lisp" :similar ())

(member :type r57rs-procedure :synopsis "(memq obj list)\n(memv obj list)\n(member obj list)\n(member obj list compare)" :description "These procedures return the first sublist of list whose car is |obj|,\nwhere the sublists of list are the non-empty lists returned by\n|(list-tail list k)| for |k| less than the length of list.\nIf |obj| does not occur in |list|, then |#f| (not the empty list) is\nreturned. |Memq| uses |eq?| to compare obj with the elements of list,\nwhile |memv| uses |eqv?| and |member| uses |compare|, if given, and\n|equal?| otherwise.\n\n@lisp\n   (memq 'a '(a b c))              =>  (a b c)\n   (memq 'b '(a b c))              =>  (b c)\n   (memq 'a '(b c d))              =>  #f\n   (memq (list 'a) '(b (a) c))     =>  #f\n   (member (list 'a)\n           '(b (a) c))             =>  ((a) c)\n   (member \"B\"\n           â\x80;\x99;(\"a\" \"b\" \"c\")\n           string-ci=?)            => (\"b\" \"c\")\n   (memv 101 '(100 101 102))       =>  (101 102)\n@end lisp\n\nNOTE: As in R7RS, the |member| function accepts also a\ncomparison function." :similar (memv memq))

(memv :see member)
(memq :see member)
(assoc :type r57rs-procedure :synopsis "(assq obj alist)\n(assv obj alist)\n(assoc obj alist)\n(assoc obj alist compare)" :description "|Alist| (for \"association list\") must be a list of pairs. These procedures\nfind the first pair in |alist| whose car field is |obj|, and returns that\npair. If no pair in |alist| has |obj| as its car, then |#f| (not the empty\nlist) is returned. |Assq| uses |eq?| to compare |obj| with the car fields\nof the pairs in |alist|, while |assv| uses |eqv?| and |assoc| uses |equal?|.\n\n@lisp\n   (define e '((a 1) (b 2) (c 3)))\n   (assq 'a e)                =>  (a 1)\n   (assq 'b e)                =>  (b 2)\n   (assq 'd e)                =>  #f\n   (assq (list 'a) '(((a)) ((b)) ((c))))\n                              =>  #f\n   (assoc (list 'a) '(((a)) ((b)) ((c))))\n                              => ((a))\n   (assoc 2.0 '((1 1) (2 4) (3 9)) =)\n                              => (2 4)\n   (assv 5 '((2 3) (5 7) (11 13)))\n                              =>  (5 7)\n@end lisp\n\nIMPORTANT: Although they are ordinarily used as predicates,\n|memq|, |memv|, |member|, |assq|, |assv|, and |assoc| do not have question\nmarks in their names because they return useful values rather than just\n|#t| or #|f|.\n\nNOTE: As in R7RS, the |assoc| function accepts also a\ncomparison function." :similar (assv assq))

(assv :see assoc)
(assq :see assoc)
(list-copy :type r7rs-procedure :synopsis "(list-copy obj)" :description "|list-copy| recursively copies trees of pairs. If |obj| is\nnot a pair, it is returned; otherwise the result is a new pair whose\n|car| and |cdr| are obtained by calling |list-copy| on\nthe |car| and |cdr| of |obj|, respectively." :similar ())

(pair-mutable? :type extended :synopsis "(pair-mutable? obj)" :description "Returns |#t| if |obj| is a mutable pair, otherwise returns |#f|.\n@lisp\n(pair-mutable? '(1 . 2))    => #f\n(pair-mutable? (cons 1 2))  => #t\n(pair-mutable? 12)          => #f\n@end lisp" :similar ())

(list* :type extended :synopsis "(list* obj ...)" :description "|list*| is like |list| except that the last argument to |list*| is\nused as the ,(emph \"cdr\") of the last pair constructed.\n@lisp\n   (list* 1 2 3)        => (1 2 . 3)\n   (list* 1 2 3 '(4 5)) => (1 2 3 4 5)\n   (list*)              => ()\n@end lisp" :similar ())

(last-pair :type extended :synopsis "(last-pair list)" :description "Returns the last pair of |list|.\n@lisp\n(last-pair '(1 2 3))   => (3)\n(last-pair '(1 2 . 3)) => (2 . 3)\n@end lisp" :similar ())

(filter! :type extended :synopsis "(filter  pred list)\n(filter! pred list)" :description "|Filter| returns all the elements of |list| that satisfy predicate\n|pred|. The |list| is not disordered: elements that appear in the\nresult list occur in the same order as they occur in the argument\nlist. |Filter!| does the same job as |filter| by physically\nmodifying its |list| argument\n@lisp\n(filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)\n(let* ((l1 (list 0 7 8 8 43 -4))\n       (l2 (filter! even? l1)))\n   (list l1 l2))                => ((0 8 8 -4) (0 8 8 -4))\n@end lisp\nAn error is signaled if |list| is a constant list." :similar (filter))

(filter :see filter!)
(append! :type extended :synopsis "(append! list ...)" :description "Returns a list consisting of the elements of the first list\nfollowed by the elements of the other lists.\nContrarily to |append|, the parameter lists (except the last one) are\nphysically modified: their last pair is changed to the value of the next\nlist in the |append!| formal parameter list.\n@lisp\n(let* ((l1 (list 1 2))\n       (l2 (list 3))\n       (l3 (list 4 5))\n       (l4 (append! l1 l2 l3)))\n  (list l1 l2 l3 l4))  => ((1 2 3 4 5) (3 4 5) (4 5) (1 2 3 4 5))\n@end lisp\nAn error is signaled if one of the given lists is a constant list." :similar ())

(reverse! :type extended :synopsis "(reverse! list)" :description "Returns a list consisting of the elements of |list| in reverse order.\nContrarily to |reverse|, the returned value is not newly allocated but\ncomputed \"in place\".\n\n@lisp\n(let ((l '(a b c)))\n  (list (reverse! l) l))        =>  ((c b a) (a))\n(reverse! '(a constant list))   =>  error\n@end lisp" :similar ())


;; Source file "misc.c"

(version :type extended :synopsis "(version)\n(implementation-version)" :description "Returns a string identifying the current version of the system. A\nversion is constituted of two numbers separated by a point: the version\nand the release numbers. Note that |implementation-version| corresponds\nto the {{link-srfi 112}} name of this function." :similar (implementation-version))

(implementation-version :see version)
(void :type extended :synopsis "(void)\n(void arg1 ...)" :description "Returns the special *_void_* object. If arguments are passed to |void|,\nthey are evalued and simply ignored." :similar ())

(address-of :type extended :synopsis "(address-of obj)" :description "Returns the address of the object |obj| as an integer." :similar ())

(gc :type extended :synopsis "(gc)" :description "Force a garbage collection step." :similar ())

(uri-parse :type extended :synopsis "(uri-parse str)" :description "Parses the string |str| as an RFC-2396 URI and return a keyed list with the\nfollowing components\n\n- |scheme| : the scheme used as a string (defaults to |\"file\"|)\n- |user|: the user information (generally expressed as |login:password|)\n- |host| : the host as a string (defaults to \"\")\n- |port| : the port as an integer (0 if no port specified)\n- |path| : the path\n- |query| : the qury part of the URI as a string (defaults to the\n   empty string)\n- |fragment| : the fragment of the URI as a string (defaults to the\n  empty string)\n\n@lisp\n(uri-parse \"https://stklos.net\")\n   => (:scheme \"https\" :user \"\" :host \"stklos.net\" :port 443\n        :path \"/\" :query \"\" :fragment \"\")\n\n(uri-parse \"https://stklos.net:8080/a/file?x=1;y=2#end\")\n    => (:scheme \"http\" :user \"\" :host \"stklos.net\" :port 8080\n        :path \"/a/file\" :query \"x=1;y=2\" :fragment \"end\")\n\n(uri-parse \"http://foo:secret@stklos.net:2000/a/file\")\n    => (:scheme \"http\" :user \"foo:secret\" :host \"stklos.net\"\n        :port 2000  :path \"/a/file\" :query \"\" :fragment \"\")\n\n(uri-parse \"/a/file\")\n   => (:scheme \"file\" :user \"\" :host \"\" :port 0 :path \"/a/file\"\n       :query \"\" :fragment \"\")\n\n(uri-parse \"\")\n   => (:scheme \"file\"  :user \"\" :host \"\" :port 0 :path \"\"\n       :query \"\" :fragment \"\")\n@end lisp" :similar ())

(string->html :type extended :synopsis "(string->html str)" :description "This primitive is a convenience function; it returns a string where\nthe HTML special chars are properly translated. It can easily be written\nin Scheme, but this version is fast.\n@lisp\n(string->html \"Just a <test>\")\n   => \"Just a &lt;test&gt;\"\n@end lisp" :similar ())

(get-password :type extended :synopsis "(get-password)" :description "This primitive permits to enter a password (character echoing\nbeing turned off). The value returned by |get-password| is the entered\npassword as a string." :similar ())


;; Source file "md5.c"

(md5sum :type extended :synopsis "(md5sum obj)" :description "Return a string contening the md5 sum of |obj|. The given parameter can\nbe a string or an open input port." :similar ())


;; Source file "number.c"

(real-precision :type extended :synopsis "(real-precision)\n(real-precision value)" :description "This parameter object allows changing the default precision used\nto print real numbers.\n\nBy precision when printing a number we mean the number of significant\ndigits -- that is, excluding the leading and trailing zeros in\ndecimal representation. (This is exactly the same as the number\nfor the `g` specifier for `printf` in the C language).\n\n@lisp\n(real-precision)         => 15\n(define f 0.123456789)\n(display f)              => 0.123456789\n(real-precision 3)\n(display f)              => 0.123\n(display   1.123456789)  => 1.12\n(display  12.123456789)  => 12.1\n(display 123.123456789)  => 123.0\n@end lisp\nIn the last example, only three significant digits were printed (123),\nand the zero only marks this number as inexact.\n\nIf the number won't fit using the usual decimal format, it will be\nprinted in scientific notation, but still using the specified number\nof significant digits:\n@lisp\n(display     1234.123456789) => 1.23e+03\n(display    12345.123456789) => 1.23e+04\n(display 12345678.123456789) => 1.23e+07\n@end lisp\nRepeating the three examples above with precision equal to one results\nin the following.\n@lisp\n(real-precision 1)\n(display     1234.123456789) => 1e+03\n(display    12345.123456789) => 1e+04\n(display 12345678.123456789) => 1e+07\n@end lisp\nIf the number is only printed up to its n-th digit, then the printed nth\ndigit will be n rounded up or down, according to the digit that comes\nafter it.\n@lisp\n(real-precision 4)\n(display 12.123456789) => 12.12  ;; \"123...\" rounded to \"12\"\n(display 12.987654321) => 12.99  ;; \"987...\" rounded to \"99\"\n@end lisp" :similar ())

(accept-srfi-169-numbers :type extended :synopsis "(accept-srfi-169-numbers)\n(accept-srfi-169-numbers value)" :description "This parameter object permits to change the behavior of the reader\nwith underscores in numbers. Numbers with underscores are defined\nin ,(link-srfi 169). By default, this variable is true, meaning that\nunderscores are accepted in numbers.\n\n@lisp\n(accept-srfi-169-numbers)        => #t\n(symbol? '1_000_000)             => #f\n(number? '1_000_000)             => #t\n(accept-srfi-169-numbers #f)\n(symbol? '1_000_000)             => #t\n(number? '1_000_000)             => #f\n@end lisp" :similar ())

(integer? :type procedure :synopsis "(number? obj)\n(complex? obj)\n(real? obj)\n(rational? obj)\n(integer? obj)" :description "These numerical type predicates can be applied to any kind of\nargument, including non-numbers. They return |#t| if the object is of\nthe named type, and otherwise they return |#f|. In general, if a type\npredicate is true for a number then all higher type predicates are\nalso true for that number. Consequently, if a type predicate is\nfalse of a number, then all lower type predicates are also false of\nthat number.\n\nIf |z| is an inexact complex number, then |(real? z)| is true if and\nonly if |(zero? (imag-part z))| is true. If |x| is an inexact real\nnumber, then |(integer? x)| is true if and only if\n|(and (finite? x) (= x (round x)))|\n\n\n@lisp\n  (complex? 3+4i)         =>  #t\n  (complex? 3)            =>  #t\n  (real? 3)               =>  #t\n  (real? -2.5+0.0i)       =>  #t\n  (real? #e1e10)          =>  #t\n  (rational? 6/10)        =>  #t\n  (rational? 6/3)         =>  #t\n  (integer? 3+0i)         =>  #t\n  (integer? 3.0)          =>  #t\n  (integer? 3.2)          =>  #f\n  (integer? 8/4)          =>  #t\n  (integer? \"no\")         =>  #f\n  (complex? +inf.0)       =>  #t\n  (real? -inf.0)          =>  #t\n  (rational? +inf.0)      =>  #f\n  (integer? -inf.0)       =>  #f\n@end lisp\n" :similar (rational? real? complex? number?))

(rational? :see integer?)
(real? :see integer?)
(complex? :see integer?)
(number? :see integer?)
(bignum? :type extended :synopsis "(bignum? x)" :description "This predicates returns |#t| if |x| is an integer number too large to be\nrepresented with a native integer.\n@lisp\n(bignum? (expt 2 300))     => |#t|   ;; (very likely)\n(bignum? 12)               => |#f|\n(bignum? \"no\")             => |#f|\n@end lisp" :similar ())

(inexact? :type procedure :synopsis "(exact? z)\n(inexact? z)" :description "These numerical predicates provide tests for the exactness of a\nquantity. For any Scheme number, precisely one of these predicates\nis true." :similar (exact?))

(exact? :see inexact?)
(integer-length :type extended :synopsis "(integer-length n)" :description "|Integer-length| returns the necessary number of bits to represent |n|\nin 2's complement, assuming a leading 1 bit when |n| is negative. When\n|n| is zero, the procedure returns zero.\nThis procedure works for any type of integer (fixnums and bignums).\n\n@lisp\n(integer-length -3)            => 2\n(integer-length -2)            => 1\n(integer-length -1)            => 0\n(integer-length 0)             => 0\n(integer-length 1)             => 1\n(integer-length 2)             => 2\n(integer-length 3)             => 2\n(integer-length (expt 2 5000)) => 5001\n@end lisp" :similar ())

(>= :type procedure :synopsis "(= z1 z2 z3 ...)\n(< x1 x2 x3 ...)\n(> x1 x2 x3 ...)\n(<= x1 x2 x3 ...)\n(>= x1 x2 x3 ...)" :description "These procedures return |#t| if their arguments are (respectively):\nequal, monotonically increasing, monotonically decreasing,\nmonotonically nondecreasing, or monotonically nonincreasing.\n@lisp\n(= +inf.0 +inf.0)           =>  #t\n(= -inf.0 +inf.0)           =>  #f\n(= -inf.0 -inf.0)           =>  #t\n@end lisp\n\nFor any finite real number x:\n\n@lisp\n(< -inf.0 x +inf.0)         =>  #t\n(> +inf.0 x -inf.0)         =>  #t\n@end lisp" :similar (<= > < =))

(<= :see >=)
(> :see >=)
(< :see >=)
(= :see >=)
(even? :type procedure :synopsis "(finite? z)\n(infinite? z)\n(zero? z)\n(positive? x)\n(negative? x)\n(odd? n)\n(even? n)" :description "These numerical predicates test a number for a particular property,\nreturning |#t| or |#f|.\n@lisp\n(positive? +inf.0)          ==>  #t\n(negative? -inf.0)          ==>  #t\n(finite? -inf.0)            ==>  #f\n(infinite? +inf.0)          ==>  #t\n@end lisp" :similar (odd? negative? positive? zero? infinite? finite?))

(odd? :see even?)
(negative? :see even?)
(positive? :see even?)
(zero? :see even?)
(infinite? :see even?)
(finite? :see even?)
(nan? :type r7rs-procedure :synopsis "(nan? z)" :description "The |nan?| procedure returns #t on |+nan.0|, and on complex\nnumbers if their real or imaginary parts or both are |+nan.0|.\nOtherwise it returns #f.\n\n@lisp\n(nan? +nan.0)          =>  #t\n(nan? 32)              =>  #f\n(nan? +nan.0+5.0i)     =>  #t\n(nan? 1+2i)            =>  #f\n@end lisp" :similar ())

(min :type procedure :synopsis "(max x1 x2 ...)\n(min x1 x2 ...)" :description "These procedures return the maximum or minimum of their arguments.\n\n@lisp\n(max 3 4)              =>  4    ; exact\n(max 3.9 4)            =>  4.0  ; inexact\n@end lisp\nFor any real number x:\n@lisp\n(max +inf.0 x)         =>  +inf.0\n(min -inf.0 x)         =>  -inf.0\n@end lisp\n\nNOTE: If any argument is inexact, then the result will also be\ninexact" :similar (max))

(max :see min)
(* :type procedure :synopsis "(+ z1 ...)\n(* z1 ...)" :description "These procedures return the sum or product of their arguments.\n@lisp\n(+ 3 4)                 =>  7\n(+ 3)                   =>  3\n(+)                     =>  0\n(+ +inf.0 +inf.0)       =>  +inf.0\n(+ +inf.0 -inf.0)       =>  +nan.0\n(* 4)                   =>  4\n(*)                     =>  1\n(* 5 +inf.0)            =>  +inf.0\n(* -5 +inf.0)           =>  -inf.0\n(* +inf.0 +inf.0)       =>  +inf.0\n(* +inf.0 -inf.0)       =>  -inf.0\n(* 0 +inf.0)            =>  +nan.0\n@end lisp\nNOTE: For any finite number z:\n@lisp\n      (+ +inf.0 z)      =>  +inf.0\n      (+ -inf.0 z)      =>  -inf.0\n@end lisp" :similar (+))

(+ :see *)
(/ :type procedure :synopsis "(- z)\n(- z1 z2)\n(/ z)\n(/ z1 z2 ...)" :description "With two or more arguments, these procedures return the difference or quotient\nof their arguments, associating to the left. With one argument, however,\nthey return the additive or multiplicative inverse of their argument.\n\n@lisp\n(- 3 4)                 =>  -1\n(- 3 4 5)               =>  -6\n(- 3)                   =>  -3\n(- +inf.0 +inf.0)       => +nan.0\n(/ 3 4 5)               =>  3/20\n(/ 3)                   =>  1/3\n(/ 0.0)                 => +inf.0\n(/ 0)                   => error (division by 0)\n@end lisp" :similar (-))

(- :see /)
(abs :type procedure :synopsis "(abs x)" :description "|Abs| returns the absolute value of its argument.\n@lisp\n(abs -7)                =>  7\n(abs -inf.0)            => +inf.0\n@end lisp" :similar ())

(modulo :type procedure :synopsis "(quotient n1 n2)\n(remainder n1 n2)\n(modulo n1 n2)" :description "These procedures implement number-theoretic (integer) division. n2 should\nbe non-zero. All three procedures return integers.\n@l\nIf |n1/n2| is an integer:\n\n@lisp\n(quotient n1 n2)   => n1/n2\n(remainder n1 n2)  => 0\n(modulo n1 n2)     => 0\n@end lisp\n\nIf n1/n2 is not an integer:\n\n@lisp\n(quotient n1 n2)   => nq\n(remainder n1 n2)  => nr\n(modulo n1 n2)     => nm\n@end lisp\n\nwhere |nq| is |n1/n2| rounded towards zero, 0 < abs(nr) < abs(n2),\n0 < abs(nm) < abs(n2), |nr| and |nm| differ from n1 by a multiple of n2,\n|nr| has the same sign as n1, and |nm| has the same sign as n2.\n@l\nFrom this we can conclude that for integers |n1| and |n2| with |n2| not\nequal to 0,\n@lisp\n (= n1 (+ (* n2 (quotient n1 n2))\n          (remainder n1 n2)))   =>  #t\n@end lisp\nprovided all numbers involved in that computation are exact.\n\n@lisp\n(modulo 13 4)           =>  1\n(remainder 13 4)        =>  1\n\n(modulo -13 4)          =>  3\n(remainder -13 4)       =>  -1\n\n(modulo 13 -4)          =>  -3\n(remainder 13 -4)       =>  1\n\n(modulo -13 -4)         =>  -1\n(remainder -13 -4)      =>  -1\n\n(remainder -13 -4.0)    =>  -1.0  ; inexact\n@end lisp" :similar (remainder quotient))

(remainder :see modulo)
(quotient :see modulo)
(lcm :type procedure :synopsis "(gcd n1 ...)\n(lcm n1 ...)" :description "These procedures return the greatest common divisor or least common\nmultiple of their arguments. The result is always non-negative.\n\n@lisp\n(gcd 32 -36)            =>  4\n(gcd)                   =>  0\n(lcm 32 -36)            =>  288\n(lcm 32.0 -36)          =>  288.0  ; inexact\n(lcm)                   =>  1\n@end lisp" :similar (gcd))

(gcd :see lcm)
(denominator :type procedure :synopsis "(numerator q)\n(denominator q)" :description "These procedures return the numerator or denominator of their argument; the\nresult is computed as if the argument was represented as a fraction in\nlowest terms. The denominator is always positive. The denominator of\n0 is defined to be 1.\n@lisp\n(numerator (/ 6 4))  =>  3\n(denominator (/ 6 4))  =>  2\n(denominator\n(exact->inexact (/ 6 4))) => 2.0\n@end lisp" :similar (numerator))

(numerator :see denominator)
(round :type procedure :synopsis "(floor x)\n(ceiling x)\n(truncate x)\n(round x)" :description "These procedures return integers. |Floor| returns the largest integer not\nlarger than |x|. |Ceiling| returns the smallest integer not smaller than |x|.\n|Truncate| returns the integer closest to |x| whose absolute value is not\nlarger than the absolute value of |x|. |Round| returns the closest integer\nto |x|, rounding to even when |x| is halfway between two integers.\n@l\nIMPORTANT: |Round| rounds to even for consistency with the default\nrounding mode specified by the IEEE floating point standard.\n@l\nNOTE: If the argument to one of these procedures is inexact, then the\nresult will also be inexact. If an exact value is needed, the result should\nbe passed to the |inexact->exact| procedure.\n\n@lisp\n\n(floor -4.3)          =>  -5.0\n(ceiling -4.3)        =>  -4.0\n(truncate -4.3)       =>  -4.0\n(round -4.3)          =>  -4.0\n\n(floor 3.5)           =>  3.0\n(ceiling 3.5)         =>  4.0\n(truncate 3.5)        =>  3.0\n(round 3.5)           =>  4.0  ; inexact\n\n(round 7/2)           =>  4    ; exact\n(round 7)             =>  7\n@end lisp" :similar (truncate ceiling floor))

(truncate :see round)
(ceiling :see round)
(floor :see round)
(atan :type procedure :synopsis "(exp z)\n(log z)\n(log z b)\n(sin z)\n(cos z)\n(tan z)\n(asin z)\n(acos z)\n(atan z)\n(atan y x)" :description "These procedures compute the usual transcendental functions. |Log| computes the\nnatural logarithm of z (not the base ten logarithm). |Asin|, |acos|,\nand |atan| compute arcsine, arccosine, and  arctangent, respectively.\nThe two-argument variant of |log| computes the logarithm of x in base b as\n@lisp\n(/ (log x) (log b))\n@end lisp\nThe two-argument variant of |atan| computes\n@lisp\n(angle (make-rectangular x y))\n@end lisp\n\nWhen it is possible these procedures produce a real result from a real\nargument." :similar (acos asin tan cos sin log exp))

(acos :see atan)
(asin :see atan)
(tan :see atan)
(cos :see atan)
(sin :see atan)
(log :see atan)
(exp :see atan)
(atanh :type extended :synopsis "(sinh z)\n(cosh z)\n(tanh z)\n(asinh z)\n(acosh z)\n(atanh z)" :description "These procedures compute the hyperbolic trigonometric functions.\n@lisp\n(sinh 1)     => 1.1752011936438\n(sinh 0+1i)  => 0.0+0.841470984807897i\n(cosh 1)     => 1.54308063481524\n(cosh 0+1i)  => 0.54030230586814\n(tanh 1)     => 0.761594155955765\n(tanh 0+1i)  => 0.0+1.5574077246549i\n(asinh 1)    => 0.881373587019543\n(asinh 0+1i) => 0+1.5707963267949i\n(acosh 0)    => 0+1.5707963267949i\n(acosh 0+1i) => 1.23340311751122+1.5707963267949i\n(atanh 1)    => error\n(atanh 0+1i) => 0.0+0.785398163397448i\n@end lisp\n\nIn general, |(asinh (sinh x))| and similar compositions should be\nequal to |x|, except for inexactness due to the internal floating\npoint number approximation for real numbers.\n@lisp\n(sinh (asinh 0+1i)) => 0.0+1.0i\n(cosh (acosh 0+1i)) => 8.65956056235493e-17+1.0i\n(tanh (atanh 0+1i)) => 0.0+1.0i\n@end lisp\n\nThese functions will always return an exact result for the following\narguments:\n@lisp\n(sinh 0.0)     => 0\n(cosh 0.0)     => 1\n(tanh 0.0)     => 0\n(asinh 0.0)    => 0\n(acosh 1.0)    => 0\n(atanh 0.0)    => 0\n@end lisp" :similar (tanh acosh cosh asinh sinh))

(tanh :see atanh)
(acosh :see atanh)
(cosh :see atanh)
(asinh :see atanh)
(sinh :see atanh)
(sqrt :type procedure :synopsis "(sqrt z)" :description "Returns the principal square root of |z|. The result will have either\npositive real part, or zero real part and non-negative imaginary part." :similar ())

(expt :type procedure :synopsis "(expt z1 z2)" :description "Returns |z1| raised to the power |z2|.\n@l\nNOTE: |0,(sup \"z\")| is 1 if |z = 0| and |0| otherwise." :similar ())

(angle :type procedure :synopsis "(make-rectangular x1 x2)\n(make-polar x3 x)\n(real-part z)\n(imag-part z)\n(magnitude z)\n(angle z)" :description "If x1, x2, x3, and x4 are real numbers and z is a complex number such that\n@l\n|z = x1 + x2.i = x3 . e,(sup \"i.x4\")|\n@l\nThen\n@lisp\n(make-rectangular x1 x2)       => z\n(make-polar x3 x4)             => z\n(real-part z)                  => x1\n(imag-part z)                  => x2\n(magnitude z)                  => abs(x3)\n(angle z)                      => xa\n@end lisp\nwhere\n|-,(symbol \"pi\") < xa <= ,(symbol \"pi\")| with |xa = x4 + 2,(symbol \"pi\")n|\nfor some integer n.\n@lisp\n(angle +inf.0)                 => 0.0\n(angle -inf.0)                 => 3.14159265358979\n@end lisp\n@l\nNOTE: |Magnitude| is the same as |abs| for a real argument." :similar (magnitude imag-part real-part make-polar make-rectangular))

(magnitude :see angle)
(imag-part :see angle)
(real-part :see angle)
(make-polar :see angle)
(make-rectangular :see angle)
(inexact->exact :type procedure :synopsis "(exact->inexact z)\n(inexact->exact z)" :description "|Exact->inexact| returns an inexact representation of z.\nThe value returned is the inexact number that is numerically closest to\nthe argument.\n|Inexact->exact| returns an exact representation of z.\nThe value returned is the exact number that is numerically closest to\nthe argument." :similar (exact->inexact))

(exact->inexact :see inexact->exact)
(number->string :type procedure :synopsis "(number->string z)\n(number->string z radix)" :description "|Radix| must be an exact integer, either 2, 8, 10, or 16. If omitted, radix\ndefaults to 10. The procedure |number->string| takes a number and a radix\nand returns as a string an external representation of the given number in\nthe given radix such that\n@lisp\n(let ((number number)\n      (radix radix))\n  (eqv? number\n       (string->number (number->string number radix) radix)))\n@end lisp\nis true. It is an error if no possible result makes this expression true.\n@l\nIf |z| is inexact, the radix is 10, and the above expression can be\nsatisfied by a result that contains a decimal point, then the result\ncontains a decimal point and is expressed using the minimum number of digits\n(exclusive of exponent and trailing zeroes) needed to make the above expression\ntrue; otherwise the format of the result is unspecified.\n@l\nThe result returned by |number->string| never contains an explicit radix\nprefix.\n@l\nNOTE: The error case can occur only when |z| is not a complex number or\nis a complex number with a non-rational real or imaginary part.\n@l\nIMPORTANT: If |z| is an inexact number represented using flonums, and\nthe radix is 10, then the above expression is normally satisfied by a result\ncontaining a decimal point. The unspecified case allows for infinities,\nNaNs, and non-flonum representations." :similar ())

(string->number :type procedure :synopsis "(string->number string)\n(string->number string radix)" :description "Returns a number of the maximally precise representation expressed by the\ngiven |string|. |Radix| must be an exact integer, either 2, 8, 10, or 16.\nIf supplied, |radix| is a default radix that may be overridden by an explicit\nradix prefix in |string| (e.g. ,(code \"\\\"#o177\\\"\")). If |radix| is not\n supplied, then\nthe default radix is 10. If |string| is not a syntactically valid notation\nfor a number, then |string->number| returns |#f|.\n@lisp\n(string->number \"100\")        =>  100\n(string->number \"100\" 16)     =>  256\n(string->number \"1e2\")        =>  100.0\n(string->number \"15##\")       =>  1500.0\n(string->number \"+inf.0\")     =>  +inf.0\n(string->number \"-inf.0\")     =>  -inf.0\n@end lisp\n" :similar ())

(decode-float :type extended :synopsis "(decode-float n)" :description "|decode-float| returns three exact integers: |significand|, |exponent|\nand |sign| (where |-1 <= sign <= 1|). The values returned by |decode-float|\nsatisfy:\n@lisp\nn = (* sign significand (expt 2 exponent))\n@end lisp\nHere is an example of |decode-float| usage.\n@lisp\n(receive l (decode-float -1.234) l)\n                    => (5557441940175192 -52 -1)\n(exact->inexact (* -1\n                    5557441940175192\n                    (expt 2 -52)))\n                    => -1.234\n@end lisp" :similar ())

(nan-negative? :type extended :synopsis "(nan-negative? nan)" :description "returns |#t| if the sign bit of |nan| is set and |#f| otherwise." :similar ())

(nan-quiet? :type extended :synopsis "(nan-quiet? nan)" :description "returns |#t| if |nan| is a quiet NaN." :similar ())

(nan-payload :type extended :synopsis "(nan-payload nan)" :description "returns  the payload bits of |nan| as a positive exact integer." :similar ())

(nan=? :type extended :synopsis "(nan=? nan1 nan2)" :description "Returns |#t| if |nan1| and |nan2| have the same sign, quiet bit,\nand payload; and |#f| otherwise." :similar ())


;; Source file "object.c"


;; Source file "parameter.c"

(make-parameter :type extended :synopsis "(make-parameter init)\n(make-parameter init converter)" :description "Returns a new parameter object which is bound in the global dynamic\nenvironment to a cell containing the value returned by the call\n|(converter init)|. If the conversion procedure |converter| is not\nspecified the identity function is used instead.\n\nThe parameter object is a procedure which accepts zero or one\nargument. When it is called with no argument, the content of the\ncell bound to this parameter object in the current dynamic\nenvironment is returned. When it is called with one argument, the\ncontent of the cell bound to this parameter object in the current\ndynamic environment is set to the result of the call\n|(converter arg)|, where |arg| is the argument passed to the\nparameter object, and an unspecified value is returned.\n\n@lisp\n(define radix\n    (make-parameter 10))\n\n(define write-shared\n   (make-parameter\n      #f\n      (lambda (x)\n        (if (boolean? x)\n            x\n            (error 'write-shared \"bad boolean ~S\" x)))))\n\n (radix)           =>  10\n (radix 2)\n (radix)           =>  2\n (write-shared 0)  => error\n\n (define prompt\n   (make-parameter\n     123\n     (lambda (x)\n       (if (string? x)\n           x\n           (with-output-to-string (lambda () (write x)))))))\n\n (prompt)       =>  \"123\"\n (prompt \">\")\n (prompt)       =>  \">\"\n@end lisp" :similar ())

(parameter? :type extended :synopsis "(parameter? obj)" :description "Returns |#t| if |obj| is a parameter object, otherwise returns |#f|." :similar ())


;; Source file "path.c"


;; Source file "port.c"

(output-port? :type procedure :synopsis "(input-port? obj)\n(output-port? obj)" :description "Returns |#t| if |obj| is an input port or output port respectively,\notherwise returns |#f|." :similar (input-port?))

(input-port? :see output-port?)
(binary-port? :type r7rs-procedure :synopsis "(textual-port? obj)\n(binary-port? obj)" :description "Returns |#t| if |obj| is a textual port or binary port respectively,\notherwise returns |#f|." :similar (textual-port?))

(textual-port? :see binary-port?)
(port? :type r7rs-procedure :synopsis "(port? obj)" :description "Returns |#t| if |obj| is an input port or an output port,\notherwise returns |#f|." :similar ())

(interactive-port? :type extended :synopsis "(interactive-port? port)" :description "Returns |#t| if |port| is connected to a terminal and |#f| otherwise." :similar ())

(current-output-port :type procedure :synopsis "(current-input-port obj)\n(current-output-port obj)" :description "Returns the current default input or output port." :similar (current-input-port))

(current-input-port :see current-output-port)
(current-error-port :type extended :synopsis "(current-error-port obj)" :description "Returns the current default error port." :similar ())

(read :type procedure :synopsis "(read)\n(read port)" :description "|Read| converts external representations of Scheme objects into the\nobjects themselves. |Read| returns the next object parsable from the given\ninput port, updating port to point to the first character past the end of\nthe external representation of the object.\n@l\nIf an end of file is encountered in the input before any characters are found\nthat can begin an object, then an end of file object is returned. The port\nremains open, and further attempts to read will also return an end of file\nobject. If an end of file is encountered after the beginning of an object's\nexternal representation, but the external representation is incomplete\nand therefore not parsable, an error is signalled.\n@l\nThe port argument may be omitted, in which case it defaults to the value\nreturned by |current-input-port|. It is an error to read from a closed port.\n@l\n{{stklos}} |read| supports the {{quick-link-srfi 10}} |#,()| form that can be used\nto denote values that do not have a convenient printed representation. See\nthe SRFI document for more information." :similar ())

(read-with-shared-structure :type extended :synopsis "(read-with-shared-structure)\n(read-with-shared-structure  port)\n(read/ss)\n(read/ss port)" :description "|read-with-shared-structure| is identical to |read|. It has been added to\nbe compatible with ,(link-srfi 38). STklos always knew how to deal with\nrecursive input data. |read/ss| is only a shorter name for\n|read-with-shared-structure|.\n" :similar ())

(define-reader-ctor :type extended :synopsis "(define-reader-ctor tag proc)" :description "This procedure permits to define a new user to reader constructor procedure\nat run-time. It is defined in ,(link-srfi 10) document. See  SRFI document\nfor more information.\n@lisp\n(define-reader-ctor 'rev (lambda (x y) (cons y x)))\n(with-input-from-string \"#,(rev 1 2)\" read)\n                             => (2 . 1)\n@end lisp" :similar ())

(read-char :type procedure :synopsis "(read-char)\n(read-char port)" :description "Returns the next character available from the input |port|, updating the |port|\nto point to the following character. If no more characters are available,\nan end of file object is returned. |Port| may be omitted, in which case\nit defaults to the value returned by |current-input-port|." :similar ())

(read-bytes :type extended :synopsis "(read-bytes size)\n(read-bytes size port)" :description "Returns a newly allocated string made of |size| characters read from |port|.\nIf less than |size| characters are available on the input port, the returned\nstring is smaller than |size| and its size is the number of available\ncharacters. |Port| may be omitted, in which case it defaults to the\nvalue returned by |current-input-port|.\n\nNOTE: This function was previously called |read-chars|. Usage\nof the old name is deprecated." :similar (read-chars))

(read-chars :see read-bytes)
(read-bytes! :type extended :synopsis "(read-bytes! str)\n(read-bytes! str port)" :description "This function reads the characters available from |port| in the string |str|\nby chuncks whose size is equal to the length of |str|.\nThe value returned by |read-bytes!| is an integer indicating the number\nof characters read. |Port| may be omitted, in which case it defaults to the\nvalue returned by |current-input-port|.\n\nThis function is similar to |read-bytes| except that it avoids to allocate\na new string for each read.\n@lisp\n(define (copy-file from to)\n  (let* ((size 1024)\n         (in  (open-input-file from))\n         (out (open-output-file to))\n         (s   (make-string size)))\n    (let Loop ()\n      (let ((n (read-bytes! s in)))\n        (cond\n          ((= n size)\n             (write-chars s out)\n             (Loop))\n          (else\n             (write-chars (substring s 0 n) out)\n             (close-port out)))))))\n@end lisp\n\nNOTE: This function was previously called |read-chars!|. Usage\nof the old name is deprecated." :similar (read-chars!))

(read-chars! :see read-bytes!)
(read-bytevector :type r7rs-procedure :synopsis "(read-bytevector k)\n(read-bytevector k port)" :description "Reads the next |k| bytes, or as many as are available\nbefore the end of file, from the textual input |port| into a\nnewly allocated string in left-to-right order and returns the\nstring. If no characters are available before the end of file,\nan end-of-file object is returned." :similar ())

(read-byte :type extended :synopsis "(read-byte)\n(read-byte port)" :description "Returns the next character available from the input |port| as an integer.\nIf the end of file is reached, this function returns the end of file\nobject." :similar ())

(peek-char :type procedure :synopsis "(peek-char)\n(peek-char port)" :description "Returns the next character available from the input |port|, without updating\nthe port to point to the following character. If no more characters are\navailable, an end of file object is returned. |Port| may be omitted, in\nwhich case it defaults to the value returned by |current-input-port|.\n@l\nNOTE: The value returned by a call to |peek-char| is the same as the\nvalue that would have been returned by a call to |read-char| with the same\nport. The only difference is that the very next call to |read-char| or\n|peek-char| on that port will return the value returned by the preceding\ncall to |peek-char|. In particular, a call to |peek-char| on an interactive\nport will hang waiting for input whenever a call to |read-char| would have\nhung." :similar ())

(peek-byte :type extended :synopsis "(peek-byte)\n(peek-byte port)" :description "Returns the next character available from the input |port|, without updating\nthe port to point to the following character. Whereas |peek-char|\nreturns a character, this function returns an integer between 0and 255." :similar ())

(eof-object? :type procedure :synopsis "(eof-object? obj)" :description "Returns |#t| if |obj| is an end of file object, otherwise returns |#f|." :similar ())

(eof-object :type extended :synopsis "(eof-object)" :description "(((#eof)))\n((end of file))\nReturns an end of file object. Note that the special notation |#eof| is\nanother way to return such an end of file object." :similar ())

(char-ready? :type procedure :synopsis "(char-ready?)\n(char-ready? port)" :description "Returns |#t| if a character is ready on the input port and returns |#f|\notherwise. If char-ready returns |#t| then the next read-char operation on\nthe given port is guaranteed not to hang. If the port is at end of file\nthen |char-ready?| returns |#t|. Port may be omitted, in which case it\ndefaults to the value returned by |current-input-port|." :similar ())

(u8-ready? :type r7rs-procedure :synopsis "(u8-ready?)\n(u8-ready? port)" :description "Returns |#t| if a byte is ready on the binary input |port| and\nreturns |#f| otherwise. If |u8-ready?| returns |#t| then the\nnext read-u8 operation on the given port is guaranteed\nnot to hang. If the |port| is at end of file then |u8-ready?|\nreturns |#t|." :similar ())

(write :type procedure :synopsis "(write obj)\n(write obj port)" :description "Writes a written representation of |obj| to the given |port|. Strings that\nappear in the written representation are enclosed in doublequotes, and\nwithin those strings backslash and doublequote characters are escaped\nby backslashes. Character objects are written using the ,(emph \"#\\\\\") notation.\n|Write| returns an unspecified value. The |port| argument may be omitted, in\nwhich case it defaults to the value returned by |current-output-port|." :similar ())

(write* :type r7rs-procedure :synopsis "(write-shared obj)\n(write-shared obj port)" :description "Writes a written representation of |obj| to the given port.  The\nmain difference with the |write| procedure is that |write*|\nhandles data structures with cycles. Circular structure written by\nthis procedure use the `\"{{sharp}}n=\"`)) and  `\"{{sharp}}n{{sharp}}\"`))\nnotations (see <<_other_notations>>).\n\nNOTE: This function is also called |write*|.\nThe name |write*| was the name used by {{stklos}} for\n|write-shared| before it was introduced in R7RS.\n" :similar (write-shared))

(write-shared :see write*)
(write-with-shared-structure :type extended :synopsis "(write-with-shared-structure obj)\n(write-with-shared-structure obj port)\n(write-with-shared-structure obj port optarg)\n(write/ss obj)\n(write/ss obj port)\n(write/ss obj port optarg)" :description "|write-with-shared-structure| has been added to be compatible with\n{{link-srfi 38}}. It is is identical to |write*|, except that it accepts one\nmore parameter (|optarg|). This parameter, which is not specified\nin {{quick-link-srfi 38}}, is always ignored. |write/ss| is only a shorter name for\n|write-with-shared-structure|.\n" :similar ())

(display :type procedure :synopsis "(display obj)\n(display obj port)" :description "Writes a representation of |obj| to the given |port|. Strings that\nappear in the written representation are not enclosed in\ndoublequotes, and no characters are escaped within those\nstrings. Character objects appear in the representation as if\nwritten by |write-char| instead of by |write|. |Display| returns an\nunspecified value. The |port| argument may be omitted, in which\ncase it defaults to the value returned by |current-output-port|.\n@l\nIMPORTANT: |Write| is intended for producing machine-readable\noutput and |display| is for producing human-readable output.\n@l\nNOTE: As required by R7RS does not loop forever when\n|obj| contains self-references." :similar ())

(display-simple :type extended :synopsis "(display-simple obj)\n(display-simple obj port)" :description "The |display-simple| procedure is the same as |display|, except\nthat shared structure is never represented using datum labels.\nThis can cause |display-simple| not to terminate if |obj|\ncontains circular structure." :similar ())

(display-shared :type extended :synopsis "(display-shared obj)\n(display-shared obj port)" :description "The |display-shared| procedure is the same as |display|, except\nthat shared structure are represented using datum labels." :similar ())

(newline :type procedure :synopsis "(newline)\n(newline port)" :description "Writes an end of line to |port|. Exactly how this is done differs from\none operating system to another. Returns an unspecified value. The |port|\nargument may be omitted, in which case it defaults to the value returned\nby |current-output-port|." :similar ())

(write-char :type procedure :synopsis "(write-char char)\n(write-char char port)" :description "Writes the character |char| (not an external representation of the\ncharacter) to the given |port| and returns an unspecified value.\nThe |port| argument may be omitted, in which case it defaults to the\nvalue returned by |current-output-port|." :similar ())

(write-chars :type extended :synopsis "(write-chars str)\n(write-chars str port)" :description "Writes the characters of string |str| to the given |port| and\nreturns an unspecified value.  The |port| argument may be omitted,\nin which case it defaults to the value returned by\n|current-output-port|.\n@l\nNOTE: This function is generally\nfaster than |display| for strings. Furthermore, this primitive does\nnot use the buffer associated to |port|.\n" :similar ())

(write-byte :type extended :synopsis "(write-byte b)\n(write-byte b port)" :description "Write byte |b| to the port. |b| must be an exact integer in range between 0\nand 255." :similar ())

(format :type extended :synopsis "(format port str obj ...)\n(format str obj)" :description "Writes the |obj|s to the given |port|, according to the format\nstring |str|. |Str| is written literally, except for the following\nsequences:\n\n- |~a| or |~A| is replaced by the printed representation of the\n  next |obj|.\n\n- |~s| or |~S| is replaced by the _slashified_ printed\n  representation of the next |obj|.\n\n- |~w| or |~W| is replaced by the printed representation\n  of the next |obj| (circular structures are correctly handled and\n  printed using |write*|).\n\n- |~d| or |~D| is replaced by the decimal printed representation\n  of the next |obj| (which must be a number).\n\n- |~x| or |~X| is replaced by the hexadecimal printed representation\n  of the next |obj| (which must be a number).\n\n- |~o| or |~O| is replaced by the octal printed representation\n  of the next |obj| (which must be a number).\n\n- |~b| or |~B| is replaced by the binary printed representation\n  of the next |obj| (which must be a number).\n\n- |~c| or |~C| is replaced by the printed representation\n  of the next |obj| (which must be a character).\n\n- |~y| or |~Y| is replaced by the pretty-printed representation\n  of the next |obj|. The standard pretty-printer is used here.\n\n- |~?| is replaced by the result of the recursive call of |format|\n  with the two next |obj|: the first item should be a string, and the\n  second, a list with the arguments.\n\n- |~k| or |~K| is another name for |~?|\n\n- |~[w[,d]]f| or |~[w[,d]]F| is replaced by the printed\n  representation of next |obj| (which must be a number) with width |w|\n  and |d| digits after the decimal. Eventually, |d| may be omitted.\n\n- |~~| is replaced by a single tilde character.\n\n- |~%| is replaced by a newline\n\n- |~t| or |~T| is replaced by a tabulation character.\n\n- |~&| is replaced by a newline character if it is known that the\n  previous character was not a newline\n\n- |~_| is replaced by a space\n\n- |~h| or |~H| provides some help\n\n|Port| can be a boolean or a port. If |port| is |#t|, output goes to\nthe current output port; if |port| is |#f|, the output is returned as a\nstring.  Otherwise, the output is printed on the specified port.\n@lisp\n   (format #f \"A test.\")        => \"A test.\"\n   (format #f \"A ~a.\" \"test\")   => \"A test.\"\n   (format #f \"A ~s.\" \"test\")   => \"A \\\"test\\\".\"\n   (format \"~8,2F\" 1/3)         => \"    0.33\"\n   (format \"~6F\" 32)            => \"    32\"\n   (format \"~1,2F\" 4321)        => \"4321.00\"\n   (format \"~1,2F\" (sqrt -3.9)) => \"0.00+1.97i\"\n   (format \"#d~d #x~x #o~o #b~b~%\" 32 32 32 32)\n                                => \"#d32 #x20 #o40 #b100000\\n\"\n   (format #f \"~&1~&~&2~&~&~&3~%\")\n                                => \"\\n1\\n2\\n3\\n\"\n   (format \"~a ~? ~a\" 'a \"~s\" '(new) 'test)\n                                => \"a new test\"\n@end lisp\n\nNOTE: The second form of |format| is compliant with {{link-srfi 28}}.\nThat is, when |port| is omitted, the output is returned as a string as if\n|port| was given the value |#f|.\n\nNOTE: Since version 0.58, |format| is also compliant with {{link-srfi 48}}." :similar ())

(error :type extended :synopsis "(error str obj ...)\n(error name str obj ...)" :description "|error| is used to signal an error to the user. The second form\nof |error| takes  a symbol as first parameter; it is generally used for the\nname of the procedure which raises the error.\n\nNOTE: The specification string may follow the _tilde conventions_ of\n|format| (see _<<format, primitive `format`>>_); in this case this\nprocedure builds an error message according to the specification\ngiven in |str|. Otherwise,\nthis procedure is in conformance with the |error| procedure defined in\n{{link-srfi 23}} and |str| is printed with the |display| procedure,\nwhereas the |obj|s are printed  with the |write| procedure.\n\nHereafter, are some calls of the |error| procedure using a formatted string\n@lisp\n(error \"bad integer ~A\" \"a\")\n                     @print{} bad integer a\n(error 'vector-ref \"bad integer ~S\" \"a\")\n                     @print{} vector-ref: bad integer \"a\"\n(error 'foo \"~A is not between ~A and ~A\" \"bar\" 0 5)\n                     @print{} foo: bar is not between 0 and 5\n@end lisp\n\nand some conform to {{quick-link-srfi 23}}\n@lisp\n(error \"bad integer\" \"a\")\n                    @print{} bad integer \"a\"\n(error 'vector-ref \"bad integer\" \"a\")\n                   @print{} vector-ref: bad integer \"a\"\n(error \"bar\" \"is not between\" 0 \"and\" 5)\n                   @print{} bar \"is not between\" 0 \"and\" 5\n@end lisp" :similar ())

(signal-error :type extended :synopsis "(signal-error cond str obj ...)\n(signal-error cond name str obj ...)" :description "This procedure is similar to error, except that the type of the error\ncan be passed as the first parameter. The type of the error must be a\ncondition which inherits from |&error-message|.\n@l\nNote that |(error arg ...)| is equivalent to\n@lisp\n(signal-error &error-message arg ...)\n@end lisp" :similar ())

(close-output-port :type procedure :synopsis "(close-input-port port)\n(close-output-port port)" :description "Closes the port associated with |port|, rendering the port incapable of\ndelivering or accepting characters. These routines have no effect if the\nport has already been closed. The value returned is *_void_*." :similar (close-input-port))

(close-input-port :see close-output-port)
(close-port :type r7rs-procedure :synopsis "(close-port port)" :description "Closes the port associated with |port|." :similar ())

(port-closed? :type extended :synopsis "(port-closed? port)\n(port-open?  port)" :description "|port-closed?| returns |#t| if |port| is closed and |#f| otherwise.\nOn the contrary, |port-open?| returns |#t| if |port| is open and\n|#f| otherwise.\n@l\nNOTE: |port-closed?| was the usual STklos function to\ntest if a port is closed. |port-open?| has been added to be the companion\nof the R7RS functions |input-port-open?| and |output-port-open?|" :similar (port-open?))

(port-open? :see port-closed?)
(read-line :type extended :synopsis "(read-line)\n(read-line port)" :description "Reads the next line available from the input port |port|. This function\nreturns 2 values: the first one is the string which contains the line\nread, and the second one is the end of line delimiter. The end of line\ndelimiter can be an end of file object, a character or a string in case\nof a multiple character delimiter. If no more characters are available\non |port|, an end of file object is returned.  |Port| may be omitted,\nin which case it defaults to the value returned by |current-input-port|.\n@l\nNOTE: As said in _<<values, primitive `values`>>_, if |read-line| is not\nused in  the context of |call-with-values|, the second value returned by\nthis procedure is ignored." :similar ())

(copy-port :type extended :synopsis "(copy-port in out)\n(copy-port in out max)" :description "Copy the content of port |in|, which must be opened for reading, on\nport |out|, which must be opened for writing. If |max| is not specified,\nAll the characters from the input port are copied on ouput port. If |max|\nis specified, it must be an integer indicating the maximum number of characters\nwhich are copied from |in| to |out|." :similar ())

(flush-output-port :type extended :synopsis "(flush-output-port)\n(flush-output-port port)" :description "Flushes the buffer associated with the given output |port|. The\n|port| argument may be omitted, in which case it defaults to the value\nreturned by |current-output-port|" :similar ())

(port-current-line :type extended :synopsis "(port-current-line)\n(port-current-line port)" :description "Returns the current line number associated to the given input |port| as an\ninteger. The |port| argument may be omitted, in which case it defaults to\nthe value returned by |current-input-port|.\n@l\nNOTE: The |port-seek|, |read-chars| and |read-chars!| procedures\ngenerally break the line-number. After using one of these procedures, the\nvalue returned by |port-current-line| will be |-1| (except a |port-seek|\nat the beginning of the port reinitializes the line counter)." :similar ())

(port-current-position :type extended :synopsis "(port-current-position)\n(port-current-position port)" :description "Returns the position associated to the given |port| as an\ninteger (i.e. number of characters from the beginning of the port).\nThe |port| argument may be omitted, in which case it defaults to\nthe value returned by |current-input-port|." :similar ())

(seek-file-port :type extended :synopsis "(port-seek port pos)\n(port-seek port pos whence)" :description "Sets the file position for the given |port| to the position |pos|.\nThe new position, measured in bytes, is obtained by adding |pos|\nbytes to the position specified by |whence|. If passed, |whence|\nmust be one of |:start|, |:current| or |:end|. The resulting\nposition is relative to the start of the file, the current position\nindicator, or end-of-file, respectively. If |whence| is omitted, it\ndefaults to |:start|.\n@l\nNOTE: After using port-seek, the value returned by\n|port-current-line| may be incorrect." :similar ())

(port-rewind :type extended :synopsis "(port-rewind port)" :description "Sets the port position to the beginning of |port|. The value returned by\n|port-rewind| is *_void_*." :similar ())

(port-close-hook-set! :type extended :synopsis "(port-close-hook-set! port thunk)" :description "Associate the procedure |thunk| to |port|. The thunk will be called\nthe first time |port| is closed.\n@lisp\n(let* ((tmp (temporary-file-name))\n       (p   (open-output-file tmp))\n       (foo #t))\n  (port-close-hook-set! p\n                     (lambda()\n                       (remove-file tmp)\n                       (set! foo #t)))\n  (close-port p)\n  foo)\n@end lisp" :similar ())

(port-close-hook :type extended :synopsis "(port-close-hook port)" :description "Returns the user close procedure associated to the given |port|." :similar ())


;; Source file "print.c"

(write-pretty-quotes :type extended :synopsis "(write-pretty-quotes)\n(write-pretty-quotes value)" :description "This parameter object permits to change the default behaviour of\nthe |display| or |write| primitives when they write a list which starts with\n the symbol quote,  quasiquote, unquote or unquote-splicing. If this parameter\nhas a false value, the writer uses the list notation instead of a\nmore human-readable value.\nBy default, this parameter value is set to |#t|.\n@lisp\n(let ((x ''a))\n  (display x)\n  (display \" \")\n  (write-pretty-quotes #f)\n  (display x))               @print 'a (quote a)\n@end lisp" :similar ())


;; Source file "proc.c"

(procedure? :type procedure :synopsis "(procedure? obj)" :description "Returns |#t| if |obj| is a procedure, otherwise returns |#f|.\n\n@lisp\n(procedure? car)                            =>  #t\n(procedure? 'car)                           =>  #f\n(procedure? (lambda (x) (* x x)))           =>  #t\n(procedure? '(lambda (x) (* x x)))          =>  #f\n(call-with-current-continuation procedure?) =>  #t\n@end lisp" :similar ())

(closure? :type extended :synopsis "(closure? obj)" :description "Returns {{true}} if |obj| is a procedure created with the |lambda| syntax and\n{{false}} otherwise." :similar ())

(procedure-formals :type extended :synopsis "(procedure-formals proc)" :description "Returns the formal parameters of procedure |proc|.\nNote that procedure formal parameters are kept in memory only if\nthe compiler flag <<\"compiler:keep-formals\">> is set at its creation.\nIf |proc| formal parameters are not available, |procedure-formals|\nreturns |#f|." :similar ())

(procedure-source :type extended :synopsis "(procedure-source proc)" :description "Returns the source form used to define procedure |proc|.\nNote that procedure source is kept in memory only if the compiler flag\n<<\"compiler:keep-source\">> is set at its creation. If |proc| source is\nnot available, |procedure-source| returns |#f|." :similar ())

(map :type procedure :synopsis "(map proc list1 list2 ...)" :description "The |list|s must be lists, and |proc| must be a procedure taking as many\narguments as there are lists and returning a single value.\nIf more than one list is given, then they must all be the same length.\n|Map| applies |proc| element-wise to the elements of the |list|s and returns\na list of the results, in order.  The dynamic order in which proc is applied\nto the elements of the lists is unspecified.\n@lisp\n(map cadr '((a b) (d e) (g h)))   =>  (b e h)\n\n(map (lambda (n) (expt n n))\n     '(1 2 3 4 5))                =>  (1 4 27 256 3125)\n\n(map + '(1 2 3) '(4 5 6))         =>  (5 7 9)\n\n(let ((count 0))\n  (map (lambda (ignored)\n      (set! count (+ count 1))\n      count)\n       '(a b)))                   =>  (1 2) ,(emph \"or\") (2 1)\n@end lisp" :similar ())

(for-each :type procedure :synopsis "(for-each proc list1 list2 ...)" :description "The arguments to |for-each| are like the arguments to |map|, but |for-each|\ncalls proc for its side effects rather than for its values.\nUnlike |map|, |for-each| is guaranteed to call proc on the elements of\nthe lists in order from the first element(s) to the last, and the value\nreturned by |for-each| is *_void_*.\n@lisp\n(let ((v (make-vector 5)))\n  (for-each (lambda (i)\n              (vector-set! v i (* i i)))\n            '(0 1 2 3 4))\n  v)                                =>  #(0 1 4 9 16)\n@end lisp" :similar ())


;; Source file "process.c"

(fork :type extended :synopsis "(fork)\n(fork thunk)" :description "This procedure is a wrapper around the standard Unix |fork| system\ncall which permits to create a new (heavy) process.\nWhen called without parameter, this procedure returns two times\n(one time in the parent process and one time in the child process).\nThe value returned to the parent process is a process object\nrepresenting the child process and the value returned to the child\nprocess is always the value |#f|.\nWhen called with a parameter (which must be a thunk), the new process\nexcutes |thunk| and terminate it execution when |thunk| returns. The\nvalue returned to the parent process is a process object representing\nthe child process." :similar ())

(process? :type extended :synopsis "(process? obj)" :description "Returns |#t| if |obj| is a process , otherwise returns |#f|." :similar ())

(process-alive? :type extended :synopsis "(process-alive? proc)" :description "Returns |#t| if process |proc| is currently running, otherwise returns |#f|." :similar ())

(process-pid :type extended :synopsis "(process-pid proc)" :description "Returns an integer which represents the Unix identification (PID) of the\nprocessus." :similar ())

(process-list :type extended :synopsis "(process-list)" :description "Returns the list of processes which are currently running (i.e. alive)." :similar ())

(process-error :type extended :synopsis "(process-input proc)\n(process-output proc)\n(process-error proc)" :description "Returns the file port associated to the standard input, output or error\nof |proc|, if it is redirected in (or to) a pipe; otherwise\nreturns |#f|. Note that the returned port is opened for reading\nwhen calling |process-output| or |process-error|; it is opened\nfor writing when calling |process-input|." :similar (process-output process-input))

(process-output :see process-error)
(process-input :see process-error)
(process-wait :type extended :synopsis "(process-wait proc)" :description "Stops the current process (the Scheme process) until |proc| completion.\n|Process-wait| returns |#f| when |proc| is already terminated; it returns\n|#t| otherwise." :similar ())

(process-exit-status :type extended :synopsis "(process-exit-status proc)" :description "Returns the exit status of |proc| if it has finished its execution;\nreturns |#f| otherwise." :similar ())

(process-send-signal :type extended :synopsis "(process-send-signal proc sig)" :description "Sends the integer signal |sig| to |proc|. Since value of |sig| is system\ndependant, use the symbolic defined signal constants to make your program\nindependant of the running system (see <<_signals>>).\nThe result of |process-send-signal| is *_void_*." :similar ())


;; Source file "promise.c"

(force :type procedure :synopsis "(force promise)" :description "Forces the value of |promise| (see _<<delay,primitive delay>>_).\nIf no value has been computed for the promise, then a value is\ncomputed and returned. The value of the promise is cached\n(or \"memoized\") so that if it is forced a second time, the\npreviously computed value is returned.\n\n@lisp\n(force (delay (+ 1 2)))        =>  3\n(let ((p (delay (+ 1 2))))\n  (list (force p) (force p)))  =>  (3 3)\n\n(define a-stream\n  (letrec ((next (lambda (n)\n                   (cons n (delay (next (+ n 1)))))))\n    (next 0)))\n(define head car)\n(define tail (lambda (stream) (force (cdr stream))))\n\n(head (tail (tail a-stream)))  =>  2\n@end lisp\n\n|Force| and |delay| are mainly intended for programs written in\nfunctional style. The following examples should not be considered\nto illustrate good programming style, but they illustrate the\nproperty that only one value is computed for a promise, no matter\nhow many times it is forced.\n@lisp\n(define count 0)\n(define p (delay (begin (set! count (+ count 1))\n                        (if (> count x)\n                            count\n                            (force p)))))\n(define x 5)\np                     =>  a promise\n(force p)             =>  6\np                     =>  a promise, still\n(begin (set! x 10)\n       (force p))     =>  6\n@end lisp\nNOTE: See R5RS for details on a posssible way to implement\n|force| and |delay|." :similar ())

(promise? :type r7rs-procedure :synopsis "(promise? obj)" :description "Returns |#t| if |obj| is a promise, otherwise returns |#f|." :similar ())


;; Source file "read.c"

(read-case-sensitive :type extended :synopsis "(read-case-sensitive)\n(read-case-sensitive value)" :description "This parameter object permits to change the default behaviour of\nthe |read| primitive when reading a symbol. If this parameter has\na true value a symbol is not converted to a default case when interned.\nSince R7RS requires that symbol are case insignificant, the default\nvalue  of this parameter is |#t|.\n@lisp\n(read-case-sensitive)        => |#t|\n(read-from-string \"ABC\")     => ABC\n(read-case-sensitive #f)\n(read-from-string \"ABC\")     => abc\n@end lisp\n[NOTE]\n====\n*  Default behaviour can be changed for a whole execution\n   with the |--case-sensitive| or |case-insensitive| options.\n*  See also syntax for _<<_symbols, special characters>>_ in symbols.\n====" :similar ())

(keyword-colon-position :type extended :synopsis "(keyword-colon-position)\n(keyword-colon-position value)" :description "This parameter object indicates the convention used by the reader to\ndenote keywords. The allowed values are:\n\n- *none*, to forbid a symbol with colon to be interpreted as a keyword,\n- *before*, to read symbols starting with a colon as keywords,\n- *after*, to read symbols ending with a colon as keywords,\n- *both*,  to read symbols starting or ending with a colon as keywords.\n\nNote that the notation |#:key| is always read as a keyword independently\nof the value of |keyword-colon-position|. Hence, we have\n@lisp\n(list (keyword? ':a)\n      (keyword? 'a:)\n      (keyword? '#:a))\n                 => (#f #f #t)  ; if keyword-colon-position is none\n                 => (#t #f #t)  ; if keyword-colon-position is before\n                 => (#f #t #t)  ; if keyword-colon-position is after\n                 => (#t #t #t)  ; if keyword-colon-position is both\n@end lisp" :similar ())


;; Source file "regexp.c"

(string->regexp :type extended :synopsis "(string->regexp string)" :description "|String->regexp| takes a string representation of a regular\nexpression and compiles it into a regexp value. Other regular\nexpression procedures accept either a string or a regexp value as\nthe matching pattern. If a regular expression string is used\nmultiple times, it is faster to compile the string once to a regexp\nvalue and use it for repeated matches instead of using the string\neach time." :similar ())

(regexp? :type extended :synopsis "(regexp? obj)" :description "|Regexp| returns |#t| if |obj| is a regexp value created by the |regexp|,\notherwise |regexp| returns |#f|." :similar ())

(regexp-match-positions :type extended :synopsis "(regexp-match pattern str)\n(regexp-match-positions pattern str)" :description "These functions attempt to match |pattern| (a string or a regexp value)\nto |str|. If the match fails, |#f| is returned. If the match succeeds,\na list (containing strings for |regexp-match| and positions for\n|regexp-match-positions|) is returned. The first string (or positions) in\nthis list is the portion of string that matched pattern. If two portions\nof string can match pattern, then the earliest and longest match is found,\nby default.\n\nAdditional strings or positions are returned in the list if pattern contains\nparenthesized sub-expressions; matches for the sub-expressions are provided\nin the order of the opening parentheses in pattern.\n@lisp\n(regexp-match-positions \"ca\" \"abracadabra\")\n                 => ((4 6))\n(regexp-match-positions \"CA\" \"abracadabra\")\n                 => #f\n(regexp-match-positions \"(?i)CA\" \"abracadabra\")\n                 => ((4 6))\n(regexp-match \"(a*)(b*)(c*)\" \"abc\")\n                 => (\"abc\" \"a\" \"b\" \"c\")\n(regexp-match-positions \"(a*)(b*)(c*)\" \"abc\")\n                 => ((0 3) (0 1) (1 2) (2 3))\n(regexp-match-positions \"(a*)(b*)(c*)\" \"c\")\n                 => ((0 1) (0 0) (0 0) (0 1))\n(regexp-match-positions \"(?<=\\\\d{3})(?<!999)foo\"\n                        \"999foo and 123foo\")\n                 => ((14 17))\n@end lisp" :similar (regexp-match))

(regexp-match :see regexp-match-positions)
(regexp-quote :type extended :synopsis "(regexp-quote str)" :description "Takes an arbitrary string and returns a string where characters of\n|str| that could serve as regexp metacharacters are escaped with a\nbackslash, so that they safely match only themselves.\n@lisp\n(regexp-quote \"cons\")       => \"cons\"\n(regexp-quote \"list?\")      => \"list\\\\?\"\n@end lisp\n|regexp-quote| is useful when building a composite regexp from\na mix of regexp strings and verbatim strings." :similar ())


;; Source file "signal.c"

(set-signal-handler! :type extended :synopsis "(set-signal-handler! sig handler)" :description "Replace the handler for integer signal |sig| with |handler|.\nThe value of |handler| can be:\n\n- |#t| to reset the signal handler for |sig| to the\n   default system handler.\n- |#f| to  ignore the |sig| signal. Note that POSIX states that\n  `SIGKILL` and `SIGSTOP` cannot be ignored or caught.\n- a one parameter procedure, which will be called when the\n  processus  receives the signal |sig|.\n\nThis procedure returns *_void_*.\n\n@lisp\n(let ((x #f))\n  (set-signal-handler! SIGUSR1\n                       (lambda (i) (set! x #t)))\n  (send-signal SIGUSR1)\n  x)    => #t\n@end lisp" :similar ())

(get-signal-handler :type extended :synopsis "(get-signal-handler! sig)" :description "Return the handler for integer signal |sig|.\nThe value of |handler| can be a boolean value or a procedure.\nSee <<set-signal-handler!, primitive `set-signal-handler!`>> for\nmore information." :similar ())

(send-signal :type extended :synopsis "(send-signal sig)\n(send-signal sig pid)" :description "Send the integer signal |sig| to the process with |pid| process id.\nIf the second parameter is absent, it deaults to the one of the running\nprogram." :similar ())


;; Source file "sio.c"


;; Source file "socket.c"

(make-server-socket :type extended :synopsis "(make-server-socket)\n(make-server-socket port-number)" :description "|make-server-socket| returns a new socket object. If |port-number|\nis specified, the socket is listening on the specified port;\notherwise, the communication port is chosen by the system." :similar ())

(make-client-socket :type extended :synopsis "(make-client-socket hostname port-number)\n(make-client-socket hostname port_number line-buffered)" :description "|make-client-socket| returns a new socket object. This socket\nestablishes a link between the running program and the application\nlistening on port |port-number| of |hostname|.  If  the optional argument\n|line-buffered| has a true value, a line buffered policy is used when writing\nto the client socket (i.e. characters on the socket are tranmitted as soon\nas a `\"#\\newline` character is encountered). The default value of\n|line-buffered| is |#t|.\n" :similar ())

(socket-shutdown :type extended :synopsis "(socket-shutdown sock)\n(socket-shutdown sock close)" :description "|Socket-shutdown| shutdowns the connection associated to\n|socket|. If the socket is a server socket, |socket-shutdown| is called\non all the client sockets connected to this server.\n|Close| indicates if the socket must be closed or not, when\nthe connection is destroyed. Closing the socket forbids further\nconnections on the same port with the |socket-accept| procedure.\nOmitting a value for |close| implies the closing of socket.\n@l\nThe following example shows a simple server: when there is\na new connection on the port number 12345, the server displays\nthe first line sent to it by the client, discards the others and\ngo back waiting for further client connections.\n@lisp\n(let ((s (make-server-socket 12345)))\n   (let loop ()\n      (let ((ns (socket-accept s)))\n        (format #t \"I've read: ~A\\\\n\"\n                (read-line (socket-input ns)))\n        (socket-shutdown ns #f)\n        (loop))))\n@end lisp" :similar ())

(socket-accept :type extended :synopsis "(socket-accept socket)\n(socket-accept socket line-buffered)" :description "|socket-accept| waits for a client connection on the given\n|socket|. If no client is already waiting for a connection, this\nprocedure blocks its caller; otherwise, the first connection request\non the queue of pending connections is connected and |socket-accept|\nreturns a new client socket to serve this request.\nThis procedure must be called on a server socket created\nwith |make-server-socket|. The result of |socket-accept| is undefined.\n|Line-buffered| indicates if the port should be considered as a\nline buffered. If |line-buffered| is omitted, it defaults to |#t|.\n\nThe following example is a simple server which waits for a connection\non the port 12345 footnote:[Under Unix, you can simply connect to\na listening socket with the |telnet| of |netcat| command. For the given\nexample, this can be achieved with `netcat localhost 12345`]\n\nOnce the connection with the distant program is established, we read\na line on the input port associated to the socket, and we write the\nlength of this line on its output port.\n@lisp\n(let* ((server (make-server-socket 12345))\n       (client (socket-accept server))\n       (l      (read-line (socket-input client))))\n  (format (socket-output client)\n          \"Length is: ~a\\n\" (string-length l))\n  (socket-shutdown server))\n@end lisp\n\nNote that shutting down the |server| socket suffices here to close\nalso the connection to |client|." :similar ())

(socket? :type extended :synopsis "(socket? obj)" :description "Returns |#t| if |socket| is a socket, otherwise returns |#f|." :similar ())

(socket-client? :type extended :synopsis "(socket-client? obj)" :description "Returns |#t| if |socket| is a client socket, otherwise returns |#f|." :similar ())

(socket-server? :type extended :synopsis "(socket-server? obj)" :description "Returns |#t| if |socket| is a server socket, otherwise returns |#f|." :similar ())

(socket-port-number :type extended :synopsis "(socket-port-number socket)" :description "Returns the integer number of the port used for |socket|." :similar ())

(socket-output :type extended :synopsis "(socket-input socket)\n(socket-output socket)" :description "Returns the port associated for reading or writing with the\nprogram connected with |socket|. Note that this port is both textual\nand binary. If no connection has already been established,\nthese functions return |#f|.\n\nThe following example shows how to make a client socket. Here we\ncreate a socket on port 13 of the machine \n|kaolin.unice.fr| footnote:[Port 13, if open, can be used for testing:\nmaking a connection to it permits to know the distant system's idea\nof the time of day.]:\n@lisp\n(let ((s (make-client-socket \"kaolin.unice.fr\" 13)))\n  (format #t \"Time is: ~A~%\" (read-line (socket-input s)))\n  (socket-shutdown  s))\n@end lisp" :similar (socket-input))

(socket-input :see socket-output)
(socket-host-name :type extended :synopsis "(socket-host-name socket)" :description "Returns a string which contains the name of the distant host\nattached to |socket|. If |socket| has been created with\n|make-client-socket| this procedure returns the official name of\nthe distant machine used for connection. If |socket| has been\ncreated with |make-server-socket|, this function returns the\n official name of the client connected to the socket. If no client\nhas used yet |socket|, this function returns |#f|." :similar ())

(socket-host-address :type extended :synopsis "(socket-host-address socket)" :description "Returns a string which contains the IP number of the distant host\nattached to |socket|. If |socket| has been created with\n|make-client-socket| this procedure returns the IP number of the\ndistant machine used for connection. If |socket| has been created\nwith |make-server-socket|, this function returns the address of the\nclient connected to the socket.  If no client has used yet\n|socket|, this function returns |#f|." :similar ())

(socket-local-address :type extended :synopsis "(socket-local-address socket)" :description "Returns a string which contains the IP number of the local host\nattached to |socket|." :similar ())


;; Source file "sport.c"

(open-input-string :type extended :synopsis "(open-input-string str)" :description "Returns an input string port capable of delivering characters from\n|str|." :similar ())

(open-input-bytevector :type r7rs-procedure :synopsis "(open-input-string bytevector)" :description "Takes a bytevector and returns a binary input port that\ndelivers bytes from the |bytevector|." :similar ())

(open-output-string :type extended :synopsis "(open-output-string)" :description "Returns an output string port capable of receiving and collecting characters." :similar ())

(open-output-bytevector :type r7rs-procedure :synopsis "(open-output-bytevector)" :description "Returns a binary output port that will accumulate bytes\nfor retrieval by |get-output-bytevector|." :similar ())

(get-output-string :type extended :synopsis "(get-output-string port)" :description "Returns a string containing all the text that has been written on the\noutput string |port|.\n@lisp\n (let ((p (open-output-string)))\n    (display \"Hello, world\" p)\n    (get-output-string p))         => \"Hello, world\"\n@end lisp" :similar ())

(get-output-bytevector :type extended :synopsis "(get-output-bytevector port)" :description "Returns a bytevector consisting of the bytes that have been\noutput to the |port| so far in the order they were output.\n\n @lisp\n (let ((p (open-output-bytevector)))\n    (u8-write 65)\n    (u8-write 66)\n    (get-output-bytevector p))         => #u8(65 66)\n@end lisp" :similar ())

(output-string-port? :type extended :synopsis "(input-string-port? obj)\n(output-string-port? obj)" :description "Returns |#t| if |obj| is an input string port or output string port\nrespectively, otherwise returns |#f|." :similar (input-string-port?))

(input-string-port? :see output-string-port?)
(output-bytevector-port? :type extended :synopsis "(input-bytevector-port? obj)\n(output-bytevector-port? obj)" :description "Returns |#t| if |obj| is an input bytevector port or output bytevector port\nrespectively, otherwise returns |#f|." :similar (input-bytevector-port?))

(input-bytevector-port? :see output-bytevector-port?)

;; Source file "stklos.c"


;; Source file "str.c"

(string? :type procedure :synopsis "(string? obj)" :description "Returns |#t| if |obj| is a string, otherwise returns |#f|." :similar ())

(make-string :type procedure :synopsis "(make-string k)\n(make-string k char)" :description "|Make-string| returns a newly allocated string of length |k|. If |char| is\ngiven, then all elements of the string are initialized to |char|, otherwise\nthe contents of the string are unspecified." :similar ())

(string :type procedure :synopsis "(string char ...)" :description "Returns a newly allocated string composed of the arguments." :similar ())

(string-length :type procedure :synopsis "(string-length string)" :description "Returns the number of characters in the given |string|." :similar ())

(string-ref :type procedure :synopsis "(string-ref string k)" :description "|String-ref| returns character k of string using zero-origin indexing\n(|k| must be a valid index of string)." :similar ())

(string-set! :type procedure :synopsis "(string-set! string k char)" :description "|String-set!| stores |char| in element |k| of |string| and returns\n*_void_* (|k| must be a valid index of |string|).\n\n@lisp\n(define (f) (make-string 3 #\\*))\n(define (g) \"***\")\n(string-set! (f) 0 #\\?)  =>  void\n(string-set! (g) 0 #\\?)  =>  error\n(string-set! (symbol->string 'immutable) 0 #\\?)\n                         =>  error\n@end lisp" :similar ())

(string-ci=? :type r57rs-procedure :synopsis "(string=? string1 string2 ...)\n(string-ci=? string1 string2 ...)" :description "Returns |#t| if all the strings are the same length and contain the same\ncharacters in the same positions, otherwise returns |#f|. |String-ci=?|\ntreats upper and lower case letters as though they were the same character,\nbut |string=?| treats upper and lower case as distinct characters.\n\nNOTE: R5RS version of these functions accept only two arguments." :similar (string=?))

(string=? :see string-ci=?)
(string-ci>=? :type r57rs-procedure :synopsis "(string<? string1 string2 ...)\n(string>? string1 string2 ...)\n(string<=? string1 string2 ...)\n(string>=? string1 string2 ...)\n(string-ci<? string1 string2 ...)\n(string-ci>? string1 string2 ...)\n(string-ci<=? string1 string2 ...)\n(string-ci>=? string1 string2)" :description "These procedures are the lexicographic extensions to strings of the\ncorresponding orderings on characters. For example, |string<?| is the\nlexicographic ordering on strings induced by the ordering |char<?| on\ncharacters. If two strings differ in length but are the same up to the\nlength of the shorter string, the shorter string is considered to be\nlexicographically less than the longer string.\n\nNOTE: R5RS version of these functions accept only two arguments." :similar (string-ci>? string-ci<=? string-ci<? string>=? string>? string<=? string<?))

(string-ci>? :see string-ci>=?)
(string-ci<=? :see string-ci>=?)
(string-ci<? :see string-ci>=?)
(string>=? :see string-ci>=?)
(string>? :see string-ci>=?)
(string<=? :see string-ci>=?)
(string<? :see string-ci>=?)
(substring :type procedure :synopsis "(substring string start end)" :description "|String| must be a string, and |start| and |end| must be exact integers\nsatisfying\n@lisp\n0 <= start <= end <= (string-length string).\n@end lisp\n|Substring| returns a newly allocated string formed from the characters\nof |string| beginning with index |start| (inclusive) and ending with\nindex |end| (exclusive)." :similar ())

(string-append :type procedure :synopsis "(string-append string ...)" :description "Returns a newly allocated string whose characters form the concatenation\nof the given strings." :similar ())

(string-append! :type extended :synopsis "(string-append! string ...)" :description "Extends string by appending each value (in order) to the end of string.\nA value can be a character or a string.\n\nIt is guaranteed that string-append! will return the same object that\nwas passed to it as first argument, whose size may be larger.\n\n\nNOTE: This function is defined in SRFI-118." :similar ())

(string-replace! :type extended :synopsis "(string-replace! dst dst-start dst-end src)\n(string-replace! dst dst-start dst-end src src-start)\n(string-replace! dst dst-start dst-end src src-start src-end)" :description "Replaces the characters of the variable-size string dst (between\ndst-start and dst-end) with the characters of the string src\n(between src-start and src-end). The number of characters from src\nmay be different from the number replaced in dst, so the string may\ngrow or contract. The special case where dst-start is equal to\ndst-end corresponds to insertion; the case where src-start is equal\nto src-end corresponds to deletion. The order in which characters\nare copied is unspecified, except that if the source and\ndestination overlap, copying takes place as if the source is first\ncopied into a temporary string and then into the destination.\nReturns string, appended with the characters form the concatenation\nof the given arguments, which can be either strings or characters.\n\nIt is guaranteed that string-replace! will return the same object that\nwas passed to it as first argument, whose size may be larger.\n\nNOTE: This function is defined in SRFI-118." :similar ())

(list->string :type r57rs-procedure :synopsis "(string->list string)\n(string->list string start)\n(string->list string start end)\n(list->string list)" :description "|String->list| returns a newly allocated list of the characters of\n|string| between |start| and |end|. |List->string| returns a newly\nallocated string formed from the characters in the list |list|,\nwhich must be a list of characters. |String->list| and\n|list->string| are inverses so far as |equal?| is concerned.\n\nNOTE: The R5RS version of |string->list| accepts only one\nparameter." :similar (string->list))

(string->list :see list->string)
(string-copy :type r57rs-procedure :synopsis "(string-copy string)\n(string-copy string start)\n(string-copy string start stop)" :description "Returns a newly allocated copy of the part of the given |string|\nbetween |start| and |stop|.\n\nNOTE: The R5RS version of |string-copy| accepts only one argument." :similar ())

(string-fill! :type r7rs-procedure :synopsis "(string-fill! string char)\n(string-fill! string char start)\n(string-fill! string char start end)" :description "Stores |char| in every element of the given |string| between |start| and |end|.\n@l\nNOTE: The R5RS version of |string-fill!| accepts only one argument." :similar ())

(string-find? :type extended :synopsis "(string-find? str1 str2)" :description "Returns |#t| if |str1| appears somewhere in |str2|; otherwise returns |#f|." :similar ())

(string-position :type extended :synopsis "(string-position str1 str2)" :description "Returns the (first) index where |str1| is a substring of |str2| if it exists;\notherwise returns |#f|.\n@lisp\n(string-position \"ca\" \"abracadabra\") =>  4\n(string-position \"ba\" \"abracadabra\") =>  #f\n@end lisp\n\nNOTE: This function was also called |string-index|. This name is deprecated\nsince it conficts with the |string-index| defined in SRFI-13." :similar (string-index))

(string-index :see string-position)
(string-split :type extended :synopsis "(string-split str)\n(string-split str delimiters)" :description "Parses |string| and returns a list of tokens ended by a character of the\n|delimiters| string. If |delimiters| is omitted, it defaults to a string\ncontaining a space, a tabulation and a newline characters.\n@lisp\n(string-split \"/usr/local/bin\" \"/\")\n                       => (\"usr\" \"local\" \"bin\")\n(string-split \"once   upon a time\")\n                       => (\"once\" \"upon\" \"a\" \"time\")\n@end lisp" :similar ())

(string-mutable? :type extended :synopsis "(string-mutable? obj)" :description "Returns |#t| if |obj| is a mutable string, otherwise returns |#f|.\n@lisp\n(string-mutable? \"abc\")                => #f\n(string-mutable? (string-copy \"abc\"))  => #t\n(string-mutable? (string #\\a #\\b #\\c)) => #t\n(string-mutable? 12)                   => #f\n@end lisp" :similar ())

(string-downcase :type r7rs-procedure :synopsis "(string-downcase str)\n(string-downcase str start)\n(string-downcase str start end)" :description "Returns a string in which the upper case letters of string |str| between the\n|start| and |end| indices have been replaced by their lower case equivalent.\nIf |start| is omited, it defaults to 0. If |end| is omited, it defaults to\nthe length of |str|.\n@lisp\n(string-downcase \"Foo BAR\")        => \"foo bar\"\n(string-downcase \"Foo BAR\" 4)      => \"bar\"\n(string-downcase \"Foo BAR\" 4 6)    => \"ba\"\n@end lisp\n\nNOTE: In R7RS, |string-downcase| accepts only one argument." :similar ())

(string-downcase! :type extended :synopsis "(string-downcase! str)\n(string-downcase! str start)\n(string-downcase! str start end)" :description "This is the in-place side-effecting variant of |string-downcase|.\n@lisp\n(string-downcase! (string-copy \"Foo BAR\") 4)    => \"Foo bar\"\n(string-downcase! (string-copy \"Foo BAR\") 4 6)  => \"Foo baR\"\n@end lisp" :similar ())

(string-upcase :type r7rs-procedure :synopsis "(string-upcase str)\n(string-upcase str start)\n(string-upcase str start end)" :description "Returns a string in which the lower case letters of string |str| between the\n|start| and |end| indices have been replaced by their upper case equivalent.\nIf |start| is omited, it defaults to 0. If |end| is omited, it defaults to\nthe length of |str|.\n@l\nNOTE: In R7RS, |string-upcase| accepts only one argument." :similar ())

(string-upcase! :type extended :synopsis "(string-upcase! str)\n(string-upcase! str start)\n(string-upcase! str start end)" :description "This is the in-place side-effecting variant of |string-upcase|." :similar ())

(string-foldcase :type r7rs-procedure :synopsis "(string-foldcase str)\n(string-foldcase str start)\n(string-foldcase str start end)" :description "Returns a string in which the Unicode simple case-folding algorithm has\nbeen applied on |str| between the |start| and |end| indices.\nIf |start| is omited, it defaults to 0. If |end| is omited, it defaults to\nthe length of |str|.\n@l\nNOTE: In R7RS, |string-foldcase| accepts only one argument." :similar ())

(string-foldcase! :type extended :synopsis "(string-foldcase! str)\n(string-foldcase! str start)\n(string-foldcase! str start end)" :description "This is the in-place side-effecting variant of |string-foldcase|." :similar ())

(string-titlecase :type extended :synopsis "(string-titlecase str)\n(string-titlecase str start)\n(string-titlecase str start end)" :description "This function returns a string.  For every character |c| in the\nselected range of |str|, if |c| is preceded by a cased character, it\nis downcased; otherwise it is titlecased. If |start| is omited, it\ndefaults to 0. If |end| is omited, it defaults to the length of |str|.\nNote that if a |start| index is specified, then the character preceding\n|s[start]| has no effect on the titlecase decision for character |s[start]|.\n@lisp\n(string-titlecase \"--capitalize tHIS sentence.\")\n         =>  \"--Capitalize This Sentence.\"\n(string-titlecase \"see Spot run. see Nix run.\")\n         =>  \"See Spot Run. See Nix Run.\"\n(string-titlecase \"3com makes routers.\")\n         =>  \"3Com Makes Routers.\"\n(string-titlecase \"greasy fried chicken\" 2)\n         => \"Easy Fried Chicken\"\n@end lisp" :similar ())

(string-titlecase! :type extended :synopsis "(string-titlecase! str)\n(string-titlecase! str start)\n(string-titlecase! str start end)" :description "This is the in-place side-effecting variant of |string-titlecase|." :similar ())

(string-blit! :type extended :synopsis "(string-blit! s1 s2 offset)" :description "This function places the characters of string |s2| in the string |s1|\nstarting at position |offset|. The result of |string-blit!| may modify\nthe string |s1|. Note that the characters of |s2| can be written after\nthe end of |s1| (in which case a new string is allocated).\n@lisp\n(string-blit! (make-string 6 #\\X) \"abc\" 2)\n              => \"XXabcX\"\n(string-blit! (make-string 10 #\\X) \"abc\" 5)\n              => \"XXXXXabcXX\"\n(string-blit! (make-string 6 #\\X) \"a\" 10)\n              => \"XXXXXX\\0\\0\\0\\0a\"\n@end lisp" :similar ())


;; Source file "struct.c"

(make-struct-type :type extended :synopsis "(make-struct-type name parent slots)" :description "This form which is more general than |define-struct| permits to define a\nnew structure type whose name is |name|. Parent is the structure\ntype from which is the new structure type is a subtype (or |#f| is the\nnew structure-type has no super type). |Slots| is the list of the slot\nnames which constitute the structure tpe.\n\nWhen a structure type is s subtype of a previous type, its slots are added\nto the ones of the super type." :similar ())

(struct-type? :type extended :synopsis "(struct-type? obj)" :description "Returns |#t| if |obj| is a structure type, otherwise returns |#f|.\n@lisp\n(let ((type (make-struct-type 'point #f '(x y))))\n  (struct-type? type))         => #t\n@end lisp" :similar ())

(struct-type-slots :type extended :synopsis "(struct-type-slots structype)" :description "Returns the slots of the structure type |structype| as a list.\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define circle (make-struct-type 'circle point '(r)))\n(struct-type-slots point)   => (x y)\n(struct-type-slots circle)  => (x y r)\n@end lisp" :similar ())

(struct-type-parent :type extended :synopsis "(struct-type-parent structype)" :description "Returns the super type of the structure type |structype|, if it exists\nor |#f| otherwise." :similar ())

(struct-type-name :type extended :synopsis "(struct-type-name structype)" :description "Returns the name associated to the structure type |structype|." :similar ())

(struct-type-change-writer! :type extended :synopsis "(struct-type-change-writer! structype proc)" :description "Change the default writer associated to structures of type |structype|\nto the |proc| procedure. The |proc| procedure must accept 2 arguments\n(the structure to write and the port wher the structure must be written\nin that order). The value returned by |struct-type-change-writer!| is the\nold writer associated to |structype|. To restore the standard structure\nwriter for |structype|, use the special value |#f|.\n\n@lisp\n(define point (make-struct-type 'point #f '(x y)))\n\n(struct-type-change-writer!\n  point\n  (lambda (s port)\n    (let ((type (struct-type s)))\n      (format port \"{~A\" (struct-type-name type))\n      ;; display the slots and their value\n      (for-each (lambda (x)\n       (format port \" ~A=~S\" x (struct-ref s x)))\n     (struct-type-slots type))\n      (format port \"}\"))))\n(display (make-struct point 1 2)) @print{} {point x=1 y=2}\n@end lisp" :similar ())

(make-struct :type extended :synopsis "(make-struct structype expr ...)" :description "Returns a newly allocated instance of the structure type |structype|,\nwhose slots are initialized to |expr| ... If fewer |expr| than the number of\ninstances are given to |make-struct|, the remaining slots are inialized with\nthe special *_void_* value." :similar ())

(struct? :type extended :synopsis "(struct? obj)" :description "Returns |#t| if |obj| is a structure, otherwise returns |#f|.\n@lisp\n(let* ((type (make-struct-type 'point #f '(x y)))\n       (inst (make-struct type 1 2)))\n  (struct? inst))         => #t\n@end lisp" :similar ())

(struct-type :type extended :synopsis "(struct-type s)" :description "Returns the structure type of the |s| structure" :similar ())

(struct-ref :type extended :synopsis "(struct-ref s slot-name)" :description "Returns the value associated to slot |slot-name| of the |s| structure.\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define circle (make-struct-type 'circle point '(r)))\n(define p (make-struct point 1 2))\n(define c (make-struct circle 10 20 30))\n(struct-ref p 'y) => 2\n(struct-ref c 'r) => 30\n@end lisp" :similar ())

(struct-set! :type extended :synopsis "(struct-set! s slot-name value)" :description "Stores value in the to slot |slot-name| of the |s| structure. The value\nreturned by |struct-set!| is *_void_*.\n\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define p (make-struct point 1 2))\n(struct-ref p 'x) => 1\n(struct-set! p 'x 0)\n(struct-ref p 'x) => 0\n@end lisp" :similar ())

(struct-is-a? :type extended :synopsis "(struct-is-a? s structype)" :description "Return a boolean that indicates if the structure |s| is of type |structype|.\nNote that if |s| is an instance of a subtype of _S_, it is considered\nalso as an instance of type _S_.\n\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define circle (make-struct-type 'circle point '(r)))\n(define p (make-struct point 1 2))\n(define c (make-struct circle 10 20 30))\n(struct-is-a? p point)   => #t\n(struct-is-a? c point)   => #t\n(struct-is-a? p circle)  => #f\n(struct-is-a? c circle)  => #t\n@end lisp" :similar ())

(struct->list :type extended :synopsis "(struct->list s)" :description "Returns the content of structure |s| as an A-list whose keys are the\nslots of the structure type of |s|.\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define p (make-struct point 1 2))\n(struct->list p) => ((x . 1) (y . 2))\n@end lisp" :similar ())


;; Source file "symbol.c"

(symbol? :type procedure :synopsis "(symbol? obj)" :description "Returns |#t| if obj is a symbol, otherwise returns |#f|.\n@lisp\n   (symbol? 'foo)          =>  #t\n   (symbol? (car '(a b)))  =>  #t\n   (symbol? \"bar\")         =>  #f\n   (symbol? 'nil)          =>  #t\n   (symbol? '())           =>  #f\n   (symbol? #f)            =>  #f\n   (symbol? :key)          =>  #f\n@end lisp" :similar ())

(symbol->string :type procedure :synopsis "(symbol->string string)" :description "Returns the name of |symbol| as a string. If the symbol was part of an\nobject returned as the value of a literal expression or by a call to the\n|read| procedure, and its name contains alphabetic characters, then the\nstring returned will contain characters in the implementation's preferred\nstandard case -- STklos prefers lower case. If the symbol was returned\nby |string->symbol|, the case of characters in the string returned will be\nthe same as the case in the string that was passed to |string->symbol|. It\nis an error to apply mutation procedures like |string-set!| to strings\nreturned by this procedure.\n@lisp\n   (symbol->string 'flying-fish)  =>  \"flying-fish\"\n   (symbol->string 'Martin)       =>  \"martin\"\n   (symbol->string (string->symbol \"Malvina\"))\n                                  =>  \"Malvina\"\n@end lisp" :similar ())

(string->symbol :type procedure :synopsis "(string->symbol string)" :description "Returns the symbol whose name is |string|. This procedure can create\nsymbols with names containing special characters or letters in the\nnon-standard case, but it is usually a bad idea to create such symbols\nbecause in some implementations of Scheme they cannot be read as themselves.\n\n@lisp\n   (eq? 'mISSISSIppi 'mississippi)                   =>  #t\n   (string->symbol \"mISSISSIppi\")                    =>  @pipemISSISSIppi@pipe\n   (eq? 'bitBlt (string->symbol \"bitBlt\"))           =>  #f\n   (eq? 'JollyWog\n        (string->symbol\n          (symbol->string 'JollyWog)))               =>  #t\n   (string=? \"K. Harper, M.D.\"\n             (symbol->string\n               (string->symbol \"K. Harper, M.D.\")))  =>  #t\n@end lisp" :similar ())

(string->uninterned-symbol :type extended :synopsis "(string->unterned-symbol string)" :description "Returns the symbol whose print name is made from the characters of\n|string|. This symbol is guaranteed to be _unique_ (i.e. not\n|eq?| to any other symbol):\n@lisp\n(let ((ua (string->uninterned-symbol \"a\")))\n  (list (eq? 'a ua)\n        (eqv? 'a ua)\n        (eq? ua (string->uninterned-symbol \"a\"))\n        (eqv? ua (string->uninterned-symbol \"a\"))))\n          => (#f #t #f #t)\n@end lisp" :similar ())


;; Source file "syntax.c"


;; Source file "system.c"

(temp-file-prefix :type extended :synopsis "(temp-file-prefix)\n(temp-file-prefix value)" :description "This parameter object permits to change the default prefix used to build\ntemporary file name. Its default value is built using the |TMPDIR|\nenvironment variable (if it is defined) and the current process ID.\nIf a value is provided, it must be a string designating a valid prefix path.\n@l\nThis parameter object is also defined in {{link-srfi 170}}." :similar ())

(winify-file-name :type extended :synopsis "(winify-file-name fn)" :description "On Win32 system, when compiled with the Cygwin environment,\nfile names are internally represented in a POSIX-like internal form.\n|Winify-file-bame| permits to obtain back the Win32 name of an interned\nfile name\n@lisp\n(winify-file-name \"/tmp\")\n    => \"C:\\\\cygwin\\\\tmp\"\n(list (getcwd) (winify-file-name (getcwd)))\n    => (\"//saxo/homes/eg/Projects/STklos\"\n        \"\\\\\\\\saxo\\\\homes\\\\eg\\\\Projects\\\\STklos\")\n@end lisp" :similar ())

(posixify-file-name :type extended :synopsis "(posixify-file-name fn)" :description "On Win32 system, when compiled with the Cygwin environment,\nfile names are internally represented in a POSIX-like internal form.\n|posixify-file-bame| permits to obtain the interned file name from\nits external form.\nfile name\n@lisp\n(posixify-file-name \"C:\\\\cygwin\\\\tmp\")\n       => \"/tmp\"\n@end lisp" :similar ())

(expand-file-name :type extended :synopsis "(expand-file-name path)" :description "|Expand-file-name| expands the filename given in |path| to\nan absolute path.\n@lisp\n  ;; Current directory is ~eg/stklos (i.e. /users/eg/stklos)\n  (expand-file-name \"..\")            => \"/users/eg\"\n  (expand-file-name \"~eg/../eg/bin\") => \"/users/eg/bin\"\n  (expand-file-name \"~/stklos)\"      => \"/users/eg/stk\"\n@end lisp" :similar ())

(canonical-file-name :type extended :synopsis "(canonical-file-name path)" :description "Expands all symbolic links in |path| and returns its canonicalized\nabsolute path name. The resulting path does not have symbolic links.\nIf |path| doesn't designate a valid path name, |canonical-file-name|\nreturns |#f|." :similar ())

(getcwd :type extended :synopsis "(getcwd)" :description "Returns a string containing the current working directory." :similar ())

(chdir :type extended :synopsis "(chdir dir)" :description "Changes the current directory to the directory given in string |dir|." :similar ())

(create-directory :type extended :synopsis "(create-directory dir)\n(create-directory dir permissions)" :description "Create a directory with name |dir|. If |permissions| is omitted, it\ndefaults to #o775 (masked by the current umask).\n\nNOTE: This function is also defined in {{link-srfi 170}}. The old name\n|make-directory| is deprecated." :similar (make-directory))

(make-directory :see create-directory)
(remove-directory :type extended :synopsis "(delete-directory dir)\n(remove-directory dir)" :description "Delete the directory with name |dir|.\n@l\nNOTE: This function is also defined in {{link-srfi 170}}. The name\n|remove-directory| is kept for compatibility." :similar (delete-directory))

(delete-directory :see remove-directory)
(getpid :type extended :synopsis "(getpid)" :description "Returns the system process number of the current program (i.e. the\nUnix _PID_ as an integer)." :similar ())

(system :type extended :synopsis "(system string)" :description "Sends the given |string| to the system shell |/bin/sh|. The result of\n|system| is the integer status code the shell returns." :similar ())

(file-is-executable? :type extended :synopsis "(file-is-directory?  string)\n(file-is-regular?    string)\n(file-is-readable?   string)\n(file-is-writable?   string)\n(file-is-executable? string)" :description "Returns |#t| if the predicate is true for the path name given in\n|string|; returns |#f| otherwise (or if |string| denotes a file\nwhich does not exist)." :similar (file-is-readable? file-is-writable? file-is-regular? file-is-directory?))

(file-is-readable? :see file-is-executable?)
(file-is-writable? :see file-is-executable?)
(file-is-regular? :see file-is-executable?)
(file-is-directory? :see file-is-executable?)
(file-exists? :type r7rs-procedure :synopsis "(file-exists? string)" :description "Returns |#t| if the path name given in |string| denotes an existing file;\nreturns |#f| otherwise." :similar ())

(file-size :type extended :synopsis "(file-size string)" :description "Returns the size of the file whose path name is given in\n|string|. If |string| denotes a file which does not exist,\n|file-size| returns |#f|." :similar ())

(glob :type extended :synopsis "(glob pattern ...)" :description "|Glob| performs file name ``globbing'' in a fashion similar to the\ncsh shell. |Glob| returns a list of the filenames that match at least\none of |pattern| arguments.  The |pattern| arguments may contain\nthe following special characters:\n\n- |?| Matches any single character.\n- |*| Matches any sequence of zero or more characters.\n- |\\[chars\\]| Matches any single character in |chars|.\n  If chars contains a sequence of the form |a-b| then any character\n  between |a| and |b| (inclusive) will match.\n- |\\x| Matches the character |x|.\n- |{a,b,...}| Matches any of the strings |a|, |b|, etc.\n)\n\nAs with csh, a '.' at the beginning of a file's name or just after\na '/' must be matched explicitly or with a |@{@}| construct.\nIn addition, all '/' characters must be matched explicitly.\n\nIf the first character in a pattern is '~' then it refers to\nthe home directory of the user whose name follows the '~'.\nIf the '~' is followed immediately by '/' then the value of\nthe environment variable HOME is used.\n\n|Glob| differs from csh globbing in two ways:\n\n1. it does not  sort its result list (use the |sort| procedure\nif you want the list  sorted).\n2. |glob| only returns the names of files that actually exist;\n   in csh no check for existence is made unless a pattern contains a\n   |?|, |*|, or |[]| construct." :similar ())

(remove-file :type r7rs-procedure :synopsis "(delete-file string)" :description "Removes the file whose path name is given in |string|.\nThe result of |delete-file| is *_void_*.\n@l\nThis function is also called |remove-file| for compatibility\nreasons. ,(index \"remove-file\")" :similar (delete-file))

(delete-file :see remove-file)
(rename-file :type extended :synopsis "(rename-file string1 string2)" :description "Renames the file whose path-name is |string1| to a file whose path-name is\n|string2|. The result of |rename-file| is *_void_*.\n@l\nThis function is also defined in {{link-srfi 170}}." :similar ())

(directory-files :type extended :synopsis "(directory-files path)\n(directory-files path dotfiles?)" :description "Returns the list of the files in the directory |path|. The |dotfiles?| flag\n(default |#f|) causes files beginning with ,(q \".\") to be included in the list.\nRegardless of the value of |dotfiles?|, the two files ,(q \".\") and ,(q \"..\")\nare never  returned.\n@l\nThis function is also defined in {{link-srfi 170}}." :similar ())

(copy-file :type extended :synopsis "(copy-file string1 string2)" :description "Copies the file whose path-name is |string1| to a file whose path-name is\n|string2|. If the file |string2| already exists, its content prior\nthe call to |copy-file| is lost. The result of |copy-file| is *_void_*." :similar ())

(create-temp-file :type extended :synopsis "(create-temp-file)\n(create-temp-file prefix)" :description "Creates a new temporary file and returns two values: its name and an opened\nfile port on it. The optional argument specifies the filename prefix\nto use, and defaults to the result of invoking |temp-file-prefix|.\nThe returned file port is opened in read/write mode. It ensures that\nthe name cannot be reused by another process before being used\nin the program that calls |create-temp-file|.\nNote, that if the opened port is not used, it can be closed and collected\nby the GC.\n@lisp\n(let-values (((name port) (create-temp-file)))\n  (let ((msg (format \"Name: ~s\\n\" name)))\n    (display msg)\n    (display msg port)\n    (close-port port)))     => prints the name of the temp. file on the\n                               current output port and in the file itself.\n@end lisp\n\nNOTE: This function is also defined in {{link-srfi 170}}.However,\nin SRFI-170, |create-temp-file| returns only the name of the temporary file.\n\nNOTE: |temporary-file-name| is another name for this function." :similar (temporary-file-name))

(temporary-file-name :see create-temp-file)
(create-temp-directory :type extended :synopsis "(create-temp-directory)\n(create-temp-directory prefix)" :description "Creates a new temporary directory and returns its name as a string.\nThe optional argument specifies the filename prefix to use, and\ndefaults to the result of invoking |temp-file-prefix|." :similar ())

(register-exit-function! :type extended :synopsis "(register-exit-function! proc)" :description "This function registers |proc| as an exit function. This function will\nbe called when the program exits. When called, |proc| will be passed one\nparmater which is the status given to the |exit| function (or 0 if the\nprograme terminates normally). The result of  |register-exit-function!|\nis undefined.\n@lisp\n(let* ((tmp (temporary-file-name))\n       (out (open-output-file tmp)))\n  (register-exit-function! (lambda (n)\n                             (when (zero? n)\n                               (delete-file tmp))))\n  out)\n@end lisp" :similar ())

(exit :type extended :synopsis "(exit)\n(exit ret-code)" :description "Exits the program with the specified integer return code. If |ret-code|\nis omitted, the program terminates with a return code of 0.\nIf  program has registered exit functions with |register-exit-function!|,\nthey are called (in an order which is the reverse of their call order).\n@l\nNOTE: The {{stklos}} |exit| primitive accepts also an\ninteger value as parameter (R7RS accepts only a boolean)." :similar ())

(emergency-exit :type extended :synopsis "(emergency-exit)\n(emergency-exit ret-code)" :description "Terminates the program without running any outstanding\ndynamic-wind _after_ procedures and communicates an exit\nvalue to the operating system in the same manner as |exit|.\n@l\nNOTE: The {{stklos}} |emergency-exit| primitive accepts also an\ninteger value as parameter (R7RS accepts only a boolean)." :similar ())

(machine-type :type extended :synopsis "(machine-type)" :description "Returns a string identifying the kind of machine which is running the\nprogram. The result string is of the form\n|[os-name]-[os-version]-[cpu-architecture]|." :similar ())

(date :type extended :synopsis "(date)" :description "Returns the current date in a string." :similar ())

(clock :type extended :synopsis "(clock)" :description "Returns an approximation of processor time, in milliseconds, used so far by the\nprogram." :similar ())

(current-seconds :type extended :synopsis "(current-seconds)" :description "Returns the time since the Epoch (that is 00:00:00 UTC, January 1, 1970),\nmeasured in seconds in the Coordinated Universal Time (UTC) scale.\n\nNOTE: This {{stklos}} function should not be confused with\nthe R7RS  primitive |current-second| which returns an inexact number\nand whose result is expressed using  the International Atomic Time\ninstead of UTC.\n" :similar ())

(current-second :type r7rs-procedure :synopsis "(current-second)" :description "Returns an inexact number representing the current time on the\nInternational Atomic Time (TAI) scale.  The value 0.0 represents\nmidnight on January 1, 1970 TAI (equivalent to ten seconds before\nmidnight Universal Time) and the value 1.0 represents one TAI\nsecond later." :similar ())

(sleep :type extended :synopsis "(sleep n)" :description "Suspend the execution of the program for at |ms| milliseconds. Note that due\nto system clock resolution, the pause may be a little bit longer. If a\nsignal arrives during the pause, the execution may be resumed.\n" :similar ())

(local-timezone-offset :type extended :synopsis "(local-timezone-offset)" :description "Returns the local timezone offset, in seconds.\n\nFor example, for GMT+2 it will be |2 * 60 * 60| = |7200|\n\n@lisp\n(local-timezone-offset) => 0        ;; for GMT\n(local-timezone-offset) => 7200     ;; for GMT+2\n(local-timezone-offset) => -10800   ;; for GMT-3\n@end lisp\n\nThe timezone is searched for in the environment variable |TZ|. If this\nvariable does not appear in the environment, the system timezone is used." :similar ())

(date->seconds :type extended :synopsis "(date->seconds d)" :description "Convert the date |d| to the number of seconds since the _Epoch_,\n1970-01-01 00:00:00 +0000 (UTC).\n\n@lisp\n(date->seconds (make-date 0 37 53 1 26 10 2012 0))   => 1351216417.0\n@end lisp" :similar ())

(running-os :type extended :synopsis "(running-os)" :description "Returns the name of the underlying Operating System which is running\nthe program.\nThe value returned by |runnin-os| is a symbol. For now, this procedure\nreturns either |unix|, |android|, |windows|, or |cygwin-windows|." :similar ())

(getenv :type extended :synopsis "(getenv str)\n(getenv)" :description "Looks for the environment variable named |str| and returns its\nvalue as a string, if it exists. Otherwise, |getenv| returns |#f|.\nIf |getenv| is called without parameter, it returns the list of\nall the environment variables accessible from the program as an\nA-list.\n@lisp\n(getenv \"SHELL\")\n     => \"/bin/zsh\"\n(getenv)\n     => ((\"TERM\" . \"xterm\") (\"PATH\" . \"/bin:/usr/bin\") ...)\n@end lisp" :similar ())

(setenv! :type extended :synopsis "(setenv! var value)" :description "Sets the environment variable |var| to |value|. |Var| and\n|value| must be strings. The result of |setenv!| is *_void_*." :similar ())

(unsetenv! :type extended :synopsis "(unsetenv! var)" :description "Unsets the environment variable |var|. |Var| must be a string.\nThe result of |unsetenv!| is *_void_*." :similar ())

(hostname :type extended :synopsis "(hostname)" :description "Return the  host name of the current processor as a string." :similar ())

(pause :type extended :synopsis "(pause)" :description "" :similar ())


;; Source file "utf8.c"


;; Source file "uvector.c"

(bytevector-copy :type r7rs-procedure :synopsis "(bytevector-copy bytevector)\n(bytevector-copy bytevector start)\n(bytevector-copy bytevector start end)" :description "Returns a newly allocated bytevector containing the bytes in |bytevector|\nbetween |start| and |end|.\n@lisp\n(define a #u8(1 2 3 4 5))\n(bytevector-copy a 2 4))       =>  #u8(3 4)\n@end lisp" :similar ())

(bytevector-append :type procedure :synopsis "(bytevector-append bytevector ...)" :description "Returns a newly allocated bytevector whose elements are\nthe concatenation of the elements in the given bytevectors.\n@lisp\n(bytevector-append #u8(0 1 2) #u8(3 4 5))\n                    =>  #u8(0 1 2 3 4 5)\n@end lisp" :similar ())

(string->utf8 :type r7rs-procedure :synopsis "(utf8->string bytevector)\n(utf8->string bytevector start)\n(utf8->string bytevector start end)\n(string->utf8 string)\n(string->utf8 string start)\n(string->utf8 string start end)" :description "These procedures translate between strings and bytevectors\nthat encode those strings using the UTF-8 encoding.\nThe |utf8->string| procedure decodes the bytes of\na bytevector between |start| and |end| and returns the\ncorresponding string; the |string->utf8| procedure encodes the\ncharacters of a string between |start| and |end| and returns\nthe corresponding bytevector.\n\nIt is an error for |bytevector| to contain invalid UTF-8 byte\nsequences.\n@lisp\n(utf8->string #u8(#x41))   => \"A\"\n(string->utf8 \"Î»\")         => #u8((#xce #xbb)\n@end lisp" :similar (utf8->string))

(utf8->string :see string->utf8)

;; Source file "vector.c"

(vector? :type procedure :synopsis "(vector? obj)" :description "Returns |#t| if |obj| is a vector, otherwise returns |#f|." :similar ())

(make-vector :type procedure :synopsis "(make-vector k)\n(make-vector k fill)" :description "Returns a newly allocated vector of |k| elements. If a second argument is\ngiven, then each element is initialized to |fill|. Otherwise, the initial\ncontents of each element is unspecified." :similar ())

(vector :type procedure :synopsis "(vector obj ...)" :description "Returns a newly allocated vector whose elements contain the given arguments.\nAnalogous to |list|.\n\n@lisp\n(vector 'a 'b 'c)               =>  #(a b c)\n@end lisp" :similar ())

(vector-length :type procedure :synopsis "(vector-length vector)" :description "Returns the number of elements in |vector| as an exact integer." :similar ())

(vector-ref :type procedure :synopsis "(vector-ref vector k)" :description "|k| must be a valid index of |vector|. |Vector-ref| returns the contents of\nelement |k| of vector.\n@lisp\n(vector-ref '#(1 1 2 3 5 8 13 21)\n            5)                                    =>  8\n(vector-ref '#(1 1 2 3 5 8 13 21)\n            (let ((i (round (* 2 (acos -1)))))\n              (if (inexact? i)\n                  (inexact->exact i)\n                  i)))                            => 13\n@end lisp" :similar ())

(vector-set! :type procedure :synopsis "(vector-set! vector k obj)" :description "|k| must be a valid index of |vector|. |Vector-set!| stores |obj| in element\n|k| of |vector|. The value returned by |vector-set!| is *_void_*.\n\n@lisp\n(let ((vec (vector 0 '(2 2 2 2) \"Anna\")))\n  (vector-set! vec 1 '(\"Sue\" \"Sue\"))\n  vec)      =>  #(0 (\"Sue\" \"Sue\") \"Anna\")\n\n(vector-set! '#(0 1 2) 1 \"doe\")  =>  error  ; constant vector\n@end lisp" :similar ())

(list->vector :type r57rs-procedure :synopsis "(vector->list vector)\n(vector->list vector start)\n(vector->list vector start end)\n(list->vector list)" :description "|Vector->list| returns a newly allocated list of the objects contained in\nthe elements of |vector| between start an end. |List->vector| returns a\nnewly created vector initialized to the elements of the list |list|.\n\nIn both procedures, order is preserved.\n\n@lisp\n(vector->list '#(dah dah didah))     =>  (dah dah didah)\n(vector->list '#(dah dah didah) 1 2) =>  (dah)\n(list->vector '(dididit dah))        =>  #(dididit dah)\n@end lisp\n\nNOTE: The R5RS version of |vector->list| accepts only one\nparameter." :similar (vector->list))

(vector->list :see list->vector)
(vector-copy :type r57rs-procedure :synopsis "(vector-copy v)\n(vector-copy v start)\n(vector-copy v start stop)" :description "Return a newly allocated copy of the elements of the given\nvector between |start| and |end| . The elements of the new\nvector are the same (in the sense of eqv?) as the elements\nof the old.\n\nNote that, if |v| is a constant vector, its copy is not constant.\n\n@lisp\n(define a #(1 8 2 8))         ; a is immutable\n(define b (vector-copy a))    ; b is mutable\n(vector-set! b 0 3)\nb                            => #(3 8 2 8)\n(define c (vector-copy b 1 3))\nc                            => #(8 2)\n@end lisp" :similar ())

(vector-append :type procedure :synopsis "(vector-append vector ...)" :description "Returns a newly allocated vector whose elements are the\nconcatenation of the elements of the given vectors.\n\n@lisp\n(vector-append #(a b c) #(d e f)) => #(a b c d e f)\n@end lisp" :similar ())

(vector-fill! :type r57rs-procedure :synopsis "(vector-fill! vector fill)\n(vector-fill! vector fill start)\n(vector-fill! vector fill start end)" :description "Stores |fill| in every element of |vector| between |start| and |end|.\n\nNOTE: The R5RS version of |vector-fill!| accepts only one\nparameter." :similar ())

(vector-resize :type extended :synopsis "(vector-resize v size)\n(vector-resize v size fill)" :description "Returns a copy of v of the given |size|. If |size| is greater\nthan the vector size of |v|, the contents of the newly allocated vector cells\nis  set to the value of |fill|. If |fill| is omitted the content of the\nnew cells is *_void_*." :similar ())

(vector-mutable? :type extended :synopsis "(vector-mutable? obj)" :description "Returns |#t| if |obj| is a mutable vector, otherwise returns |#f|.\n@lisp\n(vector-mutable? '#(1 2 a b))            => #f\n(vector-mutable? (vector-copy '#(1 2)))  => #t\n(vector-mutable? (vector 1 2 3))         => #t\n(vector-mutable? 12)                     => #f\n@end lisp" :similar ())

(sort :type extended :synopsis "(sort obj predicate)" :description "|Obj| must be a list or a vector. |Sort| returns a copy of |obj| sorted\naccording to |predicate|. |Predicate| must be a procedure which takes\ntwo arguments and returns a true value if the first argument is strictly\n``before'' the second.\n\n@lisp\n(sort '(1 2 -4 12 9 -1 2 3) <)\n               => (-4 -1 1 2 2 3 9 12)\n(sort '#(\"one\" \"two\" \"three\" \"four\")\n      (lambda (x y) (> (string-length x) (string-length y))))\n               => '#(\"three\" \"four\" \"one\" \"two\")\n@end lisp" :similar ())


;; Source file "vm.c"

(apply :type procedure :synopsis "(apply proc arg1 ... args)" :description "|Proc| must be a procedure and |args| must be a list. Calls |proc| with the\nelements of the list\n@lisp\n(append (list arg1 ...) args)\n@end lisp\nas the actual arguments.\n@lisp\n(apply + (list 3 4))              =>  7\n\n(define compose\n  (lambda (f g)\n     (lambda args\n       (f (apply g args)))))\n\n((compose sqrt *) 12 75)          =>  30\n@end lisp" :similar ())

(values :type procedure :synopsis "(values obj ...)" :description "Delivers all of its arguments to its continuation.\n\nNOTE:  R5RS imposes to use multiple values in the context\nof a |call-with-values|. In STklos, if |values| is not used with\n|call-with-values|, only the first value is used (i.e. others values are\n_ignored_)).\n" :similar ())

(current-exception-handler :type extended :synopsis "(current-exception-handler)" :description "Returns the current exception handler. This procedure is defined in\n,(link-srfi 18)." :similar ())


;; Source file "vport.c"

(open-input-virtual :type extended :synopsis "(open-input-virtual :key  (read-char #f) (ready? #f) (eof? #f) (close #f))" :description "Returns a virtual port using the |read-char| procedure to read a\ncharacter from the port, |ready?| to know if there is any data to\nread from the port, |eof?| to know if the end of file is reached\non the port and finally |close| to close the port. All these\nprocedure takes one parameter which is the port from which the input\ntakes place.  |Open-input-virtual| accepts also the special value\n|#f| for the I/O procedures with the following conventions:\n\n- if |read-char| or |eof?| is |#f|, any attempt to read\n  the virtual port will return an eof object;\n\n- if |ready?| is |#f|, the file is always  ready for reading;\n\n- if |close| is |#f|, no action is done when the port is closed.\n\nHereafter is a possible implementation of |open-input-string|\nusing virtual ports:\n@lisp\n(define (open-input-string str)\n  (let ((index 0))\n    (open-input-virtual\n       :read-char (lambda (p)\n                    ;; test on eof is already done by the system\n                    (let ((res (string-ref str index)))\n                      (set! index (+ index 1))\n                      res))\n       :eof? (lambda (p) (>= index (string-length str))))))\n@end lisp" :similar ())

(open-output-virtual :type extended :synopsis "(open-output-virtual :key  (write-char #f) (write-string #f) (flush #f) (close #f))" :description "Returns a virtual port using the |write-char| procedure to write a\ncharacter to the port, |write-string| to write a string to the port,\n|flush| to (eventuelly) flush the characters on the port and finally\n|close|to close the port. |Write-char| takes two parameters: a character and\nthe port to which the output must be done. |write-string| takes two\nparameters: a string and a port. |Flush| and |Close| take one\nparameter which is the port on which the action must be done.\n|Open-output-virtual| accepts also the special value |#f|\nfor the I/O procedures. If a procedure is |#f| nothing is done\non the corresponding action.\n\nHereafter is a (very inefficient) implementation of a variant of\n|open-output-string| using virtual ports. The value of the output\nstring is printed when the port is closed:\n@lisp\n(define (open-output-string)\n  (let ((str \"\"))\n    (open-output-virtual\n       :write-char (lambda (c p)\n                     (set! str (string-append str (string c))))\n       :write-string (lambda (s p)\n                       (set! str (string-append str s)))\n       :close (lambda (p) (write str) (newline)))))\n@end lisp\n\nNOTE: |write-string| is mainly used for writing strings and is\ngenerally more efficient than writing the string character by character.\nHowever, if |write-string| is not provided, strings are printed with\n|write-char|.  On the other hand, if |write-char| is absent,\ncharacters are written by successive allocation of one character strings.\n\nHereafter is another example: a virtual file port where all characters\nare converted to upper case:\n@lisp\n(define (open-output-uppercase-file file)\n  (let ((out (open-file file \"w\")))\n    (and out\n         (open-output-virtual\n             :write-string (lambda (s p)\n                             (display (string-upper s) out))\n             :close (lambda (p)\n                      (close-port out))))))\n@end lisp" :similar ())

(output-virtual-port? :type extended :synopsis "(input-virtual-port? obj)\n(output-virtual-port? obj)" :description "Returns |#t| if |obj| is a virtual input port or a virtual output port\nrespectively, otherwise returns |#f|." :similar (input-virtual-port?))

(input-virtual-port? :see output-virtual-port?)

;; Source file "thread-common.c"

(current-thread :type extended :synopsis "(current-thread)" :description "Returns the current thread.\n@lisp\n(eq? (current-thread) (current-thread))  =>  #t\n@end lisp" :similar ())

(thread? :type extended :synopsis "(thread? obj)" :description "Returns |#t| if |obj| is a thread, otherwise returns |#f|.\n@lisp\n(thread? (current-thread))  => #t\n(thread? 'foo)              => #f\n@end lisp" :similar ())

(thread-name :type extended :synopsis "(thread-name thread)" :description "Returns the name of the |thread|.\n@lisp\n(thread-name (make-thread (lambda () #f) 'foo))  =>  foo\n@end lisp" :similar ())

(thread-stack-size :type extended :synopsis "(thread-stack-size thread)" :description "Returns the allocated stack size for |thread|.\n@lisp\n(thread-stack-size (make-thread (lambda () #f) 'foo 2000)) => 2000\n@end lisp\n\nNote that this procedure is not present in {{quick-link-srfi 18}}." :similar ())

(thread-specific :type extended :synopsis "(thread-specific thread)" :description "Returns the content of the |thread|'s specific field." :similar ())

(thread-specific-set! :type extended :synopsis "(thread-specific-set! thread)" :description "Stores |obj| into the |thread|'s specific field. |Thread-specific-set!|\nreturns an unspecified value.\n@lisp\n(thread-specific-set! (current-thread) \"hello\")\n           =>  unspecified\n(thread-specific (current-thread))\n           =>  \"hello\"\n@end lisp" :similar ())

(thread-start! :type extended :synopsis "(thread-start! thread)" :description "Makes |thread| runnable. The |thread| must be a new thread.\n|Thread-start!| returns the thread.\n@lisp\n(let ((t (thread-start! (make-thread\n                           (lambda () (write 'a))))))\n   (write 'b)\n   (thread-join! t))       =>  unspecified\n                               after writing ab or ba\n@end lisp" :similar ())


;; Source file "thread-pthreads.c"

(thread-yield! :type extended :synopsis "(thread-yield!)" :description "The current thread exits the running state as if its quantum had\nexpired. |Thread-yield!| returns an unspecified value." :similar ())

(thread-terminate! :type extended :synopsis "(thread-terminate! thread)" :description "Causes an abnormal termination of the |thread|. If the |thread| is not\nalready terminated, all mutexes owned by the |thread| become\nunlocked/abandoned and a \"terminated thread exception\" object is stored\nin the thread's end-exception field. If |thread| is the current thread,\n|thread-terminate!| does not return. Otherwise, |thread-terminate!|\nreturns an unspecified value; the termination of the thread will occur\nbefore |thread-terminate!| returns.\n\n[NOTE]\n====\n-  This operation must be used carefully because it terminates a thread\n   abruptly and it is impossible for that thread to perform any kind of\n   cleanup. This may be a problem if the thread is in the middle of a\n   critical section where some structure has been put in an inconsistent\n   state. However, another thread attempting to enter this critical section\n   will raise an \"abandoned mutex exception\" because the mutex is\n   unlocked/abandoned.\n-  On _Android_, |thread-terminate!| can be used only to terminate the\n   current thread.  Trying to kill another thread produces an error.\n====" :similar ())

(thread-join! :type extended :synopsis "(thread-join! thread)\n(thread-join! thread timeout)\n(thread-join! thread timeout timeout-val)" :description "The current thread waits until the |thread| terminates (normally or not)\nor until the timeout is reached if |timeout| is supplied.\nIf the timeout is reached, |thread-join!| returns |timeout-val| if it is\nsupplied, otherwise a \"join timeout exception\" is raised.\nIf the |thread| terminated normally, the content of the end-result\nfield is returned, otherwise the content of the end-exception field\nis raised.\n@lisp\n(let ((t (thread-start! (make-thread (lambda ()\n                                       (expt 2 100))))))\n  (thread-sleep! 1)\n  (thread-join! t)) => 1267650600228229401496703205376\n@end lisp" :similar ())

(thread-sleep! :type extended :synopsis "(thread-sleep! timeout)" :description "The current thread waits until the |timeout| is reached. This blocks the\nthread only if timeout represents a point in the future. It is an error\nfor timeout to be |#f|. |Thread-sleep!| returns an unspecified value." :similar ())


;; Source file "mutex-common.c"

(make-mutex :type extended :synopsis "(make-mutex)\n(make-mutex name)" :description "Returns a new mutex in the unlocked/not-abandoned state. The optional |name|\nis an arbitrary Scheme object which identifies the mutex\n(useful for debugging); it defaults to an unspecified value.\nThe mutex's specific field is set to an unspecified value." :similar ())

(mutex? :type extended :synopsis "(mutex? obj)" :description "Returns |#t| if obj is a mutex, otherwise returns |#f|." :similar ())

(mutex-name :type extended :synopsis "(mutex-name mutex)" :description "Returns the name of the |mutex|.\n@lisp\n(mutex-name (make-mutex 'foo))  =>  foo\n@end lisp" :similar ())

(mutex-specific :type extended :synopsis "(mutex-specific mutex)" :description "Returns the content of the |mutex|'s specific field." :similar ())

(mutex-specific-set! :type extended :synopsis "(mutex-specific! mutex obj)" :description "Stores |obj| into the |mutex|'s specific field and eturns an unspecified value.\n@lisp\n(define m (make-mutex))\n(mutex-specific-set! m \"hello\")  =>  unspecified\n(mutex-specific m)               =>  \"hello\"\n\n(define (mutex-lock-recursively! mutex)\n  (if (eq? (mutex-state mutex) (current-thread))\n      (let ((n (mutex-specific mutex)))\n        (mutex-specific-set! mutex (+ n 1)))\n      (begin\n        (mutex-lock! mutex)\n        (mutex-specific-set! mutex 0))))\n\n(define (mutex-unlock-recursively! mutex)\n  (let ((n (mutex-specific mutex)))\n    (if (= n 0)\n        (mutex-unlock! mutex)\n        (mutex-specific-set! mutex (- n 1)))))\n@end lisp" :similar ())

(make-condition-variable :type extended :synopsis "(make-conditon-variable)\n(make-conditon-variable name)" :description "Returns a new empty condition variable. The optional |name| is an arbitrary\nScheme object which identifies the condition variable (useful for debugging);\nit defaults to an unspecified value. The condition variable's specific\nfield is set to an unspecified value." :similar ())

(condition-variable? :type extended :synopsis "(conditon-variable? obj)" :description "Returns |#t| if |obj| is a condition variable, otherwise returns |#f|." :similar ())

(condition-variable-name :type extended :synopsis "(conditon-variable-name conditon-variable)" :description "Returns the name of the |condition-variable|." :similar ())

(condition-variable-specific :type extended :synopsis "(conditon-variable-specific conditon-variable)" :description "Returns the content of the |condition-variable|'s specific field." :similar ())

(condition-variable-specific-set! :type extended :synopsis "(conditon-variable-specific-set! conditon-variable obj)" :description "Stores |obj| into the |condition-variable|'s specific field." :similar ())


;; Source file "mutex-pthreads.c"

(mutex-state :type extended :synopsis "(mutex-state mutex)" :description "Returns information about the state of the |mutex|. The possible results\nare:\n\n * a thread *T*: the mutex is in the locked/owned state and\n   thread *T* is the owner of the mutex\n * the symbol *not-owned*: the mutex is in the locked/not-owned\n   state\n * the symbol *abandoned*: the mutex is in the unlocked/abandoned\n   state\n * the symbol *not-abandoned*: the mutex is in the\n    unlocked/not-abandoned state\n\n@lisp\n(mutex-state (make-mutex))  =>  not-abandoned\n\n(define (thread-alive? thread)\n  (let ((mutex (make-mutex)))\n    (mutex-lock! mutex #f thread)\n    (let ((state (mutex-state mutex)))\n      (mutex-unlock! mutex) ; avoid space leak\n      (eq? state thread))))\n@end lisp" :similar ())

(mutex-lock! :type extended :synopsis "(mutex-lock! mutex)\n(mutex-lock! mutex timeout)\n(mutex-lock! mutex timeout thread)" :description "If the |mutex| is currently locked, the current thread waits until the\n|mutex| is unlocked, or until the timeout is reached if |timeout| is supplied.\nIf the |timeout| is reached, |mutex-lock!| returns |#f|.\nOtherwise, the state of the mutex is changed as follows:\n\n * if thread is |#f| the mutex becomes _locked/not-owned_,\n * otherwise, let T be thread (or the current thread if thread\n   is not supplied),\n ** if T is terminated the mutex becomes _unlocked/abandoned_,\n ** otherwise mutex becomes _locked/owned_ with T as the owner.\n\nAfter changing the state of the mutex, an \"abandoned mutex exception\" is\nraised if the mutex was unlocked/abandoned before the state change,\notherwise |mutex-lock!| returns |#t|.\n@lisp\n(define (sleep! timeout)\n  ;; an alternate implementation of thread-sleep!\n  (let ((m (make-mutex)))\n  (mutex-lock! m #f #f)\n  (mutex-lock! m timeout #f)))\n@end lisp" :similar ())

(mutex-unlock! :type extended :synopsis "(mutex-unlock! mutex)\n(mutex-unlock! mutex condition-variable)\n(mutex-unlock! mutex condition-variable timeout)" :description "Unlocks the |mutex| by making it unlocked/not-abandoned. It is not an error\nto unlock an unlocked mutex and a mutex that is owned by any thread.\nIf |condition-variable| is supplied, the current thread is blocked and\nadded to the |condition-variable| before unlocking |mutex|; the thread\ncan unblock at any time but no later than when an appropriate call to\n|condition-variable-signal!| or |condition-variable-broadcast!| is\nperformed (see below), and no later than the timeout (if timeout is\nsupplied). If there are threads waiting to lock this mutex, the scheduler\nselects a thread, the |mutex| becomes locked/owned or locked/not-owned,\nand the thread is unblocked. |mutex-unlock!| returns |#f| when the\n|timeout| is reached, otherwise it returns |#t|." :similar ())

(condition-variable-signal! :type extended :synopsis "(condition-variable-signal! condition-variable)" :description "If there are threads blocked on the |condition-variable|, the scheduler\nselects a thread and unblocks it. |Condition-variable-signal!|  returns\nan unspecified value." :similar ())

(condition-variable-broadcast! :type extended :synopsis "(condition-variable-broadcast! condition-variable)" :description "Unblocks all the threads blocked on the |condition-variable|.\n|Condition-variable-broadcast!| returns an unspecified value." :similar ())

;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Sat Mar 25 05:01:47 2023


;; Source file "assembler.stk"

(disassemble :type extended :synopsis "(disassemble proc)\n(disassemble proc port)" :description "This function prints on the given port (by default the current output\nport) the instructions of procedure |proc|. The printed code uses an\n_ad-hoc_ instruction set that should be quite understandable.\n\n@lisp\n(define (fact n)\n  (if (< n 2)\n      1\n      (* n (fact (- n 1)))))\n@end lisp\n\nThe call `(disassemble fact)` will produce the following output:\n\n@lisp\n   000:  LOCAL-REF0-PUSH\n   001:  SMALL-INT            2\n   003:  JUMP-NUMGE           2  ;; ==> 007\n   005:  IM-ONE\n   006:  RETURN\n   007:  LOCAL-REF0-PUSH\n   008:  PREPARE-CALL\n   009:  LOCAL-REF0\n   010:  IN-SINT-ADD2         -1\n   012:  PUSH-GREF-INVOKE     0 1\n   015:  IN-MUL2\n   016:  RETURN\n@end lisp\n\nIMPORTANT: The code of a procedure may be patched after the first execution\nof |proc| to optimize it.\n\nIf |proc| is an anonymous function, you can use the special\nnotation `#pxxx` to disassemble it:\n* @lisp\n(disassemble #p7fee1dd82f80)  ;; (address-of (lambda() 42))\n\n      000:  SMALL-INT            42\n      002:  RETURN\n@end lisp" :similar ())

(disassemble-expr :type extended :synopsis "(disassemble-expr sexpr)\n(disassemble-expr sexpr show-consts)\n(disassemble-expr sexpr show-consts port)" :description "This function prints on the given |port| (by default the current output\nport) the instructions of the given |sexpr|. If |show-consts| is true,\nthe table of the contants used in |sexpr| is also printed.\n\n@lisp\n(disassemble-expr '(begin\n                      (define x (+ y 10))\n                      (cons x y))\n                    #t)\n@end lisp\n\nwill print:\n\n@lisp\n000:  GLOBAL-REF           0\n002:  IN-SINT-ADD2         10\n004:  DEFINE-SYMBOL        1\n006:  GLOBAL-REF-PUSH      1\n008:  GLOBAL-REF           0\n010:  IN-CONS\n011:\n\nConstants:\n0: y\n1: x\n@end lisp" :similar ())


;; Source file "bb.stk"


;; Source file "bonus.stk"

(gensym :type extended :synopsis "(gensym)\n(gensym prefix)" :description "Creates a new symbol. The print name of the generated symbol\nconsists of a prefix (which defaults to \"G\") followed by the decimal\nrepresentation of a number. If |prefix| is specified, it must be\neither a string or a symbol.\n@lisp\n(gensym)        => @pipeG100@pipe\n(gensym \"foo-\") => foo-101\n(gensym 'foo-)  => foo-102\n@end lisp" :similar ())

(macro-expand :type extended :synopsis "(macro-expand form)\n(macro-expand* form)" :description "|macro-expand| returns the macro expansion of |form| if it is a macro call,\notherwise |form| is returned unchanged.\n\n@lisp\n(define-macro (add1 x) `(+ ,x 1))\n(macro-expand '(add1 foo)) => (+ foo 1)\n(macro-expand '(car bar))  => (car bar)\n@end lisp\n\n|macro-expand| returns the *full* macro expansion of |form|, that is it repeats\nthe macro-expansion, while the expanded form contains macro calls.\n\n@lisp\n(define-macro (add2 x) `(add1 (add1 ,x)))\n(macro-expand '(add2 foo)) => (add1 (add1 foo))\n(macro-expand* '(add2 foo)) => (+ (+ foo 1) 1)\n@end lisp\n\nNOTE: |macro-expand| and |macro-expand*| expand only the global macros." :similar (macro-expand*))

(macro-expand* :see macro-expand)
(remove! :type extended :synopsis "(remove pred list)" :description "|Remove| returns |list| without the elements that satisfy predicate |pred|:\n@l\nThe list is not disordered -- elements that appear in the result list occur\nin the same order as they occur in the argument list. |Remove!| does the\nsame job than |remove| by physically modifying its |list| argument\n@lisp\n(remove even? '(0 7 8 8 43 -4)) => (7 43)\n@end lisp" :similar (remove))

(remove :see remove!)
(delete! :type extended :synopsis "(delete  x list [=])\n(delete! x list [=])" :description "|Delete| uses the comparison procedure |=|, which defaults to\n|equal?|, to find all elements of |list| that are equal to |x|, and\ndeletes them from |list|. The dynamic order in which the various\napplications of |=| are made is not specified.\n@l\nThe list is not disordered -- elements that appear in the result\nlist occur in the same order as they occur in the argument list.\n@l\nThe comparison procedure is used in this way: |(= x ei)|. That is,\n|x| is always the first argument, and a list element is always the\nsecond argument. The comparison procedure will be used to compare\neach element of list exactly once; the order in which it is applied\nto the various |ei| is not specified. Thus, one can reliably remove\nall the numbers greater than five from a list with\n@lisp\n(delete 5 list <)\n@end lisp\n\n|delete!| is the linear-update variant of |delete|. It is allowed,\nbut not required, to alter the cons cells in its argument |list| to\nconstruct the result." :similar (delete))

(delete :see delete!)
(every :type extended :synopsis "(every pred list1 list2 ...)" :description "|every| applies the predicate |pred| across the lists, returning true if\nthe predicate returns true on every application.\n@l\nIf there are n list arguments |list1| ... |listn|, then |pred| must be\na procedure taking n arguments and returning a boolean result.\n@l\n|every| applies pred to the first elements of the |listi| parameters. If\nthis application returns false, every immediately returns `#f`.\nOtherwise, it iterates, applying |pred| to the second elements of the |listi|\nparameters, then the third, and so forth. The iteration stops when a\nfalse value is produced or one of the lists runs out of values.\nIn the latter case, |every| returns the true value produced by its final\napplication of pred. The application of pred to the last element of the\nlists is a tail call.\n@l\nIf one of the |listi| has no elements, |every| simply returns `#t`.\n@l\nLike |any|, |every|'s name does not end with a question mark -- this is to\nindicate that it does not return a simple boolean (`#t` or `#f`), but a\ngeneral value." :similar ())

(any :type extended :synopsis "(any pred list1 list2 ...)" :description "|any| applies the predicate across the lists, returning true if the\npredicate returns true on any application.\n\nIf there are n list arguments |list1| ... |listn|, then |pred| must be\na procedure taking n arguments.\n\n|any| applies |pred| to the first elements of the |listi| parameters. If\nthis application returns a true value, |any| immediately returns that value.\nOtherwise, it iterates, applying |pred| to the second elements of the |listi|\nparameters, then the third, and so forth. The iteration stops when a true\nvalue is produced or one of the lists runs out of values; in the latter case,\nany returns `#f`. The application of |pred| to the last element of the\nlists is a tail call.\n\nLike |every|, |any|'s name does not end with a question mark -- this is\nto indicate that it does not return a simple boolean (`#t` or `#f`), but\na general value.\n\n@lisp\n(any integer? '(a 3 b 2.7))   => #t\n(any integer? '(a 3.1 b 2.7)) => #f\n(any < '(3 1 4 1 5)\n       '(2 7 1 8 2))          => #t\n@end lisp" :similar ())

(call-with-input-string :type extended :synopsis "(call-with-input-string string proc)" :description "behaves as |call-with-input-file| except that the port passed to |proc|\nis the sting port obtained from |port|.\n@lisp\n(call-with-input-string \"123 456\"\n  (lambda (x)\n     (let* ((n1 (read x))\n            (n2 (read x)))\n        (cons n1 n2))))          => (123 . 456)\n@end lisp" :similar ())

(call-with-output-string :type extended :synopsis "(call-with-output-string proc)" :description "|Proc| should be a procedure of one argument. |Call-with-output-string|\ncalls |proc| with a freshly opened output string port. The result of\nthis procedure is a string containing all the text that has been written\non the string port.\n@lisp\n(call-with-output-string\n  (lambda (x) (write 123 x) (display \"Hello\" x))) => \"123Hello\"\n@end lisp" :similar ())

(read-from-string :type extended :synopsis "(read-from-string str)" :description "Performs a read from the given |str|. If |str| is the empty string,\nan end of file object is returned.\n\n@lisp\n(read-from-string \"123 456\") => 123\n(read-from-string \"\")        => an eof object\n@end lisp" :similar ())

(eval-from-string :type extended :synopsis "(eval-from-string str)\n(eval-from-string str module)" :description "Read an expression from |str| and evaluates it with |eval|. If a |module|\nis passed, the evaluation takes place in the environment of this module.\nOtherwise, the evaluation takes place in the environment returned by\n|current-module|.\n@lisp\n(define x 10)\n(define-module M\n  (define x 100))\n(eval-from-string \"(+ x x)\")                   => 20\n(eval-from-string \"(+ x x)\" (find-module 'M))  => 200\n@end lisp" :similar ())

(command-line :type r7rs-procedure :synopsis "(command-line)" :description "Returns the command line passed to the process as a list\nof strings. The first string corresponds to the command\nname." :similar ())

(program-name :type extended :synopsis "(program-name)" :description "Returns the invocation name of the current program as a string. If the file is\nnot a script (in sense of {{quick-link-srfi 193}}), it is the name of the\nrunning {{stklos}} interpreter, otherwise it is the name of the running script.\nThis function always returns a string whereas the |command-name| procedure returns\n`#f` when the program name is not a script." :similar ())

(create-directories :type extended :synopsis "(create-directories dir)\n(create-directories dir permissions)" :description "Create a directory with name |dir|. No error is signaled if |dir| already exists.\nParent directories of |dir| are created as needed. If |permissions| is omitted,\nit defaults to #o775 (masked by the current umask).\n\nNOTE: This function was also called |make-directories|. This old name is\nobsolete." :similar ())

(ensure-directories-exist :type extended :synopsis "(ensure-directories-exist path)" :description "Create a directory with name |dir| (and its parent directories if needed), if it\ndoes not exist yet." :similar ())

(posix-error? :type extended :synopsis "(posix-error? obj)" :description "This procedure returns `#t` if |obj| is a condition object that describes a\nPOSIX error, and `#f` otherwise.\n\nThis function is defined in {{link-srfi 170}}." :similar ())

(posix-error-name :type extended :synopsis "(posix-error-name posix-error)" :description "This procedure returns a symbol that is the name associated with the\nvalue of |errno| when the POSIX function reported an error. This can be\nused to provide programmatic recovery when a POSIX function can return\nmore than one value of |errno|.\n\nThis function is defined in {{link-srfi 170}}." :similar ())

(posix-error-message :type extended :synopsis "(posix-error-message posix-error)" :description "This procedure returns a string that is an error message reflecting the\nvalue of errno when the POSIX function reported an error. This string\nis useful for reporting the cause of the error to the user\n\nThis function is defined in {{link-srfi 170}}." :similar ())

(posix-error-errno :type extended :synopsis "(posix-error-errno posix-error)" :description "This procedure returns the value of |errno| (an exact integer)." :similar ())

(posix-error-procedure :type extended :synopsis "(posix-error-procedure posix-error)" :description "This procedure returns the name of the Scheme procedure that raised\nthe error." :similar ())

(posix-error-arguments :type extended :synopsis "(posix-error-args posix-error)" :description "This procedure returns the list of the Scheme procedure arguments\nthat raised the error." :similar ())

(make-hash-table :type extended :synopsis "(make-hash-table)\n(make-hash-table comparison)\n(make-hash-table comparison hash)" :description "|Make-hash-table| admits three different forms.  The most general form\nadmit two arguments. The first argument is a comparison function which\ndetermines how keys are compared; the second argument is a function which\ncomputes a hash code for an object and returns the hash code as a non\nnegative integer. Objets with the same hash code are stored in an A-list\nregistered in the bucket corresponding to the key.\n\nIf omitted,\n\n- |hash| defaults to the |hash-table-hash| procedure\n (see _<<hashtablehash, `hash-table-hash` primitive>>_).\n\n- |comparison| defaults to the |eq?| procedure\n  (see _<<eqprim, `eq?` primitive>>_)).\n\nConsequently,\n@lisp\n(define h (make-hash-table))\n@end lisp\nis equivalent to\n@lisp\n(define h (make-hash-table eq? hash-table-hash))\n@end lisp\n\nAn interesting example is\n@lisp\n(define h (make-hash-table string-ci=? string-length))\n@end lisp\nwhich defines a new hash table which uses |string-ci=?| for\ncomparing keys. Here, we use the string-length as a (very simple)\nhashing function. Of course, a function which gives a key depending\nof the characters composing the string gives a better repartition\nand should probably enhance performances. For instance, the following\ncall to |make-hash-table| should return a more efficient, even if\nnot perfect, hash table:\n@lisp\n(make-hash-table\n   string-ci=?\n   (lambda (s)\n     (let ((len (string-length s)))\n       (do ((h 0)  (i 0 (+ i 1)))\n           ((= i len) h)\n         (set! h\n               (+ h (char->integer\n                      (char-downcase (string-ref s i)))))))))\n@end lisp\n\nNOTE: Hash tables with a comparison function equal to |eq?| or\n|string=?| are handled in an more efficient way (in fact, they don't use\nthe |hash-table-hash| function to speed up hash table retrievals)." :similar ())

(hash-table->alist :type extended :synopsis "(hash-table->alist hash)" :description "Returns an _association list_ built from the entries in |hash|.\nEach entry in |hash| will be represented as a pair whose |car| is the\nentry's key and whose |cdr| is its value.\n\nNOTE: the order of pairs in the resulting list is unspecified.\n@lisp\n(let ((h (make-hash-table)))\n  (dotimes (i 5)\n    (hash-table-set! h i (number->string i)))\n  (hash-table->alist h))\n       => ((3 . \"3\") (4 . \"4\") (0 . \"0\")\n           (1 . \"1\") (2 . \"2\"))\n@end lisp" :similar ())

(alist->hash-table :type extended :synopsis "(alist->hash-table alist)\n(alist->hash-table alist comparison)\n(alist->hash-table alist comparison hash)" :description "Returns hash-table built from the _association list_\n|alist|. This function maps the |car| of every element in |alist|\nto the |cdr| of corresponding elements in |alist|. the |comparison| and\n|hash| functions are interpreted as in |make-hash-table|. If some key\noccurs multiple times in |alist|, the value in the first\nassociation will take precedence over later ones.\n" :similar ())

(hash-table-update! :type extended :synopsis "(hash-table-update! hash key update-fun thunk)\n(hash-table-update!/default hash key update-fun default)" :description "Update the value associated to |key| in table |hash| if key is already in\ntable with the value |(update-fun current-value)|. If no value is\nassociated to |key|, a new entry in the table is first inserted\nbefore updating it (this new entry being the result of calling |thunk|).\n\nNote that the expression\n@lisp\n(hash-table-update!/default hash key update-fun default)\n@end lisp\nis equivalent to\n@lisp\n(hash-table-update! hash key update-fun (lambda () default))\n@end lisp\n\n@lisp\n(let ((h   (make-hash-table))\n      (1+  (lambda (n) (+ n 1))))\n  (hash-table-update!/default h 'test 1+ 100)\n  (hash-table-update!/default h 'test 1+)\n  (hash-table-ref h 'test))             => 102\n@end lisp" :similar (hash-table-update!/default))

(hash-table-update!/default :see hash-table-update!)
(hash-table-keys :type extended :synopsis "(hash-table-keys hash)\n(hash-table-values hash)" :description "Returns the keys or the values of |hash|." :similar (hash-table-values))

(hash-table-values :see hash-table-keys)
(hash-table-fold :type extended :synopsis "(hash-table-fold hash func init-value)" :description "This procedure calls |func| for every association in |hash|\nwith three arguments: the key of the association key, the value\nof the association value, and an accumulated value, |val|. |Val| is\ninit-value for the first invocation of |func|, and for subsequent\ninvocations of |func|, the return value of the previous invocation of\n|func|. The value |final-value| returned by |hash-table-fold| is the\nreturn value of the last invocation of |func|. The order in which |func| is\ncalled for different associations is unspecified.\n@l\nFor instance, the following expression\n@lisp\n(hash-table-fold ht (lambda (k v acc) (+ acc 1)) 0)\n@end lisp\ncomputes the number of associations present in the |ht| hash table." :similar ())

(hash-table-merge! :type extended :synopsis "(hash-table-merge! hash1 hash2)" :description "Adds all mappings in |hash2| into |hash1| and returns the resulting\nhash table. This function may modify |hash1| destructively." :similar ())

(hash-table-copy :type extended :synopsis "(hash-table-copy hash)" :description "Returns a copy of |hash|." :similar ())

(fluid-let :type extended-syntax :synopsis "(fluid-let <bindings> <body>)" :description "The |<bindings>| are evaluated in the current environment, in some\nunspecified order, the current values of the variables present in\n|<bindings>| are saved, and the new evaluated values are assigned to the\n|<bindings>| variables. Once this is done, the expressions of |<body>|\nare evaluated sequentially in the current environment; the value of the\nlast expression is the result of |fluid-let|. Upon exit, the stored\nvariables values are restored. An error is signalled if any of the\n|<bindings>| variable is unbound.\n@lisp\n(let* ((a 'out)\n       (f (lambda () a)))\n  (list (f)\n        (fluid-let ((a 'in)) (f))\n        (f))) => (out in out)\n@end lisp\n\nWhen the body of a |fluid-let| is exited by invoking a continuation,\nthe new variable values are saved, and the variables are set to their old\nvalues. Then, if the body is reentered by invoking a continuation, the old\nvalues are saved and new values are restored. The following example illustrates\nthis behavior\n\n@lisp\n(let ((cont #f)\n      (l    '())\n      (a    'out))\n  (set! l (cons a l))\n  (fluid-let ((a 'in))\n    (set! cont (call-with-current-continuation (lambda (k) k)))\n    (set! l (cons a l)))\n  (set! l (cons a l))\n\n  (if cont (cont #f) l)) =>  (out in out in out)\n@end lisp" :similar ())

(setter :type extended :synopsis "(setter proc)" :description "Returns the setter associated to a |proc|. Setters are defined in the\n{{link-srfi 17}} document. A setter proc, can be used in a generalized\nassignment, as described in |set!|.\n\nTo associate |s| to the procedure |p|, use the following form:\n@lisp\n(set! (setter p) s)\n@end lisp\nFor instance, we can write\n@lisp\n(set! (setter car) set-car!)\n@end lisp\n\nThe following standard procedures have pre-defined setters:\n@lisp\n(set! (car x) v)              == (set-car! x v)\n(set! (cdr x) v)              == (set-cdr! x v)\n(set! (string-ref x i) v)     == (string-set! x i v)\n(set! (vector-ref x i) v)     == (vector-set! x i v)!\n(set! (slot-ref x 'name) v)   == (slot-set! x 'name v)\n(set! (struct-ref x 'name) v) == (struct-set! x 'name v)\n@end lisp\nFurhermore, Parameter Objects (see _<<_parameter_objects>>_) are\ntheir own setter:\n@lisp\n(real-precision)              => 15\n(set! (real-precision) 12)\n(real-precision)              => 12\n@end lisp" :similar ())

(time :type extended-syntax :synopsis "(time expr1 expr2 ...)" :description "Evaluates the expressions |expr1|, |expr2|, ... and returns the\nresult of the last expression. This form prints also the time spent\nfor this evaluation, in milliseconds, on the current error port.\nThis is CPU time, and not real (\"wall\") time." :similar ())

(-> :type extended-syntax :synopsis "(tagbody <expression1> <expression2> ...)\n(-> tag)" :description "The `|<expression>|`s are evaluated sequentially from left to right,\nand the value(s) of the last <expression> is(are) returned as in a\n|begin| form. Within a |tagbody| form expressions which are keywords\nare considered as tags and the special form |(-> tag)| is used to\ntransfer execution to the given tag. This is a **very low level**\nform which is inspired on |tabgody| Common Lisp's form. It can be useful\nfor defining new syntaxes, and should probably not used as is.\n\n@lisp\n(tagbody               ;; an infinite loop\n   #:1 (display \".\")\n       (-> #:1))\n\n(let ((v 0))\n  (tagbody\n   #:top (when (< v 5)\n           (display v)\n           (set! v (fx+ v 1))\n           (-> #:top))))                      @print{} 01234\n\n(tagbody (display 1)\n         (tagbody (display 2)\n                  (-> #:inner)\n                  (display \"not printed\")\n           #:inner\n                 (display 3)\n                 (-> #:outer)\n                 (display \"not printed too\"))\n   #:outer\n         (display \"4\"))                        @print{} 1234\n@end lisp" :similar (tagbody))

(tagbody :see ->)
(dotimes :type extended-syntax :synopsis "(dotimes [var count] <expression1> <expression2> ...)\n(dotimes [var count result] <expression1> <expression2> ...)" :description "Evaluates the |count| expression, which must return an\ninteger and then evaluates the `|<expression>|`s once for each\ninteger from zero (inclusive) to |count| (exclusive), in order,\nwith the symbol |var| bound to the integer; if the value of\n|count| is zero or negative, then the `|<expression>|`s are not\nevaluated. When the loop completes, |result| is evaluated and its\nvalue is returned as the value of the |dotimes| construction. If\n|result| is omitted, |dotimes| result is *_void_*.\n@lisp\n(let ((l '()))\n  (dotimes (i 4 l)\n     (set! l (cons i l)))) => (3 2 1 0)\n@end lisp" :similar ())

(repeat :type extended-syntax :synopsis "(repeat count <expression1> <expression2> ...)" :description "Evaluates the |count| expression, which must return an\ninteger and then evaluates the `|<expression>|`s once for each\ninteger from zero (inclusive) to |count| (exclusive). The result of\n|repeat| is undefined.\n\nThis form could be easily simulated with |dotimes|. Its interest is\nthat it is faster.\n@lisp\n(repeat 3 (display \".\"))     => prints \"...\"\n(repeat 0 (display \".\"))     => prints nothing\n@end lisp" :similar ())

(while :type extended-syntax :synopsis "(while <test> <expression1> <expression2> ...)" :description "|While| evaluates the `|<expression>|`s until |<test>| returns a false\nvalue. The value returned by this form is *_void_*." :similar ())

(until :type extended-syntax :synopsis "(until <test> <expression1> <expression2> ...)" :description "|Until| evaluates the `|<expression>|`s until |<while>| returns a false\nvalue. The value returned by this form is *_void_*." :similar ())

(call/ec :type extended :synopsis "(call/ec proc)" :description "|call/ec| is an short name for |call-with-escape-continuation|. |call/ec|\ncalls |proc| with one parameter, which is the current escape continuation\n(a continuation which can only be used to abort a computation and hence\ncannot be \"re-enterered\").\n\n@lisp\n(list 1\n      (call/ec (lambda (return) (list 'a (return 'b) 'c)))\n      3)        => (1 b 3)\n@end lisp\n|call/ec| is cheaper than the full call/cc. It is particularily useful\nwhen all the power of |call/cc| is not needded." :similar ())

(base64-encode-string :type extended :synopsis "(base64-encode-string str)" :description "Return a string contening the contents of |str| converted to Base64\nencoded format." :similar ())

(base64-decode-string :type extended :synopsis "(base64-decode-string str)" :description "Decode the contents of |str| expressed in Base64." :similar ())

(md5sum-file :type extended :synopsis "(md5sum-file str)" :description "Return a string contening the md5 sum of the file whose name is |str|." :similar ())

(ansi-color :type extended :synopsis "(ansi-color e1 e2 ... en)" :description "|ansi-color| permits to build a string which embeds ANSI codes to\ncolorize texts on a terminal. Each expression e~i~ must be a string,\na symbol or an integer.\n\nStrings constitute the message to be displayed.\n\nA symbol can designate\n\n- a color in the set {|black|, |red|, |green|, |yellow|, |blue|,\n  |magenta|, |cyan|, |white|} for foreground colors\n- a color in the set {|bg-black|, |bg-red|, |bg-green|, |bg-yellow|,\n  |bg-blue|, |bg-magenta|, |bg-cyan|, |bg-white|} for background colors.\n- a qualifier such as |normal|, |bold|, |italic|, |underline|, |blink|,\n  |reverse| or |no-bold|, |no-italic|, |no-underline|, |no-blink|,\n  |no-reverse|.\n\nInteger values can be used for terminals which are able to display  256 colors.\nIf the number is positive, it is used as a foreground color. Otherwise,\nit is uses as a background color. Note that not all the terminals are able to\nuse more than eight colors.\n\nFor instance,\n@lisp\n(display (ansi-color \"a word in \"\n                     'bold 'red \"RED\" 'normal\n                     \" and another in \"\n                     'reverse 'blue \"BLUE\" 'normal))\n@end lisp\nwill display the words BLUE and RED in color." :similar ())

(port->string-list :type extended :synopsis "(port->string port)\n(port->sexp-list port)\n(port->string-list port)" :description "All these procedures take a port opened for reading. |Port->string| reads\n|port| until the it reads an end of file object and returns all the\ncharacters read as a string. |Port->sexp-list| and |port->string-list|\ndo the same things except that they return a list of S-expressions and\na list of strings respectively. For the following example we suppose that\nfile |\"foo\"| is formed of two lines which contains respectively the number\n|100| and the string |\"bar\"|.\n@lisp\n(port->sexp-list (open-input-file \"foo\"))   => (100 \"bar\")\n(port->string-list (open-input-file \"foo\")) => (\"100\" \"\\\"bar\\\"\")\n@end lisp" :similar (port->sexp-list port->string))

(port->sexp-list :see port->string-list)
(port->string :see port->string-list)
(printerr :type extended :synopsis "(print obj ...)\n(printerr obj ...)" :description "These procedures display all their arguments followed by a newline. The\nprocedure |print| uses the standard output port, whereas |printerr| uses the\ncurrent error port" :similar (print))

(print :see printerr)
(eprintf :type extended :synopsis "(printf fmt obj ...)\n(fprintf port fmt obj ...)\n(eprintf fmt obj ...)" :description "These procedures are specialized versions of _<<format, `format` primitive>>_.\nIn these procedures, |fmt| is a string using the |format| conventions.\n|printf| outputs go on the current output port.\n|fprintf| outputs go on the specified |port|.\n|eprintf| outputs go on the current error port (note that eprintf always\nflushes the characters printed)." :similar (fprintf printf))

(fprintf :see eprintf)
(printf :see eprintf)
(declare-new-error :type extended-syntax :synopsis "(declare-new-error name)" :description "TODO\n" :similar ())

(exec-list :type extended :synopsis "(exec str)\n(exec-list str)" :description "These procedures execute the command given in |str|. The command given\nin |str| is passed to |/bin/sh|. |Exec| returns a string which contains\nall the characters that the command |str| has printed on it's standard\noutput, whereas |exec-list| returns a list of the lines which constitute\nthe output of |str|.\n@lisp\n(exec \"echo A; echo B\")                => \"A\\nB\\n\"\n(exec-list \"echo A; echo B\")           => (\"A\" \"B\")\n@end lisp" :similar (exec))

(exec :see exec-list)
(apropos :type extended :synopsis "(apropos obj)\n(apropos obj module)" :description "|Apropos| returns a list of symbols whose print name contains the\ncharacters of |obj| as a substring . The given |obj| can be a string or\nsymbol. This function returns the list of matched symbols which can\nbe accessed from the given |module| (defaults to the current module if not\nprovided).\n" :similar ())

(die :type extended :synopsis "(die message)\n(die message status)" :description "|Die| prints the given |message| on the current error port and exits\nthe program with the |status| value. If |status| is omitted, it\ndefaults to 1." :similar ())

(decompose-file-name :type extended :synopsis "(decompose-file-name string)" :description "Returns an ``exploded'' list of the path name components given in\n|string|.\nThe first element in the list denotes if the given |string| is an\nabsolute path or a relative one, being \"/\" or \".\" respectively.\nEach component of this list is a string.\n@lisp\n(decompose-file-name \"/a/b/c.stk\") => (\"/\" \"a\" \"b\" \"c.stk\")\n(decompose-file-name \"a/b/c.stk\")  => (\".\" \"a\" \"b\" \"c.stk\")\n@end lisp" :similar ())

(dirname :type extended :synopsis "(dirname str)" :description "Returns a string containing all but the last component of the path\nname given in |str|.\n@lisp\n(dirname \"/a/b/c.stk\") => \"/a/b\"\n@end lisp" :similar ())

(basename :type extended :synopsis "(basename str)" :description "Returns a string containing the last component of the path name\ngiven in |str|.\n@lisp\n(basename \"/a/b/c.stk\") => \"c.stk\"\n@end lisp" :similar ())

(file-separator :type extended :synopsis "(file-separator)" :description "Retuns the operating system file separator as a character. This is typically\n`{{sharp}}\\/` on Unix (or Cygwin) systems and `{{sharp}}\\\\` on Windows." :similar ())

(make-path :type extended :synopsis "(make-path dirname .  names)" :description "Builds a file name from the directory |dirname| and |names|. For instance,\non a Unix system:\n@lisp\n(make-path \"a\" \"b\" \"c\")   => \"a/b/c\"\n@end lisp" :similar ())

(file-suffix :type extended :synopsis "(file-suffix pathname)" :description "Returns the suffix of given |pathname|. If no suffix is found, |file-suffix|\nreturns `#f`.\n@lisp\n(file-suffix \"./foo.tar.gz\") => \"gz\"\n(file-suffix \"./a.b/c\")      => #f\n(file-suffix \"./a.b/c.\")     => \"\"\n(file-suffix \"~/.profile\")   => #f\n@end lisp" :similar ())

(file-prefix :type extended :synopsis "(file-prefix pathname)" :description "Returns the prefix of given |pathname|.\n@lisp\n(file-prefix \"./foo.tar.gz\") => \"./foo.tar\"\n(file-prefix \"./a.b/c\")      => \"./a.b/c\"\n@end lisp" :similar ())

(port-idle-reset! :type extended :synopsis "(port-idle-register! port thunk)\n(port-idle-unregister! port thunk)\n(port-idle-reset! port)" :description "|port-idle-register!| allows to register |thunk| as an idle handler\nwhen reading on port. That means that |thunk| will be called continuously\nwhile waiting  an input on |port| (and only while using a reading\nprimitive on this port). |port-idle-unregister!| can be used to\nunregister a handler previously set by |port-idle-register!|. The\nprimitive |port-idle-reset!| unregisters all the handlers set on\n|port|.\n\nHereafter is a (not too realistic) example: a message will be displayed\nrepeatedly until a *_sexpr_* is read on the current input port.\n\n@lisp\n(let ((idle (lambda () (display \"Nothing to read!\\\\n\"))))\n  (port-idle-register! (current-input-port) idle)\n  (let ((result (read)))\n    (port-idle-unregister! (current-input-port) idle)\n    result))\n@end lisp" :similar (port-idle-unregister! port-idle-register!))

(port-idle-unregister! :see port-idle-reset!)
(port-idle-register! :see port-idle-reset!)
(chmod :type extended :synopsis "(chmod str)\n(chmod str option1 ...)" :description "Change the access mode of the file whose path name is given in |string|.\nThe options must be composed of either an integer or one of the\nfollowing symbols |read|, |write| or |execute|. Giving no option to |chmod|\nis equivalent to pass it the integer |0|. If the operation succeeds,\n|chmod| returns `#t`; otherwise it returns `#f`.\n\n@lisp\n(chmod \"~/.stklos/stklosrc\" 'read 'execute)\n(chmod \"~/.stklos/stklosrc\" #o644)\n@end lisp" :similar ())

(with-mutex :type extended :synopsis "(with-mutex mtx <thunk>)" :description "Executes |thunk|, protected by mutex |mtx|. The mutex will\nbe locked before and released after execution of |body|, and\nalso on entrance or departure of its dynamic context\n(lock and unlock are used within |dynamic-wind|)." :similar ())

(error-object-location :type extended :synopsis "(error-object-location error-object)" :description "Returns the location encapsulated by |error-object| if it exists.\nReturns `#f` otherwise. The location corresponds generally to the name\nof the procedure which raised the error.\n@lisp\n(guard (cnd\n         (else (error-object-location cnd)))\n  (error 'foo \"error message\"))  => foo\n@end lisp" :similar ())

(define-constant :type extended :synopsis "(define-constant name expr)\n(define-constant (name param1 param2 ...) body)" :description "Evaluates the expression |expr|, then creates a new, non-mutable\nbinding for |name| with the resulting value. Note that the definition\nof constant functions can use the notation of {{quick-link-srfi 219}}.\n\n(define-constant a 'hello)\n(set! a 'goodbye)             => error\n(define a 2)                  => ok (it's a new binding)\n(define-constant ((foo a) b)  => foo is (lambda (a) (lambda (b) ...)))\n    ...)" :similar ())

(void? :type extended :synopsis "(void? obj)" :description "Returns `#t` is |obj| is `#void`, and `#f` otherwise.\nThe usual \"unspecified\" result in Scheme standard and in SRFIs is `#void`\nin STklos, and it is also returned by the procedure |void|.\n\n@lisp\n(void? (void))                    => #t\n(define x (if #f 'nope))\n(void? x)                         => #t\n(void? '())                       => #f\n(void? 'something)                => #f\n(void? (for-each print '(1 2 3))) => #t\n@end lisp" :similar ())

(receive :type extended-syntax :synopsis "(receive <formals> <expression> <body>)" :description "This form is defined in {{link-srfi 8}}. It simplifies\nthe usage of multiple values. Specifically, |<formals>| can have any\nof three forms:\n\n- (|<variable~1~>| ... |<variable~n~>|):\n  The environment in which the\n  receive-expression is evaluated is extended by binding |<variable~1~>|, ...,\n  |<variable~n~>| to fresh locations. +\n  The |<expression>| is evaluated, and its\n  values are stored into those locations. (It is an error if |<expression>|\n  does not have exactly n values.)\n\n- |<variable>|: The environment in which the receive-expression is\n  evaluated is extended by binding |<variable>| to a fresh location. +\n  The |<expression>| is evaluated, its values are converted into a newly\n  allocated list, and the list is stored in the location bound to |<variable>|.\n\n- (|<variable~1~>| ... |<variable~n~>| . |<variable~n+1~>|):  The environment\n  in which the receive-expression is evaluated is extended by binding\n  |<variable~1~>|, ..., |<variable~n+1~>| to fresh locations.\n  The |<expression>| is evaluated. Its first n values are stored into the\n  locations bound to |<variable~1~>| ... |<variable~n~>|. Any remaining values\n  are converted into a newly allocated list, which is stored into the location\n  bound to |<variable~n+1~>|. (It is an error if |<expression>| does not have\n  at least n values.\n\nIn any case, the expressions in |<body>| are evaluated sequentially in\nthe extended environment. The results of the last expression in the body\nare the values of the receive-expression.\n\n@lisp\n(let ((n 123))\n  (receive (q r)\n     (values (quotient n 10) (modulo n 10))\n     (cons q r)))\n              => (12 . 3)\n@end lisp" :similar ())

(case-lambda :type extended-syntax :synopsis "(case-lambda <clause> ...)" :description "Each |<clause>| should have the form |(<formals> <body>)|, where\n|<formals>| is a formal arguments list as for |lambda|.\nEach |<body>| is a |<tail-body>|, as defined in R5RS.\n@l\nA |case-lambda| expression evaluates to a procedure that\naccepts a variable number of arguments and is lexically scoped in\nthe same manner as procedures resulting from |lambda|\nexpressions. When the procedure is called with some arguments\n|v1 ... vk|, then the first |<clause>| for which the arguments agree\nwith |<formals>| is selected, where agreement is specified as for the\n|<formals>| of a |lambda| expression. The variables of |<formals>|\nare bound to fresh locations, the values |v1 ... vk| are stored in those\nlocations, the |<body>| is evaluated in the extended environment,\nand the results of |<body>| are returned as the results of the\nprocedure call.\n@l\nIt is an error for the arguments not to agree with the |<formals>|\nof any |<clause>|.\n@l\nThis form is defined in {{link-srfi 16}}.\n\n@lisp\n (define plus\n   (case-lambda\n    (() 0)\n    ((x) x)\n    ((x y) (+ x y))\n    ((x y z) (+ (+ x y) z))\n    (args (apply + args))))\n\n (plus)                     => 0\n (plus 1)                   => 1\n (plus 1 2 3)               => 6\n\n ((case-lambda\n   ((a) a)\n   ((a b) (* a b)))\n  1 2 3)                    => error\n@end lisp" :similar ())

(parameterize :type extended-syntax :synopsis "(parameterize ((expr1 expr2) ...) <body>)" :description "The expressions |expr1| and |expr2| are evaluated in an unspecified order.\nThe value of the |expr1| expressions must be parameter objects.\nFor each |expr1| expression and in an unspecified order, the local\ndynamic environment is extended with a binding of the parameter object\n|expr1| to a new cell whose content is the result of the call\n|(converter val)|, where |val| is the value of |expr2| and converter\nis the conversion procedure of the parameter object. The resulting\ndynamic environment is then used for the evaluation of |<body>|\n(which refers to the R5RS grammar nonterminal of that name).\nThe result(s) of the parameterize form are the result(s) of\nthe |<body>|.\n\n@lisp\n(radix)                                              =>  2\n(parameterize ((radix 16)) (radix))                  =>  16\n(radix)                                              =>  2\n\n(define (f n) (number->string n (radix)))\n\n(f 10)                                               =>  \"1010\"\n(parameterize ((radix 8)) (f 10))                    =>  \"12\"\n(parameterize ((radix 8) (prompt (f 10))) (prompt))  =>  \"1010\"\n@end lisp" :similar ())

(require-extension :type extended-syntax :synopsis "(require-extension <clause> ...)" :description "The syntax of require-extension is as follows:\n@lisp\n(require-extension <clause> ...)\n@end lisp\nA clause may have the form:\n\n1. |(srfi number ...)|\n\n2. |(identifier ...)|\n\n3. |identifier|\n\nIn the first form the functionality of the indicated SRFIs are made\navailable in the context in which the |require-extension| form appears.\nFor instance,\n@lisp\n(require-extension (srfi 1 2)) ; Make the SRFI 1 and 2 available\n@end lisp\nThis form is compatible with {{link-srfi 55}}.\n\nThe second and third forms are {{stklos}} extensions.\nIf the form is a list, it is equivalent to an import. That is,\n@lisp\n(require-extension (streams primitive) (streams derived))\n@end lisp\nis equivalent to\n@lisp\n(import (streams primitive) (streams derived))\n@end lisp\n\nThe final form permits to use symbolic names for requiring some extensions.\nFor instance,\n@lisp\n(require-extension lists and-let*)\n@end lisp\nis equivalent to the requiring |srfi-1| and |srfi-2|.\n\nA list of available symbolic names for features is given in <<_srfis>>." :similar ())

(string->keyword :type extended :synopsis "(string->keyword str)" :description "This function function has been added to be compatibe with SRFI-88.\nIt is equivalent to make-keyword, except that the parameter cannot be\na symbol." :similar ())

(get-environment-variable :type r7rs-procedure :synopsis "(get-environment-variable name)" :description "Returns the value of the named environment variable as a string, or\n`#f` if the named environment variable is not found. The name argument\nis expected to be a string. This function is similar to the |getenv|. It\nhas been added to be  support {{link-srfi 98}}." :similar ())

(get-environment-variables :type r7rs-procedure :synopsis "(get-environment-variables)" :description "Returns names and values of all the environment variables as an a-list.\nThis function is defined by {{link-srfi 98}}." :similar ())

(implementation-name :type extended :synopsis "(implementation-name)" :description "This function is defined in {{link-srfi 112}}; it returns the Scheme\nimplementation (i.e. the string `\"STklos\"`)." :similar ())

(cpu-architecture :type extended :synopsis "(cpu-architecture)" :description "This function is defined in {{link-srfi 112}}; it returns the CPU\narchitecture, real or virtual, on which this implementation\nis executing." :similar ())

(machine-name :type extended :synopsis "(machine-name)" :description "This function is defined in {{link-srfi 112}}; it returns a name for the\nparticular machine on which the implementation is running." :similar ())

(os-name :type extended :synopsis "(os-name)" :description "This function is defined in {{link-srfi 112}}; it returns the name for\nthe operating system, platform, or equivalent on which the\nimplementation is running." :similar ())

(os-version :type extended :synopsis "(os-version)" :description "This function is defined in {{link-srfi 112}}; it returns the version for\nthe operating system, platform, or equivalent on which the\nimplementation is running." :similar ())

(assume :type extended-syntax :synopsis "(assume obj ...)" :description "The special form |assume| is defined in {{link-srfi 145}}.\nWhen {{stklos}} is in debug mode, this special form is an expression\nthat evaluates to the value of |obj| if |obj| evaluates to a true\nvalue and it is an error if |obj| evaluates to a false value.\n\nWhen {{stklos}} is not in debug mode, the call to |assume| is elided." :similar ())

(version-alist :type extended :synopsis "(version-alist)" :description "This function returns an association list of STklos properties as defined by\n{{link-srfi 176}}." :similar ())

(port-has-port-position? :type extended :synopsis "(port-has-port-position? port)" :description "The port-has-port-position? procedure returns `#t` if the port\nsupports the port-position operation, and `#f` otherwise. If the port\ndoes not support the operation, port-position signals an error." :similar ())

(port-position :type extended :synopsis "(port-position port)" :description "The port-position procedure returns an object representing the\ninformation state  about the port current position as is\nnecessary to save and restore that position. This value can be useful\nonly as the pos argument to set-port-position!, if the latter is even\nsupported on the port. However, if the port is binary and the object\nis an exact integer, then it is the position measured in bytes, and\ncan be used to compute a new position some specified number of bytes\naway." :similar ())

(port-has-set-port-position!? :type extended :synopsis "(port-has-set-port-position!? port)" :description "The port-has-set-port-position!? procedure returns `#t` if the port supports\nthe set-port-position! operation, and `#f` otherwise." :similar ())

(set-port-position! :type extended :synopsis "(set-port-position! port pos)" :description "For a textual port, it is implementation-defined what happens if pos is not\nthe return value of a call to port-position on port. However, a binary port\nwill also accept an exact integer, in which case the port position is set to\nthe specified number of bytes from the beginning of the port data. If this\nis not sufficient information to specify the port state, or the specified\nposition is uninterpretable by the port, an error satisfying\ni/o-invalid-position-error? is signaled.\n\nIf |set-port-position!| procedure is invoked on a port that does not support\nthe operation or if pos is not in the range of valid positions of port,\n|set-port-position!| signals an error. Otherwise, it sets the current position\nof the port to pos. If port is an output port, |set-port-position!| first flushes\nport (even if the port position will not change).\n\nIf port is a binary output port and the current position is set beyond the\ncurrent end of the data in the underlying data sink, the object is not extended\nuntil new data is written at that position. The contents of any intervening\npositions are unspecified. It is also possible to set the position of a binary\ninput port beyond the end of the data in the data source, but a read will fail\nunless the data has been extended by other means. File ports can always be\nextended in this manner within the limits of the underlying operating system.\nIn other types of ports, if an attempt is made to set the position beyond the\ncurrent end of data in the underlying object, and the object does not support\nextension, an error satisfying |i/o-invalid-position-error?| is signaled." :similar ())

(make-i/o-invalid-position-error :type extended :synopsis "(make-i/o-invalid-position-error pos)" :description "Returns a condition object which satisfies i/o-invalid-position-error?.\nThe pos argument represents a position passed to set-position!." :similar ())

(i/o-invalid-position-error? :type extended :synopsis "(i/o-invalid-position-error? obj)" :description "Returns `#t` if |obj| is an object created by\n|make-i/o-invalid-position-error?| or an object raised in the circumstances\ndescribed in {{quick-link-srfi 192}} (attempt to access an invalid position in the\nstream), or `#f` if it is not." :similar ())

(command-name :type extended :synopsis "(command-name)" :description "Returnd the name of the running program if it is a standalone and `#f`\notherwise. This function is defined in {{link-srfi 193}}." :similar ())

(command-args :type extended :synopsis "(command-args)\n(argv)" :description "Returns a list of the arguments given on the shell command line. The\ninterpreter options are no included in the result. The name |argv| is\ndeprecated and should not be used." :similar (argv))

(argv :see command-args)
(argc :type extended :synopsis "(argc)" :description "Returns the number of arguments present on the command line." :similar ())

(script-file :type extended :synopsis "(script-file)" :description "Returns the absolute path of the current script.\nIf the calling program is not a script, `#f` is returned.\nThis function is defined in {{link-srfi 193}}." :similar ())

(script-directory :type extended :synopsis "(script-directory)" :description "Returns the non-filename part of script-file as a string.\nAs with |script-file|, this is an absolute pathname." :similar ())

(make-nan :type extended :synopsis "(make-nan negative? quiet? payload)\n(make-nan negative? quiet? payload float)" :description "Returns a NaN whose sign bit is equal to |negative?|  (`#t` for negative,\n`#f` for positive), whose quiet bit is equal to quiet? (`#t` for quiet,\n`#f` for signaling), and whose payload is the positive exact integer payload.\nIt is an error if payload is larger than a NaN can hold.\n\nThe optional parameter |float|, is never used in {{stklos}}.\n\nThis function is defined in {{quick-link-srfi 208}}." :similar ())

(fx*/carry :type extended :synopsis "(fx*/carry i j k)" :description "Returns two values: |i|*|j|+|k|, and carry: it is the value of the computation\n@lisp\n(let*-values (((s) (+ (* i j) k))\n              ((q r) (balanced/ s (expt 2 fx-width))))\n  (values r q))\n@end lisp" :similar ())


;; Source file "boot.stk"


;; Source file "callcc.stk"

(call/cc :type procedure :synopsis "(call-with-current-continuation proc)\n(call/cc proc)" :description "|Proc| must be a procedure of one argument. The procedure\n|call-with-current-continuation| packages up the current continuation\n(see the rationale below) as an \"_escape procedure_\" and passes it as\nan argument to |proc|. The escape procedure is a Scheme procedure that, if\nit is later called, will abandon whatever continuation is in effect at\nthat later time and will instead use the continuation that was in effect\nwhen the escape procedure was created. Calling the escape procedure may cause\nthe invocation of before and after thunks installed using |dynamic-wind|.\n@l\nThe escape procedure accepts the same number of arguments as\nthe continuation to the original call to\n|call-with-current-continuation|. Except for continuations created\nby the |call-with-values| procedure, all continuations take exactly\none value.\n@l\nThe escape procedure that is passed to proc has unlimited extent\njust like any other procedure in Scheme. It may be stored in variables\nor data structures and may be called as many times as desired.\n@l\nThe following examples show only the most common ways in which\n|call-with-current-continuation| is used. If all real uses were as simple\nas these examples, there would be no need for a procedure with the power\nof |call-with-current-continuation|.\n\n@lisp\n(call-with-current-continuation\n  (lambda (exit)\n    (for-each (lambda (x)\n                (if (negative? x)\n                    (exit x)))\n              '(54 0 37 -3 245 19))\n    #t))                                =>  -3\n\n(define list-length\n  (lambda (obj)\n    (call-with-current-continuation\n      (lambda (return)\n        (letrec ((r\n                  (lambda (obj)\n                    (cond ((null? obj) 0)\n                          ((pair? obj)\n                           (+ (r (cdr obj)) 1))\n                          (else (return #f))))))\n          (r obj))))))\n\n(list-length '(1 2 3 4))                =>  4\n(list-length '(a b . c))                =>  #f\n@end lisp\n\nIMPORTANT: common use of |call-with-current-continuation|\nis for structured, non-local exits from loops or procedure bodies,\nbut in fact |call-with-current-continuation| is extremely useful\nfor implementing a wide variety of advanced control structures.\n\nWhenever a Scheme expression is evaluated there is a continuation\nwanting the result of the expression. The continuation represents\nan entire (default) future for the computation. If the expression\nis evaluated at top level, for example, then the continuation\nmight take the result, print it on the screen, prompt for the\nnext input, evaluate it, and so on forever. Most of the time the\ncontinuation includes actions specified by user code, as in a\ncontinuation that will take the result, multiply it by the value\nstored in a local variable, add seven, and give the answer to the\ntop level continuation to be printed. Normally these ubiquitous\ncontinuations are hidden behind the scenes and programmers do not\nthink much about them. On rare occasions, however, a programmer\nmay need to deal with continuations explicitly.\n|Call-with-current-continuation| allows Scheme\nprogrammers to do that by creating a procedure that acts just\nlike the current continuation.\n@l\nNOTE: |call/cc| is just another name for\n|call-with-current-continuation|." :similar (call-with-current-continuation))

(call-with-current-continuation :see call/cc)
(dynamic-wind :type procedure :synopsis "(dynamic-wind before thunk after)" :description "Calls |thunk| without arguments, returning the result(s) of this call.\n|Before| and |after| are called, also without arguments, as required by\nthe following rules (note that in the absence of calls to continuations\ncaptured using |call-with-current-continuation| the three arguments are\ncalled once each, in order).  |Before| is called whenever execution enters\nthe dynamic extent of the call to |thunk| and |after| is called whenever\nit exits that dynamic extent.  The dynamic extent of a procedure call is\nthe period between when the call is initiated and when it returns.\nIn Scheme, because of |call-with-current-continuation|, the dynamic\nextent of a call may not be a single, connected time period. It is\ndefined as follows:\n\n- The dynamic extent is entered when execution of the body of\n  the called procedure begins.\n\n- The dynamic extent is also entered when execution is not\n  within the dynamic extent and a continuation is invoked that was\n  captured (using |call-with-current-continuation|) during the dynamic\n  extent.\n\n- It is exited when the called procedure returns.\n\n- It is also exited when execution is within the dynamic\n  extent and a continuation is invoked that was captured while not within\n  the dynamic extent.\n\nIf a second call to |dynamic-wind| occurs within the dynamic extent\nof the call to |thunk| and then a continuation is invoked in such a\nway that the afters from these two invocations of |dynamic-wind|\nare both to be called, then the after associated with the\nsecond (inner) call to |dynamic-wind| is called first.\n\nIf a second call to |dynamic-wind| occurs within the dynamic extent\nof the call to |thunk| and then a continuation is invoked in such a\nway that the befores from these two invocations of |dynamic-wind|\nare both to be called, then the before associated with the\nfirst (outer) call to |dynamic-wind| is called first.\n\nIf invoking a continuation requires calling the |before| from one\ncall to |dynamic-wind| and the |after| from another, then the |after|\nis called first.\n\nThe effect of using a captured continuation to enter or exit the\ndynamic extent of a call to |before| or |after| is undefined.\n\n@lisp\n(let ((path '())\n      (c #f))\n  (let ((add (lambda (s)\n               (set! path (cons s path)))))\n    (dynamic-wind\n      (lambda () (add 'connect))\n      (lambda ()\n        (add (call-with-current-continuation\n               (lambda (c0)\n                 (set! c c0)\n                 'talk1))))\n      (lambda () (add 'disconnect)))\n    (if (< (length path) 4)\n        (c 'talk2)\n        (reverse path))))\n                  =>  (connect talk1 disconnect\n                       connect talk2 disconnect)\n@end lisp" :similar ())


;; Source file "compiler.stk"

(quote :type syntax :synopsis "(quote <datum>)\n'<datum>" :description "The quoting mechanism is identical to R5RS, except that keywords\nconstants  evaluate \"to themselves\" as numerical constants, string\nconstants, character constants, and boolean constants\n@lisp\n'\"abc\"     =>  \"abc\"\n\"abc\"      =>  \"abc\"\n'145932    =>  145932\n145932     =>  145932\n'#t        =>  #t\n#t         =>  #t\n:foo       =>  :foo\n':foo      =>  :foo\n@end lisp\nNOTE: R5RS requires to quote constant lists and\nconstant vectors. This is not necessary with STklos." :similar ())

(and :type syntax :synopsis "(and <test~1~> ...)" :description "The |<test~i~>| expressions are evaluated from left to right, and the\nvalue of the first expression that evaluates to a false value is\nreturned.  Any remaining expressions are not evaluated.  If all the\nexpressions evaluate to true values, the value of the last expression\nis returned.  If there are no expressions then `#t` is returned.\n\n@lisp\n  (and (= 2 2) (> 2 1))           =>  #t\n  (and (= 2 2) (< 2 1))           =>  #f\n  (and 1 2 'c '(f g))             =>  (f g)\n  (and)                           =>  #t\n@end lisp" :similar ())

(or :type syntax :synopsis "(or <test~1~> ...)" :description "The |<test~i~>| expressions are evaluated from left to right, and the\nvalue of the first expression that evaluates to a true value is\nreturned.  Any remaining expressions are not evaluated.  If all\nexpressions evaluate to false values, the value of the last expression\nis returned.  If there are no expressions then `#f` is returned.\n\n@lisp\n  (or (= 2 2) (> 2 1))            =>  #t\n  (or (= 2 2) (< 2 1))            =>  #t\n  (or #f #f #f)                   =>  #f\n  (or (memq 'b '(a b c))\n      (/ 3 0))                    =>  (b c)\n@end lisp" :similar ())

(include :type extended-syntax :synopsis "(include <string1> <string2> ...)" :description "TODO" :similar ())


;; Source file "compfile.stk"

(compile-file :type extended :synopsis "(compile-file input output)\n(compile-file input output :prepend cmds)" :description "Compiles the file whose name is |input| into a bytecode executable\nwhose name is |output| (if |compile-file| fails, |output| file is\ndeleted).\n\nIf the |:prepend| keyword argument is given, it must be a list of\nexpressions, which will be compiled before the rest of the input\nfile. This can be used to define variables that the compiled program\nwill use (but it does not affect the compiler itself).\n\n\nThis procedure will not set the executable bit on the generated file." :similar ())


;; Source file "compflags.stk"

(compiler:time-display :type extended :synopsis "(compiler:time-display)\n(compiler:time-display bool)" :description "This parameter controls if the time used for compiling a file must be\ndisplayed or not. It defaults to `#t`.\n" :similar ())

(compiler:gen-line-number :type extended :synopsis "(compiler:gen-line-number)\n(compiler:gen-line-number bool)" :description "This parameter controls if the compiled code must embed indications of\nthe file location of the  of the source expressions. When set, this\nparameter makes programs slower and bigger. However, it can be useful\nwhen debugging a program. This parameter defaults to `#f` (but is set to\n``#t` when {{stklos}} is launched in debug mode)." :similar ())

(compiler:show-assembly-code :type extended :synopsis "(compiler:show-assembly-code)\n(compiler:show-assembly-code bool)" :description "This parameter controls if the object files produced by the {{stklos}} compiler\ncode must embed a readable version of the code. The code is placed at the beginning\nof the produced file. This parameter defaults to `#f`." :similar ())

(compiler:inline-common-functions :type extended :synopsis "(compiler:inline-common-functions)\n(compiler:inline-common-functions bool)" :description "This parameter controls if the compiler must try to inline the most common Scheme\nprimitives (simple arithmetic, main list or vector functions, ...). Code produced\nwhen this parameter is set is more efficient. Note that the compiler can sometimes be\nmisleaded if those functions are redefined, hence the existence of this parameter.\n|compiler:inline-common-functions| is set by default to `#t`.\n@lisp\n> (compiler:inline-common-functions #t)\n> (disassemble-expr '(begin (car '(1 2 3)) (+ a 1)) #t)\n\n000:  CONSTANT             0\n002:  IN-CAR\n003:  GLOBAL-REF           1\n005:  IN-INCR\n006:\n\nConstants:\n0: (1 2 3)\n1: a\n@end lisp\n\n@lisp\n> (compiler:inline-common-functions #f)\n> (disassemble-expr '(begin (car '(1 2 3)) (+ a 1)) #t)\n\n000:  PREPARE-CALL\n001:  CONSTANT-PUSH        0\n003:  GREF-INVOKE          1 1\n006:  PREPARE-CALL\n007:  GLOBAL-REF-PUSH      2\n009:  ONE-PUSH\n010:  GREF-INVOKE          3 2\n013:\n\nConstants:\n0: (1 2 3)\n1: car\n2: a\n3: +\n@end lisp" :similar ())

(compiler:keep-formals :type extended :synopsis "(compiler:keep-formals)\n(compiler:keep-formals bool)" :description "This parameter controls if the formal parameters of a user procedure is kept\nat runtime. The formal parameters can be accessed with the primitive\n<<\"procedure-formals\">>.\nDefault value for |compiler:keep-formals| is `#f`.\n@lisp\n> (compiler:keep-formals #f)\n> (define (foo a b) ( + a b 1))\n> foo\n#[closure foo]\n> (procedure-formals foo)\n#f\n@end lisp\n@lisp\n> (compiler:keep-formals #t)\n> (define (foo a b) ( + a b 1))\n> foo\n#[closure foo (a b)]\n> (procedure-formals foo)\n(a b)\n@end lisp" :similar ())

(compiler:keep-source :type extended :synopsis "(compiler:keep-source)\n(compiler:keep-source bool)" :description "This parameter controls if the source of a user procedure is kept\nat runtime. The source of a procedure can be accessed with the primitive\n<<\"procedure-source\">>.\nDefault value for |compiler:keep-source| is `#f`.\n\n@lisp\n> (compiler:keep-source #t)\n> (define fib\n     (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))\n> (pretty-print (procedure-source fib))\n(lambda (n)\n  (if (< n 2)\n    n\n    (+ (fib (- n 1))\n       (fib (- n 2)))))\n@end lisp" :similar ())


;; Source file "computils.stk"

(syntax-error :type r7rs-procedure :synopsis "(syntax-error message arg1 ...)" :description "TODO" :similar ())


;; Source file "equiv.stk"


;; Source file "expand.pp"


;; Source file "ffi.stk"

(define-external :type extended-syntax :synopsis "(define-external name parameters option)" :description "The form |define-external| binds a new procedure to |name|.\nThe arity of this new procedure is defined by the typed list of\nparameters given by |parameters|. This parameters list is a list\nof keywords (as defined in the previous table) or couples whose first\nelement is the name of the parameter, and the second one is a type\nkeyword.  All the types defined in the above table, except\n|:void|, are allowed for the parameters of a foreign function.\n\n|Define-external| accepts several options:\n\n- |:return-type| is used to define the type of the value returned\nby the foreign function. The type returned must be chosen in the types specified\nin the table. For instance:\n+\n@lisp\n(define-external maximum(:int :int)\n   :return-type :int)\n@end lisp\n+\ndefines the foreign function maximum which takes two C integers and\nreturns an integer result. Omitting this option default to a result\ntype equal to |:void| (i.e. the returned value is _undefined_).\n\n- |:entry-name| is used to specify the name of the foreign\nfunction in the C world. If this option is omitted, the entry-name is\nsupposed to be |name|. For instance:\n+\n@lisp\n(define-external minimum((a :int) (b :int))\n   :return-type :int\n   :entry-name  \"min\")\n@end lisp\n+\ndefines the Scheme function |minimum| whose application\nexecutes the C function called |min|.\n\n- |:library-name| is used to specify the library which contains the\nforeign-function. If necessary, the library is loaded before calling the\nC function. So,\n+\n@lisp\n(define-external minimum((a :int) (b :int))\n   :return-type  :int\n   :entry-name   \"min\"\n   :library-name \"libminmax\")\n@end lisp\n+\ndefines a function which will execute the function |min|\nlocated in the library |libminmax.xx| (where |xx| is the suffix used\nfor shared libraries on the running system (generally |so|)).\n" :similar ())


;; Source file "library.stk"

(library-name :type extended :synopsis "(library-name lib)" :description "Returns the name of |lib| if it was defined as an R7RS library,\nand #f if the library is anonymous. If |lib| is not a library,\n|library-name| raises an error.\n\n@lisp\n(define-library (example cool-library))\n(library-name (find-module 'example/cool-library)) => (example cool-library)\n(module-name  (find-module 'example/cool-library)) => example/cool-library\n\n(define-module example/a-module)\n(library-name (find-module 'example/a-module))     => error\n\n(library-name quotient)                            => error\n@end lisp" :similar ())


;; Source file "load.stk"

(build-path-from-shell-variable :type extended :synopsis "(build-path-from-shell-variable var)\n(build-path-from-shell-variable var sep)" :description "Builds a path as a list of strings (which is the way STklos represents\npaths) from the environment variable |var|, given the separator characters\ngiven in |sep| (which defaults to `\":\"`, the standrad Unix path separator).\nIf the |var| is not definied in the environment,\n|build-path-from-shell-variable| returns the empty list.\n\nIf the shell variable `MYPATH` is \"/bin:/sbin:/usr/bin\"`, then\n@lisp\n(build-path-from-shell-variable \"MYPATH\")       => (\"/bin\" \"/sbin\" \"/usr/bin\")\n(build-path-from-shell-variable \"MYPATH\" \"/:\")  => (\"bin\" \"sbin\" \"usr\" \"bin\")\n@end lisp" :similar ())

(load-path :type extended :synopsis "(load-path)\n(load-path value)" :description "|load-path| is a parameter object. It\nreturns the current load path. The load path is a list of strings\nwhich correspond to the directories in which a file must be searched for\nloading. Directories of the load path are ,(emph \"prepended\") (in\ntheir apparition\norder) to the file name given to |load| or |try-load| until the file\ncan be loaded.\n@l\nThe initial value of the current load path can be set from the shell, by\nsetting the |STKLOS_LOAD_PATH| shell variable.\n@l\nGiving a |value| to the parameter |load-path| permits to change the\ncurrent list of paths." :similar ())

(load-suffixes :type extended :synopsis "(load-suffixes)\n(load-suffixes value)" :description "|load-suffixes| is a parameter object. It\nreturns the list of possible suffixes for a Scheme file. Each suffix,\nmust be a string. Suffixes are appended (in their apparition order)\nto a file name  is appended to a file name given to |load| or |try-load|\nuntil the file can be loaded." :similar ())

(load-verbose :type extended :synopsis "(load-verbose)\n(load-verbose value)" :description "|load-verbose| is a parameter object. It permits to display the\npath name of the files which are loaded by |load| or |try-load| on\nthe current error port, when set to a true value. If |load-verbose|\nis set to `#f`, no message is printed." :similar ())

(current-loading-file :type extended :synopsis "(current-loading-file)" :description "Returns the path of the file that is currently being load." :similar ())

(find-path :type extended :synopsis "(find-path str)\n(find-path str path)\n(find-path str path suffixes)" :description "In its first form, |find-path| returns the path name of the file\nthat should be loaded by the procedure  |load| given the name |str|.\nThe string returned depends of the current  load path and of the\ncurrently accepted suffixes.\n@l\nThe other forms of |find-path| are more general and allow to give a path\nlist (a list of strings representing supposed directories) and a set\nof suffixes (given as a list of strings too) to try for finding a file.\nIf no file is found, |find-path| returns `#f`.\n@l\nFor instance, on a \"classical\" Unix box:\n@lisp\n(find-path \"passwd\" '(\"/bin\" \"/etc\" \"/tmp\"))\n            => \"/etc/passwd\"\n(find-path \"stdio\" '(\"/usr\" \"/usr/include\") '(\"c\" \"h\" \"stk\"))\n            => \"/usr/include/stdio.h\"\n@end lisp" :similar ())

(provided? :type extended :synopsis "(require string)\n(provide string)\n(require/provide string)\n(provided? string)" :description "|Require| loads the file whose name is |string| if it was not\npreviously \"_provided_\". |Provide| permits to store |string| in\nthe list of already provided files. Providing a file permits to avoid\nsubsequent loads of this file. |Require/provide| is more or less equivalent to\na |require| followed by a |provide|. |Provided?| returns `#t` if\n|string| was already provided; it returns `#f` otherwise." :similar (require/provide provide require))

(require/provide :see provided?)
(provide :see provided?)
(require :see provided?)
(require-for-syntax :type extended :synopsis "(require-for-syntax string)" :description "" :similar ())

(autoload :type extended :synopsis "(autoload file symbol ...)" :description "TODO\n" :similar ())


;; Source file "logical.stk"

(bit-shift :type extended :synopsis "(bit-and n1 n2 ...)\n(bit-or n1 n2 ...)\n(bit-xor n1 n2 ...)\n(bit-not n)\n(bit-shift n m)" :description "These procedures allow the manipulation of integers as bit fields.\nThe integers can be of arbitrary length. |Bit-and|, |bit-or| and\n|bit-xor| respectively compute the bitwise ,(emph \"and\"), inclusive and\nexclusive ,(emph \"or\"). |bit-not| returns the bitwise ,(emph \"not\") of |n|.\n|bit-shift| returns the bitwise ,(emph \"shift\") of |n|. The integer |n|\nis shifted left by |m| bits; If |m| is negative, |n| is shifted right by\n|-m| bits.\n\n@lisp\n(bit-or 5 3)       => 7\n(bit-xor 5 3)      => 6\n(bit-and 5 3)      => 1\n(bit-not 5)        => -6\n(bit-or 1 2 4 8)   => 15\n(bit-shift 5 3)    => 40\n(bit-shift 5 -1)   => 2\n@end lisp" :similar (bit-not bit-xor bit-or bit-and))

(bit-not :see bit-shift)
(bit-xor :see bit-shift)
(bit-or :see bit-shift)
(bit-and :see bit-shift)

;; Source file "mbe.stk"

(define-syntax :type syntax :synopsis "(define-syntax <identifier> <transformer-spec>)" :description "|<Define-syntax>|  extends the top-level syntactic environment by binding\nthe |<identifier>| to the specified transformer.\n\nNOTE: |<transformer-spec>| should be an instance of |syntax-rules|.\n@lisp\n(define-syntax let*\n  (syntax-rules ()\n    ((let* () body1 body2 ...)\n     (let () body1 body2 ...))\n    ((let* ((name1 val1) (name2 val2) ...)\n       body1 body2 ...)\n     (let ((name1 val1))\n       (let* (( name2 val2) ...)\n         body1 body2 ...))))\n@end lisp" :similar ())

(syntax-rules :type syntax :synopsis "(syntax-rules <literals> <syntax-rule> ...)" :description "|<literals>| is a list of identifiers, and each |<syntax-rule>| should be of\nthe form\n@lisp\n(pattern template)\n@end lisp\n\nAn instance of |<syntax-rules>| produces a new macro transformer by\nspecifying a sequence of hygienic rewrite rules. A use of a macro\nwhose name is associated with a transformer specified by\n<syntax-rules> is matched against the patterns contained in the\n<syntax-rules>, beginning with the leftmost syntax-rule. When a match is\nfound, the macro use is transcribed hygienically according to the\ntemplate.\n@l\nEach pattern begins with the name for the macro. This name is not\ninvolved in the matching and is not considered a pattern variable or\nliteral identifier.\n@l\nNOTE: For a complete description of the Scheme pattern language,\nrefer to R5RS." :similar ())


;; Source file "module.stk"

(module-symbols* :type extended :synopsis "(module-symbols+++*+++ module)" :description "Returns the the list of symbols acessible in |module| (that is the symbols\ndefined in |module| and the one defined in the |STklos| module if module\nis not a R7RS library." :similar ())

(select-module :type extended-syntax :synopsis "(select-module <name>)" :description "Changes the value of the current module to the module with the given |name|.\nThe expressions evaluated after |select-module| will take place in\nmodule |name| environment.  Module |name| must have been created\npreviously by a |define-module|. The result of |select-module| is\n*_void_*.\n|Select-module| is particularly useful when debugging since it\nallows to place toplevel evaluation in a particular module. The\nfollowing transcript shows an usage of |select-module|.\nfootnote:[This transcript uses the default toplevel loop\n            which displays the name of the current module in the evaluator\n            prompt.]):\n@lisp\nstklos> (define foo 1)\nstklos> (define-module bar\n          (define foo 2))\nstklos> foo\n1\nstklos> (select-module bar)\nbar> foo\n2\nbar> (select-module stklos)\nstklos>\n@end lisp" :similar ())

(define-module :type extended-syntax :synopsis "(define-module <name> <expr1> <expr2> ...)" :description "|Define-module| evaluates the expressions |<expr1>|, |<expr2>| ... which\nconstitute the body of the module |<name>| in the environment of that module.\n|Name| must be a valid symbol. If this symbol has not already been used to\ndefine a module, a new module, named |name|, is created.\nOtherwise, the expressions |<expr1>|, |<expr2>| ... are evaluated in\nthe environment of the (old) module `|<name>|`footnote:[In fact\n|define-module| on a given name defines a new module\nonly the first time it is invoked on this name. By this way, interactively\nreloading a module does not define a new entity, and the other modules\nwhich use it are not altered.]\n\nDefinitions done in a module are local to the module and do not interact with\nthe definitions in other modules. Consider the following definitions,\n@lisp\n(define-module M1\n   (define a 1))\n\n(define-module M2\n  (define a 2)\n  (define b (* 2 x)))\n@end lisp\n\nHere, two modules are defined and they both bind the symbol |a| to a\nvalue. However, since |a| has been defined in two distinct modules\nthey denote two different locations.\n\nThe |STklos| module, which is predefined, is a special module which\ncontains all the *global bindings* of a R5RS program.  A symbol\ndefined in the |STklos| module, if not hidden by a local definition, is\nalways visible from inside a module. So, in the previous exemple, the\n|x| symbol refers the |x| symbol defined in the |STklos| module.\n\nThe result of |define-module| is *_void_*." :similar ())

(import :type extended-syntax :synopsis "(import <module1> <module2> ...)" :description "Specifies the modules which are imported by the current module.\nImporting a module makes the symbols it exports visible to the\nimporter, if not hidden by local definitions. When a symbol\nis exported by several of the imported modules, the location denoted by\nthis symbol in the importer module correspond to the one of the last module\nin the list\n@lisp\n(<module1> <module2> ...)\n@end lisp\nwhich exports it.\n\nIf several |import| clauses appear in a module, the set of\nimported modules  is determined by appending the various list of modules\nin their apparition order.\n\n@lisp\n(define-module M1\n  (export a b)\n  (define a 'M1-a)\n  (define b 'M1-b))\n\n(define-module M2\n  (export b c d)\n  (define b 'M2-b)\n  (define c 'M2-c)\n  (define d 'M2-d))\n\n(define-module M3\n  (import M1 M2)\n  (display (list a b c d)))  @print{} (M1-a M2-b M2-c M2-d)\n\n(define-module M4\n  (import M2 M1)\n  (display (list a b c d)))  @print{} (M1-a M1-b M2-c M2-d)\n@end lisp\n\nIt is also possible to import partially (i.e. not all\nexported symbols) from a module, as shown below:\n@lisp\n(define-module M5\n  (import (M2 c d) M1)\n  (display (list a b c d)))  @print{} (M1-a M1-b M2-c M2-d)\n@end lisp\nIn this case, only the symbols |c| and |d| are imported from\nmodule |M2|.\n\nNOTE: Importations are not \"_transitive_\": when\nthe module -C_ imports the module _B_ which is an importer\nof module _A_ the symbols of _A_ are not visible\nfrom _C_, except  by explicitly importing the _A_ module from _C_.\n\nNOTE: The module |STklos|, which contains the _global variables_\nis always implicitly imported from a module. Furthermore,\nthis module is always placed at the end of the list of imported modules." :similar ())

(export :type extended-syntax :synopsis "(export <symbol1> <symbol2> ...)" :description "Specifies the symbols which are exported (i.e. *visible* outside\nthe current module). By default, symbols defined in a module are not\nvisible outside this module, excepted if they appear in an |export|\nclause.\n\nIf several |export| clauses appear in a module, the set of\nexported symbols is determined by \"_unionizing_\" symbols exported\nin all the |export| clauses.\n\nThe result of |export| is *_void_*." :similar ())

(in-module :type extended-syntax :synopsis "(in-module mod s)\n(in-module mod s default)" :description "This form returns the value of symbol with name |s| in the module with name\n|mod|. If this symbol is not bound,  an error is signaled if no |default| is\nprovided, otherwise |in-module| returns |default|. Note that the value of |s|\nis searched in |mod| and all the modules it imports.\n\nThis form is in fact a shortcut. In effect,\n@lisp\n(in-module my-module foo)\n@end lisp\n\nis equivalent to\n@lisp\n(symbol-value* 'foo (find-module 'my-module))\n@end lisp" :similar ())


;; Source file "object.stk"

(is-a? :type extended :synopsis "(is-a? obj class)" :description "Returns `#t` if |obj| is an instance of |class|, and `#f` otherwise." :similar ())

(find-class :type extended :synopsis "(find-class name)\n(find-class name default)" :description "Returns the class whose name is equal to symbol |name|. If |name| is not\na class instance, the |default| value is returned, if present." :similar ())

(define-class :type extended-syntax :synopsis "(define-class name supers slots . options)" :description "Creates a class whose name is |name|, and whose superclasses are in the\nlist |supers|, with the slots specified by the list |slots|.\n\nAs an example, this is the definition of a point:\n@lisp\n(define-class <point> ()\n  (x y))\n@end lisp\n\nIn another example, a class |<circle>| that inherits |<point>|.\n@lisp\n(define-class <circle> (<point>)\n  (radius))\n@end lisp\n\nThe following options can be passed to slots:\n\n- |:init-form| is the default value for the slot.\n- |:init-keyword| is the keyword for initializing the slot.\n- |:getter| is the name of the getter method.\n- |:setter| is the name of the setter method.\n- |:accessor| is the name of the accessor (setter and getter) method.\n\n\nFor example,\n@lisp\n(define-class <point> ()\n  (x :init-form 0 :getter get-x :setter set-x! :init-keyword :x)\n  (y :init-form 0 :getter get-y :setter set-y! :init-keyword :y))\n@end lisp\n\n{{stklos}} also defines setters for the specified getters, so the following\nwill work with the definition of |<point>| given above:\n\n@lisp\n(set! (slot-ref my-point 'x) 50)\n@end lisp\n\nAccessors, are methods which can be used as getter and setter, as shown bellow\n\n@lisp\n(define-class <circle> (<point>)\n  ((radius :accessor radius :init-keyword :radius)))\n\n(define x (make <circle> :radius 100))\n(radius x)                             => 100\n(set! (radius x) 200)\n(radius x)                             => 200\n@end lisp" :similar ())


;; Source file "obsolete.stk"


;; Source file "peephole.stk"


;; Source file "process.stk"

(run-process :type extended :synopsis "(run-process command p1 p2 ...)" :description "|run-process| creates a new process and run the executable\nspecified in |command|. The |p| correspond to the command line\narguments. The following values of |p| have a special meaning:\n\n- |:input| permits to redirect the standard input file of the\nprocess. Redirection can come from a file or from a pipe. To redirect\nthe standard input from a file, the name of this file must be\nspecified after |:input|. Use the special keyword |:pipe| to\nredirect the standard input from a pipe.\n\n- |:output| permits to redirect the standard output file of the\nprocess. Redirection can go to a file or to a pipe. To redirect\nthe standard output to a file, the name of this file must be\nspecified after |:output|. Use the special keyword |:pipe| to\nredirect the standard output to a pipe.\n\n- |:error| permits to redirect the standard error file of the\nprocess. Redirection can go to a file or to a pipe. To redirect\nthe standard error to a file, the name of this file must be\nspecified after |error|. Use the special keyword |:pipe| to\nredirect the standard error to a pipe.\n\n- |:wait| must be followed by a boolean value. This value\nspecifies if the process must be run asynchronously or not. By\ndefault, the process is run asynchronously (i.e. |:wait| is `#f`).\n\n- |:host| must be followed by a string. This string represents\nthe name of the machine on which the command must be executed. This\noption uses the external command |rsh|. The shell variable\n|PATH| must be correctly set for accessing it without specifying its\nabolute path.\n\n- |:fork| must be followed by a boolean value. This value\nspecifies if a _fork\"_ system call must be done before running\nthe process. If the process is run without _fork_ the Scheme\nprogram is lost. This feature mimics the ``|exec|'' primitive of the\nUnix shells. By default, a fork is executed before running the process\n(i.e. |:fork| is `#t`). This option works on Unix implementations only.\n\n\nThe following example launches a process which executes the\nUnix command |ls| with the arguments |-l| and |/bin|. The lines\nprinted by this command are stored in the file |/tmp/X|\n@lisp\n(run-process \"ls\" \"-l\" \"/bin\" :output \"/tmp/X\")\n@end lisp" :similar ())

(process-kill :type extended :synopsis "(process-kill proc)" :description "Kills (brutally) |process|. The result of |process-kill|\nis _void_. This procedure is equivalent to\n@lisp\n(process-send-signal process SIGTERM)\n@end lisp" :similar ())

(process-continue :type extended :synopsis "(process-stop proc)\n(process-continue proc)" :description "|Process-stop| stops the execution of |proc| and |process-continue| resumes\nits execution. They are equivalent, respectively, to\n@lisp\n(process-send-signal process SIGSTOP)\n(process-send-signal process SIGCONT)\n@end lisp" :similar (process-stop))

(process-stop :see process-continue)

;; Source file "r5rs.stk"

(lambda :type extended-syntax :synopsis "(lambda <formals> <body>)" :description "A lambda expression evaluates to a procedure. STklos lambda expression\nhave been extended to allow a optional and keyword parameters.\n|<formals>| should have one of the following forms:\n\n`(<variable~1~> ...)`:: The procedure takes a fixed number of arguments;\nwhen the procedure is called, the arguments will be stored in the\nbindings of the corresponding variables.  This form is identical to\nR5RS.\n\n`<variable>`:: The procedure takes any number of arguments; when the\nprocedure is called, the sequence of actual arguments is converted into\na newly allocated list, and the list is stored in the binding of the\n|<variable>|. This form is identical to R5RS.\n\n`(<variable~1~> ... <variable~n~> . <variable~n+1~>)`:: If a space-delimited\nperiod precedes the last variable, then the procedure takes n or more\n arguments, where n is the number of formal arguments before the period\n(there must be at least one). The value stored in the binding of the\nlast variable will be a newly allocated list of the actual arguments left\nover after all the other actual arguments have been matched up against\nthe other formal arguments. This form is identical to R5RS.\n\n\n`(<variable~1~ ... <variable~n~> [:optional ...] [:rest ...] [:key ...])`::\nThis form is specific to STklos and allows to have procedure with\noptional and keyword parameters. The form |:optional| allows to specify\noptional parameters. All the parameters specified after |:optional| to the end\nof |<formals>| (or until a |:rest| or |:key|) are optional parameters. An\noptional parameter can declared as:\n\n** |variable|: if a value is passed when the procedure is called, it will be\nstored in the binding of the corresponding variable, otherwise the value `#f`\nwill be stored in it.\n\n** |(variable value)|: if a value is passed when the procedure is called, it\nwill be stored in the binding of the corresponding variable, otherwise |value|\nwill be stored in it.\n\n** |(variable value test?)|: if a value is passed when the procedure is called, it\nwill be stored in the binding of the corresponding variable, otherwise |value|\nwill be stored in it. Furthermore, |test?| will be given the value `#t` if\na value is passed for the given variable, otherwise |test?| is set to `#f`.\n\nHereafter are some examples using |:optional| parameters\n@lisp\n((lambda (a b :optional c d) (list a b c d)) 1 2)\n                            => (1 2 #f #f)\n((lambda (a b :optional c d) (list a b c d)) 1 2 3)\n                            => (1 2 3 #f)\n((lambda (a b :optional c (d 100)) (list a b c d)) 1 2 3)\n                            => (1 2 3 100)\n((lambda (a b :optional c (d #f d?)) (list a b c d d?)) 1 2 3)\n                            => (1 2 3 #f #f)\n@end lisp\nThe form |:rest| parameter is similar to the dot notation seen before.\nIt is used before an identifier to collects the parameters in a single\nbinding:\n@lisp\n((lambda (a :rest b) (list a b)) 1)\n                            => (1 ())\n((lambda (a :rest b) (list a b)) 1 2)\n                            => (1 (2))\n((lambda (a :rest b) (list a b)) 1 2 3)\n                            => (1 (2 3))\n@end lisp\nThe form |:key| allows to use keyword parameter passing. All the parameters\nspecified after |:key| to the end of |<formals>| are keyword parameters. A\nkeyword  parameter can be declared using the three forms given for optional\nparameters. Here are some examples illustrating how to declare and how to use\nkeyword parameters:\n@lisp\n((lambda (a :key b c) (list a b c)) 1 :c 2 :b 3)\n                            => (1 3 2)\n((lambda (a :key b c) (list a b c)) 1 :c 2)\n                            => (1 #f 2)\n((lambda (a :key (b 100 b?) c) (list a b c b?)) 1 :c 2)\n                            => (1 100 2 #f)\n@end lisp\n\nAt last, here is an example showing |:optional| |:rest| and |:key| parameters\n@lisp\n(define f (lambda (a :optional b :rest c :key d e)\n             (list a b c d e)))\n\n(f 1)                       => (1 #f () #f #f)\n(f 1 2)                     => (1 2 () #f #f)\n(f 1 2 :d 3 :e 4)           => (1 2 (:d 3 :e 4) 3 4)\n(f 1 :d 3 :e 4)             => (1 #f (:d 3 :e 4) 3 4)\n@end lisp" :similar ())

(set! :type syntax :synopsis "(set! <variable> <expression>)\n(set! (<proc> <arg> ...) <expression>)" :description "The first form of |set!| is the R5RS one:\n\n|<Expression>| is evaluated, and the resulting value is stored in\nthe location to which |<variable>| is bound. |<Variable>| must be bound\neither in some region enclosing the |set!| expression or at top level.\n\n@lisp\n(define x 2)\n(+ x 1)                   =>  3\n(set! x 4)                =>  unspecified\n(+ x 1)                   =>  5\n@end lisp\n\nThe second form of |set!| is defined in {{link-srfi 17}}:\n\nThis special form |set!|\nis extended so the first operand can be a procedure application, and not\njust a variable. The procedure is typically one that extracts a component\nfrom some data structure. Informally, when the procedure is called in the\nfirst operand of |set!|, it causes the corresponding component to be\nreplaced by the second operand. For example,\n@lisp\n(set (vector-ref x i) v)\n@end lisp\nwould be equivalent to:\n@lisp\n(vector-set! x i v)\n@end lisp\n\nEach procedure that may be used as the first operand to |set!| must have\na corresponding *_setter_* procedure. The procedure |setter| (see below)\ntakes a procedure and returns the corresponding setter procedure.\nSo,\n@lisp\n(set! (proc arg ...) value)\n@end lisp\nis equivalent to the call\n@lisp\n((setter proc) arg ... value)\n@end lisp\n\nThe result of the |set!| expression is unspecified." :similar ())

(if :type syntax :synopsis "(if <test> <consequent> <alternate>)\n(if <test> <consequent>)" :description "An |if| expression is evaluated as follows: first, |<test>| is\nevaluated.  If it yields a true value, then |<consequent>| is\nevaluated and its value(s) is(are) returned.  Otherwise |<alternate>|\nis evaluated and its value(s) is(are) returned.  If |<test>| yields a\nfalse value and no |<alternate>| is specified, then the result of the\nexpression is *_void_*.\n\n@lisp\n  (if (> 3 2) 'yes 'no)           =>  yes\n  (if (> 2 3) 'yes 'no)           =>  no\n  (if (> 3 2)\n      (- 3 2)\n      (+ 3 2))                    =>  1\n@end lisp" :similar ())

(cond :type syntax :synopsis "(cond <clause1> <clause2> ...)" :description "In a |cond|, each |<clause>| should be of the form\n\n@lisp\n(<test> <expression1> ...)\n@end lisp\n\nwhere |<test>| is any expression.  Alternatively, a |<clause>| may be\nof the form\n\n@lisp\n(<test> => <expression>)\n@end lisp\n\nThe last |<clause>| may be an \"else clause,\" which has the form\n@lisp\n(else <expression1> <expression2> ...)\n@end lisp\n\nA cond expression is evaluated by evaluating the |<test>| expressions\nof successive ``<clause>``s in order until one of them evaluates to a\ntrue value When a |<test>| evaluates to a true value, then the\nremaining ``<expression>``s in its |<clause>| are evaluated in order,\nand the result(s) of the last |<expression>| in the |<clause>| is(are)\nreturned as the result(s) of the entire cond expression.  If the\nselected |<clause>| contains only the |<test>| and no |<expression>|s,\nthen the value of the |<test>| is returned as the result.  If the\nselected |<clause>| uses the `=>` alternate form, then the\n|<expression>| is evaluated.  Its value must be a procedure that\naccepts one argument; this procedure is then called on the value of\nthe |<test>| and the value(s) returned by this procedure is(are)\nreturned by the cond expression.\n\nIf all `|<test>|`s evaluate to false\nvalues, and there is no else clause, then the result of the\nconditional expression is *_void_*; if there is an else clause,\nthen its `|<expression>|`s are evaluated, and the value(s) of the last\none is(are) returned.\n\n@lisp\n  (cond ((> 3 2) 'greater)\n        ((< 3 2) 'less))                    =>  greater\n\n  (cond ((> 3 3) 'greater)\n        ((< 3 3) 'less)\n        (else 'equal))                      =>  equal\n\n  (cond ((assv 'b '((a 1) (b 2))) => cadr)\n        (else #f))                          =>  2\n@end lisp" :similar ())

(case :type r7rs-syntax :synopsis "(case <key> <clause1> <clause2> ...)" :description "In a |case|, each |<clause>| should have the form\n\n@lisp\n((<datum1> ...) <expression1> <expression2> ...),\n@end lisp\n\nwhere each |<datum>| is an external representation of some object.  All the\n|<datum>|s must be distinct.  The last |<clause>| may be an \"else clause,\" which\nhas the form\n\n@lisp\n    (else <expression1> <expression2> ...).\n@end lisp\n\nA case expression is evaluated as follows. |<Key>| is evaluated and\nits result is compared against each |<datum>|.  If the result of\nevaluating |<key>| is equivalent (in the sense of eqv?) to a\n|<datum>|, then the expressions in the corresponding |<clause>| are\nevaluated from left to right and the result(s) of the last expression\nin the |<clause>| is(are) returned as the result(s) of the case\nexpression.  If the result of evaluating |<key>| is different from\nevery |<datum>|, then if there is an else clause its expressions are\nevaluated and the result(s) of the last is(are) the result(s) of the\ncase expression; otherwise the result of the case expression is *_void_*.\n\nIf the selected |<clause>| or else clause uses the |=>| alternate\nform, then the |expression| is evaluated. It is an error if\nits value is not a procedure accepting one argument. This\nprocedure is then called on the value of the hkeyi and the\nvalues returned by this procedure are returned by the case\nexpression.\n\n@lisp\n  (case (* 2 3)\n    ((2 3 5 7) 'prime)\n    ((1 4 6 8 9) 'composite))     =>  composite\n  (case (car '(c d))\n    ((a) 'a)\n    ((b) 'b))                     =>  void\n  (case (car '(c d))\n    ((a e i o u) 'vowel)\n    ((w y) 'semivowel)\n    (else 'consonant))            =>  consonant\n  (case (car '(c d))\n    ((a e i o u) 'vowel)\n    ((w y) 'semivowel)\n    (else  => (lambda (x) (x))))  =>  c\n@end lisp\n" :similar ())

(when :type extended-syntax :synopsis "(when <test> <expression1> <expression2> ...)" :description "If the |<test>| expression yields a true value, the `|<expression>|`s are\nevaluated from left to right and the value of the last |<expression>| is\nreturned. Otherwise, |when| returns *_void_*." :similar ())

(unless :type extended-syntax :synopsis "(unless <test> <expression1> <expression2> ...)" :description "If the |<test>| expression yields a false value, the `|<expression>|`s are\nevaluated from left to right and the value of the last |<expression>| is\nreturned. Otherwise, |unless| returns *_void_*." :similar ())

(let :type syntax :synopsis "(let <bindings> <body>)\n(let <variable> <bindings> <body>)" :description "In a |let|, |<bindings>| should have the form\n\n@lisp\n((<variable1> <init1>) ...)\n@end lisp\n\nwhere each |<init~i~>| is an expression, and |<body>| should be a sequence of one or\nmore expressions.  It is an error for a |<variable>| to appear more than once in\nthe list of variables being bound.\n\nThe `|<init>|`s are evaluated in the current environment (in some\nunspecified order), the `|<variable>|`s are bound to fresh locations holding the\nresults, the |<body>| is evaluated in the extended environment, and the value(s)\nof the last expression of |<body>| is(are) returned.  Each binding of a\n|<variable>| has |<body>| as its region.\n\n@lisp\n(let ((x 2) (y 3))\n  (* x y))                      =>  6\n\n(let ((x 2) (y 3))\n  (let ((x 7)\n        (z (+ x y)))\n    (* z x)))                   =>  35\n@end lisp\n\nThe second form of |let|, which is generally called a *_named let_*,\nis a variant on the syntax of let which provides a more general\nlooping construct than |do| and may also be used to\nexpress recursions. It has the same syntax and semantics as ordinary\nlet except that |<variable>| is bound within |<body>| to a procedure whose\nformal arguments are the bound variables and whose body is |<body>|.\nThus the execution of |<body>| may be repeated by invoking the procedure\nnamed by |<variable>|.\n\n@lisp\n(let loop ((numbers '(3 -2 1 6 -5))\n           (nonneg  '())\n           (neg     '()))\n  (cond ((null? numbers) (list nonneg neg))\n        ((>= (car numbers) 0)\n           (loop (cdr numbers)\n                 (cons (car numbers) nonneg)\n                 neg))\n        ((< (car numbers) 0)\n           (loop (cdr numbers)\n                  nonneg\n                  (cons (car numbers) neg)))))\n   =>  ((6 1 3) (-5 -2))\n@end lisp" :similar ())

(let* :type syntax :synopsis "(let* <bindings> <body>)" :description "In a |let*|, |<bindings>| should have the same form as in a |let| (however, a\n<variable> can appear more than once in the list of variables being bound).\n@l\n|Let*| is similar to |let|, but the bindings are performed sequentially\nfrom left to right, and the region of a binding indicated by\n@lisp\n(<variable> <init>)\n@end lisp\nis that part of the |let*| expression to the right of the binding.  Thus\nthe second binding is done in an environment in which the first binding is\nvisible, and so on.\n\n@lisp\n(let ((x 2) (y 3))\n  (let* ((x 7)\n         (z (+ x y)))\n    (* z x)))             =>  70\n@end lisp" :similar ())

(letrec :type syntax :synopsis "(letrec <bindings> <body>)" :description "<bindings> should have the form as in |let|.\n\nThe `|<variable>|`s are bound to fresh locations holding undefined\nvalues, the `|<init>|`s are evaluated in the resulting environment (in\nsome unspecified order), each |<variable>| is assigned to the result\nof the corresponding |<init>|, the |<body>| is evaluated in the\nresulting environment, and the value(s) of the last expression in\n|<body>| is(are) returned.  Each binding of a |<variable>| has the\nentire |letrec| expression as its region, making it possible to define\nmutually recursive procedures.\n\n@lisp\n(letrec ((even? (lambda (n)\n                  (if (zero? n)\n                      #t\n                      (odd? (- n 1)))))\n         (odd?  (lambda (n)\n                  (if (zero? n)\n                      #f\n                      (even? (- n 1))))))\n  (even? 88))\n                  =>  #t\n@end lisp" :similar ())

(begin :type syntax :synopsis "(begin <expression1> <expression2> ...)" :description "The `|<expression>|`s are evaluated sequentially from left to right, and the\nvalue(s) of the last |<expression>| is(are) returned.  This expression type is\nused to sequence side effects such as input and output.\n\n@lisp\n  (define x 0)\n\n  (begin (set! x 5)\n         (+ x 1))                  =>  6\n\n  (begin (display \"4 plus 1 equals \")\n         (display (+ 4 1)))        @print{} 4 plus 1 equals 5\n                                   =>  void\n@end lisp" :similar ())

(do :type syntax :synopsis "(do [[<var1> <init1> <step1>] ...] [<test> <expr> ...] <command> ...)" :description "|Do| is an iteration construct.  It specifies a set of variables to be\nbound, how they are to be initialized at the start, and how they are\nto be updated on each iteration.  When a termination condition is met,\nthe loop exits after evaluating the `|<expr>|`s.\n\n|Do| expressions are evaluated as follows: The |<init>| expressions\nare evaluated (in some unspecified order), the `|<var>|`s are bound\nto fresh locations, the results of the |<init>| expressions are stored\nin the bindings of the `|<var>|`s, and then the iteration phase\nbegins.\n\nEach iteration begins by evaluating |<test>|; if the result is false\nthen the |<command>| expressions are evaluated in order for effect,\nthe |<step>| expressions are evaluated in some unspecified order, the\n`|<var>|`s are bound to fresh locations, the results of the `|<step>|`s\nare stored in the bindings of the `|<var>|`s, and the next iteration\nbegins.\n\nIf |<test>| evaluates to a true value, then the `|<expr>|`s are\nevaluated from left to right and the value(s) of the last |<expr>|\nis(are) returned.  If no `|<expr>|`s are present, then the value of\nthe do expression is *_void_*.\n\nThe region of the binding of a |<var>| consists of the entire do\nexpression except for the `|<init>|`s.  It is an error for a |<var>| to\nappear more than once in the list of do variables.\n\nA |<step>| may be omitted, in which case the effect is the same as if\n@lisp\n(<var> <init> <var>)\n@end lisp\nhad been written.\n\n@lisp\n  (do ((vec (make-vector 5))\n       (i 0 (+ i 1)))\n      ((= i 5) vec)\n    (vector-set! vec i i))            =>  #(0 1 2 3 4)\n\n  (let ((x '(1 3 5 7 9)))\n    (do ((x x (cdr x))\n         (sum 0 (+ sum (car x))))\n        ((null? x) sum)))             =>  25\n@end lisp" :similar ())

(quasiquote :type syntax :synopsis "(quasiquote <template>)\n`<template>" :description "\"Backquote\" or \"quasiquote\" expressions are useful for constructing a\nlist or vector structure when most but not all of the desired structure\nis known in advance.  If no commas appear within the |<template>|,\nthe result of evaluating |`<template>| is equivalent to the result of\nevaluating |'<template>|.  If a comma appears within the\n|<template>|, however, the expression following the comma is evaluated\n(\"unquoted\") and its result is inserted into the structure instead of\nthe comma and the expression.  If a comma appears followed immediately\nby an at-sign (@), then the following expression must evaluate to a\nlist; the opening and closing parentheses of the list are then\n\"stripped away\" and the elements of the list are inserted in place of the comma\nat-sign expression sequence.  A comma at-sign should only appear within\na list or vector |<template>|.\n\n@lisp\n`(list ,(+ 1 2) 4)  =>  (list 3 4)\n(let ((name 'a)) `(list ,name ',name))\n                    =>  (list a (quote a))\n`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)\n                    =>  (a 3 4 5 6 b)\n`((foo ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))\n                    =>  ((foo 7) . cons)\n`#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)\n                    =>  #(10 5 2 4 3 8)\n@end lisp\n\nQuasiquote forms may be nested.  Substitutions are made only for unquoted\ncomponents appearing at the same nesting level as the outermost backquote.\nThe nesting level increases by one inside each successive quasiquotation,\nand decreases by one inside each unquotation.\n\n@lisp\n`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)\n          =>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)\n(let ((name1 'x)\n      (name2 'y))\n  `(a `(b ,,name1 ,',name2 d) e))\n          =>  (a `(b ,x ,'y d) e)\n@end lisp\n\nThe two notations |`<template>| and |(quasiquote <template>)| are identical\nin all respects.  |,<expression>| is identical to |(unquote <expression>)|, and\n|,@<expression>| is identical to |(unquote-splicing <expression>)|.\n" :similar ())

(define-macro :type extended-syntax :synopsis "(define-macro (<name> <formals>) <body>)\n(define-macro <name> (lambda <formals> <body>))" :description "|define-macro| can be used to define low-level macro\n(i.e. ,(emph \"non hygienic\") macros). This form is similar to the\n|defmacro| form of Common Lisp.\n@lisp\n(define-macro (incr x) `(set! ,x (+ ,x 1)))\n(let ((a 1)) (incr a) a)   => 2\n\n(define-macro (when test . body)\n  `(if ,test ,@(if (null? (cdr body)) body `((begin ,@body)))))\n(macro-expand '(when a b)) => (if a b)\n(macro-expand '(when a b c d))\n                           => (if a (begin b c d))\n\n(define-macro (my-and . exprs)\n  (cond\n   ((null? exprs)        #t)\n   ((= (length exprs) 1) (car exprs))\n   (else                 `(if ,(car exprs)\n                           (my-and ,@(cdr exprs))\n                           #f))))\n(macro-expand '(my-and a b c))\n                          => (if a (my-and b c) #f)\n@end lisp" :similar ())

(eval :type procedure :synopsis "(eval expression environment)\n(eval expression)" :description "Evaluates expression in the specified environment and returns its\nvalue. |Expression| must be a valid Scheme expression represented\nas data. |Environment| may be a R5RS environment-specifier\n(|interaction-environment|, |scheme-report-environment| or\n|null-environment|) or a {{stklos}} module.\n@lisp\n(eval '(* 7 3) (scheme-report-environment 5))\n              => 21\n(let ((f (eval '(lambda (f x) (f x x))\n               (null-environment 5))))\n  (f + 10))\n              => 20\n(define-module A\n  (define x 1))\n(eval '(cons x x) (find-module 'A))\n              => (1 . 1)\n@end lisp" :similar ())

(cddddr :type procedure :synopsis "(caar pair)\n(cadr pair)\n...\n(cdddar pair)\n(cddddr pair)" :description "These procedures are compositions of |car| and |cdr|, where for example\n|caddr| could be defined by\n@lisp\n   (define caddr (lambda (x) (car (cdr (cdr x)))))\n@end lisp\nArbitrary compositions, up to four deep, are provided.\nThere are twenty-eight of these procedures in all." :similar (cadddr cdaddr caaddr cddadr cadadr cdaadr caaadr cdddar caddar cdadar caadar cddaar cadaar cdaaar caaaar cdddr caddr cdadr caadr cddar cadar cdaar caaar cddr cadr cdar caar))

(cadddr :see cddddr)
(cdaddr :see cddddr)
(caaddr :see cddddr)
(cddadr :see cddddr)
(cadadr :see cddddr)
(cdaadr :see cddddr)
(caaadr :see cddddr)
(cdddar :see cddddr)
(caddar :see cddddr)
(cdadar :see cddddr)
(caadar :see cddddr)
(cddaar :see cddddr)
(cadaar :see cddddr)
(cdaaar :see cddddr)
(caaaar :see cddddr)
(cdddr :see cddddr)
(caddr :see cddddr)
(cdadr :see cddddr)
(caadr :see cddddr)
(cddar :see cddddr)
(cadar :see cddddr)
(cdaar :see cddddr)
(caaar :see cddddr)
(cddr :see cddddr)
(cadr :see cddddr)
(cdar :see cddddr)
(caar :see cddddr)
(with-output-to-file :type procedure :synopsis "(with-input-from-file string thunk)\n(with-output-to-file string thunk)" :description "|String| should be a string naming a file, and |proc| should be a\nprocedure of no arguments. For |with-input-from-file|, the file should\nalready exist. The file is opened for input or output, an input or output\nport connected to it is made the default value returned by\n|current-input-port| or |current-output-port| (and is used by |(read)|,\n|(write obj)|, and so forth), and the thunk is called with no arguments.\nWhen the thunk returns, the port is closed and the previous default is\nrestored. |With-input-from-file| and |with-output-to-file| return(s)\nthe value(s) yielded by thunk.\n@l\nThe following example uses a pipe port opened for reading. It permits to\nread all the lines produced by an external ,(emph \"ls\") command (i.e. the\noutput of the ,(emph \"ls\") command is ,(emph \"redirected\") to the Scheme pipe\nport).\n@lisp\n(with-input-from-file \"@pipe ls -ls\"\n  (lambda ()\n    (do ((l (read-line) (read-line)))\n        ((eof-object? l))\n      (display l)\n      (newline))))\n@end lisp\n\nHereafter is another example of Unix command redirection. This time,\nit is the standard input of the Unix command which is redirected.\n@lisp\n(with-output-to-file \"@pipe mail root\"\n  (lambda ()\n    (display \"A simple mail from Scheme\")\n    (newline)))\n@end lisp" :similar (with-input-from-file))

(with-input-from-file :see with-output-to-file)
(with-error-to-file :type extended :synopsis "(with-error-to-file string thunk)" :description "This procedure is similar to with-output-to-file, excepted that it uses the\ncurrent error port instead of the output port." :similar ())

(with-input-from-string :type extended :synopsis "(with-input-from-string string thunk)" :description "A string port is opened for input from |string|. |Current-input-port|\nis set to the port and |thunk| is called. When |thunk| returns,\nthe previous default input port is restored. |With-input-from-string|\nreturns the value(s) computed by |thunk|.\n@lisp\n(with-input-from-string \"123 456\"\n  (lambda () (read)))                       =>  123\n@end lisp" :similar ())

(with-output-to-string :type extended :synopsis "(with-output-to-string thunk)" :description "A string port is opened for output. |Current-output-port|\nis set to it and |thunk| is called. When |thunk| returns,\nthe previous default output port is restored. |With-output-to-string|\nreturns the string containing the text written on the string port.\n@lisp\n(with-output-to-string\n   (lambda () (write 123) (write \"Hello\"))) => \"123\\\\\"Hello\\\\\"\"\n@end lisp" :similar ())

(with-error-to-port :type extended :synopsis "(with-input-from-port port thunk)\n(with-output-to-port port thunk)\n(with-error-to-port port thunk)" :description "|Port| should be a port, and |proc| should be a\nprocedure of no arguments. These procedures do a job similar to the\n|with-...-file| counterparts  excepted that they use an open port instead\nof string specifying a file name" :similar (with-output-to-port with-input-from-port))

(with-output-to-port :see with-error-to-port)
(with-input-from-port :see with-error-to-port)
(call-with-output-file :type procedure :synopsis "(call-with-input-file string proc)\n(call-with-output-file string proc)" :description "|String| should be a string naming a file, and |proc| should be a procedure\nthat accepts one argument. For |call-with-input-file|, the file should\nalready exist. These procedures call |proc| with one argument: the port\nobtained by opening the named file for input or output. If the file cannot\nbe opened, an error is signaled. If |proc| returns, then the port is closed\nautomatically and the value(s) yielded by the proc is(are) returned.\nIf proc does not return, then the port will not be closed automatically.\n\nIMPORTANT: Because Scheme's escape procedures have unlimited extent,\nit is possible to escape from the current continuation but later to escape\nback in. If implementations were permitted to close the port on any escape\nfrom the current continuation, then it would be impossible to write portable\ncode using both |call-with-current-continuation| and |call-with-input-file|\nor |call-with-output-file|." :similar (call-with-input-file))

(call-with-input-file :see call-with-output-file)
(rationalize :type procedure :synopsis "(rationalize x y)" :description "Rationalize returns the simplest rational number differing from |x|\nby no more than |y|. A rational number |r1| is simpler than another\nrational number |r2| if |r1| = |p1/q1| and |r2| = |p2/q2| (in lowest\nterms) and abs(p1) <= abs(p2) and abs(q1) <= abs(q2). Thus |3/5| is\nsimpler than |4/7|. Although not all rationals are comparable in\nthis ordering  (consider |2/7| and |3/5|) any interval contains a\nrational number that\nis simpler than every other rational number in that interval (the\nsimpler |2/5| lies between |2/7| and |3/5|). Note that |0| = |0/1| is the\nsimplest rational of all.\n@lisp\n(rationalize\n   (inexact->exact .3) 1/10)  => 1/3    ; exact\n(rationalize .3 1/10)         => #i1/3  ; inexact\n@end lisp" :similar ())

(call-with-values :type procedure :synopsis "(call-with-values producer consumer)" :description "Calls its producer argument with no values and a continuation that,\nwhen passed some values, calls the consumer procedure with those values\nas arguments. The continuation for the call to consumer is the\ncontinuation of the call to call-with-values.\n@lisp\n(call-with-values (lambda () (values 4 5))\n                  (lambda (a b) b))                =>  5\n\n(call-with-values * -)                             =>  -1\n@end lisp" :similar ())


;; Source file "r7rs.stk"

(letrec* :type r7rs-syntax :synopsis "(letrec* <bindings> <body>)" :description "<bindings> should have the form as in |let| and body is a sequence\nof zero or more definitions followed by one or more expressions.\n\nThe `|<variable>|`s are bound to fresh locations, each |variable| is\nassigned in left-to-right order to the result of evaluating the\ncorresponding |init|, the |body| is evaluated in the resulting\nenvironment, and the values of the last expression in |body| are\nreturned. Despite the left-to-right evaluation and assignment order,\neach binding of a |variable| has the entire |letrec*| expression as its\nregion, making it possible to define mutually recursive procedures.\nIf it is not possible to evaluate each |init| without assigning or\nreferring to the value of the corresponding |variable| or the\n|variable| of any of the bindings that follow it in |bindings|, it is\nan error.\n\n@lisp\n(letrec* ((p (lambda (x)\n               (+ 1 (q (- x 1)))))\n          (q(lambda (y)\n              (if (zero? y)\n                  0\n                  (+ 1 (p (- y 1))))))\n          (x (p 5))\n          (y x))\n  y)  => 5\n@end lisp" :similar ())

(let-values :type r7rs-syntax :synopsis "(let-values ((<formals> <expression>) ...) <body>)" :description "Each |<formals>| should be a formal arguments list as for a |lambda| expression.\n\nThe `|<expression>|`s are evaluated in the current environment,\nthe variables of the |<formals>| are bound to fresh locations, the return\nvalues of the `|<expression>|`s are stored in the variables, the |<body>| is\nevaluated in the extended environment, and the values of the last expression\nof |<body>| are returned.\n\nThe matching of each |<formals>| to values is as for the matching of\n|<formals>| to arguments in a |lambda| expression, and it is an error\nfor an |<expression>| to return a number of values that does not match\nits corresponding |<formals>|.\n@lisp\n(let-values (((root rem) (exact-integer-sqrt 32)))\n   (* root rem))            =>  35\n\n(let ((a 'a) (b 'b) (x 'x) (y 'y))\n   (let-values (((a b) (values x y))\n                ((x y) (values a b)))\n     (list a b x y)))      => (x y a b)\n@end lisp" :similar ())

(let*-values :type r7rs-syntax :synopsis "(let-values ((<formals> <expression>) ...) <body>)" :description "Each |<formals>| should be a formal arguments list as for a |lambda| expression.\n\n|let*-values| is similar to |let-values|, but the bindings are performed\nsequentially from left to right, and the region of a binding indicated by\n|(<formals> <expression>)| is that part of the |let*-values| expression to\nthe right of the binding. Thus the second binding is done in an environment\nin which the first binding is visible, and so on.\n@lisp\n(let ((a 'a) (b 'b) (x 'x) (y 'y))\n   (let*-values (((a b) (values x y))\n                ((x y) (values a b)))\n     (list a b x y)))      => (x y x y)\n@end lisp" :similar ())

(delay :type syntax :synopsis "(delay <expression>)" :description "The |delay| construct is used together with the procedure |force|\nto implement *_lazy evaluation_* or *_call by need_*. |(delay\n<expression>)| returns an object called a *_promise_*) which at some\npoint in the future may be asked (by the |force| procedure) to\nevaluate |<expression>|, and deliver the resulting value.\nThe effect of |<expression>| returning multiple values is unpredictable.\n\nSee the description of |force| for a more complete\ndescription of |delay|." :similar ())

(delay-force :type r7rs-syntax :synopsis "(delay-force <expression>)\n(lazy <expression>)" :description "The expression |(delay-force expression)| is conceptually similar\nto |(delay (force expression))|, with the difference that forcing the result\nof |delay-force| will in effect result in a tail call to |(force expression)|,\nwhile forcing the result of |(delay (force expression))| might not. Thus\niterative lazy algorithms that might result in a long series of chains of\n|delay| and |force| can be rewritten using |delay-force| to prevent consuming\nunbounded space during evaluation.\n\nThe special form |delay-force| appears with name |lazy| in {{link-srfi 45}}.\n" :similar (lazy))

(lazy :see delay-force)
(make-promise :type r7rs-procedure :synopsis "(make-promise obj)\n(eager obj)" :description "The |make-promise| procedure returns a promise which,\nwhen forced, will return |obj| . It is similar to |delay|, but\ndoes not delay its argument: it is a procedure rather than\nsyntax. If |obj| is already a promise, it is returned.\n\nThe primitve |make-promise| appears with name |eager| in\nSRFI-45." :similar (eager))

(eager :see make-promise)
(define-values :type r7rs-procedure :synopsis "(define-values formals expression)" :description "The form |define-values| creates multiple definitions from a single expression\nreturning multiple values. Here, |expression| is evaluated, and the |formals|\nare bound to the return values in the same way that the |formals| in a\nlambda expression are matched to the arguments in a procedure call.\n\n@lisp\n(let ()\n  (define-values (x y) (exact-integer-sqrt 17))\n  (list x y))                   => (4 1)\n\n(let ()\n   (define-values (x y) (values 1 2))\n   (+ x y))                     => 3\n\n(let ()\n   (define-values (x . y) (values 1 2 3))\n   (list x y)                  => (1 (2 3))\n@end lisp" :similar ())

(exact-integer? :type r7rs-procedure :synopsis "(exact->integer? z)" :description "Returns  `#t` if z is both exact and an integer; otherwise returns `#f`.\n\n@lisp\n(exact-integer? 32)   => #t\n(exact-integer? 32.0) => #f\n(exact-integer? 32/5) => #f\n@end lisp" :similar ())

(truncate-remainder :type r7rs-procedure :synopsis "(floor/ n1 n2)\n(floor-quotient n1 n2)\n(floor-remainder n1 n2)\n(truncate/ n1 n2)\n(truncate-quotient n1 n2)\n(truncate-remainder n1 n2)" :description "These procedures implement number-theoretic (integer) division.  It is\nan error if |n2| is zero. The procedures ending in '/' return two integers;\nthe other procedures return an integer.  All the procedures compute a\nquotient |q| and remainder |r| such that |n1=n2*q+r|.\n\nSee R7RS for more information.\n\n@lisp\n(floor/ 5 2)         => 2 1\n(floor/ -5 2)        => -3 1\n(floor/ 5 -2)        => -3 -1\n(floor/ -5 -2)       => 2 -1\n(truncate/ 5 2)      => 2 1\n(truncate/ -5 2)     => -2 -1\n(truncate/ 5 -2)     => -2 1\n(truncate/ -5 -2)    => 2 -1\n(truncate/ -5.0 -2)  => 2.0 -1.0%\n@end lisp" :similar (truncate-quotient truncate/ floor-remainder floor-quotient floor/))

(truncate-quotient :see truncate-remainder)
(truncate/ :see truncate-remainder)
(floor-remainder :see truncate-remainder)
(floor-quotient :see truncate-remainder)
(floor/ :see truncate-remainder)
(square :type r7rs-procedure :synopsis "(square z)" :description "Returns the square of |z|. This is equivalent to |(* z z)|.\n\n@lisp\n(square 42)     => 1764\n(square 2.0)    => 4.0\n@end lisp" :similar ())

(exact-integer-sqrt :type r7rs-procedure :synopsis "(exact-integer-sqrt k)" :description "Returns two non negatives integers |s| and |r| where\n|k=s**2+r| and |k<(s+1)**2|.\n\n@lisp\n(exact-integer-sqrt 4)     => 2 0\n(exact-integer-sqrt 5)     => 2 1\n@end lisp" :similar ())

(inexact :type r7rs-procedure :synopsis "(inexact z)\n(exact z)" :description "These R7RS procedures correspond to the R5RS |exact->inexact|\nand |inexact->exact| procedure respectively" :similar (exact))

(exact :see inexact)
(boolean=? :type procedure :synopsis "(boolean=? boolean1 boolean2  ...)" :description "Returns `#t` if all the arguments are booleans and all are `#t` or all are `#f`.\n" :similar ())

(make-list :type r7rs-procedure :synopsis "(make-list k)\n(make-list k fill)" :description "Returns a newly allocated list of k elements. If a second\nargument is given, then each element is initialized to fill .\nOtherwise the initial contents of each element is unspecified." :similar ())

(symbol=? :type procedure :synopsis "(symbol=? symbol1 symbol2  ...)" :description "Returns `#t` if all the arguments are symbols and all have the same name in\nthe sense of |string=?|." :similar ())

(string-copy! :type r7rs-procedure :synopsis "(string-copy! to at from)\n(string-copy! to at from start)\n(string-copy! to at from start end)" :description "Copies the characters of |string| from between |start| and |end|\nto string |to|, starting at |at|. The order in which characters are copied\nis unspecified, except that if the source and destination overlap,\ncopying takes place as if the source is first copied into a temporary\nstring and then into the destination. This can be achieved without\nallocating storage by making sure to copy in the correct direction in\nsuch circumstances.\n\nIt is an error if |at| is less than zero or greater than the length\nof |to|. It is also an error if |(- (string-length to) at)| is less\nthan |(- end start)|." :similar ())

(vector-copy! :type r7rs-procedure :synopsis "(vector-copy! to at from)\n(vector-copy! to at from start)\n(vector-copy! to at from start end)" :description "" :similar ())

(string->vector :type r7rs-procedure :synopsis "(vector->string string)\n(vector->string string start)\n(vector->string string start end)\n(string->vector vector)\n(string->vector vector start)\n(string->vector vector start end)" :description "The |vector->string| procedure returns a newly allocated\nstring of the objects contained in the elements of |vector|\nbetween |start| and |end|. It is an error if any element of |vector|\nbetween |start| and |end| is not a character.\n\nThe |string->vector| procedure returns a newly created vector\ninitialized to the elements of |string| between |start| and |end|.\n\nIn both procedures, order is preserved.\n\n@lisp\n(string->vector \"ABC\")           => #(#\\A #\\B #\\C)\n(vector->string #(#\\1 #\\2 #\\3))  => \"123\"\n@end lisp" :similar (vector->string))

(vector->string :see string->vector)
(make-bytevector :type r7rs-procedure :synopsis "(make-bytevector k)\n(make-bytevector k byte)" :description "Returns a newly allocated bytevector of k bytes. If If |byte| is given,\nthen all elements of the bytevector are initialized to |byte|, otherwise\nthe contents of each element is 0.\n@lisp\n(make-bytevector 2 12) => #u8(12 12)\n(make-bytevector 3)    => #u8(0 0 0)\n@end lisp" :similar ())

(bytevector? :type r7rs-procedure :synopsis "(bytevector? obj)" :description "Returns |!t| if |obj| is a bytevector and returns |!f| otherwise." :similar ())

(bytevector :type r7rs-procedure :synopsis "(bytevector byte ...)" :description "Returns a newly allocated bytevector containing its arguments.\n@lisp\n(bytevector 1 3 5 1 3 5)   => #u8(1 3 5 1 3 5)\n(bytevector)               => #u8()\n@end lisp" :similar ())

(bytevector-length :type r7rs-procedure :synopsis "(bytevector-length bytevector)" :description "Returns the length of |bytevector| in bytes as an exact integer." :similar ())

(bytevector-u8-ref :type r7rs-procedure :synopsis "(bytevector-u8-ref bytevector k)" :description "Returns the byte at index |k| of |bytevector| as an exact integer in the\nrange [0..255]. It is an error if |k| is not a valid index of |bytevector|.\n\n@lisp\n(bytevector-u8-ref #u8(1 1 2 3 5 8 13 21) 5    => 8\n@end lisp" :similar ())

(bytevector-u8-set! :type extended :synopsis "(bytevector-u8-ref bytevector k byte)" :description "Stores byte as the k th byte of bytevector. It is an error if |k|\nis not a valid index of |bytevector|.\n\n@lisp\n(let ((bv (bytevector 1 2 3 4)))\n  (bytevector-u8-set! bv 1 3)\n  bv)                             => #u8(1 3 3 4)\n@end lisp" :similar ())

(bytevector-copy! :type r7rs-procedure :synopsis "(bytevector-copy! to at from)\n(bytevector-copy! to at from start)\n(bytevector-copy! to at from start end)" :description "Copies the bytes of bytevector |from| between |start| and |end|\nto bytevector |to|, starting at |at|. The order in which bytes\nare copied is unspecified, except that if the source and\ndestination overlap, copying takes place as if the source is first\ncopied into a temporary bytevector and then into the destination.\nThis can be achieved without allocating storage by making sure\nto copy in the correct direction in such circumstances.\n\nIt is an error if |at| is less than zero or greater than the length\nof |to|. It is also an error if |(- (bytevector-length to) at)| is\nless than |(- end start)|.\n\n@lisp\n(define a (bytevector 1 2 3 4 5))\n(define b (bytevector 10 20 30 40 50))\n(bytevector-copy! b 1 a 0 2)\nb                                  =>  #u8(10 1 2 40 50\n@end lisp" :similar ())

(string-map :type r7rs-procedure :synopsis "(string-map proc string1 string2 ...)" :description "The |strings| must be strings, and |proc| must be a procedure taking as\nmany arguments as there are strings and returning a single\nvalue. If more than one string is given and not all strings have the\nsame length, |string-map| terminates when the shortest list runs\nout. |String-map| applies |proc| element-wise to the elements of the\nstrings and returns a string of the results, in order. The dynamic\norder in which proc is applied to the elements of the |strings| is\nunspecified.\n@lisp\n(string-map char-downcase \"AbdEgH\")\n         => \"abdegh\"\n\n(string-map\n  (lambda (c)\n    (integer->char (+ 1 (char->integer c))))\n  \"HAL\")\n         => \"IBM\"\n\n(string-map (lambda (c k)\n           (if (eqv? k #\\u)\n               (char-upcase c)\n               (char-downcase c)))\n         \"studlycaps\"\n         \"ululululul\")\n      => \"StUdLyCaPs\"\n@end lisp\n" :similar ())

(vector-map :type r7rs-procedure :synopsis "(vector-map proc vector1 vector2 ...)" :description "The |vectors| must be vectors, and |proc| must be a procedure\ntaking as many arguments as there are vectors and returning a single\nvalue. If more than one vector is given and not all vectors have the\nsame length, |vector-map| terminates when the shortest list runs\nout. |Vector-map| applies |proc| element-wise to the elements of the\nvectors and returns a vector of the results, in order. The dynamic\norder in which proc is applied to the elements of the |vectors| is\nunspecified.\n@lisp\n(vector-map cadr '#((a b) (d e) (g h)))\n    =>  #(b e h)\n\n(vector-map (lambda (n) (expt n n))\n         '#(1 2 3 4 5))\n    => #(1 4 27 256 3125)\n\n(vector-map + '#(1 2 3) '#(4 5 6))\n    => #(5 7 9)\n\n(let ((count 0))\n  (vector-map\n    (lambda (ignored)\n      (set! count (+ count 1))\n      count)\n    '#(a b)))\n    => #(1 2) or #(2 1)\n@end lisp" :similar ())

(string-for-each :type r7rs-procedure :synopsis "(string-for-each proc string1 string2 ...)" :description "The arguments to |string-for-each| are like the arguments to\n|string-map|, but |string-for-each| calls |proc| for its side effects\nrather than for its values. Unlike |string-map|, |string-for-each| is\nguaranteed to call |proc| on the elements of the lists in order from\nthe first element(s) to the last, and the value returned by\n|string-for-each| is unspecified. If more than one string is given and\nnot all strings have the same length, |string-for-each| terminates when\nthe shortest string runs out.\n@lisp\n(let ((v (list)))\n  (string-for-each (lambda (c) (set! v (cons (char->integer c) v)))\n                   \"abcde\")\n   v)\n       => (101 100 99 98 97)\n@end lisp" :similar ())

(vector-for-each :type r7rs-procedure :synopsis "(vector-for-each proc vector1 vector2 ...)" :description "The arguments to |vector-for-each| are like the arguments to\n|vector-map|, but |vector-for-each| calls |proc| for its side effects\nrather than for its values. Unlike |vector-map|, |vector-for-each| is\nguaranteed to call |proc| on the elements of the lists in order from\nthe first element(s) to the last, and the value returned by\n|vector-for-each| is unspecified. If more than one vector is given and\nnot all vectors have the same length, |vector-for-each| terminates when\nthe shortest vector runs out.\n@lisp\n(let ((v (make-vector 5)))\n  (vector-for-each (lambda (i) (vector-set! v i (* i i)))\n                '#(0 1 2 3 4))\n  v)\n       => #(0 1 4 9 16)\n@end lisp" :similar ())

(error-object? :type r7rs-procedure :synopsis "(error-object? obj )" :description "Returns `#t` if |obj| is an object created by error. Otherwise,\nit returns `#f`." :similar ())

(error-object-message :type r7rs-procedure :synopsis "(error-object-message error-object)" :description "Returns the message encapsulated by |error-object|.\n" :similar ())

(error-object-irritants :type r7rs-procedure :synopsis "(error-object-irritants error-object)" :description "Returns the message encapsulated by |error-object|.\n" :similar ())

(file-error? :type r7rs-procedure :synopsis "(read-error? obj)\n(file-error? obj)" :description "\nError type predicates. Returns `#t` if |obj| is an object raised\nby the read procedure or by the inability to open an input or\noutput port on a file, respectively. Otherwise, it returns `#f`.\n" :similar (read-error?))

(read-error? :see file-error?)
(call-with-port :type r7rs-procedure :synopsis "(call-with-port port proc)" :description "The |call-with-port| procedure calls |proc| with |port| as an\nargument. If |proc| returns, then the |port| is closed automatically\nand the values yielded by the |proc| are returned.\nIf |proc| does not return, then the |port| must not be closed\nautomatically unless it is possible to prove that the port\nwill never again be used for a read or write operation.\n\nIt is an error if proc does not accept one argument." :similar ())

(output-port-open? :type r7rs-procedure :synopsis "(input-port-open? port)\n(output-port-open? port)" :description "Returns `#t` if port is still open and capable of performing\ninput or output, respectively, and `#f` otherwise." :similar (input-port-open?))

(input-port-open? :see output-port-open?)
(read-string :type r7rs-procedure :synopsis "(read-string k)\n(read-string k port)" :description "Reads the next |k| characters, or as many as are available\nbefore the end of file, from the textual input |port| into a\nnewly allocated string in left-to-right order and returns the\nstring. If no characters are available before the end of file,\nan end-of-file object is returned." :similar ())

(read-u8 :type r7rs-procedure :synopsis "(read-u8)\n(read-u8 port)" :description "Returns the next byte available from the binary input |port|,\nupdating the |port| to point to the following byte. If no more\nbytes are available, an end-of-file object is returned.\n\n@l\nNOTE: This function is similar to the |read-byte|\nfunction, excepted that it can be used only on  a binary port." :similar ())

(peek-u8 :type r7rs-procedure :synopsis "(peek-u8)\n(peek-u8 port)" :description "Returns the next byte available from the binary input |port|,\nbut without updating the |port| to point to the following\nbyte. If no more bytes are available, an end-of-file object\nis returned.\n\n@l\nNOTE: This function is similar to the |peek-byte|\nfunction, excepted that it can be used only on  a binary port." :similar ())

(read-bytevector! :type r7rs-procedure :synopsis "(read-bytevector! k)\n(read-bytevector! k port)\n(read-bytevector! k port start)\n(read-bytevector! k port start end)" :description "Reads the next |end - start| bytes, or as many as are available\nbefore the end of file, from the binary input port\ninto |bytevector| in left-to-right order beginning at the start\nposition. If |end| is not supplied, reads until the end of\n|bytevector| has been reached. If |start| is not supplied, reads\nbeginning at position 0. Returns the number of bytes read.\nIf no bytes are available, an end-of-file object is returned." :similar ())

(write-string :type r7rs-procedure :synopsis "(write-string string)\n(write-string string port)\n(write-string string port start)\n(write-string string port start end)" :description "Writes the characters of |string| from |start| to |end| in\nleft-to-right order to the textual output |port|." :similar ())

(write-u8 :type r7rs-procedure :synopsis "(write-u8 byte)\n(write-u8 byte port)" :description "Writes the |byte| to the given binary output port." :similar ())

(write-bytevector :type r7rs-procedure :synopsis "(write-bytevector bytevector)\n(write-bytevector bytevector port)\n(write-bytevector bytevector port start)\n(write-bytevector bytevector port start end)" :description "Writes the bytes of |bytevector| from |start| to |end| in\nleft-to-right order to the binary output |port|." :similar ())

(with-handler :type extended-syntax :synopsis "(with-handler <handler> <expr~1~> ... <expr~n~>)" :description "Evaluates the sequences of expressions |<expr~1~>| to |<expr~n~>|.\n|<handler>| must be a procedure that accepts one argument. It is installed\nas the current exception handler for the dynamic extent (as determined by\ndynamic-wind) of the evaluations of the expressions\n@lisp\n(with-handler (lambda (c)\n                (display \"Catch an error\\\\n\"))\n   (display \"One ... \")\n   (+ \"will yield\" \"an error\")\n   (display \"... Two\"))\n       @print{} \"One ... Catch an error\"\n@end lisp" :similar ())

(with-exception-handler :type r7rs-procedure :synopsis "(with-exception-handler <handler> <thunk>)" :description "This form is similar to |with-handler|. It uses a *_thunk_* instead of\na sequence of expressions. It is conform to {{link-srfi 34}}.\nIn fact,\n@lisp\n(with-handler <handler> <expr1> ... <exprn>)\n@end lisp\nis equivalent to\n@lisp\n(with-exception-handler <handler>\n  (lambda () <expr1> ... <exprn>))\n@end lisp" :similar ())

(raise-continuable :type r7rs-procedure :synopsis "(raise-continuable obj)" :description "Raises an exception by invoking the current exception handler on\n|obj|. The handler is called with the same dynamic environment as the\ncall to |raise-continuable|, except that: (1) the current exception\nhandler is the one that was in place when the handler being called was\ninstalled, and (2) if the handler being called returns, then it will again\nbecome the current exception handler.  If the handler returns, the values\nit returns become the values returned by the call to |raise-continuable|.\n@lisp\n(with-exception-handler\n  (lambda (con)\n    (cond\n      ((string? con)\n       (display con))\n      (else\n       (display \"a warning has been issued\")))\n    42)\n  (lambda ()\n    (+ (raise-continuable \"should be a number\")\n       23)))\n  ;; prints should be a number\n                => 65\n@end lisp" :similar ())

(guard :type r7rs-procedure :synopsis "(guard (<var> <clause1 > <clause2 > ...)  <body>)" :description "Evaluating a guard form evaluates |<body>| with an exception handler\nthat binds the raised object to |<var>| and within the scope of that\nbinding evaluates the clauses as if they were the clauses of a cond\nexpression. That implicit cond  expression is evaluated with the\ncontinuation and dynamic environment of the |guard| expression.\nIf every `|<clause>|`s test evaluates to false and there is no |else|\nclause, then |raise| is re-invoked on the raised object within the\ndynamic environment of the original call to |raise| except that the\ncurrent exception handler is that of the |guard| expression.\n\n@lisp\n(guard (condition\n         ((assq 'a condition) => cdr)\n         ((assq 'b condition)))\n  (raise (list (cons 'a 42))))\n         => 42\n\n(guard (condition\n         ((assq 'a condition) => cdr)\n         ((assq 'b condition)))\n  (raise (list (cons 'b 23))))\n         => (b . 23)\n\n(with-handler (lambda (c) (format \"value ~A was raised\" c))\n  (guard (condition\n       ((assq 'a condition) => cdr)\n       ((assq 'b condition)))\n      (raise (list (cons 'x 0)))))\n         => \"value ((x . 0)) was raised\"\n@end lisp" :similar ())

(current-jiffy :type r7rs-procedure :synopsis "(current-jiffy)" :description "Returns the number of _jiffies_ as an exact integer that\nhave elapsed since an arbitrary, implementation-defined\nepoch. A jiffy is an implementation-defined fraction of\na second which is defined by the return value of the\n|jiffies-per-second| procedure. The starting epoch is\nguaranteed to be constant during a run of the program,\nbut may vary between runs." :similar ())

(jiffies-per-second :type r7rs-procedure :synopsis "(jiffies-per-seconds)" :description "Returns an exact integer representing the number of jiffies\nper second.\n\n@lisp\n(define (time-length)\n  (let ((list (make-list 100000))\n        (start (current-jiffy)))\n    (length list)\n    (/ (- (current-jiffy) start)\n       (jiffies-per-second))))\n@end lisp" :similar ())

(features :type r7rs-procedure :synopsis "(features)" :description "Returns a list of the feature identifiers which |cond-expand|\ntreats as true. Here is an\nexample of what |features| might return:\n\n@lisp\n(features) => (STklos STklos-{{version}} exact-complex\n               ieee-float full-unicode ratios little-endian ...)\n@end lisp" :similar ())


;; Source file "regexp.stk"

(regexp-replace-all :type extended :synopsis "(regexp-replace pattern string substitution)\n(regexp-replace-all pattern string substitution)" :description "|Regexp-replace| matches the regular expression |pattern| against\n|string|. If there is a match, the portion of |string| which matches\n|pattern| is replaced by the |substitution| string. If there is no\nmatch, |regexp-replace| returns |string| unmodified. Note that the\ngiven |pattern| could be here either a string or a regular expression.\n\nIf |pattern| contains |\\n| where *n* is a digit between 1 and 9,\nthen it is replaced in the substitution with the portion of string that\nmatched the *n*-th parenthesized subexpression of |pattern|. If\n*n* is equal to 0, then it is replaced in |substitution|\nwith the portion of |string| that matched |pattern|.\n\n|Regexp-replace| replaces the first occurrence of |pattern| in |string|.\nTo replace _all_ the occurrences of |pattern|, use |regexp-replace-all|.\n\n@lisp\n(regexp-replace \"a*b\" \"aaabbcccc\" \"X\")\n                   => \"Xbcccc\"\n(regexp-replace (string->regexp \"a*b\") \"aaabbcccc\" \"X\")\n                   => \"Xbcccc\"\n(regexp-replace \"(a*)b\" \"aaabbcccc\" \"X\\\\1Y\")\n                   => \"XaaaYbcccc\"\n(regexp-replace \"f(.*)r\" \"foobar\" \"\\\\1 \\\\1\")\n                   => \"ooba ooba\"\n(regexp-replace \"f(.*)r\" \"foobar\" \"\\\\0 \\\\0\")\n                   => \"foobar foobar\"\n\n(regexp-replace \"a*b\" \"aaabbcccc\" \"X\")\n                   => \"Xbcccc\"\n(regexp-replace-all \"a*b\" \"aaabbcccc\" \"X\")\n                   => \"XXcccc\"\n@end lisp" :similar (regexp-replace))

(regexp-replace :see regexp-replace-all)

;; Source file "readline.stk"


;; Source file "repl.stk"

(repl-theme :type extended :synopsis "(repl-theme)\n(repl-theme plist)\n(repl-theme name)" :description "The {{stklos}} REPL colors can be customized using a property list (or a theme\nname) using the `repl-theme` parameter. The properties that can be used in this\nproperty list are:\n\n- `#:error` for the color of error messages\n- `#:prompt` for the color of the prompt\n- `#:help-prompt` for the color of the help prompt\n- `#:help` for the color of the help messages\n- `#:repl-depth` for the color of the depth indicator for recursive REPLs\n- `#:info` for the color of information messages.\n\nThere are three default themes:\n\n- **classic** which is the (colorful) default theme.\n- **monochrome** which doesn't use colors\n- **minimal** where only the prompt and errors are colored.\n\nColors are expressed using the conventions of\n<<ansicolor, the `ansi-color` primitive>>. For instance:\n\n@lisp\n(key-set! (repl-theme) :prompt '(bold green)) ;; set the prompt to bold green\n\n(repl-theme 'minimal)                         ;; to use a sober prompt\n\n(repl-theme '(#:error (bold red)              ;; explicitly defined theme\n              #:prompt (bold bg-red white)))\n@end lisp\n\nA good place to change your theme is the `.stklosrc` file." :similar ())

(repl :type extended :synopsis "(repl)\n(repl :in inport :out outport :err errport)" :description "This procedure launches a new Read-Eval-Print-Loop. Calls to |repl| can be\nembedded. The ports used for input/output as well as the error port can\nbe passed when |repl| is called. If not passed, they default to\n|current-input-port|, |current-output-port| and |current-error-port|." :similar ())


;; Source file "repl-readline.stk"


;; Source file "runtime.stk"

(setter :type extended :synopsis "(setter proc)" :description "Returns the setter associated to a |proc|. Setters are defined in the\n{{link-srfi 17}} document. A setter proc, can be used in a generalized\nassignment, as described in |set!|.\n\nTo associate |s| to the procedure |p|, use the following form:\n@lisp\n(set! (setter p) s)\n@end lisp\nFor instance, we can write\n@lisp\n(set! (setter car) set-car!)\n@end lisp\n\nThe following standard procedures have pre-defined setters:\n@lisp\n(set! (car x) v)              == (set-car! x v)\n(set! (cdr x) v)              == (set-cdr! x v)\n(set! (string-ref x i) v)     == (string-set! x i v)\n(set! (vector-ref x i) v)     == (vector-set! x i v)!\n(set! (slot-ref x 'name) v)   == (slot-set! x 'name v)\n(set! (struct-ref x 'name) v) == (struct-set! x 'name v)\n@end lisp\nFurhermore, Parameter Objects (see _<<_parameter_objects>>_) are\ntheir own setter:\n@lisp\n(real-precision)              => 15\n(set! (real-precision) 12)\n(real-precision)              => 12\n@end lisp" :similar ())

(stklos-debug-level :type extended :synopsis "(stklos-debug-level)" :description "|stklos-debug-level| is a parameter objet. It permits to know the current\ndebugging level. The default value of this parameter is 0 (meaning \"no debug\").\nNote that the debugging level can also be set by the |--debug| option of the\n|stklos(1)| command." :similar ())


;; Source file "runtime-macros.stk"


;; Source file "srfis-data.scm"


;; Source file "srfi-0.stk"

(require-feature :type extended :synopsis "(require-feature feature)" :description "This primitive ensures that the |feature| (in sense of SRFI-0 feature)\ncan be used. In particular, it eventually requires the loading of the\nfiles needed to used |feature|. The |feature| can be expressed as a\nstring or a symbol, If feature is an integer |n|, it is equivalent to |srfi-n|.\nConsequently, to use {{quick-link-srfi 1}} the following forms are equivalent:\n\n@lisp\n(require-feature 'srfi-1)\n(require-feature \"srfi-1\")\n(require-feature 1)\n(require-feature 'lists)      ;; Since this feature name is an alias for SRFI-1\n@end lisp\n\nSee also <<_srfis>> for more information." :similar ())


;; Source file "str.stk"


;; Source file "struct.stk"

(define-struct :type extended-syntax :synopsis "(define-struct <name> <slot> ...)" :description "Defines a structure type whose name is |<name>|. Once a structure type is\ndefined, the following symbols are bound:\n\n- |<name>| denotes the structure type.\n\n- |make-<name>| is a procedure which takes 0 to |n| parameters (if there\n  are |n| slots defined). Each parameter is assigned to the corresponding\n  field (in the definition order).\n\n- |<name>?| is a predicate which returns `#t` when applied to an\n  instance of the |<name>| structure type and `#f` otherwise\n\n- |<name>-<slot>| (one for each defined |<slot>|) to read the\n  content of an instance of the |<name>| structure type. Writting the\n  content of a slot can be done using a generalized |set!|.\n\n@lisp\n(define-struct point x y)\n(define p (make-point 1 2))\n(point? p)    => #t\n(point? 100)  => #f\n(point-x p)   => 1\n(point-y p)   => 2\n(set! (point-x p) 10)\n(point-x p)   => 10\n@end lisp\n" :similar ())


;; Source file "time.stk"

(make-time :type extended :synopsis "(make-time nanosecond second)\n(make-time type nanosecond second)" :description "Creates a time structure with the given |nanosecond| and |second|.\nIf |type| is passed, it must be a symbol representing one of the\nsupported time types (|time-tai|, |time-utc|, |time-monotonic|,\n|time-process| and |time-duration|).\n\nNOTE:  |time-monotonic|, |time-process| and |time-duration| can\nbe created, but operations on them are only available when SRFI-19 is\nloaded." :similar ())

(set-time-nanosecond! :type extended :synopsis "(time-type t)\n(set-time-type! t v)\n(time-second t)\n(set-time-second! t s)\n(time-nanosecond t)\n(set-time-nanosecond! t n)" :description "These are accessors for time structures." :similar (time-nanosecond set-time-second! time-second set-time-type! time-type))

(time-nanosecond :see set-time-nanosecond!)
(set-time-second! :see set-time-nanosecond!)
(time-second :see set-time-nanosecond!)
(set-time-type! :see set-time-nanosecond!)
(time-type :see set-time-nanosecond!)
(time? :type extended :synopsis "(time? obj)" :description "Return `#t` if |obj| is a time object, othererwise returns `#f`." :similar ())

(time->seconds :type extended :synopsis "(time->seconds time)" :description "Convert the time object |time| into an inexact real number representing\nthe number of seconds elapsed since the Epoch.\n@lisp\n(time->seconds (current-time))  ==>  1138983411.09337\n@end lisp" :similar ())

(seconds->time :type extended :synopsis "(seconds->time x)" :description "Converts into a time object the real number |x| representing the number\nof seconds elapsed since the Epoch.\n@lisp\n(seconds->time (+ 10 (time->seconds (current-time))))\n         ==>  a time object representing 10 seconds in the future\n@end lisp" :similar ())

(time-tai->time-utc! :type extended :synopsis "(time-tai->time-utc t)\n(time-tai->time-utc! t)" :description "Converts |t|, which must be of type |time-tai|, to the type\n|time-utc|.\n\n|Time-tai->time-utc| creates a new object, while |time-tai->time-utc|\ncan use |t| to build the returned object." :similar (time-tai->time-utc))

(time-tai->time-utc :see time-tai->time-utc!)
(time-utc->time-tai! :type extended :synopsis "(time-utc->time-tai t)\n(time-utc->time-tai! t)" :description "Converts |t|, which must be of type |time-utc|, to the type\n|time-tai|.\n\n|Time-utc->time-tai| creates a new object, while |time-utc->time-tai|\ncan use |t| to build the returned object." :similar (time-utc->time-tai))

(time-utc->time-tai :see time-utc->time-tai!)
(current-time :type extended :synopsis "(current-time)\n(current-time type)" :description "Return the current time as time object. The type can be |time-utc| or |time-tai|.\nIf omitted, |type| is |time-utc|.\n\nNOTE: To use more time types, such as |time-monotonic| and |time-process|, please\nload {{quick-link-srfi 19}}." :similar ())

(make-date :type extended :synopsis "(make-date :key      nanosecond second minute hour day month year zone-offset)\n(make-date :optional nanosecond second minute hour day month year zone-offset)" :description "Build a date from its argument. |hour|, |minute|, |second|, |nanosecond|\ndefault to 0; |day| and |month| default to 1; |year| defaults to 1970." :similar ())

(date? :type extended :synopsis "(date? obj)" :description "Return `#t` if |obj| is a date, and otherwise returns `#f`." :similar ())

(seconds->date :type extended :synopsis "(seconds->date n)" :description "Convert the date |n| expressed as a number of seconds since the _Epoch_,\n1970-01-01 00:00:00 +0000 (UTC) into a date.\n|n| can be an exact integer or an inexact real.\n\nThis is equivalent to converting time-UTC to date.\n@lisp\n(seconds->date 1351216417)           => #[date 2012-10-26 1:53:37]\n@end lisp" :similar ())

(date-nanosecond :type extended :synopsis "(date-nanosecond d)" :description "Return the nanosecond of date |d|." :similar ())

(date-second :type extended :synopsis "(date-second d)" :description "Return the second of date |d|, in the range 0 to 59." :similar ())

(date-minute :type extended :synopsis "(date-minute d)" :description "Return the minute of date |d|, in the range 0 to 59." :similar ())

(date-hour :type extended :synopsis "(date-hour d)" :description "Return the hour of date |d|, in the range 0 to 23." :similar ())

(date-day :type extended :synopsis "(date-day d)" :description "Return the day of date |d|, in the range 1 to 31" :similar ())

(date-month :type extended :synopsis "(date-month d)" :description "Return the month of date |d|, in the range 1 to 12" :similar ())

(date-year :type extended :synopsis "(date-year d)" :description "Return the year of date |d|." :similar ())

(date-week-day :type extended :synopsis "(date-week-day d)" :description "Return the week day of date |d|, in the range 0 to 6 (0 is Sunday)." :similar ())

(date-year-day :type extended :synopsis "(date-year-day d)" :description "Return the the number of days since January 1 of date |d|, in the range\n1 to 366." :similar ())

(date-dst :type extended :synopsis "(date-dst d)" :description "Return an indication about daylight saving adjustment of date |d|:\n\n- 0 if no daylight saving adjustment\n- 1 if daylight saving adjustment\n- -1 if the information is not available" :similar ())

(date-tz :type extended :synopsis "(date-tz d)" :description "Return the time zone of date |d|." :similar ())

(seconds->list :type extended :synopsis "(seconds->list sec)" :description "Returns a keyword list for the date given by |sec| (a date based on the\nEpoch). The keyed values returned are\n\n- nanosecond : 0 to 999999\n- second : 0 to 59 (but can be up to 61 to allow for leap seconds)\n- minute : 0 to 59\n- hour : 0 to 23\n- day : 1 to 31\n- month : 1 to 12\n- year : e.g., 2002\n- week-day : 0 (Sunday) to 6 (Saturday)\n- year-day : 0 to 365 (365 in leap years)\n- dst : indication about daylight savings time\n  (see _<<datedst, primitive `date-dst`>>_).\n- tz : the difference between Coordinated Universal Time\n  (UTC) and local standard time in seconds.])\n\n@lisp\n(seconds->list (current-second))\n       => (#:nanosecond 182726 #:second 21 #:minute 35 #:hour 20 #:day 10 #:month 1\n           #:year 2022 #:week-day 1 #:year-day 10 #:dst 0 #:tz -3600)\n@end lisp" :similar ())

(current-date :type extended :synopsis "(current-date)" :description "Returns the current system date." :similar ())

(seconds->string :type extended :synopsis "(seconds->string format n)" :description "Convert a date expressed in seconds using the string |format| as a\nspecification. Conventions for |format| are given below:\n\n - *~~* a literal ~\n - *~a* locale's abbreviated weekday name (Sun...Sat)\n - *~A* locale's full weekday name (Sunday...Saturday)\n - *~b* locale's abbreviate month name (Jan...Dec)\n - *~B* locale's full month day (January...December)\n - *~c* locale's date and time\n        (e.g., ,(code \"Fri Jul 14 20:28:42-0400 2000\"))\n - *~d* day of month, zero padded (01...31)\n - *~D* date (mm/dd/yy)\n - *~e* day of month, blank padded ( 1...31)\n - *~f* seconds+fractional seconds, using locale's\n        decimal separator (e.g. 5.2).\n - *~h* same as ~b\n - *~H* hour, zero padded, 24-hour clock (00...23)\n - *~I* hour, zero padded, 12-hour clock (01...12)\n - *~j* day of year, zero padded\n - *~k* hour, blank padded, 24-hour clock (00...23)\n - *~l* hour, blank padded, 12-hour clock (01...12)\n - *~m* month, zero padded (01...12)\n - *~M* minute, zero padded (00...59)\n - *~n* new line\n - *~p* locale's AM or PM\n - *~r* time, 12 hour clock, same as +\"~I:~M:+~S ~p\"\n - *~s* number of full seconds since _the epoch_ (in UTC)\n - *~S* second, zero padded (00...61)\n - *~t* horizontal tab\n - *~T* time, 24 hour clock, same as +\"~H:~M:~S\"+\n - *~U* week number of year with Sunday as first day of week\n        (00...53)\n - *~V* weekISO 8601:1988 week number of year (01...53)\n        (week 1 is the first week that has at least 4 days in\n        the current year, and  with  Monday  as  the first day\n        of the week)\n - *~w* day of week (1...7, 1 is Monday)\n - *~W* week number of year with Monday as first day of week\n        (01...52)\n - *~x* week number of year with Monday as first day of week\n        (00...53)\n - *~X* locale's date representation, for example: \"07/31/00\"\n - *~y* last two digits of year (00...99)\n - *~Y* year\n - *~z* time zone in RFC-822 style\n - *~Z* symbol time zone\n" :similar ())

(date->string :type extended :synopsis "(date->string d)\n(date->string d format)" :description "Convert the date |d| using the string |format| as a\nspecification. Conventions for format are the same as the one\nof _<<seconds2string, primitive `seconds->string`>>_.\nIf |format| is omitted, it defaults to |\"~c\"|." :similar ())


;; Source file "thread.stk"

(make-thread :type extended :synopsis "(make-thread thunk)\n(make-thread thunk name)\n(make-thread thunk name stack-size)" :description "Returns a new thread. This thread is not automatically made runnable\n(the procedure |thread-start!| must be used for this). A thread has the\nfollowing fields:  name, specific, end-result, end-exception, and a list\nof locked/owned mutexes it owns. The thread's execution consists of a call\nto thunk with the \"initial continuation\". This continuation causes the\n(then) current thread to store the result in its end-result field, abandon\nall mutexes it owns, and finally terminate. The dynamic-wind\nstack of the initial continuation is empty. The optional name is an\narbitrary Scheme object which identifies the thread (useful for debugging);\nit defaults to an unspecified value. The specific field is set to an\nunspecified value.  The thread inherits the dynamic environment from the\ncurrent thread. Moreover, in this dynamic environment the exception handler\nis bound to the \"initial exception handler\" which is a unary procedure\nwhich causes the (then) current thread to store in its end-exception\nfield an \"uncaught exception\" object whose \"reason\" is the argument\nof the handler, abandon all mutexes it owns, and finally terminate.\n\nNOTE: The optional parameter |stack-size| permits to specify\nthe size (in words) reserved for the thread. This option does not exist\nin {{quick-link-srfi 18}}." :similar ())

(thread-handler-error-show :type extended :synopsis "(thread-handler-error-show)\n(thread-handler-error-show value)" :description "When an untrapped error occurs in a thread, it produces an\n<<make-thread, _uncaught exception_>> which can finally be\ntrapped when the thread is <<thread-join, _joined_>>.\nSetting the |thread-handler-error-show| parameter permits to see\nerror message as soon as possible, even without joining the thread.\nThis makes debugging easier. By default, this parameter is set to\n`#t`." :similar ())

(join-timeout-exception? :type extended :synopsis "(join-timeout-exception? obj)" :description "Returns `#t` if |obj| is a _join timeout exception_ object,\notherwise returns `#f`.\n\nA _join timeout exception_ is raised when thread-join! is called, the timeout\nis reached and no timeout-val is supplied." :similar ())

(abandoned-mutex-exception? :type extended :synopsis "(abandoned-mutex-exception? obj)" :description "Returns `#t` if |obj| is an _abandoned mutex exception_ object,\notherwise returns `#f`.\n\nAn _abandoned mutex exception_ is raised when the current thread locks\na mutex that was owned by a thread which terminated ,(see |mutex-lock!|)." :similar ())

(terminated-thread-exception? :type extended :synopsis "(terminated-thread-exception? obj)" :description "Returns `#t` if |obj| is a _terminated thread exception_ object, otherwise\nreturns `#f`.\n\nA _terminated thread exception_ is raised when thread-join! is\ncalled and the target thread has terminated as a result of a call to\n|thread-terminate!|." :similar ())

(uncaught-exception? :type extended :synopsis "(uncaught-exception? obj)" :description "Returns `#t` if |obj| is an _uncaught exception_ object, otherwise\nreturns `#f`.\n\nAn _uncaught exception_ is raised when |thread-join!| is called and the\ntarget thread has terminated because it raised an exception that called\nthe initial exception handler of that thread." :similar ())

(uncaught-exception-reason :type extended :synopsis "(uncaught-exception-reason exc)" :description "Returns the object which was passed to the initial exception handler\nof that thread (`exc` must be an _uncaught exception_ object)." :similar ())


;; Source file "STklos.init"


;; Source file "bigmatch.stk"

(match-lambda :type extended-syntax :synopsis "(match-lambda <clause> ...)" :description "|match-lambda| expands into a lambda-expression expecting an argument\nwhich, once applied to an expression, behaves exactly like a\n|match-case| expression.\n@lisp\n((match-lambda\n  ((?x ?x) 'foo)\n  ((?x ?- ?x) 'bar))\n '(a b a))           => bar\n@end lisp" :similar ())

(match-case :type extended-syntax :synopsis "(match-case <key> <clause> ...)" :description "The argument key may be any expression and each clause has the form\n@lisp\n(<pattern> <expression> ...)\n@end lisp\nA match-case expression is evaluated as follows: |<key>| is evaluated\nand the result is compared with each successive pattern. If the |<pattern>|\nin some clause yields a match, then the `|<expression>|`s in that clause are\nevaluated from left to right in an environment where the pattern variables\nare bound to the corresponding subparts of |<key>|, and the result of the\nlast expression in that clause is returned as the result of the\n|match-case| expression. If no pattern in any clause matches the |<key>|,\nthen, if there is an |else| clause, its expressions are evaluated and\nthe result of the last is the result of the whole |match-case|\nexpression; otherwise the result of the |match-case| expression\nis unspecified.\n\nThe equality predicate used for tests is |eq?|.\n@lisp\n(match-case '(a b a)\n   ((?x ?x) 'foo)\n   ((?x ?- ?x) 'bar))   => bar\n\n(match-case '(a (b c) d)\n   ((?x ?y) (list 'length=2 y x))\n   ((?x ?y ?z) (list 'length=3 z y x)))\n                        => (length=3 d (b c) a)\n@end lisp" :similar ())


;; Source file "conditions.stk"


;; Source file "describe.stk"

(describe :type extended :synopsis "(describe obj)" :description "Shows a brief description of |obj|. If the object is structured\nsuch as a struct, class or instance, some information about its\ninternal structure will be shown.\n\n*Using `describe` on simple values*\n@lisp\n(describe 5)\n  5 is an integer.\n\n(describe 5.4)\n  5.4 is a real.\n\n(describe 2+3i)\n  2+3i is a complex number.\n\n(describe #\\A)\n  #\\A is a character, ascii value is 65.\n@end lisp\n\n*Using `describe` on a class*\n@lisp\n(describe <integer>)\n  <integer> is a class. It's an instance of <class>.\n  Superclasses are:\n      <rational>\n  (No direct slot)\n  (No direct subclass)\n  Class Precedence List is:\n      <integer>\n      <rational>\n      <real>\n      <complex>\n      <number>\n      <top>\n  (No direct method)\n@end lisp\n\n*Using `describe` on structures*\n@lisp\n(define-struct person name email)\n(define one (make-person \"Some One\" \"one@domain.org\"))\n\n(describe person)\n  #[struct-type person 139786494092352] is a structure type whose name is person.\n  Parent structure type: #f\n  Slots are:\n       name\n       email\n\n(describe one)\n  #[struct person 139786494288064] is an instance of the structure type person.\n  Slots are:\n       name = \"Some One\"\n       email = \"one@domain.org\"\n@end lisp" :similar ())


;; Source file "env.stk"

(environment :type r7rs-procedure :synopsis "(environment set1 ...)" :description "This procedure returns a specifier for the environment that\nresults by starting with an empty environment and then\nimporting each *set*, considered as an import\nset, into it. The bindings of the environment represented by\nthe specifier, as is the environment itself.\n\nIn STklos,\n- each |set| argument can be a list (specifying an R7RS\n  library) or a symbol (specifying a module).\n- the return environment is an R7RS library (which can be\n  passed to |eval|).\n\n@lisp\n(eval '(* 7 3) (environment '(scheme base)))    => 21\n\n(let ((f (eval '(lambda (f x) (f x x))\n               (null-environment 5))))\n  (f + 10))                                     => 20\n\n(eval '(define foo 32)\n      (environment '(scheme base)))             => errror\n\n(let ((e (environment '(only (scheme base) + -)\n                      '(only (scheme write) display))))\n  (length (module-symbols e)))                  => 3\n\n(let ((e (environment '(prefix (only (scheme base) car)\n                               foo-))))\n   (module-symbols e))                            => (foo-car)\n\n@end lisp" :similar ())

(interaction-environment :type procedure :synopsis "(interaction-environment)" :description "This procedure returns the environment in the expression are\nevaluated by default (the {{stklos}} module). The returned environment\nis mutable." :similar ())

(null-environment :type procedure :synopsis "(null-environment)\n(null-environment version)" :description "Returns a specifier for an environment that is empty except for\nthe (syntactic) bindings for all syntactic keywords defined in\nthe R5RS report.\n\nNOTE: In STklos, |null-environment| function can be called\nwithout the version number (defaults to 5)." :similar ())

(scheme-report-environment :type procedure :synopsis "(scheme-report-environment)\n(scheme-report-environment version)" :description "Returns a specifier for an environment that contains the bindings defined\nin the R5RS report.\n\nNOTE: In STklos, |scheme-report-environment| function can be called\nwithout the version number (defaults to 5)." :similar ())


;; Source file "expand.ss"


;; Source file "full-syntax.stk"

(let-syntax :type syntax :synopsis "(let-syntax <bindings> <body>)" :description "|<Bindings>| should have the form\n@lisp\n((<keyword> <transformer spec>) ...)\n@end lisp\nEach |<keyword>| is an identifier, each |<transformer spec>| is an instance of\n|syntax-rules|, and |<body>| should be a sequence of one or more expressions.  It\nis an error for a |<keyword>| to appear more than once in the list of keywords\nbeing bound.\n\nThe |<body>| is expanded in the syntactic environment obtained by\nextending the syntactic environment of the |let-syntax| expression with macros\nwhose keywords are the `|<keyword>|`s, bound to the specified transformers.  Each\nbinding of a |<keyword>| has |<body>| as its region.\n\nNOTE: |let-syntax| is available only after having required the file\n|\"full-syntax\"|.\n@lisp\n(let-syntax ((when (syntax-rules ()\n                  ((when test stmt1 stmt2 ...)\n                   (if test\n                       (begin stmt1\n                              stmt2 ...))))))\n  (let ((if #t))\n    (when if (set! if 'now))\n    if))                           =>  now\n\n(let ((x 'outer))\n  (let-syntax ((m (syntax-rules () ((m) x))))\n    (let ((x 'inner))\n      (m))))                       =>  outer\n@end lisp" :similar ())

(letrec-syntax :type syntax :synopsis "(letrec-syntax <bindings> <body>)" :description "Syntax of |letrec-syntax| is the same as for |let-syntax|.\n\nThe |<body>| is expanded in the syntactic environment obtained by\nextending the syntactic environment of the |letrec-syntax| expression\nwith macros whose keywords are the `|<keyword>|`s, bound to the specified\ntransformers.  Each binding of a |<keyword>| has the |<bindings>| as well\nas the |<body>| within its region, so the transformers can transcribe\nexpressions into uses of the macros introduced by the |letrec-syntax|\nexpression.\n\nNOTE: |letrec-syntax| is available only after having required the file\n|\"full-syntax\"|.\n\n@lisp\n(letrec-syntax\n  ((my-or (syntax-rules ()\n            ((my-or) #f)\n            ((my-or e) e)\n            ((my-or e1 e2 ...)\n             (let ((temp e1))\n               (if temp\n                   temp\n                   (my-or e2 ...)))))))\n  (let ((x #f)\n        (y 7)\n        (temp 8)\n        (let odd?)\n        (if even?))\n    (my-or x\n           (let temp)\n           (if y)\n           y)))        =>  7\n@end lisp" :similar ())


;; Source file "getopt.stk"

(arg-usage :type extended :synopsis "(arg-usage port)\n(arg-usage port as-sexpr)" :description "This procedure is only bound inside a |parse-arguments| form.\nIt pretty prints the help associated to the clauses of the\n|parse-arguments| form on the given port. If the argument\n|as-sexpr| is passed and is not `#f`, the help strings are\nprinted on |port| as __Sexpr__s. This is useful if the help\nstrings need to be manipulated by a program.\n" :similar ())

(parse-arguments :type extended :synopsis "(parse-arguments <args> <clause1> <clause2> ...)" :description "The |parse-arguments| special form is used to parse the\ncommand line arguments of a Scheme script. The implementation of\nthis form internally uses the GNU C |getopt| function. As a\nconsequence |parse-arguments| accepts options which start with\nthe '-' (short option) or '--' characters (long option).\n\nThe first argument of |parse-arguments| is a list of the arguments\ngiven to the program (comprising the program name in the CAR of this\nlist). Following arguments are clauses. Clauses are described later.\n\nBy  default, |parse-arguments| permutes the contents of (a copy) of\nthe arguments as it scans, so that eventually all the non-options are\nat the end. However, if the shell environment variable |POSIXLY_CORRECT|\nis set, then option processing stops as soon as a non-option argument\nis encountered.\n\nA clause must follow the syntax:\n```\n<clause>       => string @pipe <list-clause>\n<list clause>  => (<option descr> <expr> ...) @pipe (else <expr> ...)\n<option descr> => (<option name> [<keyword> value]*)\n<option name>  => string\n<keyword>      => :alternate @pipe :arg @pipe :help\n```\n\nA string clause is used to build the  help associated to the command.\nA list clause must follow the syntax describes an option. The\n`|<expr>|`s associated to a list clauses are executed when the option\nis recognized.\nThe |else| clauses is executed when all parameters have\nbeen parsed. The |:alternate| key permits to have an alternate name for an\noption (generally a short or long name if the option name is a\nshort or long name).  The |:help| is used to provide help about the\nthe option. The |:arg| is used when the option admit a parameter:\nthe symbol given after |:arg| will be bound to the value of the option\nargument when the corresponding |<expr>|s will be executed.\n\nIn an |else| clause the symbol |other-arguments| is bound to the\nlist of the arguments which are not options.\n\nThe following example shows a rather complete usage of the\n|parse-arguments| form\n\n@lisp\n#!/usr/bin/env stklos\n\n(define (main args)\n  (parse-arguments args\n     \"Usage: foo [options] [parameter ...]\"\n     \"General options:\"\n         ((\"verbose\" :alternate \"v\" :help \"be more verbose\")\n           (printf \"Seen the verbose option~%\"))\n         ((\"long\" :help \"a long option alone\")\n           (printf \"Seen the long option~%\"))\n         ((\"s\" :help \"a short option alone\")\n           (printf \"Seen the short option~%\"))\n     \"File options:\"\n         ((\"input\" :alternate \"f\" :arg file\n                   :help \"use <file> as input\")\n           (printf \"Seen the input option with ~S argument~%\" file))\n         ((\"output\" :alternate \"o\" :arg file\n                    :help \"use <file> as output\")\n           (printf \"Seen the output option with ~S argument~%\" file))\n     \"Misc:\"\n         ((\"help\" :alternate \"h\"\n                  :help \"provides help for the command\")\n           (arg-usage (current-error-port))\n           (exit 1))\n     (else\n         (printf \"All options parsed. Remaining arguments are ~S~%\"\n                 other-arguments))))\n@end lisp\n\nThe following program invocation\n@lisp\nfoo -vs --input in -o out arg1 arg2\n@end lisp\n\nproduces the following output\n```\nSeen the verbose option\nSeen the short option\nSeen the input option with \"in\" argument\nSeen the output option with \"out\" argument\nAll options parsed. Remaining arguments are (\"arg1\" \"arg2\")\n```\n\nFinally, the program invocation\n@lisp\nfoo --help\n@end lisp\nproduces the following output\n```\nUsage: foo [options] [parameter ...]\nGeneral options:\n  --verbose, -v               be more verbose\n  --long                      a long option alone\n  -s                          a short option alone\nFile options:\n  --input=<file>, -f <file>   use <file> as input\n  --output=<file>, -o <file>  use <file> as output\nMisc:\n  --help, -h                  provides help for the command\n```\n\n**Notes:**\n\n* Short option can be concatenated. That is,\n+\n@lisp\nprog -abc\n@end lisp\n+\nis equivalent to the following program call\n+\n@lisp\nprog -a -b -c\n@end lisp\n\n* Any argument following a '--' argument is no more considered as\n  an option, even if it starts with a '-' or '--'.\n\n* Option with a parameter can be written in several ways. For instance\n  to set the output in the |bar| file for the previous example can be\n  expressed as\n\n** |--output=bar|, or\n** |-o bar|, or\n** |-obar|\n" :similar ())


;; Source file "help.stk"

(help :type extended :synopsis "(help obj)\n(help)" :description "When called with an argument, |help| tries to give some help on the\ngiven object, which could be a symbol, a procedure, a generic function\nor a method. Whe called called without arguments, |help| enters a\nread-help-print loop. The documentation for an object is searched in\nthe object itself or, if absent, in STklos documentation.  Inserting\nthe documentation in an objet is very similar to Emacs docstrings: a\ndocumentation string is defined among the code. Exemples of such\nstrings are given below\n@lisp\n(define (foo n)\n  \"If the function body starts with a string, it's a docstring\"\n  (+ n 1))\n\n(define-generic bar\n  :documentation \"Generic function docsting for bar\")\n\n(define-method bar ((x <integer>))\n  \"Probably less useful: as in functions, methods can have docstrings\"\n  (- x 1))\n@end lisp" :similar ())


;; Source file "lex-rt.stk"


;; Source file "make-C-boot.stk"


;; Source file "pretty-print.stk"

(pp :type extended :synopsis "(pretty-print sexpr :key port width)\n(pp sexpr :key port width)" :description "This function tries to obtain a pretty-printed representation of |sexpr|.\nThe pretty-printed form is written on |port| with lines which are no\nmore long than |width| characters. If |port| is omitted if defaults to\nthe current error port. As a special convention, if |port| is `#t`,\noutput goes to the current output port and if |port| is `#f`, the output\nis returned as a string by |pretty-print|.\nNote that |pp| is another name for |pretty-print|.\n" :similar (pretty-print))

(pretty-print :see pp)

;; Source file "slib.stk"


;; Source file "trace.stk"

(trace :type extended-syntax :synopsis "(trace f-name ...)" :description "Invoking |trace| with one or more function names causes the functions\nnamed to be traced. Henceforth, whenever such a function is invoked,\ninformation about the call and the returned values, if any, will be\nprinted on the current error port.\n\nCalling |trace| with no argument returns the list of traced functions." :similar ())

(untrace :type extended-syntax :synopsis "(untrace f-name ...)" :description "Invoking |untrace| with one or more function names causes the functions\nnamed not to be traced anymore.\n\nCalling |untrace| with no argument will untrace all the functions\ncurrently traced." :similar ())


;; Source file "readline-complete.c"

;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Sat Mar 25 05:01:48 2023


;; Source file "base.stk"


;; Source file "case-lambda.stk"


;; Source file "char.stk"


;; Source file "complex.stk"


;; Source file "cxr.stk"


;; Source file "eval.stk"


;; Source file "file.stk"


;; Source file "inexact.stk"


;; Source file "lazy.stk"


;; Source file "load.stk"


;; Source file "process-context.stk"


;; Source file "r5rs.stk"


;; Source file "read.stk"


;; Source file "repl.stk"


;; Source file "time.stk"


;; Source file "write.stk"


;; Source file "list.stk"


;; Source file "charset.stk"


;; Source file "stream.stk"


;; Source file "box.stk"


;; Source file "set.stk"


;; Source file "list-queue.stk"


;; Source file "hash-table.stk"


;; Source file "lseq.stk"


;; Source file "comparator.stk"


;; Source file "generator.stk"


;; Source file "ideque.stk"


;; Source file "text.stk"


;; Source file "division.stk"


;; Source file "bitwise.stk"


;; Source file "ilist.stk"

(xipair :type extended :synopsis "(xipair d a)" :description "The same as |(lambda (d a) (ipair a d))|\n\nOf utility only as a value to be conveniently passed to\nhigher-order procedures.\n\n@lisp\n(xipair (iq b c) 'a) => (a b c)\n@end lisp\n\nThe name stands for \"eXchanged Immutable PAIR.\"" :similar ())

(make-ilist :type extended :synopsis "(make-ilist n [fill])" :description "Returns an n-element ilist, whose elements are all the value\nfill. If the fill argument is not given, the elements of the\nilist may be arbitrary values.\n\n@lisp\n(make-ilist 4 'c) => (c c c c)\n@end lisp" :similar ())

(ilist-tabulate :type extended :synopsis "(ilist-tabulate n init-proc)" :description "Returns an n-element ilist. Element i of the ilist,\nwhere 0 <= i < n, is produced by |(init-proc i)|.\nNo guarantee is made about the dynamic order in which\n|init-proc| is applied to these indices.\n\n@lisp\n(ilist-tabulate 4 values) => (0 1 2 3)\n@end lisp" :similar ())

(ilist-copy :type extended :synopsis "(ilist-copy lst)" :description "Copies the spine of the argument, including the ilist tail." :similar ())

(iiota :type extended :synopsis "(iiota count [ start step ]" :description "Returns an ilist containing the elements\n\n|(start start+step ... start+(count-1)*step)|\n\nThe |start| and |step| parameters default to 0 and 1,\nrespectively. This procedure takes its name from the APL\nprimitive.\n\n@lisp\n(iiota 5) => (0 1 2 3 4)\n(iiota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)\n@end lisp" :similar ())

(null-ilist? :type extended :synopsis "(null-ilist? lst)" :description "Ilist is a proper ilist. This procedure returns true if the argument\nis the empty list |()|, and false otherwise. It is an error to pass this\nprocedure a value which is not a proper ilist. This procedure is\nrecommended as the termination condition for ilist-processing\nprocedures that are not defined on dotted ilists." :similar ())

(not-ipair? :type extended :synopsis "(not-ipair? x)" :description "This is the same as |(lambda (x) (not (ipair? x)))|\n\nProvided as a procedure as it can be useful as the termination\ncondition for ilist-processing procedures that wish to handle\nall ilists, both proper and dotted." :similar ())

(ilist? :type extended :synopsis "(proper-ilist? x)\n(ilist? x)" :description "These identifiers are bound either to the same procedure.\nIn either case, true is returned iff |x| is a proper ilist\nâ\x80;\x94; a ()-terminated ilist.\n\nMore carefully: The empty list is a proper ilist. An ipair\nwhose icdr is a proper ilist is also a proper ilist. Everything\nelse is a dotted ilist. This includes non-ipair, non-() values\n(e.g. symbols, numbers, mutable pairs), which are considered to\nbe dotted ilists of length 0." :similar (proper-ilist?))

(proper-ilist? :see ilist?)
(dotted-ilist? :type extended :synopsis "(dotted-ilist? x)" :description "Returns true if |x| is a finite, non-nil-terminated ilist. That is,\nthere exists an n >= 0 such that |icdrn(x)| is neither an ipair nor\n|()|. This includes non-ipair, non-() values (e.g. symbols, numbers),\nwhich are considered to be dotted ilists of length 0.\n\n@lisp\n(dotted-ilist? x) = (not (proper-ilist? x))\n@end lisp" :similar ())

(ilist= :type extended :synopsis "(ilist= elt= ilist1 ...)" :description "Determines ilist equality, given an element-equality procedure. Proper\nilist A equals proper ilist B if they are of the same length, and\ntheir corresponding elements are equal, as determined by |elt=|. If the\nelement-comparison procedure's first argument is from ilisti, then\nits second argument is from ilisti+1, i.e. it is always called as\n|(elt= a b)| for |a| an element of ilist A, and |b| an element of ilist B.\n\nIn the n-ary case, every ilisti is compared to ilisti+1 (as opposed,\nfor example, to comparing ilist1 to ilisti, for i>1). If there are no\nilist arguments at all, |ilist=| simply returns true.\n\nIt is an error to apply ilist= to anything except proper ilists. It\ncannot reasonably be extended to dotted ilists, as it provides no way\nto specify an equality procedure for comparing the ilist terminators.\n\nNote that the dynamic order in which the elt= procedure is applied to\npairs of elements is not specified. For example, if ilist= is applied\nto three ilists, A, B, and C, it may first completely compare A to B,\nthen compare B to C, or it may compare the first elements of A and B,\nthen the first elements of B and C, then the second elements of A and\nB, and so forth.\n\nThe equality procedure must be consistent with |eq?|. That is, it must\nbe the case that\n\n@lisp\n(eq? x y) => (elt= x y)\n@end lisp\n\nNote that this implies that two ilists which are |eq?| are always ilist=,\nas well; implementations may exploit this fact to \"short-cut\" the\nelement-by-element comparisons.\n\n@lisp\n(ilist= eq?) => #t       ; Trivial cases\n(ilist= eq? (iq a)) => #t\n@end lisp" :similar ())

(icdr :type extended :synopsis "(icar ipair)\n(icdr ipair)" :description "These procedures return the contents of the icar and icdr\nfield of their argument, respectively. Note that it is an\nerror to apply them to the empty ilist.\n\n@lisp\n(icar (iq a b c))       =>  a          (icdr (iq a b c))     =>  (b c)\n(icar (iq (a) b c d))   =>  (a)        (icdr (iq (a) b c d)) =>  (b c d)\n(icar (ipair 1 2))      =>  1          (icdr (ipair 1 2))    =>  2\n(icar '())              =>  *error*    (icdr '())            =>  *error*\n@end lisp" :similar (icar))

(icar :see icdr)
(itenth :type extended :synopsis "(ifirst   ipair)\n(isecond  ipair)\n(ithird   ipair)\n(ifourth  ipair)\n(ififth   ipair)\n(isixth   ipair)\n(iseventh ipair)\n(ieighth  ipair)\n(ininth   ipair)\n(itenth   ipair)" :description "Synonyms for car, cadr, caddr, ...\n\n@lisp\n(ithird '(a b c d e)) => c\n@end lisp" :similar (ininth ieighth iseventh isixth ififth ifourth ithird isecond ifirst))

(ininth :see itenth)
(ieighth :see itenth)
(iseventh :see itenth)
(isixth :see itenth)
(ififth :see itenth)
(ifourth :see itenth)
(ithird :see itenth)
(isecond :see itenth)
(ifirst :see itenth)
(ilist-tail :type extended :synopsis "(itake x i)\n(idrop x i)\n(ilist-tail x i)" :description "|itake| returns the first i elements of ilist |x|.\n|idrop| returns all but the first i elements of ilist |x|.\n|ilist-tail| is either the same procedure as idrop or else a procedure\nwith the same behavior.\n\n@lisp\n (itake (iq a b c d e)  2) => (a b)\n (idrop (iq a b c d e)  2) => (c d e)\n@end lisp\n|x| may be any value â\x80;\x94; a proper or dotted ilist:\n\n@lisp\n(itake (ipair 1 (ipair 2 (ipair 3 'd)))    => (1 2)\n(idrop (ipair 1 (ipair 2 (ipair 3 'd))) 2) => (3 . d)\n(itake (ipair 1 (ipair 2 (ipair 3 'd))) 3) => (1 2 3)\n(idrop (ipair 1 (ipair 2 (ipair 3 'd))) 3) => d\n@end lisp\n\nFor a legal |i|, itake and idrop partition the ilist in a manner\nwhich can be inverted with iappend:\n\n@lisp\n(iappend (itake x i) (idrop x i)) = x\n@end lisp\n\nidrop is exactly equivalent to performing i icdr operations on |x|;\nthe returned value shares a common tail with |x|." :similar (idrop itake))

(idrop :see ilist-tail)
(itake :see ilist-tail)
(idrop-right :type extended :synopsis "(itake-right dilist i)\n(idrop-right dilist i)" :description "|Itake-right| returns the last |i| elements of |dilist|.\n|Idrop-right| returns all but the last |i| elements of |dilist|.\n\n@lisp\n(itake-right (iq a b c d e) 2) => (d e)\n(idrop-right (iq a b c d e) 2) => (a b c)\n@end lisp\n\nThe returned ilist may share a common tail with the argument |ilist|.\n\n|dilist| may be any ilist, either proper or dotted:\n\n@lisp\n(itake-right (iq ipair 1 (ipair 2 (ipair 3 'd))) 2) => (2 3 . d)\n(idrop-right (ipair 1 (ipair 2 (ipair 3 'd))) 2)    => (1)\n(itake-right (ipair 1 (ipair 2 (ipair 3 'd))) 0)    => d\n(idrop-right (ipair 1 (ipair 2 (ipair 3 'd))) 0)    => (1 2 3)\n@end lisp\n\nFor a legal |i|, |itake-right| and |idrop-right| partition the ilist\nin a manner which can be inverted with |iappend|:\n\n```\n(iappend (itake dilist i) (idrop dilist i)) = dilist\n```\n\n|Itake-right|++'++s return value is guaranteed to share a common tail\nwith |dilist|." :similar (itake-right))

(itake-right :see idrop-right)
(isplit-at :type extended :synopsis "(isplit-at  x i)" :description "|Isplit-at| splits the ilist |x| at index |i|, returning an\nilist of the first |i| elements, and the remaining tail. It is\nequivalent to\n\n@lisp\n(values (itake x i) (idrop x i))\n@end lisp" :similar ())

(last-ipair :type procedure :synopsis "(ilast ipair)\n(last-ipair ipair)" :description "|Ilast| returns the last element of the non-empty, possibly\ndotted, ilist ipair.\n|Last-ipair| returns the last ipair in the non-empty ilist pair.\n\n@lisp\n(ilast (iq a b c))      => c\n(last-ipair (iq a b c)) => (c)\n@end lisp" :similar (ilast))

(ilast :see last-ipair)
(ilength :type extended :synopsis "(ilength  ilist)" :description "Returns the length of its argument. It is an error to pass a value\nto |ilength| which is not a proper ilist (()-terminated).\n\nThe length of a proper ilist is a non-negative integer n such that\n|icdr| applied n times to the ilist produces the empty list." :similar ())

(iconcatenate :type extended :synopsis "(iconcatenate  ilist-of-ilists)" :description "Appends the elements of its argument together. That is, |iconcatenate|\nreturns the same as\n\n@lisp\n(iapply iappend ilist-of-ilists)\n@end lisp\n\nor, equivalently,\n\n@lisp\n(ireduce-right iappend '() ilist-of-ilists)\n@end lisp\n\nAs with |iappend|, the last element of the input list may be any\nvalue at all." :similar ())

(ireverse :type extended :synopsis "(ireverse  ilist)" :description "Returns a newly allocated ilist consisting of the elements of |ilist|\nin reverse order.\n\n@lisp\n(ireverse (iq a b c))              =>  (c b a)\n(ireverse (iq a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)\n@end lisp" :similar ())

(iappend-reverse :type extended :synopsis "(iappend-reverse  rev-head tail)" :description "|Iappend-reverse| returns |(iappend (ireverse rev-head) tail)|.\nIt is provided because it is a common operation â\x80;\x94; a common list-processing\nstyle calls for this exact operation to transfer values accumulated in\nreverse order onto the front of another ilist, and because the\nimplementation is significantly more efficient than the simple\ncomposition it replaces. (But note that this pattern of iterative\ncomputation followed by a reverse can frequently be rewritten as a\nrecursion, dispensing with the reverse and iappend-reverse steps, and\nshifting temporary, intermediate storage from the heap to the stack,\nwhich is typically a win for reasons of cache locality and eager\nstorage reclamation.)" :similar ())

(izip :type extended :synopsis "(izip ilist1 ilist2 ...)" :description "Returns the same as |(lambda ilists (iapply imap ilist ilists))|\n\nIf |izip| is passed n ilists, it returns an ilist as long as the shortest\nof these ilists, each element of which is an n-element ilist comprised of\nthe corresponding elements from the parameter ilists.\n\n@lisp\n(izip (iq one two three)\n     (iq 1 2 3)\n     (iq odd even odd even odd even odd even))\n    => ((one 1 odd) (two 2 even) (three 3 odd))\n\n(izip (iq 1 2 3)) => ((1) (2) (3))\n@end lisp" :similar ())

(iunzip5 :type extended :synopsis "(iunzip1 ilist)\n(iunzip2 ilist)\n(iunzip3 ilist)\n(iunzip4 ilist)\n(iunzip5 ilist)" :description "|Iunzip1| takes an ilist of ilists, where every ilist must\ncontain at least one element, and returns an ilist containing\nthe initial element of each such ilist. That is, it returns\n|(imap icar ilists)|. |Iunzip2| takes an ilist of ilists, where\nevery ilist must contain at least two elements, and returns two\nvalues: an ilist of the first elements, and an ilist of the second\nelements. |Iunzip3| does the same for the first three elements of\nthe ilists, and so forth.\n\n@lisp\n(iunzip2 (iq (1 one) (2 two) (3 three))) =>\n    (1 2 3)\n    (one two three)\n@end lisp" :similar (iunzip4 iunzip3 iunzip2 iunzip1))

(iunzip4 :see iunzip5)
(iunzip3 :see iunzip5)
(iunzip2 :see iunzip5)
(iunzip1 :see iunzip5)
(icount :type extended :synopsis "(icount pred ilist1 ilist2 ...)" :description "|Pred| is a procedure taking as many arguments as there are ilists and\nreturning a single value. It is applied element-wise to the elements\nof the ilists, and a count is tallied of the number of elements that\nproduce a true value. This count is returned. count is \"iterative\" in\nthat it is guaranteed to apply pred to the ilist elements in a\nleft-to-right order. The counting stops when the shortest ilist\nexpires.\n\n@lisp\n(icount even? (iq 3 1 4 1 5 9 2 5 6))            => 3\n(icount < (iq 1 2 4 8) (iq 2 4 6 8 10 12 14 16)) => 3\n@end lisp" :similar ())

(ifold :type extended :synopsis "(ifold kons knil ilist1 ilist2 ...)" :description "The fundamental ilist iterator.\n\nFirst, consider the single ilist-parameter case. If\n|ilist1| = |(e1 e2 ... en)|, then this procedure returns\n\n@lisp\n  (kons en ... (kons e2 (kons e1 knil)) ... )\n@end lisp\n\nThat is, it obeys the (tail) recursion\n\n@lisp\n(ifold kons knil lis) = (ifold kons (kons (icar lis) knil) (icdr lis))\n(ifold kons knil '()) = knil\n@end lisp\n\nExamples:\n\n @lisp\n  (ifold + 0 lis)                    ; Add up the elements of LIS.\n  (ifold ipair '() lis)              ; Reverse LIS.\n  (ifold ipair tail rev-head)        ; See APPEND-REVERSE.\n@end lisp\n\n@lisp\n;; How many symbols in LIS?\n(ifold (lambda (x count) (if (symbol? x) (+ count 1) count))\n      0\n      lis)\n\n;; Length of the longest string in LIS:\n(ifold (lambda (s max-len) (max max-len (string-length s)))\n      0\n      lis)\n@end lisp\n\nIf n |ilist| arguments are provided, then the |kons| function must take\nn+1 parameters: one element from each ilist, and the \"seed\" or fold\nstate, which is initially knil. The fold operation terminates when the\nshortest ilist runs out of values:\n\n@lisp\n(ifold ipair* '() (iq a b c) (iq 1 2 3 4 5)) => (c 3 b 2 a 1)\n@end lisp" :similar ())

(ifold-right :type extended :synopsis "(ifold-right kons knil ilist1 ilist2 ...)" :description "The fundamental ilist recursion operator.\n\nFirst, consider the single ilist-parameter case. If\n|ilist1 = (e1 e2 ... en)|, then this procedure returns\n|(kons e1 (kons e2 ... (kons en knil)))|\n\nThat is, it obeys the recursion\n\n@lisp\n(ifold-right kons knil lis) = (kons (icar lis) (ifold-right kons knil (icdr lis)))\n(ifold-right kons knil '()) = knil\n@end lisp\n\nExamples:\n\n@lisp\n(ifold-right ipair '() lis)          ; Copy LIS.\n\n;; Filter the even numbers out of LIS.\n(ifold-right (lambda (x l) (if (even? x) (ipair x l) l)) '() lis))\n@end lisp\n\nIf n ilist arguments are provided, then the |kons| procedure must take\nn+1 parameters: one element from each ilist, and the \"seed\" or fold\nstate, which is initially |knil|. The fold operation terminates when the\nshortest ilist runs out of values:\n\n@lisp\n(ifold-right ipair* '() (iq a b c) (iq 1 2 3 4 5)) => (a 1 b 2 c 3)\n@end lisp" :similar ())

(ipair-fold :type extended :synopsis "(ipair-fold kons knil ilist1 ilist2 ...)" :description "Analogous to fold, but kons is applied to successive sub-ilists of the\nilists, rather than successive elements â\x80;\x94; that is, kons is applied to\nthe ipairs making up the lists, giving this (tail) recursion:\n\n@lisp\n(ipair-fold kons knil lis) = (let ((tail (icdr lis)))\n                              (ipair-fold kons (kons lis knil) tail))\n(ipair-fold kons knil '()) = knil\n@end lisp\n\nExample:\n\n@lisp\n(ipair-fold ipair '() (iq a b c)) => ((c) (b c) (a b c))\n@end lisp" :similar ())

(ipair-fold-right :type extended :synopsis "(ipair-fold-right kons knil ilist1 ilist2 ...)" :description "Holds the same relationship with |ifold-right| that |ipair-fold|\nholds with |ifold|. Obeys the recursion\n\n@lisp\n (ipair-fold-right kons knil lis) =\n     (kons lis (ipair-fold-right kons knil (icdr lis)))\n (ipair-fold-right kons knil '()) = knil\n@end lisp\n\nExample:\n\n@lisp\n(ipair-fold-right ipair '() (iq a b c)) => ((a b c) (b c) (c))\n@end lisp" :similar ())

(ireduce :type extended :synopsis "(ireduce f ridentity ilist)" :description "|Ireduce| is a variant of |ifold|.\n\n|Ridentity| should be a \"right identity\" of the procedure |f|\nâ\x80;\x94; that is, for any value |x| acceptable to |f|,\n@lisp\n (f x ridentity) = x\n@end lisp\n|Ireduce| has the following definition:\n\n     If ilist = (), return ridentity;\n     Otherwise, return (ifold f (icar ilist) (icdr ilist)).\n\n...in other words, we compute |(ifold f ridentity ilist)|.\n\nNote that ridentity is used only in the empty-list case. You typically\nuse ireduce when applying |f| is expensive and you'd like to avoid the\nextra application incurred when ifold applies |f| to the head of |ilist|\nand the identity value, redundantly producing the same value passed in\nto |f|. For example, if |f| involves searching a file directory or\nperforming a database query, this can be significant. In general,\nhowever, |ifold| is useful in many contexts where |ireduce| is\nnot (consider the examples given in the ifold definition â\x80;\x94; only one of\nthe five folds uses a function with a right identity. The other four\nmay not be performed with ireduce).\n\n@lisp\n;; take the max of an ilist of non-negative integers.\n(ireduce max 0 nums) ; i.e., (iapply max 0 nums)\n@end lisp" :similar ())

(ireduce-right :type extended :synopsis "(ireduce-right f ridentity ilist)" :description "|Ireduce-right| is the |fold-right| variant of |ireduce|. It obeys the\nfollowing definition:\n@lisp\n(ireduce-right f ridentity '()) = ridentity\n(ireduce-right f ridentity (iq e1)) = (f e1 ridentity) = e1\n(ireduce-right f ridentity (iq e1 e2 ...)) =\n    (f e1 (ireduce f ridentity (e2 ...)))\n@end lisp\n...in other words, we compute |(ifold-right f ridentity ilist)|.\n\n@lisp\n;; Append a bunch of ilists together.\n;; I.e., (iapply iappend ilist-of-ilists)\n(ireduce-right iappend '() ilist-of-ilists)\n@end lisp" :similar ())

(iunfold :type extended :synopsis "(iunfold p f g seed [tail-gen])" :description "|Iunfold| is best described by its basic recursion:\n\n@lisp\n(iunfold p f g seed) =\n    (if (p seed) (tail-gen seed)\n        (ipair (f seed)\n              (iunfold p f g (g seed))))\n@end lisp\n\n  p        Determines when to stop unfolding.\n  f        Maps each seed value to the corresponding ilist element.\n  g        Maps each seed value to next seed value.\n  seed     The \"state\" value for the unfold.\n  tail-gen Creates the tail of the ilist; defaults to (lambda (x) '())\n\nIn other words, we use g to generate a sequence of seed values\n seed, g(seed), g2(seed), g3(seed), ...\n These seed values are mapped to ilist elements by f, producing\nthe elements of the result ilist in a left-to-right order. P says when\nto stop.\n\n|Iunfold| is the fundamental recursive ilist constructor, just as\n|ifold-right| is the fundamental recursive ilist consumer. While\n|iunfold| may seem a bit abstract to novice functional programmers,\nit can be used in a number of ways:\n\n@lisp\n;; Ilist of squares: 1^2 ... 10^2\n(iunfold (lambda (x) (> x 10))\n         (lambda (x) (* x x))\n         (lambda (x) (+ x 1))\n         1)\n\n(iunfold null-ilist? icar icdr lis) ; Copy a proper ilist.\n\n;; Read current input port into an ilist of values.\n(iunfold eof-object? values (lambda (x) (read)) (read))\n\n;; Copy a possibly non-proper ilist:\n(iunfold not-ipair? icar icdr lis\n         values)\n\n;; Append HEAD onto TAIL:\n(iunfold null-ilist? icar icdr head\n        (lambda (x) tail))\n@end lisp\n\nInterested functional programmers may enjoy noting that ifold-right and\niunfold are in some sense inverses. That is, given operations |knull?|,\n|kar|, |kdr|, |kons|, and |knil| satisfying\n@lisp\n(kons (kar x) (kdr x)) = x and (knull? knil) = #t\n@end lisp\nthen\n@lisp\n(ifold-right kons knil (iunfold knull? kar kdr x)) = x\n@end lisp\nand\n@lisp\n(iunfold knull? kar kdr (ifold-right kons knil x)) = x.\n@end lisp\nThis combinator sometimes is called an \"anamorphism;\" when an explicit\ntail-gen procedure is supplied, it is called an \"apomorphism.\"" :similar ())

(iunfold-right :type extended :synopsis "(iunfold-right p f g seed [tail])" :description "|Iunfold-right| constructs an ilist with the following loop:\n\n@lisp\n(let lp ((seed seed) (lis tail))\n  (if (p seed) lis\n      (lp (g seed)\n          (ipair (f seed) lis))))\n@end lisp\n\n  p         Determines when to stop unfolding.\n  f         Maps each seed value to the corresponding ilist element.\n  g         Maps each seed value to next seed value.\n  seed      The \"state\" value for the unfold.\n  tail      ilist terminator; defaults to '().\n\nIn other words, we use g to generate a sequence of seed values\n@lisp\nseed, g(seed), g2(seed), g3(seed), ...\n@end lisp\nThese seed values are mapped to ilist elements by |f|, producing the\nelements of the result ilist in a right-to-left order. P says when to\nstop.\n\n|Iunfold-right| is the fundamental iterative ilist constructor, just as\n|ifold| is the fundamental iterative ilist consumer. While |iunfold-right|\nmay seem a bit abstract to novice functional programmers, it can be\nused in a number of ways:\n\n@lisp\n;; Ilist of squares: 1^2 ... 10^2\n(iunfold-right zero?\n              (lambda (x) (* x x))\n              (lambda (x) (- x 1))\n              10)\n\n;; Reverse a proper ilist.\n(iunfold-right null-ilist? icar icdr lis)\n\n;; Read current input port into an ilist of values.\n(iunfold-right eof-object? values (lambda (x) (read)) (read))\n\n;; (iappend-reverse rev-head tail)\n(iunfold-right null-ilist? icar icdr rev-head tail)\n@end lisp\n\nInterested functional programmers may enjoy noting that ifold and\n|iunfold-right| are in some sense inverses. That is, given operations\n|knull?|, |kar|, |kdr|, |kons|, and |knil| satisfying\n@lisp\n(kons (kar x) (kdr x)) = x and (knull? knil) = #t\n@end lisp\nthen\n@lisp\n(ifold kons knil (iunfold-right knull? kar kdr x)) = x\n@end lisp\nand\n@lisp\n(iunfold-right knull? kar kdr (ifold kons knil x)) = x.\n@end lisp" :similar ())

(imap :type extended :synopsis "(imap proc ilist1 ilist2 ...)" :description "proc is a procedure taking as many arguments as there are ilist\narguments and returning a single value. imap applies proc element-wise\nto the elements of the ilists and returns an ilist of the results, in\norder. The dynamic order in which proc is applied to the elements of\nthe ilists is unspecified.\n\n@lisp\n(imap icadr (iq (a b) (d e) (g h))) =>  (b e h)\n\n(imap (lambda (n) (expt n n))\n     (iq 1 2 3 4 5))\n    =>  (1 4 27 256 3125)\n\n(imap + (iq 1 2 3) (iq 4 5 6)) =>  (5 7 9)\n\n(let ((count 0))\n  (imap (lambda (ignored)\n         (set! count (+ count 1))\n         count)\n       (iq a b))) =>  (1 2) or (2 1)\n@end lisp" :similar ())

(ifor-each :type extended :synopsis "(ifor-each proc ilist1 ilist2 ...)" :description "The arguments to |ifor-each| are like the arguments to |imap|, but\n|ifor-each| calls |proc| for its side effects rather than for its\nvalues. Unlike |imap|, |ifor-each| is guaranteed to call proc on the\nelements of the ilists in order from the first element(s) to the last,\nand the value returned by |ifor-each| is unspecified.\n\n@lisp\n(let ((v (make-vector 5)))\n  (ifor-each (lambda (i)\n              (vector-set! v i (* i i)))\n            (iq 0 1 2 3 4))\n  v)  =>  #(0 1 4 9 16)\n@end lisp" :similar ())

(iappend-map :type extended :synopsis "(iappend-map  f ilist1 ilist2 ...)" :description "Equivalent to\n@lisp\n(iapply iappend (imap f ilist1 ilist2 ...))\n@end lisp\nand\n@lisp\n(iapply iappend (imap f ilist1 ilist2 ...))\n@end lisp\nMap f over the elements of the ilists, just as in the |imap|\nfunction. However, the results of the applications are appended\ntogether (using |iappend|) to make the final result.\n\nThe dynamic order in which the various applications of |f| are made is\nnot specified.\n\nExample:\n\n@lisp\n(iappend-map (lambda (x) (ilist x (- x))) (iq 1 3 8))\n    => (1 -1 3 -3 8 -8)\n@end lisp" :similar ())

(imap-in-order :type procedure :synopsis "(imap-in-order f ilist1 ilist2 ...)" :description "A variant of the |imap| procedure that guarantees to apply |f| across the\nelements of the |ilisti| arguments in a left-to-right order. This is\nuseful for mapping procedures that both have side effects and return\nuseful values." :similar ())

(ipair-for-each :type extended :synopsis "(ipair-for-each f ilist1 ilist2 ...)" :description "Like |ifor-each|, but |f| is applied to successive sub-ilists of the\nargument |ilists|. That is, |f| is applied to the cells of the ilists,\nrather than the ilists' elements. These applications occur in\nleft-to-right order.\n\n@lisp\n(ipair-for-each (lambda (ipair) (display ipair) (newline)) (iq a b c)) ==>\n    (a b c)\n    (b c)\n    (c)\n@end lisp" :similar ())

(ifilter-map :type extended :synopsis "(ifilter-map f ilist1 ilist2 ...)" :description "Like |imap|, but only true values are saved.\n\n@lisp\n(ifilter-map (lambda (x) (and (number? x) (* x x))) (iq a 1 b 3 c 7))\n    => (1 9 49)\n@end lisp\n\nThe dynamic order in which the various applications of |f| are made is\nnot specified." :similar ())

(ifilter :type extended :synopsis "(ifilter pred ilist )" :description "Return all the elements of |ilist| that satisfy predicate |pred|. The\nilist is not disordered â\x80;\x94; elements that appear in the result ilist\noccur in the same order as they occur in the argument |ilist|. The\nreturned ilist may share a common tail with the argument ilist. The\ndynamic order in which the various applications of pred are made is\nnot specified.\n\n@lisp\n(ifilter even? (iq 0 7 8 8 43 -4)) => (0 8 8 -4)\n@end lisp" :similar ())

(ipartition :type extended :synopsis "(ipartition pred ilist)" :description "Partitions the elements of |ilist| with predicate |pred|, and returns two\nvalues: the ilist of in-elements and the ilist of out-elements. The\nilist is not disordered â\x80;\x94; elements occur in the result ilists in the\nsame order as they occur in the argument ilist. The dynamic order in\nwhich the various applications of |pred| are made is not specified. One\nof the returned ilists may share a common tail with the argument\nilist.\n\n@lisp\n(ipartition symbol? (iq one 2 3 four five 6)) =>\n    (one four five)\n    (2 3 6)\n@end lisp" :similar ())

(iremove :type extended :synopsis "(iremove pred ilist)" :description "Returns ilist without the elements that satisfy predicate pred,\nsimilar to\n\n@lisp\n(lambda (pred ilist) (ifilter (lambda (x) (not (pred x))) ilist))\n@end lisp\n\nThe ilist is not disordered â\x80;\x94; elements that appear in the result\nilist occur in the same order as they occur in the argument ilist. The\nreturned ilist may share a common tail with the argument ilist. The\ndynamic order in which the various applications of |pred| are made is\nnot specified.\n\n@lisp\n(iremove even? (iq 0 7 8 8 43 -4)) => (7 43)\n@end lisp" :similar ())

(ifind :type procedure :synopsis "(ifind pred ilist)" :description "Return the first element of ilist that satisfies predicate |pred|;\nfalse if no element does.\n\n@lisp\n(ifind even? (iq 3 1 4 1 5 9)) => 4\n@end lisp\n\nNote that ifind has an ambiguity in its lookup semantics â\x80;\x94; if ifind\nreturns false, you cannot tell (in general) if it found a false element\nthat satisfied |pred|, or if it did not find any element at all. In many\nsituations, this ambiguity cannot arise â\x80;\x94; either the ilist being\nsearched is known not to contain any false elements, or the ilist is\nguaranteed to have an element satisfying pred. However, in cases where\nthis ambiguity can arise, you should use |ifind-tail| instead of |ifind|,\nsince |ifind-tail| has no such ambiguity:\n\n@lisp\n(cond ((ifind-tail pred lis) => (lambda (ipair) ...)) ; Handle (icar ipair)\n      (else ...)) ; Search failed.\n@end lisp" :similar ())

(ifind-tail :type extended :synopsis "(ifind-tail pred ilist)" :description "Return the first ipair of ilist whose icar satisfies |pred|. If no\nipair does, return false.\n\n|Ifind-tail| can be viewed as a general-predicate variant of the\n|imember| function.\n\nExamples:\n\n@lisp\n(ifind-tail even? (iq 3 1 37 -8 -5 0 0)) => (-8 -5 0 0)\n(ifind-tail even? (iq 3 1 37 -5)) => #f\n\n;; IMEMBER X LIS:\n(ifind-tail (lambda (elt) (equal? x elt)) lis)\n@end lisp\n\n|Ifind-tail| is essentially |idrop-while|, where the sense of the\npredicate is inverted: |Ifind-tail| searches until it finds an element\nsatisfying the predicate; |idrop-while| searches until it finds an\nelement that doesn't satisfy the predicate." :similar ())

(itake-while :type extended :synopsis "(itake-while  pred ilist)" :description "Returns the longest initial prefix of ilist whose elements all\nsatisfy the predicate |pred|.\n\n@lisp\n(itake-while even? (iq 2 18 3 10 22 9)) => (2 18)\n@end lisp" :similar ())

(idrop-while :type extended :synopsis "(idrop-while pred ilist)" :description "Drops the longest initial prefix of |ilist| whose elements all\nsatisfy the predicate |pred|, and returns the rest of the ilist.\n\n@lisp\n(idrop-while even? (iq 2 18 3 10 22 9)) => (3 10 22 9)\n@end lisp" :similar ())

(iany :type extended :synopsis "(iany pred ilist1 ilist2 ...)" :description "Applies the predicate across the ilists, returning true if the\npredicate returns true on any application.\n\nIf there are n ilist arguments |ilist1 ... ilistn|, then |pred| must\nbe a procedure taking n arguments and returning a boolean result.\n\n|Iany| applies |pred| to the first elements of the |ilisti|\nparameters. If this application returns a true value, iany immediately\nreturns that value. Otherwise, it iterates, applying pred to the\nsecond elements of the |ilisti| parameters, then the third, and so\nforth. The iteration stops when a true value is produced or one of the\nilists runs out of values; in the latter case, iany returns false. The\napplication of |pred| to the last element of the ilists is a tail call.\n\nNote the difference between |ifind| and |iany| â\x80;\x94; |ifind| returns the\nelement that satisfied the predicate; iany returns the true value that\nthe predicate produced.\n\nLike |ievery|, |iany|'s name does not end with a question mark â\x80;\x94; this\nis to indicate that it does not return a simple boolean (true or false),\nbut a general value.\n\n@lisp\n(iany integer? (iq a 3 b 2.7))   => #t\n(iany integer? (iq a 3.1 b 2.7)) => #f\n(iany < (iq 3 1 4 1 5)\n       (iq 2 7 1 8 2)) => #t\n@end lisp" :similar ())

(ievery :type extended :synopsis "(ievery pred ilist1 ilist2 ...)" :description "Applies the predicate across the ilists, returning true if the\npredicate returns true on every application.\n\nIf there are n ilist arguments |ilist1 ... ilistn|, then |pred| must be a\nprocedure taking n arguments and returning a boolean result.\n\n|Ievery| applies |pred| to the first elements of the |ilisti| parameters. If\nthis application returns false, ievery immediately returns\nfalse. Otherwise, it iterates, applying pred to the second elements of\nthe ilisti parameters, then the third, and so forth. The iteration\nstops when a false value is produced or one of the ilists runs out of\nvalues. In the latter case, ievery returns the true value produced by\nits final application of |pred|. The application of pred to the last\nelement of the ilists is a tail call.\n\nIf one of the |ilisti| has no elements, ievery simply returns true.\n\nLike |iany|, |ievery|'s name does not end with a question mark â\x80;\x94; this is\nto indicate that it does not return a simple boolean (true or false), but a\ngeneral value." :similar ())

(ilist-index :type procedure :synopsis "(ilist-index pred ilist1 ilist2 ...)" :description "Returns the index of the leftmost element that satisfies |pred|.\n\nIf there are n ilist arguments |ilist1 ... ilistn|, then |pred| must be a\nfunction taking n arguments and returning a boolean result.\n\n|Ilist-index| applies |pred| to the first elements of the |ilisti|\nparameters. If this application returns true, |ilist-index| immediately\nreturns zero. Otherwise, it iterates, applying |pred| to the second\nelements of the |ilisti| parameters, then the third, and so forth. When\nit finds a tuple of ilist elements that cause |pred| to return true, it\nstops and returns the zero-based index of that position in the ilists.\n\nThe iteration stops when one of the ilists runs out of values; in this\ncase, |ilist-index| returns false.\n\n@lisp\nilist-index even? (iq 3 1 4 1 5 9)) => 2\nilist-index < (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)) => 1\nilist-index = (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)) => #f\n@end lisp" :similar ())

(ibreak :type extended :synopsis "(ispan   pred ilist)\n(ibreak  pred ilist)" :description "|Ispan| splits the ilist into the longest initial prefix whose\nelements all satisfy |pred|, and the remaining tail. |Ibreak| inverts the\nsense of the predicate: the tail commences with the first element of\nthe input ilist that satisfies the predicate.\n\nIn other words: |ispan| finds the initial span of elements\nsatisfying |pred|, and |ibreak| breaks the ilist at the first element\nsatisfying |pred|.\n\n|Ispan| is equivalent to\n\n@lisp\n(values (itake-while pred ilist)\n        (idrop-while pred ilist))\n\n(ispan even? (iq 2 18 3 10 22 9)) =>\n  (2 18)\n  (3 10 22 9)\n\n(ibreak even? (iq 3 1 4 1 5 9)) =>\n  (3 1)\n  (4 1 5 9)\n@end lisp" :similar (ispan))

(ispan :see ibreak)
(imemv :type extended :synopsis "(imember x ilist [=])\n(imemq x ilist)\n(imemv x ilist)" :description "These procedures return the first sub-ilist of |ilis|t whose icar is |x|,\nwhere the sub-ilists of ilist are the non-empty ilists returned\nby |(idrop ilist i)| for |i| less than the length of ilist. If |x| does not\noccur in |ilist|, then false is returned. |Imemq| uses |eq?| to compare |x| with\nthe elements of |ilist|, while |imemv| uses |eqv?|, and |imember| uses |equal?|.\n\n@lisp\n(imemq 'a (iq a b c))           =>  (a b c)\n(imemq 'b (iq a b c))           =>  (b c)\n(imemq 'a (iq b c d))           =>  #f\n(imemq (list 'a)\n        (ilist 'b '(a) 'c))     =>  #f\n(imember (list 'a)\n        (ilist 'b '(a) 'c)))    =>  ((a) c)\n(imemq 101 (iq 100 101 102))    =>  *unspecified*\n(imemv 101 (iq 100 101 102))    =>  (101 102)\n@end lisp\n\nThe comparison procedure is used to compare the elements |ei| of |ilist|\nto the key |x| in this way:\n\n@lisp\n(= x ei) ; ilist is (E1 ... En)\n@end lisp\n\nThat is, the first argument is always |x|, and the second argument is\none of the ilist elements. Thus one can reliably find the first\nelement of ilist that is greater than five with |(imember 5 ilist <)|\n\nNote that fully general ilist searching may be performed with the\n|ifind-tail| and |ifind| procedures, e.g.\n\n@lisp\n(ifind-tail even? ilist) ; Find the first elt with an even key.\n@end lisp" :similar (imemq imember))

(imemq :see imemv)
(imember :see imemv)
(idelete :type extended :synopsis "(idelete  x ilist [=])" :description "|Idelete| uses the comparison procedure |=|, which defaults to |equal?|,\nto find all elements of ilist that are equal to |x|, and deletes them from\n|ilist|. The dynamic order in which the various applications of = are\nmade is not specified.\n\nThe ilist is not disordered â\x80;\x94; elements that appear in the result\nilist occur in the same order as they occur in the argument ilist. The\nresult may share a common tail with the argument ilist.\n\nNote that fully general element deletion can be performed with the\niremove procedures, e.g.:\n@lisp\n;; idelete all the even elements from LIS:\n(iremove even? lis)\n@end lisp\nThe comparison procedure is used in this way: |(= x ei)|. That is, |x|\nis always the first argument, and an ilist element is always the\nsecond argument. The comparison procedure will be used to compare each\nelement of ilist exactly once; the order in which it is applied to the\nvarious ei is not specified. Thus, one can reliably remove all the\nnumbers greater than five from an ilist with |(idelete 5 ilist <)|." :similar ())

(idelete-duplicates :type extended :synopsis "(idelete-duplicates  ilist [=])" :description "|Idelete-duplicates| removes duplicate elements from the |ilist|\nargument. If there are multiple equal elements in the argument |ilist|,\nthe result ilist only contains the first or leftmost of these elements\nin the result. The order of these surviving elements is the same as in\nthe original ilist â\x80;\x94; |idelete-duplicates| does not disorder the\nilist (hence it is useful for \"cleaning up\" immutable association\nlists).\n\nThe |=| parameter is used to compare the elements of the ilist; it\ndefaults to equal?. If x comes before y in ilist, then the comparison\nis performed |(= x y)|. The comparison procedure will be used to compare\neach pair of elements in ilist no more than once; the order in which\nit is applied to the various pairs is not specified.\n\nAlthough  |idelete-duplicates| can be implemented so it runs in time\nO(n2) for n-element ilists, the STklos implementation runs in linear\nexpected time.\n\n@lisp\n(idelete-duplicates (iq a b a c a b c z)) => (a b c z)\n\n;; Clean up an ialist:\n(idelete-duplicates (iq (a . 3) (b . 7) (a . 9) (c . 1))\n                   (lambda (x y) (eq? (icar x) (icar y))))\n    => ((a . 3) (b . 7) (c . 1))\n@end lisp" :similar ())

(iassv :type extended :synopsis "(iassoc key ialist [=] -> ipair or #f\n(iassq key ialist -> ipair or #f\n(iassv key ialist -> ipair or #f" :description "|Ialist| must be an immutable association list â\x80;\x94; an ilist of\nipairs. These procedures find the first ipair in ialist whose icar\nfield is key, and returns that ipair. If no ipair in ialist has key as\nits icar, then false is returned. |Iassq| uses |eq?| to compare key with the\nicar fields of the ipairs in ialist, while |iassv| uses |eqv?| and |iassoc|\nuses |equal?|.\n\n@lisp\n(define e (iq (a 1) (b 2) (c 3)))\n(iassq 'a e)                               =>  (a 1)\n(iassq 'b e)                               =>  (b 2)\n(iassq 'd e)                               =>  #f\n(iassq (ilist 'a) (iq ((a)) ((b)) ((c))))  =>  #f\n(iassoc '(a) (ilist '((a)) '((b)) '((c)))) =>  ((a))\n(iassq 5 (iq (2 3) (5 7) (11 13)))         =>  *unspecified*\n(iassv 5 (iq (2 3) (5 7) (11 13)))         =>  (5 7)\n@end lisp\n\nThe comparison procedure is used to compare the elements |ei| of ilist\nto the key parameter in this way:\n@lisp\n(= key (icar ei)) ; ilist is (E1 ... En)\n@end lisp\n\nThat is, the first argument is always key, and the second argument\nis one of the ilist elements. Thus one can reliably find the first\nentry of ialist whose key is greater than five with\n|(iassoc 5 ialist <)|.\n\nNote that fully general ialist searching may be performed with the\nifind-tail and ifind procedures, e.g.\n\n@lisp\n;; Look up the first association in ialist with an even key:\n(ifind (lambda (a) (even? (icar a))) ialist)\n@end lisp" :similar (iassq iassoc))

(iassq :see iassv)
(iassoc :see iassv)
(ialist-cons :type extended :synopsis "(ialist-cons key datum ialist)" :description "Constructs a new ialist entry mapping key -> datum onto ialist.\nThis is the same as\n@lisp\n(lambda (key datum ialist) (ipair (ipair key datum) ialist))\n@end lisp" :similar ())

(ialist-delete :type extended :synopsis "(ialist-delete  key ialist [=])" :description "|Ialist-delete| deletes all associations from ialist with the given\nkey, using key-comparison procedure |=|, which defaults to |equal?|. The\ndynamic order in which the various applications of |=| are made is not\nspecified.\n\nReturn values may share common tails with the ialist argument. The\nialist is not disordered â\x80;\x94; elements that appear in the result ialist\noccur in the same order as they occur in the argument ialist.\n\nThe comparison procedure is used to compare the element keys ki of\nialist's entries to the key parameter in this way: |(= key ki)|. Thus,\none can reliably remove all entries of ialist whose key is greater\nthan five with |(ialist-delete 5 ialist <)|" :similar ())

(gtree->tree :type extended :synopsis "(gtree->itree object)\n(gtree->tree object)" :description "These procedures walk a generalized tree consisting of pairs,\nipairs, or a combination of both, and make a deep copy of it,\nreturning an isomorphic tree containing only ipairs or pairs\nrespectively. The result may share structure with the argument.\nIf the argument is neither a pair nor an ipair, it is returned." :similar (gtree->itree))

(gtree->itree :see gtree->tree)
(iapply :type extended :synopsis "(iapply procedure object ... ilist)" :description "The |iapply| procedure is an analogue of |apply| whose last argument\nis an ilist rather than a list. It is equivalent to\n@lisp\n(apply procedure object ... (ilist->list ilist))\n@end lisp" :similar ())


;; Source file "flonum.stk"


;; Source file "sort.stk"


;; Source file "vector.stk"


;; Source file "bytevector.stk"

(endianness :type procedure :synopsis "(endianness endianness-symbol)" :description "The name of |endianness-symbol| must be a symbol describing an \nendianness.  An implementation must support at least the symbols big\nand little, but may support other endianness symbols.\n|(endianness endianness-symbol)| evaluates to the symbol named\n|endianness-symbol|. Whenever one of the procedures operating on\nbytevectors accepts an endianness as an argument, that argument must\nbe one of these symbols. It is a syntax violation for |endianness-symbol|\nto be anything other than |little| or |big|." :similar ())


;; Source file "ilist.c"

(ipair :type extended :synopsis "(ipair a d)" :description "Returns a newly allocated |ipair| whose |icar| is |a| and whose |icdr| is |d|.\nThe ipair is guaranteed to be different (in the sense of |eqv?|)\nfrom every existing object." :similar ())

(ilist :type extended :synopsis "(ilist obj ...)" :description "Returns a newly allocated ilist of its arguments.\n@lisp\n   (ilist 'a (+ 3 4) 'c)            =>  (a 7 c)\n   (ilist)                          =>  ()\n@end lisp\nBeing an ilist, its CAR, CDR and all sublists are immutable." :similar ())

(ipair* :type extended :synopsis "(ipair* obj ...)" :description "|ipair*| is like |ilist| except that the last argument to |ipair*| is\nused as the ,(emph \"cdr\") of the last pair constructed.\n@lisp\n   (ipair* 1 2 3)        => (1 2 . 3)\n   (ipair* 1 2 3 '(4 5)) => (1 2 3 4 5)\n   (ipair*)              => ()\n@end lisp" :similar ())

(ipair? :type extended :synopsis "(ipair? obj)" :description "Returns true and only if |x| is a proper ilist â\x80;\x94; that is,\na ()-terminated ilist." :similar ())

(icar+icdr :type extended :synopsis "(icar+icdr ip)" :description "The fundamental ipair deconstructor. Returns two values:\nthe icar and the icdrif |ip|." :similar ())

(iappend :type extended :synopsis "(iappend ilist1 ...)" :description "Returns an ilist consisting of the elements of ilist1 followed by the elements of the other ilist parameters.\n\n@lisp\n(iappend (iq x) (iq y))        =>  (x y)\n(iappend (iq a) (iq b c d))    =>  (a b c d)\n(iappend (iq a (b)) (iq (c)))  =>  (a (b) (c))\n@end lisp\n\nThe resulting ilist is always newly allocated, except that it\nshares structure with the final ilisti argument. This last argument\nmay be any value at all; an improper ilist results if it is not a\nproper ilist. All other arguments must be proper ilists.\n\n@lisp\n(iappend (iq a b) (ipair 'c 'd))  =>  (a b c . d)\n(iappend '() 'a)           =>  a\n(iappend (iq x y))         =>  (x y)\n(iappend)                  =>  ()\n@end lisp" :similar ())

(replace-icdr :type extended :synopsis "(replace-icar ipair object)\n(replace-icdr ipair object)" :description "|Replace-icar| returns an ipair with object in the icar field and\nthe icdr of ipair in the icdr field.\n\n|Replace-icdr| returns an ipair with object in the icdr field and\nthe icar of ipair in the icar field." :similar (replace-icar))

(replace-icar :see replace-icdr)
(ipair->pair :type extended :synopsis "(pair->ipair pair)\n(ipair->pair ipair)" :description "These procedures, which are inverses, return an ipair and\na pair respectively that have the same (i)car and (i)cdr\nfields as the argument." :similar (pair->ipair))

(pair->ipair :see ipair->pair)
(ilist->list :type extended :synopsis "(list->ilist lst)\n(ilist->list lst)" :description "These procedures return an ilist and a list respectively that have\nthe same elements as the argument. The tails of dotted (i)lists are\npreserved in the result, which makes the procedures not inverses\nwhen the tail of a dotted ilist is a list or vice versa. The empty\nlist is converted to itself.\n\nIt is an error to apply list->ilist to a circular list." :similar (list->ilist))

(list->ilist :see ilist->list)
(itree->tree :type extended :synopsis "(tree->itree object)\n(itree->tree object)" :description "These procedures walk a tree of pairs or ipairs respectively and\nmake a deep copy of it, returning an isomorphic tree containing\nipairs or pairs respectively. The result may share structure with\nthe argument. If the argument is not of the expected type, it is\nreturned.\n\nThese procedures are not inverses in the general case. For example,\na pair of ipairs would be converted by |tree->itree| to an ipair of\nipairs, which if converted by |itree->tree| would produce a pair of\npairs." :similar (tree->itree))

(tree->itree :see itree->tree)
(list-immutable! :type extended :synopsis "(list-immutable+! lst)\n(list-immutable! lst)" :description "Destructive versions of |list->ilist|: both procedures change their\nargument so it will become an immutable list.\n|List-immutable+!| returns the list, while |list-immutable!| returns |#void|." :similar (list-immutable+!))

(list-immutable+! :see list-immutable!)

;; Source file "flonum.c"


;; Source file "sort.c"


;; Source file "vector.c"


;; Source file "bytevector.c"

(native-endianness :type extended :synopsis "(native-endianness)" :description "Returns the endianness symbol of the underlying machine." :similar ())

(bytevector=? :type extended :synopsis "(bytevector=? bytevector1 bytevector2 )" :description "Returns true if |bytevector1| and |bytevector2| are equalâ\x80;\x94;that\nis, if they have the same length and equal bytes at all valid\nindices. It returns false otherwise." :similar ())

(bytevector-fill! :type extended :synopsis "(bytevector-fill! bytevector fill )" :description "The |fill| argument is as in the description of the make-bytevector\nprocedure. The |bytevector-fill!|  procedure stores |fill| in every\nelement of bytevector and returns unspecified values. Analogous to\n|vector-fill!|." :similar ())

(bytevector-s8-ref :type extended :synopsis "(bytevector-u8-ref bytevector k)\n(bytevector-s8-ref bytevector k)" :description "The |bytevector-u8-ref| procedure returns the byte at index |k| of\n|bytevector|, as an octet.\nThe |bytevector-s8-ref| procedure returns the byte at index |k| of\n|bytevector|, as a signed byte.\n\n@lisp\n(let ((b1 (make-bytevector 16 -127))\n      (b2 (make-bytevector 16 255)))\n  (list\n    (bytevector-s8-ref b1 0)\n    (bytevector-u8-ref b1 0)\n    (bytevector-s8-ref b2 0)\n    (bytevector-u8-ref b2 0)))\n=> (-127 129 -1 255)\n@end lisp" :similar (bytevector-u8-ref))

(bytevector-u8-ref :see bytevector-s8-ref)
(bytevector-s8-set! :type extended :synopsis "(bytevector-u8-set! bytevector k octet)\n(bytevector-s8-set! bytevector k byte)" :description "|K| must be a valid index of bytevector.\nThe |bytevector-u8-set!| procedure stores octet in element\n|k| of |bytevector|.\nThe |bytevector-s8-set!| procedure stores the twoâ\x80;\x99;s-complement\nrepresentation of |byte| in element |k| of |bytevector|.\nBoth procedures return unspecified values.\n\n@lisp\n(let ((b (make-bytevector 16 -127)))\n  (bytevector-s8-set! b 0 -126)\n  (bytevector-u8-set! b 1 246)\n  (list\n    (bytevector-s8-ref b 0)\n    (bytevector-u8-ref b 0)\n    (bytevector-s8-ref b 1)\n    (bytevector-u8-ref b 1)))\n  => (-126 130 -10 246)\n@end lisp" :similar (bytevector-u8-set!))

(bytevector-u8-set! :see bytevector-s8-set!)
(bytevector-sint-set! :type extended :synopsis "(bytevector-uint-ref bytevector k endianness size)\n(bytevector-sint-ref bytevector k endianness size)\n(bytevector-uint-set! bytevector k n endianness size)\n(bytevector-sint-set! bytevector k n endianness size)" :description "The |bytevector-uint-ref| procedure retrieves the exact\ninteger object corresponding to the unsigned representation\nof size |size| and specified by |endianness| at indices\n|k , ... , k + size â\x88;\x92; 1|.\n\nThe |bytevector-sint-ref| procedure retrieves the exact\ninteger object corresponding to the twoâ\x80;\x99;s-complement\nrepresentation of size |size| and specified by |endianness|\nat indices |k , ... , k + size â\x88;\x92; 1|.\n\nFor |bytevector-uint-set!|, |n| must be an exact integer\nobject in the interval |{0, ... , 256^size â\x88;\x92; 1}|.\n\nThe |bytevector-uint-set!| procedure stores the unsigned\nrepresentation of size |size| and specified by |endianness|\ninto |bytevector| at indices |k , ... , k + size â\x88;\x92; 1|.\n\nFor bytevector-sint-set!, n must be an exact integer\nobject in the interval |{â\x88;\x92;256^size /2, ... , 256^size /2 â\x88;\x92; 1}|.\n|Bytevector-sint-set!| stores the twoâ\x80;\x99;s-complement\nrepresentation of size |size| and specified by |endianness|\ninto |bytevector| at indices |k , ... , k + size â\x88;\x92; 1|.\n\nThe |...-set!| procedures return unspecified values.\n\n@lisp\n(define b (make-bytevector 16 -127))\n\n(bytevector-uint-set! b 0 (- (expt 2 128) 3)\n                      (endianness little) 16)\n(bytevector-uint-ref b 0 (endianness little) 16)\n => #xfffffffffffffffffffffffffffffffd\n\n(bytevector-sint-ref b 0 (endianness little) 16)\n => -3\n\n(bytevector->u8-list b)\n => (253 255 255 255 255 255 255 255\n     255 255 255 255 255 255 255 255)\n\n(bytevector-uint-set! b 0 (- (expt 2 128) 3)\n                      (endianness big) 16)\n(bytevector-uint-ref b 0 (endianness big) 16)\n => #xfffffffffffffffffffffffffffffffd\n\n(bytevector-sint-ref b 0 (endianness big) 16)\n =>-3\n\n(bytevector->u8-list b)\n => (255 255 255 255 255 255 255 255\n     255 255 255 255 255 255 255 253))\n@end lisp" :similar (bytevector-uint-set! bytevector-sint-ref bytevector-uint-ref))

(bytevector-uint-set! :see bytevector-sint-set!)
(bytevector-sint-ref :see bytevector-sint-set!)
(bytevector-uint-ref :see bytevector-sint-set!)
;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Sat Mar 25 05:01:48 2023


;; Source file "itrie.c"

(fxmapping-height :type extended :synopsis "(fxmapping-height trie)" :description "Returns the height of the internal trie of an fxmap. The\nexpected running time of searches and insertions is\nproportional to this value." :similar ())

(iset-height :type extended :synopsis "(iset-height trie)" :description "Returns the height of the internal trie of an iset. The\nexpected running time of searches and insertions is\nproportional to this value." :similar ())

(constant-fxmapping :type extended :synopsis "(fxmapping k1 v1 k2 v2 ... kn vn)\n(constant-fxmapping k1 v1 k2 v2 ... kn vn)" :description "Builds a fixnum map containing the integer keys |k1|, |k2|, ..., |kn|\nwith respective associated values |v1|, |v2|, ... |vn|.\n\nIt is an error if any of the keys is not an integer, or if the\nnumber of arguments is not even." :similar (fxmapping))

(fxmapping :see constant-fxmapping)
(constant-iset :type extended :synopsis "(iset n1 n2 ... nk)\n(constant-iset n1 n2 ... nk)" :description "Builds a fixnum set containing the fixnums  |n1|, |n2|, ..., |nk|.\n\nIt is an error if any of the keys is not an integer." :similar (iset))

(iset :see constant-iset)
(alist->fxmapping :type extended :synopsis "(alist->fxmapping alist) â\x86;\x92; fxmapping" :description "Returns a newly allocated fxmapping containing the associations of\nalist. It is an error if the car of any pair in alist is not a\nfixnum. If an integer k appears as the key of multiple associations in\nalist (i.e. as the car of multiple pairs), then the first association\nfor k is preferred.\n\n@lisp\n(fxmapping->alist\n  (alist->fxmapping '((1 . b) (0 . a) (2 . c))))\n => ((0 . a) (1 . b) (2 . c))\n\n(fxmapping->alist\n  (alist->fxmapping '((-10 . \"yar\") (-10 . \"worf\"))))\n => ((-10 . \"yar\"))\n@end lisp" :similar ())

(iset-unfold :type extended :synopsis "(iset-unfold stop? mapper successor seed)" :description "Create a newly allocated iset as if by iset. If the result of\napplying the predicate |stop?| to |seed| is true, return the\niset. Otherwise, apply the procedure |mapper| to |seed|. The\nvalue that |mapper| returns is added to the iset. Then get a\nnew seed by applying the procedure |successor| to |seed|, and\nrepeat this algorithm.\n\n@lisp\n(iset->list (iset-unfold (lambda (n) (> n 64))\n                         values\n                         (lambda (n) (* n 2))\n                         2))\n=> (2 4 8 16 32 64)\n@end lisp" :similar ())

(make-range-iset :type extended :synopsis "(make-range-iset start end [step])" :description "Returns a newly allocated iset specified by an inclusive lower bound\n|start|, an exclusive upper bound |e|nd, and a step value (default 1), all\nof which are exact integers. This constructor produces an iset\ncontaining the sequence\n\n|start, (+ start step), (+ start (* 2 step)), ..., (+ start (* n step))|,\n\nwhere |n| is the greatest integer such that |(+ start (* n step)) < end|\nif |step| is positive, or such that |(+ start (* n step)) > end| if |step|\nis negative. It is an error if |step| is zero.\n\n@lisp\n(iset->list (make-range-iset 25 30))    => (25 26 27 28 29)\n(iset->list (make-range-iset -10 10 6)) => (-10 -4 2 8)\n@end lisp" :similar ())

(fxmapping? :type extended :synopsis "(fxmapping? obj)" :description "Returns |#t| is |obj| is an fxmapping object and |#f| otherwise." :similar (SRFI-224))

(SRFI-224 :see fxmapping?)
(iset? :type extended :synopsis "(iset? obj)" :description "Returns |#t| is |obj| is an iset and |#f| otherwise." :similar (SRFI-217))

(SRFI-217 :see iset?)
(fxmapping-empty? :type extended :synopsis "(fxmapping-empty? obj)" :description "Returns |#t| is |obj| is an empty fxmapping and |#f| if it\nis an fxmapping containing at least one key.\nIf |obj| is not an fxmapping object, an error is sginaled." :similar (SRFI-224))

(SRFI-224 :see fxmapping-empty?)
(iset-empty? :type extended :synopsis "(iset-empty? obj)" :description "Returns |#t| is |obj| is an empty iset and |#f| if it\nis an iset containing at least one key.\nIf |obj| is not an iset object, an error is sginaled." :similar (SRFI-217))

(SRFI-217 :see iset-empty?)
(fxmapping-mutable? :type extended :synopsis "(fxmapping-mutable? obj)" :description "Returns |#t| is |obj| is a mutable fxmapping and |#f| otherwise." :similar ())

(iset-mutable? :type extended :synopsis "(iset-mutable? obj)" :description "Returns |#t| is |obj| is a mutable iset and |#f| otherwise." :similar ())

(fxmapping-contains? :type extended :synopsis "(fxmapping-contains? map element)" :description "Returns true if |map| contains an association for |element|, and false otherwise." :similar ())

(iset-contains? :type extended :synopsis "(iset-contains? set element)" :description "Returns true if |set| contains |element|, and false otherwise." :similar ())

(iset-disjoint? :type extended :synopsis "(iset-disjoint? iset1 iset2)" :description "Returns |#t| if |iset1| and |iset2| have no elements in common and |#f| otherwise.\n\n@lisp\n(iset-disjoint? (iset 1 3 5) (iset 0 2 4)) => #t\n(iset-disjoint? (iset 1 3 5) (iset 2 3 4)) => #f\n@end lisp" :similar ())

(fxmapping-ref/default :type extended :synopsis "(fxmapping-ref/default map k obj)" :description "If an association |(k, v)| occurs in |map|, returns |v|. Otherwise, returns |obj|.\n\n@lisp\n(fxmapping-ref/default (fxmapping 36864 'zap) 36864 #f) => zap\n(fxmapping-ref/default (fxmapping 0 'a) 36864 #f) => #f\n@end lisp" :similar ())

(iset-member :type extended :synopsis "(iset-member element set default)" :description "Returns the element of |set| that is equal to |element|. If |element| is not a member\nof |set|, then |default| is returned." :similar ())

(iset-max :type extended :synopsis "(iset-min set)\n(iset-max set)" :description "Returns the smallest or largest integer in |set|, or |#f| if there is none.\n\n@lisp\n(iset-min (iset 2 3 5 7 11)) => 2\n(iset-max (iset 2 3 5 7 11)) => 11\n(iset-max (iset))            => #f\n@end lisp" :similar (iset-min))

(iset-min :see iset-max)
(iset-adjoin! :type extended :synopsis "(iset-adjoin set element1 element2 ...)\n(iset-adjoin! set element1 element2 ...)" :description "The |iset-adjoin| procedure returns a newly allocated iset that contains\nall the values of |set|, and in addition each element unless it is\nalready equal to one of the existing or newly added members.\n\n@lisp\n(iset->list (iset-adjoin (iset 1 3 5) 0)) => (0 1 3 5)\n@end lisp\n\nThe |iset-adjoin!| procedure is the linear update version of\n|iset-adjoin|. In STklos, it is an alias to |iset-adjoin|." :similar (iset-adjoin))

(iset-adjoin :see iset-adjoin!)
(fxmapping-adjoin :type extended :synopsis "(fxmapping-adjoin fxmap k1 obj1 k2 ...)" :description "Returns a fxmapping containing all of the associations of |fxmap| as\nwell as the associations |(k1, obj1)|, |(k2, obj2)|, ... The number of\nkey/value arguments must be even.\n\nIf any of the keys already have associations in |fxmap|, the old\nassociations are preserved.\n\n@lisp\n(fxmapping->alist (fxmapping-adjoin (fxmapping 1 'b) 0 'a))\n => ((0 . a) (1 . b))\n@end lisp" :similar ())

(iset-delete-all! :type extended :synopsis "(iset-delete set element1 element2 ...)\n(iset-delete! set element1 element2 ...)\n(iset-delete-all set element-list)\n(iset-delete-all! set element-list)" :description "The |iset-delete| procedure returns a newly allocated iset containing\nall the values of |set| except for any that are equal to one or more of\nthe elements. Any element that is not equal to some member of the |set|\nis ignored.\n\nThe |iset-delete!| procedure is the same as |iset-delete|.\nis permitted to mutate and return the iset argument rather than\nallocating a new iset -- but in STklos, it doesn't.\n\nThe |iset-delete-all| and |iset-delete-all!| procedures are the same as\n|iset-delete| and |iset-delete!|, except that they accept a single\nargument which is a list of elements to be deleted.\n\n@lisp\n(iset->list (iset-delete (iset 1 3 5) 3)) => (1 5)\n(iset->list (iset-delete-all (iset 2 3 5 7 11)\n                             '(3 4 5)))   => (2 7 11)\n@end lisp" :similar (iset-delete-all iset-delete! iset-delete))

(iset-delete-all :see iset-delete-all!)
(iset-delete! :see iset-delete-all!)
(iset-delete :see iset-delete-all!)
(iset-delete-max! :type extended :synopsis "(iset-delete-min set)\n(iset-delete-min! set)\n(iset-delete-max set)\n(iset-delete-max! set)" :description "Returns two values: the smallest/largest integer n in |set| and a\nnewly-allocated iset that contains all elements of |set| except for\nn. It is an error if iset is empty.\n\nThe |iset-delete-min!| and |iset-delete-max!| procedures are the same as\n|iset-delete-min| and |iset-delete-max|, respectively, except that they\nare permitted to mutate and return the |set| argument instead of\nallocating a new iset. In STklos, they do not.\n\n@lisp\n(let-values (((n set) (iset-delete-min (iset 2 3 5 7 11))))\n  (list n (iset->list set)))\n  => (2 (3 5 7 11))\n(let-values (((n set) (iset-delete-max (iset 2 3 5 7 11))))\n  (list n (iset->list set)))\n  => (11 (2 3 5 7))\n@end lisp" :similar (iset-delete-max iset-delete-min! iset-delete-min))

(iset-delete-max :see iset-delete-max!)
(iset-delete-min! :see iset-delete-max!)
(iset-delete-min :see iset-delete-max!)
(iset-search! :type extended :synopsis "(iset-search set element failure success)\n(iset-search! iset element failure success)" :description "|Set| is searched from lowest to highest value for |element|. If it\nis not found, then the |failure| procedure is tail-called with two\ncontinuation arguments, |insert| and |ignore|, and is expected to\ntail-call one of them. If |element| is found, then the |success| procedure\nis tail-called with the matching element of |set| and two\ncontinuations, |update| and |remove|, and is expected to tail-call one of\nthem.\n\nThe effects of the continuations are as follows (where |obj| is any\nScheme object):\n\nInvoking |(insert obj)| causes |element| to be inserted into iset.\n\nInvoking |(ignore obj)| causes |set| to remain unchanged.\n\nInvoking |(update new-element obj)| causes |new-element| to be\ninserted into |set| in place of |element|.\n\nInvoking |(remove obj)| causes the matching element of |set| to\nbe removed from it.\n\nIn all cases, two values are returned: an iset and |obj|.\n\nThe |iset-search!| procedure is the same as |iset-search|, except that it\nis permitted to mutate and return the iset argument rather than\nallocating a new iset. In STklos, it does not." :similar (iset-search))

(iset-search :see iset-search!)
(fxmapping-size :type extended :synopsis "(fxmapping-size trie)" :description "Returns the number of key/value pairs in an fxmap." :similar ())

(iset-size :type extended :synopsis "(iset-size set)" :description "Returns the number of fixnums in |set|." :similar ())

(iset-find :type extended :synopsis "(iset-find predicate set failure)" :description "Returns the smallest element of |set| that satisfies predicate, or\nthe result of invoking |failure| with no arguments if there is none.\n\n@lisp\n(iset-find positive? (iset -1 1) (lambda () #f))  => 1\n(iset-find zero?     (iset -1 1) (lambda () #f))  => #f\n@end lisp" :similar ())

(iset-count :type extended :synopsis "(iset-count pred? set)" :description "Returns the number of elements of |set| that satisfy\n|pred?| as an exact integer.\n\n@lisp\n(iset-count odd? (iset 10 2 1 -3 9 4 3))  => 4\n@end lisp" :similar ())

(iset-any? :type extended :synopsis "(iset-any? pred? set)" :description "Returns true if at least one of the elements of |set| satisfies\n|pred?|. Note that this differs from the SRFI 1 analogue because\nit does not return an element of the iset.\n\n@lisp\n(iset-any odd? (iset 10 2 -3 4))    => #t\n(iset-any odd? (iset 10 2 -8 4 0))  => #f\n@end lisp" :similar ())

(iset-every? :type extended :synopsis "(iset-every? predicate iset)" :description "Returns |#t| if every element of |set| satisfies |predicate|, or |#f|\notherwise. Note that this differs from the SRFI 1 analogue because it\ndoes not return an element of the iset.\n\n@lisp\n(iset-every? (lambda (x) (< x 5)) (iset -2 -1 1 2)) => #t\n(iset-every? positive? (iset -2 -1 1 2))            => #f\n@end lisp" :similar ())

(iset-map :type extended :synopsis "(iset-map proc set)" :description "Applies |proc| to each element of |set| in arbitrary order and returns a\nnewly allocated iset, created as if by iset, which contains the\nresults of the applications. It is an error if |proc| returns a value\nthat is not an exact integer.\n\n@lisp\n(iset-map (lambda (x) (* 10 x)) (iset 1 11 21))\n     => (iset 10 110 210)\n(iset-map (lambda (x) (quotient x 2))\n         (iset 1 2 3 4 5))\n => (iset 0 1 2)\n@end lisp" :similar ())

(iset-for-each :type extended :synopsis "(iset-for-each proc set)" :description "Applies |proc| to |set| in increasing numerical order, discarding the\nreturned values. Returns an unspecified result.\n\n@lisp\n(let ((sum 0))\n  (iset-for-each (lambda (x) (set! sum (+ sum x)))\n                 (iset 2 3 5 7 11))\n  sum)\n=> 28\n@end lisp" :similar ())

(iset-fold-right :type extended :synopsis "(iset-fold proc nil set)\n(iset-fold-right proc nil set)" :description "Invokes |proc| on each member of |set| in increasing/decreasing numerical\norder, passing the result of the previous invocation as a second\nargument. For the first invocation, |nil| is used as the second\nargument. Returns the result of the last invocation, or |nil| if there\nwas no invocation.\n\n@lisp\n(iset-fold + 0 (iset 2 3 5 7 11))            => 28\n(iset-fold cons '() (iset 2 3 5 7 11))       => (11 7 5 3 2)\n(iset-fold-right cons '() (iset 2 3 5 7 11)) => (2 3 5 7 11)\n@end lisp" :similar (iset-fold))

(iset-fold :see iset-fold-right)
(iset-filter! :type extended :synopsis "(iset-filter predicate set)\n(iset-filter! predicate set)" :description "Returns a newly allocated iset containing just the elements\nof |set| that satisfy |predicate|.\n\n@lisp\n(iset->list (iset-filter (lambda (x) (< x 6)) (iset 2 3 5 7 11)))\n => (2 3 5)\n@end lisp\n\n|iset-filter!| is allowed to modify |set|, but in STklos it does not." :similar (iset-filter))

(iset-filter :see iset-filter!)
(iset-remove! :type extended :synopsis "(iset-remove predicate set)\n(iset-remove! predicate set)" :description "Returns a newly allocated |set| containing just the elements of |set|\nthat do not satisfy |predicate|.\n\n@lisp\n(iset->list (iset-remove (lambda (x) (< x 6)) (iset 2 3 5 7 11)))\n => (7 11)\n@end lisp\n\n|Iset-remove!| is allowed to modify |set|, but in STklos it does not." :similar (iset-remove))

(iset-remove :see iset-remove!)
(iset-partition! :type extended :synopsis "(iset-partition predicate set)\n(iset-partition! predicate set)" :description "Returns two values: a newly allocated iset that contains just the\nelements of |set| that satisfy |predicate| and another newly allocated\niset that contains just the elements of |set| that do not satisfy\n|predicate|.\n\n@lisp\n(let-values (((low high) (iset-partition (lambda (x) (< x 6))\n                                         (iset 2 3 5 7 11))))\n  (list (iset->list low) (iset->list high)))\n => ((2 3 5) (7 11))\n@end lisp" :similar (iset-partition))

(iset-partition :see iset-partition!)
(iset-copy :type extended :synopsis "(iset-copy set)" :description "Returns a newly allocated iset containing the elements of |set|." :similar ())

(iset->list :type extended :synopsis "(iset->list set)" :description "Returns a newly allocated list containing the members of\n|set| in increasing numerical order.\n\n@lisp\n(iset->list (iset 2 3 5 7 11)) => (2 3 5 7 11)\n@end lisp" :similar ())

(list->iset :type extended :synopsis "(list->iset list)\n(list->iset! set list)" :description "Returns a newly allocated iset, created as if by iset, that contains\nthe elements of |list|. Duplicate elements are omitted.\n\n@lisp\n(list->iset '(-3 -1 0 2)) = (iset -3 -1 0 2)\n@end lisp\n\n|list->iset!| may mutate |set| rather than allocating a new iset,\nbut in STklos it does not.\n\n@lisp\n(iset->list (list->iset! (iset 2 3 5) '(-3 -1 0))) â\x87;\x92; (-3 -1 0 2 3 5)\n@end lisp" :similar ())

(fxmapping-keys :type extended :synopsis "(fxmapping-keys fxmap)" :description "Returns the keys of |fxmap| as a list in ascending numerical order.\n\n@lisp\n(fxmapping-keys (fxmapping 137 'a -24 'b -5072 'c))\n => (-5072 -24 137)\n@end lisp" :similar ())

(fxmapping-values :type extended :synopsis "(fxmapping-values fxmap)" :description "Returns the values of |fxmap| as a list in ascending numerical order of\nkey. That is, if |(k1, v1), ..., (kn, vn)| are the associations of |fxmap|\nordered so that |k1 <= â\x80;¦ <= kn|, then |(fxmapping-values fxmap)| produces\nthe list |(v1 ... vn)|.\n\n@lisp\n(fxmapping-values (fxmapping 0 \"picard\" 1 \"riker\" 2 \"troi\"))\n => (\"picard\" \"riker\" \"troi\")\n@end lisp" :similar ())

(iet>=? :type extended :synopsis "(iset=? iset1 iset2 iset3 ...)\n(iset<? iset1 iset2 iset3 ...)\n(iset>? iset1 iset2 iset3 ...)\n(iset<=? iset1 iset2 iset3 ...)\n(iset>=? iset1 iset2 iset3 ...)" :description "These procedures return true when each set is\nequal (|iset=?|) or a proper subset (|iset<?|), a proper\nsuperset (|iset>?|), a subset (|iset<=?|) or a superset\n(|iset>=?|) of the next one.\n\n@lisp\n(iset=? (iset 1 2 3) (iset 3 1 2))           => #t\n(iset<? (iset 3 1 2) (iset 4 2 1 3))         => #t\n(iset>=? (iset 3 0 1) (iset 0 1) (iset 0 1)) => #t\n@end lisp" :similar (iset<=? iset>? iset<? iset=?))

(iset<=? :see iet>=?)
(iset>? :see iet>=?)
(iset<? :see iet>=?)
(iset=? :see iet>=?)
(iset-xor! :type extended :synopsis "(iset-union iset1 iset2 iset3 ...)\n(iset-intersection iset1 iset2 iset3 ...)\n(iset-difference iset1 iset2 iset3 ...)\n(iset-xor iset1 iset2)\n(iset-union! iset1 iset2 iset3 ...)\n(iset-intersection! iset1 iset2 iset3 ...)\n(iset-difference! iset1 iset2 iset3 ...)\n(iset-xor! iset1 iset2)" :description "Return a newly allocated iset that is the union, intersection,\nasymmetric difference, or symmetric difference of the\nisets. Asymmetric difference is extended to more than two isets by\ntaking the difference between the first iset and the union of the\nothers. Symmetric difference is not extended beyond two\nisets. Elements in the result iset are drawn from the first iset in\nwhich they appear.\n\n@lisp\n(iset->list (iset-union (iset 0 1 3) (iset 0 2 4))) => (0 1 2 3 4)\n(iset->list (iset-intersection (iset 0 1 3 4) (iset 0 2 4))) => (0 4)\n(iset->list (iset-difference (iset 0 1 3 4) (iset 0 2) (iset 0 4))) => (1 3)\n(iset->list (iset-xor (iset 0 1 3) (iset 0 2 4))) => (1 2 3 4)\n@end lisp\n\nThe procedures whose name end in |!| are linear update procedures.\nThe specification says they may or may not alter their argument. In\nSTklos they do not: in fact, they are aliases to the pure functional\nversions." :similar (iset-difference! iset-intersection! iset-union! iset-xor iset-difference iset-intersection iset-union))

(iset-difference! :see iset-xor!)
(iset-intersection! :see iset-xor!)
(iset-union! :see iset-xor!)
(iset-xor :see iset-xor!)
(iset-difference :see iset-xor!)
(iset-intersection :see iset-xor!)
(iset-union :see iset-xor!)
(fxmapping-xor :type extended :synopsis "(fxmapping-union fxmap1 fxmap2 fxmap3 ...)\n(fxmapping-intersection fxmap1 fxmap2 fxmap3 ...)\n(fxmapping-difference fxmap1 fxmap2 fxmap3 ...)\n(fxmapping-xor fxmap1 fxmap2)" :description "Return a fxmapping whose set of associations is the union,\nintersection, asymmetric difference, or symmetric difference of the\nsets of associations of the fxmaps. Asymmetric difference is extended\nto more than two fxmappings by taking the difference between the first\nfxmapping and the union of the others. Symmetric difference is not\nextended beyond two fxmappings. When comparing associations, only the\nkeys are compared. In case of duplicate keys, associations in the\nresult fxmapping are drawn from the first fxmapping in which they\nappear.\n\n@lisp\n(fxmapping->alist (fxmapping-union (fxmapping 0 'a 2 'c)\n                                  (fxmapping 1 'b 3 'd)))\n   => ((0 . a) (1 . b) (2 . c) (3 . d))\n\n (fxmapping->alist\n  (fxmapping-intersection (fxmapping 0 'a 2 'c)\n                          (fxmapping 1 'b 2 'c 3 'd)\n                          (fxmapping 2 'c 4 'e)))\n    => ((2 . c))\n\n(fxmapping->alist\n (fxmapping-difference (fxmapping 0 'a 1 'b 2 'c)\n                       (fxmapping 2 \"worf\")\n                       (fxmapping 1 \"data\")))\n    => ((0 . a))\n@end lisp" :similar (fxmapping-difference fxmapping-intersection fxmapping-union))

(fxmapping-difference :see fxmapping-xor)
(fxmapping-intersection :see fxmapping-xor)
(fxmapping-union :see fxmapping-xor)
(iset-closed-open-interval :type extended :synopsis "(iset-open-interval set low high)\n(iset-closed-interval set low high)\n(iset-open-closed-interval set low high)\n(iset-closed-open-interval set low high)" :description "Procedures that return a subset of |set| contained in the interval from\n|low| to |high|. The interval may be open, closed, open below and closed\nabove, or open above and closed below.\n\n@lisp\n(iset->list (iset-open-interval (iset 2 3 5 7 11) 2 7))        => (3 5)\n(iset->list (iset-closed-interval (iset 2 3 5 7 11) 2 7))      => (2 3 5 7)\n(iset->list (iset-open-closed-interval (iset 2 3 5 7 11) 2 7)) => (3 5 7)\n(iset->list (iset-closed-open-interval (iset 2 3 5 7 11) 2 7)) => (2 3 5)\n@end lisp" :similar (iset-open-closed-interval iset-closed-interval iset-open-interval))

(iset-open-closed-interval :see iset-closed-open-interval)
(iset-closed-interval :see iset-closed-open-interval)
(iset-open-interval :see iset-closed-open-interval)
(isubset>= :type extended :synopsis "(isubset= set k)\n(isubset< set k)\n(isubset<= set k)\n(isubset> set k)\n(isubset>= set k)" :description "Procedures that return an integer set containing the elements of |set|\nthat are equal to, less than, less than or equal to, greater than, or\ngreater than or equal to |k|. Note that the result of |isubset=| contains\nat most one element.\n\n@lisp\n(iset->list (isubset= (iset 2 3 5 7 11) 7))  => (7)\n(iset->list (isubset< (iset 2 3 5 7 11) 7))  => (2 3 5)\n(iset->list (isubset>= (iset 2 3 5 7 11) 7)) => (7 11)\n@end lisp" :similar (isubset> isubset<= isubset< isubset=))

(isubset> :see isubset>=)
(isubset<= :see isubset>=)
(isubset< :see isubset>=)
(isubset= :see isubset>=)

;; Source file "preproc.stk"


;; Source file "itrie.stk"

;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Sat Mar 25 05:01:48 2023


;; Source file "primitive.stk"


;; Source file "derived.stk"

;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Sat Mar 25 05:01:48 2023


;; Source file "25.c"

(shape? :type extended :synopsis "(shape? obj)" :description "Checks if |obj| is an array shape. SRFI-25 dictates that a\nshape is an ordinary array, with rank two and shape |(0 r 0 2)|,\nwhere |r| is the rank of the array that the shape describes.\nSo, any array of shape |(0 r 0 2| is a shape, for any non-negative\ninteger |r|." :similar ())

(shared-array? :type extended :synopsis "(shared-array? array)" :description "Will return `#t` when the array has its data shared with other\narrays, and `#f` otherwise." :similar ())

(array-share-count :type extended :synopsis "(array-share-count array)" :description "Returns the number of arrays that were built sharing `|array|`'s\nelements through |(share-array array shape proc)|, and that were not\nyet garbage collected.\nNote that it may take a long time for an object to be garbage\ncollected automatically. It is possible to force a garbage\ncollection pass by calling |(gc)|, but even that does not guarantee that\na specific object will be collected." :similar ())

(array-shape :type extended :synopsis "(array-shape array)" :description "Returns the shape of |array|." :similar ())

(array-size :type extended :synopsis "(array-size array)" :description "Returns the number of elements in |array|." :similar ())

(array-copy+share :type extended :synopsis "(array-copy+share array)" :description "Returns a copy of |array|.\nIf array does not have its own internal data, but was built using\nshare-array, then the new array will be similar -- it will be a copy of\narray, sharing the elements in the same way." :similar ())

(shape-for-each :type extended :synopsis "(shape-for-each shape proc [index-object])" :description "This procedure will apply proc to all valid sequences of\nindices in |shape|, in row-major order.\n\nIf |index-object| is not provided, then |proc| must accept\nas many arguments as the number of dimensions that the shape\ndescribes.\n@lisp\n(shape-for-each (shape 1 3 10 12)\n                (lambda (x y)\n                  (format #t \"[~a ~a]~%\" x y)))\n        @print [1 10]\n           [1 11]\n           [2 10]\n           [2 11]\n@end lisp\nIf |index-object| is provided, it is used as a place to store the\nindices, so proc must accept either a vector or an array (this is to\navoid pushing and popping too many values when calling |proc|).\n|index-object|, when present, must be aither a vector or array.\n@lisp\n(let ((vec (make-vector 2 #f)))\n  (shape-for-each (shape 1 3 10 12)\n                  (lambda (o)\n                    (format #t \"[~a ~a]~%\"\n                    (vector-ref o 0)\n                    (vector-ref o 1)))\n                  vec))\n        @print [1 10]\n           [1 11]\n           [2 10]\n           [2 11]\n\n(let ((arr (make-array (shape 0 2))))\n  (shape-for-each (shape 1 3 10 12)\n                  (lambda (o)\n                    (format #t \"[~a ~a]~%\"\n                    (array-ref o 0)\n                    (array-ref o 1)))\n                  arr))\n         @print [1 10]\n            [1 11]\n            [2 10]\n            [2 11]\n@end lisp" :similar ())


;; Source file "27.c"


;; Source file "170.c"


;; Source file "175.c"


;; Source file "238.c"

(codeset-list :type extended :synopsis "(codeset-list)" :description "Retuns a list of known codeset names.\n\n@lisp\n(codeset-list) => (errno signal)\n@end lisp" :similar ())


;; Source file "1.stk"


;; Source file "2.stk"


;; Source file "4.stk"

(uvector-tag :type extended :synopsis "(uvector? uv)\n(uvector-length uv)\n(uvector-ref uv k)\n(uvector-set! uv k val)\n(uvector->list uv)\n(uvector-tag uv)" :description "These primitives extend {{quick-link-srfi 4}}. They can be called with any type\nof uniform (homogeneous) vector.  The primitive |uvector-tag| returns the tag\nof the uniform vector, as a symbol\n@lisp\n(uvector? #s16(-1 2 3))    => #t\n(uvector-length #u32(1 2)) => 2\n(uvector-length #s64(1 2)) => 2\n(uvector-tag #u8(1 2 3))   => u8\n(uvector-tag #c32())       => c32\n@end lisp" :similar (uvector->list uvector-set! uvector-ref uvector-length uvector?))

(uvector->list :see uvector-tag)
(uvector-set! :see uvector-tag)
(uvector-ref :see uvector-tag)
(uvector-length :see uvector-tag)
(uvector? :see uvector-tag)

;; Source file "5.stk"


;; Source file "6.stk"


;; Source file "7.stk"


;; Source file "8.stk"


;; Source file "9.stk"


;; Source file "10.stk"


;; Source file "11.stk"


;; Source file "13.stk"


;; Source file "14.stk"


;; Source file "15.stk"


;; Source file "16.stk"


;; Source file "17.stk"


;; Source file "18.stk"


;; Source file "19.stk"

(time-resolution :type extended :synopsis "(time-resolution [time-type])" :description "Clock resolution, in nanoseconds, of the system clock of type type\n|time-type|, which defaults to |TIME-UTC|.\n\n@lisp\n(time-resolution)              => 1000000\n(time-resolution time-process) => 1000000\n(time-resolution time-tai)     => 1000000\n@end lisp" :similar ())

(time>? :type procedure :synopsis "(time<=? time1 time2)\n(time<? time1 time2)\n(time=? time1 time2)\n(time>=? time1 time2)\n(time>? time1 time2)" :description "These are SRFI-19 predicates used to compare times. They return:\n\ntime<=? : `#t` if |time1| is before or at (less than or equal to) |time2|, `#f` otherwise.\ntime<? :  `#t` if |time1| is before (less than) |time2|, `#f` otherwise.\ntime=? :  `#t` if |time1| at (equal) |time2|, `#f` otherwise.\ntime>=? : `#t` if |time1| is at or after (greater than or equal to) |time2|, `#f` otherwise.\ntime>? :  `#t` if |time1| is after (greater than) |time2|, `#f` otherwise.\n\nAn attempt to compare times of different will raise an error." :similar (time>=? time=? time<? time<=?))

(time>=? :see time>?)
(time=? :see time>?)
(time<? :see time>?)
(time<=? :see time>?)
(time-difference :type extended :synopsis "(time-difference time1 time2)\n(time-difference! time1 time2)" :description "These are SRFI-19 procdures return the time duration (as an object of type |time-duration|)\nbetween |time1| and |time2|. It is an error if |time1| and |time2| are of different time types.\n\n|Time-Difference| creats a new time object, while |Time-Difference!| may use |time1| to\ncreate the resulting object." :similar ())


;; Source file "22.stk"


;; Source file "23.stk"


;; Source file "26.stk"


;; Source file "28.stk"


;; Source file "29.stk"


;; Source file "31.stk"


;; Source file "34.stk"


;; Source file "35.stk"


;; Source file "36.stk"


;; Source file "37.stk"


;; Source file "38.stk"


;; Source file "39.stk"


;; Source file "41.stk"


;; Source file "43.stk"


;; Source file "45.stk"


;; Source file "48.stk"


;; Source file "51.stk"


;; Source file "54.stk"


;; Source file "55.stk"


;; Source file "59.stk"


;; Source file "60.stk"


;; Source file "61.stk"


;; Source file "62.stk"


;; Source file "64.stk"


;; Source file "66.stk"


;; Source file "69.stk"


;; Source file "70.stk"


;; Source file "74.stk"


;; Source file "87.stk"


;; Source file "88.stk"


;; Source file "89.stk"


;; Source file "94.stk"


;; Source file "95.stk"


;; Source file "96.stk"


;; Source file "100.stk"


;; Source file "111.stk"


;; Source file "113.stk"


;; Source file "116.stk"


;; Source file "117.stk"


;; Source file "118.stk"


;; Source file "125.stk"


;; Source file "127.stk"


;; Source file "128.stk"


;; Source file "129.stk"


;; Source file "130.stk"


;; Source file "132.stk"


;; Source file "133.stk"


;; Source file "134.stk"


;; Source file "135.stk"


;; Source file "137.stk"


;; Source file "141.stk"


;; Source file "143.stk"


;; Source file "144.stk"


;; Source file "151.stk"


;; Source file "152.stk"


;; Source file "154.stk"


;; Source file "156.stk"


;; Source file "158.stk"


;; Source file "160.stk"


;; Source file "161.stk"


;; Source file "162.stk"


;; Source file "169.stk"


;; Source file "171.stk"


;; Source file "173.stk"


;; Source file "174.stk"


;; Source file "176.stk"


;; Source file "180.stk"


;; Source file "185.stk"


;; Source file "189.stk"


;; Source file "190.stk"


;; Source file "193.stk"


;; Source file "195.stk"


;; Source file "196.stk"


;; Source file "207.stk"


;; Source file "208.stk"


;; Source file "214.stk"


;; Source file "215.stk"


;; Source file "216.stk"


;; Source file "217.stk"


;; Source file "219.stk"


;; Source file "221.stk"


;; Source file "223.stk"


;; Source file "224.stk"


;; Source file "228.stk"


;; Source file "229.stk"


;; Source file "230.stk"


;; Source file "233.stk"


;; Source file "235.stk"


;; Source file "236.stk"


;; Source file "244.stk"


;; Source file "25.stk"

(array-length :type extended :synopsis "(array-length array dim)" :description "Returns the length of dimension |dim| in array |array|." :similar ())

(array-for-each-index :type extended :synopsis "(array-for-each-index arr proc [index-object])" :description "Will loop through all valid indices of |array|, applying |proc|\nto those indices.\n\nIf |index-object| is not provided, then |proc| must accept\nas many arguments as the number of dimensions that the shape\ndescribes.\n\nIf |index-object| is provided, it is used as a place to store the\nindices, so |proc| must accept a vector or an array (this is to avoid\npushing and popping too many values when calling proc).\n|index-object|, when present, must be aither a vector or array.\n\nSee the documentation of |shape-for-each| for more information\non |index-object|." :similar ())

(array->vector :type extended :synopsis "(array->vector array)" :description "Returns a vector that contains a copy of the elements of |array|,\nin row-major order. The new vector does not share elements with\nthe original array (it is a fresh copy).\nThis is not recursive, and will not flatten the array." :similar ())

(array->list :type extended :synopsis "(array->list array)" :description "Returns a list that contains a copy of the elements of |array|,\nin row-major order.\nThis is not recursive, and will not flatten the array." :similar ())

(array-map! :type extended :synopsis "(array-map! array [shape] proc arr~0~ arr~1~ ...)" :description "For each valid index |idx|, applies proc to the corresponding\nposition in |arr~0~|, |arr~1~|, ...  and then sets the same\nplace in |array| to the result.\n\nIf |shape| is specified, it should specify a subarray of\n|array|, and only that section will be mapped." :similar ())

(array-map :type extended :synopsis "(array-map [shape] proc arr~0~ arr~1~ ...)" :description "This procedure is similar to |map| for lists:\nit will run |proc| on an element of each of the\n|arr~0~|, |arr~1~|, ... arguments, storing the result in\nthe equivalent position of a newly created array.\n\nThe shapes of the arrays must be the same.\n\nThe procedure will create a new array with shape |shape|\n(or `|arr~0~|`'s shape, if |shape| was not specified)." :similar ())

(array-copy :type extended :synopsis "(array-copy array)" :description "Returns a copy of |array|.\nThe new copy will have no data shared with any other array, even if the\nargument |array| did." :similar ())

(tabulate-array :type extended :synopsis "(tabulate-array shape proc)\n(tabulate-array shape proc idx)" :description "Returns a new array of shape |shape|, populated according\nto |proc|. Each valid index in |shape| is passed to |proc|,\nand the result is place in the according array position.\n\n|idx| is an object that may be used to store the indices, and\nit may be either a vector or an array. If it is not present, or\nif it is `#f`, then an index vector will be created internally.\n" :similar ())

(array-retabulate! :type extended :synopsis "(array-retabulate! arr shp proc [index-object])" :description "Sets the elements of |arr| in |shape| to the value of |proc| at that\nindex, using |index-object| if provided. This is similar to\n|tabulate-array!|, except that the array is given by the user.\n\n@lisp\n(define arr (array (shape 0 2 0 2) 'a 'b 'c 'd))\n(array-retabulate! arr (shape 0 2 0 2) (lambda (x y) (+ 1 x y)))\narr => #,(<array> (0 2 0 2) 1 2 2 3)\n@end lisp" :similar ())

(share-row :type extended :synopsis "(share-row arr k)" :description "Shares whatever the first index is about. The result has one dimension less.\n\n@lisp\n(define a (array (shape 0 2 0 2 0 2) -1 -2 -3 -4 -5 -6 -7 -8))\n\n(share-row a 0) => #,(<array> (0 2 0 2) -1 -2 -3 -4)\n(share-row a 1) => #,(<array> (0 2 0 2) -5 -6 -7 -8)\n@end lisp" :similar ())

(share-column :type extended :synopsis "(share-column arr k)" :description "Shares whatever the second index is about. The result has one dimension less.\n\n@lisp\n(define a (array (shape 0 2 0 2 0 2) -1 -2 -3 -4 -5 -6 -7 -8))\n\n(share-column a 1) => #,(<array> (0 2 0 2) -3 -4 -7 -8)\n(share-column a 0) => #,(<array> (0 2 0 2) -1 -2 -5 -6)\n@end lisp" :similar ())

(share-array/origin :type extended :synopsis "(share-array/origin arr k ...)\n(share-array/origin arr index)" :description "change the origin of |arr| to |k| ..., with |index| a vector or zero-based\none-dimensional array that contains k ...\n\n@lisp\n(define a (array (shape 0 2 0 2 ) -1 -2 -3 -4))\n\n(share-array/origin  a 1 1) => #,(<array> (1 3 1 3) -1 -2 -3 -4)\n@end lisp" :similar ())

(array-append :type extended :synopsis "(array-append dim arr~1~ arr~2~ ...)" :description "Appends arrays |arr~1~|, |arr~2~|, ... along the specified dimension |dim|.\nThe arrays must have equally many dimensions and all other dimensions\nequally long.\n\n@lisp\n(define a (array (shape 0 2 0 3) 11 22 33 44 55 66))\n(define b (array (shape 0 3 0 3) -11 -22 -33 -44 -55 -66 -77 -88 -99))\n(define c (array (shape 0 1 0 3) 'a 'b 'c))\n\n(array-append 0 a b c) =>  #,(<array> (0 6 0 3)\n                                      11  22  33\n                                      44  55  66\n                                     -11 -22 -33\n                                     -44 -55 -66\n                                     -77 -88 -99\n                                       a   b   c)\n@end lisp" :similar ())

(transpose :type extended :synopsis "(transpose arr k ...)" :description "Shares |arr| with permuted dimensions. Each dimension from 0\ninclusive to rank exclusive must appear once in |k| ...\n\nThis is a generalized transpose. It can permute the dimensions any which\nway. The permutation is provided by a permutation matrix: a square matrix\nof zeros and ones, with exactly one one in each row and column, or a\npermutation of the rows of an identity matrix; the size of the matrix\nmust match the number of dimensions of the array.\n\nThe default permutation is |[ 0 1 , 1 0 ]| of course, but any permutation\narray can be specified, and the shape array of the original array is then\nmultiplied with it, and index column vectors of the new array with its\ninverse, from left, to permute the rows appropriately.\n@lisp\n(transpose (array (shape 0 4 0 4)\n                  -1  -2   -3  -4\n                  -5  -6   -7  -8\n                  -9  -10 -11 -12\n                  -13 -14 -15 -16))\n => #,(<array> (0 4 0 4)\n              -1 -5  -9 -13\n              -2 -6 -10 -14\n              -3 -7 -11 -15\n              -4 -8 -12 -16)\n\n(transpose (array (shape 0 3 0 3 0 2)\n                  -1 -2\n                  -3 -4\n                  -5 -6\n\n                  -7 -8\n                  -9 -10\n                  -11 -12\n\n                  -13 -14\n                  -15 -16\n                  -17 -18))\n => #,(<array> (0 2 0 3 0 3)\n               -1  -7 -13\n               -3  -9 -15\n               -5 -11 -17\n\n               -2  -8 -14\n               -4 -10 -16\n               -6 -12 -18)\n@end lisp" :similar ())

(share-nths :type extended :synopsis "(share-nths a d n)" :description "|Share-nths| takes every |n|th slice along dimension |d| into a shared array.\nThis preserves the origin.\n\n@lisp\n(define a (array (shape 0 4 0 4)\n                 -1 -2 -3 -4\n                 -5 -6 -7 -8\n                 -9 -10 -11 -12\n                 -13 -14 -15 -16))\n\n(share-nths a 0 2)\n => #,(<array> (0 2 0 4) -1  -2  -3  -4\n                         -9 -10 -11 -12)\n\n(share-nths a 1 2)\n => #,(<array> (0 4 0 2) -1  -3  -5  -7\n                         -9 -11 -13 -15)\n@end lisp" :similar ())


;; Source file "27.stk"

(random-integer :type extended :synopsis "(random-integer n)" :description "Return an integer in the range \\[0, ..., |n|\\[.  Subsequent results of\nthis procedure appear to be independent uniformly distributed over\nthe range \\[0, ..., |n|\\[. The argument |n| must be a positive integer,\notherwise an error is signaled. This function is equivalent to the eponym\nfunction of SRFI-27 (see ,(link-srfi 27) definition for more details)." :similar ())

(random-real :type extended :synopsis "(random-real)" :description "Return a real number |r| such that |0 < r < 1|.\nSubsequent results of this procedure appear to be independent uniformly\ndistributed. This function is equivalent to the eponym\nfunction of SRFI-27 (see ,(link-srfi 27) definition for more details)." :similar ())


;; Source file "170.stk"


;; Source file "175.stk"


;; Source file "238.stk"

(make-codeset :type extended :synopsis "(make-codeset name lst)" :description "returns a new codeset object of the given |name| (a symbol). The  list |lst|\nis a list of triplets (code-number symbol message) where |symbol| and\n|message|  can be `#f` if |code-number| has no associated name or message.\n\n@lisp\n (define cs\n     (make-codeset 'foo\n                   '((1   OK    \"Everything is OK\")\n                     (1   YES   #f)                  ; Other name for OK\n                     (2   KO    \"We have a problem\")\n                     (2   NO    #f)                  ; Other name for KO\n                     (3   MAYBE \"To be determined\")\n                     (404 #f    \"Not found\"))))      ; No symbolic name\n@end lisp" :similar ())

