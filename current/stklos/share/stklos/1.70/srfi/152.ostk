#!/usr/bin/env stklos
; A -*- Scheme -*- generated file *DO NOT EDIT**
STklos (#:version "1.70" #:globals (%trace-expand stklos:string-ci>=? untrace parse-arguments stklos:string-ci<? stklos:string-ci=? stklos:string-ci>? match-case match-lambda trace random-real srfi48:help stklos:string<? stklos:string=? stklos:string>? %find-macro-clause %display-backtrace help %untrace-expand %before-exit-hook expand-match-lambda scheme-report-environment %simple-fatal-exception-handler environment null-environment %build-error-location srfi48:format-fixed lexer-next-token pretty-print stklos:string<=? %print-usage random-integer stklos:string-ci<=? describe interaction-environment pp %parse-arguments-expand stklos:string>=? char-set? char-set= char-set<= char-set-hash char-set-cursor char-set-ref char-set-cursor-next end-of-char-set? char-set-fold char-set-unfold char-set-unfold! char-set-for-each char-set-map char-set-copy char-set list->char-set string->char-set list->char-set! string->char-set! char-set-filter ucs-range->char-set char-set-filter! ucs-range->char-set! ->char-set char-set->list char-set->string char-set-size char-set-count char-set-contains? char-set-every char-set-any char-set-adjoin char-set-delete char-set-adjoin! char-set-delete! char-set-complement char-set-union char-set-intersection char-set-complement! char-set-union! char-set-intersection! char-set-difference char-set-xor char-set-diff+intersection char-set-difference! char-set-xor! char-set-diff+intersection! char-set:lower-case char-set:upper-case char-set:title-case char-set:letter char-set:digit char-set:letter+digit char-set:graphic char-set:printing char-set:whitespace char-set:iso-control char-set:punctuation char-set:symbol char-set:hex-digit char-set:blank char-set:ascii char-set:empty char-set:full check-arg <char-set> %full-set-val %is-in? %char-set-add1-char %char-set-del1-char %char-set-add1-int %make-char-set-from-integer %char-set-value-set! %char-set-copy make-char-set %char-set-val %latin1->char %char-set-add %valid-cursor %char-set-unfold! %char-set-filter! %ucs-range->char-set! %char-set-setop %char-set-setop! string-null? string-every string-any string-tabulate reverse-list->string string-join substring/shared string-take string-drop string-take-right string-drop-right string-pad string-pad-right string-trim string-trim-right string-trim-both string-compare string-compare-ci string= string<> string< string> string<= string>= string-ci= string-ci<> string-ci< string-ci> string-ci<= string-ci>= string-hash string-hash-ci string-prefix-length string-suffix-length string-prefix-length-ci string-suffix-length-ci string-prefix? string-suffix? string-prefix-ci? string-suffix-ci? string-index-right string-skip string-skip-right string-count string-contains string-contains-ci string-reverse string-reverse! string-concatenate string-concatenate/shared string-append/shared string-concatenate-reverse string-concatenate-reverse/shared string-map! string-fold string-fold-right string-unfold string-unfold-right string-for-each-index xsubstring string-xcopy! string-replace string-tokenize string-filter string-delete string-parse-start+end string-parse-final-start+end substring-spec-ok? check-substring-spec make-kmp-restart-vector kmp-step string-kmp-partial-search let-string-start+end %%check-indexes-func %check-indexes %check-substring-indexes %substring/shared %string-copy! %string-compare %true %false %str-cmp %str-cmp-ci %string-hash %string-prefix-length %string-suffix-length %string-prefix? %string-suffix? %finish-string-concatenate-reverse %string-map %string-map! %multispan-repcopy! string-contains-right string-take-while string-take-while-right string-drop-while string-drop-while-right string-break string-span string-remove string-replicate string-segment allow-no-args let-optionals* %let-optionals* let-string-start+end2 %string-split-chars %string-split %substring %kmp-search) #:macros ())
#(%module-handler srfi/152 %module-create current-module ((STklos #:only (string-copy! string-fill! string-set! write-string read-string string-for-each string-map string-append string-copy substring string-ref string-length list->string string->list vector->string string->vector string make-string string?))) list-copy %do-imports ((STklos #:rename ((string=? stklos:string=?) (string-ci>=? stklos:string-ci>=?) (string-ci<=? stklos:string-ci<=?) (string-ci>? stklos:string-ci>?) (string-ci<? stklos:string-ci<?) (string-ci=? stklos:string-ci=?) (string>=? stklos:string>=?) (string<=? stklos:string<=?) (string>? stklos:string>?) (string<? stklos:string<?)))) ((srfi/13)) ((string? . string?) (string-null? . string-null?) (string-every . string-every) (string-any . string-any) (make-string . make-string) (string . string) (string-tabulate . string-tabulate) (string-unfold . string-unfold) (string-unfold-right . string-unfold-right) (string->vector . string->vector) (string->list . string->list) (vector->string . vector->string) (list->string . list->string) (reverse-list->string . reverse-list->string) (string-length . string-length) (string-ref . string-ref) (substring . substring) (string-copy . string-copy) (string-take . string-take) (string-take-right . string-take-right) (string-drop . string-drop) (string-drop-right . string-drop-right) (string-pad . string-pad) (string-pad-right . string-pad-right) (string-trim . string-trim) (string-trim-right . string-trim-right) (string-trim-both . string-trim-both) (string-replace . string-replace) (string=? . string=?) (string-ci=? . string-ci=?) (string<? . string<?) (string-ci<? . string-ci<?) (string>? . string>?) (string-ci>? . string-ci>?) (string<=? . string<=?) (string-ci<=? . string-ci<=?) (string>=? . string>=?) (string-ci>=? . string-ci>=?) (string-prefix-length . string-prefix-length) (string-suffix-length . string-suffix-length) (string-prefix? . string-prefix?) (string-suffix? . string-suffix?) (string-index . string-index) (string-index-right . string-index-right) (string-skip . string-skip) (string-skip-right . string-skip-right) (string-contains . string-contains) (string-contains-right . string-contains-right) (string-take-while . string-take-while) (string-take-while-right . string-take-while-right) (string-drop-while . string-drop-while) (string-drop-while-right . string-drop-while-right) (string-break . string-break) (string-span . string-span) (string-append . string-append) (string-concatenate . string-concatenate) (string-concatenate-reverse . string-concatenate-reverse) (string-join . string-join) (string-fold . string-fold) (string-fold-right . string-fold-right) (string-map . string-map) (string-for-each . string-for-each) (string-count . string-count) (string-filter . string-filter) (string-remove . string-remove) (string-replicate . string-replicate) (string-segment . string-segment) (string-split . string-split) (read-string . read-string) (write-string . write-string) (string-set! . string-set!) (string-fill! . string-fill!) (string-copy! . string-copy!)) %do-exports allow-no-args (lambda (proc) (let ((args (gensym 'args)) (pref (lambda (a b) (string->symbol (string-append a (symbol->string b)))))) `(define (,proc unquote args) (if (null? ,args) #t (apply ,(pref "stklos:" proc) ,args))))) args gensym symbol->string string-append string->symbol define if null? apply "stklos:" %make-syntax stklos:string=? string=? stklos:string<? string<? stklos:string>? string>? stklos:string<=? string<=? stklos:string>=? string>=? stklos:string-ci=? string-ci=? stklos:string-ci<? string-ci<? stklos:string-ci>? string-ci>? stklos:string-ci<=? string-ci<=? stklos:string-ci>=? string-ci>=? let-optionals* (lambda args (%find-macro-clause 'let-optionals* args '(let-optionals*) '(((let-optionals* arg (opt-clause ...) body ...) (let ((rest arg)) (%let-optionals* rest (opt-clause ...) body ...)))))) (let-optionals*) (((let-optionals* arg (opt-clause ...) body ...) (let ((rest arg)) (%let-optionals* rest (opt-clause ...) body ...)))) %find-macro-clause %let-optionals* (lambda args (%find-macro-clause '%let-optionals* args '(%let-optionals*) '(((%let-optionals* arg (((var ...) xparser) opt-clause ...) body ...) (call-with-values (lambda () (xparser arg)) (lambda (rest var ...) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg ((var default) opt-clause ...) body ...) (call-with-values (lambda () (if (null? arg) (values default '()) (values (car arg) (cdr arg)))) (lambda (var rest) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg ((var default test) opt-clause ...) body ...) (call-with-values (lambda () (if (null? arg) (values default '()) (let ((var (car arg))) (if test (values var (cdr arg)) (error "arg failed LET-OPT test" var))))) (lambda (var rest) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg ((var default test supplied?) opt-clause ...) body ...) (call-with-values (lambda () (if (null? arg) (values default #f '()) (let ((var (car arg))) (if test (values var #t (cdr arg)) (error "arg failed LET-OPT test" var))))) (lambda (var supplied? rest) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg (rest) body ...) (let ((rest arg)) body ...)) ((%let-optionals* arg () body ...) (if (null? arg) (begin body ...) (error "Too many arguments in let-opt" arg)))))) (%let-optionals*) (((%let-optionals* arg (((var ...) xparser) opt-clause ...) body ...) (call-with-values (lambda () (xparser arg)) (lambda (rest var ...) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg ((var default) opt-clause ...) body ...) (call-with-values (lambda () (if (null? arg) (values default '()) (values (car arg) (cdr arg)))) (lambda (var rest) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg ((var default test) opt-clause ...) body ...) (call-with-values (lambda () (if (null? arg) (values default '()) (let ((var (car arg))) (if test (values var (cdr arg)) (error "arg failed LET-OPT test" var))))) (lambda (var rest) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg ((var default test supplied?) opt-clause ...) body ...) (call-with-values (lambda () (if (null? arg) (values default #f '()) (let ((var (car arg))) (if test (values var #t (cdr arg)) (error "arg failed LET-OPT test" var))))) (lambda (var supplied? rest) (%let-optionals* rest (opt-clause ...) body ...)))) ((%let-optionals* arg (rest) body ...) (let ((rest arg)) body ...)) ((%let-optionals* arg () body ...) (if (null? arg) (begin body ...) (error "Too many arguments in let-opt" arg)))) let-string-start+end (lambda args (%find-macro-clause 'let-string-start+end args '(let-string-start+end) '(((_ (?start ?end ?rest) ?proc ?s ?args . ?body) (call-with-values (lambda () (string-parse-start+end ?proc ?s ?args)) (lambda (?rest ?start ?end) . ?body))) ((_ (?start ?end) ?proc ?s ?args . ?body) (call-with-values (lambda () (string-parse-final-start+end ?proc ?s ?args)) (lambda (?start ?end) . ?body)))))) (let-string-start+end) (((_ (?start ?end ?rest) ?proc ?s ?args . ?body) (call-with-values (lambda () (string-parse-start+end ?proc ?s ?args)) (lambda (?rest ?start ?end) . ?body))) ((_ (?start ?end) ?proc ?s ?args . ?body) (call-with-values (lambda () (string-parse-final-start+end ?proc ?s ?args)) (lambda (?start ?end) . ?body)))) let-string-start+end2 (lambda args (%find-macro-clause 'let-string-start+end2 args '(let-string-start+end2) '(((l-s-s+e2 (start1 end1 start2 end2) proc s1 s2 args body ...) (let ((procv proc)) (let-string-start+end (start1 end1 rest) procv s1 args (let-string-start+end (start2 end2) procv s2 rest body ...))))))) (let-string-start+end2) (((l-s-s+e2 (start1 end1 start2 end2) proc s1 s2 args body ...) (let ((procv proc)) (let-string-start+end (start1 end1 rest) procv s1 args (let-string-start+end (start2 end2) procv s2 rest body ...))))) check-arg (lambda (pred val caller) `(if (,pred ,val) ,val (error ,caller "bad argument ~S" ,val))) error "bad argument ~S" string? "string expected" "string expected" string-length pair? cddr cdddr cadr caddr cadddr values infix (infix strict-infix prefix suffix) memq "grammar must be one of (infix strict-infix prefix suffix)" integer? exact? "limit must be exact nonnegative integer or #f" "start argument must be exact integer" <= "start argument out of range" "end argument out of range" "start argument is greater than end argument" strict-infix "empty string cannot be spilt with strict-infix grammar" string-null? %string-split-chars %string-split call-with-values string-split string string->list map reverse substring suffix string-contains prefix zero? %substring "minimum segment size is 1" min string-segment string-take-while string-parse-final-start+end string-skip "" string-skip-right "" string-take-while-right string-drop-while string-drop-while-right string-span "" string-break string-index "" string-replicate "" "Cannot replicate empty (sub)string" make-string floor modulo %multispan-repcopy! + %string-copy! quotient string-remove string-fold make-kmp-restart-vector %kmp-search char=? string-parse-start+end make-vector string-contains-right string-reverse - %module-restore "srfi/152" provide)
3026
  
   -∆ % U  V   J % % V    n U  V   ! M V   % % V    n U  V   ! M V   % % V    n U  V   ! M V   % % V    ! U 	 V 
  % U  U  # K  % % U  V   ! #   % % f % e V   q   s   $ ! +  U  u   ; ! U  U  f  ; ; ! N U  % U  u   &  ! f  ; ; ; !  ; ; ; ; !  ; ; ; $ ! U  V     # ˇˇ  <    $ % j  e l   $   # ˇˇ  <    $ % j  e l   $   # ˇˇ  <    $ % j  e l   $   # ˇˇ  <    $ % j  e l   $   # ˇˇ  <    $ % j   e l   $  ! # ˇˇ  <    $ % j " e l   $  # # ˇˇ  <    $ % j $ e l   $  % # ˇˇ  <    $ % j & e l   $  ' # ˇˇ  <    $ % j ( e l   $  ) # ˇˇ  <    $ % j * e l   $  + % U , U - # ˇˇ % U , e U . U / l 0  $ ! U  V    , % U 1 U 2 # ˇˇ % U 1 e U 3 U 4 l 0  $ ! U  V    1 % U 5 U 6 # ˇˇ % U 5 e U 7 U 8 l 0  $ ! U  V    5 % U 9 U : # ˇˇ % U 9 e U ; U < l 0  $ ! U  V    9 % U = U > #   U  g f  ; ; ! f U ? e U @ f  ; ; ; ; !  ; ; ; ; $ ! U  V    = #äˇ˝ % g V A   	 % U B g V ?     % f V A   	 % U C f V ?     % % g V D  ! +  % # å   % u  V E   w %   > q E   ` % % u  V F  q E   A % % u  V G  q E    %   = n u  V H  ! M % u  V I  n u  V J  s K  $ %   = n u  V H  ! M % u  V I  ! u  l K  $ %   = n u  V H  ! M Q u  l K  $ %   = ! M N Q u  l K  $ % U L M N Q u  l K  $ ! # »  % i U M V N   	 % U O i V ?                % h V P    % h V Q    h  8        	 % U R h V ?     % f V P    % f V Q      	 % U S f V ?     % Q f u  V T   	 % U U f V ?     % Q e u  V T   	 % U V e V ?     f  _  % U W f e ?  q ?     f  \  i 	 X b  % U Y l ?  $  $ % u V Z    % u f e h l [    % u f e u i h l \  $ s ]  $  ^ # d     % j _ % h g f V `  s a  $ % O g Q % M )  % # ;  f  \  % g l b  $ e   ^  % % u f u V c  !  ; s b    % % u  C q _  !  ; !  9 !  9 !   '  $ ! )     ,  , '  $  [ # …  % % g V D  ! +  % M M +  # .  % % u e u V c  ! +  u 	 d b  % e V Z       % u l b  $ % e  ; s b  $  # }      e   8      % g f  '  $ % % u u f u V e  ! +    J % % u u e V c  ! +  u   \  u 	 f b  % e V Z       % u u    0 !   9 !   '  $ % e  ; ! u    0 !   9 !   '  $ $ % u u  '  $ $  % O u Q  '  $  \ #   % f V g   	 e % g V D  4       $ % g f e l c  $  h # _  e  a 	 % U i e V ?     % % f V D  ! +  % Q O % M )  % # 1  f   \  % e l b  $ % % f   0 ! u  V j  ! +  % e % u u e V h  !   ; !   '  $ $ ! )     ,  , '  $  k # 5ˇ˝ % #    % j l u u  l m  $ ! #   % % u u f e V n  ! +    	 % u Q e l h  $ 	 o $ s ]  $  l # ;ˇ˝ % #    % j l u u  l m  $ ! # $  % % u u f e V p  ! +     % u  9 n u V D  s h  $ 	 q $ s ]  $  r # :ˇ˝ % #    % j s u u  l m  $ ! # #  % % u u f e V n  ! +     % u e % u V D  s h  $  $ s ]  $  s # 6ˇ˝ % #    % j s u u  l m  $ ! #   % % u u f e V p  ! +    
 % u Q  9 s h  $  $ s ]  $  t # Lˇ˝ % #    % j u u u  l m  $ ! # 5  % % u u f e V n  ! +     % % u Q e V h  n u e % u V D  q h  s K  $ % U v u l K  $ s ]  $  u # Lˇ˝ % #    % j w u u  l m  $ ! # 5  % % u u f e V x  ! +     % % u Q e V h  n u e % u V D  q h  s K  $ % u U y l K  $ s ]  $  w #?ˇ˝ % f )  % e V P    % e V Q     ,     	 % j z U @ f V ?  % # Ö   % u  V E   Q % #    % j z u   > s m  $ ! # :  %   = ! +  % e )  % e V P    % e V Q    u  7    ,     	 % j z U @ e V ?  % e u u  l K  $ s ]  $ % % % u V A      
 % j z U @ u V ?  q D  ! +  % u  0 ! Q e l K  $ $ ! # ç  % e  1 ! g  1 ! +  % e V g    	 { $ % f V g    % U | j z u u u u u  l ?   Z R  \  % e u  C s }   J % u  3 q ~  n u  3 q ~  \  % u u % u f V   0 ! u % u f V   0 s c    % % e V }  ! +  % e Q u u u u u  V Ä   $ $ s ]  $  z # y  f  _ 4 % M )  % #   f   ^   $ u e u  C D %  9 !  9 !   '  $ ! )     , % u u  &  , $ % M )  % #   f  a   $ u e u  C D %  : !  : !   '  $ ! )     , %   : n P u u   1 q Å  !  &  , $  Ç # ë  *  u   1  u % u e V   0  u  1  % u u u f u  V Ç  *  u   1  u  1  % f u  V É   % M )  % # 9  % e V g    % u f u u u u f  1 1 0 s Ç  $ % u f u u u  V Ç  % f   0 !  : !   '  $ ! )     , % u   0 ! u  &  , $  Ä # Vˇ˝ % #    % j Ñ u u  l m  $ ! # ?  *  u   1  % e V }   % #   % f  &     $ u e  D  9 $ ! Q u u u  V Ö   g  \   $ % f Q g l c  $ s ]  $  Ñ # ó  % g  1 n   ! i h g V Ü  ! +  % u Q u   1 ! f % M )  % # g  g  \  h  1 $ e  ` V % u  C ! u u  0 C !  &    %  9 !  9 !  : !  : !   '   0 % u   A ! +  e  \  %  9 ! Q  : ! u   '  $ % u e u u  1 !   '  $    $ ! )     ,  , '  $  á #ˇ˛ % e +  % #      <   % j à O l K  $ %   = !   > s K  $ ! # ‰  % e +  % #    % j Ü u u  l â  $ ! # …  *  u   1  % e P V ä   e  _ ≤ %  : ! u  C ! )  % Q P u % M )  % # å  g  a Ñ % f % M )  % # o  e  \ - %  9 ! u
   9 C ! +  u f % e u  	 &        B % f Q   9 !   '  $ $ % u
   C ! u
 e  0 C !  &    *   9    9  u e  B % e f   9 !   '  $  
 % u  A !   '  $ ! )     ,  , '  $  $ ! )     ,  , &  ,     $ s ]  $ s ]  $  Ü # çˇ˝ % j ã +  % #    % u  u u  l â  $ ! # q  % #    % u  u u l m  $ ! # Z  *  % u V D   % u V D   u   1  e   1  e  1  f   1   f  1   % % u V å  n u V å  o à !   !   ! h i V á       
 % e   ! g V ç  $  $ s ]  $ s ]  $  ã % V é   J % S U  V K  . % U è V ê  /
