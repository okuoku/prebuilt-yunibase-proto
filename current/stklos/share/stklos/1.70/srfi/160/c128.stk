;;;;
;;;; 160/c128.stk         -- SRFI-160: Homogeneous numeric vector libraries
;;;;                                  (c128 sublibrary)
;;;;
;;;; Copyright Â© 2021 Jeronimo Pellegrini <j_p@aleph0.info>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Jeronimo Pellegrini [j_p@aleph0.info]
;;;;    Creation date: 17-Jun-2022 15:54
;;;;

(define-module srfi/160/c128

  (import (srfi 4)
          (srfi 128)
          (srfi 160 base))
  (export
   ;; Constructors
   make-c128vector   ;; BASE
   c128vector        ;; BASE
   c128vector-unfold
   c128vector-unfold-right
   c128vector-copy
   c128vector-reverse-copy
   c128vector-append
   c128vector-concatenate
   c128vector-append-subvectors

   ;; Predicates
   c128?              ;; BASE
   c128vector?        ;; BASE
   c128vector-empty?
   c128vector=

   ;; Selectors
   c128vector-ref     ;; BASE
   c128vector-length  ;; BASE

   ;; Iteration
   c128vector-take
   c128vector-take-right
   c128vector-drop
   c128vector-drop-right
   c128vector-segment
   c128vector-fold
   c128vector-fold-right
   c128vector-map
   c128vector-map!
   c128vector-for-each
   c128vector-count
   c128vector-cumulate

   ;; Searching
   c128vector-take-while
   c128vector-take-while-right
   c128vector-drop-while
   c128vector-drop-while-right
   c128vector-index
   c128vector-index-right
   c128vector-skip
   c128vector-skip-right
   c128vector-any
   c128vector-every
   c128vector-partition
   c128vector-filter
   c128vector-remove

   ;; Mutators
   c128vector-set!            ;; BASE
   c128vector-swap!
   c128vector-fill!
   c128vector-reverse!
   c128vector-copy!
   c128vector-reverse-copy!
   c128vector-unfold!
   c128vector-unfold-right!

   ;; Conversion
   c128vector->list           ;; BASE
   reverse-c128vector->list
   list->c128vector           ;; BASE
   reverse-list->c128vector
   c128vector->vector
   vector->c128vector

   ;; Generators
   make-c128vector-generator

   ;; Comparators
   c128vector-comparator

   ;; Output
   write-c128vector)


;; A case of "macros for performance"... Not the best thing to do, we could
;; actually have done a more sofisticated job in generating the output from
;; the template, but this keeps it simple.
;; The macro (uvector-tag) will expand to c128 in the template.
;; However, in the generated file, the c128 will be replaed by the tag name.
;; So the macro will expand to the VALUE of the tag, which is the
;; fastest thing we can do. Not even access to a global will be done, the
;; correct constant will be pushed onto the stack.
;;
;;  (%s32vector-something (uvector-tag) args)
;; EXPANDS into
;;  (u8vector-something 4 args)
;; and NOT into
;;  (%u8vector-something s32 args)

(define-macro (uvector-tag)
  (let ((s8   0)
        (u8   1)
        (s16  2)
        (u16  3)
        (s32  4)
        (u32  5)
        (s64  6)
        (u64  7)
        (f32  8)
        (f64  9)
        (c64  10)
        (c128 11))
    c128))

;; We'll be accessing the base module to get some procedures from it:
(define base (find-module 'srfi/160/base))

;; These are implemented in C, and used here to build the actual procedures:
(define %uvector-unfold            (symbol-value '%uvector-unfold base))
(define %uvector-copy              (symbol-value '%uvector-copy base))
(define %uvector-append-subvectors (symbol-value '%uvector-append-subvectors base))
(define %uvector-empty?            (symbol-value '%uvector-empty? base))
(define %uvector=                  (symbol-value '%uvector= base))
(define %uvector-iterate           (symbol-value '%uvector-iterate base))
(define %uvector-segment           (symbol-value '%uvector-segment base))

;;;
;;; Constructors OK
;;;

;; make-vector OK
;; vector      OK

(define (c128vector-unfold f len seed)
  (%uvector-unfold (uvector-tag) f #f len seed #f))

(define (c128vector-unfold-right f len seed)
  (%uvector-unfold (uvector-tag) f #f len seed #t))

(define (c128vector-copy v :optional (start 0) (end (c128vector-length v)))
  (%uvector-copy (uvector-tag) #f 0 v start end #f))

(define (c128vector-reverse-copy v :optional (start 0) (end (c128vector-length v)))
  (%uvector-copy (uvector-tag) #f 0 v start end #t))

(define (c128vector-append . vecs)
  (%uvector-append-subvectors (uvector-tag) #f vecs))

(define (c128vector-concatenate vecs)
  (%uvector-append-subvectors (uvector-tag) #f vecs))

(define (c128vector-append-subvectors . vecs)
  (%uvector-append-subvectors (uvector-tag) #t vecs))

;;;
;;; Predicates OK
;;;

(define (c128vector-empty? v) (%uvector-empty? (uvector-tag) v))

(define (c128vector= . args) (%uvector= (uvector-tag) args))

;;;
;;; Selectors OK
;;;

;; vector-ref    OK
;; vector-length OK

;; Iteration OK

(define (c128vector-take v n) (c128vector-copy v 0 n))
(define (c128vector-take-right v n)
  (c128vector-copy v (- (c128vector-length v) n))) ; FIXME: optimize?

(define (c128vector-drop v n)       (c128vector-copy v n))
(define (c128vector-drop-right v n)
  (%uvector-copy (uvector-tag) #f 0 v 0 (- (c128vector-length v) n) #f)) ; FIXME: optimize?

(define (c128vector-segment v n) (%uvector-segment (uvector-tag) v n))

(define (c128vector-fold kons knil v1 . v2)
  (%uvector-iterate (uvector-tag) kons (cons v1 v2)
   #f   ;; do NOT mutate
   10   ;; operation (10 = fold)
   #f   ;; NOT from-right
   knil ;; seed
   ))

(define (c128vector-fold-right kons knil v1 . v2)
  (%uvector-iterate (uvector-tag) kons (cons v1 v2)
   #f   ;; do NOT mutate
   10   ;; operation (10 = fold)
   #t   ;; YES from-right
   knil ;; seed
   ))

(define (c128vector-map proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   0  ;; operation (0 = map)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-map! proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #t ;; DO mutate
   0  ;; operation (0 = map)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-for-each proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   9  ;; operation (9 = for-each)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-count proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   5  ;; operation (5 = count)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-cumulate kons knil v1)
  (%uvector-iterate (uvector-tag) kons (list v1)
   #f   ;; do NOT mutate
   11   ;; operation (11 = cumulate)
   #f   ;; NOT from-right
   knil ;; seed
   ))

;;;
;;; Searching OK
;;;

(define (c128vector-take-while pred? vec)
  (c128vector-take vec (c128vector-skip pred? vec)))

(define (c128vector-take-while-right pred? vec)
  (c128vector-drop vec (+ 1 (c128vector-skip-right pred? vec))))

(define (c128vector-drop-while pred? vec)
  (c128vector-drop vec (c128vector-skip pred? vec)))

(define (c128vector-drop-while-right pred? vec)
  (c128vector-take vec (+ 1 (c128vector-skip-right pred? vec))))


(define (c128vector-index proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   3  ;; operation (3 = index)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-index-right proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   3  ;; operation (3 = index)
   #t ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-skip proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   4  ;; operation (4 = skip)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-skip-right proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   4  ;; operation (4 = skip)
   #t ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-any proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   1  ;; operation (1 = any)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-every proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   2  ;; operation (2 = every)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-partition proc v1)
  (%uvector-iterate (uvector-tag) proc (list v1)
   #f ;; do NOT mutate
   6  ;; operation (6 = partition)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (c128vector-filter proc v1)
  (%uvector-iterate (uvector-tag) proc (list v1)
   #f ;; do NOT mutate
   7  ;; operation (7 = filter)
   #f ;; NOT from-right
   #f ;; NO seed
   ))
(define (c128vector-remove proc v1)
  (%uvector-iterate (uvector-tag) proc (list v1)
   #f ;; do NOT mutate
   8  ;; operation (8 = remove)
   #f ;; NOT from-right
   #f ;; NO seed
   ))


;;;
;;; Mutators OK
;;;

;; vector-set! OK

;; FIXME:
;; vector-fill! and vector-swap! do not depend on vector type,
;; but vector-fill! does some type checking for each element
;; written. Maybe this could be optimized...
(define c128vector-swap! (symbol-value '%uvector-swap!         base))
(define c128vector-fill! (symbol-value '%uvector-fill!         base))

(define (c128vector-reverse! v :optional (start 0) (end (c128vector-length v)))
  (%uvector-copy (uvector-tag) v start v start end #t)
  #void)

(define (c128vector-copy! to at from :optional (start 0) (end (c128vector-length from)))
  (%uvector-copy (uvector-tag) to at from start end #f)
  #void)

(define (c128vector-reverse-copy! to at from :optional (start 0) (end (c128vector-length from)))
  (%uvector-copy (uvector-tag) to at from start end #t)
  #void)

(define (c128vector-unfold! f v start end seed)
  (%uvector-unfold (uvector-tag) f v start end seed #f)
  #void)

(define (c128vector-unfold-right! f v start end seed)
  (%uvector-unfold (uvector-tag) f v start end seed #t)
  #void)

;;;
;;; Conversion OK
;;;

(define (vector->c128vector v :optional (start 0) (end (vector-length v)))
  (let* ((w (make-c128vector (- end start))))
    (do ((i start (+ i 1)))
        ((= i end))
      (c128vector-set! w (- i start) (vector-ref v i)))
    w))

(define (c128vector->vector v :optional (start 0) (end (c128vector-length v)))
  (let* ((w (make-vector (- end start))))
    (do ((i start (+ i 1)))
        ((= i end))
      (vector-set! w (- i start) (c128vector-ref v i)))
    w))


(define (c128vector->list v :optional (start 0) (end (c128vector-length v)))
  (let ((v (c128vector-copy v start end)))
    (let loop ((i (fx- (c128vector-length v) 1))
               (lst '()))
      (if (fx< i 0)
          lst
          (loop (fx- i 1) (cons (c128vector-ref v i) lst))))))


(define (reverse-list->c128vector lst)
  (c128vector-reverse-copy (list->c128vector lst)))

(define (reverse-c128vector->list v :optional (start 0) (end (c128vector-length v)))
  (c128vector->list (c128vector-reverse-copy v start end)))

;;;
;;; Generators OK
;;;

(define (make-c128vector-generator v :optional (start 0) (end (c128vector-length v)))
  (lambda () (if (fx>= start end)
            (eof-object)
            (let ((x (c128vector-ref v start)))
              (set! start (fx+ 1 start))
              x))))

;;;
;;; Comparators OK
;;;

;; Adapted from reference implementation in Chicken:
(define (c128vector< vec1 vec2)
     (let ((len1 (c128vector-length vec1))
           (len2 (c128vector-length vec2)))
       (cond
         ((fx< (c128vector-length vec1)
               (c128vector-length vec2))
          #t)
         ((fx> (c128vector-length vec1)
               (c128vector-length vec2))
          #f)
         (else
          (let loop ((i 0))
            (cond
              ((fx= i len1) #f)
              ((< (c128vector-ref vec1 i) (c128vector-ref vec2 i))
               #t)
              ((> (c128vector-ref vec1 i) (c128vector-ref vec2 i))
               #f)
              (else
               (loop (fx+ i 1)))))))))

(define c128vector-comparator
  (make-comparator c128vector? c128vector= c128vector< hash-table-hash))

;;;
;;; Output OK
;;;

(define (write-c128vector v :optional port)
  (unless ()
    (error))
  (if port
      (write v port)
      (write v)))

  )

(provide "srfi/160/c128")
