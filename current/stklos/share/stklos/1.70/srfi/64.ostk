#!/usr/bin/env stklos
; A -*- Scheme -*- generated file *DO NOT EDIT**
STklos (#:version "1.70" #:globals (define-record-type define-condition-type condition test-begin %test-approximate= %test-begin %test-on-test-begin %test-result-expected-value! %test-result-actual-value! %test-on-test-end %test-report-result %test-end %test-as-specifier %test-match-all %test-runner-fail-list %test-runner-fail-list! %test-should-execute %test-runner-skip-list %test-runner-skip-list! %test-match-nth %test-match-any %test-comp1body %test-evaluate-with-catch %test-comp2 %test-comp2body %test-error test-end test-assert test-eqv test-eq test-equal test-approximate test-error test-apply test-with-runner test-match-nth test-match-all test-match-any test-match-name test-skip test-expect-fail test-read-eval-string test-runner-group-path test-group test-group-with-cleanup test-result-ref test-result-set! test-result-clear test-result-remove test-result-kind test-passed? test-log-to-file test-runner? test-runner-reset test-runner-null test-runner-simple test-runner-current test-runner-factory test-runner-get test-runner-create test-runner-test-name test-runner-pass-count test-runner-pass-count! test-runner-fail-count test-runner-fail-count! test-runner-xpass-count test-runner-xpass-count! test-runner-xfail-count test-runner-xfail-count! test-runner-skip-count test-runner-skip-count! test-runner-group-stack test-runner-group-stack! test-runner-on-test-begin test-runner-on-test-begin! test-runner-on-test-end test-runner-on-test-end! test-runner-on-group-begin test-runner-on-group-begin! test-runner-on-group-end test-runner-on-group-end! test-runner-on-final test-runner-on-final! test-runner-on-bad-count! test-runner-on-bad-end-name test-runner-on-bad-end-name! test-result-alist test-result-alist! test-runner-aux-value test-runner-aux-value! test-on-group-begin-simple test-on-group-end-simple test-on-bad-count-simple test-on-bad-end-name-simple test-on-final-simple test-on-test-end-simple %test-runner-cookie %test-record-define %test-runner-alloc %test-runner-run-list %test-runner-skip-save %test-runner-fail-save test-runner-on-bad-count %test-runner-total-count %test-runner-count-list %test-runner-run-list! %test-runner-skip-save! %test-runner-fail-save! %test-runner-total-count! %test-runner-count-list! %test-null-callback %test-specifier-matches %test-any-specifier-matches %test-on-bad-count-write %test-final-report1 %test-final-report-simple %test-format-line test-on-test-begin-simple %test-write-result1 %test-source-line2) #:macros (((test-begin . test-begin) srfi/64 (lambda args (%find-macro-clause 'test-begin args '(test-begin) '(((test-begin suite-name) (%test-begin suite-name #f)) ((test-begin suite-name count) (%test-begin suite-name count)))))) ((%test-comp1body . %test-comp1body) srfi/64 (lambda args (%find-macro-clause '%test-comp1body args '(%test-comp1body) '(((%test-comp1body r expr) (let () (if (%test-on-test-begin r) (let () (let ((res (%test-evaluate-with-catch expr))) (%test-result-actual-value! r res) (%test-on-test-end r res)))) (%test-report-result))))))) ((%test-evaluate-with-catch . %test-evaluate-with-catch) srfi/64 (lambda args (%find-macro-clause '%test-evaluate-with-catch args '(%test-evaluate-with-catch) '(((%test-evaluate-with-catch test-expression) (guard (err (else #f)) test-expression)))))) ((%test-comp2 . %test-comp2) srfi/64 (lambda args (%find-macro-clause '%test-comp2 args '(%test-comp2) '(((%test-comp2 comp tname expected expr) (let* ((r (test-runner-get)) (name tname)) (test-result-alist! r (list (cons 'test-name tname))) (%test-comp2body r comp expected expr))) ((%test-comp2 comp expected expr) (let* ((r (test-runner-get))) (test-result-alist! r '()) (%test-comp2body r comp expected expr))))))) ((%test-comp2body . %test-comp2body) srfi/64 (lambda args (%find-macro-clause '%test-comp2body args '(%test-comp2body) '(((%test-comp2body r comp expected expr) (let () (if (%test-on-test-begin r) (let ((exp expected)) (%test-result-expected-value! r exp) (let ((res (%test-evaluate-with-catch expr))) (%test-result-actual-value! r res) (%test-on-test-end r (comp exp res))))) (%test-report-result))))))) ((%test-error . %test-error) srfi/64 (lambda args (%find-macro-clause '%test-error args '(%test-error) '(((%test-error r etype expr) (%test-comp1body r (guard (ex ((condition-type? etype) (and (condition? ex) (condition-has-type? ex etype))) ((procedure? etype) (etype ex)) ((equal? etype #t) #t) (else #t)) expr #f))))))) ((test-end . test-end) srfi/64 (lambda args (%find-macro-clause 'test-end args '(test-end) '(((test-end) (%test-end #f '())) ((test-end suite-name) (%test-end suite-name '())))))) ((test-assert . test-assert) srfi/64 (lambda args (%find-macro-clause 'test-assert args '(test-assert) '(((test-assert tname test-expression) (let* ((r (test-runner-get)) (name tname)) (test-result-alist! r '((test-name . tname))) (%test-comp1body r test-expression))) ((test-assert test-expression) (let* ((r (test-runner-get))) (test-result-alist! r '()) (%test-comp1body r test-expression))))))) ((test-eqv . test-eqv) srfi/64 (lambda args (%find-macro-clause 'test-eqv args '(test-eqv) '(((test-eqv . rest) (%test-comp2 eqv? . rest)))))) ((test-eq . test-eq) srfi/64 (lambda args (%find-macro-clause 'test-eq args '(test-eq) '(((test-eq . rest) (%test-comp2 eq? . rest)))))) ((test-equal . test-equal) srfi/64 (lambda args (%find-macro-clause 'test-equal args '(test-equal) '(((test-equal . rest) (%test-comp2 equal? . rest)))))) ((test-approximate . test-approximate) srfi/64 (lambda args (%find-macro-clause 'test-approximate args '(test-approximate) '(((test-approximate tname expected expr error) (%test-comp2 (%test-approximate= error) tname expected expr)) ((test-approximate expected expr error) (%test-comp2 (%test-approximate= error) expected expr)))))) ((test-error . test-error) srfi/64 (lambda args (%find-macro-clause 'test-error args '(test-error) '(((test-error name etype expr) (let ((r (test-runner-get))) (test-result-alist! r `((test-name unquote name))) (%test-error r etype expr))) ((test-error etype expr) (let ((r (test-runner-get))) (test-result-alist! r '()) (%test-error r etype expr))) ((test-error expr) (let ((r (test-runner-get))) (test-result-alist! r '()) (%test-error r #t expr))))))) ((test-with-runner . test-with-runner) srfi/64 (lambda args (%find-macro-clause 'test-with-runner args '(test-with-runner) '(((test-with-runner runner form ...) (let ((saved-runner (test-runner-current))) (dynamic-wind (lambda () (test-runner-current runner)) (lambda () form ...) (lambda () (test-runner-current saved-runner))))))))) ((test-match-nth . test-match-nth) srfi/64 (lambda args (%find-macro-clause 'test-match-nth args '(test-match-nth) '(((test-match-nth n) (test-match-nth n 1)) ((test-match-nth n count) (%test-match-nth n count)))))) ((test-match-all . test-match-all) srfi/64 (lambda args (%find-macro-clause 'test-match-all args '(test-match-all) '(((test-match-all pred ...) (%test-match-all (%test-as-specifier pred) ...)))))) ((test-match-any . test-match-any) srfi/64 (lambda args (%find-macro-clause 'test-match-any args '(test-match-any) '(((test-match-any pred ...) (%test-match-any (%test-as-specifier pred) ...)))))) ((test-skip . test-skip) srfi/64 (lambda args (%find-macro-clause 'test-skip args '(test-skip) '(((test-skip pred ...) (let ((runner (test-runner-get))) (%test-runner-skip-list! runner (cons (test-match-all (%test-as-specifier pred) ...) (%test-runner-skip-list runner))))))))) ((test-expect-fail . test-expect-fail) srfi/64 (lambda args (%find-macro-clause 'test-expect-fail args '(test-expect-fail) '(((test-expect-fail pred ...) (let ((runner (test-runner-get))) (%test-runner-fail-list! runner (cons (test-match-all (%test-as-specifier pred) ...) (%test-runner-fail-list runner))))))))) ((test-group . test-group) srfi/64 (lambda args (%find-macro-clause 'test-group args '(test-group) '(((test-group suite-name . body) (let ((r (test-runner-current))) (test-result-alist! r (list (cons 'test-name suite-name))) (if (%test-should-execute r) (dynamic-wind (lambda () (test-begin suite-name)) (lambda () . body) (lambda () (test-end suite-name)))))))))) ((test-group-with-cleanup . test-group-with-cleanup) srfi/64 (lambda args (%find-macro-clause 'test-group-with-cleanup args '(test-group-with-cleanup) '(((test-group-with-cleanup suite-name form cleanup-form) (test-group suite-name (dynamic-wind (lambda () #f) (lambda () form) (lambda () cleanup-form)))) ((test-group-with-cleanup suite-name cleanup-form) (test-group-with-cleanup suite-name #f cleanup-form)) ((test-group-with-cleanup suite-name form1 form2 form3 . rest) (test-group-with-cleanup suite-name (begin form1 form2) form3 . rest)))))) ((test-result-ref . test-result-ref) srfi/64 (lambda args (%find-macro-clause 'test-result-ref args '(test-result-ref) '(((test-result-ref runner pname) (test-result-ref runner pname #f)) ((test-result-ref runner pname default) (let ((p (assq pname (test-result-alist runner)))) (if p (cdr p) default)))))))))
#(%module-handler srfi/64 %module-create current-module ((srfi/9) (srfi/35)) list-copy %do-imports ((test-begin . test-begin) (%test-approximate= . %test-approximate=) (%test-begin . %test-begin) (%test-on-test-begin . %test-on-test-begin) (%test-result-expected-value! . %test-result-expected-value!) (%test-result-actual-value! . %test-result-actual-value!) (%test-on-test-end . %test-on-test-end) (%test-report-result . %test-report-result) (%test-end . %test-end) (%test-as-specifier . %test-as-specifier) (%test-match-all . %test-match-all) (%test-runner-fail-list . %test-runner-fail-list) (%test-runner-fail-list! . %test-runner-fail-list!) (%test-should-execute . %test-should-execute) (%test-runner-skip-list . %test-runner-skip-list) (%test-runner-skip-list! . %test-runner-skip-list!) (%test-match-nth . %test-match-nth) (%test-match-any . %test-match-any) (%test-comp1body . %test-comp1body) (%test-evaluate-with-catch . %test-evaluate-with-catch) (%test-comp2 . %test-comp2) (%test-comp2body . %test-comp2body) (%test-error . %test-error) (test-end . test-end) (test-assert . test-assert) (test-eqv . test-eqv) (test-eq . test-eq) (test-equal . test-equal) (test-approximate . test-approximate) (test-assert . test-assert) (test-error . test-error) (test-apply . test-apply) (test-with-runner . test-with-runner) (test-match-nth . test-match-nth) (test-match-all . test-match-all) (test-match-any . test-match-any) (test-match-name . test-match-name) (test-skip . test-skip) (test-expect-fail . test-expect-fail) (test-read-eval-string . test-read-eval-string) (test-runner-group-path . test-runner-group-path) (test-group . test-group) (test-group-with-cleanup . test-group-with-cleanup) (test-result-ref . test-result-ref) (test-result-set! . test-result-set!) (test-result-clear . test-result-clear) (test-result-remove . test-result-remove) (test-result-kind . test-result-kind) (test-passed? . test-passed?) (test-log-to-file . test-log-to-file) (test-runner? . test-runner?) (test-runner-reset . test-runner-reset) (test-runner-null . test-runner-null) (test-runner-simple . test-runner-simple) (test-runner-current . test-runner-current) (test-runner-factory . test-runner-factory) (test-runner-get . test-runner-get) (test-runner-create . test-runner-create) (test-runner-test-name . test-runner-test-name) (test-runner-pass-count . test-runner-pass-count) (test-runner-pass-count! . test-runner-pass-count!) (test-runner-fail-count . test-runner-fail-count) (test-runner-fail-count! . test-runner-fail-count!) (test-runner-xpass-count . test-runner-xpass-count) (test-runner-xpass-count! . test-runner-xpass-count!) (test-runner-xfail-count . test-runner-xfail-count) (test-runner-xfail-count! . test-runner-xfail-count!) (test-runner-skip-count . test-runner-skip-count) (test-runner-skip-count! . test-runner-skip-count!) (test-runner-group-stack . test-runner-group-stack) (test-runner-group-stack! . test-runner-group-stack!) (test-runner-on-test-begin . test-runner-on-test-begin) (test-runner-on-test-begin! . test-runner-on-test-begin!) (test-runner-on-test-end . test-runner-on-test-end) (test-runner-on-test-end! . test-runner-on-test-end!) (test-runner-on-group-begin . test-runner-on-group-begin) (test-runner-on-group-begin! . test-runner-on-group-begin!) (test-runner-on-group-end . test-runner-on-group-end) (test-runner-on-group-end! . test-runner-on-group-end!) (test-runner-on-final . test-runner-on-final) (test-runner-on-final! . test-runner-on-final!) (test-runner-on-bad-count! . test-runner-on-bad-count!) (test-runner-on-bad-end-name . test-runner-on-bad-end-name) (test-runner-on-bad-end-name! . test-runner-on-bad-end-name!) (test-result-alist . test-result-alist) (test-result-alist! . test-result-alist!) (test-runner-aux-value . test-runner-aux-value) (test-runner-aux-value! . test-runner-aux-value!) (test-on-group-begin-simple . test-on-group-begin-simple) (test-on-group-end-simple . test-on-group-end-simple) (test-on-bad-count-simple . test-on-bad-count-simple) (test-on-bad-end-name-simple . test-on-bad-end-name-simple) (test-on-final-simple . test-on-final-simple) (test-on-test-end-simple . test-on-test-end-simple) (test-on-final-simple . test-on-final-simple)) %do-exports "<<FIXME>>" test-result-ref "<<FIXME>>" test-group-with-cleanup "<<FIXME>>" test-group "<<FIXME>>" test-expect-fail "<<FIXME>>" test-skip "<<FIXME>>" test-match-any "<<FIXME>>" test-match-all "<<FIXME>>" test-match-nth "<<FIXME>>" test-with-runner "<<FIXME>>" test-error "<<FIXME>>" test-approximate "<<FIXME>>" test-equal "<<FIXME>>" test-eq "<<FIXME>>" test-eqv "<<FIXME>>" test-assert "<<FIXME>>" test-begin "<<FIXME>>" test-end "test-runner" %test-runner-cookie %test-record-define (lambda args (%find-macro-clause '%test-record-define args '(%test-record-define) '(((%test-record-define tname alloc runner? (name index getter setter) ...) (begin (define (runner? obj) (and (vector? obj) (> (vector-length obj) 1) (eq? (vector-ref obj 0) %test-runner-cookie))) (define (alloc) (let ((runner (make-vector 23))) (vector-set! runner 0 %test-runner-cookie) runner)) (begin (define (getter runner) (vector-ref runner index)) ...) (begin (define (setter runner value) (vector-set! runner index value)) ...)))))) (%test-record-define) (((%test-record-define tname alloc runner? (name index getter setter) ...) (begin (define (runner? obj) (and (vector? obj) (> (vector-length obj) 1) (eq? (vector-ref obj 0) %test-runner-cookie))) (define (alloc) (let ((runner (make-vector 23))) (vector-set! runner 0 %test-runner-cookie) runner)) (begin (define (getter runner) (vector-ref runner index)) ...) (begin (define (setter runner value) (vector-set! runner index value)) ...)))) %find-macro-clause %make-syntax vector? vector-length test-runner? make-vector %test-runner-alloc test-runner-pass-count test-runner-fail-count test-runner-xpass-count test-runner-xfail-count test-runner-skip-count %test-runner-skip-list %test-runner-fail-list %test-runner-run-list %test-runner-skip-save %test-runner-fail-save test-runner-group-stack test-runner-on-test-begin test-runner-on-test-end test-runner-on-group-begin test-runner-on-group-end test-runner-on-final test-runner-on-bad-count test-runner-on-bad-end-name %test-runner-total-count %test-runner-count-list test-result-alist test-runner-aux-value test-runner-pass-count! test-runner-fail-count! test-runner-xpass-count! test-runner-xfail-count! test-runner-skip-count! %test-runner-skip-list! %test-runner-fail-list! %test-runner-run-list! %test-runner-skip-save! %test-runner-fail-save! test-runner-group-stack! test-runner-on-test-begin! test-runner-on-test-end! test-runner-on-group-begin! test-runner-on-group-end! test-runner-on-final! test-runner-on-bad-count! test-runner-on-bad-end-name! %test-runner-total-count! %test-runner-count-list! test-result-alist! test-runner-aux-value! test-runner-reset reverse test-runner-group-path %test-null-callback test-runner-null test-log-to-file test-on-group-begin-simple test-on-group-end-simple test-on-final-simple test-on-test-begin-simple test-on-test-end-simple test-on-bad-count-simple test-on-bad-end-name-simple test-runner-simple make-parameter test-runner-current test-runner-factory "test-runner not initialized - test-begin missing?" error test-runner-get %test-specifier-matches test-runner-create %test-any-specifier-matches result-kind skip test-result-set! xfail %test-should-execute %test-begin (lambda args (%find-macro-clause 'test-begin args '(test-begin) '(((test-begin suite-name) (%test-begin suite-name #f)) ((test-begin suite-name count) (%test-begin suite-name count))))) (test-begin) (((test-begin suite-name) (%test-begin suite-name #f)) ((test-begin suite-name count) (%test-begin suite-name count))) "%%%% Starting test " display string? ".log" string-append char-alphabetic? char-numeric? #\space char=? #\- #\+ #\_ #\. #\, string-copy string-length open-output-file "%%%% Starting test " newline "  (Writing full log to \"" "\")" output-port? "Group begin: " "Group end: " "*** Total number of tests was " " but should be " ". ***" "*** Discrepancy indicates testsuite error or exceptions. ***" %test-on-bad-count-write current-output-port %test-format-line "test-end " " does not match test-begin " %test-final-report1 "# of expected passes      " "# of expected failures    " "# of unexpected successes " "# of unexpected failures  " "# of skipped tests        " %test-final-report-simple source-file assq source-line "" ":" number->string ": " "" "test-end not in a group" equal? cdar caar %test-end (lambda args (%find-macro-clause 'test-group args '(test-group) '(((test-group suite-name . body) (let ((r (test-runner-current))) (test-result-alist! r (list (cons 'test-name suite-name))) (if (%test-should-execute r) (dynamic-wind (lambda () (test-begin suite-name)) (lambda () . body) (lambda () (test-end suite-name))))))))) (test-group) (((test-group suite-name . body) (let ((r (test-runner-current))) (test-result-alist! r (list (cons 'test-name suite-name))) (if (%test-should-execute r) (dynamic-wind (lambda () (test-begin suite-name)) (lambda () . body) (lambda () (test-end suite-name))))))) (lambda args (%find-macro-clause 'test-group-with-cleanup args '(test-group-with-cleanup) '(((test-group-with-cleanup suite-name form cleanup-form) (test-group suite-name (dynamic-wind (lambda () #f) (lambda () form) (lambda () cleanup-form)))) ((test-group-with-cleanup suite-name cleanup-form) (test-group-with-cleanup suite-name #f cleanup-form)) ((test-group-with-cleanup suite-name form1 form2 form3 . rest) (test-group-with-cleanup suite-name (begin form1 form2) form3 . rest))))) (test-group-with-cleanup) (((test-group-with-cleanup suite-name form cleanup-form) (test-group suite-name (dynamic-wind (lambda () #f) (lambda () form) (lambda () cleanup-form)))) ((test-group-with-cleanup suite-name cleanup-form) (test-group-with-cleanup suite-name #f cleanup-form)) ((test-group-with-cleanup suite-name form1 form2 form3 . rest) (test-group-with-cleanup suite-name (begin form1 form2) form3 . rest))) source-form test-name "Test begin:" %test-write-result1 (lambda args (%find-macro-clause 'test-result-ref args '(test-result-ref) '(((test-result-ref runner pname) (test-result-ref runner pname #f)) ((test-result-ref runner pname default) (let ((p (assq pname (test-result-alist runner)))) (if p (cdr p) default)))))) (test-result-ref) (((test-result-ref runner pname) (test-result-ref runner pname #f)) ((test-result-ref runner pname default) (let ((p (assq pname (test-result-alist runner)))) (if p (cdr p) default)))) (fail xpass) memq ":" ": " xpass "XPASS" "FAIL" " " "Test end:" pair? (test-name source-file source-line source-form) "  " ": " write set-cdr! actual-value %test-result-actual-value! expected-value %test-result-expected-value! test-result-clear test-result-remove test-result-kind (pass xpass) test-passed? pass fail %test-report-result %test-evaluate-with-catch (lambda args (%find-macro-clause '%test-evaluate-with-catch args '(%test-evaluate-with-catch) '(((%test-evaluate-with-catch test-expression) (guard (err (else #f)) test-expression))))) (%test-evaluate-with-catch) (((%test-evaluate-with-catch test-expression) (guard (err (else #f)) test-expression))) %test-source-line2 %test-on-test-begin %test-on-test-end "" test-runner-test-name %test-comp2body (lambda args (%find-macro-clause '%test-comp2body args '(%test-comp2body) '(((%test-comp2body r comp expected expr) (let () (if (%test-on-test-begin r) (let ((exp expected)) (%test-result-expected-value! r exp) (let ((res (%test-evaluate-with-catch expr))) (%test-result-actual-value! r res) (%test-on-test-end r (comp exp res))))) (%test-report-result)))))) (%test-comp2body) (((%test-comp2body r comp expected expr) (let () (if (%test-on-test-begin r) (let ((exp expected)) (%test-result-expected-value! r exp) (let ((res (%test-evaluate-with-catch expr))) (%test-result-actual-value! r res) (%test-on-test-end r (comp exp res))))) (%test-report-result)))) real-part imag-part %test-approximate= %test-comp1body (lambda args (%find-macro-clause '%test-comp1body args '(%test-comp1body) '(((%test-comp1body r expr) (let () (if (%test-on-test-begin r) (let () (let ((res (%test-evaluate-with-catch expr))) (%test-result-actual-value! r res) (%test-on-test-end r res)))) (%test-report-result)))))) (%test-comp1body) (((%test-comp1body r expr) (let () (if (%test-on-test-begin r) (let () (let ((res (%test-evaluate-with-catch expr))) (%test-result-actual-value! r res) (%test-on-test-end r res)))) (%test-report-result)))) (lambda args (%find-macro-clause 'test-end args '(test-end) '(((test-end) (%test-end #f '())) ((test-end suite-name) (%test-end suite-name '()))))) (test-end) (((test-end) (%test-end #f '())) ((test-end suite-name) (%test-end suite-name '()))) (lambda args (%find-macro-clause 'test-assert args '(test-assert) '(((test-assert tname test-expression) (let* ((r (test-runner-get)) (name tname)) (test-result-alist! r '((test-name . tname))) (%test-comp1body r test-expression))) ((test-assert test-expression) (let* ((r (test-runner-get))) (test-result-alist! r '()) (%test-comp1body r test-expression)))))) (test-assert) (((test-assert tname test-expression) (let* ((r (test-runner-get)) (name tname)) (test-result-alist! r '((test-name . tname))) (%test-comp1body r test-expression))) ((test-assert test-expression) (let* ((r (test-runner-get))) (test-result-alist! r '()) (%test-comp1body r test-expression)))) %test-comp2 (lambda args (%find-macro-clause '%test-comp2 args '(%test-comp2) '(((%test-comp2 comp tname expected expr) (let* ((r (test-runner-get)) (name tname)) (test-result-alist! r (list (cons 'test-name tname))) (%test-comp2body r comp expected expr))) ((%test-comp2 comp expected expr) (let* ((r (test-runner-get))) (test-result-alist! r '()) (%test-comp2body r comp expected expr)))))) (%test-comp2) (((%test-comp2 comp tname expected expr) (let* ((r (test-runner-get)) (name tname)) (test-result-alist! r (list (cons 'test-name tname))) (%test-comp2body r comp expected expr))) ((%test-comp2 comp expected expr) (let* ((r (test-runner-get))) (test-result-alist! r '()) (%test-comp2body r comp expected expr)))) (lambda args (%find-macro-clause 'test-equal args '(test-equal) '(((test-equal . rest) (%test-comp2 equal? . rest))))) (test-equal) (((test-equal . rest) (%test-comp2 equal? . rest))) (lambda args (%find-macro-clause 'test-eqv args '(test-eqv) '(((test-eqv . rest) (%test-comp2 eqv? . rest))))) (test-eqv) (((test-eqv . rest) (%test-comp2 eqv? . rest))) (lambda args (%find-macro-clause 'test-eq args '(test-eq) '(((test-eq . rest) (%test-comp2 eq? . rest))))) (test-eq) (((test-eq . rest) (%test-comp2 eq? . rest))) (lambda args (%find-macro-clause 'test-approximate args '(test-approximate) '(((test-approximate tname expected expr error) (%test-comp2 (%test-approximate= error) tname expected expr)) ((test-approximate expected expr error) (%test-comp2 (%test-approximate= error) expected expr))))) (test-approximate) (((test-approximate tname expected expr error) (%test-comp2 (%test-approximate= error) tname expected expr)) ((test-approximate expected expr error) (%test-comp2 (%test-approximate= error) expected expr))) %test-error (lambda args (%find-macro-clause '%test-error args '(%test-error) '(((%test-error r etype expr) (%test-comp1body r (guard (ex ((condition-type? etype) (and (condition? ex) (condition-has-type? ex etype))) ((procedure? etype) (etype ex)) ((equal? etype #t) #t) (else #t)) expr #f)))))) (%test-error) (((%test-error r etype expr) (%test-comp1body r (guard (ex ((condition-type? etype) (and (condition? ex) (condition-has-type? ex etype))) ((procedure? etype) (etype ex)) ((equal? etype #t) #t) (else #t)) expr #f)))) (lambda args (%find-macro-clause 'test-error args '(test-error) '(((test-error name etype expr) (let ((r (test-runner-get))) (test-result-alist! r `((test-name unquote name))) (%test-error r etype expr))) ((test-error etype expr) (let ((r (test-runner-get))) (test-result-alist! r '()) (%test-error r etype expr))) ((test-error expr) (let ((r (test-runner-get))) (test-result-alist! r '()) (%test-error r #t expr)))))) (test-error) (((test-error name etype expr) (let ((r (test-runner-get))) (test-result-alist! r `((test-name unquote name))) (%test-error r etype expr))) ((test-error etype expr) (let ((r (test-runner-get))) (test-result-alist! r '()) (%test-error r etype expr))) ((test-error expr) (let ((r (test-runner-get))) (test-result-alist! r '()) (%test-error r #t expr)))) (lambda args (%find-macro-clause 'test-with-runner args '(test-with-runner) '(((test-with-runner runner form ...) (let ((saved-runner (test-runner-current))) (dynamic-wind (lambda () (test-runner-current runner)) (lambda () form ...) (lambda () (test-runner-current saved-runner)))))))) (test-with-runner) (((test-with-runner runner form ...) (let ((saved-runner (test-runner-current))) (dynamic-wind (lambda () (test-runner-current runner)) (lambda () form ...) (lambda () (test-runner-current saved-runner)))))) test-apply apply dynamic-wind %test-match-nth (lambda args (%find-macro-clause 'test-match-nth args '(test-match-nth) '(((test-match-nth n) (test-match-nth n 1)) ((test-match-nth n count) (%test-match-nth n count))))) (test-match-nth) (((test-match-nth n) (test-match-nth n 1)) ((test-match-nth n count) (%test-match-nth n count))) %test-match-all (lambda args (%find-macro-clause 'test-match-all args '(test-match-all) '(((test-match-all pred ...) (%test-match-all (%test-as-specifier pred) ...))))) (test-match-all) (((test-match-all pred ...) (%test-match-all (%test-as-specifier pred) ...))) %test-match-any (lambda args (%find-macro-clause 'test-match-any args '(test-match-any) '(((test-match-any pred ...) (%test-match-any (%test-as-specifier pred) ...))))) (test-match-any) (((test-match-any pred ...) (%test-match-any (%test-as-specifier pred) ...))) procedure? integer? test-match-name "not a valid test specifier" %test-as-specifier (lambda args (%find-macro-clause 'test-skip args '(test-skip) '(((test-skip pred ...) (let ((runner (test-runner-get))) (%test-runner-skip-list! runner (cons (test-match-all (%test-as-specifier pred) ...) (%test-runner-skip-list runner)))))))) (test-skip) (((test-skip pred ...) (let ((runner (test-runner-get))) (%test-runner-skip-list! runner (cons (test-match-all (%test-as-specifier pred) ...) (%test-runner-skip-list runner)))))) (lambda args (%find-macro-clause 'test-expect-fail args '(test-expect-fail) '(((test-expect-fail pred ...) (let ((runner (test-runner-get))) (%test-runner-fail-list! runner (cons (test-match-all (%test-as-specifier pred) ...) (%test-runner-fail-list runner)))))))) (test-expect-fail) (((test-expect-fail pred ...) (let ((runner (test-runner-get))) (%test-runner-fail-list! runner (cons (test-match-all (%test-as-specifier pred) ...) (%test-runner-fail-list runner)))))) open-input-string read read-char eof-object? eval "(not at eof)" test-read-eval-string %module-restore values "srfi/64" provide)
4358
  
   -ú % U  V   J % % V    n U  V   ! M V   % % V    ! U  V   	 	  
 	    	    	    	    	    	    	    	    	    	    	     	 !  " 	 #  $ 	 %  & 	 '  ( 	 )  * U + ?   , % U - U . # ÿÿ % U - e U / U 0 l 1  $ ! U  V 2   - #   % e V 3    % e V 4  !  _  e  A o , E $  $  5 #    % % T  V 6  ! +  e Q 
 , B  $  7 #   e  A $  8 #   e   A $  9 #   e   A $  : #   e   A $  ; #   e   A $  < #   e   A $  = #   e   A $  > #   e   A $  ? #   e  	 A $  @ #   e  
 A $  A #   e   A $  B #   e   A $  C #   e   A $  D #   e   A $  E #   e   A $  F #   e   A $  G #   e   A $  H #   e   A $  I #   e   A $  J #   e   A $  K #   e   A $  L #   e   A $  M #   f R  B $  N #   f T   B $  O #   f T   B $  P #   f T   B $  Q #   f T   B $  R #   f T   B $  S #   f T   B $  T #   f T   B $  U #   f T 	  B $  V #   f T 
  B $  W #   f T   B $  X #   f T   B $  Y #   f T   B $  Z #   f T   B $  [ #   f T   B $  \ #   f T   B $  ] #   f T   B $  ^ #   f T   B $  _ #   f T   B $  ` #   f T   B $  a #   f T   B $  b #   f T   B $  c # V  % e O V b  % e Q V N  % e Q V O  % e Q V P  % e Q V Q  % e Q V R  % e Q V `  % e O V a  % e N V U  % e O V S  % e O V T  % e O V V  % e O V W  % e O l X  $  d #   % % e V B  s e  $  f #    $  g # N   % % V 7   ! +  % e V d  % e #    $ q [  % e j g V \  % e j g V ]  % e j g V Y  % e j g V Z  % e #    $ q ^  % e #   % M  '  $ q _   $  h   i # A   % % V 7   ! +  % e V d  % e j j V [  % e j k V \  % e j l V ]  % e j m V Y  % e j n V Z  % e j o V ^  % e j p V _   $  q % M V r   s % j q V r   t #    % % V s   ! +     % U u l v  $  $  w #   % e  '  $  x # 	   % % V t   '   $  y # =  % M +  % u % M )  % # "   <     $ %  = ! u  V x          %  > !   '  $ ! )     ,  , '  $  z # Y  % % e V ?  ! +  e  F  
 % e u  V z     @   % % u  V =  ! u  V z       % u  U { U | V }   $ % % u  V >  ! u  V z    % u  U { U ~ V }  	 ~    $   # i  % V s    
 % % V y   q s     % % V s   ! +  % e u u  % e V E  &  % e % e V =  n e V @  ; q V  % e % e V >  n e V A  ; q W  % e % e V J  !   ; n e V K  ; q a  % e u % e V B  ; s X  $  € % U ( U  # ÿÿ % U ( e U ‚ U ƒ l 1  $ ! U  V 2   ( #(  % g V B  <  õ % U „ V …  % f V …  
 i  ß (  % j i V †    
 i   % u U ‡ V ˆ   # M  % e V ‰   > % e V Š   7 % e U ‹ V Œ   . % e U  V Œ   % % e U  V Œ    % e U  V Œ    % e U  V Œ   
 % e U ‘ V Œ        $ 	  $  % % e V ’  n e V “  ! )  % M )  % #    e   ^   $ u e % u  C !  &  D %  9 !   '  $ ! )     , % Q  &  , ,  % g V ”   % U • h V …  % u h V …  % h V –  % u h V c  % U — V …  % g V …  % U ˜ V …  ,    % V –      % % g V M  ! )  % e V ™    % U š e V …  % u e V …  % e V –     ,  $  j # 0  % % e V M  ! )  % e V ™    % U › e V …  % % u  V B  = ! e V …  % e V –     ,  $  k # 4  % U œ e V …  % g e V …  % U  e V …  % f e V …  % U  e V …  % e V –  % U Ÿ e V …  % e l –  $    # *  % g f e % V ¡   q    % % g V M  ! +  % e V ™    % u u u  e l    $  $  o #   % % % g V ¢  ! U £ f U ¤ e V ˆ  ! +  % e l v  $  p #   g  _  % f e V …  % g e V …  % e l –  $  $  ¥ # C  % % f V 8  ! U ¦ e V ¥  % % f V ;  ! U § e V ¥  % % f V :  ! U ¨ e V ¥  % % f V 9  ! U © e V ¥  % % f V <  ! U ª e l ¥  $  « # $  % e % V ¡   q «  % % e V M  ! +  % e V ™    % u  e l «  $  $  l # ;  *  % u  V L   % U ¬ e V ­   % U ® e V ­       >   	 ¯     % h U ° %  > q ±  ! U ² l ˆ  $ 	 ³ $  ¢ # ÿ  *  % V w    % e V B   % e V ¢   % e u  V b   <   % % g U ´ V ˆ  ! )  % e V v  ,       % u  = q µ  @      % e u  = n e V I  &     *  % u  V K   % e V ¶   % e V ·   % u  V J  !  1     f  X      % u  h f % u  V H  &     % u  % u  V F  &  % u  % u  V B  > q X  % u  % u  V @  = q S  % u  % u  V @  > q V  % u  % u  V A  = q T  % u  % u  V A  > q W  % u   > q a  % u  V B  <   % u  % u  V G  &  % M l s  $  $  ¸ % U  U ¹ # ÿÿ % U  e U º U » l 1  $ ! U  V 2    % U  U ¼ # ÿÿ % U  e U ½ U ¾ l 1  $ ! U  V 2    #   % % e V M  ! +  % e V ™   l *  % u  V L   % U ¬ e V ­   % U ® e V ­   % U ¿ e V ­   % U À e V ­   % U Á u  V …  % u  V –    	 % i u  V Â       	 % f u  V Â       	 % g u  V Â        % h u  l Â  $  $ $  $  m % U 
 U Ã # ÿÿ % U 
 e U Ä U Å l 1  $ ! U  V 2   
 #  % % e V M  n % U { % e V L  q ­  ! )      >    , ! +  % e U Æ V Ç   z (  % u  V L   % U ¬ e V ­   % U ® e V ­   % U À e V ­           &    %  > q …     % U È V …     %  > q …     % U É V …     % u  	 Ê b  	 Ë   	 Ì q …     % U Í V …  %  > q …     % V –   ,    % f V ™   V % U Î f V …  % f V –  % % u  V L  n M )  % # 0  % e V Ï   & %  = ! +  %  = ! U Ğ V Ç   	 % e u V Â     %   > !   '  $ $  $ ! )     ,  , '  $  $  n # %  % U Ñ e V …  %  = ! e V …  % U Ò e V …  %  > ! e V Ó  % e l –  $  Â # ,  *  % u V L   % u e V ­      % f u  l Ô  $ % u u   ; !  ; s b  $  } # 
  % f U Õ e l }  $  Ö # 
  % f U × e l }  $  Ø #   % e O l b  $  Ù # G  *  % u V L   % u  e V ­     0 % u % e % M )  % #   e  b   > $  = n  > !   &  ; $ ! )     ,  , &  s b  $  $  Ú # +ÿÿ % % e V Ï     =   % V s   ! +  % % U { % e V L  q ­  ! +      > $  $  Û # 4ÿÿ % % e V Ï     =   % V w   ! +  % % % U { % e V L  q ­  ! )      >    , ! U Ü l Ç  $  İ # v   *  % V w    % e V Û   f 	 Ş c  % e % e V 8  9 q N   A f 	 ß c  % e % e V 9  9 q O   / f 	 Ê c  % e % e V :  9 q P    f 	 ~ c  % e % e V ;  9 q Q    % e % e V <  9 q R  % e % e V J  9 q `  % e % e V D  '  $  à % U á U â # ÿÿ % U á e U ã U ä l 1  $ ! U  V 2   á #    $  å # +  % e V   % e % e V C  &  U | % % U { % e V L  q ­  ! )      >    , Y $  æ # :  % f U { % % U { % f V L  q ­  ! )      >    , ! 	 ~ b     	 Ê   	 ~  	    	 Ş   	 ß s }  $  ç #   % % U À % e V L  q ­  ! +      > $ 	 è $  é % U ê U ë # ÿÿ % U ê e U ì U í l 1  $ ! U  V 2   ê # ;  # 7  % % f V î  n f V ï  n e V î  n e V ï  ! +  h f   1 ^  g e   1 ^  h f   0 `  g e   0 7 $  $ $  ğ % U ñ U ò # ÿÿ % U ñ e U ó U ô l 1  $ ! U  V 2   ñ % U * U õ # ÿÿ % U * e U ö U ÷ l 1  $ ! U  V 2   * % U & U ø # ÿÿ % U & e U ù U ú l 1  $ ! U  V 2   & % U û U ü # ÿÿ % U û e U ı U ş l 1  $ ! U  V 2   û % U   U ÿ # ÿÿ % U   e U  U l 1  $ ! U  V 2     % U $ U # ÿÿ % U $ e U U l 1  $ ! U  V 2   $ % U " U # ÿÿ % U " e U U l 1  $ ! U  V 2   " % U  U # ÿÿ % U  e U	 U
 l 1  $ ! U  V 2    % U U # ÿÿ % U e U U l 1  $ ! U  V 2   % U  U # ÿÿ % U  e U U l 1  $ ! U  V 2    % U  U # ÿÿ % U  e U U l 1  $ ! U  V 2    # Ìÿş % f V 5   0 % % V s   ! +  % #    % u l s  $ ! # 
   % j u  l  $ ! #    % u  l s  $ s  $ $ % % V s   ! +    D % % e V ?  ! +    <   % u  % e V e  q U  %  '   $ % u  e  b  u ?    u  ; q U  % j u  V  % u  e l U  $ $ % % V y   ! +  % % V s   ! )  % #    % u  l s  $ ! #    % j u u  l  $ ! #    % u  l s  $ q  , % e % e V G  '  $ $ $  #   % Q +  #     9   u   ^ 	 u  u   0 5 $  $ $  % U  U # ÿÿ % U  e U U l 1  $ ! U  V 2    # ?ÿÿ # ;  % N +  % u  % M )  % #     <     $ % u   = &          %  > !   '  $ ! )     ,  , '  $ $  % U  U # ÿÿ % U  e U U l 1  $ ! U  V 2    # ?ÿÿ # ;  % M +  % u  % M )  % #     <     $ % u   = &          %  > !   '  $ ! )     ,  , '  $ $   % U  U! # ÿÿ % U  e U" U# l 1  $ ! U  V 2    # .  % e V$     $ % e V%    % R e l    % e V †    % e l&    % U' l v  $ ( % U  U) # ÿÿ % U  e U* U+ l 1  $ ! U  V 2    % U  U, # ÿÿ % U  e U- U. l 1  $ ! U  V 2    #   #   % u  % e V é  s µ  $ $ & # (  *  % u  V/   % e V0   % % e V1  q2    % f l3  $ % U4 l v  $ 5 % V6   J % S U  V7  . % U8 V9  /
