#!/usr/bin/env stklos
; A -*- Scheme -*- generated file *DO NOT EDIT**
STklos (#:version "1.70" #:globals ($hash-keyword $perfect-hash-table-lookup $undefined $process-keys $opt-key $req-key define* lambda*) #:macros (((define* . define*) srfi/89 (lambda (pattern . body) (if (pair? pattern) `(define ,(car pattern) (lambda* ,(cdr pattern) ,@body)) `(define ,pattern ,@body)))) ((lambda* . lambda*) srfi/89 (lambda (formals . body) (define (parse-formals formals) (define (variable? x) (symbol? x)) (define (required-positional? x) (variable? x)) (define (optional-positional? x) (and (pair? x) (pair? (cdr x)) (null? (cddr x)) (variable? (car x)))) (define (required-named? x) (and (pair? x) (pair? (cdr x)) (null? (cddr x)) (keyword? (car x)) (variable? (cadr x)))) (define (optional-named? x) (and (pair? x) (pair? (cdr x)) (pair? (cddr x)) (null? (cdddr x)) (keyword? (car x)) (variable? (cadr x)))) (define (named? x) (or (required-named? x) (optional-named? x))) (define (duplicates? lst) (cond ((null? lst) #f) ((memq (car lst) (cdr lst)) #t) (else (duplicates? (cdr lst))))) (define (parse-positional-section lst cont) (let loop1 ((lst lst) (rev-reqs '())) (if (and (pair? lst) (required-positional? (car lst))) (loop1 (cdr lst) (cons (car lst) rev-reqs)) (let loop2 ((lst lst) (rev-opts '())) (if (and (pair? lst) (optional-positional? (car lst))) (loop2 (cdr lst) (cons (car lst) rev-opts)) (cont lst (cons (reverse rev-reqs) (reverse rev-opts)))))))) (define (parse-named-section lst cont) (let loop ((lst lst) (rev-named '())) (if (and (pair? lst) (named? (car lst))) (loop (cdr lst) (cons (car lst) rev-named)) (cont lst (reverse rev-named))))) (define (parse-rest lst positional-before-named? positional-reqs/opts named) (if (null? lst) (parse-end positional-before-named? positional-reqs/opts named #f) (if (variable? lst) (parse-end positional-before-named? positional-reqs/opts named lst) (error "syntax error in formal parameter list")))) (define (parse-end positional-before-named? positional-reqs/opts named rest) (let ((positional-reqs (car positional-reqs/opts)) (positional-opts (cdr positional-reqs/opts))) (let ((vars (append positional-reqs (map car positional-opts) (map cadr named) (if rest (list rest) '()))) (keys (map car named))) (cond ((duplicates? vars) (error "duplicate variable in formal parameter list")) ((duplicates? keys) (error "duplicate keyword in formal parameter list")) (else (list positional-before-named? positional-reqs positional-opts named rest)))))) (define (parse lst) (if (and (pair? lst) (named? (car lst))) (parse-named-section lst (lambda (lst named) (parse-positional-section lst (lambda (lst positional-reqs/opts) (parse-rest lst #f positional-reqs/opts named))))) (parse-positional-section lst (lambda (lst positional-reqs/opts) (parse-named-section lst (lambda (lst named) (parse-rest lst #t positional-reqs/opts named))))))) (parse formals)) (define (expand-lambda* formals body) (define (range lo hi) (if (< lo hi) (cons lo (range (+ lo 1) hi)) '())) (define (expand positional-before-named? positional-reqs positional-opts named rest) (if (and (null? positional-opts) (null? named)) `(lambda ,(append positional-reqs (or rest '())) ,@body) (let () (define utility-fns `(,@(if (or positional-before-named? (null? positional-reqs)) `() `(($req (lambda () (if (pair? $args) (let ((arg (car $args))) (set! $args (cdr $args)) arg) (error "too few actual parameters")))))) ,@(if (null? positional-opts) `() `(($opt (lambda (default) (if (pair? $args) (let ((arg (car $args))) (set! $args (cdr $args)) arg) (default)))))))) (define positional-bindings `(,@(if positional-before-named? `() (map (lambda (x) `(,x ($req))) positional-reqs)) ,@(map (lambda (x) `(,(car x) ($opt (lambda () ,(cadr x))))) positional-opts))) (define named-bindings (if (null? named) `() `(($key-values (vector ,@(map (lambda (x) `$undefined) named))) ($args ($process-keys $args ',(make-perfect-hash-table (map (lambda (x i) (cons (car x) i)) named (range 0 (length named)))) $key-values)) ,@(map (lambda (x i) `(,(cadr x) ,(if (null? (cddr x)) `($req-key $key-values ,i) `($opt-key $key-values ,i (lambda () ,(caddr x)))))) named (range 0 (length named)))))) (define rest-binding (if (not rest) `(($args (or (null? $args) (error "too many actual parameters")))) `((,rest $args)))) (let ((bindings (append (if positional-before-named? (append utility-fns positional-bindings named-bindings) (append named-bindings utility-fns positional-bindings)) rest-binding))) `(lambda ,(append (if positional-before-named? positional-reqs '()) '$args) (let* ,bindings ,@body)))))) (apply expand (parse-formals formals))) (define (make-perfect-hash-table alist) (let loop1 ((n (length alist))) (let ((v (make-vector (* 2 n) #f))) (let loop2 ((lst alist)) (if (pair? lst) (let* ((key-val (car lst)) (key (car key-val))) (let ((x (* 2 ($hash-keyword key n)))) (if (vector-ref v x) (loop1 (+ n 1)) (begin (vector-set! v x key) (vector-set! v (+ x 1) (cdr key-val)) (loop2 (cdr lst)))))) v))))) (define ($hash-keyword key n) (let ((str (keyword->string key))) (let loop ((h 0) (i 0)) (if (< i (string-length str)) (loop (modulo (+ (* h 65536) (char->integer (string-ref str i))) n) (+ i 1)) h)))) (expand-lambda* formals body)))))
#(%module-handler srfi/89 %module-create current-module (($hash-keyword . $hash-keyword) ($perfect-hash-table-lookup . $perfect-hash-table-lookup) ($undefined . $undefined) ($process-keys . $process-keys) ($opt-key . $opt-key) ($req-key . $req-key)) %do-exports ((define* . define*) (lambda* . lambda*)) define* (lambda (pattern . body) (if (pair? pattern) `(define ,(car pattern) (lambda* ,(cdr pattern) ,@body)) `(define ,pattern ,@body))) pair? define lambda* %make-syntax (lambda (formals . body) (define (parse-formals formals) (define (variable? x) (symbol? x)) (define (required-positional? x) (variable? x)) (define (optional-positional? x) (and (pair? x) (pair? (cdr x)) (null? (cddr x)) (variable? (car x)))) (define (required-named? x) (and (pair? x) (pair? (cdr x)) (null? (cddr x)) (keyword? (car x)) (variable? (cadr x)))) (define (optional-named? x) (and (pair? x) (pair? (cdr x)) (pair? (cddr x)) (null? (cdddr x)) (keyword? (car x)) (variable? (cadr x)))) (define (named? x) (or (required-named? x) (optional-named? x))) (define (duplicates? lst) (cond ((null? lst) #f) ((memq (car lst) (cdr lst)) #t) (else (duplicates? (cdr lst))))) (define (parse-positional-section lst cont) (let loop1 ((lst lst) (rev-reqs '())) (if (and (pair? lst) (required-positional? (car lst))) (loop1 (cdr lst) (cons (car lst) rev-reqs)) (let loop2 ((lst lst) (rev-opts '())) (if (and (pair? lst) (optional-positional? (car lst))) (loop2 (cdr lst) (cons (car lst) rev-opts)) (cont lst (cons (reverse rev-reqs) (reverse rev-opts)))))))) (define (parse-named-section lst cont) (let loop ((lst lst) (rev-named '())) (if (and (pair? lst) (named? (car lst))) (loop (cdr lst) (cons (car lst) rev-named)) (cont lst (reverse rev-named))))) (define (parse-rest lst positional-before-named? positional-reqs/opts named) (if (null? lst) (parse-end positional-before-named? positional-reqs/opts named #f) (if (variable? lst) (parse-end positional-before-named? positional-reqs/opts named lst) (error "syntax error in formal parameter list")))) (define (parse-end positional-before-named? positional-reqs/opts named rest) (let ((positional-reqs (car positional-reqs/opts)) (positional-opts (cdr positional-reqs/opts))) (let ((vars (append positional-reqs (map car positional-opts) (map cadr named) (if rest (list rest) '()))) (keys (map car named))) (cond ((duplicates? vars) (error "duplicate variable in formal parameter list")) ((duplicates? keys) (error "duplicate keyword in formal parameter list")) (else (list positional-before-named? positional-reqs positional-opts named rest)))))) (define (parse lst) (if (and (pair? lst) (named? (car lst))) (parse-named-section lst (lambda (lst named) (parse-positional-section lst (lambda (lst positional-reqs/opts) (parse-rest lst #f positional-reqs/opts named))))) (parse-positional-section lst (lambda (lst positional-reqs/opts) (parse-named-section lst (lambda (lst named) (parse-rest lst #t positional-reqs/opts named))))))) (parse formals)) (define (expand-lambda* formals body) (define (range lo hi) (if (< lo hi) (cons lo (range (+ lo 1) hi)) '())) (define (expand positional-before-named? positional-reqs positional-opts named rest) (if (and (null? positional-opts) (null? named)) `(lambda ,(append positional-reqs (or rest '())) ,@body) (let () (define utility-fns `(,@(if (or positional-before-named? (null? positional-reqs)) `() `(($req (lambda () (if (pair? $args) (let ((arg (car $args))) (set! $args (cdr $args)) arg) (error "too few actual parameters")))))) ,@(if (null? positional-opts) `() `(($opt (lambda (default) (if (pair? $args) (let ((arg (car $args))) (set! $args (cdr $args)) arg) (default)))))))) (define positional-bindings `(,@(if positional-before-named? `() (map (lambda (x) `(,x ($req))) positional-reqs)) ,@(map (lambda (x) `(,(car x) ($opt (lambda () ,(cadr x))))) positional-opts))) (define named-bindings (if (null? named) `() `(($key-values (vector ,@(map (lambda (x) `$undefined) named))) ($args ($process-keys $args ',(make-perfect-hash-table (map (lambda (x i) (cons (car x) i)) named (range 0 (length named)))) $key-values)) ,@(map (lambda (x i) `(,(cadr x) ,(if (null? (cddr x)) `($req-key $key-values ,i) `($opt-key $key-values ,i (lambda () ,(caddr x)))))) named (range 0 (length named)))))) (define rest-binding (if (not rest) `(($args (or (null? $args) (error "too many actual parameters")))) `((,rest $args)))) (let ((bindings (append (if positional-before-named? (append utility-fns positional-bindings named-bindings) (append named-bindings utility-fns positional-bindings)) rest-binding))) `(lambda ,(append (if positional-before-named? positional-reqs '()) '$args) (let* ,bindings ,@body)))))) (apply expand (parse-formals formals))) (define (make-perfect-hash-table alist) (let loop1 ((n (length alist))) (let ((v (make-vector (* 2 n) #f))) (let loop2 ((lst alist)) (if (pair? lst) (let* ((key-val (car lst)) (key (car key-val))) (let ((x (* 2 ($hash-keyword key n)))) (if (vector-ref v x) (loop1 (+ n 1)) (begin (vector-set! v x key) (vector-set! v (+ x 1) (cdr key-val)) (loop2 (cdr lst)))))) v))))) (define ($hash-keyword key n) (let ((str (keyword->string key))) (let loop ((h 0) (i 0)) (if (< i (string-length str)) (loop (modulo (+ (* h 65536) (char->integer (string-ref str i))) n) (+ i 1)) h)))) (expand-lambda* formals body)) symbol? cddr keyword? cadr cdddr memq reverse "syntax error in formal parameter list" error car map append "duplicate variable in formal parameter list" "duplicate keyword in formal parameter list" lambda $req if $args let arg set! cdr "too few actual parameters" $opt default $key-values vector $undefined $process-keys quote length $req-key $opt-key caddr or null? "too many actual parameters" let* apply make-vector keyword->string string-length 65536 char->integer modulo $hash-keyword vector-length quotient $perfect-hash-table-lookup undefined "a required named parameter was not provided" "unknown parameter keyword" "a value was expected after keyword" "duplicate parameter" %module-restore values "srfi/89" provide)
2006
  
   -Ê % U  V   J % % V    ! U  V   % % V    ! U  V   % U  U  # "ÿþ % f V 	    U 
  = ! U   > !  ; ; !  ; ; ; $ U 
 f  ; ; $ ! U  V     % U  U  #&ÿþ % M M M M +  #¿  % M M M M M M M M M M M M +  #   % e l   $   #   % e  '  $  
 # #  % e V 	    %  > q 	    % e V   <  	 %  = !  '  $  $  	 # .  % e V 	   $ %  > q 	    % e V   <   %  = q     % % e V   !  '  $  $   # 9  % e V 	   / %  > q 	   ' % % e V   q 	    % e V   <   %  = q     % % e V   !  '  $  $   #   % e  &   	 % e  '     $   #    <    $ %  = !  > q        %  > !  '  $   # ‰  % f O % M )  % # r  % f V 	   
 %  = ! 
 &       %  > !  = !  ; !   '  $ % f O % M )  % # 8  % f V 	   
 %  = ! 	 &       %  > !  = !  ; !   '  $ % f % u  V   n e V   ; !   '  $ ! )     ,  , '  $ ! )     ,  , '  $  # H  % f O % M )  % # 1  % f V 	   
 %  = !  &       %  > !  = !  ; !   '  $ % f % e V   !   '  $ ! )     ,  , '  $  # )   <  
 % g f e M  '  $ % h  &    % g f e h  '    % U  l   $  # b  %  = !  > ! +  % % f % j  e V   n j  u V   !     u  ?     q   n j  u V   ! +  % f  &    % U  l   $ % e  &    % U  l     u u u  u u  ?  $  # W  % e V 	   
 %  = !  &      ! % e #   % f #   % f M e u   '  $ !  '  $ !  '  $ % e #   % f #   % f N u  e  '  $ !  '  $ !  '  $  % u   '  $  #v  % M M +  #   f  a  f %  9 ! e  &  ; $  $  #J   <    <      U  % h        q   !   ; ; $ % M M M M +  %     <        T U  U  O U  U 	 U   ; ; ! U   U ! U  U   ; ; !  ; ; !  ; ! U " U  U # U   ; ; !  ; ; ; ! U !  ; ; ; ; ! U  U $  ; ; !  ; ; ; ; !  ; ; ; !  ; ; !  ; !  <     U U % U  U &  ; ! U  U 	 U   ; ; ! U   U ! U  U   ; ; !  ; ; !  ; ! U " U  U # U   ; ; !  ; ; ; ! U !  ; ; ; ; ! U &  ; !  ; ; ; ; !  ; ; ; !  ; ; !  ; q    %       % #   e U   ; !  ; ; $ ! u V   n #    = ! U % U  O % e V   !  ; ; ; !  ; ; !  ; ; $ ! u V   q     <       U ' U ( % #   	 ) $ ! u V   ; !  ; ; ! U  U * U  U + % % #    = !  ; $ ! u % Q % u V ,  !  &  q   !  &  !  ; ; ! U '  ; ; ; ; !  ; ; n # 6  % f V   n f V   <   U - U ' e  ; ; ;   U . U ' e U  O % f V /  !  ; ; ; !  ; ; ; ; !  ; ; $ ! u % Q % u V ,  !  &  q   ; ;     ! U  U 0 U 1 U   ; ; ! U  U 2  ; ; !  ; ; ; !  ; ; !  ;  
 u  U   ; ; !  ;  % %   	 % h g f V     % f h g V   ! e V   ! +  U  %        ! U  V   ! U 3 e   ; ; !  ; ; ; $ $  % e % u  &  s 4  $  # Š  % % e V ,  n M )  % # p  % %  ‰  ! M V 5  ! +  % u  % M )  % # L  % e V 	   A *    =   =  % % f u    &  ‰  ! +  u   A  
 %   9 !   '  $ u  e  B u   9 !   > B %   > !   '  $ $   $ ! )     ,  , '  $ ! )     ,  , '  $  # J  % % f V 6  ! +  % Q Q % M )  % # *  e % u  V 7  a  % % f 	 8 2 n u   C q 9  0 ! u  V :  !  9 !   '  $  $ ! )     ,  , '  $  % u u   '  $ ! U  V     # J  % % f V 6  ! +  % Q Q % M )  % # *  e % u  V 7  a  % % f 	 8 2 n u   C q 9  0 ! u  V :  !  9 !   '  $  $ ! )     ,  , '  $  ; # ,  *  % % u V <  ! T  V =   % u  e V ;  ‰   u  A !   b  u  9 A $  $  > U ? ?   ) #   % f  A ! +  e 
 ) b  % U @ l   $  $  - #   % g  A ! +  e 
 ) b  %   '   $  $  . #   % g % M )  % # i   <    $ %  = ! +  % e V       $ % % u e V >  ! +    	 % U A u  l   $   > <  
 % U B u  l    ( u   A o ) b  u  e % u  V   B   % U C u  V   % % u  V   !   '  $ $ $ ! )     ,  , '  $  * % V D   J % S U  V E  . % U F V G  /
