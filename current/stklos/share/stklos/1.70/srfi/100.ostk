#!/usr/bin/env stklos
; A -*- Scheme -*- generated file *DO NOT EDIT**
STklos (#:version "1.70" #:globals (%check-duplicate %check-field %field-key unquote-get unquote-get* unquote-set! seq-lambda key-lambda define-object define-lambda-object) #:macros (((unquote-get . unquote-get) srfi/100 (lambda (symbol args) (if (null? args) `(error 'define-lambda-object "absent field" ,symbol) (let ((arg (car args))) `(if (eq? ,symbol ',(car arg)) ,(cdr arg) (unquote-get ,symbol ,(cdr args))))))) ((unquote-get* . unquote-get*) srfi/100 (lambda (symbol args) (if (null? args) `(error 'define-lambda-object "not available inspection" ,symbol) (let ((arg (car args))) `(if (eq? ,symbol ',arg) ,arg (unquote-get* ,symbol ,(cdr args))))))) ((unquote-set! . unquote-set!) srfi/100 (lambda (symbol new-val args iargs) (define (lp args) (if (null? args) `(if (memq ,symbol ',iargs) (error 'define-lambda-object "read-only field" ,symbol) (error 'define-lambda-object "absent field" ,symbol)) (let ((arg (car args))) `(if (eq? ,symbol ',arg) (set! ,arg ,new-val) ,(lp (cdr args)))))) (lp args))) ((seq-lambda . seq-lambda) srfi/100 (lambda (r o body) (define (opt-seq z cls body) (if (null? cls) `(if (null? ,z) ,body (error 'define-lambda-object "too many arguments" ,z)) (let ((cl (car cls))) `(let ((,(car cl) (if (null? ,z) ,(cadr cl) (car ,z))) (,z (if (null? ,z) ,z (cdr ,z)))) ,(opt-seq z (cdr cls) body))))) (if (null? o) `(lambda ,r ,body) (let ((z (gensym))) `(lambda (,@r unquote z) ,(opt-seq z o body)))))) ((key-lambda . key-lambda) srfi/100 (lambda (r o body) (define (opt-key z cls body) (if (null? cls) `(if (null? ,z) ,body (error 'define-lambda-object "too many arguments" ,z)) (let ((cl (car cls))) (let ((var (car cl)) (val (cadr cl))) `(let* ((,z (if (null? ,z) (cons ,val ,z) (%field-key ,z ',var ,val))) (,var (car ,z)) (,z (cdr ,z))) ,(opt-key z (cdr cls) body)))))) (if (null? o) `(lambda ,r ,body) (let ((z (gensym))) `(lambda (,@r unquote z) ,(opt-key z o body)))))) ((define-object . define-object) srfi/100 (lambda (name gr gi fm fi r o a c v h) (let ((safe-name (gensym)) (safe-parent (gensym)) (arg (gensym)) (args (gensym)) (makers (gensym)) (group-name (symbol->string name))) (let ((make-object (string->symbol (string-append "make-" group-name))) (make-object-by-name (string->symbol (string-append "make-" group-name "-by-name"))) (pred-object (string->symbol (string-append group-name "?")))) `(begin (define ,safe-parent (begin (%check-duplicate (append (list ',name) ',gi ',gr) "duplicated group") (%check-duplicate ',(append fm (map car fi) (map car h)) "duplicated field") (for-each (lambda (g y) (%check-field (g 'read-write-field) ',fm eq? y "incompatible read-write field") (%check-field (g 'read-only-field) ',(map car fi) eq? y "incompatible read-only field") (%check-field (g 'required-field) ',r eq? y "incompatible required field") (%check-field (g 'optional-field) ',o equal? y "incompatible optional field") (%check-field (g 'automatic-field) ',(append c v a) equal? y "incompatible automatic field") (%check-field (map car (g 'common-field)) ',(map car c) eq? y "incompatible common field") (%check-field (map car (g 'virtual-field)) ',(map car v) eq? y "incompatible virtual field") (%check-field (map car (g 'hidden-field)) ',(map car h) eq? y "incompatible hidden field")) (list ,@gi) ',gi) (for-each (lambda (g y) (%check-field (append (g 'read-write-field) (g 'read-only-field) (map car (g 'hidden-field))) ',(append fm (map car fi) (map car h)) eq? y "incompatible whole field")) (list ,@gr) ',gr) (list ,@gi ,@gr))) (define ,makers (let* ,c (cons (seq-lambda ,r ,o (let* ,a (define *%lambda-object%* (lambda (,arg unquote args) (if (null? ,args) (unquote-get ,arg ,(append (map cons fm fm) fi)) (if (null? (cdr ,args)) (unquote-set! ,arg (car ,args) ,fm ,(map car fi)) ,safe-name)))) (%set-procedure-plist! *%lambda-object%* '*%lambda-object%*) *%lambda-object%*)) (key-lambda ,r ,o (let* ,a (define *%lambda-object%* (lambda (,arg unquote args) (if (null? ,args) (unquote-get ,arg ,(append (map cons fm fm) fi)) (if (null? (cdr ,args)) (unquote-set! ,arg (car ,args) ,fm ,(map car fi)) ,safe-name)))) (%set-procedure-plist! *%lambda-object%* '*%lambda-object%*) *%lambda-object%*))))) (define ,make-object (car ,makers)) (define ,make-object-by-name (cdr ,makers)) (define (,pred-object object) (and (eq? '*%lambda-object%* (%procedure-plist object)) (let ((group (object #f #f #f))) (or (eq? ,safe-name group) (let lp ((group-list (group 'parent))) (if (null? group-list) #f (or (eq? ,safe-name (car group-list)) (lp ((car group-list) 'parent)) (lp (cdr group-list))))))))) (define ,name (let ((parent ,safe-parent) (constructor ,makers) (predicate ,pred-object) (read-write-field ',fm) (read-only-field ',(map car fi)) (required-field ',r) (optional-field ',o) (automatic-field ',(append c v a)) (common-field ',c) (virtual-field ',v) (hidden-field ',h)) (lambda (symbol) (unquote-get* symbol (parent constructor predicate read-write-field read-only-field required-field optional-field automatic-field common-field virtual-field hidden-field))))) (define ,safe-name ,name)))))) ((define-lambda-object . define-lambda-object) srfi/100 (lambda (group . field) (define (field-sort gr gi field fm fi r o a c v h) (if (null? field) `(define-object ,(car gi) ,gr ,(cdr gi) ,fm ,fi ,r ,o ,a ,c ,v ,h) (let ((vars (car field))) (if (symbol? vars) (if (and (null? o) (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) fm (append fi (list (cons vars vars))) (append r (list vars)) o a c v h) (error 'define-lambda-object "required-field should precede optional-field and automatic-field" vars)) (let ((var (car vars))) (if (symbol? var) (if (null? (cdr vars)) (if (and (null? o) (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) (append fm vars) fi (append r vars) o a c v h) (error 'define-lambda-object "required-field should precede optional-field and automatic-field" var)) (if (null? (cddr vars)) (if (and (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) fm (append fi (list (cons var var))) r (append o (list vars)) a c v h) (error 'define-lambda-object "optional-field should precede automatic-field" var)) (error 'define-lambda-object "incorrect syntax" vars))) (if (and (pair? (cdr vars)) (null? (cddr vars))) (let ((b (car var))) (if (symbol? b) (if (null? (cdr var)) (if (and (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) (append fm var) fi r (append o (list (cons b (cdr vars)))) a c v h) (error 'define-lambda-object "optional-field should precede automatic-field" b)) (if (null? (cddr var)) (let ((d (cadr var))) (if (symbol? d) (if (eq? 'unquote b) (field-sort gr gi (cdr field) fm (append fi (list (cons d d))) r o (append a (list (cons d (cdr vars)))) c v h) (if (eq? 'quote b) (if (and (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) fm fi r (append o (list (cons d (cdr vars)))) a c v (append h (list (cons d (cdr vars))))) (error 'define-lambda-object "optional-field should precede automatic-field" b)) (error 'define-lambda-object "incorrect syntax" vars))) (if (and (eq? 'unquote (car d)) (symbol? (cadr d)) (null? (cddr d))) (if (eq? 'unquote b) (field-sort gr gi (cdr field) fm (append fi (list (cons (cadr d) (cadr d)))) r o a (append c (list (cons (cadr d) (cdr vars)))) v h) (if (eq? 'quote b) (field-sort gr gi (cdr field) fm fi r o (append a (list (cons (cadr d) (cdr vars)))) c v (append h (list (cons (cadr d) (cdr vars))))) (if (eq? 'quasiquote b) (field-sort gr gi (cdr field) fm (append fi (list (cons (cadr d) (cadr vars)))) r o a c (append v (list (cons (cadr d) (cdr vars)))) h) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars))) (if (and (null? (cdr var)) (eq? 'unquote (car b)) (null? (cddr b))) (if (symbol? (cadr b)) (field-sort gr gi (cdr field) (append fm (cdr b)) fi r o (append a (list (cons (cadr b) (cdr vars)))) c v h) (let ((e (cadr b))) (if (and (eq? 'unquote (car e)) (symbol? (cadr e)) (null? (cddr e))) (field-sort gr gi (cdr field) (append fm (cdr e)) fi r o a (append c (list (cons (cadr e) (cdr vars)))) v h) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars)))))))) (define (group-sort gr gi gg field) (if (pair? gg) (let ((g (car gg))) (if (pair? g) (group-sort (append gr g) gi (cdr gg) field) (group-sort gr (append gi (list g)) (cdr gg) field))) (if (symbol? gg) (group-sort gr (cons gg gi) '() field) (field-sort gr gi field '() '() '() '() '() '() '() '())))) (group-sort '() '() group field)))))
#(%module-handler srfi/100 %module-create current-module ((%check-duplicate . %check-duplicate) (%check-field . %check-field) (%field-key . %field-key) (unquote-get . unquote-get) (unquote-get* . unquote-get*) (unquote-set! . unquote-set!) (seq-lambda . seq-lambda) (key-lambda . key-lambda) (define-object . define-object)) %do-exports ((define-lambda-object . define-lambda-object)) unquote-get (lambda (symbol args) (if (null? args) `(error 'define-lambda-object "absent field" ,symbol) (let ((arg (car args))) `(if (eq? ,symbol ',(car arg)) ,(cdr arg) (unquote-get ,symbol ,(cdr args)))))) error quote define-lambda-object "absent field" if eq? %make-syntax unquote-get* (lambda (symbol args) (if (null? args) `(error 'define-lambda-object "not available inspection" ,symbol) (let ((arg (car args))) `(if (eq? ,symbol ',arg) ,arg (unquote-get* ,symbol ,(cdr args)))))) "not available inspection" unquote-set! (lambda (symbol new-val args iargs) (define (lp args) (if (null? args) `(if (memq ,symbol ',iargs) (error 'define-lambda-object "read-only field" ,symbol) (error 'define-lambda-object "absent field" ,symbol)) (let ((arg (car args))) `(if (eq? ,symbol ',arg) (set! ,arg ,new-val) ,(lp (cdr args)))))) (lp args)) memq "read-only field" "absent field" set! seq-lambda (lambda (r o body) (define (opt-seq z cls body) (if (null? cls) `(if (null? ,z) ,body (error 'define-lambda-object "too many arguments" ,z)) (let ((cl (car cls))) `(let ((,(car cl) (if (null? ,z) ,(cadr cl) (car ,z))) (,z (if (null? ,z) ,z (cdr ,z)))) ,(opt-seq z (cdr cls) body))))) (if (null? o) `(lambda ,r ,body) (let ((z (gensym))) `(lambda (,@r unquote z) ,(opt-seq z o body))))) null? "too many arguments" let cadr car cdr lambda gensym append %field-key key-lambda (lambda (r o body) (define (opt-key z cls body) (if (null? cls) `(if (null? ,z) ,body (error 'define-lambda-object "too many arguments" ,z)) (let ((cl (car cls))) (let ((var (car cl)) (val (cadr cl))) `(let* ((,z (if (null? ,z) (cons ,val ,z) (%field-key ,z ',var ,val))) (,var (car ,z)) (,z (cdr ,z))) ,(opt-key z (cdr cls) body)))))) (if (null? o) `(lambda ,r ,body) (let ((z (gensym))) `(lambda (,@r unquote z) ,(opt-key z o body))))) "too many arguments" let* cons %check-duplicate %check-field define-object (lambda (name gr gi fm fi r o a c v h) (let ((safe-name (gensym)) (safe-parent (gensym)) (arg (gensym)) (args (gensym)) (makers (gensym)) (group-name (symbol->string name))) (let ((make-object (string->symbol (string-append "make-" group-name))) (make-object-by-name (string->symbol (string-append "make-" group-name "-by-name"))) (pred-object (string->symbol (string-append group-name "?")))) `(begin (define ,safe-parent (begin (%check-duplicate (append (list ',name) ',gi ',gr) "duplicated group") (%check-duplicate ',(append fm (map car fi) (map car h)) "duplicated field") (for-each (lambda (g y) (%check-field (g 'read-write-field) ',fm eq? y "incompatible read-write field") (%check-field (g 'read-only-field) ',(map car fi) eq? y "incompatible read-only field") (%check-field (g 'required-field) ',r eq? y "incompatible required field") (%check-field (g 'optional-field) ',o equal? y "incompatible optional field") (%check-field (g 'automatic-field) ',(append c v a) equal? y "incompatible automatic field") (%check-field (map car (g 'common-field)) ',(map car c) eq? y "incompatible common field") (%check-field (map car (g 'virtual-field)) ',(map car v) eq? y "incompatible virtual field") (%check-field (map car (g 'hidden-field)) ',(map car h) eq? y "incompatible hidden field")) (list ,@gi) ',gi) (for-each (lambda (g y) (%check-field (append (g 'read-write-field) (g 'read-only-field) (map car (g 'hidden-field))) ',(append fm (map car fi) (map car h)) eq? y "incompatible whole field")) (list ,@gr) ',gr) (list ,@gi ,@gr))) (define ,makers (let* ,c (cons (seq-lambda ,r ,o (let* ,a (define *%lambda-object%* (lambda (,arg unquote args) (if (null? ,args) (unquote-get ,arg ,(append (map cons fm fm) fi)) (if (null? (cdr ,args)) (unquote-set! ,arg (car ,args) ,fm ,(map car fi)) ,safe-name)))) (%set-procedure-plist! *%lambda-object%* '*%lambda-object%*) *%lambda-object%*)) (key-lambda ,r ,o (let* ,a (define *%lambda-object%* (lambda (,arg unquote args) (if (null? ,args) (unquote-get ,arg ,(append (map cons fm fm) fi)) (if (null? (cdr ,args)) (unquote-set! ,arg (car ,args) ,fm ,(map car fi)) ,safe-name)))) (%set-procedure-plist! *%lambda-object%* '*%lambda-object%*) *%lambda-object%*))))) (define ,make-object (car ,makers)) (define ,make-object-by-name (cdr ,makers)) (define (,pred-object object) (and (eq? '*%lambda-object%* (%procedure-plist object)) (let ((group (object #f #f #f))) (or (eq? ,safe-name group) (let lp ((group-list (group 'parent))) (if (null? group-list) #f (or (eq? ,safe-name (car group-list)) (lp ((car group-list) 'parent)) (lp (cdr group-list))))))))) (define ,name (let ((parent ,safe-parent) (constructor ,makers) (predicate ,pred-object) (read-write-field ',fm) (read-only-field ',(map car fi)) (required-field ',r) (optional-field ',o) (automatic-field ',(append c v a)) (common-field ',c) (virtual-field ',v) (hidden-field ',h)) (lambda (symbol) (unquote-get* symbol (parent constructor predicate read-write-field read-only-field required-field optional-field automatic-field common-field virtual-field hidden-field))))) (define ,safe-name ,name))))) symbol->string "make-" string-append string->symbol "make-" "-by-name" "?" begin define list "duplicated group" map "duplicated field" for-each g y read-write-field "incompatible read-write field" read-only-field "incompatible read-only field" required-field "incompatible required field" optional-field equal? "incompatible optional field" automatic-field "incompatible automatic field" common-field "incompatible common field" virtual-field "incompatible virtual field" hidden-field "incompatible hidden field" "incompatible whole field" *%lambda-object%* %set-procedure-plist! object and %procedure-plist group or lp group-list parent constructor predicate symbol (lambda (group . field) (define (field-sort gr gi field fm fi r o a c v h) (if (null? field) `(define-object ,(car gi) ,gr ,(cdr gi) ,fm ,fi ,r ,o ,a ,c ,v ,h) (let ((vars (car field))) (if (symbol? vars) (if (and (null? o) (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) fm (append fi (list (cons vars vars))) (append r (list vars)) o a c v h) (error 'define-lambda-object "required-field should precede optional-field and automatic-field" vars)) (let ((var (car vars))) (if (symbol? var) (if (null? (cdr vars)) (if (and (null? o) (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) (append fm vars) fi (append r vars) o a c v h) (error 'define-lambda-object "required-field should precede optional-field and automatic-field" var)) (if (null? (cddr vars)) (if (and (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) fm (append fi (list (cons var var))) r (append o (list vars)) a c v h) (error 'define-lambda-object "optional-field should precede automatic-field" var)) (error 'define-lambda-object "incorrect syntax" vars))) (if (and (pair? (cdr vars)) (null? (cddr vars))) (let ((b (car var))) (if (symbol? b) (if (null? (cdr var)) (if (and (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) (append fm var) fi r (append o (list (cons b (cdr vars)))) a c v h) (error 'define-lambda-object "optional-field should precede automatic-field" b)) (if (null? (cddr var)) (let ((d (cadr var))) (if (symbol? d) (if (eq? 'unquote b) (field-sort gr gi (cdr field) fm (append fi (list (cons d d))) r o (append a (list (cons d (cdr vars)))) c v h) (if (eq? 'quote b) (if (and (null? a) (null? c) (null? v)) (field-sort gr gi (cdr field) fm fi r (append o (list (cons d (cdr vars)))) a c v (append h (list (cons d (cdr vars))))) (error 'define-lambda-object "optional-field should precede automatic-field" b)) (error 'define-lambda-object "incorrect syntax" vars))) (if (and (eq? 'unquote (car d)) (symbol? (cadr d)) (null? (cddr d))) (if (eq? 'unquote b) (field-sort gr gi (cdr field) fm (append fi (list (cons (cadr d) (cadr d)))) r o a (append c (list (cons (cadr d) (cdr vars)))) v h) (if (eq? 'quote b) (field-sort gr gi (cdr field) fm fi r o (append a (list (cons (cadr d) (cdr vars)))) c v (append h (list (cons (cadr d) (cdr vars))))) (if (eq? 'quasiquote b) (field-sort gr gi (cdr field) fm (append fi (list (cons (cadr d) (cadr vars)))) r o a c (append v (list (cons (cadr d) (cdr vars)))) h) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars))) (if (and (null? (cdr var)) (eq? 'unquote (car b)) (null? (cddr b))) (if (symbol? (cadr b)) (field-sort gr gi (cdr field) (append fm (cdr b)) fi r o (append a (list (cons (cadr b) (cdr vars)))) c v h) (let ((e (cadr b))) (if (and (eq? 'unquote (car e)) (symbol? (cadr e)) (null? (cddr e))) (field-sort gr gi (cdr field) (append fm (cdr e)) fi r o a (append c (list (cons (cadr e) (cdr vars)))) v h) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars)))) (error 'define-lambda-object "incorrect syntax" vars)))))))) (define (group-sort gr gi gg field) (if (pair? gg) (let ((g (car gg))) (if (pair? g) (group-sort (append gr g) gi (cdr gg) field) (group-sort gr (append gi (list g)) (cdr gg) field))) (if (symbol? gg) (group-sort gr (cons gg gi) '() field) (field-sort gr gi field '() '() '() '() '() '() '() '())))) (group-sort '() '() group field)) symbol? "required-field should precede optional-field and automatic-field" "required-field should precede optional-field and automatic-field" cddr "optional-field should precede automatic-field" "incorrect syntax" pair? "optional-field should precede automatic-field" unquote "optional-field should precede automatic-field" "incorrect syntax" quasiquote "incorrect syntax" "incorrect syntax" "incorrect syntax" "incorrect syntax" "incorrect syntax" "incorrect syntax" %module-restore values "srfi/100" provide)
4058
  
   -Î % U  V   J % % V    ! U  V   % % V    ! U  V   % U  U  # I   <   U 	 U 
 U   ; ; ! U  f  ; ; ; ; $ %  = ! +  U  U  u U 
  = !  ; ; !  ; ; ; !  > ! U  u   > !  ; ; ; !  ; ; ; ; $ $ ! U  V     % U  U  # E   <   U 	 U 
 U   ; ; ! U  f  ; ; ; ; $ %  = ! +  U  U  u U 
 e  ; ; !  ; ; ; ! e U  u   > !  ; ; ; !  ; ; ; ; $ $ ! U  V     % U  U  # ‡  % M +  # x   <  A U  U  u U 
 u   ; ; !  ; ; ; ! U 	 U 
 U   ; ; ! U  u  ; ; ; ; ! U 	 U 
 U   ; ; ! U  u  ; ; ; ; !  ; ; ; ; $ %  = ! +  U  U  u U 
 e  ; ; !  ; ; ; ! U  e u  ; ; ; n   > !   &  !  ; ; ; ; $ $  % u  '  $ ! U  V     % U  U  # Å  % M +  # ‹   <  # U  U  g  ; ; ! e U 	 U 
 U   ; ; ! U  g  ; ; ; ; !  ; ; ; ; $ %  = ! +  U   = ! U  U  u  ; ; n e V   ! U  u  ; ; !  ; ; ; ; !  ; ; ! u U  U  u  ; ; ! u U   u  ; ; !  ; ; ; ; !  ; ; !  ; ; n u  > ! u    &  !  ; ; ; $ $   <   U ! u u   ; ; ; $ % % V "   ! +  U ! % u e V #  n e u u    &  !  ; ; ; $ $ ! U  V     # |  %  = !  > ! +   <   u   ; $ u  b    _ % f  = ! ?  !  > n M )  % # C   <   u   ; $ %  = !  > ! +   <   u   ; $ u  b   = n u  > q #  ;   % f  = !  ; ; !  > !   '  $ $ ! )     ,  , '  $  $ % U % U & # Ú  % M +  #     <  # U  U  g  ; ; ! e U 	 U 
 U   ; ; ! U ' g  ; ; ; ; !  ; ; ; ; $ %  = ! +  %  = n e V   ! +  U ( u U  U  u  ; ; ! U ) e u  ; ; ; ! U $ u U 
 f  ; ; ! e  ; ; ; ; !  ; ; ; ; !  ; ; ! f U  u  ; ; !  ; ; ! u U   u  ; ; !  ; ; !  ; ; ; n u  > ! u    &  !  ; ; ; $ $   <   U ! u u   ; ; ; $ % % V "   ! +  U ! % u e V #  n e u u    &  !  ; ; ; $ $ ! U  V    % # &   <    $ %  = !  > q     % U  e  = s 	    %  > ! e l *  $  * # ®  % i h % M )  % # —   <    $  <   % U  u  u  = s 	   } %  = ! +  % e   = !  &    %  > !   > !   '  $ %   = ! ?  !   > n M )  % # ?   <   % U  u  u u  l 	  $ % u   = !  &    %  > n f  > q #  !   '    %  = !  ; !  > !   '  $ ! )     ,  , '  $ $ ! )     ,  , '  $  + % U , U - #-  % % V "   n V "   n V "   n V "   n V "   n  
 q .  ! +  % % % U / e V 0  q 1  n % U 2 e U 3 V 0  q 1  n % e U 4 V 0  q 1  ! +  U 5 U 6 u U 5 U * U # U 7 U 
 u
  ; ; !  ; ; ! U 
 u  ; ; ! U 
 u	  ; ; !  ; ; ; ; ! U 8  ; ; ; ! U * U 
 % u % j  u V 9  n j  u  V 9  q #  !  ; ; ! U :  ; ; ; ! U ; U ! U < U =  ; ; ! U + U < U 
 U >  ; ; !  ; ; ! U 
 u  ; ; ! U  U = U ?  ; ; ; ; ; ; ! U + U < U 
 U @  ; ; !  ; ; ! U 
 % j  u V 9  !  ; ; ! U  U = U A  ; ; ; ; ; ; ! U + U < U 
 U B  ; ; !  ; ; ! U 
 u  ; ; ! U  U = U C  ; ; ; ; ; ; ! U + U < U 
 U D  ; ; !  ; ; ! U 
 u  ; ; ! U E U = U F  ; ; ; ; ; ; ! U + U < U 
 U G  ; ; !  ; ; ! U 
 % u u u V #  !  ; ; ! U E U = U H  ; ; ; ; ; ; ! U + U 9 U  U < U 
 U I  ; ; !  ; ; !  ; ; ; ! U 
 % j  u V 9  !  ; ; ! U  U = U J  ; ; ; ; ; ; ! U + U 9 U  U < U 
 U K  ; ; !  ; ; !  ; ; ; ! U 
 % j  u V 9  !  ; ; ! U  U = U L  ; ; ; ; ; ; ! U + U 9 U  U < U 
 U M  ; ; !  ; ; !  ; ; ; ! U 
 % j  u  V 9  !  ; ; ! U  U = U N  ; ; ; ; ; ; !  ; ; ; ; ; ; ; ; ; ; ! U 7  ; ! U 
 u  ; ; !  ; ; ; ; ! U ; U ! U < U =  ; ; ! U + U # U < U 
 U >  ; ; !  ; ; ! U < U 
 U @  ; ; !  ; ; ! U 9 U  U < U 
 U M  ; ; !  ; ; !  ; ; ; !  ; ; ; ; ! U 
 % u % j  u V 9  n j  u  V 9  q #  !  ; ; ! U  U = U O  ; ; ; ; ; ; !  ; ; ; ! U 7 	 ; ! U 
 u	  ; ; !  ; ; ; ; ! U 7 % u u	 V #  ; !  ; ; ; ; ; ; !  ; ; ; ! U 6 u U ( u U ) U  u u U ( u U 6 U P U ! u  ; ! U  U  u  ; ; ! U  u % % j ) u u V 9  ! u V #  !  ; ; ; ! U  U  U   u  ; ; !  ; ; ! U  u U  u  ; ; ! u % j  u V 9  !  ; ; ; ; ; ! u  ; ; ; ; !  ; ; ; ; !  ; ; ; !  ; ; ; ! U Q U P U 
 U P  ; ; !  ; ; ; ! U P  ; ; ; ; ; !  ; ; ; ; ! U % u u U ( u U 6 U P U ! u  ; ! U  U  u  ; ; ! U  u % % j ) u u V 9  ! u V #  !  ; ; ; ! U  U  U   u  ; ; !  ; ; ! U  u U  u  ; ; ! u % j  u V 9  !  ; ; ; ; ; ! u  ; ; ; ; !  ; ; ; ; !  ; ; ; !  ; ; ; ! U Q U P U 
 U P  ; ; !  ; ; ; ! U P  ; ; ; ; ; !  ; ; ; ; !  ; ; ; !  ; ; ; !  ; ; ; ! U 6 g U  u  ; ; !  ; ; ; ! U 6 f U   u  ; ; !  ; ; ; ! U 6 e U R  ; ; ! U S U  U 
 U P  ; ; ! U T U R  ; ; !  ; ; ; ! U  U U U R M M M  ; ; ; ; !  ; ; !  ; ! U V U  u U U  ; ; ; ! U  U W U X U U U 
 U Y  ; ; !  ; ; !  ; ; !  ; ! U  U  U X  ; ; ! M U V U  u U  U X  ; ; !  ; ; ; ! U W U  U X  ; ; ! U 
 U Y  ; ; !  ; ; !  ; ; ! U W U   U X  ; ; !  ; ; !  ; ; ; ; !  ; ; ; ; !  ; ; ; ; !  ; ; ; !  ; ; ; !  ; ; ; !  ; ; ; ! U 6 u
 U  U Y u  ; ; ! U Z u  ; ; ! U [ e  ; ; ! U > U 
 u  ; ; !  ; ; ! U @ U 
 % j  u V 9  !  ; ; !  ; ; ! U B U 
 u  ; ; !  ; ; ! U D U 
 u  ; ; !  ; ; ! U G U 
 % u u u V #  !  ; ; !  ; ; ! U I U 
 u  ; ; !  ; ; ! U K U 
 u  ; ; !  ; ; ! U M U 
 u   ; ; !  ; ; !  ; ; ; ; ; ; ; ; ; ; ; ! U ! U \  ; ! U  U \ U Y U Z U [ U > U @ U B U D U G U I U K U M  ; ; ; ; ; ; ; ; ; ; ; !  ; ; ; !  ; ; ; !  ; ; ; !  ; ; ; ! U 6 u u
  ; ; ; !  ; ; ; ; ; ; ; ; $ ! U  V    , % U  U ] #þÿþ % M M +  #}    <  ) U ,  	 = !  
 !  	 > !   !   !   ! i h g f e  ; ; ; ; ; ; ; ; ; ; ; ; $ %   = ! +  % e V ^   Q  <    <  
  <    <     0 % u
 u	  > ! u % u e  ; ! ?  q #  n u e ?  q #  ! u u u u u   '  $ % U  U _ e l 	  $ %  = ! +  % e V ^   ¶   > <  L  <    <  
  <    <     + % u
 u	  > n u u  V #  ! u % u u  V #  ! u u u u u   '  $ % U  U ` e l 	  $ % u  V a  <  P  <  
  <    <     3 % u
 u	  > ! u % u e  ; ! ?  q #  ! u % u u  ?  q #  ! u u u u   '    % U  U b e l 	   
 % U  U c u  l 	  $ %   > q d   	 % u  V a  <    
 %  = ! +  % e V ^  /   > <  M  <  
  <    <     1 % u
 u	  > n u u  V #  ! u u % u e   > ; ! ?  q #  ! u u u u   '  $ % U  U e e l 	  $ % u  V a  < È % % u  V   ! +  % e V ^   ¤ U f   b 6 % u
 u	  > ! u % u e  ; ! ?  q #  ! u u % u e   > ; ! ?  q #  ! u u u   '  $ U 
   b W  <  
  <    <     9 % u
 u	  > ! u u u % u e   > ; ! ?  q #  ! u u u % u  e   > ; ! ?  q #  !  '    % U  U g u  l 	   
 % U  U h u  l 	  $ U f  = b  % % e V   q ^    % e V a  <     ê U f   b D % u
 u	  > ! u % u % e V   n e V   ; ! ?  q #  ! u u u % u % e V   !   > ; ! ?  q #  ! u u   '   ª U 
   b C % u
 u	  > ! u u u u % u % e V   !   > ; ! ?  q #  ! u u % u  % e V   !   > ; ! ?  q #  !  '   U U i   b E % u
 u	  > ! u % u % e V   n u  V   ; ! ?  q #  ! u u u u % u % e V   !   > ; ! ?  q #  ! u   '   
 % U  U j u  l 	   
 % U  U k u  l 	  $  
 % U  U l u  l 	  $   > <   U f  = b  % e V a  <     ª % % e V   q ^   7 % u
 u	  > n u  > q #  ! u u u % u % e V   !   > ; ! ?  q #  ! u u u   '   r % % e V   ! +  U f  = b  % % e V   q ^    % e V a  <     6 % u
 u	  > n u  > q #  ! u u u u % u % e V   !   > ; ! ?  q #  ! u u   '  $ % U  U m u  l 	  $  
 % U  U n u  l 	  $  
 % U  U o u  l 	  $ $ $  # j  % f V d   < %  = ! +  % e V d    % % u e V #  ! u  > ! u    '  $ % u % u e ?  q #  !  > ! u    '  $ $ % f V ^    % h f  ; ! O e   '    % h g e O O O O O O O O  '  $  % O O u u   '  $ ! U  V     % V p   J % S U  V q  . % U r V s  /
