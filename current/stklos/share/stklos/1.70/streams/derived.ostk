#!/usr/bin/env stklos
; A -*- Scheme -*- generated file *DO NOT EDIT**
STklos (#:version "1.70" #:globals (stream-null stream-cons stream? stream-null? stream-pair? stream-car stream-cdr make-stream make-stream-pare %stream-eager stream-lambda stream-delay stream-lazy stream stream-promise stream-promise! stream-force stream-pare stream-pare? stream-pare-kar stream-pare-kdr stream-kar stream-kdr xcons list-tabulate cons* proper-list? circular-list? dotted-list? not-pair? null-list? list= circular-list length+ iota first second third fourth fifth sixth seventh eighth ninth tenth car+cdr take drop take-right drop-right take! drop-right! split-at split-at! last zip unzip1 unzip2 unzip3 unzip4 unzip5 count append-reverse append-reverse! concatenate concatenate! unfold fold pair-fold reduce unfold-right fold-right pair-fold-right reduce-right map! pair-for-each map-in-order partition partition! find find-tail list-index take-while drop-while take-while! span break span! break! alist-cons alist-copy delete-duplicates delete-duplicates! alist-delete alist-delete! lset<= lset= lset-adjoin lset-union lset-intersection lset-difference lset-xor lset-diff+intersection lset-union! lset-intersection! lset-difference! lset-xor! lset-diff+intersection! check-arg %cdrs %cars+ %cars+cdrs %cars+cdrs+ %cars+cdrs/no-test really-append-map %lset2<= redefine list->stream port->stream stream->list stream-append stream-concat stream-constant stream-drop stream-drop-while stream-filter stream-fold stream-for-each stream-from stream-iterate stream-length stream-map stream-range stream-ref stream-reverse stream-scan stream-take stream-take-while stream-unfold stream-unfolds stream-zip define-stream stream-let stream-match stream-match-next stream-match-one stream-match-body stream-of stream-of-aux stream-of-aux2 exists) #:macros (((define-stream . define-stream) streams/derived (lambda args (%find-macro-clause 'define-stream args '(define-stream) '(((define-stream (name . formal) body0 body1 ...) (define name (stream-lambda formal body0 body1 ...))))))) ((stream . stream) streams/derived (lambda args (%find-macro-clause 'stream args '(stream) '(((stream) stream-null) ((stream x y ...) (stream-cons x (stream y ...))))))) ((stream-let . stream-let) streams/derived (lambda args (%find-macro-clause 'stream-let args '(stream-let) '(((stream-let tag ((name val) ...) body1 body2 ...) ((letrec ((tag (stream-lambda (name ...) body1 body2 ...))) tag) val ...)))))) ((stream-match . stream-match) streams/derived (lambda args (%find-macro-clause 'stream-match args '(stream-match) '(((stream-match expr clause ...) (let ((strm expr)) (if (not (stream? strm)) (error 'stream-match "non-stream argument") (stream-match-next strm clause ...)))))))) ((stream-match-next . stream-match-next) streams/derived (lambda args (%find-macro-clause 'stream-match-next args '(stream-match-next) '(((stream-match-next strm) (error 'stream-match "pattern failure")) ((stream-match-next strm clause . clauses) (let ((fail (lambda () (stream-match-next strm . clauses)))) (stream-match-one strm clause (fail)))))))) ((stream-match-one . stream-match-one) streams/derived (lambda args (%find-macro-clause 'stream-match-one args '(stream-match-one _) '(((stream-match-one strm (() . body) fail) (if (stream-null? strm) (stream-match-body fail . body) fail)) ((stream-match-one strm (_ . body) fail) (stream-match-body fail . body)) ((stream-match-one strm ((a . b) . body) fail) (if (stream-pair? strm) (stream-match-one (stream-car strm) (a (stream-match-one (stream-cdr strm) (b . body) fail)) fail) fail)) ((stream-match-one strm (a . body) fail) (let ((a strm)) (stream-match-body fail . body))))))) ((stream-match-body . stream-match-body) streams/derived (lambda args (%find-macro-clause 'stream-match-body args '(stream-match-body) '(((stream-match-body fail fender expr) (if fender expr fail)) ((stream-match-body fail expr) expr))))) ((stream-of . stream-of) streams/derived (lambda args (%find-macro-clause 'stream-of args '(stream-of) '(((_ expr rest ...) (stream-of-aux expr stream-null rest ...)))))) ((stream-of-aux . stream-of-aux) streams/derived (lambda args (%find-macro-clause 'stream-of-aux args '(stream-of-aux in is) '(((stream-of-aux expr base) (stream-cons expr base)) ((stream-of-aux expr base (var in stream) rest ...) (stream-of-aux2 expr base (var in stream) rest ...)) ((stream-of-aux expr base (var is exp) rest ...) (let ((var exp)) (stream-of-aux expr base rest ...))) ((stream-of-aux expr base pred? rest ...) (if pred? (stream-of-aux expr base rest ...) base)))))) ((stream-of-aux2 . stream-of-aux2) streams/derived (lambda (expr base v . rest) (let ((var (car v)) (loop (gensym "loop")) (strm (gensym "strm")) (stream (caddr v))) `(stream-let ,loop ((,strm ,stream)) (if (stream-null? ,strm) ,base (let ((,var (stream-car ,strm))) (stream-of-aux ,expr (,loop (stream-cdr ,strm)) ,@rest)))))))))
#(%module-handler streams/derived %module-create current-module ((streams/primitive) (scheme/list)) list-copy %do-imports ((list->stream . list->stream) (port->stream . port->stream) (stream->list . stream->list) (stream-append . stream-append) (stream-concat . stream-concat) (stream-constant . stream-constant) (stream-drop . stream-drop) (stream-drop-while . stream-drop-while) (stream-filter . stream-filter) (stream-fold . stream-fold) (stream-for-each . stream-for-each) (stream-from . stream-from) (stream-iterate . stream-iterate) (stream-length . stream-length) (stream-map . stream-map) (stream-range . stream-range) (stream-ref . stream-ref) (stream-reverse . stream-reverse) (stream-scan . stream-scan) (stream-take . stream-take) (stream-take-while . stream-take-while) (stream-unfold . stream-unfold) (stream-unfolds . stream-unfolds) (stream-zip . stream-zip)) %do-exports ((define-stream . define-stream) (stream . stream) (stream-let . stream-let) (stream-match . stream-match) (stream-match-next . stream-match-next) (stream-match-one . stream-match-one) (stream-match-body . stream-match-body) (stream-of . stream-of) (stream-of-aux . stream-of-aux) (stream-of-aux2 . stream-of-aux2)) any exists define-stream (lambda args (%find-macro-clause 'define-stream args '(define-stream) '(((define-stream (name . formal) body0 body1 ...) (define name (stream-lambda formal body0 body1 ...)))))) (define-stream) (((define-stream (name . formal) body0 body1 ...) (define name (stream-lambda formal body0 body1 ...)))) %find-macro-clause %make-syntax lazy stream-null %stream-eager make-stream make-stream-pare list? list->stream "non-list argument" error read-char eof-object? current-input-port input-port? port->stream "non-input-port argument" stream (lambda args (%find-macro-clause 'stream args '(stream) '(((stream) stream-null) ((stream x y ...) (stream-cons x (stream y ...)))))) (stream) (((stream) stream-null) ((stream x y ...) (stream-cons x (stream y ...)))) length cadr stream? stream->list "non-stream argument" integer? "non-integer count" negative? "negative count" zero? stream-null? stream-car stream-cdr stream-append "non-stream argument" stream-concat "non-stream object in input stream" "non-stream argument" stream-constant append apply stream-drop "non-integer argument" "negative argument" "non-stream argument" stream-pair? procedure? stream-drop-while "non-procedural argument" "non-stream argument" stream-filter "non-procedural argument" "non-stream argument" stream-fold "non-procedural argument" "non-stream argument" map stream-for-each "non-procedural argument" "no stream arguments" "non-stream argument" number? stream-from "non-numeric starting number" "non-numeric step size" stream-iterate "non-procedural argument" stream-length "non-stream argument" stream-let (lambda args (%find-macro-clause 'stream-let args '(stream-let) '(((stream-let tag ((name val) ...) body1 body2 ...) ((letrec ((tag (stream-lambda (name ...) body1 body2 ...))) tag) val ...))))) (stream-let) (((stream-let tag ((name val) ...) body1 body2 ...) ((letrec ((tag (stream-lambda (name ...) body1 body2 ...))) tag) val ...))) stream-map "non-procedural argument" "no stream arguments" "non-stream argument" stream-match (lambda args (%find-macro-clause 'stream-match args '(stream-match) '(((stream-match expr clause ...) (let ((strm expr)) (if (not (stream? strm)) (error 'stream-match "non-stream argument") (stream-match-next strm clause ...))))))) (stream-match) (((stream-match expr clause ...) (let ((strm expr)) (if (not (stream? strm)) (error 'stream-match "non-stream argument") (stream-match-next strm clause ...))))) stream-match-next (lambda args (%find-macro-clause 'stream-match-next args '(stream-match-next) '(((stream-match-next strm) (error 'stream-match "pattern failure")) ((stream-match-next strm clause . clauses) (let ((fail (lambda () (stream-match-next strm . clauses)))) (stream-match-one strm clause (fail))))))) (stream-match-next) (((stream-match-next strm) (error 'stream-match "pattern failure")) ((stream-match-next strm clause . clauses) (let ((fail (lambda () (stream-match-next strm . clauses)))) (stream-match-one strm clause (fail))))) stream-match-one (lambda args (%find-macro-clause 'stream-match-one args '(stream-match-one _) '(((stream-match-one strm (() . body) fail) (if (stream-null? strm) (stream-match-body fail . body) fail)) ((stream-match-one strm (_ . body) fail) (stream-match-body fail . body)) ((stream-match-one strm ((a . b) . body) fail) (if (stream-pair? strm) (stream-match-one (stream-car strm) (a (stream-match-one (stream-cdr strm) (b . body) fail)) fail) fail)) ((stream-match-one strm (a . body) fail) (let ((a strm)) (stream-match-body fail . body)))))) (stream-match-one _) (((stream-match-one strm (() . body) fail) (if (stream-null? strm) (stream-match-body fail . body) fail)) ((stream-match-one strm (_ . body) fail) (stream-match-body fail . body)) ((stream-match-one strm ((a . b) . body) fail) (if (stream-pair? strm) (stream-match-one (stream-car strm) (a (stream-match-one (stream-cdr strm) (b . body) fail)) fail) fail)) ((stream-match-one strm (a . body) fail) (let ((a strm)) (stream-match-body fail . body)))) stream-match-body (lambda args (%find-macro-clause 'stream-match-body args '(stream-match-body) '(((stream-match-body fail fender expr) (if fender expr fail)) ((stream-match-body fail expr) expr)))) (stream-match-body) (((stream-match-body fail fender expr) (if fender expr fail)) ((stream-match-body fail expr) expr)) stream-of (lambda args (%find-macro-clause 'stream-of args '(stream-of) '(((_ expr rest ...) (stream-of-aux expr stream-null rest ...))))) (stream-of) (((_ expr rest ...) (stream-of-aux expr stream-null rest ...))) stream-of-aux2 (lambda (expr base v . rest) (let ((var (car v)) (loop (gensym "loop")) (strm (gensym "strm")) (stream (caddr v))) `(stream-let ,loop ((,strm ,stream)) (if (stream-null? ,strm) ,base (let ((,var (stream-car ,strm))) (stream-of-aux ,expr (,loop (stream-cdr ,strm)) ,@rest)))))) "loop" gensym "strm" caddr if let stream-of-aux (lambda args (%find-macro-clause 'stream-of-aux args '(stream-of-aux in is) '(((stream-of-aux expr base) (stream-cons expr base)) ((stream-of-aux expr base (var in stream) rest ...) (stream-of-aux2 expr base (var in stream) rest ...)) ((stream-of-aux expr base (var is exp) rest ...) (let ((var exp)) (stream-of-aux expr base rest ...))) ((stream-of-aux expr base pred? rest ...) (if pred? (stream-of-aux expr base rest ...) base))))) (stream-of-aux in is) (((stream-of-aux expr base) (stream-cons expr base)) ((stream-of-aux expr base (var in stream) rest ...) (stream-of-aux2 expr base (var in stream) rest ...)) ((stream-of-aux expr base (var is exp) rest ...) (let ((var exp)) (stream-of-aux expr base rest ...))) ((stream-of-aux expr base pred? rest ...) (if pred? (stream-of-aux expr base rest ...) base))) stream-range "non-numeric starting number" "non-numeric ending number" pair? "non-numeric step size" < > stream-ref "non-stream argument" "non-integer argument" "negative argument" "beyond end of stream" stream-reverse "non-stream argument" stream-scan "non-procedural argument" "non-stream argument" stream-take "non-stream argument" "non-integer argument" "negative argument" stream-take-while "non-stream argument" "non-procedural argument" stream-unfold "non-procedural mapper" "non-procedural pred?" "non-procedural generator" call-with-values list-ref stream-unfolds "can't happen" values "non-procedural argument" stream-zip "no stream arguments" "non-stream argument" %module-restore "streams/derived" provide)
3992
  
   -Œ % U  V   J % % V    n U  V   ! M V   % % V    ! U  V   % % V    ! U 	 V   
 
   % U  U  # ÿÿ % U  e U  U  l   $ ! U  V     # c  % M +  # C  % U  # 8     <   
  $ % % % U  # 	   %   = s   $ ; q   n U  #    %   > !   '  $ ; q   q   s   $ ; s   $  % u  V    	 % U  U  l   $ % u   '  $   # }ÿÿ % M +  # L  % U  # A   % % u  V   ! +  % e V     
  $ % % % U  #    % u  l   $ ; q   n U  # 	   % u    '  $ ; q   q   s   $ ; s   $  %   <   % V        = ! +  % e V    	 % U  U   l   $ % e   '  $   % U ! U " # ÿÿ % U ! e U # U $ l   $ ! U  V    ! # ¨ÿÿ % R % e V %  \      = ! R % e V %  \   =   % e V &  ! +  % e V '   	 % U ( U ) l   $    % f V *  @     
 % U ( U + l    [    % f V ,      
 % U ( U - l    D %        ! e % M )  % # (  % f V .    % e V /        $ % e V 0  n  : n e V 1  !   &  ; $ ! )     ,  , '  $  ( # šÿÿ % M +  # f  % U  # [     > <     = $ %   = q /    %   > !   '   ; % % % U  #    % %   = q 0  s   $ ; q   n U  #    % %   = q 1  !   > ; !   '  $ ; q   q   s   $ ; s   $    <   
  $ % #   % e V '  @ $ ! u  V    
 % U 2 U 3 l     % u   '  $  2 # Ì  % M +  # ¬  % U  # ¡   % u  V /    
  $ % % u  V 0  q '   
 % U 4 U 5 l    ~ % % u  V 0  q /    % % u  V 1  !   '   d % % % U  #    % % % u  V 0  q 0  s   $ ; q   n U  # :   % % % % U  #    % % % u  V 0  q 1  s   $ ; q   n U  #    % u  l 1  $ ; q   q   q   !   '  $ ; q   q   s   $ ; s   $  % u  V '   	 % U 4 U 6 l   $ % u   '  $  4 # ‚ÿÿ % U  # w     <   
  $   > <  . % % % U  # 	   %   = s   $ ; q   n U  # 	   %   = s 7  $ ; q   q   s    9 % % % U  # 	   %   = s   $ ; q   n U  #    % j 7 %   > !   = ! ?  q 8  s 9  $ ; q   q   s   $ ; s   $  7 # x  % M +  # 2  % U  # '   % u V .   	 % u  V /         $ %  : n u  V 1  !   '  $ ; s   $  % u V *   	 % U : U ; l   $ % u V ,   
 % U : U < l     % u  V '   
 % U : U = l     % u u   '  $  : # g  % M +  # 5  % U  # *   % u  V >    % % u  V 0  !  &       % % u  V 1  !   '  $   $ ; s   $  % u V ?   	 % U @ U A l   $ % u  V '   
 % U @ U B l     % u   '  $  @ # š  % M +  # h  % U  # ]   % u  V /    
  $ % % u  V 0  !  &   6 % % % U  #    % % u  V 0  s   $ ; q   n U  #    % % u  V 1  !   '  $ ; q   q   s     % % u  V 1  !   '  $ ; s   $  % u V ?   	 % U C U D l   $ % u  V '   
 % U C U E l     % u   '  $  C # Z  % g V ?   	 % U F U G l   $ % e V '   
 % U F U H l    7 % f e % M )  % # "  % e V /     $ % % f % e V 0  !  &  n e V 1  !   '  $ ! )     ,  , '  $  F # sÿþ % M +  # '  % j / e V     % u % j 0 e V I  q 9  % % j 1 e V I  !   '  $  $  % u V ?   	 % U J U K l   $   <  
 % U J U L l    # % #   % e V '  @ $ ! u  V    
 % U J U M l     % u   '  $  J # €ÿþ % M +  # >  % U  # 3   % % % U  #    % u l   $ ; q   n U  #    % u   0 ! u    '  $ ; q   q   s   $ ; s   $  %   <        = ! +  % u V N   	 % U O U P l   $ % e V N   
 % U O U Q l     % u e   '  $  O # ^  % M +  # >  % U  # 3   % % % U  #    % u  l   $ ; q   n U  #    % % u   &  !   '  $ ; q   q   s   $ ; s   $  % u V ?   	 % U R U S l   $ % u   '  $  R # ?  % e V '   	 % U T U U l   $ % Q e % M )  % #   % e V /     $ %  9 n e V 1  !   '  $ ! )     ,  , '  $  T % U V U W # ÿÿ % U V e U X U Y l   $ ! U  V    V # ¤ÿþ % M +  # X  % U  # M   % j / u  V     
  $ % % % U  #    % % u % j 0 u  V I  q 9  s   $ ; q   n U  #    % % j 1 u  V I  !   '  $ ; q   q   s   $ ; s   $  % u V ?   	 % U Z U [ l   $   <  
 % U Z U \ l    # % #   % e V '  @ $ ! u  V    
 % U Z U ] l     % u   '  $  Z % U ^ U _ # ÿÿ % U ^ e U ` U a l   $ ! U  V    ^ % U b U c # ÿÿ % U b e U d U e l   $ ! U  V    b % U f U g # ÿÿ % U f e U h U i l   $ ! U  V    f % U j U k # ÿÿ % U j e U l U m l   $ ! U  V    j % U n U o # ÿÿ % U n e U p U q l   $ ! U  V    n % U r U s # gÿü %  = n U t V u  n U v V u  n f V w  ! +  U V g f e  ; ; !  ; ! U x U / f  ; ; ! u U y h U 0 f  ; ; !  ; ; !  ; ! U z u g U 1 f  ; ; !  ; ; !   ; ; ; !  ; ; ; !  ; ; ; ; !  ; ; ; ; $ ! U  V    r % U z U { # ÿÿ % U z e U | U } l   $ ! U  V    z # Ãÿý % M +  # P  % U  # E   % u u   &   6 % % % U  #    % u l   $ ; q   n U  #    % u  0 ! u u u    '  $ ; q   q   s   $ 
  $ ; s   $  % u V N   	 % U ~ U  l   $ % u V N   
 % U ~ U € l    G % % u  V       =  
 u  a      ! +  % e V N   	 % U ~ U ‚ l   $ % Q  a  
 ƒ   
 „ ! +  % u u u  e   '  $ $ $  ~ # w  % f V '   	 % U … U † l   $ % e V *   
 % U … U ‡ l    T % e V ,   
 % U … U ˆ l    C % f e % M )  % # .  % f V /   	 % U … U ‰ l   $ % e V .    % f l 0    % % f V 1  !  : !   '  $ ! )     ,  , '  $  … # p  % M +  # N  % U  # C   % u V /      $ % % u V 1  n % % U  #    % % u V 0  s   $ ; q   n U  #      $ ; q   q   q   !   '  $ ; s   $  % u  V '   	 % U Š U ‹ l   $ % u  j   '  $  Š # ®  % M +  # z  % U  # o   % u  V /   ' % % % U  #    % u l   $ ; q   n U  #    
  $ ; q   q   s   $ % % % U  #    % u l   $ ; q   n U  #    % % u % u  V 0  !  &  n u  V 1  !   '  $ ; q   q   s   $ ; s   $  % u V ?   	 % U Œ U  l   $ % u  V '   
 % U Œ U Ž l     % u u   '  $  Œ #    % M +  # Z  % U  # O   % u  V /   	 % u V .       
  $ % % % U  #    % % u  V 0  s   $ ; q   n U  #    %  : n u  V 1  !   '  $ ; q   q   s   $ ; s   $  % u  V '   	 % U  U  l   $ % u V *   
 % U  U ‘ l     % u V ,   
 % U  U ’ l     % u u   '  $   #   % M +  # ^  % U  # S   % u  V /    
  $ % % u  V 0  !  &   6 % % % U  #    % % u  V 0  s   $ ; q   n U  #    % % u  V 1  !   '  $ ; q   q   s     
  $ ; s   $  % u  V '   	 % U “ U ” l   $ % u V ?   
 % U “ U • l     % u   '  $  “ # “  % M +  # O  % U  # D   % u   &   7 % % % U  #    % % u   &  s   $ ; q   n U  #    % % u   &  !   '  $ ; q   q   s   $ 
  $ ; s   $  % u V ?   	 % U – U — l   $ % u V ?   
 % U – U ˜ l     % u V ?   
 % U – U ™ l     % u   '  $  – #^  % M M M M +  #   % # 	   % u   '  $ ! # ÿÿ % e V %  : $ s š  $  # N  % U  # C   % # 	   % u   '  $ ! # /ÿþ % % % U  #    % u  l   $ ; q   n U  #    % u u  '  $ ; q   q   s   $ s š  $ ; s   $  # }  % U  # r   % % % u V 0  !   : q ›  ! +  % e V    4 % % % U  # 	   %   = s   $ ; q   n U  #    % % u V 1  ! u   '  $ ; q   q   s   $    % % u V 1  ! u   '     <   
    % U œ U  l   $ ; s   $  # D  % % u u   &  ! O % M )  % # $  % f V .    % j ž e l 9  $ %  : n u  f  &  !  ; !   '  $ ! )     ,  , '  $  % u V ?   	 % U œ U Ÿ l   $ % % u u   &  !  '  $  œ # Œÿÿ % M +  # R  % U  # G   % j / u  V     
  $ % % % U  #    % % j 0 u  V I  s   $ ; q   n U  #    % % j 1 u  V I  !   '  $ ; q   q   s   $ ; s   $    <  	 % U   U ¡ l   $ % #   % e V '  @ $ ! u  V    
 % U   U ¢ l     % u   '  $    % V £   J % S U  V ž  . % U ¤ V ¥  /
