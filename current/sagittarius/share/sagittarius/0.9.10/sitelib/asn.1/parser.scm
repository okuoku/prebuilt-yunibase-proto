;; This file is automatically generated by lalr.scm. DO NOT EDIT!!
(library
  (asn.1 parser)
  (export
    asn.1-parser
    make-lexical-token
    lexical-token?
    lexical-token-value
    lexical-token-category
    lexical-token-source
    make-source-location
    source-location?
    source-location-input
    source-location-line
    source-location-column)
  (import (rnrs) (asn.1 types) (srfi :1 lists))
  (define-record-type
    lexical-token
    (fields category source value))
  (define-record-type
    source-location
    (fields input line column offset length))
  (define *max-stack-size* 500)
  (define (lr-driver
           action-table
           goto-table
           reduction-table)
    (define ___atable action-table)
    (define ___gtable goto-table)
    (define ___rtable reduction-table)
    (define ___lexerp #f)
    (define ___errorp #f)
    (define ___stack #f)
    (define ___sp 0)
    (define ___curr-input #f)
    (define ___reuse-input #f)
    (define ___input #f)
    (define (___consume)
      (set! ___input
        (if ___reuse-input ___curr-input (___lexerp)))
      (set! ___reuse-input #f)
      (set! ___curr-input ___input))
    (define (___pushback) (set! ___reuse-input #t))
    (define (___initstack)
      (set! ___stack (make-vector *max-stack-size* 0))
      (set! ___sp 0))
    (define (___growstack)
      (let ((new-stack
              (make-vector (* 2 (vector-length ___stack)) 0)))
        (let loop ((i (- (vector-length ___stack) 1)))
          (if (>= i 0)
            (begin
              (vector-set! new-stack i (vector-ref ___stack i))
              (loop (- i 1)))))
        (set! ___stack new-stack)))
    (define (___checkstack)
      (if (>= ___sp (vector-length ___stack))
        (___growstack)))
    (define (___push delta new-category lvalue)
      (set! ___sp (- ___sp (* delta 2)))
      (let* ((state (vector-ref ___stack ___sp))
             (new-state
               (cdr (assoc new-category (vector-ref ___gtable state)))))
        (set! ___sp (+ ___sp 2))
        (___checkstack)
        (vector-set! ___stack ___sp new-state)
        (vector-set! ___stack (- ___sp 1) lvalue)))
    (define (___reduce st)
      ((vector-ref ___rtable st)
       ___stack
       ___sp
       ___gtable
       ___push
       ___pushback))
    (define (___shift token attribute)
      (set! ___sp (+ ___sp 2))
      (___checkstack)
      (vector-set! ___stack (- ___sp 1) attribute)
      (vector-set! ___stack ___sp token))
    (define (___action x l)
      (let ((y (assoc x l))) (if y (cadr y) (cadar l))))
    (define (___recover tok)
      (let find-state ((sp ___sp))
        (if (< sp 0)
          (set! ___sp sp)
          (let* ((state (vector-ref ___stack sp))
                 (act (assoc 'error (vector-ref ___atable state))))
            (if act
              (begin (set! ___sp sp) (___sync (cadr act) tok))
              (find-state (- sp 2)))))))
    (define (___sync state tok)
      (let ((sync-set
              (map car (cdr (vector-ref ___atable state)))))
        (set! ___sp (+ ___sp 4))
        (___checkstack)
        (vector-set! ___stack (- ___sp 3) #f)
        (vector-set! ___stack (- ___sp 2) state)
        (let skip ()
          (let ((i (___category ___input)))
            (if (eq? i '*eoi*)
              (set! ___sp -1)
              (if (memq i sync-set)
                (let ((act (assoc i (vector-ref ___atable state))))
                  (vector-set! ___stack (- ___sp 1) #f)
                  (vector-set! ___stack ___sp (cadr act)))
                (begin (___consume) (skip))))))))
    (define (___category tok)
      (if (lexical-token? tok)
        (lexical-token-category tok)
        tok))
    (define (___value tok)
      (if (lexical-token? tok)
        (lexical-token-value tok)
        tok))
    (define (___run)
      (let loop ()
        (if ___input
          (let* ((state (vector-ref ___stack ___sp))
                 (i (___category ___input))
                 (attr (___value ___input))
                 (act (___action i (vector-ref ___atable state))))
            (cond ((not (symbol? i))
                   (___errorp
                     "Syntax error: invalid token: "
                     ___input)
                   #f)
                  ((eq? act 'accept) (vector-ref ___stack 1))
                  ((eq? act '*error*)
                   (if (eq? i '*eoi*)
                     (begin
                       (___errorp
                         "Syntax error: unexpected end of input")
                       #f)
                     (begin
                       (___errorp
                         "Syntax error: unexpected token : "
                         ___input)
                       (___recover i)
                       (if (>= ___sp 0)
                         (set! ___input #f)
                         (begin (set! ___sp 0) (set! ___input '*eoi*)))
                       (loop))))
                  ((>= act 0)
                   (___shift act attr)
                   (set! ___input (if (eq? i '*eoi*) '*eoi* #f))
                   (loop))
                  (else (___reduce (- act)) (loop))))
          (let* ((state (vector-ref ___stack ___sp))
                 (acts (vector-ref ___atable state))
                 (defact (if (pair? acts) (cadar acts) #f)))
            (if (and (= 1 (length acts)) (< defact 0))
              (___reduce (- defact))
              (___consume))
            (loop)))))
    (lambda (lexerp errorp)
      (set! ___errorp errorp)
      (set! ___lexerp lexerp)
      (___initstack)
      (___run)))
  (define asn.1-parser
    (lr-driver
      '#(((*default* -52)
          (WORD 3)
          (CLASS 2)
          (COMPONENTS 1)
          (*eoi* -37))
         ((*default* *error*) (OF 11))
         ((*default* -53))
         ((*default* -52) (CLASS 2) (ASSIGN 12))
         ((*default* -54) (IMPLICIT 15) (EXPLICIT 14))
         ((*default* -40))
         ((*default* -38) (COMMA 18) (POSTRBRACE 17))
         ((*default* -2))
         ((*default* -48))
         ((*default* -3) (WORD 19))
         ((*default* *error*) (*eoi* 20))
         ((*default* *error*) (WORD 21))
         ((*default* -52) (CLASS 2) (COMPONENTS 1))
         ((*default* -54) (IMPLICIT 15) (EXPLICIT 14))
         ((*default* -55))
         ((*default* -56))
         ((*default* *error*)
          (SEQUENCE 28)
          (SET 27)
          (CHOICE 26))
         ((*default* -52)
          (WORD 30)
          (CLASS 2)
          (COMPONENTS 1)
          (RBRACE -39)
          (*eoi* -39))
         ((*default* -52)
          (WORD 30)
          (CLASS 2)
          (COMPONENTS 1))
         ((*default* *error*) (ASSIGN 33))
         ((*default* -1) (*eoi* accept))
         ((*default* -12))
         ((*default* -54) (IMPLICIT 15) (EXPLICIT 14))
         ((*default* -7))
         ((*default* -4))
         ((*default* *error*)
          (WORD 39)
          (SEQUENCE 38)
          (SET 37)
          (CHOICE 26)
          (ANY 36)
          (ENUM 35))
         ((*default* *error*) (LBRACE 47))
         ((*default* *error*) (LBRACE 48))
         ((*default* *error*) (LBRACE 49))
         ((*default* -49))
         ((*default* -52) (CLASS 2))
         ((*default* -42))
         ((*default* -41))
         ((*default* -52) (CLASS 2) (COMPONENTS 1))
         ((*default* *error*)
          (WORD 39)
          (SEQUENCE 38)
          (SET 37)
          (CHOICE 26)
          (ANY 36)
          (ENUM 35))
         ((*default* -27) (LBRACE 56))
         ((*default* -28) (DEFINED 57))
         ((*default* -25) (LBRACE 48) (OF -14))
         ((*default* -24) (LBRACE 49) (OF -13))
         ((*default* -23))
         ((*default* -47))
         ((*default* -50) (OPTIONAL 59))
         ((*default* -30))
         ((*default* -44))
         ((*default* -46))
         ((*default* -45))
         ((*default* *error*) (OF 61))
         ((*default* *error*) (WORD 62))
         ((*default* -52)
          (WORD 30)
          (CLASS 2)
          (COMPONENTS 1)
          (RBRACE -37))
         ((*default* -52)
          (WORD 30)
          (CLASS 2)
          (COMPONENTS 1)
          (RBRACE -37))
         ((*default* -5))
         ((*default* -10))
         ((*default* -9))
         ((*default* -8))
         ((*default* -11))
         ((*default* -60) (POSTRBRACE 68))
         ((*default* *error*) (WORD 70))
         ((*default* *error*) (BY 73))
         ((*default* -26))
         ((*default* -51))
         ((*default* -43))
         ((*default* -52) (CLASS 2))
         ((*default* -52) (CLASS 2))
         ((*default* -33))
         ((*default* -31) (COMMA 77) (POSTRBRACE 76))
         ((*default* *error*) (RBRACE 78))
         ((*default* *error*) (RBRACE 79))
         ((*default* *error*) (RBRACE 80))
         ((*default* -61))
         ((*default* -6))
         ((*default* *error*) (NUMBER 81))
         ((*default* -57))
         ((*default* *error*) (RBRACE 83) (COMMA 82))
         ((*default* *error*) (WORD 84))
         ((*default* -54) (IMPLICIT 15) (EXPLICIT 14))
         ((*default* -54) (IMPLICIT 15) (EXPLICIT 14))
         ((*default* -32) (WORD 62))
         ((*default* *error*) (WORD 62))
         ((*default* -21))
         ((*default* -20))
         ((*default* -19))
         ((*default* -59))
         ((*default* *error*) (WORD 70))
         ((*default* -22))
         ((*default* -29))
         ((*default* *error*)
          (WORD 39)
          (SEQUENCE 91)
          (SET 90)
          (CHOICE 26)
          (ANY 36)
          (ENUM 35))
         ((*default* *error*)
          (WORD 39)
          (SEQUENCE 38)
          (SET 37)
          (CHOICE 26)
          (ANY 36)
          (ENUM 35))
         ((*default* -34))
         ((*default* -35))
         ((*default* -58))
         ((*default* -25) (LBRACE 48))
         ((*default* -24) (LBRACE 49))
         ((*default* -17))
         ((*default* -16))
         ((*default* -18))
         ((*default* -50) (OPTIONAL 59))
         ((*default* -36))
         ((*default* -15)))
      (vector
        '((22 . 4)
          (20 . 5)
          (18 . 6)
          (17 . 7)
          (5 . 8)
          (2 . 9)
          (1 . 10))
        '()
        '()
        '((22 . 13))
        '((23 . 16))
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '((22 . 22) (5 . 23) (3 . 24))
        '((23 . 25))
        '()
        '()
        '((9 . 29))
        '((22 . 4) (20 . 31) (5 . 8))
        '((22 . 4) (20 . 32) (5 . 8))
        '()
        '()
        '()
        '((23 . 34))
        '()
        '()
        '((19 . 40)
          (13 . 41)
          (11 . 42)
          (10 . 43)
          (9 . 44)
          (7 . 45)
          (6 . 46))
        '()
        '()
        '()
        '()
        '((22 . 13))
        '()
        '()
        '((22 . 22) (5 . 23) (3 . 50))
        '((13 . 51)
          (11 . 42)
          (10 . 52)
          (9 . 53)
          (7 . 54)
          (6 . 46)
          (4 . 55))
        '()
        '((12 . 58))
        '()
        '()
        '()
        '()
        '((21 . 60))
        '()
        '()
        '()
        '()
        '()
        '((16 . 63) (15 . 64) (14 . 65))
        '((22 . 4) (20 . 5) (18 . 6) (17 . 66) (5 . 8))
        '((22 . 4) (20 . 5) (18 . 6) (17 . 67) (5 . 8))
        '()
        '()
        '()
        '()
        '()
        '((26 . 69))
        '((25 . 71) (24 . 72))
        '()
        '()
        '()
        '()
        '((22 . 74))
        '((22 . 75))
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '((23 . 85))
        '((23 . 86))
        '((16 . 87))
        '((16 . 88))
        '()
        '()
        '()
        '()
        '((25 . 89))
        '()
        '()
        '((13 . 92) (11 . 42) (10 . 93) (9 . 94) (8 . 95))
        '((13 . 51)
          (11 . 42)
          (10 . 52)
          (9 . 53)
          (7 . 54)
          (6 . 46)
          (4 . 96))
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '()
        '((21 . 97))
        '()
        '())
      (vector
        '()
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($2 (vector-ref ___stack (- ___sp 1)))
                 ($1 (vector-ref ___stack (- ___sp 3))))
            $1))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 1 (list (cons '() $1)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 1 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 2 (list (cons $1 (list $3))))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              2
              (cond ((assoc $2 $1)
                     =>
                     (lambda (slot) (set-cdr! slot (list $4)) $1))
                    (else (append! $1 (list (list $2 $4))))))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              3
              (begin
                (asn.1-type-tag-set! $3 $1)
                (if $2 (tag-explicit! $3) $3)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 3 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 4 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 4 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 4 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 4 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push
              3
              5
              (make-asn.1-type :type $1 :child $3))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 6 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 6 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($6 (vector-ref ___stack (- ___sp 1)))
                 ($5 (vector-ref ___stack (- ___sp 3)))
                 ($4 (vector-ref ___stack (- ___sp 5)))
                 ($3 (vector-ref ___stack (- ___sp 7)))
                 ($2 (vector-ref ___stack (- ___sp 9)))
                 ($1 (vector-ref ___stack (- ___sp 11))))
            (___push
              6
              7
              (begin
                (asn.1-type-tag-set! $5 $3)
                (let ((ret (make-asn.1-type
                             :type
                             $1
                             :child
                             (list $5)
                             :loop
                             #t
                             :optional
                             $6)))
                  (if $4 (tag-explicit! ret) ret))))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 8 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 8 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 8 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              9
              (make-asn.1-type :type $1 :child $3))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              9
              (make-asn.1-type :type $1 :child $3))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              9
              (make-asn.1-type :type $1 :child $3))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push 4 10 (make-asn.1-type :type $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 11 (make-asn.1-type :type $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 11 (make-asn.1-type :type $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 11 (make-asn.1-type :type $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($2 (vector-ref ___stack (- ___sp 1)))
                 ($1 (vector-ref ___stack (- ___sp 3))))
            (___push
              2
              11
              (make-asn.1-type
                :type
                $1
                :child
                #f
                :defined-by
                $2))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 11 (make-asn.1-type :type $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 0 12 '())))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 12 $3)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 13 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 14 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($2 (vector-ref ___stack (- ___sp 1)))
                 ($1 (vector-ref ___stack (- ___sp 3))))
            (___push 2 14 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 15 (list $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 15 (append! $1 (list $3)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 15 (append! $1 (list $3)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              16
              (let ((ret $4))
                (asn.1-type-name-set! ret $1)
                (asn.1-type-tag-set! ret $2)
                (if $3 (tag-explicit! ret) ret)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 0 17 '())))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 17 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($2 (vector-ref ___stack (- ___sp 1)))
                 ($1 (vector-ref ___stack (- ___sp 3))))
            (___push 2 17 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 18 (list $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 18 (append! $1 (list $3)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 18 (append! $1 (list $3)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($2 (vector-ref ___stack (- ___sp 1)))
                 ($1 (vector-ref ___stack (- ___sp 3))))
            (___push
              2
              19
              (begin (asn.1-type-optional-set! $1 $2) $1))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 19 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 19 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 19 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($4 (vector-ref ___stack (- ___sp 1)))
                 ($3 (vector-ref ___stack (- ___sp 3)))
                 ($2 (vector-ref ___stack (- ___sp 5)))
                 ($1 (vector-ref ___stack (- ___sp 7))))
            (___push
              4
              20
              (let ((ret $4))
                (asn.1-type-name-set! ret $1)
                (asn.1-type-tag-set! ret $2)
                (if $3 (tag-explicit! ret) ret)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 20 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push
              3
              20
              (let ((ret $3))
                (asn.1-type-tag-set! $1)
                (if $2 (tag-explicit! ret) ret)))))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 0 21 #f)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 21 #t)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 0 22 #f)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 22 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 0 23 #f)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 23 #t)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 1 23 #f)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 24 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($3 (vector-ref ___stack (- ___sp 1)))
                 ($2 (vector-ref ___stack (- ___sp 3)))
                 ($1 (vector-ref ___stack (- ___sp 5))))
            (___push 3 24 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($2 (vector-ref ___stack (- ___sp 1)))
                 ($1 (vector-ref ___stack (- ___sp 3))))
            (___push 2 25 $1)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* () (___push 0 26 #f)))
        (lambda (___stack ___sp ___goto-table ___push yypushback)
          (let* (($1 (vector-ref ___stack (- ___sp 1))))
            (___push 1 26 $1)))))))

