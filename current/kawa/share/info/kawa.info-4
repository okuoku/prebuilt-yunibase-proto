This is kawa.info, produced by makeinfo version 6.8 from kawa.texi.

START-INFO-DIR-ENTRY
* kawa: (kawa).         The Kawa Scheme language
END-INFO-DIR-ENTRY


File: kawa.info,  Node: Formatting XML,  Next: Creating HTML nodes,  Up: XML tools

20.1 Formatting XML
===================

The easiest way to generate HTML or XML output is to run Kawa with the
appropriate *note ‘--output-format’ option: Named output formats.

   The intentation is that these output modes should be compatible with
XSLT 2.0 and XQuery 1.0 Serialization
(http://www.w3.org/TR/2006/PR-xslt-xquery-serialization-20061121/).
(However, that specifies many options, most of which have not yet been
implemented.

‘xml’
     Values are printed in XML format.  "Groups" or "elements" are
     written as using xml element syntax.  Plain characters (such as
     ‘<’) are escaped (such as ‘&lt;’).
‘xhtml’
     Same as ‘xml’, but follows the xhtml compatibility guidelines.
‘html’
     Values are printed in HTML format.  Mostly same as ‘xml’ format,
     but certain elements without body, are written without a closing
     tag.  For example ‘<img>’ is written without ‘</img>’, which would
     be illegal for html, but required for xml.  Plain characters (such
     as ‘<’) are not escaped inside ‘<script>’ or ‘<style>’ elements.

   To illustrate:
     $ kawa --output-format html
     #|kawa:1|# (html:img src:"img.jpg")
     <img src="img.jpg">
     $ kawa --output-format xhtml
     #|kawa:1|# (html:img src:"img.jpg")
     <img xmlns="http://www.w3.org/1999/xhtml" src="img.jpg" />
     $ kawa --output-format xml
     #|kawa:1|# (html:img src:"img.jpg")
     <img xmlns="http://www.w3.org/1999/xhtml" src="img.jpg"></img>
   And here is the default ‘scheme’ formatting:
     $ kawa
     #|kawa:1|# (html:img src:"img.jpg")
     ({http://www.w3.org/1999/xhtml}img src: img.jpg )

 -- Procedure: as-xml value
     Return a value (or multiple values) that when printed will print
     VALUE in XML syntax.
          (require 'xml)
          (as-xml (make-element 'p "Some " (make-element 'em "text") "."))
     prints ‘<p>Some <em>text</em>.</p>’.

 -- Procedure: unescaped-data data
     Creates a special value which causes ‘data’ to be printed, as is,
     without normal escaping.  For example, when the output format is
     XML, then printing ‘"<?xml?>"’ prints as ‘&lt;?xml?&gt;’, but
     ‘(unescaped-data "<?xml?>")’ prints as ‘<?xml?>’.


File: kawa.info,  Node: Creating HTML nodes,  Next: Creating XML nodes,  Prev: Formatting XML,  Up: XML tools

20.2 Creating HTML nodes
========================

The ‘html’ prefix names a special namespace (*note Namespaces::) of
functions to create HTML element nodes.  For example, ‘html:em’ is a
constructor that when called creates a element node whose tag is ‘em’.
If this element node is formatted as HTML, the result has an ‘<em>’ tag.

 -- Syntax: html:TAG attributes ... content ...
     Creates an element node whose tag is TAG.  The parameters are first
     zero or more attributes, followed by zero of more child values.  An
     attribute is either an attribute value (possibly created using
     ‘make-attribute’), or a pair of arguments: A keyword followed by
     the attribute value.  Child values are usually either strings (text
     content), or nested element nodes, but can also be comment or
     processing-instruction nodes.
          (html:a href: "http://gnu.org/" "the "(html:i "GNU")" homepage")

   The compound identifier ‘html:TAG’ is actually a type: When you call
it as a function you’re using Kawa’s standard coercion of a type to its
constructor function.  This means you can do type tests:
     (define some-node ...)
     (if (instance? some-node html:blink)
       (error "blinking not allowed!"))

   Object identity is currently not fully specified.  Specifically, it
is undefined if a nested (child) element node is copied “by value” or
“by reference”.  This is related to whether nodes have a parent
reference.  In the XPath/XQuery data model nodes do have a parent
reference, and child nodes are conceptually copied.  (In the actual
implemention copying is commonly avoided.)  Kawa/Scheme currently
followed the XQuery copying semantics, which may not be the most
appropriate for Scheme.


File: kawa.info,  Node: Creating XML nodes,  Next: XML literals,  Prev: Creating HTML nodes,  Up: XML tools

20.3 Creating XML nodes
=======================

The XML data model is similar to HTML, with one important addition: XML
tags may be “qualified names”, which are similar to *note compound
symbols: Namespaces.

   You must do this to use the following types and functions:
     (require 'xml)

   The following types and functions assume:
     (require 'xml)

 -- Procedure: make-element tag [attribute ...] child ...
     Create a representation of a XML element, corresponding to
          <TAG ATTRIBUTE...>CHILD...</TAG>
     The result is a ‘TreeList’, though if the result context is a
     consumer the result is instead "written" to the consumer.  Thus
     nested calls to ‘make-element’ only result in a single ‘TreeList’.
     More generally, whether an ATTRIBUTE or CHILD is includded by
     copying or by reference is (for now) undefined.  The TAG should
     currently be a symbol, though in the future it should be a
     qualified name.  An ATTRIBUTE is typically a call to
     ‘make-attribute’, but it can be any attribute-valued expression.
          (make-element 'p
          	      "The time is now: "
          	      (make-element 'code (make <java.util.Date>)))

 -- Procedure: element-name element
     Returns the name (tag) of the element node, as a symbol (QName).

 -- Procedure: make-attribute name value...
     Create an "attribute", which is a name-value pair.  For now, NAME
     should be a symbol.

 -- Procedure: attribute-name element
     Returns the name of the attribute node, as a symbol (QName).

 -- Type: comment
     Instances of this type represent comment values, specifically
     including comments in XML files.  Comment nodes are currently
     ignored when printing using Scheme formatting, though that may
     change.
 -- Constructor: comment comment-text
     Create a comment object with the specified COMMENT-TEXT.

 -- Type: processing-instruction
     Instances of this type represent “processing instructions”, such as
     may appear in XML files.  Processing-instruction nodes are
     currently ignored when printing using Scheme formatting, though
     that may change.
 -- Constructor: processing-instruction target contents
     Crreate a processing-instruction object with the specified TARGET
     (a simple symbol) and CONTENTS (a string).


File: kawa.info,  Node: XML literals,  Next: Server-side scripts,  Prev: Creating XML nodes,  Up: XML tools

20.4 XML literals
=================

You can write XML literals directly in Scheme code, following a ‘#’.
Notice that the outermost element needs to be prefixed by ‘#’, but
nested elements do not (and must not).
     #<p>The result is <b>final</b>!</p>

   Actually, these are not really literals since they can contain
enclosed expressions:
     #<em>The result is &{result}.</em>
   The value of RESULT is substituted into the output, in a similar way
to quasi-quotation.  (If you try to quote one of these “XML literals”,
what you get is unspecified and is subject to change.)

   An XML-LITERAL is usually an element constructor, but there some
rarely used forms (processing-instructions, comments, and CDATA section)
we’ll cover later.

     XML-LITERAL ::= ‘#’XML-CONSTRUCTOR
     XML-CONSTRUCTOR ::= XML-ELEMENT-CONSTRUCTOR
       | XML-PI-CONSTRUCTOR
       | XML-COMMENT-CONSTRUCTOR
       | XML-CDATA-CONSTRUCTOR

20.4.1 Element constructors
---------------------------

     XML-ELEMENT-CONSTRUCTOR ::=
         ‘<’QNAME XML-ATTRIBUTE*‘>’XML-ELEMENT-DATUM...‘</’QNAME ‘>’
       | ‘<’XML-NAME-FORM XML-ATTRIBUTE*‘>’XML-ELEMENT-DATUM...‘</>’
       | ‘<’XML-NAME-FORM XML-ATTRIBUTE*‘/>’
     XML-NAME-FORM ::= QNAME
       | XML-ENCLOSED-EXPRESSION
     XML-ENCLOSED-EXPRESSION ::=
         ‘{’EXPRESSION‘}’
       | ‘(’EXPRESSION...‘)’

   The first XML-ELEMENT-CONSTRUCTOR variant uses a literal QNAME, and
looks like standard non-empty XML element, where the starting QNAME and
the ending QNAME must match exactly:

     #<a href="next.html">Next</a>

   As a convenience, you can leave out the ending tag(s):
     #<p>This is a paragraph in <emphasis>DocBook</> syntax.</>

   You can use an expression to compute the element tag at runtime - in
that case you _must_ leave out the ending tag:
     #<p>This is <(if be-bold 'strong 'em)>important</>!</p>

   You can use arbitrary EXPRESSION inside curly braces, as long as it
evaluates to a symbol.  You can leave out the curly braces if the
EXPRESSION is a simple parenthesised compound expression.  The previous
example is equivalent to:
     #<p>This is <{(if be-bold 'strong 'em)}>important</>!</p>

   The third XML-ELEMENT-CONSTRUCTOR variant above is an XML “empty
element”; it is equivalent to the second variant when there are no
XML-ELEMENT-DATUM items.

   (Note that every well-formed XML element, as defined in the XML
specifications, is a valid XML-ELEMENT-CONSTRUCTOR, but not vice versa.)

20.4.2 Elements contents (children)
-----------------------------------

The “contents” (children) of an element are a sequence of character
(text) data, and nested nodes.  The characters ‘&’, ‘<’, and ‘>’ are
special, and need to be escaped.

     XML-ELEMENT-DATUM ::=
         any character except ‘&’, or ‘<’.
       | XML-CONSTRUCTOR
       | XML-ESCAPED
     XML-ESCAPED ::=
         ‘&’XML-ENCLOSED-EXPRESSION
       | ‘&’XML-ENTITY-NAME‘;’
       | XML-CHARACTER-REFERENCE
     XML-CHARACTER-REFERENCE ::=
         ‘&#’DIGIT+‘;’
       | ‘&#x’HEX-DIGIT+‘;’

   Here is an example shows both hex and decimal character references:
     #<p>A&#66;C&#x44;E</p>  ⇒  <p>ABCDE</p>

     XML-ENTITY-NAME ::= IDENTIFIER
   Currently, the only supported values for XML-ENTITY-NAME are the
builtin XML names ‘lt’, ‘gt’, ‘amp’, ‘quot’, and ‘apos’, which stand for
the characters ‘<’, ‘>’, ‘&’, ‘"’, and ‘'’, respectively.  The following
two expressions are equivalent:
     #<p>&lt; &gt; &amp; &quot; &apos;</p>
     #<p>&{"< > & \" '"}</p>

20.4.3 Attributes
-----------------

     XML-ATTRIBUTE ::=
         XML-NAME-FORM‘=’XML-ATTRIBUTE-VALUE
     XML-ATTRIBUTE-VALUE ::=
         ‘"’QUOT-ATTRIBUTE-DATUM*‘"’
       | ‘’’APOS-ATTRIBUTE-DATUM*‘’’
     QUOT-ATTRIBUTE-DATUM ::=
         any character except ‘"’, ‘&’, or ‘<’.
       | XML-ESCAPED
     APOS-ATTRIBUTE-DATUM ::=
         any character except ‘'’, ‘&’, or ‘<’.
       | XML-ESCAPED

   If the XML-NAME-FORM is either ‘xmlns’ or a compound named with the
prefix ‘xmlns’, then technically we have a namespace declaration, rather
than an attribute.

20.4.4 QNames and namespaces
----------------------------

The names of elements and attributes are “qualified names” (QNames),
which are represented using compound symbols (*note Namespaces::).  The
lexical syntax for a QName is either a simple identifier, or a
(prefix,local-name) pair:

     QNAME ::= XML-LOCAL-PART
        | XML-PREFIX‘:’XML-LOCAL-PART
     XML-LOCAL-PART ::= IDENTIFIER
     XML-PREFIX ::= IDENTIFIER

   An XML-PREFIX is an alias for a namespace-uri, and the mapping
between them is defined by a namespace-declaration.  You can either use
a ‘define-namespace’ form, or you can use a “namespace declaration
attribute”:

     XML-NAMESPACE-DECLARATION-ATTRIBUTE ::=
         ‘xmlns:’XML-PREFIX‘=’XML-ATTRIBUTE-VALUE
       | ‘xmlns=’XML-ATTRIBUTE-VALUE

   The former declares XML-PREFIX as a namespace alias for the
namespace-uri specified by XML-ATTRIBUTE-VALUE (which must be a
compile-time constant).  The second declares that XML-ATTRIBUTE-VALUE is
the default namespace for simple (unprefixed) element tags.  (A default
namespace declaration is ignored for attribute names.)

     (let ((qn (element-name #<gnu:b xmlns:gnu="http://gnu.org/"/>)))
       (list (symbol-local-name qn)
             (symbol-prefix qn)
             (symbol-namespace-uri qn)))
     ⇒ ("b" "gnu" "http://gnu.org/")


20.4.5 Other XML types
----------------------

20.4.5.1 Processing instructions
................................

An XML-PI-CONSTRUCTOR can be used to create an XML “processing
instruction”, which can be used to pass instructions or annotations to
an XML processor (or tool).  (Alternatively, you can use the
‘processing-instruction’ type constructor.)

     XML-PI-CONSTRUCTOR ::= ‘<?’XML-PI-TARGET XML-PI-CONTENT‘?>’
     XML-PI-TARGET ::= NCNAME (i.e. a simple (non-compound) identifier)
     XML-PI-CONTENT ::= any characters, not containing ‘?>’.

   For example, the DocBook XSLT stylesheets can use the ‘dbhtml’
instructions to specify that a specific chapter should be written to a
named HTML file:
     #<chapter><?dbhtml filename="intro.html" ?>
     <title>Introduction</title>
     ...
     </chapter>

20.4.5.2 XML comments
.....................

You can cause XML comments to be emitted in the XML output document.
Such comments can be useful for humans reading the XML document, but are
usually ignored by programs.  (Alternatively, you can use the ‘comment’
type constructor.)

     XML-COMMENT-CONSTRUCTOR ::= ‘<!–’XML-COMMENT-CONTENT‘–>’
     XML-COMMENT-CONTENT ::= any characters, not containing ‘--’.

20.4.5.3 CDATA sections
.......................

A ‘CDATA’ section can be used to avoid excessive use of XML-ENTITY-REF
such as ‘&amp;’ in element content.

     XML-CDATA-CONSTRUCTOR ::= ‘<![CDATA[’XML-CDATA-CONTENT‘]]>’
     XML-CDATA-CONTENT ::= any characters, not containing ‘]]>’.

   The following are equivalent:
     #<p>Specal characters <![CDATA[< > & ' "]]> here.</p>
     #<p>Specal characters &lt; &gt; &amp; &quot; &apos; here.</p>

   Kawa remembers that you used a ‘CDATA’ section in the
XML-ELEMENT-CONSTRUCTOR and will write it out using a ‘CDATA’
constructor.


File: kawa.info,  Node: Server-side scripts,  Next: Self-configuring page scripts,  Prev: XML literals,  Up: XML tools

20.5 Web page scripts
=====================

A Kawa “web page script” is a Kawa program that is invoked by a web
server because the server received an HTTP request.  The result of
evaluating the top-level expressions becomes the HTTP response that the
servlet sends back to the client, usually a browser.

   A web page script may be as simple as:
     (format "The time is <~s>." (java.util.Date))
   This returns a response of consisting of a formatted string giving
the current time.  The string would interpreted as ‘text/plain’ content:
The angle brackets are regular characters, and not HTML tag markers.

   The script can alternatively evaluate to XML/HTML node values, for
example those created by *note XML literals:::
     #<p>Hello, <b>&(request-remote-host)</b>!</p>
   In this case the response would be ‘text/html’ or similar content:
The angle brackets should be interpreted by the browser as HTML tag
markers.  The function ‘request-remote-host’ is available
(automatically) to web page scripts; it returns the host that made the
HTTP request, which is then interpolated into the response.

   Following sections will go into more details about how to write web
page scripts.  You can do so in any supported Kawa language, including
Scheme, BRL, KRL, or XQuery.

   A web server will use a URL mapping to map a request URL to a
specific web page script.  This can be done in a number of different
ways:
   • The easiest to manage is to use Kawa’s mechanism for *note
     Self-configuring page scripts::.  Ths is especially easy if you the
     web server built in to JDK 6, since no configuration files are
     needed.  You can also use a “servlet engine” like Tomcat or
     Glassfish.

   • You can explicitly compile the web page script to a servlet, in the
     same way Java servlets are compiled.  This can then be installed
     ("deployed") in a servlet-supporting web server, such a Tomcat or
     Glassfish.  *Note Servlets::.
   • You can run the servlet as a *note CGI script: CGI scripts.

   For details on how to extract information from the request see *note
HTTP requests::.  For details on how the response is created see *note
Generating HTTP responses: HTTP response.  If the response is HTML or
XML, you may want to read *note Creating HTML nodes::, or *note Creating
XML nodes::, or *note XML literals::.

   Here are some examples, starting with a simple ‘hello.scm’:
     (response-content-type 'text/html) ; Optional
     (html:p
       "The request URL was: " (request-url))
     (make-element 'p
       (let ((query (request-query-string)))
         (if query
           (values-append "The query string was: " query)
           "There was no query string.")))
   This returns two ‘<p>’ (paragraph) elements: One using ‘make-element’
and one using the ‘html:p’ constructor.  Or you may prefer to use *note
XML literals::.

   The same program using KRL:
     <p>The request URL was: [(request-url)]</p>,
     <p>[(let ((query (request-query-string)))
         (if query
           (begin ]The query string was: [query)

           ]There was no query string.[))]</p>

   You can also use XQuery:
     <p>The request URL was: {request-url()}</p>
     <p>{let $query := request-query-string() return
         if ($query)
         then ("The query string was: ",$query)
         else "There was no query string."}</p>

   The ‘+default+’ script in the ‘doc’ directory is useful for reading
the Kawa documentation using a browser.  The script uses the ‘jar:’ URL
scheme to automatically extract and uncompress the pages from
‘doc/kawa-manual.epub’, which is in EPUB3 format.  Read the script for
usage instructions.


File: kawa.info,  Node: Self-configuring page scripts,  Next: Servlets,  Prev: Server-side scripts,  Up: XML tools

20.6 Self-configuring web page scripts
======================================

Kawa makes it easy to set up a web site without configuration files.
Instead, the mapping from request URL to web page script matches the
layout of files in the application directory.

   Many web servers make it easy to execute a script using a script
processor which is selected depending on the extension of the requested
URL. That is why you see lots of URLs that end in ‘.cgi’, ‘.php’, or
‘.jsp’.  This is bad, because it exposes the server-side implementation
to the user: Not only are such URLs ugly, but they make it difficult to
change the server without breaking people’s bookmarks and search
engines.  A server will usually provide a mechanism to use prettier
URLs, but doing so requires extra effort, so many web-masters don’t.

   If you want a script to be executed in response to a URL
‘http://host/app/foo/bar’ you give the script the name ‘app/foo/bar’, in
the appropriate server “application” directory (as explained below).
You get to pick the name ‘bar’.  Or you can use the name ‘bar.html’,
even though the file named ‘bar.html’ isn’t actually an html file -
rather it produces html when evaluated.  Or better: just use a name
without an extension at all.  Kawa figures out what kind of script it is
based on the content of the file, rather than the file name.  Once Kawa
has found a script, it looks at the first line to see if it can
recognize the kind (language) of the script.  Normally this would be a
comment that contains the name of a programming language that Kawa knows
about.  For example:
     ;; Hello world page script written in -*- scheme -*-
     #<p>Hello, <b>&(request-remote-host)</b>!</p>
   (Using the funny-looking string ‘-*- scheme -*-’ has the bonus is
that it recognized by the Emacs text editor.)

   A script named ‘+default+’ is run if there isn’t a matching script.
For example assume the following is a file named ‘+default’.
     ;; This is -*- scheme -*-
     (make-element 'p "servlet-path: " (request-servlet-path))
   This becomes the default script for HTTP requests that aren’t handled
by a more specific script.  The ‘request-servlet-path’ function returns
the "servlet path", which is the part of the requested URL that is
relative to the current web application.  Thus a request for
‘http://host:port/app/this/is/a/test’ will return:
     servlet-path: /this/is/a/test

   You can use the feature variable ‘in-http-server’ in a ‘cond-expand’
to test if the code is executing in a web server.

20.6.1 Using the OpenJDK built-in web server
--------------------------------------------

The easiest way to run a Kawa web server is to use the web server built
in to JDK 6 or later.

     kawa --http-auto-handler CONTEXT-PATH APPDIR --http-start PORT

   This starts a web server that listens on the given PORT, using the
files in directory APPDIR to handle requests that start with the given
CONTEXT-PATH.  The CONTEXT-PATH must start with a ‘"/"’ (one is added if
needed), and it is recommended that it also end with a ‘"/"’ (otherwise
you might get some surprising behavior).

   You can specify multiple ‘--http-auto-handler’ options.

   For example use the files in the current directory to handle all
requests on the standard port 80 do:
     kawa --http-auto-handler / . --http-start 80

   There are some examples in the ‘testsuite/webtest’ directory the Kawa
source distribution.  You can start the server thus:
     bin/kawa --http-auto-handler / testsuite/webtest/ --http-start 8888
   and then for example browse to ‘http://localhost:8888/adder.scm’.

   For lots of information about the HTTP request, browse to
‘http://localhost:8888/info/ANYTHING’.

20.6.2 Using a servlet container
--------------------------------

You can also can use a “servlet container” such as Tomcat or Glassfish
with self-configuring script.  See *note Servlets:: for information on
how to install these servers, and the concept of web applications.  Once
you have these server installed, you create a web application with the
following in the ‘APPDIR/WEB-INF/web.xml’ configuration file:
     <web-app>
       <display-name>Kawa auto-servlet</display-name>
       <servlet>
         <servlet-name>KawaPageServlet</servlet-name>
         <servlet-class>gnu.kawa.servlet.KawaPageServlet</servlet-class>
       </servlet>
       <servlet-mapping>
         <servlet-name>KawaPageServlet</servlet-name>
         <url-pattern>/*</url-pattern>
       </servlet-mapping>
     </web-app>
   This creates a web application where all URLs are handled by the
‘gnu.kawa.servlet.KawaPageServlet’ servlet class, which is included in
the Kawa jar file.  The ‘KawaPageServlet’ class handles the searching
and compiling described in this page.

20.6.3 Finding a matching script
--------------------------------

When Kawa receives a request for:
     http://host:port/appname/a/b/anything
   it will look for a file:
     APPDIR/a/b/anything

   If such a file exists, the script will be executed, as described
below.  If not, it will look for a file name ‘+default+’ in the same
directory.  If that desn’t exist either, it will look for ‘+default+’ in
the parent directory, then the grand-parent directory, and so on until
it gets to the appname web application root directory.  So the default
script is this: ‘APPDIR/+default’.

   If that doesn’t exist then Kawa returns a 404 "page not found" error.

20.6.4 Determining script language
----------------------------------

Once Kawa has found a script file corresponding to a request URL, it
needs to determine if this is a data file or a web page script, and in
the latter case, what language it is written in.

   Kawa recognizes the following "magic strings" in the first line of a
script:

‘kawa:scheme’
     The Scheme language.

‘kawa:xquery’
     The XQuery language.

‘kawa:LANGUAGE’
     Some other language known to Kawa.

   Kawa also recognizes Emacs-style "mode specifiers":

‘-*- scheme -*-’
     The Scheme language.
‘-*- xquery -*-’
     The XQuery language (though Emacs doesn’t know about XQuery).
‘-*- emacs-lisp -*-’
‘-*- elisp -*-’
     The Emacs Lisp extension language.
‘-*- common-lisp -*-’
‘-*- lisp -*-’
     The Common Lisp language.

   Also, it also recognizes comments in the first two columns of the
line:
‘;;’
     A Scheme or Lisp comment - assumed to be in the Scheme language.
‘(:’
     Start of an XQuery comment, so assumed to be in the XQuery
     language.

   If Kawa doesn’t recognize the language of a script (and it isn’t
named +default+) then it assumes the file is a data file.  It asks the
servlet engine to figure out the content type (using the getMimeType
method of ServletContext), and just copies the file into the response.

20.6.5 Compilation and caching
------------------------------

Kawa automatically compiles a script into a class.  The class is
internal to the server, and is not written out to disk.  (There is an
unsupported option to write the compiled file to a class file, but there
is no support to use previously-compiled classes.)  The server then
creates a module instance to handle the actual request, and runs the
body (the ‘run’ method) of the script class.  On subsequence requests
for the same script, the same class and instance are reused; only the
‘run’ is re-executed.

   If the script is changed, then it is re-compiled and a new module
instance created.  This makes it very easy to develop and modify a
script.  (Kawa for performance reasons doesn’t check more than once a
second whether a script has been modified.)


File: kawa.info,  Node: Servlets,  Next: CGI scripts,  Prev: Self-configuring page scripts,  Up: XML tools

20.7 Installing web page scripts as Servlets
============================================

You can compile a Kawa program to a Servlet
(http://en.wikipedia.org/wiki/Java_Servlet), and run it in a servlet
engine (a Servlet-aware web server).  One or more servlets are installed
together as a web application.  This section includes specific
information for the Tomcat and Glassfish web servers.

20.7.1 Creating a web application
---------------------------------

A “web application” is a group of data, servlets, and configuration
files to handle a related set of URLs.  The servlet specification
(http://jcp.org/aboutJava/communityprocess/final/jsr315/index.html)
specifies the directory structure of a web application.

   Assume the web application is called ‘myapp’, and lives in a
directory with the same name.  The application normally handles requests
for URLs that start with ‘http://example.com/myapp’.  Most files in the
application directory are used to handle requests with corresponding
URL. For example, a file ‘myapp/list/help.html’ would be the response to
the request ‘http://example.com/myapp/list/help.html’.

   The directory ‘WEB-INF’ is special.  It contains configuration files,
library code, and other server data.

   So to create the ‘myapp’ application, start with:
     mkdir myapp
     cd myapp
     mkdir WEB-INF WEB-INF/lib WEB-INF/classes

   Copy the Kawa jar from the ‘lib’ direcory.  (You can also use a
“hard” link, but symbolic links may not work, for security systems.)
     cp KAWA-HOME/kawa-3.1.1.jar WEB-INF/lib/kawa.jar

   If you build Kawa from source, you must specify the ‘--with-servlet’
*note configure option: configure options.

   You should also create the file ‘WEB-INF/web.xml’.  For now, this is
is just a place-holder:
     <web-app>
       <display-name>My Application</display-name>
     </web-app>

20.7.2 Compiling a web page script to a servlet
-----------------------------------------------

Assume for simplicity that the source files are in the ‘WEB-INF/classes’
directory, and make that the current directory:
     cd .../myapp/WEB-INF/classes

   Depending on the source language, you compile your script sing the
‘--servlet’ switch:
     kawa --servlet -C hello.scm
   or:
     kawa --servlet --krl -C hello.krl
   or:
     kawa --servlet --xquery -C hello.xql

   This lets the web-application find the compiled servlets.  Finally,
you just need to add the new servlet to the ‘WEB-INF/web.xml’ file:
     <web-app>
       <display-name>My Application</display-name>

       <servlet>
         <servlet-name>MyHello</servlet-name>
         <servlet-class>hello</servlet-class>
       </servlet>

       <servlet-mapping>
         <servlet-name>MyHello</servlet-name>
         <url-pattern>/hello</url-pattern>
       </servlet-mapping>
     </web-app>

   The ‘<servlet>’ clause says that the servlet named ‘MyHello’ is
implemented by the Java class ‘hello’.  The ‘<servlet-mapping>’ clause
says that a request URL ‘/hello’ should be handled by the servlet named
‘MyHello’.  The URL is relative to the application context path, so the
actual URL would be ‘http://example.com/myapp/hello’.

20.7.3 Installing a servlet under Tomcat
----------------------------------------

Apache’s Tomcat (http://tomcat.apache.org/) is an open-source
implementation of the servlet specifications.  After you download it
(http://tomcat.apache.org/download-60.cgi), uncompress it in some
convenient location, which is commonly referred to as ‘$CATALINA_HOME’.

   To install your web application, copy/move its directory to be in the
‘$CATALINA_HOME/webapps’ directory.  Thus for the example above you
would have a ‘$CATALINA_HOME/webapps/myapp’ directory.

   To start or stop Tomcat use the scripts in ‘$CATALINA_HOME/bin’.  For
example to start Tomcat on a GNU/Linux system run
‘$CATALINA_HOME/bin/startup.sh’.  This will start a web server that
listens on the default port of 8080, so you can browse the above example
at ‘http://localhost:8080/myapp/hello’.

   If you’re running Fedora GNU/Linux, you can use the ‘tomcat6’
package:
     # yum install tomcat6
     # export CATALINA_HOME=/usr/share/tomcat6
   You can the manage Tomcat like other system services.  You can
install webapps under ‘$CATALINA_HOME/webapps’.

20.7.4 Installing a servlet under Glassfish
-------------------------------------------

Glassfish (https://glassfish.dev.java.net/) from Oracle/Sun is a
open-source “application server” that implements Java EE 6, including
the 3.0 servlet specification.  After you download it
(https://glassfish.dev.java.net/downloads/3.0.1-final.html), uncompress
it in some convenient location.  This location is called
AS-INSTALL-PARENT in the Quick Start Guide
(http://docs.sun.com/app/docs/doc/820-7689/aboaa?a=view).  The commands
you will use is most in ‘AS-INSTALL/bin’, where AS-INSTALL is
‘AS-INSTALL/glassfish’.

   To start the server, do:
     AS-INSTALL/bin/startserv
   or under under Windows:
     AS-INSTALL\bin\startserv.bat
   The default post to listen to is ‘8080’; you can the port (and lots
of other properties) using the adminstration console at port ‘4848’.

   A web application does not need to be any particular location,
instead you just install it with this command:
     AS-INSTALL/bin/adadmin deploy APPDIR
   where APPDIR is the application directory - ‘myapp’ in the example.
(Use ‘asadmin.bat’ under Windows.)

20.7.5 Servlet-specific script functions
----------------------------------------

The following functions only work within a servlet container.  To use
these functions, first do:
     (require 'servlets)

   You can conditionalize your code to check at compile-time for
servlets, like this:

     (cond-expand
      (in-servlet
        (require 'servlets)
        (format "[servlet-context: ~s]" (current-servlet-context)))
      (else
        "[Not in a servlet]"))

   For a run-time check you can test if ‘(current-servlet)’ is
non-‘#!null’.

 -- Procedure: current-servlet
     When called from a Kawa servlet handler, returns the actual
     ‘javax.servlet.http.HttpServlet’ instance.  Returns ‘#!null’ if the
     current context is not that of ‘KawaServlet’.  (Hence this function
     also returns ‘#!null’ if you compile a servlet “by hand” rather
     that using the ‘--servet’ option.)

 -- Procedure: current-servlet-context
     Returns the context of the currently executing servlet, as an
     instance of ‘javax.servlet.ServletContext’.

 -- Procedure: current-servlet-config
     Returns the ‘ServletConfig’ of the currently executing servlet.

 -- Procedure: get-request
     Return the current servlet request, as an instance of
     ‘javax.servlet.http.HttpServletRequest’.

 -- Procedure: get-response
     Return the current servlet response, as an instance of
     ‘javax.servlet.http.HttpServletResponse’.

 -- Procedure: request-servlet-path
     Get the servlet path of the current request.  Similar to
     ‘request-script-path’, but not always the same, depending on
     configuration, and does _not_ end with a ‘"/"’.

 -- Procedure: request-path-info
     Get the path info of the current request.  Corresponds to the CGI
     variable ‘PATH_INFO’.

 -- Procedure: servlet-context-realpath [path]
     Returns the file path of the current servlet’s "Web application".


File: kawa.info,  Node: CGI scripts,  Next: HTTP requests,  Prev: Servlets,  Up: XML tools

20.8 Installing Kawa programs as CGI scripts
============================================

The recommended way to have a web-server run a Kawa program as a CGI
script is to compile the Kawa program to a servlet (as explained in
*note Server-side scripts::, and then use Kawa’s supplied CGI-to-servlet
bridge.

   First, compile your program to one or more class files as explained
in *note Server-side scripts::.  For example:
     kawa --servlet --xquery -C hello.xql

   Then copy the resulting ‘.class’ files to your server’s CGI
directory.  On Red Hat GNU/Linux, you can do the following (as root):
     cp hello*.class /var/www/cgi-bin/

   Next find the ‘cgi-servlet’ program that Kawa builds and installs.
If you installed Kawa in the default place, it will be in
‘/usr/local/bin/cgi-servlet’.  (You’ll have this if you installed Kawa
from source, but not if you’re just using Kawa ‘.jar’ file.)  Copy this
program into the same CGI directory:
     cp /usr/local/bin/cgi-servlet /var/www/cgi-bin/

   You can link instead of copying:
     ln -s /usr/local/bin/cgi-servlet /var/www/cgi-bin/
   However, because of security issues this may not work, so it is safer
to copy the file.  However, if you already have a copy of ‘cgi-servlet’
in the CGI-directory, it is safe to make a hard link instead of making
an extra copy.

   Make sure the files have the correct permissions:
     chmod a+r /var/www/cgi-bin/hello*.class /var/www/cgi-bin/hello
     chmod a+x /var/www/cgi-bin/hello

   Now you should be able to run the Kawa program, using the URL
<http://localhost/cgi-bin/hello>.  It may take a few seconds to get the
reply, mainly because of the start-up time of the Java VM. That is why
servlets are preferred.  Using the CGI interface can still be useful for
testing or when you can’t run servlets.


File: kawa.info,  Node: HTTP requests,  Next: HTTP response,  Prev: CGI scripts,  Up: XML tools

20.9 Functions for accessing HTTP requests
==========================================

The following functions are useful for accessing properties of a HTTP
request, in a Kawa program that is run either as a servlet or a CGI
script.  These functions can be used from plain Scheme, from KRL
(whether in BRL-compatible mode or not), and from XQuery.

   The examples below assume the request
‘http://example.com:8080/myapp/foo/bar?val1=xyz&val2=abc’, where ‘myapp’
is the application context.  We also assume that this is handled by a
script ‘foo/+default+’.

   The file ‘testsuite/webtest/info/+default+’ in the Kawa source
distribution calls most of these functions.  You can try it as described
in *note Self-configuring page scripts::.

20.9.1 Request URL components
-----------------------------

 -- Procedure: request-URI
     Returns the URI of the request, as a value of type ‘URI’.  This
     excludes the server specification, but includes the query string.
     (It is the combination of CGI variables ‘SCRIPT_NAME’, ‘PATH_INFO’,
     and ‘QUERY_STRING’.  Using servlets terminology, it is the
     combination of Context Path, Servlet Path, PathInfo, and Query
     String.)
          (request-URI) ⇒ "/myapp/foo/bar?val1=xyz&val2=abc"

 -- Procedure: request-path
     Returns the URI of the request, as a value of type ‘URI’.  This
     excludes the server specification and the query string.  Equivalent
     to ‘(path-file (request-URI))’.  (It is the combination of CGI
     variables ‘SCRIPT_NAME’, and ‘PATH_INFO’.  Same as the
     concatenation of ‘(request-context-path)’, ‘(request-script-path)’,
     and ‘(request-local-path)’.  Using servlets terminology, it is the
     combination of Context Path, Servlet Path, and PathInfo.)
          (request-path) ⇒ "/myapp/foo/bar"

 -- Procedure: request-uri
     This function is deprecated, because of possible confusion with
     ‘request-URI’.  Use ‘request-path’ instead.

 -- Procedure: request-url
     Returns the complete URL of the request, except the query string.
     The result is a ‘java.lang.StringBuffer’.
          (request-url) ⇒ "http://example.com:8080/myapp/foo/bar"

 -- Procedure: request-context-path
     Returns the context path, relative to the server root.  This is an
     initial substring of the ‘(request-path)’.  Similar to the Context
     Path of a servlet request, except that it ends with a ‘"/"’.
          (request-context-path) ⇒ "/myapp/"

 -- Procedure: request-script-path
     Returns the path of the script, relative to the context.  This is
     either an empty string, or a string that ends with ‘"/"’, but does
     not start with one.  (The reason for this is to produce URIs that
     work better with operations like ‘resolve-uri’.)  This is
     conceptually similar to ‘request-servlet-path’, though not always
     the same, and the ‘"/"’ conventions differ.
          (request-script-path) ⇒ "foo/"

 -- Procedure: request-local-path
     Returns the remainder of the ‘request-path’, relative to the
     ‘request-script-path’.
          (request-local-path) ⇒ "bar"

 -- Procedure: request-query-string
     Returns the query string from an HTTP request.  The query string is
     the part of the request URL after a question mark.  Returns false
     if there was no query string.  Corresponds to the CGI variable
     ‘QUERY_STRING’.
          (request-query-string) ⇒ "val1=xyz&val2=abc"

20.9.2 Request parameters
-------------------------

Request parameters are used for data returned from forms, and for other
uses.  They may be encoded in the query string or in the request body.

 -- Procedure: request-parameter name [default]
     If there is a parameter with the given name (a string), return the
     (first) corresponding value, as a string.  Otherwise, return the
     DEFAULT value, or ‘#!null’ if there is no DEFAULT.
          (request-parameter "val1") ⇒ "xyz"
          (request-parameter "val9" "(missing)") ⇒ "(missing)"

 -- Procedure: request-parameters name
     If there is are one or more parameter with the given name (a
     string), return them all (as multiple values).  Otherwise, return
     no values (i.e.  ‘(values)’).
          (request-parameters "val1") ⇒ "xyz"
          (request-parameters "val9") ⇒ #!void

 -- Procedure: request-parameter-map
     Request a map of all the parameters.  This is a map from strings to
     a sequence of strings.  (Specifically, a
     ‘java.util.Map<String,java.util.List<String>>’.)

20.9.3 Request headers
----------------------

The request headers are a set of (keyword, string)-pairs transmitted as
part of the HTTP request, before the request body.

 -- Procedure: request-header name
     If there is a header with the given NAME (a string), return the
     corresponding value string.  Otherwise, return ‘#!null’.
          (request-header "accept-language") ⇒ "en-us,en;q=0.5"

 -- Procedure: request-header-map
     Request a map of all the headers.  This is a map from strings to a
     sequence of strings.  (Specifically, a
     ‘java.util.Map<String,java.util.List<String>>’.)

20.9.4 Request body
-------------------

 -- Procedure: request-input-port
     Return a textual input port for reading the request body, as a
     sequence of characters.

 -- Procedure: request-input-stream
     Return a binary input stream for reading the request body, as a
     sequence of bytes.

 -- Procedure: request-body-string
     Return the entire request body as a string

20.9.5 Request IP addresses and ports
-------------------------------------

Information about the interface and port on which the request was
received.

 -- Procedure: request-local-socket-address
     The local address on which the request was received.  This is the
     combination of ‘(request-local-host)’ and ‘(request-local-port)’,
     as an instance of ‘java.net.InetSocketAddress’.
 -- Procedure: request-local-host
     Get the IP address of the interface on which request was received,
     as an ‘java.net.InetAddress’.
 -- Procedure: request-local-IP-address
     Get the IP address of the interface on which request was received,
     a string in numeric form:
          (request-local-host) ⇒ "127.0.0.1"
 -- Procedure: request-local-port
     Get the port this request was received on.
          (request-local-port) ⇒ 8080

   Information about the interface and port of the remote client that
invoked the request.

 -- Procedure: request-remote-socket-address
     The address of the remote client (usually a web browser) which
     invoked the request.  This is the combination of
     ‘(request-remove-host)’ and ‘(request-remote-port)’, as an instance
     of ‘java.net.InetSocketAddress’.
 -- Procedure: request-remote-host
     Get the IP address of the remote client which invoked the request,
     as an ‘java.net.InetAddress’.
 -- Procedure: request-remote-IP-address
     Get the IP address of the remote client which invoked the request,
     as a string in numeric form.
          (request-remote-host) ⇒ "123.45.6.7"
 -- Procedure: request-remote-port
     The port used by the remote client.

20.9.6 Miscellaneous request properties
---------------------------------------

 -- Procedure: request-path-translated
     Map the request-path to a file name (a string) in the server
     application directory.  Corresponds to the CGI variable
     ‘PATH_TRANSLATED’.

 -- Procedure: request-method
     Returns the method of the HTTP request, usually ‘"GET"’ or
     ‘"POST"’.  Corresponds to the CGI variable ‘REQUEST_METHOD’.

 -- Procedure: request-scheme
     Returns the scheme (protocol) of the request.  Usually ‘"http"’, or
     ‘"https"’.


File: kawa.info,  Node: HTTP response,  Next: XML beyond Scheme,  Prev: HTTP requests,  Up: XML tools

20.10 Generating HTTP responses
===============================

The result of evaluating the top-level expressions of a web page script
becomes the HTTP response that the servlet sends back to the browser.
The result is typically an HTML/XML element code object Kawa will
automatically format the result as appropriate for the type.  Before the
main part of the response there may be special "response header values",
as created by the ‘response-header’ function.  Kawa will use the
response header values to set various required and optional fields of
the HTTP response.  Note that ‘response-header’ does not actually do
anything until it is "printed" to the standard output.  Note also that a
‘"Content-Type"’ response value is special since it controls the
formatting of the following non-response-header values.

 -- Procedure: response-header key value
     Create the response header ‘KEY: VALUE’ in the HTTP response.  The
     result is a "response header value" (of some unspecified type).  It
     does not directly set or print a response header, but only does so
     when you actually "print" its value to the response output stream.

 -- Procedure: response-content-type type
     Species the content-type of the result - for example
     ‘"text/plain"’.  Convenience function for ‘(response-header
     "Content-Type" TYPE)’.

 -- Procedure: error-response code [message]
     Creates a response-header with an error code of CODE and a response
     message of MESSAGE.  (For now this is the same as
     ‘response-status’.)

     Note this also returns a response-header value, which does not
     actually do anything unless it is returned as the result of
     executing a servlet body.

 -- Procedure: response-status code [message]
     Creates a response-header with an status code of CODE and a
     response message of MESSAGE.  (For now this is the same as
     ‘error-response’.)


File: kawa.info,  Node: XML beyond Scheme,  Prev: HTTP response,  Up: XML tools

20.11 Using non-Scheme languages for XML/HTML
=============================================

20.11.1 XQuery language
-----------------------

Bundled with Kawa is a fairly complete implementation of W3C’s new XML
Query language (http://www.w3c.org/XML/Query).  If you start Kawa with
the ‘--xquery’ it selects the "XQuery" source language; this also prints
output using XML syntax.  See the Qexo (Kawa-XQuery) home page
(http://www.gnu.org/software/qexo/) for examples and more information.

20.11.2 XSL transformations
---------------------------

There is an experimental implementation of the XSLT (XML Stylesheet
Language Transformations) language.  Selecting ‘--xslt’ at the Kawa
command line will parse a source file according to the syntax on an XSLT
stylesheet.  See the Kawa-XSLT page
(http://www.gnu.org/software/qexo/xslt.html) for more information.

* Menu:

* KRL::              KRL - The Kawa Report Language for generating XML/HTML


File: kawa.info,  Node: KRL,  Up: XML beyond Scheme

20.11.3 KRL - The Kawa Report Language for generating XML/HTML
--------------------------------------------------------------

KRL (the "Kawa Report Language") is powerful Kawa dialect for embedding
Scheme code in text files such as HTML or XML templates.  You select the
KRL language by specifying ‘--krl’ on the Kawa command line.

   KRL is based on on BRL (http://brl.sourceforge.net/), Bruce Lewis’s
"Beautiful Report Language", and uses some of BRL’s code, but there are
some experimental differences, and the implementation core is different.
You can run KRL in BRL-compatility-mode by specifying ‘--brl’ instead of
‘--krl’.

20.11.4 Differences between KRL and BRL
---------------------------------------

This section summarizes the known differences between KRL and BRL.
Unless otherwise specified, KRL in BRL-compatibility mode will act as
BRL.

   • In BRL a normal Scheme string ‘"mystring"’ is the same as the
     inverted quote string ‘]mystring[’, and both are instances of the
     type ‘<string>’.  In KRL ‘"mystring"’ is a normal Scheme string of
     type ‘<string>’, but ‘]mystring[’ is special type that suppresses
     output escaping.  (It is equivalent to ‘(unescaped-data
     "mystring")’.)
   • When BRL writes out a string, it does not do any processing to
     escape special characters like ‘<’.  However, KRL in its default
     mode does normally escape characters and strings.  Thus ‘"<a>"’ is
     written as ‘&lt;a&gr;’.  You can stop it from doing this by
     overriding the output format, for example by specifying
     ‘--output-format scheme’ on the Kawa command line, or by using the
     ‘unescaped-data’ function.
   • Various Scheme syntax forms, including ‘lambda’, take a BODY, which
     is a list of one or more declarations and expressions.  In normal
     Scheme and in BRL the value of a BODY is the value of the last
     expression.  In KRL the value of a BODY is the concatenation of all
     the values of the expressions, as if using ‘values-append’.
   • In BRL a word starting with a colon is a keyword.  In KRL a word
     starting with a colon is an identifier, which by default is bound
     to the ‘make-element’ function specialized to take the rest of the
     word as the tag name (first argument).
   • BRL has an extensive utility library.  Most of this has not yet
     been ported to KRL, even in BRL-compatibility mode.


File: kawa.info,  Node: Miscellaneous,  Next: FAQs,  Prev: XML tools,  Up: Top

21 Miscellaneous topics
***********************

 -- Procedure: scheme-implementation-version
     Returns the Kawa version number as a string.

 -- Procedure: scheme-window [shared]
     Create a read-eval-print-loop in a new top-level window.  If SHARED
     is true, it uses the same environment as the current
     ‘(interaction-environment)’; if not (the default), a new top-level
     environment is created.

     You can create multiple top-level window that can co-exist.  They
     run in separate threads.

* Menu:

* Composable pictures::
* Building JavaFX applications::
* Building for Android::  Building for Android devices
* Android view construction::
* System inquiry::
* Processes::
* Time-related functions::
* Low-level functions:: Deprecated low-level functions


File: kawa.info,  Node: Composable pictures,  Next: Building JavaFX applications,  Up: Miscellaneous

21.1 Composable pictures
========================

The ‘(kawa pictures)’ library lets you create geometric shapes and
images, and combine them in interesting ways.  The *note tutorial:
Tutorial - Pictures. gives an introduction.

   The easiest way to use and learn the ‘pictures’ library is with a
suitable REPL. You can use the old Swing-based console or any *note
DomTerm: Using DomTerm.-based terminal emulator.  You can create a
suitable window either by starting ‘kawa’ with the ‘-w’ flag, or by
running the ‘kawa’ command inside an existing DomTerm-based terminal
emulator.  The screenshot below is of the latter, using the ‘qtdomterm’
terminal emulator.

 [image src="images/domterm-pictures-1.png" ]


   After ‘(import (kawa swing))’ you can use ‘show-picture’ to display a
picture in a Swing window.

   A “picture” is an object that can be displayed on a screen, web-page,
or printed page, and combined with other pictures.

   A picture has a method printing itself in a graphical context.  It
also has various properties.

   An important property of a picture is its “bounding box”.  This is a
rectangle (with edges parallel to the axes) that surrounds the contents
of the picture.  Usually the entire visible part of the picture is
inside the bounding box, but in some cases part of the picture may stick
outside the bounding box.  For example when a circle is drawn (stroked)
with a “pen”, the bounding box is that of the infinitely-thin
mathematical circle, so “ink” from the pen that is outside the circle
may be outside the bounding box.

   A picture has an origin point corresponding to the (0 0) cordinates.
The origin is commonly but not always inside the bounding box.  Certain
operations (for example ‘hbox’) combine pictures by putting them “next
to” each other, where “next to” is defined in terms of the bounding box
and origin point.

21.1.1 Coordinates - points and dimensions
------------------------------------------

The library works with a two-dimensional grid, where each position has
an x cordinate and y coordinate.  Normally, x values increase as you
move right on the screen/page, while y values increase as you move
_down_.  This convention matches that used by Java 2D, SVG, and many
other graphics libraries.  However, note that this is different from the
traditional mathematical convention of y values increasing as you go up.

   By default, one unit is one “pixel”.  (More precisely, it is the ‘px’
unit in the CSS specification.)

 -- Type: Point
     A point is a pair consisting of an x and a y coordinate.

 -- Literal: &P[ X Y ]
     Construct a point value with the specified X and Y values.  Both X
     and Y are expressions that evaluate to real numbers:
          &P[(+ old-right 10) baseline]

 -- Type: Dimension
     A dimension value is a pair of a width and a height.  It is used
     for the size of pictures in the two dimensions.

     In a context that expects a point, a dimension is treated as an
     offset relative to some other point.

 -- Literal: &D[ WIDTH HEIGHT ]
     Construct a dimension value with the specified WIDTH and HEIGHT
     values, which are both expressions that evaluate to real numbers.

21.1.2 Shapes
-------------

A shape is a collection of lines and curves.  Examples include lines,
circles, and polygons.  A shape can be “stroked”, which you can think of
as being drawn by a very fancy calligraphic pen that follows the lines
and curves of the shape.

   A “closed shape” is a shape that is continuous and ends up where it
started.  This includes circles and polygons.  A closed shape can be
filled, which means the entire “interior” is painted with some color or
texture.

   A shape is represented by the Java ‘java.awt.Shape’ interface.  The
‘picture’ library only provides relatively simple shapes, but you can
use any methods that create a ‘java.awt.Shape’ object.

   “Shape” is effectively a sub-type of “picture”, though they’re
represented using using disjoint classes: If you use a shape where a
picture is required, the shape is automatically converted to a picture,
as if using the ‘draw’ procedure.

 -- Procedure: line p1 [p2 ...]
     In the simple case two points are specified, and the result is a
     line that goes from point P1 to P2.  If N points are specied, the
     result is a “polyline”: a path consisting of N-1 line segments,
     connecting adjacent arguments.  (If only a single point is
     specified, the result is degenerate single-point shape.)

     All of the points except the first can optionally be specified
     using a dimension, which is treated an an offset from the previous
     point:
          (line &P[30 40] &D[10 5] &D[10 -10])
     is the same as:
          (line &P[30 40] &P[40 45] &P[50 35])

 -- Procedure: polygon p1 [p2 ...]
     Constructs a closed shape from line segments.  This is the same as
     calling ‘line’ with the same arguments, with the addition of a
     final line segment from the last point back to the first point.

 -- Procedure: rectangle p1 [p2]
     A rectangle is closed polygon of 4 line segments that are
     alternatively parallel to the x-axis and the y-axis.  I.e.  if you
     rotate a rectangle it is no longer a rectangle by this definition,
     though of course it still has a rectangular shape.  If P2 is not
     specified, constructs a rectangle whose upper-left corner is ‘&P[0
     0]’ and whose lower-right corner is P1.  If P2 is specified,
     constructs a rectangle whose upper-left corner is P1 and whose
     lower-right corner is P2.  If P2 is a dimension it is considered a
     relative offset from P1, just like for ‘polygon’.

 -- Procedure: circle radius [center]
     Creates a circle with the specified RADIUS.  If the CENTER is not
     specified, it defaults to ‘&P[0 0]’.

21.1.3 Colors and paints
------------------------

A “paint” is a color pattern used to fill part of the canvas.  A paint
can be a color, a texture (a replicated pattern), or a gradient (a color
that gradually fades to some other color).

   A “color” is defined by red, green, and blue values.  It may also
have an alpha component, which specifies transparency.

 -- Procedure: ->paint value
     Converts VALUE to a color - or more general a paint.  Specificlly,
     the return type is ‘java.awt.Paint’.  The VALUE can be any one of:
        • A ‘java.awt.Paint’, commonly a ‘java.awt.Color’.
        • A 24-bit integer value is converted to a color.  Assume the
          integer is equal to a hexadecimal literal of the form
          ‘#xRRGGBB’.  Then ‘RR’ (bits 16-23) is the intensity of the
          red component; ‘GG’ (bits 8-15) is the intensity of the green
          component; and ‘RR’ (bits 0-7) is the intensity of the red
          component.
        • One of the standard HTML/CSS/SVG color names, as a string or
          symbol.  See the table in ‘gnu/kawa/models/StandardColor.java’
          source file.  Case is ignored, and you can optionally use
          hyphens to separate words.  For example ‘'hot-pink’,
          ‘'hotpink’, and ‘'hotPink’ are all the same sRGB color
          ‘#xFF69B4’.

 -- Procedure: with-paint paint picture
     Create a new picture that is the “same” as PICTURE but use PAINT as
     the default paint.  For PAINT you can use any valid argument to
     ‘->paint’.  The default paint (which is the color black if none is
     specified) is used for both ‘fill’ (paint interior) and ‘draw’
     (stroke outline).

          #|kawa:1|# (! circ1 (circle 20 &P[20 20]))
          #|kawa:2|# (hbox (fill circ1) (draw circ1))
           [image src="images/paint-circ-1.png" ]
          #|kawa:3|# (with-paint 'hot-pink (hbox (fill circ1) (draw circ1)))
           [image src="images/paint-circ-2.png" ]
     Above we use ‘with-paint’ to create a cloned picture, which is the
     same as the original ‘hbox’, except for the default paint, in this
     case the color ‘hot-pink’.
          #|kawa:4|# (! circ2 (hbox (fill circ1) (with-paint 'hot-pink (fill circ1))))
          #|kawa:5|# circ2
           [image src="images/paint-circ-3.png" ]
          #|kawa:6|# (with-paint 'lime-green circ2)
           [image src="images/paint-circ-4.png" ]
     Here ‘circ2’ is an ‘hbox’ of two filled circles, one that has
     unspecified paint, and one that is ‘hot-pink’.  Printing ‘circ2’
     directly uses black for the circle with unspecified color, but if
     we wrap ‘circ2’ in another ‘with-paint’ that provides a default
     that is used for the first circle.

21.1.4 Filling a shape with a color
-----------------------------------

 -- Procedure: fill shape
 -- Procedure: fill paint shape

     Fill the “inside” of SHAPE.  If no PAINT is specified, uses the
     current default paint.  Otherwise, ‘(fill PAINT SHAPE)’ is the same
     ‘(with-paint PAINT (fill SHAPE))’.

21.1.5 Stroking (outlining) a shape
-----------------------------------

 -- Procedure: draw option^{*} shape^{+}

     Returns a picture that draws the outline of the SHAPE.  This is
     called “stroking”.  An OPTION may be one of:
        • A ‘Paint’ or ‘Color’ object, which is used to draw the shape.
        • A standard color name, such as ‘'red’ or ‘'medium-slate-blue’.
          This is mapped to a ‘Color’.
        • A join-specifier, which is a symbol specifying how each curve
          of the shape is connected to the next one.  The options are
          ‘'miter-join’, ‘'round-join’, and ‘'bevel-join’.  The default
          if none is specified is ‘'miter-join’.
        • A end-cap-specifier, which is a symbol specifying how each end
          of the shape is terminated.  The options are ‘'square-cap’,
          ‘'round-cap’, or ‘'butt-cap’.  The default is ‘'butt-cap’.
          (This follows SVG and HTML Canvas.  The default in plain Java
          AWT is a square cap.)
        • A real number specifies the thickness of the stroke.
        • A ‘java.awt.Stroke’ object.  This combines join-specifier,
          end-cap-specifier, thickness, and more in a single object.
          The ‘BasicStroke’ class can specify dashes, though that is not
          yet supported for SVG output; only AWT or image output.

     Let us illustrate with a sample line ‘lin’ and a helper macro
     ‘show-draw’, which adds a border around a shape, then draws the
     given shape with some options, and finally re-draws the shape in
     plain form.
          #|kawa:10|# (define lin (line &P[0 0] &P[300 40] &P[200 100] &P[50 70]))
          #|kawa:11|# (define-syntax show-draw
          #|....:12|#   (syntax-rules ()
          #|....:13|#     ((_ options ... shape)
          #|....:14|#      (border 12 'bisque (zbox (draw options ... shape) shape)))))
          #|....:15|# (show-draw 8 'lime lin)
           [image src="images/show-draw-1.png" ]
          #|....:16|# (show-draw 8 'lime 'round-cap 'round-join lin)
           [image src="images/show-draw-2.png" ]
          #|....:17|# (show-draw 8 'lime 'square-cap 'bevel-join lin)
           [image src="images/show-draw-3.png" ]
   Notice how the different cap and join styles change the drawing.
Also note how the stroke (color lime) extends beyond its bounding box,
into the surrounding border (color bisque).

21.1.6 Affine transforms
------------------------

A 2D affine transform is a linear mapping from coordinates to
coordinates.  It generalizes translation, scaling, flipping, shearing,
and their composition.  An affine transform maps straight parallel lines
into other straight parallel lines, so it is only a subset of possible
mappings - but a very useful subset.

 -- Procedure: affine-transform xx xy yx yy x0 y0
 -- Procedure: affine-transform px py p0
     Creates a new affine transform.  The result of applying
     ‘(affine-transform X_{X} X_{Y} Y_{X} Y_{Y} X_{0} Y_{0})’ to the
     point ‘&P[X Y]’ is the transformed point
          &P[(+ (* X X_{X}) (* Y Y_{X}) X_{0})
             (+ (* X X_{Y}) (* Y Y_{Y}) Y_{0})]

     If using point arguments, ‘(affine-transform &P[X_{X} X_{Y}]
     &P[Y_{X} Y_{Y}] &P[X_{0} Y_{0}])’ is equivalent to:
     ‘(affine-transform X_{X} X_{Y} Y_{X} Y_{Y} X_{0} Y_{0})’.

 -- Procedure: with-transform transform picture
 -- Procedure: with-transform transform shape
     Creates a transformed picture.

     If the argument is a SHAPE, then the result is also a shape.

 -- Procedure: with-transform transform point
     Apply a transform to a single point, yielding a new point.

 -- Procedure: with-transform transform1 transform2
     Combine two transforms, yielding the composed transform.

 -- Procedure: rotate angle
 -- Procedure: rotate angle picture
     The one-argument variant creates a new affine transform that
     rotates a picture about the origin by the specified ANGLE.  A
     positive ANGLE yields a clockwise rotation.  The ANGLE can be
     either a quantity (with a unit of either ‘rad’ radians, ‘deg’
     (degrees), or ‘grad’ (gradians)), or it can be a unit-less real
     number (which is treated as degrees).

     The two-argument variant applies the resulting transform to the
     specified picture.  It is equivalent to:
          (with-transform (rotate ANGLE) PICTURE)

 -- Procedure: scale factor
 -- Procedure: scale factor picture
     Scales the PICTURE by the given FACTOR.  The FACTOR can be a real
     number.  The FACTOR can also be a point or a dimension, in which
     case the two cordinates are scaled by a different amount.

     The two-argument variant applies the resulting transform to the
     specified picture.  It is equivalent to:
          (with-transform (scale FACTOR) PICTURE)

 -- Procedure: translate offset
 -- Procedure: translate offset picture

     The single-argument variant creates a transform that adds the
     OFFSET to each point.  The OFFSET can be either a point or a
     dimension (which are treated quivalently).

     The two-argument variant applies the resulting transform to the
     specified picture.  It is equivalent to:
          (with-transform (translate OFFSET) PICTURE)

21.1.7 Combining pictures
-------------------------

 -- Procedure: hbox [spacing] picture ...
 -- Procedure: vbox [spacing] picture ...
 -- Procedure: zbox picture ...
     Make a combined picture from multiple sub-pictures drawn either
     “next to” or “on top of” each other.

     The case of ‘zbox’ is simplest: The sub-pictures are drawn in
     argument order at the same position (origin).  The “‘z’” refers to
     the idea that the pictures are stacked on top of each other along
     the “Z-axis” (the one perpendicular to the screen).

     The ‘hbox’ and ‘vbox’ instead place the sub-pictures next to each
     other, in a row or column.  If SPACING is specified, if must be a
     real number.  That much extra spacing is added between each
     sub-picture.

     More precisely: ‘hbox’ shifts each sub-picture except the first so
     its left-origin control-point (see discussion at ‘re-center’) has
     the same position as the right-origin control point of the previous
     picture PLUS the amount of SPACING.  Similarly, ‘vbox’ shifts each
     sub-picture except the first so its top-origin control point has
     the same position as the bottom-origin point of the previous
     picture, plus SPACING.

     The bounding box of the result is the smallest rectangle that
     includes the bounding boxes of the (shifted) sub-pictures.  The
     origin of the result is that of the first picture.

 -- Procedure: border [size [paint]] picture
     Return a picture that combines PICTURE with a rectangular border
     (frame) around PICTURE’s bounding box.  The SIZE specifies the
     thickness of the border: it can be real number, in which it is the
     thickness on all four sides; it can be a Dimension, in which case
     the width is the left and right thickness, while the height is the
     top and bottom thickness; or it can be a Rectangle, in which case
     it is the new bounding box.  If PAINT is specified it is used for
     the border; otherwise the default paint is used.  The border is
     painted before (below) the PICTURE painted.  The bounding box of
     the result is that of the border, while the origin point is that of
     the original PICTURE.
          #|kawa:2|# (with-paint 'blue (border &D[8 5] (fill 'pink (circle 30))))
           [image src="images/border-1.png" ]

 -- Procedure: padding width [background] picture
     This is similar to ‘border’, but it just adds extra space around
     PICTURE, without painting it.  The SIZE is specified the same way.
     If BACKGROUND is specified, it becomes the background paint for the
     entire padded rectangle (both PICTURE and the extra padding).
          #|kawa:3|# (define circ1 (fill 'teal (circle 25)))
          #|kawa:4|# (zbox (line &P[-30 20] &P[150 20])
          #|kawa:5|#   (hbox circ1 (padding 6 'yellow circ1) (padding 6 circ1)))
           [image src="images/padding-1.png" ]
     This shows a circle drawn three ways: as-is; with padding and a
     background color; with padding and a transparent background.  A
     line is drawn before (below) the circles to contrast the yellow vs
     transparent backgrounds.

 -- Procedure: re-center [xpos] [ypos] picture
     Translate the PICTURE such that the point specified by XPOS and
     YPOS is the new origin point, adjusting the bounding box to match.
     If the PICTURE is a shape, so is the result.

     The XPOS can have four possible values, all of which are symbols:
     ‘'left’ (move the origin to the left edge of the bounding box);
     ‘'right’ (move the origin to the right edge of the bounding box);
     ‘'center’ (or ‘'centre’) (move the origin to halfway between the
     left and right edges); or ‘'origin’ (don’t change the location
     along the x-axis).  The YPOS can likewise have four possible
     values: ‘'top’ (move the origin to the top edge of the bounding
     box); ‘'bottom’ (move the origin to the bottom edge of the bounding
     box); ‘'center’ (or ‘'centre’) (move the origin to halfway between
     the top and bottom edges); or ‘'origin’ (don’t change the location
     along the y-axis).

     A single ‘'center’ argument is the same as specifying ‘'center’ for
     both axis; this is the default.  A single ‘'origin’ argument is the
     same as specifying ‘'origin’ for both axis; this is the same as
     just PICTURE.

     The 16 control points are shown below, relative to a picture’s
     bounding box and the X- and Y-axes.  The abbreviations have the
     obvious values, for example ‘LC’ means ‘'left 'center’.
          LT    OT  CT      RT
            ┌────┬──────────┐
            │    │          │
            │    │          │
          LC│   OC  C       │RC
          LO├────O──CO──────┤RO
            │    │          │
            └────┴──────────┘
          LB    OB  CB       RB
     The result of (for example) ‘(re-center 'left 'center P)’ is P
     translated so the origin is at control point ‘LC’.

          #|kawa:1|# (define D (fill 'light-steel-blue (polygon &P[-20 0] &P[0 -20] &P[60 0] &P[0 40])))
          #|kawa:2|# (zbox D (draw 'red (circle 5)))
           [image src="images/re-center-1.png" ]
     Above we defined ‘D’ as a vaguely diamond-shaped quadrilateral.  A
     small red circle is added to show the origin point.  Below we
     display 5 versions of ‘D’ in a line (an ‘hbox’), starting with the
     original ‘D’ and 4 calls to ‘re-center’.
          #|kawa:3|# (zbox (hbox D (re-center 'top D) (re-center 'bottom D)
          #|....:4|#               (re-center 'center D) (re-center 'origin D))
          #|....:5|#   (line &P[0 0] &P[300 0]))
           [image src="images/re-center-2.png" ]
     The line at Y=0 shows the effects of ‘re-center’.

21.1.8 Images
-------------

An image is a picture represented as a rectangular grid of color values.
An image file is some encoding (usually compressed) of an image, and
mostly commonly has the extensions ‘png’, ‘gif’, or ‘jpg’/‘jpeg’.

   A “native image” is an instance of ‘java.awt.image.BufferedImage’,
while a “picture image” is an instance of ‘gnu.kawa.models.DrawImage’.
(Both classes implement the ‘java.awt.image.RenderedImage’ interface.)
A ‘BufferedImage’ is automatically converted to a ‘DrawImage’ when
needed.

 -- Procedure: image bimage
 -- Procedure: image picture
 -- Procedure: image src: path

     Creates a picture image, using either an existing native image
     BIMAGE, or an image file specified by PATH.

     Writing ‘(image src: PATH)’ is roughly the same as ‘(image
     (read-image PATH))’ except that the former has the PATH associated
     with the resulting picture image.  This can make a difference when
     the image is used or displayed.

     If the argument is a PICTURE, it is converted to an image as if by
     ‘->image’.

 -- Procedure: image-read path
     Read an image file from the specified PATH, and returns a native
     image object (a ‘BufferedImage’).
          #|kawa:10|# (define img1 (image-read "http://pics.bothner.com/2013/Cats/06t.jpg"))
          #|kawa:11|# img1
           [image src="images/image-cat-1a.png" ]
          #|kawa:12|# (scale 0.6 (rotate 30 img1))
           [image src="images/image-cat-1b.png" ]

   Note that while ‘img1’ above is a (native) image, the scaled rotated
image is not an image object.  It is a picture - a more complex value
that _contains_ an image.

 -- Procedure: image-write picture path
     The PICTURE is converted to an image (as if by using ‘->image’) and
     then it is written to the specified PATH.  The format used depends
     on (the lower-cased string value of) the path: A JPG file if the
     name ends with ‘".jpg"’ or ‘".jpeg"’; a GIF file if the name ends
     with ‘".gif"’; a PNG file if the name ends with ‘".png"’.
     (Otherwise, the defalt is PNG, but that might change.)

 -- Procedure: image-width image
 -- Procedure: image-height image
     Return the width or height of the given IMAGE, in pixels.

 -- Procedure: ->image picture
     Convert PICTURE to an image (a ‘RenderedImage’).  If the PICTURE is
     an image, return as-is.  Otherwise, create an empty image (a
     ‘BufferedImage’ whose size is the PICTURE’s bounding box), and
     “paint” the PICTURE into it.
          #|kawa:1|# (define c (fill (circle 10)))
          #|kawa:2|# (scale 3 (hbox c (->image c)))
           [image src="images/image-scaled-1.png" ]
     Here we take a circle ‘c’, and convert it to an image.  Note how
     when the image is scaled, the pixel artifacts are very noticable.
     Also note how the origin of the image is the top-level corner,
     while the origin of the original circle is its center.

21.1.9 Compositing - Controlling how pictures are combined
----------------------------------------------------------

 -- Procedure: with-composite [[compose-op] picture] ...
     Limited support - SVG and DomTerm output has not been implemented.

21.1.10 Displaying and exporting pictures
-----------------------------------------

21.1.10.1 Export to SVG
.......................

 -- Procedure: picture-write-svg picture path [headers]
     Writes the PICTURE to the file specified by PATH, in SVG
     (Structered Vector Graphics) format.  If HEADERS is true (which is
     the default) first write out the XML and DOCTYPE declarations that
     should be in a well-formed standaline SVG file.  Otherwise, just
     write of the ‘<svg>’ element.  (Modern browers should be able to
     display a file consisting of just the ‘<svg>’ element, as long as
     it has extension ‘.svg’, ‘.xml’, or ‘.html’; the latter may add
     some extra padding.)

 -- Procedure: picture->svg-node picture
     Returns a SVG representation of ‘picture’, in the form of an
     ‘<svg>’ element, similar to those discussed in *note Creating XML
     nodes::.  If you convert the ‘<svg>’ element to a string, you get
     formatted XML; if you ‘write’ the ‘<svg>’ element you get an *note
     XML literal: XML literals. of form ‘"#<svg>...</svg>"’.  If you
     ‘display’ the ‘<svg>’ element in a DomTerm terminal you get the
     picture (as a picture).  This works because when you display an
     element in DomTerm it gets inserted into the display.

21.1.10.2 Display in Swing
..........................

These procedures require ‘(import (kawa swing))’ in addition to ‘(import
(kawa pictures))’.

   The convenience function ‘show-picture’ is useful for displaying a
picture in a new (Swing) window.

 -- Procedure: show-picture picture
     If this is the first call to ‘show-pictures’, displays PICTURE in a
     new top-level window (using the Swing toolkit).  Sequenent calls to
     ‘show-picture’ will reuse the window.
          #|kawa:1|# (import (kawa swing) (kawa pictures))
          #|kawa:2|# (show-picture SOME-PICTURE)
          #|kawa:3|# (set-frame-size! &D[200 200]) ; Adjust window size
          #|kawa:4|# (show-picture SOME-OTHER-PICTURE)

 -- Procedure: picture->jpanel picture
     Return a ‘JPanel’ that displays PICTURE.  You can change the
     displayed picture by:
          (set! PANEL:picture SOME-OTHER-PICTURE)

 -- Procedure: set-frame-size! size [frame]
     If FRAME is specified, set its size.  Otherwise, remember the size
     for future ‘show-picture’ calls; if there is already a
     ‘show-picture’ window, adjust its size.

21.1.10.3 Convert to image
..........................

You can convert a picture to an image using the ‘->image’ procedure, or
write it to a file using the ‘image-write’ procedure.


File: kawa.info,  Node: Building JavaFX applications,  Next: Building for Android,  Prev: Composable pictures,  Up: Miscellaneous

21.2 Building JavaFX applications
=================================

Kawa makes it easy to build “rich client” (i.e.  GUI) applications using
JavaFX
(http://www.oracle.com/technetwork/java/javafx/overview/index.html).
For example the following program will print up a window with a button;
clicking on the button will print a message on the console output about
the event.
     (require 'javafx-defs)
     (javafx-application)

     (javafx-scene
      title: "Hello Button"
      width: 600 height: 450
      (Button
       text: "Click Me"
       layout-x: 25
       layout-y: 40
       on-action: (lambda (e) (format #t "Event: ~s~%~!" e))))

   JavaFX support is builtin to the pre-built ‘kawa-3.1.1.jar’.  It is
easiest to use JDK 8; see below if you’re using JDK 7.  If you build
Kawa from source, specify ‘--with-javafx’ on the ‘configure’ command
line (assuming you’re using JDK 8).

   Assume the above file is ‘HelloButton1.scm’, you can run it like
this:
     $ kawa HelloButton1.scm

   For more information and examples read this (slightly older)
introduction
(http://per.bothner.com/blog/2011/JavaFX-using-Kawa-intro/), and this on
animation (http://localhost/per/blog/2011/JavaFX-using-Kawa-animation/).

   The ‘browse-kawa-manual’ script in the ‘doc’ directory (source only)
uses JavaFX WebView to create a window for browsing the Kawa
documentation.

21.2.1 Using JavaFX with JDK 11+
--------------------------------

Starting with JDK 11, JavaFX has been moved to a separate project and is
no longer included in the JDK. The separate project OpenJFX provides an
SDK that includes modular jar files which can be added to the
‘CLASSPATH’ or via the ‘--module-path’ parameter to ‘javac’ and ‘java’.

   To run the previous ‘HelloButton1.scm’ you can do:
     $ java -cp $KAVA_HOME/kawa.jar --module-path $JAVAFX_HOME/lib \
       --add-modules javafx.web HelloButton1.scm

   If you build Kawa from source you must use an appropriate JDK version
and enable the modular OpenJFX SDK:
     $ ./configure --with-javafx=path-to-sdk ...other-args...
   The resulting Kawa binary sets up the module path and the boostrap
module so you just need to do:
     $ kawa HelloButton1.scm


File: kawa.info,  Node: Building for Android,  Next: Android view construction,  Prev: Building JavaFX applications,  Up: Miscellaneous

21.3 Building for Android
=========================

Google’s phone/tablet operating system Android
(https://developers.google.com/android/) is based on a custom virtual
machine on top of a Linux kernel.  Even though Android isn’t strictly
(or legally) speaking Java, you can build Android applications using
Kawa.

   Below is "Hello world" written in Kawa Scheme.  A slightly more
interesting example is in *note next section: Android view construction.

     (require 'android-defs)
     (activity hello
       (on-create-view
        (android.widget.TextView (this)
         text: "Hello, Android from Kawa Scheme!")))

   The following instructions have been tested on GNU/Linux,
specifically Fedora 17.  This link
(http://asieno.com/blog/index.php/post/2012/08/16/Setting-up-the-environment-Android-Kawa)
may be helpful if you’re building on Windows.

21.3.1 Downloading and setting up the Android SDK
-------------------------------------------------

First download the Android SDK
(http://code.google.com/android/download.html).  Unzip in a suitable
location, which we’ll refer to as ‘ANDROID_HOME’.

     export ANDROID_HOME=/path/to/android-sdk-linux
     PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH

   Next you have to get the appropriate platform SDK:

     $ android update sdk
   You need to select an Android “platform”.  Platform (API) 16
corresponds to Android 4.1.2 (Jelly Bean).  Select that or whatever you
prefer, and click ‘Install’.  (You can install multiple platforms, but
each project is built for a specific platform.)

     ANDROID_PLATFORM=android-16

21.3.2 Building Kawa for Android
--------------------------------

Set ‘JAVA_HOME’ to where your JDK tree is.  You should use JDK 6; JDK 7
does not work at time of writing.

     $ export JAVA_HOME=/opt/jdk1.6

   First *note get the Kawa source code: Getting Kawa.

   If using Ant (as is recommended on Windows):

     $ ant -Denable-android=true
   Alternatively, you can use ‘configure’ and ‘make’:

     $ KAWA_DIR=path_to_Kawa_sources
     $ cd $KAWA_DIR
     $ ./configure --with-android=$ANDROID_HOME/platforms/$ANDROID_PLATFORM/android.jar --disable-xquery --disable-jemacs
     $ make

21.3.3 Creating the application
-------------------------------

Next, we need to create a project or “activity”.  This tutorial assumes
you want to create the project in the target directory ‘KawaHello’, with
the main activity being a class named ‘hello’ in a package
‘kawa.android’:
     PROJECT_DIR=KawaHello
     PROJECT_CLASS=hello
     PROJECT_PACKAGE=kawa.android
     PROJECT_PACKAGE_PATH=kawa/android

   To create the project use the following command:
     $ android create project --target $ANDROID_PLATFORM --name $PROJECT_DIR --activity $PROJECT_CLASS --path ./$PROJECT_DIR --package $PROJECT_PACKAGE

   Replace the skeleton ‘hello.java’ by the Scheme code at the top of
this note, placing in a file named ‘hello.scm’:
     $ cd $PROJECT_DIR
     $ HELLO_APP_DIR=`pwd`
     $ cd $HELLO_APP_DIR/src/$PROJECT_PACKAGE_PATH
     $ rm $PROJECT_CLASS.java
     $ create $PROJECT_CLASS.scm

   We need to copy/link the Kawa jar file so the Android SDK can find
it:
     $ cd $HELLO_APP_DIR
     $ ln -s $KAWA_DIR/kawa-3.1.1.jar libs/kawa.jar

   Optionally, you can use kawart-3.1.1.jar, which is slightly smaller,
but does not support eval, and does not get built by the Ant build:
     $ ln -s $KAWA_DIR/kawart-3.1.1.jar libs/kawa.jar

   Copy or link ‘custom_rules.xml’ from the Kawa sources:
     ln -s $KAWA_DIR/gnu/kawa/android/custom_rules.xml .

   Finally to build the application just do:
     $ ant debug

21.3.4 Running the application on the Android emulator
------------------------------------------------------

First you need to create an Android Virtual Device (avd)
(http://developer.android.com/tools/devices).  Start:
     android
   Then from menu ‘Tools’ select ‘Manage AVDs...’.  In the new window
click ‘New....’ Pick a ‘Name’ (we use ‘avd16’ in the following), a
‘Target’ (to match ‘$ANDROID_PLATFORM’), and optionally change the other
properties, before clicking ‘Create AVD’.

   Now you can start up the Android emulator:

     $ emulator -avd avd16 &
   Wait until Android has finished booting (you will see the Android
home screen), click the menu and home buttons.  Now install our new
application:

     adb install bin/KawaHello-debug.apk

21.3.5 Running the application on your device
---------------------------------------------

If the emulator is running, kill it:
     $ kill %emulator

   On your phone or other Android devude, enable USB debugging.  (This
is settable from the ‘Settings’ application, under ‘Applications /
Development’.)

   Connect the phone to your computer with the USB cable.  Verify that
the phone is accessible to ‘adb’:
     $ adb devices
     List of devices attached
     0A3A560F0C015024	device

   If you don’t see a device listed, it may be permission problem.  You
can figure out which device corresponds to the phone by doing:

     $ ls -l /dev/bus/usb/*
     /dev/bus/usb/001:
     total 0
     ...
     crw-rw-rw- 1 root wheel 189, 5 2010-10-18 16:52 006
     ...

   The timestamp corresponds to when you connected the phone.  Make the
USB connection readable:
     $ sudo chmod a+w /dev/bus/usb/001/006

   Obviously if you spend time developing for an Androd phone you’ll
want to automate this process; this link
(https://sites.google.com/site/siteofhx/Home/android/drivers/udc) or
this link
(https://groups.google.com/forum/?fromgroups=#!topic/android-developers/nTfhhPktGfM)
may be helpful.

   Anyway, once ‘adb’ can talk to the phone, you install in the same way
as before:
     adb install bin/KawaHello-debug.apk

21.3.6 Some debugging notes
---------------------------

You will find a copy of the SDK documentation in
‘$ANDROID_HOME/docs/index.html’.

   If the emulator complains that your application has stopped
unexpectedly, do:
     $ adb logcat

   This shows log messages, stack traces, output from the ‘Log.i’
logging method, and other useful information.  (You can alternatively
start ‘ddms’ (Dalvik Debug Monitor Service), click on the ‘kawa.android
line’ in the top-left sub-window to select it, then from the ‘Device’
menu select ‘Run logcat....’).

   To uninstall your application, do:
     $ adb uninstall kawa.android

21.3.7 Other resources
----------------------

(A more interesting text-to-speech
(http://androidscheme.blogspot.com/2010/10/text-to-speech-app.html)
example app is on Santosh Rajan’s Android-Scheme blog
(http://androidscheme.blogspot.com/).)

   <https://github.com/ecraven/SchemeAndroidOGL>


File: kawa.info,  Node: Android view construction,  Next: System inquiry,  Prev: Building for Android,  Up: Miscellaneous

21.4 Android view construction
==============================

An Android user interface is constructed from ‘View’ objects.  The
following is an example that illustrates some features of Kawa to help
write views hierarchies, The example is self-contained, and can be built
and run as described in *note Building for Android::.

     (require 'android-defs)
     (activity hello
       (on-create-view
        (define counter ::integer 0)
        (define counter-view
          (TextView text: "Not clicked yet."))
        (LinearLayout orientation: LinearLayout:VERTICAL
         (TextView text: "Hello, Android from Kawa Scheme!")
         (Button
          text: "Click here!"
          on-click-listener: (lambda (e)
                               (set! counter (+ counter 1))
                               (counter-view:setText
                                (format "Clicked ~d times." counter))))
         counter-view)))

   The first ‘import’ form imports various useful definitions from the
Kawa Android library.  Using these is not required for writing a Kawa
application, but makes it more convenient.

   The names ‘LinearLayout’, ‘TextView’, and ‘Button’ are just aliases
for standard Android ‘View’ sub-classes.  A few are prefined by
‘(require 'android-defs)’, or you can define them yourself using
‘define-alias’.

   An Android application consists of one or more “activities”, each of
which is an instance of the ‘android.app.Activity’ class.  You can use
the ‘activity’ macro to define your ‘Activity’ class.  The first macro
argument (in this case ‘hello’) is the class name, and the others are
members of the class, in the syntax of a FIELD-OR-METHOD-DECL.  The
sub-form ‘on-create-view’ is an abbreviation for declaring an ‘onCreate’
method (which is called when the ‘Activity’ starts up followed by a
‘setContentView’: The body of the ‘on-create-view’ is evaluated.  The
result should be a ‘View’ expression, which is passed to
‘setContentView’.

 -- Procedure: current-activity [new-value]
     With no arguments, returns the current ‘Activity’.  If a NEW-VALUE
     argument is given, sets the current activity.  It is set
     automatically by the ‘on-create’ and ‘on-create-view’ methods of
     the ‘activity’ macro.

     Since ‘current-activity’ is a *note parameter object: Parameter
     objects, you can locally change the value using *note
     ‘parameterize’: parameterize-syntax.

21.4.1 View object allocation
-----------------------------

To create an instance of a ‘View’ class you “call” the class as if it
were a function, as described in *note Allocating objects::.  For
example:
     (TextView (this) text: "Hello, Android from Kawa Scheme!")

   If you ‘(require 'android-defs)’ that defines some special handling
for ‘View’ classes.  You can leave out the ‘(this)’ argument, which
refers to the enclosing ‘Activity’:
     (TextView text: "Hello, Android from Kawa Scheme!")

21.4.2 Event handlers
---------------------

You can register event listeners on Android ‘View’ objects using methods
typically named ‘setOnEVENTListener’.  For example ‘setOnClickListener’.
When allocating an object you can leave out the ‘set’, and you can
optionally use Scheme-style names: ‘on-click-listener’.  The argument is
an object of a special nested listener class, for example
‘View$OnClickListener’.  These are single-method classes, so you can use
a lambda expression and *note SAM-conversion:: will automatically create
the needed listener class.


File: kawa.info,  Node: System inquiry,  Next: Processes,  Prev: Android view construction,  Up: Miscellaneous

21.5 System inquiry
===================

 -- Variable: home-directory
     A string containing the home directory of the user.

 -- Procedure: command-line
     Returns a nonempty list of immutable strings.  The first element is
     an implementation-specific name for the running top-level program.
     The remaining elements are the command-line arguments, as passed to
     the ‘main’ method (except for those flags processed by Kawa
     itself).

     The first element will depend on how the Kawa module was invoked.
     Kawa uses the following rules to determine the command name:

       1. If the property ‘kawa.command.name’ is set, that is used.
          This variable can be set on the ‘kawa’ command line, for
          example from a script:
               kawa -Dkawa.command.name="$0" foo "$@"
          This variable is also set implicitly by the meta-arg option.
          FIXME.
       2. If we’re reading a source file that starts with the Unix
          command-file prefix ‘#!/’ then we use the name of the source
          file.  The assumption is that such a file is an executable
          script.
       3. If the Java property ‘kawa.command.line’ is set, then we use
          that (after stripping off text that duplicates the remaining
          arguments).  The ‘kawa’ program sets this property to the
          command line used to invoke it (specifically the contents of
          the entire ‘argv’ array), before invoking the ‘java’ program.
       4. If the Java property ‘sun.java.command’ is set, then we use
          that (after stripping off text that duplicates the remaining
          arguments), and then prepending the string ‘"java "’.  The
          OpenJDK ‘java’ program sets this property.
       5. If all else fails, the command name is ‘"kawa"’.

 -- Variable: command-line-arguments
     Any command-line arguments (following flags processed by Kawa
     itself) are assigned to the global variable
     ‘command-line-arguments’, which is a vector of strings.

 -- Procedure: process-command-line-assignments
     Process any initial command-line options that set variables.  These
     have the form ‘NAME=VALUE’.  Any such command-line options (at the
     start of the command-line) are processed and removed from the
     command-line.
          $ java kawa.repl -- abc=123 def
          #|kawa:1|# (write (command-line))
          ("java kawa.repl --" "abc=123" "def")
          #|kawa:2|# (process-command-line-assignments)
          #|kawa:3|# (write (command-line))
          ("java kawa.repl -- abc=123" "def")
          #|kawa:4|# abc
          123
     This function is mostly useful for Kawa applications compiled with
     the ‘--main’ option.  (It is used to set XQuery ‘external’
     variables.)

 -- Procedure: get-environment-variable name
     Many operating systems provide each running process with an
     environment conisting of environment variables.  (This environment
     is not to be confused with the Scheme environments that can be
     passed to ‘eval’.)  Both the name and value of an environment
     variable are strings.  The procedure ‘get-environment-variable’
     returns the value of the environment variable NAME, or ‘#f’ if the
     environment variable is not found.  (This uses the
     ‘java.lang.System:getenv’ method.)  It is an error to mutate the
     resulting string.
          (get-environment-variable "PATH")
              ⇒ "/usr/local/bin:/usr/bin:/bin"

 -- Procedure: get-environment-variables
     Returns the names and values of all the environment variables as an
     alist, where the car of each entry is the name of an environment
     variable, and the cdr is its value, both as strings.  It is an
     error to mutate any of the strings or the alist itself.
          (get-environment-variables)
            ⇒ (("USER" . "root") ("HOME" . "/"))


File: kawa.info,  Node: Processes,  Next: Time-related functions,  Prev: System inquiry,  Up: Miscellaneous

21.6 Processes
==============

A “process” is a native (operating-system-level) application or program
that runs separately from the current virtual machine.

   Many programming languages have facilities to allow access to system
processes (commands).  (For example Java has ‘java.lang.Process’ and
‘java.lang.ProcessBuilder’.)  These facilities let you send data to the
standard input, extract the resulting output, look at the return code,
and sometimes even pipe commands together.  However, this is rarely as
easy as it is using the old Bourne shell; for example command
substitution is awkward.  Kawa’s solution is based on these two ideas:
   • A “process expression” (typically a function call) evaluates to a
     ‘LProcess’ value, which provides access to a Unix-style (or
     Windows) process.
   • In a context requiring a string (or a bytevector), an ‘LProcess’ is
     automatically converted to a string (or bytevector) comprising the
     standard output from the process.

21.6.1 Creating a process
-------------------------

The most flexible way to start a process is with either the
‘run-process’ procedure or the ‘&`{COMMAND}’ syntax for *note process
literals::.

 -- Procedure: run-process PROCESS-KEYWORD-ARGUMENT^{*} COMMAND
     Creates a process object, specifically a
     ‘gnu.kawa.functions.LProcess’ object.  A PROCESS-KEYWORD-ARGUMENT
     can be used to set various options, as discussed below.

     The COMMAND is the process command-line (name and arguments).  It
     can be an array of strings, in which case those are used as the
     command arguments directly:
          (run-process ["ls" "-l"])
     The COMMAND can also be a single string, which is split (tokenized)
     into command arguments separated by whitespace.  Quotation groups
     words together just like traditional shells:
          (run-process "cmd a\"b 'c\"d k'l m\"n'o")
             ⇒ (run-process ["cmd"   "ab 'cd"   "k'l m\"no"])

     The syntax shorthand ‘&`{COMMAND}’ or ‘&sh{COMMAND}’ (discussed
     below) is usually more convenient.

     PROCESS-KEYWORD-ARGUMENT ::=
         PROCESS-REDIRECT-ARGUMENT
       | PROCESS-ENVIRONMENT-ARGUMENT
       | PROCESS-MISC-ARGUMENT

   We discuss PROCESS-REDIRECT-ARGUMENT and PROCESS-ENVIRONMENT-ARGUMENT
later.  The PROCESS-MISC-ARGUMENT options are just the following:
‘shell:’ SHELL
     Currently, SHELL must be one of ‘#f’ (which is ignored) or ‘#t’.
     The latter means to use an external shell to tokenize the COMMAND.
     I.e.  the following are equivalent:
          (run-process shell: #t "COMMAND")
          (run-process ["/bin/sh" "-c" "COMMAND"])
‘directory:’ DIR
     Change the working directory of the new process to DIR.

21.6.2 Process literals
-----------------------

A simple “process literal” is a kind of *note named literal: Named
quasi-literals. that uses the backtick character (‘`’) as the CNAME.
For example:
     &`{date --utc}
   This is equivalent to:
     (run-process "date --utc")

   In general the following are roughly equivalent (using *note string
quasi-literals::):
     &`[ARGS...]{COMMAND}
     (run-process ARGS... &{COMMAND})
   The reason for the “roughly” is if COMMAND contains escaped
sub-expressions; in that case ‘&`’ may process the resulting values
differently from plain string-substitution, as discussed below.

   If you use ‘&sh’ instead of ‘&`’ then a shell is used:
     &sh{rm *.class}
   which is equivalent to:
     &`{/bin/sh -c "rm *.class"}

   In general, the following are equivalent:
     &sh[ARGS...]{COMMAND}
     &`[shell: #t ARGS...]{COMMAND}

21.6.3 Process values and process output
----------------------------------------

The value returned from a call to ‘run-process’ or a process literal is
an instance of ‘gnu.kawa.functions.LProcess’.  This class extends
‘java.lang.Process’, so you can treat it as any other ‘Process’ object.
     #|kawa:1|# (define p1 &`{date --utc})
     #|kawa:2|# (p1:toString)
     gnu.kawa.functions.LProcess@377dca04
     #|kawa:3|# (write p1)
     gnu.kawa.functions.LProcess@377dca04

   What makes an ‘LProcess’ interesting is that it is also a *note blob:
Blobs, which is automatically converted to a string (or bytevector) in a
context that requires it.  The contents of the blob comes from the
standard output of the process.  The blob is evaluated *note lazily:
Lazy evaluation, so data it is only collected when requested.

     #|kawa:4|# (define s1 ::string p1)
     #|kawa:5|# (write s1)
     "Wed Jan  1 01:18:21 UTC 2014\n"
     #|kawa:6|# (define b1 ::bytevector p1)
     (write b1)
     #u8(87 101 100 32 74 97 110 ... 52 10)

   The ‘display’ procedure prints it in “human” form, as a string:
     #|kawa:7|# (display p1)
     Wed Jan  1 01:18:21 UTC 2014
   This is also the default REPL formatting:
     #|kawa:8|# &`{date --utc}
     Wed Jan  1 01:18:22 UTC 2014

   When you type a command to a shell, its output goes to the console,
Similarly, in a REPL the output from the process is copied to the
console output - which can sometimes by optimized by letting the process
inherit its standard output from the Kawa process.

21.6.4 Substitution and tokenization
------------------------------------

To substitute the variable or the result of an expression in the command
line use the usual syntax for quasi literals:
     (define filename (make-temporary-file))
     &sh{run-experiment >&[filename]}

   Since a process is convertible a string, we need no special syntax
for command substitution:
     `{echo The directory is: &[&`{pwd}]}
   or equivalently:
     `{echo The directory is: &`{pwd}}

   Things get more interesting when considering the interaction between
substitution and tokenization.  This is not simple string interpolation.
For example, if an interpolated value contains a quote character, we
want to treat it as a literal quote, rather than a token delimiter.
This matches the behavior of traditional shells.  There are multiple
cases, depending on whether the interpolation result is a string or a
vector/list, and depending on whether the interpolation is inside
quotes.

   • If the value is a string, and we’re not inside quotes, then all
     non-whitespace characters (including quotes) are literal, but
     whitespace still separates tokens:
          (define v1 "a b'c ")
          &`{cmd x y&[v1]z}   ⇒  (run-process ["cmd" "x" "ya" "b'c" "z"])
   • If the value is a string, and we are inside single quotes, all
     characters (including whitespace) are literal.
          &`{cmd 'x y&[v1]z'}   ⇒  (run-process ["cmd" "x ya b'c z"])
     Double quotes work the same except that newline is an argument
     separator.  This is useful when you have one filename per line, and
     the filenames may contain spaces, as in the output from ‘find’:
          &`{ls -l "&`{find . -name '*.pdf'}"}
     This solves a problem that is quite painful with traditional
     shells.
   • If the value is a vector or list (of strings), and we’re not inside
     quotes, then each element of the array becomes its own argument,
     as-is:
          (define v2 ["a b" "c\"d"])
          &`{cmd &[v2]}  ⇒  (run-process ["cmd" "a b" "c\"d"])
     However, if the enclosed expression is adjacent to non-space
     non-quote characters, those are prepended to the first element, or
     appended to the last element, respectively.
          &`{cmd x&[v2]y}   ⇒  (run-process ["cmd" "xa b" "c\"dy"])
          &`{cmd x&[[]]y}   ⇒  (run-process ["cmd" "xy"])
     This behavior is similar to how shells handle ‘"$@"’ (or
     ‘"${name[@]}"’ for general arrays), though in Kawa you would leave
     off the quotes.

     Note the equivalence:
          &`{&[array]}   ⇒  (run-process array)
   • If the value is a vector or list (of strings), and we _are_ inside
     quotes, it is equivalent to interpolating a single string resulting
     from concatenating the elements separated by a space:
          &`{cmd "&[v2]"}
           ⇒  (run-process ["cmd" "a b c\"d"])
     This behavior is similar to how shells handle ‘"$*"’ (or
     ‘"${name[*]}"’ for general arrays).
   • If the value is the result of a call to ‘unescaped-data’ then it is
     parsed as if it were literal.  For example a quote in the unescaped
     data may match a quote in the literal:
          (define vu (unescaped-data "b ' c d '"))
          &`{cmd 'a &[vu]z'}   ⇒  (run-process ["cmd" "a b " "c" "d" "z"])
   • If we’re using a shell to tokenize the command, then we add quotes
     or backslashes as needed so that the shell will tokenize as
     described above:
          (define authors ["O'Conner" "de Beauvoir"])
          &sh{list-books &[authors]}
     The command passed to the shell is:
          list-books 'O'\''Conner' 'de Beauvoir
     Having quoting be handled by the ‘$construct$:sh’ implementation
     automatically eliminates common code injection problems.

   Smart tokenization only happens when using the quasi-literal forms
such as ‘&`{command}’.  You can of course use string templates with
‘run-process’:
     (run-process &{echo The directory is: &`{pwd}})
   However, in that case there is no smart tokenization: The template is
evaluated to a string, and then the resulting string is tokenized, with
no knowledge of where expressions were substituted.

21.6.5 Input/output redirection
-------------------------------

You can use various keyword arguments to specify standard input, output,
and error streams.  For example to lower-case the text in ‘in.txt’,
writing the result to ‘out.txt’, you can do:
     &`[in-from: "in.txt" out-to: "out.txt"]{tr A-Z a-z}
   or:
     (run-process in-from: "in.txt" out-to: "out.txt" "tr A-Z a-z")

   A PROCESS-REDIRECT-ARGUMENT can be one of the following:

‘in:’ VALUE
     The VALUE is evaluated, converted to a string (as if using
     ‘display’), and copied to the input file of the process.  The
     following are equivalent:
          &`[in: "text\n"]{command}
          &`[in: &`{echo "text"}]{command}
     You can pipe the output from ‘command1’ to the input of ‘command2’
     as follows:
          &`[in: &`{command1}]{command2}
‘in-from:’ PATH
     The process reads its input from the specified PATH, which can be
     any value coercible to a ‘filepath’.
‘out-to:’ PATH
     The process writes its output to the specified PATH.
‘err-to:’ PATH
     Similarly for the error stream.
‘out-append-to:’ PATH
‘err-append-to:’ PATH
     Similar to ‘out-to’ and ‘err-to’, but append to the file specified
     by PATH, instead of replacing it.
‘in-from: ’pipe’
‘out-to: ’pipe’
‘err-to: ’pipe’
     Does not set up redirection.  Instead, the specified stream is
     available using the methods ‘getOutputStream’, ‘getInputStream’, or
     ‘getErrorStream’, respectively, on the resulting ‘Process’ object,
     just like Java’s ‘ProcessBuilder.Redirect.PIPE’.
‘in-from: ’inherit’
‘out-to: ’inherit’
‘err-to: ’inherit’
     Inherits the standard input, output, or error stream from the
     current JVM process.
‘out-to:’ PORT
‘err-to:’ PORT
     Redirects the standard output or error of the process to the
     specified PORT.
‘out-to: ’current’
‘err-to: ’current’
     Same as ‘out-to: (current-output-port)’, or ‘err-to:
     (current-error-port)’, respectively.
‘in-from:’ PORT
‘in-from: ’current’
     Re-directs standard input to read from the PORT (or
     ‘(current-input-port)’).  It is unspecified how much is read from
     the PORT.  (The implementation is to use a thread that reads from
     the port, and sends it to the process, so it might read to the end
     of the port, even if the process doesn’t read it all.)
‘err-to: ’out’
     Redirect the standard error of the process to be merged with the
     standard output.

   The default for the error stream (if neither ‘err-to’ or
‘err-append-to’ is specified) is equivalent to ‘err-to: 'current’.

   _Note:_ Writing to a port is implemented by copying the output or
error stream of the process.  This is done in a thread, which means we
don’t have any guarantees when the copying is finished.  (In the future
we might change ‘process-exit-wait’ (discussed later) wait for not only
the process to finish, but also for these helper threads to finish.)

   A here document (https://en.wikipedia.org/wiki/Here_document) is a
form a literal string, typically multi-line, and commonly used in shells
for the standard input of a process.  You can use string literals or
*note string quasi-literals:: for this.  For example, this passes the
string ‘"line1\nline2\nline3\n"’ to the standard input of ‘command’:
     (run-process [in: &{
         &|line1
         &|line2
         &|line3
         }] "command")

   Note the use of ‘&|’ to mark the end of ignored indentation.

21.6.6 Pipe-lines
-----------------

Piping the output of one process as the input of another is in principle
easy - just use the ‘in:’ process argument.  However, writing a
multi-stage pipe-line quickly gets ugly:
     &`[in: &`[in: "My text\n"]{tr a-z A-Z}]{wc}
   The convenience macro ‘pipe-process’ makes this much nicer:
     (pipe-process
       "My text\n"
       &`{tr a-z A-Z}
       &`{wc})

 -- Syntax: pipe-process input process^{*}
     All of the PROCESS expressions must be ‘run-process’ forms, or
     equivalent ‘&`{command}’ forms.  The result of evaluating INPUT
     becomes the input to the first PROCESS; the output from the first
     PROCESS becomes the input to the second PROCESS, and so on.  The
     result of whole ‘pipe-process’ expression is that of the last
     PROCESS.

     Copying the output of one process to the input of the next is
     optimized: it uses a copying loop in a separate thread.  Thus you
     can safely pipe long-running processes that produce huge output.
     This isn’t quite as efficient as using an operating system pipe,
     but is portable and works pretty well.

21.6.7 Setting the process environment
--------------------------------------

By default the new process inherits the system environment of the
current (JVM) process as returned by ‘System.getenv()’, but you can
override it.  A PROCESS-ENVIRONMENT-ARGUMENT can be one of the
following:

‘env-’NAME‘:’ VALUE
     In the process environment, set the ‘"NAME"’ to the specified
     VALUE.  For example:
          &`[env-CLASSPATH: ".:classes"]{java MyClass}
NAME‘:’ VALUE
     Same as using the ‘env-NAME’ option above, but only if the ‘NAME’
     is uppercase (i.e.  if uppercasing ‘NAME’ yields the same string).
     For example the previous example could be written:
          &`[CLASSPATH: ".:classes"]{java MyClass}
‘environment:’ ENV
     The ENV is evaluated and must yield a ‘HashMap’.  This map is used
     as the system environment of the process.

21.6.8 Waiting for process exit
-------------------------------

When a process finishes, it returns an integer exit code.  The code is
traditionally 0 on successful completion, while a non-zero code
indicates some kind of failure or error.

 -- Procedure: process-exit-wait process
     The PROCESS expression must evaluate to a process (any
     ‘java.lang.Process’ object).  This procedure waits for the process
     to finish, and then returns the exit code as an ‘int’.
          (process-exit-wait (run-process "echo foo")) ⇒ 0

 -- Procedure: process-exit-ok? process
     Calls ‘process-exit-wait’, and then returns ‘#false’ if the process
     exited it 0, and returns ‘#true’ otherwise.

     This is useful for emulating the way traditional shell do logic
     control flow operations based on the exit code.  For example in
     ‘sh’ you might write:
          if grep Version Makefile >/dev/null
          then echo found Version
          else echo no Version
          fi

     The equivalent in Kawa:

          (if (process-exit-ok? &`{grep Version Makefile})
            &`{echo found}
            &`{echo not found})

     Strictly speaking these are not quite the same, since the Kawa
     version silently throws away the output from ‘grep’ (because no-one
     has asked for it).  To match the output from the ‘sh’, you can use
     ‘out-to: 'inherit’:
          (if (process-exit-ok? &`[out-to: 'inherit]{grep Version Makefile})
            &`{echo found}
            &`{echo not found})

21.6.9 Exiting the current process
----------------------------------

 -- Procedure: exit [code]
     Exits the Kawa interpreter, and ends the Java session.  Returns the
     value of CODE to the operating system: The CODE must be integer, or
     the special values ‘#f’ (equivalent to -1), or ‘#t’ (equivalent to
     0).  If CODE is not specified, zero is returned.  The CODE is a
     status code; by convention a non-zero value indicates a
     non-standard (error) return.

     Before exiting, finally-handlers (as in ‘try-finally’, or the AFTER
     procedure of ‘dynamic-wind’) are executed, but only in the current
     thread, and only if the current thread was started normally.
     (Specifically if we’re inside an ‘ExitCalled’ block with non-zero
     nesting - see ‘gnu.kawa.util.ExitCalled’.)  Also, JVM shutdown
     hooks are executed - which includes flushing buffers of output
     ports.  (Specifically ‘Writer’ objects registered with the
     ‘WriterManager’.)

 -- Procedure: emergency-exit [code]
     Exits the Kawa interpreter, and ends the Java session.
     Communicates an exit value in the same manner as ‘exit’.  Unlike
     ‘exit’, neither finally-handlers nor shutdown hooks are executed.

21.6.10 Deprecated functions
----------------------------

 -- Procedure: make-process command envp
     Creates a ‘<java.lang.Process>’ object, using the specified COMMAND
     and ENVP.  The COMMAND is converted to an array of Java strings
     (that is an object that has type ‘<java.lang.String[]>’.  It can be
     a Scheme vector or list (whose elements should be Java strings or
     Scheme strings); a Java array of Java strings; or a Scheme string.
     In the latter case, the command is converted using ‘command-parse’.
     The ENVP is process environment; it should be either a Java array
     of Java strings, or the special ‘#!null’ value.

     Except for the representation of ENVP, this is similar to:
          (run-process environment: ENVP COMMAND)

 -- Procedure: system command
     Runs the specified COMMAND, and waits for it to finish.  Returns
     the return code from the command.  The return code is an integer,
     where 0 conventionally means successful completion.  The COMMAND
     can be any of the types handled by ‘make-process’.

     Equivalent to:
          (process-exit-wait (make-process COMMAND #!null))

 -- Variable: command-parse
     The value of this variable should be a one-argument procedure.  It
     is used to convert a command from a Scheme string to a Java array
     of the constituent "words".  The default binding, on Unix-like
     systems, returns a new command to invoke ‘"/bin/sh" "-c"’
     concatenated with the command string; on non-Unix-systems, it is
     bound to ‘tokenize-string-to-string-array’.

 -- Procedure: tokenize-string-to-string-array command
     Uses a ‘java.util.StringTokenizer’ to parse the COMMAND string into
     an array of words.  This splits the COMMAND using spaces to delimit
     words; there is no special processing for quotes or other special
     characters.  (This is the same as what
     ‘java.lang.Runtime.exec(String)’ does.)


File: kawa.info,  Node: Time-related functions,  Next: Low-level functions,  Prev: Processes,  Up: Miscellaneous

21.7 Time-related functions
===========================

 -- Procedure: current-second
     Returns an inexact number represent the current time on the
     International Atomic Time (TAI)
     (http://en.wikipedia.org/wiki/International_Atomic_Time) scale.
     The value 0.0 represents midnight on January 1, 1070 TAI
     (equivalent to 10 seconds before midnight Universal Time), and the
     value 1.0 represents on TAI second later.  Neither high acuracy nor
     high precision are required; in particular returning Coordinated
     Universal Time plus a suitable constant might be the best an
     implementation cat do.  The Kawa implementation just multiplies by
     0.001 the result of calling the method ‘currentTimeMillis’ in class
     ‘java.lang.System’.

 -- Procedure: current-jiffy
     Returns the number of “jiffies” as an exact integer that have
     elapses since an arbitrary implementation-defined epoch (instant).
     A jiffy is an implementation-defined fraction of a second which is
     defined by the return value of the ‘jiffies-per-second’ procedure.
     The starting epoch (instant 0) is guaranteed to be constant during
     a run of the program, but may vary between runs.  (At the time of
     writing, Kawa’s jiffy is one nano-second.)

     _Rationale:_ Jiffies are allowed to be implementation-dependent so
     that ‘current-jiffy’ can execute with minimal overhead.  It should
     be very likely that a compactly represented integer will suffice as
     the return value.  Any particular jiffy size will be inappropriate
     some some implementations: a microsecond is too long for a very
     fast machine, while a much smaller unit would force many
     implementations to return integers which have to allocated for most
     calls, rendering ‘current-jiffy’ less useful for accurate timing
     measurements.

 -- Procedure: jiffies-per-second
     Returns an exact integer representing the number of jiffies per SI
     second.  This value is an implementation-specified constant.  (At
     the time of writing, the value in Kawa is 1,000,000,000.)

 -- Procedure: sleep time
     Suspends the current thread for the specified time.  The TIME can
     be either a pure number (in secords), or a quantity whose unit is a
     time unit (such as ‘10s’).


File: kawa.info,  Node: Low-level functions,  Prev: Time-related functions,  Up: Miscellaneous

21.8 Deprecated low-level functions
===================================

These sections document older and less convenient ways to call Java
methods, access Java fields, and use Java arrays.

21.8.1 Low-level Method invocation
----------------------------------

The following lower-level primitives require you to specify the
parameter and return types explicitly.  You should probably use the
functions ‘invoke’ and ‘invoke-static’ (*note Method operations::)
instead.

 -- Syntax: primitive-constructor class (argtype ...)
     Returns a new anonymous procedure, which when called will create a
     new object of the specified class, and will then call the
     constructor matching the specified argument types.

 -- Syntax: primitive-virtual-method class method rtype (argtype ...)
     Returns a new anonymous procedure, which when called will invoke
     the instance method whose name is the string METHOD in the class
     whose name is CLASS.

 -- Syntax: primitive-static-method class method rtype (argtype ...)
     Returns a new anonymous procedure, which when called will invoke
     the static method whose name is the string METHOD in the class
     whose name is CLASS.

 -- Syntax: primitive-interface-method interface method rtype (argtype
          ...)
     Returns a new anonymous procedure, which when called will invoke
     the matching method from the interface whose name is INTERFACE.

   The macros return procedure values, just like ‘lambda’.  If the
macros are used directly as the procedure of a procedure call, then kawa
can inline the correct bytecodes to call the specified methods.  (Note
also that neither macro checks that there really is a method that
matches the specification.)  Otherwise, the Java reflection facility is
used.

21.8.2 Low-level field operations
---------------------------------

The following macros evaluate to procedures that can be used to access
or change the fields of objects or static fields.  The compiler can
inline each to a single bytecode instruction (not counting type
conversion).

   These macros are deprecated.  The ‘fields’ and ‘static-field’
functions (*note Field operations::) are easier to use, more powerful,
and just as efficient.  However, the high-level functions currently do
not provide access to non-public fields.

 -- Syntax: primitive-get-field class fname ftype
     Use this to access a field named FNAME having type TYPE in class
     CLASS.  Evaluates to a new one-argument procedure, whose argument
     is a reference to an object of the specified CLASS.  Calling that
     procedure returns the value of the specified field.

 -- Syntax: primitive-set-field class fname ftype
     Use this to change a field named FNAME having type TYPE in class
     CLASS.  Evaluates to a new two-argument procedure, whose first
     argument is a reference to an object of the specified CLASS, and
     the second argument is the new value.  Calling that procedure sets
     the field to the specified value.  (This macro’s name does not end
     in a ‘!’, because it does not actually set the field.  Rather, it
     returns a function for setting the field.)

 -- Syntax: primitive-get-static class fname ftype
     Like ‘primitive-get-field’, but used to access static fields.
     Returns a zero-argument function, which when called returns the
     value of the static field.

 -- Syntax: primitive-set-static class fname ftype
     Like ‘primitive-set-field’, but used to modify static fields.
     Returns a one-argument function, which when called sets the value
     of the static field to the argument.

21.8.3 Old low-level array macros
---------------------------------

The following macros evaluate to procedures that can be used to
manipulate primitive Java array objects.  The compiler can inline each
to a single bytecode instruction (not counting type conversion).

 -- Syntax: primitive-array-new element-type
     Evaluates to a one-argument procedure.  Applying the resulting
     procedure to an integer count allocates a new Java array of the
     specified length, and whose elements have type ELEMENT-TYPE.

 -- Syntax: primitive-array-set element-type
     Evaluates to a three-argument procedure.  The first argument of the
     resulting procedure must be an array whose elements have type
     ELEMENT-TYPE; the second argument is an index; and the third
     argument is a value (coercible to ELEMENT-TYPE) which replaces the
     value specified by the index in the given array.

 -- Syntax: primitive-array-get element-type
     Evaluates to a two-argument procedure.  The first argument of the
     resulting procedure must be an array whose elements have type
     ELEMENT-TYPE; the second argument is an index.  Applying the
     procedure returns the element at the specified index.

 -- Syntax: primitive-array-length element-type
     Evaluates to a one-argument procedure.  The argument of the
     resulting procedure must be an array whose elements have type
     ELEMENT-TYPE.  Applying the procedure returns the length of the
     array.  (Alternatively, you can use ‘(field ARRAY 'length)’.)


File: kawa.info,  Node: FAQs,  Next: Framework,  Prev: Miscellaneous,  Up: Top

22 Frequently Asked Questions
*****************************

What is the equivalent of Java import?
......................................

To provide a short name for a class instead of the complete
fully-qualified name use either ‘define-alias’ (or
‘define-private-alias’) or the ‘import’-‘class’ combination.  For
example, to be able to write ‘ArrayList’ instead of
‘java.util.ArrayList’ do either:
     (import (class java.util ArrayList))
   or
     (define-alias ArrayList java.util.ArrayList)
   Using ‘import’ is recommended: It handles errors better, and it
allows you to define multiple aliases conveniently:
     (import (class java.util Map HashMap))

   Both forms allow renaming.  For example if you want to refer to
‘java.lang.StringBuilder’ as ‘StrBuf’ do:
     (import (class java.lang (StringBuilder StrBuf)))
   or:
     (define-alias StrBuf java.lang.StringBuilder)

   The name(s) defined by ‘import’ are by default private.  A name
defined using ‘define-alias’ is by default exported; to avoid that use
‘define-private-alias’ instead.

   You can also use ‘define-namespace’ to introduce an abbreviation or
renaming of a class name, but as a matter of style ‘define-alias’ is
preferred.

   There is no direct equivalent to Java’s ‘import PackageOrTypeName.*’
(type-import-on-demand) declaration, but you can alias a package:
     (define-alias jutil java.util)
     (define mylist :: jutil:List (jutil:ArrayList))

   To import a static member, giving it a shortened name (like Java’s
static-import-on-demand declaration), you can use ‘define-alias’.  For
example:
     (define-alias console java.lang.System:console)

   For static fields only (not methods or member classes) you can use an
‘import’ form, either:
     (import (only (java lang System) out))
   or:
     (import (only java.lang.System out))
   This works because Kawa can treat any class as a “library”; in which
case it considers all public static fields as exported bindings.

How do I refer to a Java member (nested) class?
...............................................

Consider the Java SE member class
‘javax.swing.text.AbstractDocument.Content’.  Using the Java syntax
doesn’t work in Kawa.  Inside you should use Kawa’s colon operator:
     javax.swing.text.AbstractDocument:Content
   Alternatively, you can use the internal JVM class name:
     javax.swing.text.AbstractDocument$Content

Why does Kawa’s REPL use display rather than write?
...................................................

The read-eval-print-loop of most Scheme implementations prints the
evaluation result using ‘write’, while Kawa uses ‘display’ by default.

   First note that it is easy to override the default with the
‘--output-format’ command-line option:
     $kawa --output-format readable-scheme
     #|kawa:1|# "abc"
     "abc"

   The reason ‘display’ is the default is because of a vision of the
REPL console as more than just printing out Scheme objects in textual
form for use by a programmer.  Some examples:
   • A math program can display equations and graphs as the output of an
     expression.
   • An expression can evaluate to a“*note picture: Composable
     pictures.” which would be displayed inline.
   • An HTML/XML obj can be insert into the output in visual form if the
     console understands HTML. (There is a prototype for this that works
     by using the JavaFX WebView as the display.)
   • The plan for "Kawa-shell" functionality is to have expressions that
     evaluate to process objects, which would be lazy strings.  This
     string would be the data from standard output.  Thus the effect of
     displaying a process object would be to print out the standard
     output - just like a regular shell.  Users would find it
     confusing/annoying if shell output used quotes.

   This "repl-as-pad" model doesn’t work as well if the repl uses
‘write’ rather than ‘display’.


File: kawa.info,  Node: Framework,  Next: License,  Prev: FAQs,  Up: Top

23 The Kawa language framework
******************************

Kawa is a framework written in Java for implementing high-level and
dynamic languages, compiling them into Java bytecodes.

   The Kawa distributions includes of other programming languages
besides Scheme, including XQuery (Qexo) (../qexo/index.html) and Emacs
Lisp (JEmacs) (http://JEmacs.sourceforge.net/).

   For a technical overview of Kawa, see these
<http://www.gnu.org/software/kawa/internals/index.html>.  Javadoc
generated documentation of the Kawa classes
(http://www.gnu.org/software/kawa/api/) is also available.  The packages
‘gnu.bytecode’
(http://www.gnu.org/software/kawa/api/gnu/bytecode/package-summary.html),
‘gnu.math’
(http://www.gnu.org/software/kawa/api/gnu/math/package-summary.html),
‘gnu.lists’
(http://www.gnu.org/software/kawa/api/gnu/lists/package-summary.html),
‘gnu.xml’
(http://www.gnu.org/software/kawa/api/gnu/xml/package-summary.html),
‘gnu.expr’
(http://www.gnu.org/software/kawa/api/gnu/expr/package-summary.html),
‘gnu.mapping’
(http://www.gnu.org/software/kawa/api/gnu/mapping/package-summary.html),
and ‘gnu.text’
(http://www.gnu.org/software/kawa/api/gnu/text/package-summary.html),
are used by Kawa, and distributed with it, but may be independently
useful.

   This article (gnu.bytecode/compiling-regexps.html) explains how to
use ‘gnu.bytecode’ to compile regular expressions to bytecode.


File: kawa.info,  Node: License,  Next: Overall Index,  Prev: Framework,  Up: Top

24 License
**********

* Menu:

* Software-License::      License for the Kawa software
* Manual-License::        License for the Kawa manual


File: kawa.info,  Node: Software-License,  Next: Manual-License,  Up: License

24.1 License for the Kawa software
==================================

The license for the Kawa software (except the optional JEmacs and BRL
features - see below) is the X11/MIT license
(http://opensource.org/licenses/mit-license.php) which is quoted below.

     The software (with related files and documentation) in these packages
     are copyright (C) 1996-2009  Per Bothner.

     Permission is hereby granted, free of charge, to any person obtaining
     a copy of this software and associated documentation files (the
     "Software"), to deal in the Software without restriction, including
     without limitation the rights to use, copy, modify, merge, publish,
     distribute, sublicense, and/or sell copies of the Software, and to
     permit persons to whom the Software is furnished to do so, subject to
     the following conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   In the past the Kawa license was a “modified GNU GPL (General Public
License)".  If you find any files that contain the old license or
otherwise seem to contradict the new license, please report that as a
bug.

   Some of the JEmacs files are based on Emacs and have a GPL license,
which is incompatible with non-Free (proprietary) products.  For that
reason, the ‘gnu.jemacs.*’ packages are not included any more in the
standard ‘.jar’, or by default when building from source, to avoid
surprises.  To build JEmacs you have to specify the ‘configure’ flag
‘--enable-jemacs’ or the ‘ant’ flag ‘-Denable-jemacs=true’.

   Some code in ‘gnu/brl’ and ‘gnu/kawa/brl’ is copyright Bruce R. Lewis
and Eaton Vance Management, with a modified-GPL license: no restrictions
if used unmodified, but otherwise the GPL applies.  These packages are
no longer included by default in Kawa builds, but have to be selected
with the ‘configure’ flag ‘--enable-brl’ or the ‘ant’ flag
‘-Denable-brl=true’.

   Kawa uses some math routines from fdlib’s libf77, which have a AT&T
Bell Laboratories and Bellcore copyright.  See the source file
‘gnu/math/DComplex.java’.

   The sorting routine in ‘gnu.xquery.util.OrderedTuples’ is a
re-implementatiomn in Java of code copyrighted by Simon Tatham.

   Some of the Scheme code in ‘kawa/lib’ and ‘gnu/kawa/slib’ are
copyright other parties, and may have slightly different license
wording, but I believe none of then contradicts the main Kawa license or
impose extra restrictions.  Search for the word ‘copyright’ in these
directories.

   Some code has been converted from other languages, with permission.
This includes the ‘rationalize’ method in ‘gnu/math/RatNum.java’, based
on an algorithm of Alan Bawden, as expressed by Marc Feeley in C-Gambit.
The concepts and algorithm of ‘gnu/text/PrettyWriter.java’ are converted
from SBCL, which is in the public domain.


File: kawa.info,  Node: Manual-License,  Prev: Software-License,  Up: License

24.2 License for the Kawa manual
================================

Here is the copyright license for this manual:

   Copyright © 1996, 1997, 1998, 1999, 2005 Per Bothner

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the author.

   Parts of this manual are copied from the R6RS (http://www.r6rs.org/)
or R7RS (http://www.r7rs.org/), which both state:
     We intend this report to belong to the entire Scheme community, and
     so we grant permission to copy it in whole or in part without fee.
     In particular, we encourage implementors of Scheme to use this
     report as a starting point for manuals and other documentation,
     modifying it as necessary.

   Parts of this manual were derived from the SLIB manual, copyright ©
1993-1998 Todd R. Eigenschink and Aubrey Jaffer.

   Parts of this manual were derived from ISO/EIC 10179:1996(E)
(Document Style and Specifical Language) - unknown copyright.

   This manual has quoted from SRFI-6 (Basic String Ports), which is
Copyright (C) William D Clinger (1999).  All Rights Reserved.

   This manual has quoted from SRFI-8 (receive: Binding to multiple
values), which is Copyright (C) John David Stone (1999).  All Rights
Reserved.

   This manual has quoted from SRFI-9 (Defining Record Types) which is
Copyright (C) Richard Kelsey (1999).  All Rights Reserved.

   This manual has quoted from SRFI-11 (Syntax for receiving multiple
values), which is Copyright (C) Lars T. Hansen (1999).  All Rights
Reserved.

   This manual has quoted from SRFI-25 (Multi-dimensional Array
Primitives), which is Copyright (C) Jussi Piitulainen (2001).  All
Rights Reserved.

   This manual has quoted from SRFI-26 (Notation for Specializing
Parameters without Currying), which is Copyright (C) Sebastian Egner
(2002).  All Rights Reserved.

   This manual has quoted from SRFI-39 (Parameter objects), which is
Copyright (C) Marc Feeley (2002).  All Rights Reserved.

   The following notice applies to SRFI-6, SRFI-8, SRFI-9, SRFI-11,
SRFI-25, SRFI-26, and SRFI-39, which are quoted in this manual, but it
does not apply to the manual as a whole:

     This document and translations of it may be copied and furnished to
     others, and derivative works that comment on or otherwise explain
     it or assist in its implementation may be prepared, copied,
     published and distributed, in whole or in part, without restriction
     of any kind, provided that the above copyright notice and this
     paragraph are included on all such copies and derivative works.
     However, this document itself may not be modified in any way, such
     as by removing the copyright notice or references to the Scheme
     Request For Implementation process or editors, except as needed for
     the purpose of developing SRFIs in which case the procedures for
     copyrights defined in the SRFI process must be followed, or as
     required to translate it into languages other than English.

     The limited permissions granted above are perpetual and will not be
     revoked by the authors or their successors or assigns.

     This document and the information contained herein is provided on
     an "AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
     WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
     WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE
     ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
     FOR A PARTICULAR PURPOSE.

   This manual has quoted from SRFI-69 (Basic hash tables), which is
Copyright (C) Panu Kalliokoski (2005).  All Rights Reserved.

   The following notice applies to SRFI-69, which is quoted in this
manual, but it does not apply to the manual as a whole:

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the Software), to deal in the Software without restriction,
     including without limitation the rights to use, copy, modify,
     merge, publish, distribute, sublicense, and/or sell copies of the
     Software, and to permit persons to whom the Software is furnished
     to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
     BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
     ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     SOFTWARE.

   This manual has made use of text and examples from Dorai Sitaram’s
‘pregexp’ implementation.  But not where the latter talks about
‘pregexp-xxx’ functions; the manual also talks about the ‘regex-xxx’
functions (which are similar but use a slightly different regular
expression syntax).  The ‘pregexp’ distribution has the following
‘COPYING’ file:
     Copyright (c) 1999-2005, Dorai Sitaram.  All rights reserved.

     Permission to copy, modify, distribute, and use this work or a
     modified copy of this work, for any purpose, is hereby granted,
     provided that the copy includes this copyright notice, and in the
     case of a modified copy, also includes a notice of modification.
     This work is provided as is, with no warranty of any kind.


File: kawa.info,  Node: Overall Index,  Prev: License,  Up: Top

Appendix A Index
****************

 [index ]
* Menu:

* !:                                     Definitions.        (line   10)
* #!eof:                                 Special named constants.
                                                             (line   18)
* #!fold-case:                           Lexical syntax.     (line  201)
* #!key:                                 Special named constants.
                                                             (line   14)
* #!no-fold-case:                        Lexical syntax.     (line  202)
* #!null:                                Special named constants.
                                                             (line   30)
* #!optional:                            Special named constants.
                                                             (line    6)
* #!rest:                                Special named constants.
                                                             (line   10)
* #!void:                                Special named constants.
                                                             (line   26)
* &D[:                                   Composable pictures.
                                                             (line   72)
* &P[:                                   Composable pictures.
                                                             (line   60)
* *:                                     Arithmetic operations.
                                                             (line   86)
* * <1>:                                 Quaternions.        (line   54)
* *print-base*:                          Ports.              (line  594)
* *print-miser-width*:                   Ports.              (line  612)
* *print-radix*:                         Ports.              (line  600)
* *print-right-margin*:                  Ports.              (line  609)
* *print-xml-indent*:                    Ports.              (line  617)
* +:                                     Arithmetic operations.
                                                             (line   85)
* + <1>:                                 Quaternions.        (line   52)
* -:                                     Arithmetic operations.
                                                             (line  125)
* - <1>:                                 Arithmetic operations.
                                                             (line  126)
* - <2>:                                 Quaternions.        (line   53)
* --no-warn-WHATEVER:                    Options.            (line  200)
* --output-format:                       Options.            (line  301)
* --warn-WHATEVER:                       Options.            (line  200)
* ->image:                               Composable pictures.
                                                             (line  469)
* ->paint:                               Composable pictures.
                                                             (line  142)
* ->shape:                               Arrays.             (line   57)
* /:                                     Arithmetic operations.
                                                             (line  146)
* / <1>:                                 Arithmetic operations.
                                                             (line  147)
* / <2>:                                 Quaternions.        (line   55)
* / <3>:                                 Quaternions.        (line   56)
* ?:                                     Conditionals.       (line   33)
* ~$:                                    Format.             (line  152)
* ~%:                                    Format.             (line  166)
* ~&:                                    Format.             (line  170)
* ~(:                                    Format.             (line  198)
* ~*:                                    Format.             (line  206)
* ~;:                                    Format.             (line  225)
* ~?:                                    Format.             (line  194)
* ~a:                                    Format.             (line   47)
* ~b:                                    Format.             (line   95)
* ~c:                                    Format.             (line   60)
* ~d:                                    Format.             (line   71)
* ~e:                                    Format.             (line  135)
* ~f:                                    Format.             (line  129)
* ~g:                                    Format.             (line  141)
* ~newline:                              Format.             (line  182)
* ~o:                                    Format.             (line   87)
* ~p:                                    Format.             (line  114)
* ~r:                                    Format.             (line  103)
* ~s:                                    Format.             (line   53)
* ~t:                                    Format.             (line  188)
* ~x:                                    Format.             (line   79)
* ~[:                                    Format.             (line  220)
* ~^:                                    Format.             (line  240)
* ~{:                                    Format.             (line  233)
* ~|:                                    Format.             (line  174)
* ~~:                                    Format.             (line  178)
* abbrev-prefix:                         Datum syntax.       (line   62)
* abbreviation:                          Datum syntax.       (line   60)
* abs:                                   Arithmetic operations.
                                                             (line  256)
* acos:                                  Arithmetic operations.
                                                             (line  365)
* acos <1>:                              Quaternions.        (line   65)
* acosh:                                 Arithmetic operations.
                                                             (line  399)
* affine-transform:                      Composable pictures.
                                                             (line  248)
* affine-transform <1>:                  Composable pictures.
                                                             (line  249)
* alist->hash-table:                     Hash tables.        (line  252)
* alternate:                             Conditionals.       (line   49)
* and:                                   Conditionals.       (line  196)
* angle:                                 Quaternions.        (line   95)
* annotation:                            Annotations.        (line   26)
* annotation-element-pair:               Annotations.        (line   29)
* annotation-element-value:              Annotations.        (line   30)
* annotation-or-type:                    Extended formals.   (line   70)
* annotation-typename:                   Annotations.        (line   31)
* annotations-element-values:            Annotations.        (line   27)
* any-bits-set?:                         Logical Number Operations.
                                                             (line  197)
* apos-attribute-datum:                  XML literals.       (line  108)
* apply:                                 Application and Arguments Lists.
                                                             (line  185)
* arglist:                               Application and Arguments Lists.
                                                             (line  115)
* arglist <1>:                           Application and Arguments Lists.
                                                             (line  116)
* arglist-arg-count:                     Application and Arguments Lists.
                                                             (line  154)
* arglist-arg-ref:                       Application and Arguments Lists.
                                                             (line  159)
* arglist-key-count:                     Application and Arguments Lists.
                                                             (line  147)
* arglist-key-index:                     Application and Arguments Lists.
                                                             (line  172)
* arglist-key-ref:                       Application and Arguments Lists.
                                                             (line  165)
* arglist-key-start:                     Application and Arguments Lists.
                                                             (line  150)
* arglist-key-value:                     Application and Arguments Lists.
                                                             (line  177)
* arglist-walk:                          Application and Arguments Lists.
                                                             (line  133)
* argvector:                             Application and Arguments Lists.
                                                             (line   90)
* argvector <1>:                         Application and Arguments Lists.
                                                             (line   91)
* arithmetic-shift:                      Logical Number Operations.
                                                             (line  226)
* array:                                 Arrays.             (line  135)
* array <1>:                             Arrays.             (line  267)
* array->vector:                         Arrays.             (line  600)
* array-bound:                           Arrays.             (line  167)
* array-copy!:                           Arrays.             (line  494)
* array-end:                             Arrays.             (line  122)
* array-fill!:                           Arrays.             (line  498)
* array-flatten:                         Arrays.             (line  599)
* array-index-ref:                       Arrays.             (line  373)
* array-index-share:                     Arrays.             (line  547)
* array-literal:                         Arrays.             (line  165)
* array-literal-header:                  Arrays.             (line  166)
* array-rank:                            Arrays.             (line  112)
* array-ref:                             Arrays.             (line  355)
* array-ref <1>:                         Arrays.             (line  356)
* array-reshape:                         Arrays.             (line  552)
* array-set!:                            Arrays.             (line  478)
* array-set! <1>:                        Arrays.             (line  479)
* array-shape:                           Arrays.             (line  108)
* array-size:                            Arrays.             (line  127)
* array-start:                           Arrays.             (line  118)
* array-transform:                       Arrays.             (line  512)
* array?:                                Arrays.             (line   32)
* arrayN:                                Arrays.             (line  136)
* arrayN[ETYPE]:                         Arrays.             (line  138)
* array[ETYPE]:                          Arrays.             (line  137)
* as:                                    Type tests and conversions.
                                                             (line   28)
* as-xml:                                Formatting XML.     (line   43)
* ash:                                   Logical Number Operations.
                                                             (line  229)
* asin:                                  Arithmetic operations.
                                                             (line  364)
* asin <1>:                              Quaternions.        (line   64)
* asinh:                                 Arithmetic operations.
                                                             (line  398)
* atan:                                  Arithmetic operations.
                                                             (line  366)
* atan <1>:                              Arithmetic operations.
                                                             (line  367)
* atan <2>:                              Quaternions.        (line   66)
* atanh:                                 Arithmetic operations.
                                                             (line  400)
* atmosphere:                            Lexical syntax.     (line   77)
* attribute-name:                        Creating XML nodes. (line   38)
* base-uri:                              Eval and Environments.
                                                             (line   66)
* binary-port?:                          Ports.              (line   58)
* bit-count:                             Logical Number Operations.
                                                             (line  201)
* bit-extract:                           Logical Number Operations.
                                                             (line  261)
* bit-field:                             Logical Number Operations.
                                                             (line  220)
* bit-set?:                              Logical Number Operations.
                                                             (line  214)
* bitwise-and:                           Logical Number Operations.
                                                             (line   15)
* bitwise-arithmetic-shift:              Logical Number Operations.
                                                             (line  112)
* bitwise-arithmetic-shift-left:         Logical Number Operations.
                                                             (line  124)
* bitwise-arithmetic-shift-right:        Logical Number Operations.
                                                             (line  125)
* bitwise-bit-count:                     Logical Number Operations.
                                                             (line   36)
* bitwise-bit-field:                     Logical Number Operations.
                                                             (line   83)
* bitwise-bit-set?:                      Logical Number Operations.
                                                             (line   64)
* bitwise-copy-bit:                      Logical Number Operations.
                                                             (line   73)
* bitwise-copy-bit-field:                Logical Number Operations.
                                                             (line   93)
* bitwise-first-bit-set:                 Logical Number Operations.
                                                             (line   57)
* bitwise-if:                            Logical Number Operations.
                                                             (line   25)
* bitwise-ior:                           Logical Number Operations.
                                                             (line   16)
* bitwise-length:                        Logical Number Operations.
                                                             (line   42)
* bitwise-merge:                         Logical Number Operations.
                                                             (line  194)
* bitwise-not:                           Logical Number Operations.
                                                             (line    9)
* bitwise-reverse-bit-field:             Logical Number Operations.
                                                             (line  158)
* bitwise-rotate-bit-field:              Logical Number Operations.
                                                             (line  137)
* bitwise-xor:                           Logical Number Operations.
                                                             (line   17)
* body:                                  Bodies.             (line   77)
* boolean:                               Boolean values.     (line   10)
* boolean <1>:                           Boolean values.     (line   45)
* boolean=?:                             Boolean values.     (line   58)
* boolean?:                              Boolean values.     (line   51)
* booleans->integer:                     Logical Number Operations.
                                                             (line  251)
* border:                                Composable pictures.
                                                             (line  337)
* bound-identifier=?:                    Macros.             (line  323)
* bounded-range:                         Ranges.             (line   34)
* build-array:                           Arrays.             (line  290)
* byte:                                  Numerical types.    (line   54)
* bytevector:                            Bytevectors.        (line   28)
* bytevector <1>:                        Bytevectors.        (line   31)
* bytevector-append:                     Bytevectors.        (line   91)
* bytevector-copy:                       Bytevectors.        (line   65)
* bytevector-copy!:                      Bytevectors.        (line   73)
* bytevector-length:                     Bytevectors.        (line   48)
* bytevector-u8-ref:                     Bytevectors.        (line   51)
* bytevector-u8-set!:                    Bytevectors.        (line   57)
* bytevector?:                           Bytevectors.        (line   37)
* call-with-input-file:                  Ports.              (line   46)
* call-with-input-string:                Ports.              (line  209)
* call-with-output-file:                 Ports.              (line   47)
* call-with-output-string:               Ports.              (line  214)
* call-with-port:                        Ports.              (line   33)
* call-with-values:                      Multiple values.    (line   11)
* case:                                  Conditionals.       (line  121)
* case <1>:                              Conditionals.       (line  122)
* case-clause:                           Conditionals.       (line  125)
* case-else-clause:                      Conditionals.       (line  127)
* case-key:                              Conditionals.       (line  124)
* catch:                                 Exceptions.         (line  186)
* ceiling:                               Arithmetic operations.
                                                             (line  288)
* char:                                  Characters.         (line   49)
* char->integer:                         Characters.         (line  106)
* char-alphabetic?:                      Unicode.            (line   93)
* char-ci<=?:                            Unicode.            (line   84)
* char-ci<?:                             Unicode.            (line   82)
* char-ci=?:                             Unicode.            (line   81)
* char-ci>=?:                            Unicode.            (line   85)
* char-ci>?:                             Unicode.            (line   83)
* char-downcase:                         Unicode.            (line   14)
* char-foldcase:                         Unicode.            (line   16)
* char-general-category:                 Unicode.            (line  120)
* char-lower-case?:                      Unicode.            (line   97)
* char-numeric?:                         Unicode.            (line   94)
* char-or-entity-name:                   String literals.    (line  127)
* char-ready?:                           Ports.              (line  309)
* char-ref:                              String literals.    (line  122)
* char-set:                              Character sets.     (line   20)
* char-title-case?:                      Unicode.            (line   98)
* char-titlecase:                        Unicode.            (line   15)
* char-upcase:                           Unicode.            (line   13)
* char-upper-case?:                      Unicode.            (line   96)
* char-whitespace?:                      Unicode.            (line   95)
* char<=?:                               Characters.         (line  131)
* char<?:                                Characters.         (line  129)
* char=?:                                Characters.         (line  128)
* char>=?:                               Characters.         (line  132)
* char>?:                                Characters.         (line  130)
* char?:                                 Characters.         (line  102)
* character:                             Standard Types.     (line   52)
* character <1>:                         Characters.         (line   36)
* character <2>:                         Characters.         (line   61)
* character-except-x:                    Lexical syntax.     (line  155)
* character-or-eof:                      Characters.         (line   42)
* child-value:                           Allocating objects. (line   83)
* circle:                                Composable pictures.
                                                             (line  128)
* class-methods:                         Method operations.  (line  195)
* class-name:                            Defining new classes.
                                                             (line   32)
* close-input-port:                      Ports.              (line  154)
* close-output-port:                     Ports.              (line  155)
* close-port:                            Ports.              (line  153)
* cname:                                 Named quasi-literals.
                                                             (line   44)
* coding specifier:                      Bodies.             (line   31)
* colatitude:                            Quaternions.        (line  161)
* colon notation:                        Colon notation.     (line    6)
* command-line:                          System inquiry.     (line    9)
* command-line-arguments:                System inquiry.     (line   40)
* command-parse:                         Processes.          (line  433)
* comment:                               Lexical syntax.     (line   69)
* comment <1>:                           Creating XML nodes. (line   41)
* comment <2>:                           Creating XML nodes. (line   46)
* comment-cont:                          Lexical syntax.     (line   76)
* comment-text:                          Lexical syntax.     (line   75)
* compile-file:                          Archive compilation.
                                                             (line    6)
* complex:                               Numerical types.    (line   33)
* complex-part:                          Quaternions.        (line  130)
* compound-datum:                        Datum syntax.       (line   22)
* cond:                                  Conditionals.       (line   72)
* cond <1>:                              Conditionals.       (line   73)
* cond-clause:                           Conditionals.       (line   75)
* cond-expand:                           Syntax and conditional compilation.
                                                             (line    9)
* cond-expand-clause:                    Syntax and conditional compilation.
                                                             (line   11)
* configure options:                     Source distribution.
                                                             (line   77)
* conjugate:                             Quaternions.        (line  193)
* consequent:                            Conditionals.       (line   48)
* constant:                              Primitive expression syntax.
                                                             (line   15)
* constant-fold:                         Application and Arguments Lists.
                                                             (line  194)
* constituent:                           Lexical syntax.     (line  132)
* constructor-value:                     Allocating objects. (line   81)
* copy-bit:                              Logical Number Operations.
                                                             (line  217)
* copy-bit-field:                        Logical Number Operations.
                                                             (line  223)
* copy-file:                             Files.              (line   32)
* cos:                                   Arithmetic operations.
                                                             (line  362)
* cos <1>:                               Quaternions.        (line   62)
* cosh:                                  Arithmetic operations.
                                                             (line  396)
* create-directory:                      Files.              (line   36)
* cross-product:                         Quaternions.        (line  187)
* current-activity:                      Android view construction.
                                                             (line   47)
* current-error-port:                    Ports.              (line   80)
* current-input-port:                    Ports.              (line   78)
* current-jiffy:                         Time-related functions.
                                                             (line   19)
* current-output-port:                   Ports.              (line   79)
* current-path:                          Paths.              (line   35)
* current-second:                        Time-related functions.
                                                             (line    6)
* current-servlet:                       Servlets.           (line  156)
* current-servlet-config:                Servlets.           (line  167)
* current-servlet-context:               Servlets.           (line  163)
* cut:                                   Partial application.
                                                             (line    6)
* cute:                                  Partial application.
                                                             (line   47)
* datum:                                 Datum syntax.       (line   13)
* datum->syntax:                         Macros.             (line  463)
* datum->syntax-object:                  Macros.             (line  464)
* datum-label:                           Datum syntax.       (line   31)
* decimal:                               Lexical syntax.     (line  223)
* default-prompter:                      Ports.              (line  517)
* define:                                Definitions.        (line   21)
* define <1>:                            Definitions.        (line   25)
* define <2>:                            Definitions.        (line   27)
* define-alias:                          Locations.          (line   54)
* define-base-unit:                      Quantities.         (line   43)
* define-class:                          Defining new classes.
                                                             (line   20)
* define-constant:                       Definitions.        (line   50)
* define-early-constant:                 Definitions.        (line   51)
* define-enum:                           Enumerations.       (line   32)
* define-library:                        Module classes.     (line   78)
* define-macro:                          Macros.             (line  108)
* define-namespace:                      Namespaces.         (line  123)
* define-private:                        Definitions.        (line   46)
* define-private <1>:                    Definitions.        (line   47)
* define-private-alias:                  Locations.          (line   59)
* define-private-namespace:              Namespaces.         (line  162)
* define-procedure:                      Procedure properties.
                                                             (line   40)
* define-record-type:                    Record types.       (line   13)
* define-simple-class:                   Defining new classes.
                                                             (line   22)
* define-syntax:                         Macros.             (line   65)
* define-syntax-case:                    Macros.             (line   91)
* define-unit:                           Quantities.         (line   48)
* define-values:                         Multiple values.    (line   25)
* define-variable:                       Definitions.        (line   66)
* define-xml-namespace:                  Namespaces.         (line  187)
* defined-datum:                         Datum syntax.       (line   33)
* defining-datum:                        Datum syntax.       (line   32)
* defmacro:                              Macros.             (line  111)
* deg:                                   Quantities.         (line   71)
* delay:                                 Lazy evaluation.    (line   38)
* delay-force:                           Lazy evaluation.    (line   47)
* delete-file:                           Files.              (line   26)
* delimiter:                             Lexical syntax.     (line   40)
* denominator:                           Arithmetic operations.
                                                             (line  276)
* deprecated-return-specifier:           Defining new classes.
                                                             (line  164)
* digit:                                 Lexical syntax.     (line  141)
* digit-10:                              Lexical syntax.     (line  246)
* digit-16:                              Lexical syntax.     (line  247)
* digit-2:                               Lexical syntax.     (line  244)
* digit-8:                               Lexical syntax.     (line  245)
* digit-value:                           Characters.         (line  143)
* Dimension:                             Composable pictures.
                                                             (line   65)
* disassemble:                           Debugging.          (line   32)
* display:                               Ports.              (line  396)
* div:                                   Arithmetic operations.
                                                             (line  223)
* div-and-mod:                           Arithmetic operations.
                                                             (line  174)
* div0:                                  Arithmetic operations.
                                                             (line  224)
* div0-and-mod0:                         Arithmetic operations.
                                                             (line  175)
* domterm-load-stylesheet:               REPL Console.       (line  188)
* dot-product:                           Quaternions.        (line  180)
* double:                                Numerical types.    (line   75)
* draw:                                  Composable pictures.
                                                             (line  198)
* dynamic:                               Standard Types.     (line  102)
* dynamic-wind:                          Exceptions.         (line  129)
* eager:                                 Lazy evaluation.    (line   68)
* element-name:                          Creating XML nodes. (line   31)
* ellipsis:                              Macros.             (line  164)
* emergency-exit:                        Processes.          (line  403)
* enclosed-modifier:                     String literals.    (line  226)
* enclosed-part:                         String literals.    (line  208)
* encoding specifier:                    Bodies.             (line   31)
* entity-ref:                            String literals.    (line  125)
* environment:                           Eval and Environments.
                                                             (line    6)
* environment-bound?:                    Eval and Environments.
                                                             (line   37)
* environment-fold:                      Eval and Environments.
                                                             (line   41)
* eof-object:                            Ports.              (line  306)
* eof-object?:                           Ports.              (line  299)
* equal-hash:                            Hash tables.        (line  192)
* error:                                 Exceptions.         (line  153)
* error-object-irritants:                Exceptions.         (line  176)
* error-object-message:                  Exceptions.         (line  172)
* error-object?:                         Exceptions.         (line  167)
* error-response:                        HTTP response.      (line   29)
* escape-sequence:                       Lexical syntax.     (line  146)
* euler-xyx:                             Quaternions.        (line  313)
* euler-xzx:                             Quaternions.        (line  314)
* euler-yxy:                             Quaternions.        (line  315)
* euler-yzy:                             Quaternions.        (line  316)
* euler-zxz:                             Quaternions.        (line  317)
* euler-zyz:                             Quaternions.        (line  318)
* eval:                                  Eval and Environments.
                                                             (line   76)
* exact complex number:                  Numerical types.    (line   95)
* exact-integer-sqrt:                    Arithmetic operations.
                                                             (line  433)
* exact-integer?:                        Arithmetic operations.
                                                             (line   53)
* exactness:                             Numerical types.    (line   85)
* exit:                                  Processes.          (line  386)
* exp:                                   Arithmetic operations.
                                                             (line  358)
* exp <1>:                               Quaternions.        (line   58)
* expand:                                Macros.             (line  137)
* explicit-source-name:                  Importing.          (line   27)
* exponent-marker:                       Lexical syntax.     (line  229)
* export:                                Module classes.     (line   37)
* export-spec:                           Module classes.     (line   42)
* expression:                            Primitive expression syntax.
                                                             (line    6)
* expt:                                  Arithmetic operations.
                                                             (line  440)
* expt <1>:                              Quaternions.        (line   57)
* extended-datum-literal:                Named quasi-literals.
                                                             (line   41)
* extended-string-literal:               String literals.    (line   99)
* extrinsic-xyx:                         Quaternions.        (line  395)
* extrinsic-xyz:                         Quaternions.        (line  396)
* extrinsic-xzx:                         Quaternions.        (line  397)
* extrinsic-yxy:                         Quaternions.        (line  399)
* extrinsic-yxz:                         Quaternions.        (line  400)
* extrinsic-yzx:                         Quaternions.        (line  401)
* extrinsic-yzy:                         Quaternions.        (line  402)
* extrinsic-zxy:                         Quaternions.        (line  398)
* extrinsic-zxy <1>:                     Quaternions.        (line  403)
* extrinsic-zxz:                         Quaternions.        (line  404)
* extrinsic-zyx:                         Quaternions.        (line  405)
* extrinsic-zyz:                         Quaternions.        (line  406)
* f32vector:                             Uniform vectors.    (line   64)
* f32vector <1>:                         Uniform vectors.    (line  106)
* f32vector->list:                       Uniform vectors.    (line  157)
* f32vector-length:                      Uniform vectors.    (line  120)
* f32vector-ref:                         Uniform vectors.    (line  132)
* f32vector-set!:                        Uniform vectors.    (line  144)
* f32vector?:                            Uniform vectors.    (line   80)
* f64vector:                             Uniform vectors.    (line   68)
* f64vector <1>:                         Uniform vectors.    (line  107)
* f64vector->list:                       Uniform vectors.    (line  158)
* f64vector-length:                      Uniform vectors.    (line  121)
* f64vector-ref:                         Uniform vectors.    (line  133)
* f64vector-set!:                        Uniform vectors.    (line  145)
* f64vector?:                            Uniform vectors.    (line   81)
* feature-identifier:                    Syntax and conditional compilation.
                                                             (line   17)
* feature-requirement:                   Syntax and conditional compilation.
                                                             (line   12)
* features:                              Syntax and conditional compilation.
                                                             (line   67)
* fff-rec:                               Syntax and conditional compilation.
                                                             (line   12)
* field:                                 Field operations.   (line   58)
* field-decl:                            Defining new classes.
                                                             (line   91)
* field-name:                            Defining new classes.
                                                             (line   92)
* field-option:                          Defining new classes.
                                                             (line   93)
* field-or-method-decl:                  Defining new classes.
                                                             (line   34)
* file-directory?:                       Files.              (line   11)
* file-error?:                           Exceptions.         (line  144)
* file-exists?:                          Files.              (line    6)
* file-readable?:                        Files.              (line   17)
* file-writable?:                        Files.              (line   21)
* filepath:                              Paths.              (line   54)
* filepath?:                             Paths.              (line   58)
* fill:                                  Composable pictures.
                                                             (line  188)
* fill <1>:                              Composable pictures.
                                                             (line  189)
* finite?:                               Arithmetic operations.
                                                             (line   60)
* first-set-bit:                         Logical Number Operations.
                                                             (line  210)
* float:                                 Numerical types.    (line   76)
* floor:                                 Arithmetic operations.
                                                             (line  287)
* floor-quotient:                        Arithmetic operations.
                                                             (line  221)
* floor-remainder:                       Arithmetic operations.
                                                             (line  229)
* floor/:                                Arithmetic operations.
                                                             (line  172)
* fluid-let:                             Eval and Environments.
                                                             (line   58)
* flush-output-port:                     Ports.              (line  423)
* for-each:                              Mapping functions.  (line   13)
* force:                                 Lazy evaluation.    (line   77)
* force <1>:                             Threads.            (line   17)
* force*:                                Lazy evaluation.    (line  123)
* force-output:                          Ports.              (line  424)
* formal-arguments:                      Extended formals.   (line   55)
* formals:                               Extended formals.   (line   38)
* format:                                Format.             (line    6)
* format-array:                          Arrays.             (line  196)
* format-array <1>:                      Arrays.             (line  615)
* free-identifier=?:                     Macros.             (line  341)
* future:                                Threads.            (line   11)
* gcd:                                   Arithmetic operations.
                                                             (line  262)
* gentemp:                               Macros.             (line  131)
* get-environment-variable:              System inquiry.     (line   62)
* get-environment-variables:             System inquiry.     (line   75)
* get-output-bytevector:                 Ports.              (line  227)
* get-output-string:                     Ports.              (line  194)
* get-request:                           Servlets.           (line  170)
* get-response:                          Servlets.           (line  174)
* Glassfish:                             Servlets.           (line  113)
* grad:                                  Quantities.         (line   75)
* guard:                                 Variables and Patterns.
                                                             (line   74)
* guard <1>:                             Exceptions.         (line  101)
* hash:                                  Hash tables.        (line  384)
* hash-by-identity:                      Hash tables.        (line  406)
* hash-table->alist:                     Hash tables.        (line  356)
* hash-table-copy:                       Hash tables.        (line  368)
* hash-table-delete!:                    Hash tables.        (line  297)
* hash-table-equivalence-function:       Hash tables.        (line  268)
* hash-table-exists?:                    Hash tables.        (line  304)
* hash-table-fold:                       Hash tables.        (line  346)
* hash-table-hash-function:              Hash tables.        (line  271)
* hash-table-keys:                       Hash tables.        (line  329)
* hash-table-merge!:                     Hash tables.        (line  372)
* hash-table-ref:                        Hash tables.        (line  277)
* hash-table-ref/default:                Hash tables.        (line  285)
* hash-table-set!:                       Hash tables.        (line  291)
* hash-table-size:                       Hash tables.        (line  325)
* hash-table-update!:                    Hash tables.        (line  310)
* hash-table-update!/default:            Hash tables.        (line  317)
* hash-table-values:                     Hash tables.        (line  333)
* hash-table-walk:                       Hash tables.        (line  338)
* hash-table?:                           Hash tables.        (line  249)
* hashtable-clear!:                      Hash tables.        (line  142)
* hashtable-clear! <1>:                  Hash tables.        (line  143)
* hashtable-contains?:                   Hash tables.        (line  113)
* hashtable-copy:                        Hash tables.        (line  136)
* hashtable-copy <1>:                    Hash tables.        (line  137)
* hashtable-delete!:                     Hash tables.        (line  109)
* hashtable-entries:                     Hash tables.        (line  154)
* hashtable-equivalence-function:        Hash tables.        (line  172)
* hashtable-hash-function:               Hash tables.        (line  177)
* hashtable-keys:                        Hash tables.        (line  150)
* hashtable-mutable?:                    Hash tables.        (line  181)
* hashtable-ref:                         Hash tables.        (line  100)
* hashtable-set!:                        Hash tables.        (line  104)
* hashtable-size:                        Hash tables.        (line   96)
* hashtable-update!:                     Hash tables.        (line  117)
* hashtable?:                            Hash tables.        (line   93)
* hbox:                                  Composable pictures.
                                                             (line  309)
* hex-digit:                             Lexical syntax.     (line  143)
* hex-scalar-value:                      Lexical syntax.     (line  150)
* home-directory:                        System inquiry.     (line    6)
* html:TAG:                              Creating HTML nodes.
                                                             (line   11)
* identifier:                            Lexical syntax.     (line  126)
* identifier?:                           Macros.             (line  292)
* if:                                    Conditionals.       (line   45)
* if <1>:                                Conditionals.       (line   46)
* imag-part:                             Quaternions.        (line   84)
* image:                                 Composable pictures.
                                                             (line  429)
* image <1>:                             Composable pictures.
                                                             (line  430)
* image <2>:                             Composable pictures.
                                                             (line  431)
* image-height:                          Composable pictures.
                                                             (line  466)
* image-read:                            Composable pictures.
                                                             (line  444)
* image-width:                           Composable pictures.
                                                             (line  465)
* image-write:                           Composable pictures.
                                                             (line  457)
* import:                                Importing.          (line   11)
* import-only-name:                      Importing.          (line   26)
* import-set:                            Importing.          (line   16)
* include:                               Syntax and conditional compilation.
                                                             (line   82)
* include-ci:                            Syntax and conditional compilation.
                                                             (line   84)
* include-relative:                      Syntax and conditional compilation.
                                                             (line   83)
* index-array:                           Arrays.             (line  326)
* indexnum:                              Datum syntax.       (line   34)
* inexact complex number:                Numerical types.    (line   95)
* infinite?:                             Arithmetic operations.
                                                             (line   68)
* initial:                               Lexical syntax.     (line  128)
* initial-ignored:                       String literals.    (line  159)
* inline-hex-escape:                     Lexical syntax.     (line  149)
* input-port:                            Standard Types.     (line   63)
* input-port-column-number:              Ports.              (line  550)
* input-port-line-number:                Ports.              (line  541)
* input-port-open?:                      Ports.              (line   71)
* input-port-prompter:                   Ports.              (line  514)
* input-port-read-state:                 Ports.              (line  555)
* input-port?:                           Ports.              (line   55)
* input-prompt1:                         Ports.              (line  439)
* input-prompt2:                         Ports.              (line  440)
* instance?:                             Type tests and conversions.
                                                             (line   24)
* int:                                   Numerical types.    (line   52)
* integer:                               Numerical types.    (line   42)
* integer->char:                         Characters.         (line  107)
* integer->list:                         Logical Number Operations.
                                                             (line  238)
* integer-length:                        Logical Number Operations.
                                                             (line  206)
* integer-valued?:                       Arithmetic operations.
                                                             (line    8)
* interaction-environment:               Eval and Environments.
                                                             (line   32)
* interlexeme-space:                     Lexical syntax.     (line   78)
* intraline-whitespace:                  Lexical syntax.     (line   61)
* intrinsic-xyx:                         Quaternions.        (line  297)
* intrinsic-xyz:                         Quaternions.        (line  321)
* intrinsic-xzx:                         Quaternions.        (line  298)
* intrinsic-xzy:                         Quaternions.        (line  322)
* intrinsic-yxy:                         Quaternions.        (line  299)
* intrinsic-yxz:                         Quaternions.        (line  323)
* intrinsic-yzx:                         Quaternions.        (line  324)
* intrinsic-yzy:                         Quaternions.        (line  300)
* intrinsic-zxy:                         Quaternions.        (line  325)
* intrinsic-zxz:                         Quaternions.        (line  301)
* intrinsic-zyx:                         Quaternions.        (line  326)
* intrinsic-zyz:                         Quaternions.        (line  302)
* invoke:                                Method operations.  (line  136)
* invoke-special:                        Method operations.  (line  168)
* invoke-static:                         Method operations.  (line  110)
* istring:                               Strings.            (line   21)
* istring?:                              Strings.            (line   68)
* JavaFX:                                Building JavaFX applications.
                                                             (line    6)
* jiffies-per-second:                    Time-related functions.
                                                             (line   38)
* jmag-part:                             Quaternions.        (line  118)
* kawa-abbreviation:                     Datum syntax.       (line   64)
* kawac:                                 Compiling using Ant.
                                                             (line    6)
* key-arg:                               Extended formals.   (line  115)
* keyword:                               Standard Types.     (line   35)
* keyword <1>:                           Keywords.           (line   14)
* keyword->string:                       Keywords.           (line   37)
* keyword?:                              Keywords.           (line   34)
* kmag-part:                             Quaternions.        (line  124)
* lambda-expression:                     Extended formals.   (line   36)
* lazy:                                  Lazy evaluation.    (line   48)
* lcm:                                   Arithmetic operations.
                                                             (line  263)
* length:                                Sequences.          (line   59)
* let:                                   Local binding constructs.
                                                             (line   16)
* let*:                                  Local binding constructs.
                                                             (line   38)
* let*-values:                           Multiple values.    (line   62)
* let-values:                            Multiple values.    (line   40)
* letrec:                                Local binding constructs.
                                                             (line   52)
* letrec*:                               Local binding constructs.
                                                             (line   53)
* letter:                                Lexical syntax.     (line  130)
* lexeme:                                Lexical syntax.     (line   35)
* lexeme-datum:                          Datum syntax.       (line   19)
* library-declaration:                   Module classes.     (line   96)
* library-definition:                    Module classes.     (line   78)
* library-name:                          Module classes.     (line   79)
* library-name-parts:                    Module classes.     (line   80)
* library-reference:                     Importing.          (line   25)
* line:                                  Composable pictures.
                                                             (line   98)
* line-ending:                           Lexical syntax.     (line   66)
* list:                                  Standard Types.     (line   38)
* list <1>:                              Datum syntax.       (line   23)
* list->f32vector:                       Uniform vectors.    (line  169)
* list->f64vector:                       Uniform vectors.    (line  170)
* list->integer:                         Logical Number Operations.
                                                             (line  239)
* list->s16vector:                       Uniform vectors.    (line  163)
* list->s32vector:                       Uniform vectors.    (line  165)
* list->s64vector:                       Uniform vectors.    (line  167)
* list->s8vector:                        Uniform vectors.    (line  161)
* list->string:                          Strings.            (line  297)
* list->u16vector:                       Uniform vectors.    (line  164)
* list->u32vector:                       Uniform vectors.    (line  166)
* list->u64vector:                       Uniform vectors.    (line  168)
* list->u8vector:                        Uniform vectors.    (line  162)
* list->vector:                          Vectors.            (line  106)
* list-pattern:                          Macros.             (line  177)
* literal-expression:                    Primitive expression syntax.
                                                             (line   12)
* load:                                  Eval and Environments.
                                                             (line   92)
* load-relative:                         Eval and Environments.
                                                             (line   93)
* location:                              Locations.          (line   40)
* log:                                   Arithmetic operations.
                                                             (line  359)
* log <1>:                               Arithmetic operations.
                                                             (line  360)
* log <2>:                               Quaternions.        (line   59)
* log2-binary-factors:                   Logical Number Operations.
                                                             (line  209)
* logand:                                Logical Number Operations.
                                                             (line  182)
* logbit?:                               Logical Number Operations.
                                                             (line  213)
* logcount:                              Logical Number Operations.
                                                             (line  200)
* logior:                                Logical Number Operations.
                                                             (line  185)
* lognot:                                Logical Number Operations.
                                                             (line  191)
* logop:                                 Logical Number Operations.
                                                             (line  165)
* logtest:                               Logical Number Operations.
                                                             (line  169)
* logxor:                                Logical Number Operations.
                                                             (line  188)
* long:                                  Numerical types.    (line   51)
* longitude:                             Quaternions.        (line  164)
* lpattern:                              Variables and Patterns.
                                                             (line   68)
* magnitude:                             Quaternions.        (line   91)
* make:                                  Allocating objects. (line  154)
* make-array:                            Arrays.             (line  272)
* make-array <1>:                        Arrays.             (line  273)
* make-attribute:                        Creating XML nodes. (line   34)
* make-axis/angle:                       Quaternions.        (line  270)
* make-axis/angle <1>:                   Quaternions.        (line  271)
* make-bytevector:                       Bytevectors.        (line   40)
* make-bytevector <1>:                   Bytevectors.        (line   41)
* make-element:                          Creating XML nodes. (line   16)
* make-eq-hashtable:                     Hash tables.        (line   48)
* make-eq-hashtable <1>:                 Hash tables.        (line   49)
* make-eqv-hashtable:                    Hash tables.        (line   55)
* make-eqv-hashtable <1>:                Hash tables.        (line   56)
* make-euler-xyx:                        Quaternions.        (line  353)
* make-euler-xzx:                        Quaternions.        (line  354)
* make-euler-yxy:                        Quaternions.        (line  355)
* make-euler-yzy:                        Quaternions.        (line  356)
* make-euler-zxz:                        Quaternions.        (line  357)
* make-euler-zyz:                        Quaternions.        (line  358)
* make-extrinsic-xyx:                    Quaternions.        (line  412)
* make-extrinsic-xyz:                    Quaternions.        (line  413)
* make-extrinsic-xzx:                    Quaternions.        (line  414)
* make-extrinsic-xzy:                    Quaternions.        (line  415)
* make-extrinsic-yxy:                    Quaternions.        (line  416)
* make-extrinsic-yxz:                    Quaternions.        (line  417)
* make-extrinsic-yzx:                    Quaternions.        (line  418)
* make-extrinsic-yzy:                    Quaternions.        (line  419)
* make-extrinsic-zxy:                    Quaternions.        (line  420)
* make-extrinsic-zxz:                    Quaternions.        (line  421)
* make-extrinsic-zyx:                    Quaternions.        (line  422)
* make-extrinsic-zyz:                    Quaternions.        (line  423)
* make-f32vector:                        Uniform vectors.    (line   92)
* make-f64vector:                        Uniform vectors.    (line   93)
* make-hash-table:                       Hash tables.        (line  225)
* make-hashtable:                        Hash tables.        (line   62)
* make-hashtable <1>:                    Hash tables.        (line   63)
* make-intrinsic-xyx:                    Quaternions.        (line  343)
* make-intrinsic-xyz:                    Quaternions.        (line  364)
* make-intrinsic-xzx:                    Quaternions.        (line  344)
* make-intrinsic-xzy:                    Quaternions.        (line  365)
* make-intrinsic-yxy:                    Quaternions.        (line  345)
* make-intrinsic-yxz:                    Quaternions.        (line  366)
* make-intrinsic-yzx:                    Quaternions.        (line  367)
* make-intrinsic-yzy:                    Quaternions.        (line  346)
* make-intrinsic-zxy:                    Quaternions.        (line  368)
* make-intrinsic-zxz:                    Quaternions.        (line  347)
* make-intrinsic-zyx:                    Quaternions.        (line  369)
* make-intrinsic-zyz:                    Quaternions.        (line  348)
* make-list:                             Lists.              (line   56)
* make-parameter:                        Parameter objects.  (line   50)
* make-polar:                            Quaternions.        (line   48)
* make-polar <1>:                        Quaternions.        (line   49)
* make-procedure:                        Generic procedures. (line   20)
* make-process:                          Processes.          (line  411)
* make-promise:                          Lazy evaluation.    (line  252)
* make-quantity:                         Quantities.         (line   39)
* make-record-type:                      Dynamic records.    (line   11)
* make-rectangular:                      Quaternions.        (line   44)
* make-rectangular <1>:                  Quaternions.        (line   45)
* make-rotation-procedure:               Quaternions.        (line  448)
* make-rpy:                              Quaternions.        (line  429)
* make-s16vector:                        Uniform vectors.    (line   86)
* make-s32vector:                        Uniform vectors.    (line   88)
* make-s64vector:                        Uniform vectors.    (line   90)
* make-s8vector:                         Uniform vectors.    (line   84)
* make-string:                           Strings.            (line  815)
* make-tait-bryan-xyz:                   Quaternions.        (line  374)
* make-tait-bryan-xzy:                   Quaternions.        (line  375)
* make-tait-bryan-yxz:                   Quaternions.        (line  376)
* make-tait-bryan-yzx:                   Quaternions.        (line  377)
* make-tait-bryan-zxy:                   Quaternions.        (line  378)
* make-tait-bryan-zyx:                   Quaternions.        (line  379)
* make-temporary-file:                   Files.              (line   45)
* make-u16vector:                        Uniform vectors.    (line   87)
* make-u32vector:                        Uniform vectors.    (line   89)
* make-u64vector:                        Uniform vectors.    (line   91)
* make-u8vector:                         Uniform vectors.    (line   85)
* make-vector:                           Vectors.            (line   58)
* make-vector <1>:                       Vectors.            (line   59)
* make-vector-quaternion:                Quaternions.        (line  171)
* map:                                   Mapping functions.  (line   12)
* match:                                 Conditionals.       (line  171)
* match-clause:                          Conditionals.       (line  174)
* match-key:                             Conditionals.       (line  173)
* method-body:                           Defining new classes.
                                                             (line  163)
* method-decl:                           Defining new classes.
                                                             (line  159)
* method-name:                           Defining new classes.
                                                             (line  161)
* method-option:                         Defining new classes.
                                                             (line  162)
* mnemonic-escape:                       String literals.    (line   18)
* mod:                                   Arithmetic operations.
                                                             (line  231)
* mod0:                                  Arithmetic operations.
                                                             (line  232)
* module-class:                          Resources.          (line   35)
* module-compile-options:                Module classes.     (line  344)
* module-export:                         Module classes.     (line   36)
* module-extends:                        Module classes.     (line  182)
* module-implements:                     Module classes.     (line  186)
* module-name:                           Module classes.     (line  159)
* module-name <1>:                       Module classes.     (line  160)
* module-name <2>:                       Module classes.     (line  161)
* module-static:                         Module classes.     (line  296)
* module-static <1>:                     Module classes.     (line  297)
* module-static <2>:                     Module classes.     (line  298)
* module-static <3>:                     Module classes.     (line  299)
* module-uri:                            Resources.          (line   22)
* modulo:                                Arithmetic operations.
                                                             (line  242)
* mstring:                               Strings.            (line   21)
* multi-escape-sequence:                 Lexical syntax.     (line  151)
* named-literal-part:                    Named quasi-literals.
                                                             (line   45)
* namespace:                             Namespaces.         (line   38)
* namespace-prefix:                      Namespaces.         (line   59)
* namespace-uri:                         Namespaces.         (line   56)
* nan?:                                  Arithmetic operations.
                                                             (line   77)
* nested-comment:                        Lexical syntax.     (line   74)
* newline:                               Ports.              (line  404)
* nondefining-datum:                     Datum syntax.       (line   16)
* not:                                   Conditionals.       (line  264)
* null-environment:                      Eval and Environments.
                                                             (line   13)
* number:                                Lexical syntax.     (line  221)
* number <1>:                            Numerical types.    (line   26)
* number->string:                        Numerical input and output.
                                                             (line    6)
* numerator:                             Arithmetic operations.
                                                             (line  275)
* Object:                                Standard Types.     (line   26)
* object:                                Anonymous classes.  (line    6)
* object-field-decl:                     Anonymous classes.  (line   10)
* object-field-or-method-decl:           Anonymous classes.  (line    9)
* object-init:                           Anonymous classes.  (line   11)
* oct-digit:                             Lexical syntax.     (line  142)
* open-binary-input-file:                Ports.              (line  129)
* open-binary-output-file:               Ports.              (line  141)
* open-input-bytevector:                 Ports.              (line  219)
* open-input-file:                       Ports.              (line  128)
* open-input-string:                     Ports.              (line  169)
* open-output-bytevector:                Ports.              (line  223)
* open-output-file:                      Ports.              (line  140)
* open-output-string:                    Ports.              (line  183)
* operand:                               Primitive expression syntax.
                                                             (line   65)
* operator:                              Primitive expression syntax.
                                                             (line   64)
* opt-return-type:                       Extended formals.   (line   37)
* opt-type-specifier:                    Types.              (line   35)
* option-pair:                           Defining new classes.
                                                             (line   33)
* optional-arg:                          Extended formals.   (line   97)
* optional-exponent:                     Lexical syntax.     (line  227)
* optional-sign:                         Lexical syntax.     (line  243)
* options:                               Options.            (line    6)
* or:                                    Conditionals.       (line  236)
* output-port:                           Standard Types.     (line   66)
* output-port-open?:                     Ports.              (line   72)
* output-port?:                          Ports.              (line   56)
* padding:                               Composable pictures.
                                                             (line  352)
* pair:                                  Standard Types.     (line   42)
* parameter:                             Standard Types.     (line   79)
* parameterize:                          Parameter objects.  (line   93)
* parse-format:                          Format.             (line   26)
* path:                                  Paths.              (line   14)
* path <1>:                              Paths.              (line   22)
* path-authority:                        Paths.              (line   88)
* path-bytes:                            Reading and writing whole files.
                                                             (line   92)
* path-data:                             Reading and writing whole files.
                                                             (line   81)
* path-directory:                        Paths.              (line  124)
* path-extension:                        Paths.              (line  151)
* path-file:                             Paths.              (line  116)
* path-fragment:                         Paths.              (line  162)
* path-host:                             Paths.              (line   95)
* path-last:                             Paths.              (line  141)
* path-parent:                           Paths.              (line  134)
* path-port:                             Paths.              (line  107)
* path-query:                            Paths.              (line  156)
* path-scheme:                           Paths.              (line   82)
* path-user-info:                        Paths.              (line  101)
* path?:                                 Paths.              (line   31)
* pattern:                               Variables and Patterns.
                                                             (line   62)
* pattern-literal:                       Variables and Patterns.
                                                             (line   72)
* peculiar-identifier:                   Lexical syntax.     (line  156)
* peek-char:                             Ports.              (line  263)
* peek-u8:                               Ports.              (line  336)
* picture->jpanel:                       Composable pictures.
                                                             (line  532)
* picture->svg-node:                     Composable pictures.
                                                             (line  504)
* picture-write-svg:                     Composable pictures.
                                                             (line  494)
* pipe-process:                          Processes.          (line  309)
* Point:                                 Composable pictures.
                                                             (line   57)
* polygon:                               Composable pictures.
                                                             (line  112)
* port-char-encoding:                    Ports.              (line  576)
* port-column:                           Ports.              (line  526)
* port-line:                             Ports.              (line  527)
* port?:                                 Ports.              (line   59)
* pprint:                                Pretty-printing.    (line   42)
* pprint-end-logical-block:              Pretty-printing.    (line  113)
* pprint-ident:                          Pretty-printing.    (line  122)
* pprint-logical-block:                  Pretty-printing.    (line   82)
* pprint-newline:                        Pretty-printing.    (line  116)
* pprint-start-logical-block:            Pretty-printing.    (line  110)
* primitive-array-get:                   Low-level functions.
                                                             (line  101)
* primitive-array-length:                Low-level functions.
                                                             (line  107)
* primitive-array-new:                   Low-level functions.
                                                             (line   89)
* primitive-array-set:                   Low-level functions.
                                                             (line   94)
* primitive-constructor:                 Low-level functions.
                                                             (line   17)
* primitive-get-field:                   Low-level functions.
                                                             (line   57)
* primitive-get-static:                  Low-level functions.
                                                             (line   72)
* primitive-interface-method:            Low-level functions.
                                                             (line   32)
* primitive-set-field:                   Low-level functions.
                                                             (line   63)
* primitive-set-static:                  Low-level functions.
                                                             (line   77)
* primitive-static-method:               Low-level functions.
                                                             (line   27)
* primitive-throw:                       Exceptions.         (line  215)
* primitive-virtual-method:              Low-level functions.
                                                             (line   22)
* procedure:                             Standard Types.     (line   60)
* procedure-call:                        Primitive expression syntax.
                                                             (line   63)
* procedure-property:                    Procedure properties.
                                                             (line   21)
* process-command-line-assignments:      System inquiry.     (line   45)
* process-exit-ok?:                      Processes.          (line  357)
* process-exit-wait:                     Processes.          (line  351)
* process-keyword-argument:              Processes.          (line   48)
* processing-instruction:                Creating XML nodes. (line   49)
* processing-instruction <1>:            Creating XML nodes. (line   54)
* program-unit:                          Bodies.             (line   11)
* promise:                               Lazy evaluation.    (line  215)
* promise-set-alias!:                    Lazy evaluation.    (line  242)
* promise-set-exception!:                Lazy evaluation.    (line  238)
* promise-set-thunk!:                    Lazy evaluation.    (line  246)
* promise-set-value!:                    Lazy evaluation.    (line  234)
* promise[T]:                            Lazy evaluation.    (line  264)
* prompts:                               Ports.              (line  430)
* property-access-abbreviation:          Colon notation.     (line   11)
* property-initializer:                  Allocating objects. (line   82)
* property-name:                         Colon notation.     (line   13)
* property-owner-expression:             Colon notation.     (line   12)
* provide:                               Importing.          (line  116)
* QName:                                 XML literals.       (line  124)
* quantity:                              Numerical types.    (line   29)
* quantity <1>:                          Quantities.         (line   12)
* quantity->number:                      Quantities.         (line   30)
* quantity->unit:                        Quantities.         (line   35)
* quantity?:                             Quantities.         (line   24)
* quasisyntax:                           Macros.             (line  693)
* quaternion:                            Quaternions.        (line  106)
* quaternion->rotation-matrix:           Quaternions.        (line  231)
* quaternion?:                           Quaternions.        (line  108)
* quot-attribute-datum:                  XML literals.       (line  105)
* quotient:                              Arithmetic operations.
                                                             (line  240)
* r6rs-abbreviation:                     Datum syntax.       (line   61)
* rad:                                   Quantities.         (line   66)
* raise:                                 Exceptions.         (line   66)
* raise-continuable:                     Exceptions.         (line   77)
* range-end:                             Ranges.             (line   35)
* rational:                              Numerical types.    (line   39)
* rational-valued?:                      Arithmetic operations.
                                                             (line    7)
* rationalize:                           Arithmetic operations.
                                                             (line  333)
* re-center:                             Composable pictures.
                                                             (line  366)
* read:                                  Ports.              (line  239)
* read-bytevector:                       Ports.              (line  347)
* read-bytevector!:                      Ports.              (line  354)
* read-char:                             Ports.              (line  256)
* read-error?:                           Exceptions.         (line  140)
* read-line:                             Ports.              (line  279)
* read-string:                           Ports.              (line  324)
* read-u8:                               Ports.              (line  331)
* real:                                  Numerical types.    (line   36)
* real-part:                             Quaternions.        (line   77)
* real-valued?:                          Arithmetic operations.
                                                             (line    6)
* receive:                               Multiple values.    (line   78)
* record-accessor:                       Dynamic records.    (line   38)
* record-constructor:                    Dynamic records.    (line   20)
* record-modifier:                       Dynamic records.    (line   47)
* record-predicate:                      Dynamic records.    (line   32)
* record-type-descriptor:                Dynamic records.    (line   62)
* record-type-field-names:               Dynamic records.    (line   74)
* record-type-name:                      Dynamic records.    (line   68)
* record?:                               Dynamic records.    (line   58)
* rectangle:                             Composable pictures.
                                                             (line  117)
* regex:                                 Regular expressions.
                                                             (line   55)
* regex <1>:                             Regular expressions.
                                                             (line   59)
* regex-match:                           Regular expressions.
                                                             (line  142)
* regex-match-positions:                 Regular expressions.
                                                             (line  107)
* regex-quote:                           Regular expressions.
                                                             (line  203)
* regex-split:                           Regular expressions.
                                                             (line  153)
* regex‑replace:                         Regular expressions.
                                                             (line  179)
* regex‑replace*:                        Regular expressions.
                                                             (line  194)
* remainder:                             Arithmetic operations.
                                                             (line  241)
* rename-file:                           Files.              (line   29)
* rename-pair:                           Importing.          (line   28)
* repeat expression:                     Repeat forms.       (line   19)
* repeat pattern:                        Repeat forms.       (line   10)
* repeat variable:                       Repeat forms.       (line   16)
* report-syntax-error:                   Macros.             (line  601)
* request-body-string:                   HTTP requests.      (line  130)
* request-context-path:                  HTTP requests.      (line   51)
* request-header:                        HTTP requests.      (line  109)
* request-header-map:                    HTTP requests.      (line  114)
* request-input-port:                    HTTP requests.      (line  122)
* request-input-stream:                  HTTP requests.      (line  126)
* request-local-host:                    HTTP requests.      (line  143)
* request-local-IP-address:              HTTP requests.      (line  146)
* request-local-path:                    HTTP requests.      (line   66)
* request-local-port:                    HTTP requests.      (line  150)
* request-local-socket-address:          HTTP requests.      (line  139)
* request-method:                        HTTP requests.      (line  180)
* request-parameter:                     HTTP requests.      (line   84)
* request-parameter-map:                 HTTP requests.      (line   98)
* request-parameters:                    HTTP requests.      (line   91)
* request-path:                          HTTP requests.      (line   32)
* request-path-info:                     Servlets.           (line  183)
* request-path-translated:               HTTP requests.      (line  175)
* request-query-string:                  HTTP requests.      (line   71)
* request-remote-host:                   HTTP requests.      (line  162)
* request-remote-IP-address:             HTTP requests.      (line  165)
* request-remote-port:                   HTTP requests.      (line  169)
* request-remote-socket-address:         HTTP requests.      (line  157)
* request-scheme:                        HTTP requests.      (line  184)
* request-script-path:                   HTTP requests.      (line   57)
* request-servlet-path:                  Servlets.           (line  178)
* request-URI:                           HTTP requests.      (line   23)
* request-uri:                           HTTP requests.      (line   42)
* request-url:                           HTTP requests.      (line   46)
* require:                               Importing.          (line   99)
* require <1>:                           Importing.          (line  100)
* require <2>:                           Importing.          (line  101)
* required-arg:                          Extended formals.   (line   68)
* required-or-guard:                     Extended formals.   (line   67)
* resolve-uri:                           Paths.              (line  168)
* resource-url:                          Resources.          (line   12)
* response-content-type:                 HTTP response.      (line   24)
* response-header:                       HTTP response.      (line   18)
* response-status:                       HTTP response.      (line   38)
* rest-arg:                              Extended formals.   (line  174)
* rest-key-args:                         Extended formals.   (line   56)
* rest-parameter:                        Extended formals.   (line  170)
* reverse!:                              Lists.              (line   71)
* reverse-bit-field:                     Logical Number Operations.
                                                             (line  235)
* reverse-list->string:                  Strings.            (line  305)
* rotate:                                Composable pictures.
                                                             (line  272)
* rotate <1>:                            Composable pictures.
                                                             (line  273)
* rotate-bit-field:                      Logical Number Operations.
                                                             (line  232)
* rotate-vector:                         Quaternions.        (line  439)
* rotation-angle:                        Quaternions.        (line  249)
* rotation-axis:                         Quaternions.        (line  248)
* rotation-axis/angle:                   Quaternions.        (line  250)
* rotation-matrix->quaternion:           Quaternions.        (line  232)
* rotx:                                  Quaternions.        (line  278)
* roty:                                  Quaternions.        (line  279)
* rotz:                                  Quaternions.        (line  280)
* round:                                 Arithmetic operations.
                                                             (line  290)
* rpy:                                   Quaternions.        (line  428)
* run-process:                           Processes.          (line   30)
* runnable:                              Threads.            (line   22)
* s16vector:                             Uniform vectors.    (line   37)
* s16vector <1>:                         Uniform vectors.    (line  100)
* s16vector->list:                       Uniform vectors.    (line  151)
* s16vector-length:                      Uniform vectors.    (line  114)
* s16vector-ref:                         Uniform vectors.    (line  126)
* s16vector-set!:                        Uniform vectors.    (line  138)
* s16vector?:                            Uniform vectors.    (line   74)
* s32vector:                             Uniform vectors.    (line   46)
* s32vector <1>:                         Uniform vectors.    (line  102)
* s32vector->list:                       Uniform vectors.    (line  153)
* s32vector-length:                      Uniform vectors.    (line  116)
* s32vector-ref:                         Uniform vectors.    (line  128)
* s32vector-set!:                        Uniform vectors.    (line  140)
* s32vector?:                            Uniform vectors.    (line   76)
* s64vector:                             Uniform vectors.    (line   55)
* s64vector <1>:                         Uniform vectors.    (line  104)
* s64vector->list:                       Uniform vectors.    (line  155)
* s64vector-length:                      Uniform vectors.    (line  118)
* s64vector-ref:                         Uniform vectors.    (line  130)
* s64vector-set!:                        Uniform vectors.    (line  142)
* s64vector?:                            Uniform vectors.    (line   78)
* s8vector:                              Uniform vectors.    (line   25)
* s8vector <1>:                          Uniform vectors.    (line   98)
* s8vector->list:                        Uniform vectors.    (line  149)
* s8vector-length:                       Uniform vectors.    (line  112)
* s8vector-ref:                          Uniform vectors.    (line  124)
* s8vector-set!:                         Uniform vectors.    (line  136)
* s8vector?:                             Uniform vectors.    (line   72)
* scale:                                 Composable pictures.
                                                             (line  285)
* scale <1>:                             Composable pictures.
                                                             (line  286)
* scheme-implementation-version:         Miscellaneous.      (line    6)
* scheme-report-environment:             Eval and Environments.
                                                             (line   21)
* scheme-window:                         Miscellaneous.      (line    9)
* Scheme.eval:                           Evaluating Scheme expressions from Java.
                                                             (line   14)
* Scheme.eval <1>:                       Evaluating Scheme expressions from Java.
                                                             (line   20)
* Scheme.eval <2>:                       Evaluating Scheme expressions from Java.
                                                             (line   26)
* Scheme.registerEnvironment:            Evaluating Scheme expressions from Java.
                                                             (line   10)
* servlet-context-realpath:              Servlets.           (line  187)
* set-frame-size!:                       Composable pictures.
                                                             (line  537)
* set-input-port-line-number!:           Ports.              (line  546)
* set-input-port-prompter!:              Ports.              (line  501)
* set-port-line!:                        Ports.              (line  538)
* set-procedure-property!:               Procedure properties.
                                                             (line   26)
* setter:                                Locations.          (line   25)
* shape:                                 Arrays.             (line   91)
* share-array:                           Arrays.             (line  561)
* shebang-comment:                       Lexical syntax.     (line   86)
* short:                                 Numerical types.    (line   53)
* show-picture:                          Composable pictures.
                                                             (line  523)
* sin:                                   Arithmetic operations.
                                                             (line  361)
* sin <1>:                               Quaternions.        (line   61)
* sinh:                                  Arithmetic operations.
                                                             (line  395)
* sleep:                                 Time-related functions.
                                                             (line   43)
* slot-ref:                              Field operations.   (line   87)
* slot-set!:                             Field operations.   (line   90)
* special-escape:                        String literals.    (line  161)
* special-initial:                       Lexical syntax.     (line  136)
* special-subsequent:                    Lexical syntax.     (line  145)
* sqrt:                                  Arithmetic operations.
                                                             (line  408)
* sqrt <1>:                              Quaternions.        (line   60)
* square:                                Arithmetic operations.
                                                             (line  403)
* statement:                             Bodies.             (line   14)
* statements:                            Bodies.             (line   13)
* static-field:                          Field operations.   (line   72)
* string:                                Standard Types.     (line   45)
* String:                                Standard Types.     (line   69)
* string <1>:                            Strings.            (line   56)
* string <2>:                            Strings.            (line   72)
* string <3>:                            String literals.    (line   13)
* string->keyword:                       Keywords.           (line   41)
* string->list:                          Strings.            (line  312)
* string->number:                        Numerical input and output.
                                                             (line   41)
* string->symbol:                        Simple symbols.     (line   29)
* string->utf16:                         Bytevectors.        (line  136)
* string->utf16be:                       Bytevectors.        (line  137)
* string->utf16le:                       Bytevectors.        (line  138)
* string->utf8:                          Bytevectors.        (line  131)
* string->vector:                        Strings.            (line  326)
* string-any:                            Strings.            (line  102)
* string-append:                         Strings.            (line  485)
* string-append!:                        Strings.            (line  864)
* string-capitalize!:                    Unicode.            (line  145)
* string-ci-hash:                        Hash tables.        (line  204)
* string-ci-hash <1>:                    Hash tables.        (line  400)
* string-ci<=?:                          Strings.            (line  282)
* string-ci<?:                           Strings.            (line  280)
* string-ci=?:                           Strings.            (line  279)
* string-ci>=?:                          Strings.            (line  283)
* string-ci>?:                           Strings.            (line  281)
* string-concatenate:                    Strings.            (line  492)
* string-concatenate-reverse:            Strings.            (line  501)
* string-contains:                       Strings.            (line  461)
* string-contains-right:                 Strings.            (line  463)
* string-copy:                           Strings.            (line  835)
* string-copy!:                          Strings.            (line  887)
* string-count:                          Strings.            (line  720)
* string-cursor:                         Strings.            (line 1029)
* string-cursor-end:                     Strings.            (line 1038)
* string-cursor-for-each:                Strings.            (line 1077)
* string-cursor-next:                    Strings.            (line 1047)
* string-cursor-next-quiet:              Strings.            (line 1052)
* string-cursor-prev:                    Strings.            (line 1058)
* string-cursor-ref:                     Strings.            (line 1043)
* string-cursor-start:                   Strings.            (line 1034)
* string-cursor<=?:                      Strings.            (line 1067)
* string-cursor<?:                       Strings.            (line 1066)
* string-cursor=?:                       Strings.            (line 1068)
* string-cursor>=?:                      Strings.            (line 1069)
* string-cursor>?:                       Strings.            (line 1070)
* string-downcase:                       Strings.            (line  334)
* string-downcase!:                      Unicode.            (line  141)
* string-drop:                           Strings.            (line  210)
* string-drop-right:                     Strings.            (line  212)
* string-element:                        String literals.    (line   14)
* string-every:                          Strings.            (line  101)
* string-fill!:                          Strings.            (line  919)
* string-filter:                         Strings.            (line  724)
* string-fold:                           Strings.            (line  603)
* string-fold-right:                     Strings.            (line  604)
* string-foldcase:                       Strings.            (line  336)
* string-for-each:                       Strings.            (line  637)
* string-for-each <1>:                   Strings.            (line  638)
* string-for-each-index:                 Strings.            (line  706)
* string-hash:                           Hash tables.        (line  199)
* string-hash <1>:                       Hash tables.        (line  395)
* string-index:                          Strings.            (line  427)
* string-index-right:                    Strings.            (line  428)
* string-join:                           Strings.            (line  526)
* string-length:                         Strings.            (line   79)
* string-literal-part:                   String literals.    (line  100)
* string-map:                            Strings.            (line  663)
* string-map-index:                      Strings.            (line  693)
* string-normalize-nfc:                  Strings.            (line  391)
* string-normalize-nfd:                  Strings.            (line  389)
* string-normalize-nfkc:                 Strings.            (line  392)
* string-normalize-nfkd:                 Strings.            (line  390)
* string-null?:                          Strings.            (line   97)
* string-pad:                            Strings.            (line  228)
* string-pad-right:                      Strings.            (line  229)
* string-prefix-length:                  Strings.            (line  407)
* string-prefix?:                        Strings.            (line  418)
* string-ref:                            Strings.            (line   87)
* string-remove:                         Strings.            (line  725)
* string-repeat:                         Strings.            (line  734)
* string-replace:                        Strings.            (line  567)
* string-replace!:                       Strings.            (line  904)
* string-set!:                           Strings.            (line  841)
* string-skip:                           Strings.            (line  429)
* string-skip-right:                     Strings.            (line  430)
* string-split:                          Strings.            (line  781)
* string-suffix-length:                  Strings.            (line  409)
* string-suffix?:                        Strings.            (line  420)
* string-tabulate:                       Strings.            (line  126)
* string-take:                           Strings.            (line  209)
* string-take-right:                     Strings.            (line  211)
* string-titlecase:                      Strings.            (line  335)
* string-trim:                           Strings.            (line  239)
* string-trim-both:                      Strings.            (line  241)
* string-trim-right:                     Strings.            (line  240)
* string-unfold:                         Strings.            (line  138)
* string-unfold-right:                   Strings.            (line  140)
* string-upcase:                         Strings.            (line  333)
* string-upcase!:                        Unicode.            (line  137)
* string<=?:                             Strings.            (line  261)
* string<?:                              Strings.            (line  259)
* string=?:                              Strings.            (line  252)
* string>=?:                             Strings.            (line  262)
* string>?:                              Strings.            (line  260)
* string?:                               Strings.            (line   65)
* subsequent:                            Lexical syntax.     (line  138)
* substring:                             Strings.            (line  199)
* substring-cursor:                      Strings.            (line 1062)
* supplied-var:                          Extended formals.   (line   99)
* symbol:                                Standard Types.     (line   29)
* symbol <1>:                            Datum syntax.       (line   21)
* symbol <2>:                            Namespaces.         (line   70)
* symbol <3>:                            Namespaces.         (line   71)
* symbol->string:                        Simple symbols.     (line   22)
* symbol-element:                        Lexical syntax.     (line  152)
* symbol-hash:                           Hash tables.        (line  209)
* symbol-local-name:                     Namespaces.         (line   89)
* symbol-namespace:                      Namespaces.         (line  102)
* symbol-namespace-uri:                  Namespaces.         (line   98)
* symbol-prefix:                         Namespaces.         (line   94)
* symbol-read-case:                      Ports.              (line  563)
* symbol=?:                              Namespaces.         (line  106)
* symbol?:                               Simple symbols.     (line   12)
* synchronized:                          Threads.            (line   28)
* syntax->datum:                         Macros.             (line  449)
* syntax-error:                          Macros.             (line  583)
* syntax-object->datum:                  Macros.             (line  450)
* syntax-pattern:                        Macros.             (line  175)
* syntax-rule:                           Macros.             (line  162)
* syntax-template:                       Macros.             (line  248)
* system:                                Processes.          (line  424)
* system-tmpdir:                         Files.              (line   42)
* tait-bryan-xyz:                        Quaternions.        (line  335)
* tait-bryan-xzy:                        Quaternions.        (line  336)
* tait-bryan-yxz:                        Quaternions.        (line  337)
* tait-bryan-yzx:                        Quaternions.        (line  338)
* tait-bryan-zxy:                        Quaternions.        (line  339)
* tait-bryan-zyx:                        Quaternions.        (line  340)
* tan:                                   Arithmetic operations.
                                                             (line  363)
* tan <1>:                               Quaternions.        (line   63)
* tanh:                                  Arithmetic operations.
                                                             (line  397)
* template-element:                      Macros.             (line  252)
* test-expression:                       Boolean values.     (line   12)
* test-or-match:                         Conditionals.       (line   23)
* textual-port?:                         Ports.              (line   57)
* this:                                  Objects Classes and Modules.
                                                             (line   31)
* throw:                                 Exceptions.         (line  203)
* tokenize-string-to-string-array:       Processes.          (line  441)
* Tomcat:                                Servlets.           (line   88)
* tr-literal:                            Macros.             (line  163)
* trace:                                 Debugging.          (line    6)
* transformer-spec:                      Macros.             (line  158)
* translate:                             Composable pictures.
                                                             (line  295)
* translate <1>:                         Composable pictures.
                                                             (line  296)
* truncate:                              Arithmetic operations.
                                                             (line  289)
* truncate-quotient:                     Arithmetic operations.
                                                             (line  222)
* truncate-remainder:                    Arithmetic operations.
                                                             (line  230)
* truncate/:                             Arithmetic operations.
                                                             (line  173)
* try-catch:                             Exceptions.         (line  227)
* try-finally:                           Exceptions.         (line  219)
* type:                                  Types.              (line   34)
* u16vector:                             Uniform vectors.    (line   41)
* u16vector <1>:                         Uniform vectors.    (line  101)
* u16vector->list:                       Uniform vectors.    (line  152)
* u16vector-length:                      Uniform vectors.    (line  115)
* u16vector-ref:                         Uniform vectors.    (line  127)
* u16vector-set!:                        Uniform vectors.    (line  139)
* u16vector?:                            Uniform vectors.    (line   75)
* u32vector:                             Uniform vectors.    (line   50)
* u32vector <1>:                         Uniform vectors.    (line  103)
* u32vector->list:                       Uniform vectors.    (line  154)
* u32vector-length:                      Uniform vectors.    (line  117)
* u32vector-ref:                         Uniform vectors.    (line  129)
* u32vector-set!:                        Uniform vectors.    (line  141)
* u32vector?:                            Uniform vectors.    (line   77)
* u64vector:                             Uniform vectors.    (line   59)
* u64vector <1>:                         Uniform vectors.    (line  105)
* u64vector->list:                       Uniform vectors.    (line  156)
* u64vector-length:                      Uniform vectors.    (line  119)
* u64vector-ref:                         Uniform vectors.    (line  131)
* u64vector-set!:                        Uniform vectors.    (line  143)
* u64vector?:                            Uniform vectors.    (line   79)
* u8-ready?:                             Ports.              (line  341)
* u8vector:                              Uniform vectors.    (line   29)
* u8vector <1>:                          Uniform vectors.    (line   99)
* u8vector->list:                        Uniform vectors.    (line  150)
* u8vector-length:                       Uniform vectors.    (line  113)
* u8vector-ref:                          Uniform vectors.    (line  125)
* u8vector-set!:                         Uniform vectors.    (line  137)
* u8vector?:                             Uniform vectors.    (line   73)
* ubyte:                                 Numerical types.    (line   64)
* uint:                                  Numerical types.    (line   62)
* ulong:                                 Numerical types.    (line   61)
* unbounded-range:                       Ranges.             (line   23)
* unescaped-data:                        Formatting XML.     (line   50)
* uniform-tag:                           Uniform vectors.    (line   11)
* uniform-vector:                        Uniform vectors.    (line   10)
* unit-name:                             Quantities.         (line   14)
* unit-quaternion:                       Quaternions.        (line  144)
* unit-term:                             Quantities.         (line   13)
* unit-vector:                           Quaternions.        (line  153)
* unless:                                Conditionals.       (line  281)
* unsyntax:                              Macros.             (line  694)
* unsyntax-splicing:                     Macros.             (line  695)
* untrace:                               Debugging.          (line   29)
* URI:                                   Paths.              (line   62)
* URI?:                                  Paths.              (line   70)
* URL:                                   Paths.              (line   74)
* ushort:                                Numerical types.    (line   63)
* utf16->string:                         Bytevectors.        (line  108)
* utf16be->string:                       Bytevectors.        (line  109)
* utf16le->string:                       Bytevectors.        (line  110)
* utf8->string:                          Bytevectors.        (line  101)
* values:                                Multiple values.    (line    8)
* values-append:                         Multiple values.    (line   94)
* variable-reference:                    Primitive expression syntax.
                                                             (line   49)
* vbox:                                  Composable pictures.
                                                             (line  310)
* vectag:                                Arrays.             (line  168)
* vector:                                Standard Types.     (line   57)
* vector <1>:                            Datum syntax.       (line   26)
* vector <2>:                            Vectors.            (line   45)
* vector <3>:                            Vectors.            (line   48)
* vector->list:                          Vectors.            (line   99)
* vector->string:                        Strings.            (line  318)
* vector-append:                         Vectors.            (line  141)
* vector-copy:                           Vectors.            (line  111)
* vector-copy!:                          Vectors.            (line  123)
* vector-fill!:                          Vectors.            (line  148)
* vector-for-each:                       Mapping functions.  (line  108)
* vector-length:                         Vectors.            (line   67)
* vector-map:                            Mapping functions.  (line   85)
* vector-part:                           Quaternions.        (line  137)
* vector-pattern:                        Macros.             (line  181)
* vector-quaternion->list:               Quaternions.        (line  175)
* vector-quaternion?:                    Quaternions.        (line  167)
* vector-ref:                            Vectors.            (line   70)
* vector-set!:                           Vectors.            (line   79)
* vector?:                               Vectors.            (line   64)
* warn-as-error:                         Options.            (line  235)
* warn-invoke-unknown-method:            Options.            (line  212)
* warn-undefined-variable:               Options.            (line  200)
* warn-uninitialized:                    Options.            (line  221)
* warn-unknown-member:                   Options.            (line  207)
* warn-unreachable:                      Options.            (line  224)
* warn-unused:                           Options.            (line  217)
* warn-void-used:                        Options.            (line  227)
* when:                                  Conditionals.       (line  277)
* whitespace:                            Lexical syntax.     (line   62)
* with-compile-options:                  Module classes.     (line  387)
* with-composite:                        Composable pictures.
                                                             (line  485)
* with-exception-handler:                Exceptions.         (line   31)
* with-input-from-file:                  Ports.              (line  114)
* with-output-to-file:                   Ports.              (line  115)
* with-paint:                            Composable pictures.
                                                             (line  159)
* with-syntax:                           Macros.             (line  640)
* with-transform:                        Composable pictures.
                                                             (line  260)
* with-transform <1>:                    Composable pictures.
                                                             (line  261)
* with-transform <2>:                    Composable pictures.
                                                             (line  266)
* with-transform <3>:                    Composable pictures.
                                                             (line  269)
* write:                                 Ports.              (line  372)
* write-bytevector:                      Ports.              (line  419)
* write-char:                            Ports.              (line  408)
* write-shared:                          Ports.              (line  385)
* write-simple:                          Ports.              (line  390)
* write-string:                          Ports.              (line  412)
* write-u8:                              Ports.              (line  416)
* xml-attribute:                         XML literals.       (line  100)
* xml-attribute-value:                   XML literals.       (line  102)
* xml-CDATA-constructor:                 XML literals.       (line  191)
* xml-CDATA-content:                     XML literals.       (line  192)
* xml-character-reference:               XML literals.       (line   82)
* xml-comment-constructor:               XML literals.       (line  182)
* xml-comment-content:                   XML literals.       (line  183)
* xml-constructor:                       XML literals.       (line   23)
* xml-element-constructor:               XML literals.       (line   31)
* xml-element-datum:                     XML literals.       (line   74)
* xml-enclosed-expression:               XML literals.       (line   37)
* xml-entity-name:                       XML literals.       (line   89)
* xml-escaped:                           XML literals.       (line   78)
* xml-literal:                           XML literals.       (line   22)
* xml-local-part:                        XML literals.       (line  126)
* xml-name-form:                         XML literals.       (line   35)
* xml-namespace-declaration-attribute:   XML literals.       (line  134)
* xml-PI-constructor:                    XML literals.       (line  162)
* xml-PI-content:                        XML literals.       (line  164)
* xml-PI-target:                         XML literals.       (line  163)
* xml-prefix:                            XML literals.       (line  127)
* xsubstring:                            Strings.            (line  743)
* zbox:                                  Composable pictures.
                                                             (line  311)

