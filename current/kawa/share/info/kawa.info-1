This is kawa.info, produced by makeinfo version 6.8 from kawa.texi.

START-INFO-DIR-ENTRY
* kawa: (kawa).         The Kawa Scheme language
END-INFO-DIR-ENTRY


File: kawa.info,  Node: Top,  Next: Installation,  Prev: (dir),  Up: (dir)

The Kawa Scheme language
************************

Kawa is a general-purpose programming language that runs on the Java
platform.  It aims to combine:
   • the benefits of dynamic scripting languages (non-verbose code with
     less boiler-plate, fast and easy start-up, a REPL
     (http://en.wikipedia.org/wiki/Read-eval-print_loop), no required
     compilation step); with
   • the benefits of traditional compiled languages (fast execution,
     static error detection, modularity, zero-overhead Java platform
     integration).
   It is an extension of the long-established Scheme
(http://www.schemers.org/) language, which is in the Lisp family of
programming languages.  Kawa has many *note useful features: Features.

   Kawa is also a useful *note framework: Framework. for implementing
other programming languages on the Java platform.  It has many useful
utility classes.

   This manual describes version 3.1.1, updated 3 March 2023.  See the
summary of *note recent changes: News.

   The Kawa home page (which is currently just an on-line version of
this document) is <http://www.gnu.org/software/kawa/>.

   The *note Kawa tutorial: Tutorial. is useful to get stated.  While it
is woefully incomplete, it does link to some other more in-depth (but
not Kawa-specific) Scheme tutorials.

   For copyright information on the software and documentation, see
*note License::.

   Various people and orgnizations *note have contributed to Kawa:
Acknowledgements.

   This package has nothing to do with the defunct Kawa commercial Java
IDE.

* Menu:

* News::                 News - Recent Changes
* Features::
* Community::
* Installation::         Building and installing Kawa
* Tutorial::             Kawa Scheme Tutorial
* Running::              Invoking, Running, and Using Kawa
* Syntax::
* Program structure::
* Control features::
* Symbols and namespaces::
* Procedures::
* Numbers::              Quantities and Numbers
* Characters and text::
* Data structures::
* Eval and Environments::
* Debugging::
* Input-Output::         Input, output, and file handling
* Types::
* Objects Classes and Modules::
* XML tools::            XML, HTML, and the web
* Miscellaneous::
* FAQs::                 Frequently Asked Questions
* Framework::            The Kawa language framework
* License::
* Overall Index::	 Index of functions, macros, concepts, and more.


File: kawa.info,  Node: News,  Next: Features,  Up: Top

1 News - Recent Changes
***********************

These changes are in more-or-less reverse chronological order, with the
most recent changes first.

   See also the list of Qexo (XQuery)-specific changes
(../qexo/news.html).

Kawa 3.1.1 (January 16, 2020)
-----------------------------

   • Various bug-fixes, mostly related to packaging and
     ‘--browse-manual’.

Kawa 3.1 (January 7, 2020)
--------------------------

   • Updates for Java 9 and newer.
   • Support justification ~‘<’...‘~>’ in ‘format’ (thanks to Helmut
     Eller).
   • Partial (and highly experimental) support for the Language Server
     Protocol (https://langserver.org) (used by editors and IDEs for
     on-the-fly syntax checking and more).
   • Revert 3.0 change in allocating closure objects for inlined
     functions.
   • Enhancements to arrays to match SRFI 163
     (http://srfi.schemers.org/srfi-163/srfi-163.html) and SRFI 164
     (http://srfi.schemers.org/srfi-163/srfi-164.html):
        • The type ‘gvector’ is a “generalized vector”.
        • Add optional port parameter to ‘format-array’.
        • The ‘build-array’ procedure takes an optional setter
          procedure.
        • New procedures ‘array-shape’, ‘->shape’.
   • In array constructors, index keywords must be all or none: ‘[int[]
     length: 5 11 22]’ or ‘[int[] length: 5 1: 22 0: 11]’.
   • Various improvements in the Common Lisp implementation, by Helmut
     Eller.
   • New ‘--max-errors’ option.
   • The classes created by ‘define-record-type’ now extends
     ‘kawa.lang.Record’, which adds some conveniences, such as printing.
   • Support for source location ranges with an end position.
   • Various improvements when running under DomTerm include clickable
     error message locations.
   • Many bug-fixes and minor improvements.

Kawa 3.0 (October 2, 2017)
--------------------------

   • Binary release are now built for Java 8.  The repository source
     code is now set up for Java 8.  (Building for Java 6 or 7 is still
     supported.  Java 5 might also work, but has not been tested
     recently.)
   • Tested and updated for Java 9.
   • Most places where you could declare a new identifier binding have
     been generalized to accept *note patterns: Variables and Patterns,
     including literals and boolean GUARDs.

     Related changes:
        • The form ‘(! PATTERN EXPRESSION)’ creates *note variable
          bindings: exclam-syntax. by matching the EXPRESSION against
          the PATTERN.  It is like ‘define-constant’ but generalized to
          patterns.

        • The conditional match form ‘(? PATTERN EXPRESSION)’ is similar
          to ‘!’ but can only be used *note in conditional context:
          Conditionals.  If the match fails, the condition is false.

        • *note Repeat patterns and forms: Repeat forms. is a powerful
          experimental feature, similar to list comprehensions.

        • The new form *note ‘match’: def-match. form is a
          generalization of ‘case’ using patterns.
        • The internal calling convention used for “apply” (ie.  calling
          an unknown-at-compile-time procedure) has been completely
          changed.
        • New types for arguments list (possibly with keywords) *note
          ‘arglist’ and ‘argvector’: Explicit argument list objects.
          along with *note an API: Argument list library. for using
          them.
   • Major changes to strings:
        • _Incompatible change:_ String literals are now
          ‘gnu.lists.IString’ rather than ‘java.lang.String’.  The
          advantage of using ‘gnu.lists.IString’ is that ‘string-ref’
          and ‘string-length’ are (roughly) constant-time, rather than
          having to linearly scan the string.
        • _Incompatible change:_ The procedures ‘string-append’,
          ‘string-map’, ‘substring’, ‘list->string’, ‘vector->string’,
          ‘string-downcase’, ‘string-upcase’, ‘string-foldcase’,
          ‘string-titlecase’, and the constructor ‘string’ return an
          immutable string (an ‘IString’).  (The function ‘string-copy’
          is similar to ‘substring’, but returns a mutable string.)
          This is a work-in-progress with the goal of implementing
          SRFI-140 (http://srfi.schemers.org/srfi-140/srfi-140.html):
          Other procedures will be changed to return immutable strings.

          If you ‘(import (scheme base))’ standard procedures such as
          ‘string-append’ will return mutable strings; if you ‘(import
          (kawa base))’ the procedures will return immutable strings.
          The command-line options ‘--r5rs’ or ‘--r6rs’ or ‘--r7rs’
          override the default so these procedures return mutable
          strings.
        • _Incompatible change:_ Treating a string as a sequence is now
          simpler but possibly slower: The I’th element is now the I’th
          Unicode code point.  Indexing with function-call syntax
          ‘(STRING I)’ is the same as ‘(string-ref STRING I)’ and
          ‘(length STRING)’ is the same as ‘(string-length STRING)’.
          This applies to all classes that implement
          ‘java.lang.CharSequence’.  Indexing may be a linear-time
          operation (thus much slower), unless the string is an
          ‘IString’ (in which case it is constant-time),
        • _Incompatible change:_ Before, if a Java parameter type was
          ‘java.lang.String’ Kawa would accept any value, converting it
          using Object’s ‘toString’ method.  Now Kawa will reject an
          argument if it is not a ‘java.lang.CharSequence’.
        • New procedures: ‘istring?’, ‘reverse-list->string’,
          ‘string-any’, ‘string-concatenate’,
          ‘string-concatenate-reverse’, ‘string-contains’,
          ‘string-contains-right’, ‘string-count’, ‘string-drop’,
          ‘string-drop-right’, ‘string-every’, ‘string-filter’,
          ‘string-fold’, ‘string-fold-right’, ‘string-for-each-index’,
          ‘string-index’, ‘string-index-right’, ‘string-join’,
          ‘string-map-index’, ‘string-null?’, ‘string-prefix?’,
          ‘string-prefix-length’, ‘string-repeat’, ‘string-remove’,
          ‘string-replace’, ‘string-skip’, ‘string-skip-right’,
          ‘string-split’, ‘string-suffix?’, ‘string-suffix-length’,
          ‘string-tabulate’, ‘string-take’, ‘string-take-right’,
          ‘string-trim’, ‘string-trim-right’, ‘string-trim-both’,
          ‘string-unfold’, ‘string-unfold-right’, ‘string->utf16’,
          ‘string->utf16be’, ‘string->utf16le’, ‘utf16->string’,
          ‘utf16be->string’, ‘utf16le->string’, ‘xsubstring’.  These
          follow SRFI-140 and return immutable strings.  (Some of these
          had previously been available in SRFI-13, but the older
          versions return mutable strings.)
   • _Incompatible change:_ Kawa traditionally followed Java in allowing
     you to pass an array with the “rest” arguments to a varargs method.
     For example, you could write:

     (define args (Object[] 3 "cm"))
     (java.lang.String:format "length:%s%s" args)

     This is no longer allowed.  Instead, use the splice operator:

     (java.lang.String:format "length:%s%s" @args)
   • _Incompatible change:_ You used to be able to write a
     type-specifier in a formal parameter or return type without using
     ‘::’, as in:
          (define (incr (x int)) int (+ x 1))
     This is no longer allowed, because it conflicts with the syntax for
     patterns.  Instead you have to write:
          (define (incr (x ::int)) ::int (+ x 1))
   • New type aliases ‘bitvector’ and ‘c16vector’.  The latter is a
     *note uniform vector: Uniform vectors. type for wrapping ‘char[]’
     arrays.
   • You can convert a Java array (for example a ‘int[]’ to the
     corresponing uniform vector type (for example ‘u32vector’) using
     the ‘as’ pseudo-function or the corresponding conversion procedure
     (for example ‘->u32vector’).  The result shares storage with the
     array, so changes in one will update the other.
   • The expression ‘(module-class)’ evaluates to the containing module
     class.
   • Change the *note mangling: Mangling. for field and local variables
     names to match the Symbolic Freedom
     (https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm)
     style.
   • Internally, expressions now record their ending position
     (line/column), in addition to the starting position.
   • The new procedure ‘environment-fold’ can be used to iterate over
     the bindings of an environment.
   • Change in how closure objects are allocated for inlined functions.
     This sometimes reduces the number of objection allocations and also
     of helper classes, though in pathological cases it could cause
     objects to be retained (leak) where it didn’t before.

   • New command-line flag ‘--warn-uninitialized’ (by default on) to
     control warning about using uninitialized variables.
   • The pre-defined *note character sets: Character sets. are now based
     on Java 9’s Unicode 8 support.

Kawa 2.4 (April 30, 2017)
-------------------------

   • Final 2.x release.  Minor updates and fixes.

Kawa 2.3 (January 13, 2017)
---------------------------

   • Moved Kawa’s source code repository (version control system) to use
     git, hosted at GitLab (https://gitlab.com/kashell/Kawa).
   • Issues (bugs, feature requests, etc) should now be reported using
     the GitLab Issue Tracker (https://gitlab.com/kashell/Kawa/issues).
   • New ‘with-docbook-stylesheets’ to make it easier to build the
     documentation with better functionality and look.
   • The command-line option ‘console:jline-mouse=yes’ enables moving
     the input cursor using a mouse click, when using JLine in the REPL
     on common xterm-like terminals.  This is disabled by default
     because it conflicts with other mouse actions, such as making a
     selection for copying text.  You can press shift to get the
     terminal’s standard mouse handling.

Kawa 2.2 (November 12, 2016)
----------------------------

   • A binary release is no longer just a Kawa ‘.jar’ file, but is now a
     ‘zip’ archive that also includes shell/batch scripts for running
     Kawa, useful third-party libraries, and the complete documentation
     in EPUB format.  The archives are named ‘kawa-version.zip’.
   • The ‘kawa --browse-manual’ switch makes it easy to *note browse the
     local documentation: browse-manual-option.
   • The *note ‘(kawa pictures’) library: Composable pictures. lets you
     create “picture” objects, display them, transform them, combine
     them, and more.
   • There is a new *note API for pretty-printing: Pretty-printing.
   • Basic support for Java 9 (though still some issues).
   • Generated files like ‘Makefile.in’ and ‘configure’ are no longer in
     the Subversion source code repository, though they are still
     included in the distributed ‘kawa-version.tar.gz’ releases.  The
     new top-level script ‘autogen.sh’ should be run before ‘configure’.
   • Kawa traditionally followed Java in allowing you to pass an array
     with the "rest" arguments to a varargs method.  (A "varargs" method
     includes Java varargs methods, as well as Kawa methods with a
     ‘#!rest’ parameter that is explicitly typed to be an array type.)
     For example, you could write:

     (define args (Object[] 3 "cm"))
     (java.lang.String:format "length:%s%s" args)

     This is deprecated, and may stop working in a future release.
     Instead, use the splice operator:

     (java.lang.String:format "length:%s%s" @args)

   • More options for *note range objects: Ranges.  For example, you can
     write ‘[1 by: 2 <=: 9]’.

   • Many enhancements to *note arrays: Arrays. and vectors:

        • Shape specifiers (used when creating an array) can now be one
          of a rank-2 array of low/high-bounds, as in SRFI-25; a vector
          of upper bounds; or a vector of ranges.
        • New type specifiers for array: ‘array’ is any array (i.e.  any
          ‘gnu.lists.Array’); ‘arrayN’ is the same restricted to rank
          ‘N’; ‘array[etype]’ or ‘arrayN[etype]’ restrict the types of
          elements to ‘etype’.

          If the ‘etype’ is a primitive type (for example
          ‘array2[double]’) then indexing is optimized to method calls
          that avoid object allocation.

        • Generalized array indexing: If A is an array (or a vector),
          then the expression:
          ‘(A I J K ...)’
          in general evaluates to an array B such that:
          ‘(B i1 i2 ... j1 j2 ... k1 k2 ... ...)’ is
          ‘(A (I i1 i2 ..) (J j1 j2 ...) (K k1 k2 ...) ...)’

          If an index I is an integer, it is treated as a zero-index
          array - a scalar.

          For example: if ‘(define B (A 2 [4 <: 10]))’ then ‘(B i)’ is
          ‘(A 2 (+ i 4))’.

        • The procedure ‘array-index-ref’ is does the above indexing
          explicitly: ‘(array-index-ref A I J K ...)’ is ‘(A I J K
          ...)’.  The result is a read-only snapshot.
        • The procedure ‘array-index-share’ is like ‘array-index-ref’
          but creates a modifiable view into argument array.
        • ‘(build-array shape procedure)’ is a general constructor for
          lazy arrays: If ‘A’ is the result, then ‘(A i j k ...)’ is
          ‘(procedure [I J K ...])’.
        • ‘array-transform’ creates a view, with a mapping of the
          indexes.
        • Other new procedures (like those in the Racket math package):
          ‘array-size’, ‘array-fill!’, ‘array-copy!’, ‘array-transform’,
          ‘array-reshape’, ‘array-flatten’, ‘array->vector’,
          ‘index-array’, ‘build-array’.
        • Add Common Lisp array reader syntax (‘#rankA’) with Guile
          extensions
          (https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html),
          including reader sypport for multi-dimensional uniform
          (primitive) arrays.  This is also used when printing arrays.
        • New ‘format-array’ procedure print an array a tabular
          2-dimensional (APL-like) format.  This format is used by
          default in the top-level of the REPL.

   • Print bit-vectors using the Common Lisp (and Guile) reader syntax.
     For example ‘#*1100110’.  Enhanced the reader to read this format.

   • Various REPL enhancements and new features:

        • The ‘-w’ switch to create a new REPL window can be followed by
          various sub-options to control _how_ and where the window is
          created.  For example ‘-wbrowser’ creates a new window using
          your default web browser.
        • Prompts are now normally specified using ‘printf’-style
          templates.  The normal prompt template is specified by the
          ‘input-prompt1’ variable, while continuation lines use
          ‘input-prompt2’.  These can be initialized by command-line
          options ‘console:prompt1’ and ‘console:prompt2’, or otherwise
          use language-specific defaults.  You can still use
          ‘set-input-port-prompter!’ to set a more general
          prompt-procedure, but it is now only called for the initial
          line of a command, not continuation lines.
        • The new ‘--with-jline3’ configure option builds support for
          the JLine (version 3) (https://github.com/jline/jline3)
          library for handling console input, similar to GNU readline.
        • Context-dependent command-completion (tab-completion) works
          when using JLine.

   • Various REPL enhancements when using DomTerm (http://domterm.org/).
        • If you “print” an XML/HTML node, it gets inserted into the
          DomTerm objects.  You print images, tables, fancy text, and
          more.
        • If you “print” a picture object or a ‘BuferredImage’ the
          picture is shown in the DomTerm console.
        • You can load or modify styles with the
          ‘domterm-load-stylesheet’ procedure.
        • When pretty-printing, calculation of line-breaks and
          indentation is handled by DomTerm.  If you change the window
          width, DomTerm will dynamically re-calculate the line-breaks
          of previous pretten output.  This works even in the case of a
          session saved to an HTML file, as long as JavaScript is
          enabled.
        • Hide/show buttons are emitted as part of the default prompt.
   • Multiple literals that have the same value (as in ‘equal?’) get
     compiled to the same object.
   • The syntax ‘&<[expr]’ is now equivalent to ‘&<{&[expr]}’, assuming
     ‘expr’ is an expression that evaluates to a string that named an
     existing file.  That file is read is the result is the contents of
     the file (as if by ‘(path-data expr)’).

Kawa 2.1 (October 26, 2015)
---------------------------

Lots of little changes, and some big changes to sequences and strings.

   • Enhancements to the Kawa tutorial.
   • Added ‘parameter’ as a new typename, for Scheme parameter objects.
     It can be parameterized (for example ‘parameter[string]’) for
     better type inference when "calling" (reading) the parameter.
   • We now define “interactive mode” as a REPL or a source module that
     uses the default global top-level environment _or_ a source module
     imported/required by a interactive module.  Interactive mode
     attempts to support dynamic re-definition and re-loading of
     function and other definitions.  This is a work-in-progres;
     interactive mode currently uses extra indirection to support
     re-definitions (at a slight performance cost).
   • Various changes and fixes in Path/URI handling.  Most
     significantly, the resolve argorithm used by ‘resolve-uri’ was
     re-written to use the algorithm from RFC-3986, rather than the
     obsolete RFC-2396 algorithm used by ‘java.net.URI.resolve’.
   • Change to mangle class and package name in Symbolic Freedom
     (https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm)
     style.  This means that class names and class filenames usually
     match the source file, even if special charaters are used, except
     for a small number of disallowed characters.  Note this is
     currently _only_ used for class and package names.
   • Allow ‘'synchronized’ and ‘'strictfp’ as access flags for methods.
   • You can now have a type-specifier for ‘define-variable’.

   • Better support for forward references between macros.

   • Added unsigned primitive integer types ‘ubyte’, ‘ushort’, ‘uint’,
     and ‘ulong’.  These are represented at run-time by the
     corresponding signed types, but Kawa generates code to do unsigned
     arithmethic and comparisons.  Corresponding boxed classes are
     ‘gnu.math.UByte’, ‘gnu.math.UShort’, ‘gnu.math.UInt’, and
     ‘gnu.math.ULong’.

   • Improvements and unification of sequences and strings:

        • The new ‘sequence’ type generalizes lists, vectors, arrays,
          strings, and more.  It is implemented as the ‘java.util.List’
          interface, but strings (‘java.lang.CharSequence’) and Java
          arrays are compatible with ‘sequence’ and converted as needed.
        • The ‘length’ function is generalized to arbitrary sequences.
          (For strings it uses the ‘CharSequence.length’ method, which
          returns the number of (16-bit) code units.  This is different
          from the ‘string-length’ function, which returns the number of
          Unicode code points.)
        • A new pseudo-character value ‘#\ignorable-char’ is introduced.
          It is ignored in string-construction contexts.
        • The function-call syntax for indexing works for all sequences.
          If the sequence is a string, the result is the Unicode
          (20-bit) scalar value at the specified index.  If index
          references the trailing surrogate of a surrogate pair the
          result is ‘#\ignorable-char’.  This allows efficient indexing
          of strings: Handing of surrogate pairs are handled
          automatically as long as ‘#\ignorable-char’ is skipped.
        • Indexing of uniform vector types (such as ‘s64vector’ or
          ‘f64vector’ or ‘u16vector’) now return the “standard”
          primitive type (such as ‘long’ or ‘double’) or the new
          unsigned primitive (such as ‘ushort’).  This improves
          performance (since we can generally use primitive types), and
          improves compatibility with Java arrays.  Specifically,
          ‘s64vector’ now implements ‘Sequence<Long>’, and thus
          ‘java.util.List<Long>’ Note that indexing a ‘f64vector’
          returns a ‘double’ which as an object is a ‘java.lang.Double’,
          not the Kawa floating-point type ‘gnu.math.DFloNum’.  The
          result is usually the same, but ‘eqv?’ might return a
          different result than previously.
        • The arguments to ‘map’, ‘for-each’, and ‘vector-for-each’ can
          now be any sequence (including strings and native arrays).
          The arguments to ‘vector-for-each’ can now be arbitrary
          ‘java.util.List’ values.  All of these are inlined.  If the
          sequence type is known, more efficient custom code is
          generated.

        • A range represents an enumerable sequence, normally integers,
          but it is represented compactly using the start value, the
          step (usually 1), and size.  There is a new convenient syntax
          for writing a range: if ‘i’ and ‘j’ are integers then ‘[i <=:
          j]’ is the sequence of integers starting at ‘i’ and ending at
          ‘j’ (inclusive).  You can also write ‘[i <=: j]’ (excludes the
          upper bound), ‘[i >: j]’ (counts down to ‘j’, exclusive), and
          ‘[i >=: j]’ (counts down to ‘j’, inclusive).
        • You can use a sequences of integers to index a sequence.  The
          result is the sequence of the selected elements.  In general
          ‘(seq [i0 ... in])’ is ‘[(seq i0) ... (seq in)]’.  This work
          well with ranges: ‘(seq [i <: j])’ is the subsequence of ‘seq’
          from ‘i’ to ‘j’ (exclusive).

          If the ‘seq’ is a string (a ‘CharSequence’) then the result is
          also a string.  In this case the indexing behavior is slightly
          different in that indexing selects (16-bit) code units, which
          are combined to a string.

   • A new ‘dynamic’ type is like ‘Object’.  However, it forces runtime
     lookup and type-checking, and supresses compile-time type check and
     errors.  (This is similar to C#.  It is useful as an escape hatch
     if we ever implement traditional strict static type-checking.)
   • Specifying the parameter type or return type of a function or
     method without a ’‘::’’ is deprecated and results in a warning.

   • In ‘--r7rs’ mode: The ’‘l’’ exponent suffix of a number literal
     creates a floating-point double, rather than a ‘BigInteger’.
   • Added the hyperbolic functions: sinh, cosh, tanh, asinh, acosh,
     atanh.
   • The ‘equal?’ function can now handle cyclic lists and vectors.  So
     can ‘equal-hash’.
   • The command-line option ‘--with-arg-count=N’ allows finer control
     of command-line-processing.  It is used before an “action”, and
     specifies the ‘N’ arguments following the action are set as the
     command-line-arguments.  After the action, command-line-processing
     continues following those ‘N’ arguments.
   • Added the R6RS module ‘(rnrs arithmetic bitwise)’.
   • The ‘kawa.repl’ argument processor now handles ‘-D’ options.
   • The new ‘class’ sub-form of ‘import’ allows you to import classes,
     and give them abbreviated names, like the Java ‘import’ statement.
     The new form is more compact and convenient than ‘define-alias’.

     You can also use a classname directly, as a symbol, instead of
     writing it in the form of a list:

     (import (only java.lang.Math PI))

   • In the ‘only’ clause of the ‘import’ syntax you can now directly
     rename, without having to write a ‘rename’ clause.
   • Changes in the calling-convention for ‘--full-tailcalls’ yields a
     substantial speed-up in some situations.
   • The type of boolean literals ‘#f’ and ‘#t’ is now primitive
     ‘boolean’ rather than ‘java.lang.Boolean’.
   • General multi-dimensional arrays can be indexed with function call
     notation.  E.g.  ‘(arr i j k)’ is equivalent to ‘(array-ref a i j
     k)’.  You can also use ‘set!’ with either ‘array-ref’ or function
     call notation.
   • The ‘#!null’ value (Java ‘null’) is now considered false, not true.
     Likewise for non-canonical false Boolean objects (i.e.  all
     instances of ‘java.lang.Boolean’ for which ‘booleanValue’ returns
     false, not just ‘Boolean.FALSE’).

   • New standard libraries ‘(kawa base)’ and ‘(kawa reflect)’.
   • You can now use patterns in the ‘let’ form and related forms.

   • Implemented the lambda lifting
     (http://en.wikipedia.org/wiki/Lambda_lifting) optimzation.
   • An expression that has type T is now considered compatible with a
     context requiring an interface type I only if T implements I (or T
     is Object).  (Before they were considered possibly-compatible if T
     was non-final because the run-time class might be a subclass of T
     that implements I.)
   • New ‘--console’ flag forces input to be treated as an interactive
     console, with prompting.  This is needed on Windows under Emacs,
     where ‘System.console()’ gives the wrong result.
   • You can now in a sub-class reference fields from not-yet-compiled
     super-classes.  (This doesn’t work for methods yet.)
   • The ‘(? name::type value)’ operator supports conditional binding.
     The ‘(! name::type value)’ operator supports unconditional binding;
     it is similar to ‘define-constant’, but supports patterns.

   • More efficient implementation of ‘call-with-values’: If either
     argument is a fixed-arity lambda expression it is inlined.  Better
     type-checking of both ‘call-with-values’ and ‘values’.

   • Jamison Hope enhanced the support for quaternions, primarily the
     new ‘(kawa rotations)’ library.

Kawa 2.0 (December 2 2014)
--------------------------

There are many new features, but the big one is R7RS compatibility.

   • New ‘define-alias’ can define aliases for static class members.
   • The treatment of keywords is changing to not be self-evaluating (in
     Scheme).  If you want a literal keyword, you should quote it.
     Unquoted keywords should only be used for keyword arguments.  (This
     will be enforced in a future release.)  The compiler now warns
     about badly formed keyword arguments, for example if a value is
     missing following a keyword.
   • The default is now Java 7, rather than Java 6.  This means the
     checked-in source code is pre-processed for Java 7, and future
     binary releases will require Java 7.
   • The behavior of parameters and fluid variables has changed.
     Setting a parameter no longer changes its value in already-running
     sub-threads.  The implementation is simpler and should be more
     efficient.

   • The form ‘define-early-constant’ is similar to ‘define-constant’,
     but it is evaluated in a module’s class initializer (or constructor
     in the case of a non-static definition).
   • Almost all of R7RS is now working:

        • Importing a SRFI library can now use the syntax ‘(import (srfi
          N [name]))’
        • The various standard libraries such as ‘(scheme base)’ are
          implemented.
        • The functions ‘eval’ and ‘load’ can now take an
          environment-specifier.  Implemented the ‘environment’
          function.
        • Extended ‘numerator’, ‘denominator’, ‘gcd’, and ‘lcm’ to
          inexacts.
        • The full R7RS library functionality is working, including
          ‘define-library’ The keyword ‘export’ is now a synonym for
          ‘module-export’, and both support the ‘rename’ keyword.  The
          ‘prefix’ option of ‘import’ now works.

        • The ‘cond-expand’ form now supports the ‘library’ clause.
        • Implemented ‘make-promise’ and ‘delay-force’ (equivalent to
          the older name ‘lazy’).
        • Changed ‘include’ so that by default it first seaches the
          directory containing the included file, so by default it has
          the same effect as ‘include-relative’.  However, you can
          override the search path with the ‘-Dkawa.include.path’
          property.  Also implemented ‘include-ci’.
        • Implemented ‘define-values’.
        • Fixed ‘string->number’ to correctly handle a radix specifier
          in the string.
        • The ‘read’ procedure now returns mutable pairs.
        • If you need to use ‘...’ in a ‘syntax-rules’ template you can
          use ‘(... template)’, which disables the special meaning of
          ‘...’ in ‘template’.  (This is an extension of the older ‘(...
          ...)’.)
        • Alternatively, you can can write ‘(syntax-rules dots
          (literals) rules)’.  The symbol ‘dots’ replaces the
          functionality of ‘...’ in the ‘rules’.
        • An underscore ‘_’ in a ‘syntax-rules’ pattern matches
          anything, and is ignored.
        • The ‘syntax-error’ syntax (renamed from ‘%syntax-error’)
          allows error reporting in ‘syntax-rules’ macros.  (The older
          Kawa-specific ‘syntax-error’ procedure was renamed to
          ‘report-syntax-error’.)
        • Implemented and documented R7RS exception handling: The syntax
          ‘guard’ and the procedures ‘with-exception-handler’, ‘raise’,
          and ‘raise-continuable’ all work.  The ‘error’ procedure is
          R7RS-compatible, and the procedures ‘error-object?’,
          ‘error-object-message’, ‘error-object-irritants’,
          ‘file-error?’, and ‘read-error?’ were implemented.

        • Implemented ‘emergency-exit’, and modified ‘exit’ so
          finally-blocks are executed.

        • Implemented ‘exact-integer?’, ‘floor/’, ‘floor-quotient’,
          ‘floor-remainder’, ‘truncate/’, ‘truncate-quotient’, and
          ‘truncate-remainder’.
        • The ‘letrec*’ syntax is now supported.  (It works the same as
          ‘letrec’, which is an allowed extension of ‘letrec’.)

        • The functions ‘utf8->string’ and ‘string->utf8’ are now
          documented in the manual.

   • The changes to characters and strings are worth covering
     separately:

        • The ‘character’ type is now a new primitive type (implemented
          as ‘int’).  This can avoid boxing (object allocation)
        • There is also a new ‘character-or-eof’.  (A union of
          ‘character’ and the EOF value, except the latter is encoded as
          -1, thus avoiding object allocation.)  The functions read-char
          and ‘peek-char’ now return a ‘character-or-eof’ value.
        • Functions like ‘string-ref’ that take a character index would
          not take into account non-BMP characters (those whose value is
          greater than ‘#xffff’, thus requiring two surrogate
          characters).  This was contrary to R6RS/R7RS. This has been
          fixed, though at some performance cost .  (For example
          ‘string-ref’ and ‘string-length’ are no longer constant-time.)
        • Implemented a ‘string-cursor’ API
          (Strings.html#String-Cursor-API) (based on Chibi Scheme).
          Thes allow efficient indexing, based on opaque cursors
          (actually counts of 16-bits ‘char’s).
        • Optimized ‘string-for-each’, which is now the preferred way to
          iterate through a string.
        • Implemented ‘string-map’.
        • New function ‘string-append!’ for in-place appending to a
          mutable string.
        • New function ‘string-replace!’ for replacing a substring of a
          string with some other string.
        • The SRFI-13 function ‘string-append/shared’ is no longer
          automatically visible; you have to ‘(import (srfi :13
          strings))’ or similar.

   • The ‘module-name’ form allows the name to be a list, as in a
     R6RS/R7RS-style library name.
   • The syntax ‘@expression’ is a _splicing form_.  The ‘expression’
     must evaluate to a sequence (vector, list, array, etc).  The
     function application or constructor form is equivalent to all the
     elements of the sequence.
   • The parameter object ‘current-path’ returns (or sets) the default
     directory of the current thread.
   • Add convenience procedures and syntax for working with processes
     (Processes.html): ‘run-process’, ‘process-exit-wait’,
     ‘process-exit-ok?’, ‘&cmd’, ‘&`’, ‘&sh’.
   • The functions ‘path-bytes’, and ‘path-data’ can read or write the
     entire contents of a file
     (http://www.gnu.org/software/kawa/Reading-and-writing-whole-files.html).
     Alternatively, you can use the short-hand syntax: ‘&<{pname}’
     ‘&>{pname}’ ‘&>>{pname}’.  These work with "blobs" which may be
     text or binary depending on context.
   • The initial values of ‘(current-output-port)’ and
     ‘(current-error-port)’ are now hybrid textual/binary ports.  This
     means you can call ‘write-bytevector’ and ‘write-u8’ on them,
     making it possible for an application to write binary data to
     standard output.  Similarly, initial value of
     ‘(current-input-port)’ is a hybrid textual/binary port, but only if
     there is no console (standard input is not a tty).

   • Jamison Hope contributed support for quaternions
     (http://en.wikipedia.org/wiki/Quaternion), a generalization of
     complex numbers containing 4 real components.

   • Andrea Bernardini contributed an optimized implementation of ‘case’
     expressions.  He was sponsored by Google Summer of Code.
   • The ‘kawa.sh’ shell script (which is installed as ‘kawa’ when _not_
     configuring with ‘--enable-kawa-frontend’) now handles ‘-D’ and
     ‘-J’ options.  The ‘kawa.sh’ script is now also built when usint
     Ant.
   • The ‘cond-expand’ features ‘java-6’ though ‘java-9’ are now set
     based on the ‘System’ property ‘"java.version"’ (rather than how
     Kawa was configured).
   • An Emacs-style ‘coding’ declaration allows you to specify the
     encoding of a Scheme source file.
   • The command-line option ‘--debug-syntax-pattern-match’ prints
     logging importation to standard error when a ‘syntax-rules’ or
     ‘syntax-case’ pattern matches.
   • SRFI-60 (Integers as Bits)
     (http://srfi.schemers.org/srfi-60/srfi-60.html) is now fully
     implemented.

   • Ported SRFI-101 (http://srfi.schemers.org/srfi-101/srfi-101.html).
     These are immutable (read-only) lists with fast (logarithmic)
     indexing and functional update (i.e.  return a modified list).
     These are implemented by a ‘RAPair’ class which extends the generic
     ‘pair’ type, which means that most code that expects a standard
     list will work on these lists as well.

   • The class ‘kawa.lib.kawa.expressions’ contains an experimental
     Scheme API for manipulating and validating expressions.
   • Internal: Changed representation used for multiple values to an
     abstract class with multiple implementations.

   • Internal: Started converting to more standard Java code formatting
     and indentation conventions, rather than GNU conventions.  Some
     files converted; this is ongoing work.
   • Internal: Various I/O-related classes moved to new package
     ‘gnu.kawa.io’.

   • Various changes to the ‘configure+make’ build framework: A C
     compiler is now only needed if you configure with
     ‘--enable-kawa-frontend’.  Improved support for building under
     Windows (using MinGW/MSYS).

   • Support for building with GCJ (http://gcc.gnu.org/java/) was
     removed.

Kawa 1.14 (October 4, 2013)
---------------------------

   • You can pass flags from the ‘kawa’ front-end to the ‘java’ launcher
     using ‘-J’ and ‘-D’ flags.  The ‘kawa’ front-end now passes the
     ‘kawa.command.line’ property to Java; this is used by the
     ‘(command-line)’ procedure.
   • Various improvements to the shell-script handling, including
     re-written documentation (Scripts.html).
   • Some initial support for Java 8.

   • More of R7RS is now working:

        • After adding list procedures ‘make-list’, ‘list-copy’,
          ‘list-set!’ all the R7RS list procedures are implemented.
        • Other added procedures: ‘square’, ‘boolean=?’, ‘string-copy!’,
          ‘digit-value’, ‘get-environment-variable’,
          ‘get-environment-variables’, ‘current-second’,
          ‘current-jiffy’, ‘jiffies-per-second’, and ‘features’.
        • The predicates ‘finite?’, ‘infinite?’, and ‘nan?’ are
          generalized to complex numbers.
        • The procedures ‘write’, ‘write-simple’, and ‘write-shared’ are
          now consistent with R7RS.
        • String and character comparison functions are generalized to
          more than two arguments (but restricted to strings or
          characters, respectively).
        • The procedures ‘string-copy’, ‘string->list’, and
          ‘string-fill!’ now take optional (start,end)-bounds.  All of
          the R7RS string functions are now implemented.
        • Support ‘=>’ syntax in ‘case’ form.
        • Support backslash-escaped special characters in symbols when
          inside vertical bars, such as ‘'|Hello\nworld|’.
        • The new functions and syntax are documented in the Kawa manual
          (index.html); look for the functions in the index
          (Overall-Index.html).

   • Added ‘define-private-alias’ keyword.
   • Extended string quasi-literals (templates)
     (Strings.html#String-templates) as specified by SRFI-109
     (http://srfi.schemers.org/srfi-109/srfi-109.html).  For example, if
     ‘name’ has the value ‘"John"’, then:

     &{Hello &[name]!}

     evaluates to: ‘"Hello John!"’.

   • Named quasi-literal constructors as specified by SRFI-108
     (http://srfi.schemers.org/srfi-108/srfi-108.html).
   • A symbol having the form ‘->type’ is a type conversion function
     that converts a value to ‘type’.
   • New and improved check for void-valued expressions in a context
     requiring a value.  This is controlled by the new option
     ‘--warn-void-used’, which defaults to true.

   • The ‘datum->syntax’ procedure takes an optional third parameter to
     specify the source location.  See ‘testsuite/srfi-108-test.scm’ for
     an example.
   • Instead of specifying ‘--main’ the command line, you can now
     specify ‘(module-compile-options: main: #t)’ in the Scheme file.
     This makes it easier to compile one or more application (main)
     modules along with other modules.
   • A change to the data structure used to detect never-returning
     procedure uses a lot less memory.  (Kawa 1.13 implemented a
     conservative detection of when a procedure cannot return.  This
     analysis would sometimes cause the Kawa compiler to run out of
     memory.  The improved analysis uses the same basic algorithm, but
     with a more space-efficient “inverted” data structure.)
   • Multiple fixes to get Emacs Lisp (JEmacs) working (somewhat) again.

Kawa 1.13 (December 10, 2012)
-----------------------------

   • We now do a simple (conservative) analysis of when a procedure
     cannot return.  This is combined with earlier and more precise
     analysis of reachable code.  Not only does this catch programmer
     errors better, but it also avoids some internal compiler errors,
     because Kawa could get confused by unreachable code.
   • Implement 2-argument version of ‘log’ function, as specified by
     R6RS and R7RS (and, prematurely, the Kawa documentation).
   • Implement the R7RS ‘bytevector’ functions.  The ‘bytevector’ type
     is a synonym for older ‘u8vector’ type.

   • Implement R7RS ‘vector’ procedures.  Various procedures now take
     (start,end)-bounds.

   • Implement most of the R7RS input/output proecdures.  Most
     significant enhancement is support for R7RS-conforming binary
     ports.
   • Various enhancements to the manual, including merging in lots of
     text from R7RS.
   • Improved Android support, including a more convenient Ant script
     contributed by Julien Rousseau.  Also, documentation merged into
     manual.

Kawa 1.12 (May 30, 2012)
------------------------

   • Implement a compile-time data-flow framework, similar to Single
     Static Assignment.  This enables better type inference, improves
     some warnings/errors, and enables some optimizations.

   • Jamison Hope added support for co-variant return types and bridge
     methods for generics.
   • Macros were improved and more standards-conforming:
        • ‘datum->syntax’ and ‘syntax->datum’ are preferred names for
          ‘datum->syntax-object’ and ‘syntax-object->datum’.
        • Implemented ‘bound-identifier=?’ and re-wrote implementation
          of ‘free-identifier=?’.

        • Implement ‘unsyntax’ and ‘unsyntax-splicing’, along with the
          reader prefixes ‘#,’ and ‘#,@’.

   • New and improved lazy evaluation functionality:

        • Lazy values (resulting from ‘delay’ or ‘future’) are
          implicitly forced as needed.  This makes “lazy programming”
          more convenient.
        • New type ‘promise’.
        • The semantics of promises (‘delay’ etc) is now compatible with
          SRFI 45 (http://srfi.schemers.org/srfi-45/srfi-45.html).
        • “Blank promises” are useful for passing data between
          processes, logic programmming, and more.  New functions
          ‘promise-set-value!’, ‘promise-set-alias!’,
          ‘promise-set-exception!’, and ‘promise-set-thunk!’.
        • The stream functions of SRFI-41
          (http://srfi.schemers.org/srfi-41/srfi-41.html) were
          re-implemented to use the new promise functionality.

   • Different functions in the same module can be compiled with or
     without full tailcall support.  You can control this by using
     ‘full-tailcalls’ in ‘with-compile-options’.  You can also control
     ‘full-tailcalls’ using ‘module-compile-options’.

   • Charles Turner (sponsored by Google’s Summer of Code
     (http://code.google.com/soc/)) enhanced the printer with support
     for SRFI-38: External Representation for Data With Shared Structure
     (http://srfi.schemers.org/srfi-38/).

   • Optimize tail-recursion in module-level procedures.  (We used to
     only do this for internal functions, for reasons that are no longer
     relevant.)

   • Add support for building Kawa on Windows using configure+make
     (autotools) and Cygwin.

   • Some support for parameterized (generic) types:

       Type[Arg1 Arg2 ... ArgN]

     is more-or-less equivalent to Java’s:

       Type<Arg1, Arg2, ..., ArgN>

   • New language options ‘--r5rs’, ‘--r6rs’, and ‘--r7rs’ provide
     better compatibility with those Scheme standards.  (This is a
     work-in-progress.)  For example ‘--r6rs’ aims to disable Kawa
     extensions that conflict with R6RS. It does not aim to disable all
     extensions, only incompatible extensions.  So far these extensions
     disable the colon operator and keyword literals.  Selecting
     ‘--r5rs’ makes symbols by default case-insensitive.

   • The special tokens ‘#!fold-case’ and ‘#!no-fold-case’ act like
     comments except they enable or disable case-folding of symbols.
     The old ‘symbol-read-case’ global is now only checked when a
     LispReader is created, not each time a symbol is read.
   • You can now use square brackets to construct immutable sequences
     (vectors).
   • A record type defined using ‘define-record-type’ is now compiled to
     a class that is a member of the module class.

   • Annotations are now supported.  This example
     (http://per.bothner.com/blog/2011/Using-JAXB-annotations/) shows
     how to use JAXB (http://java.sun.com/xml/downloads/jaxb.html)
     annotations to automatically convert between between Java objects
     and XML files.
   • Prevent mutation of vector literals.

   • More R6RS procedures: ‘vector-map’, ‘vector-for-each’,
     ‘string-for-each’, ‘real-valued?’, ‘rational-valued?’,
     ‘integer-valued?’, ‘finite?’, ‘infinite?’, ‘nan?’,
     ‘exact-integer-sqrt’.

   • SRFI-14 (http://srfi.schemers.org/srfi-14/srfi-14.html) ("character
     sets") and SRFI-41 (http://srfi.schemers.org/srfi-41/srfi-41.html)
     ("streams") are now supported, thanks to porting done by Jamison
     Hope.

   • Kawa now runs under JDK 1.7.  This mostly involved fixing some
     errors in ‘StackMapTable’ generation.

   • You can now have a class created by ‘define-simple-class’ with the
     same name as the module class.  For example ‘(define-simple-class
     foo ...)’ in a file ‘foo.scm’.  The defined class will serve
     dual-purpose as the module class.
   • Improvements in separating compile-time from run-time code,
     reducing the size of the runtime jar used for compiled code.
   • In the ‘cond-expand’ conditional form you can now use
     ‘class-exists:ClassName’ as a feature “name” to tests that
     ‘ClassName’ exists.

Kawa 1.11 (November 11, 2010)
-----------------------------

   • A new Kawa logo, contributed by Jakub Jankiewicz
     (http://jcubic.pl).
   • A new ‘--warn-unknown-member’ option, which generalizes
     ‘--warn-invoke-unknown-method’ to fields as well as methods.
   • A new ‘kawac’ task (ant-kawac.html), useful for Ant ‘build.xml’
     files, contributed by Jamison Hope.
   • Updated Android support
     (http://per.bothner.com/blog/2010/AndroidHelloScheme).
   • New ‘define-enum’ macro (Enumerations.html) contributed by Jamison
     Hope.
   • Access specifiers ‘'final’ and ‘'enum’ are now allowed in
     ‘define-class’ and related forms.
   • Optimized ‘odd?’ and ‘even?’.
   • If you specify the type of a ‘#!rest’ parameter as an array type,
     that will now be used for the "varargs" method parameter.  (Before
     only object arrays did this.)
   • When constructing an object and there is no matching constructor
     method, look for "‘add’" methods in addition to "‘set’" methods.
     Also, allow passing constructor args as well as keyword setters.
     See here (Allocating-objects.html) for the gory details.
   • New ‘expand’ function (contributed by Helmut Eller, and enabled by
     ‘(require 'syntax-utils)’) for converting Scheme expressions to
     macro-expanded forms.
   • SAM-conversion (Anonymous-classes.html#SAM-conversion): In a
     context that expects a Single Abstract Method (SAM) type (for
     example ‘java.lang.Runnable’), if you pass a lambda you will get an
     ‘object’ where the lambda implements the abstract method.

   • In interactive mode allow dynamic rebinding of procedures.  I.e.
     if you re-define a procedure, the old procedure objects gets
     modified in-place and re-used, rather than creating a new procedure
     object.  Thus calls in existing procedures will call the new
     version.

   • Fix various threading issues related to compilation and eval.

   • When ‘format’ returns a string, return a ‘java.lang.String’ rather
     than a ‘gnu.lists.FString’.  Also, add some minor optimization.
   • Inheritance of environments and fluid variables now work properly
     for all child threads, not just ones created using ‘future’.

Kawa 1.10 (July 24, 2010)
-------------------------

   • Now defaults to using Java 6, when compiling from source.  The
     pre-built ‘jar’ works with Java 5, but makes use of some Java 6
     features (‘javax.script’, built-in HTTP server) if available.
   • You can write XML literals (XML-literals.html) in Scheme code
     prefixed by a ‘#’, for example:

     #<p>The result is &{result}.</p>

   • New functions ‘element-name’ and ‘attribute-name’.
   • Various Web server improvements (Server-side-scripts.html).  You
     have the option of using JDK 6’s builtin web-server
     (Options.html#Options-for-web-servers) for auto-configued web pages
     (Self-configuring-page-scripts.html).  Automatic import of web
     server functions, so you should not need to ‘(import 'http)’ any
     more.
   • Kawa hashtables (Hash-tables.html) now extend ‘java.util.Map’.

   • If a source file is specified on the ‘kawa’ command line without
     any options, it is read and compiled as a whole module before it is
     run.  In contrast, if you want to read and evaluate a source file
     line-by-line you must use the ‘-f’ flag.

   • You can specify a class name on the ‘kawa’ command line:

     $ kawa fully.qualified.name

     This is like the ‘java’ command.  but you don’t need to specify the
     path to the Kawa runtime library, and you don’t need a ‘main’
     method (as long as the class is ‘Runnable’).

   • The usual bug-fixes, including better handling of the ‘~F’ ‘format’
     directive; and fix in handling of macro hygiene of the ‘lambda’
     (bug #27042 (https://savannah.gnu.org/bugs/index.php?27042)).

   • Spaces are now optional before and after the ’::’ in type
     specifiers.  The preferred syntax leave no space after the ’::’, as
     in:

     (define xx ::int 1)

   • ‘define-for-syntax’ and ‘begin-for-syntax’ work.

   • You can now use ‘car’, ‘cdr’ etc to work with ‘syntax’ objects that
     wrap lists, as in SRFI-72.

   • You can now define a package alias:

     (define-alias jutil java.util)
     (define mylist :: jutil:List (jutil:ArrayList))

   • ‘--module-static’ is now the default.  A new ‘--module-nonstatic’
     (or ‘--no-module-static’) option can be used to get the old
     behavior.

   • You can use ‘access:’ to specify that a field is ‘'volatile’ or
     ‘'transient’.

   • You can now have type-specifiers for multiple variables in a ‘do’.

   • Imported variables are read-only.

   • Exported variables are only made into Locations when needed.

   • The letter used for the exponent in a floating-point literal
     determines its type: ‘12s2’ is a ‘java.lang.Float’, ‘12d2’ is a
     ‘java.lang.Double’, ‘12l2’ is a ‘java.math.BigInteger’, ‘12e2’ is a
     ‘gnu.math.DFloat’.

   • Internal: Asking for a ‘.class’ file using ‘getResourceAsStream’ on
     an ‘ArrayClassLoader’ will now open a ‘ByteArrayInputStream’ on the
     class bytes.

   • A new ‘disassemble’ function.

   • If ‘exp1’ has type ‘int’, the type of ‘(+ exp1 1)’ is now (32-bit)
     ‘int’, rather than (unlimited-precision) ‘integer’.  Similar for
     ‘long’ expressions, other arithmetic operations (as appropriate),
     and other untyped integer literals (as long as they fit in 32/64
     bits respectively).

   • Many more oprimization/specializations of arithmetic, especially
     when argument types are known.

   • Top-level bindings in a module compiled with ‘--main’ are now
     implicitly module-private, unless there is an explicit
     ‘module-export’.

   • SRFI-2 (http://srfi.schemers.org/srfi-2/srfi-2.html) (‘and-let*’:
     an ‘and’ with local bindings, a guarded ‘*’ special form) is now
     supported.

   • The reader now supports shared sub-objects, as in SRFI-38
     (http://srfi.schemers.org/srfi-38/srfi-38.html) and Common Lisp:
     ‘(#2=(3 4) 9 #2# #2#)’.  (Writing shared sub-objects is not yet
     implemented.)

   • A module compiled with ‘--main’ by default exports no bindings
     (unless overriden by an explicit ‘module-export’).

   • Factor out compile-time only code from run-time code.  The new
     ‘kawart-version.jar’ is smaller because it has less compile-time
     only code.  (Work in progress.)
   • More changes for R6RS compatibility:

        • The reader now recognizes ‘+nan.0’, ‘+inf.0’ and variations.

        • The ‘div’, ‘mod’, ‘div0’, ‘mod0’, ‘div-and-mod’,
          ‘div0-and-mod0’, ‘inexact’ and ‘exact’ functions were
          implemented.

        • ‘command-line’ and ‘exit’.

Kawa 1.9.90 (August 8, 2009)
----------------------------

   • Support for ‘javax.script’.

   • Support for regular expressions (Regular-expressions.html).

   • Performance improvements:

        • Emit ‘iinc’ instruction (to increment a local ‘int’ by a
          constant).

        • Inline the ‘not’ function if the argument is constant.

        • If ‘call-with-current-continuation’ is only used to exit a
          block in the current method, optimize to a ‘goto’.

        • Generate ‘StackMapTable’ attributes when targeting Java 6.

        • Kawa can now inline a function with multiple calls (without
          code duplication) if all call sites have the same return
          location (continuation).  For example: ‘(if p (f a) (f b))’.
          Also mutually tail-recursive functions are inlined, so you get
          constant stack space even without ‘--full-tailcalls’.  (Thanks
          for Helmut Eller for a prototype.)

   • A number of changes for R6RS compatibility:

        • The ‘char-titlecase’, ‘char-foldcase’, ‘char-title-case?’
          library functions are implemented.

        • Imported variables are read-only.

        • Support the R6RS ‘import’ keyword, including support for
          renaming.

        • Support the R6RS ‘export’ keyword (though without support for
          renaming).

        • Implemented the ‘(rnrs hashtables)’ library.

        • Implemented the ‘(rnrs sorting)’ library.

        • CommonLisp-style keyword syntax is no longer supported (for
          Scheme): A colon followed by an identifier is no longer a
          keyword (though an identifier followed by a colon is still a
          keyword).  (One reason for this change is to support SRFI-97.)

        • The character names ‘#\delete’, ‘#\alarm’, ‘#\vtab’ are now
          supported.  The old names ‘#\del’, ‘#\rubout’, and ‘#\bel’ are
          deprecated.

        • Hex escapes in character literals are supported.  These are
          now printed where we before printed octal escapes.

        • A hex escape in a string literal should be terminated by a
          semi-colon, but for compatibily any other non-hex-digit will
          also terminate the escape.  (A terminating semi-colon will be
          skipped, though a different terminator will be included in the
          string.)

        • A backslash-whitespace escape in a string literal will not
          only ignore the whitespace through the end of the line, but
          also any initial whitespace at the start of the following
          line.

        • The comment prefix ‘#;’ skips the following S-expression, as
          specified by SRFI-62
          (http://srfi.schemers.org/srfi-62/srfi-62.html).

        • All the R6RS exact bitwise arithmetic
          (http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4)
          functions are now implemented and documented in the manual
          (Logical-Number-Operations.html).  The new standard functions
          (for example ‘bitwise-and’) are now preferred over the old
          functions (for example ‘logand’).

        • If ‘delete-file’ fails, throws an exception instead of
          returning ‘#f’.

   • The code-base now by default assumes Java 5 (JDK 1.5 or newer), and
     pre-built ‘jar’ files will require Java 5.  Also, the Kawa source
     code now uses generics, so you need to use a generics-aware
     ‘javac’, passing it the appropriate ‘--target’ flag.

   • New SRFIs supported:

        • SRFI-62 (http://srfi.schemers.org/srfi-62/srfi-62.html) -
          S-expression comments.

        • SRFI-64 (http://srfi.schemers.org/srfi-64/srfi-64.html) -
          Scheme API for test suites.

        • SRFI-95 (http://srfi.schemers.org/srfi-95/srfi-95.html) -
          Sorting and Merging.

        • SRFI-97 (http://srfi.schemers.org/srfi-97/srfi-97.html) -
          Names for SRFI Libraries.  This is a naming convention for
          R6RS ‘import’ statements to reference SRFI libraries.

   • In BRL text outside square brackets (or nested like ‘]this[’) now
     evaluates to ‘UnescapedData’, which a Scheme quoted string
     evaluates to ‘String’, rather than an ‘FString’.  (All of the
     mentioned types implement ‘java.lang.CharSequence’.)

   • You can now run Kawa Scheme programs on Android
     (http://per.bothner.com/blog/2009/AndroidHelloScheme/), Google’s
     mobile-phone operating system.

   • The macro ‘resource-url’ is useful for accessing resources.

   • A new command-line option ‘--target’ (or ‘-target’) similar to
     ‘javac’’s ‘-target’ option.

   • If there is no console, by default create a window as if ‘-w’ was
     specificed.

   • If a class method (defined in ‘define-class’, ‘define-simple-class’
     or ‘object’) does not have its parameter or return type specified,
     search the super-classes/interfaces for matching methods (same name
     and number of parameters), and if these are consistent, use that
     type.

   • Trying to modify the ‘car’ or ‘cdr’ of a literal list now throws an
     exception.

   • The ‘.zip’ archive created by ‘compile-file’ is now compressed.

   • Java5-style varargs-methods are recognized as such.

   • When evaluating or loading a source file, we now always compile to
     bytecode, rather than interpreting “simple” expressions.  This
     makes semantics and performance more consistent, and gives us
     better exception stack traces.

   • The Scheme type specifier ‘<integer>’ now handles automatic
     conversion from ‘java.math.BigInteger’ and the ‘java.lang’ classes
     ‘Long’, ‘Integer’, ‘Short’, and ‘Byte’.  The various standard
     functions that work on ‘<integer>’ (for example ‘gcd’ and
     ‘arithmetic-shift’) can be passed (say) a ‘java.lang.Integer’.  The
     generic functions such as ‘+’ and the real function ‘modulo’ should
     also work.  (The result is still a ‘gnu.math.IntNum’.)

   • If a name such as (‘java.util’) is lexically unbound, and there is
     a known package with that name, return the ‘java.lang.Package’
     instance.  Also, the colon operator is extended so that
     ‘package:name’ evaluates to the ‘Class’ for ‘package.name’.

   • ‘`prefix:,expression’ works - it finds a symbol in ‘prefix’’s
     package (aka namespace), whose local-name is the value of
     ‘expression’.

   • A quantity ‘3.0cm’ is now syntactic sugar for ‘(* 3.0 unit:cm)’.
     Similarly:
     ‘(define-unit name value)’
     is equivalent to:
     ‘(define-constant unit:name value)’
     This means that unit names follow normal name-lookup rules (except
     being in the ‘unit’ “package”), so for example you can have local
     unit definitions.

   • You can specify whether a class has public or package access, and
     whether it is translated to an interface or class.

   • You can declare an abstract method by writing ‘#!abstract’ as its
     body.

   • If a name of the form ‘type?’ is undefined, but ‘type’ is defined,
     then treat the former as ‘(lambda (x) (instance? x type))’.
   • A major incompatible (but long-sought) change: Java strings (i.e.
     ‘java.lang.String’ values) are now Scheme strings, rather than
     Scheme symbols.  Since Scheme strings are mutable, while Java
     ‘String’s are not, we use a different type for mutable strings:
     ‘gnu.lists.FString’ (this is not a change).  Scheme string literals
     are ‘java.lang.String’ values.  The common type for Scheme string
     is ‘java.lang.CharSequence’ (which was introducted in JDK 1.4).

     Scheme symbols are now instances of ‘gnu.mapping.Symbol’
     (api/gnu/mapping/Symbol.html), specifically the ‘SimpleSymbol’
     class.

   • A fully-qualified class name such as ‘java.lang.Integer’ now
     evaluates to the corresponding ‘java.lang.Class’ object.  I.e.  it
     is equivalent to the Java term ‘java.lang.Integer.class’.  This
     assumes that the name does not have a lexical binding, _and_ that
     it exists in the class-path at compile time.

     Array class names (such as ‘java.lang.Integer[]’) and primitive
     types (such as ‘int’) also work.

     The older angle-bracket syntax ‘<java.lang.Integer>’ also works and
     has the same meaning.  It also evaluates to a ‘Class’.  It used to
     evaluate to a ‘Type’ (api/gnu/bytecode/Type.html), so this is a
     change.

     The name bound by a ‘define-simple-class’ now evaluates to a
     ‘Class’, rather than a ‘ClassType’
     (api/gnu/bytecode/ClassType.html).  A ‘define-simple-class’ is not
     allowed to reference non-static module-level bindings; for that use
     ‘define-class’.

   • New convenience macro ‘define-syntax-case’
     (Syntax-and-conditional-compilation.html).

Kawa 1.9.1 (January 23, 2007)
-----------------------------

   • Fix some problems building Kawa from source using ‘configure+make’.

Kawa 1.9.0 (January 21, 2007)
-----------------------------

   • New types and functions for working with paths and URIs
     (Paths.html).

   • Reader macros URI, namespace, duration.

   • Simplified build using gcj (Source-distribution.html), and added
     configure flag –with-gcj-dbtool.

   • If two “word” values are written, a space is written between them.
     A word is most Scheme values, including numbers and lists.  A
     Scheme string is treated as a word by ‘write’ but by not ‘display’.

   • A new ‘--pedantic’ command-line flag.  It currently only affects
     the XQuery parser.

   • The ‘load-compile’ procedure was removed.

   • The string printed by the ‘--version’ switch now includes the
     Subversion revision and date (but only if Kawa was built using
     ‘make’ rather than ‘ant’ from a checked-out Subversion tree).

   • Kawa development now uses the Subversion (svn)
     (http://subversion.tigris.org/) version control system instead of
     CVS.

   • Show file/line/column on unbound symbols (both when interpreted and
     when compiled).

   • Cycles are now allowed between ‘require’’d modules.  Also,
     compiling at set of modules that depend on each other can now
     specified on the compilation command line in any order, as long as
     needed ‘require’ forms are given.

   • The “colon notation” has been generalized.  (PathExpressions.html).
     The syntax ‘object:name’ generally means to extract a component
     with a given ‘name’ from ‘object’, which may be an object, a class,
     or a namespace.

   • New command-line options ‘--debug-error-prints-stack-trace’ and
     ‘--debug-warning-prints-stack-trace’ provide stack trace on static
     error messages.

   • The license for the Kawa software (Software-License.html) has been
     changed to the X11/MIT license
     (http://opensource.org/licenses/mit-license.php).

   • A much more convenient syntax for working with Java arrays
     (Array-operations.html).

     The same function-call syntax also works for Scheme vectors,
     uniform vectors, strings, lists - and anything else that implements
     ‘java.util.List’.

   • The fields and methods of a class and its bases classes are in
     scope within methods of the class.
   • Unnamed procedures (such as lambda expressions) are printed with
     the source filename and line.

   • The numeric compare functions (‘=’, ‘<=’, etc) and ‘number->string’
     now work when passed standard Java ‘Number’ objects (such as
     ‘java.lang.Long’ or ‘java.math.BigDecimal’).
   • SRFI-10 (http://srfi.schemers.org/srfi-10/srfi-10.html) is now
     implemented, providing the ‘#,(name args ...)’ form.  Predefined
     constructor ‘name’s so far are ‘URI’ and ‘namespace’.  The
     ‘define-reader-ctor’ function is available if you ‘(require
     'srfi-10)’.

   • A new ‘--script’ option makes it easier to write Unix shell
     scripts.

   • Allow general URLs for loading (including the ‘-f’ flag),
     compilation and ‘open-input-file’, if the “file name” starts with a
     URL “scheme” like ‘http:’.

   • Classes defined (_e.g._  with ‘define-simple-class’) in a module
     can now mutually reference each other.  On the other hand, you can
     no longer ‘define-class’ if the class extends a class rather than
     an interface; you must use ‘define-simple-class’.

   • ‘KawaPageServlet’ now automatically selects language.

   • ‘provide’ macro.
   • ‘quasisyntax’ and the convenience syntax ‘#`’, from SRFI-72
     (http://srfi.schemers.org/srfi-72/srfi-72.html).
   • ‘define-for-syntax’, ‘syntax-source’, ‘syntax-line’, and
     ‘syntax-column’, for better compatibility with mzscheme.
   • SRFI-34 (http://srfi.schemers.org/srfi-34/srfi-34.html) (Exception
     Handling for Programs), which implements ‘with-exception-handler’,
     ‘guard’, and ‘raise’, is now available, if you ‘(require
     'srfi-34)’.
     Also, SRFI-35 (http://srfi.schemers.org/srfi-35/srfi-35.html)
     (Conditions) is available, if you ‘(require 'srfi-35)’.
   • The ‘case-lambda’ form from SRFI-16
     (http://srfi.schemers.org/srfi-16/srfi-16.html) is now implemented
     more efficiently.

Kawa 1.8 (October 18, 2005)
---------------------------

SRFI-69 “Basic hash tables”
(http://srfi.schemers.org/srfi-69/srfi-69.html) is now available, if you
‘(require 'hash-table)’ or ‘(require 'srfi-69)’.  This is an optimized
and Java-compatible port whose default hash function calls the standard
‘hashCode’ method.

   A ‘define-simple-class’ can now have one (or more) explicit
constructor methods.  These have the spcial name ‘*init*’.  You can call
superclass constructors or sibling constructors (‘this’ constructor
calls) using the (admittedly verbose but powerful) ‘invoke-special’
form.

   The ‘runnable’ function creates a ‘Runnable’ from a ‘Procedure’.  It
is implemented using the new class ‘RunnableClosure’, which is now also
used to implement ‘future’.

   The ‘kawa’ command can now be run “in-place” from the build
directory: ‘$build_dir/bin/kawa’.

   The special field name ‘class’ in ‘(static-name type 'class)’ or
‘(prefix:.class)’ returns the ‘java.lang.Class’ object corresponding to
the ‘type’ or ‘prefix’.  This is similar to the Java syntax.

   Contructing an instance (perhaps using ‘make’) of a class defined
using ‘define-simple-class’ in the current module is much more
efficient, since it no longer uses reflection.  (Optimizing classes
defined using ‘define-class’ is more difficult.)  The constructor
function defined by the ‘define-record-type’ macro is also optimized.

   You can now access instance methods using this short-hand:
‘(*:methodname instance arg ...)’
This is equivalent to: ‘(invoke instance 'methodname arg ...)’

   You can now also access a fields using the same colon-notation as
used for accessing methods, except you write a dot before the field
name:
‘(type:.fieldname)’ ‘ ;; ’is like: ‘(static-field type 'fieldname)’.
‘(*:.fieldname instance)’ ‘;;’ is like: ‘(field 'fieldname instance)’
‘(type:.fieldname instance)’ ‘;;’ is like: ‘(*:.fieldname (as instance
type))’
These all work with ‘set!’ - for example: ‘(set! (*:.fieldname instance)
value)’.

   In the above uses of colon-notation, a ‘type’ can be any one of:
- a namespace prefix bound using ‘define-namespace’ to a namespace uri
of the form ‘"class:classname"’;
- a namespace prefix using ‘define-namespace’ bound to a ‘<classname>’
name, which can be a fully-qualified class name or a locally-declared
class, or an alias (which might be an imported class);
- a fully qualified name of a class (that exists at compile-time), as in
‘(java.lang.Integer:toHexString 123)’; or
- a ‘<classname>’ variable, for example: ‘(<list>:list3 11 12 13)’.

   New fluid variables ‘*print-base*’, ‘*print-radix*’,
‘*print-right-margin*’, and ‘*print-miser-width*’ can control output
formatting.  (These are based on Common Lisp.)

   You can new emit elipsis (‘...’) in the output of a ‘syntax’ template
using the syntax ‘(... ...)’, as in other ‘syntax-case’ implementations.

   The ‘args-fold’ program-argument processor from SRFI-37
(http://srfi.schemers.org/srfi-37/srfi-37.html) is available after you
‘(require 'args-fold)’ or ‘(require 'srfi-37)’.

   The ‘fluid-let’ form now works with lexical bindings, and should be
more compatible with other Scheme implementations.

   ‘(module-export namespace:prefix)’ can be used to export a namespace
prefix.

   Static modules are now implemented more similarly to non-static
modules.  Specifically, the module body is not automatically run by the
class initializer.  To get the old behavior, use the new
‘--module-static-run’ flag.  Alternatively, instead of ‘(module-static
#t)’ use ‘(module-static 'init-run)’.

   Implement SRFI-39 (http://srfi.schemers.org/srfi-39/srfi-39.html)
"Parameter-objects".  These are like anonymous fluid values and use the
same implementation.  ‘current-input-port’, ‘current-output-port’, and
‘current-error-port’ are now parameters.

   Infer types of variables declared with a ‘let’.

   Character comparisons (such as ‘char-=?’, ‘char-ci<?’) implemented
much more efficiently — and (if using Java5) work for characters not in
the Basic Multilingual Plane.

   Major re-write of symbol and namespace handling.  A ‘Symbol’
(api/gnu/mapping/Symbol.html) is now immutable, consisting of a
"print-name" and a pointer to a ‘Namespace’
(api/gnu/mapping/Namespace.html) (package).  An ‘Environment’
(api/gnu/mapping/Environment.html) is a mapping from ‘Symbol’ to
‘Location’ (api/gnu/mapping/Location.html).

   Rename ‘Interpreter’ to ‘Language’ (api/gnu/expr/Language.html) and
‘LispInterpreter’ to ‘LispLanguage’
(api/gnu/kawa/lispexpr/LispLanguage.html).

   Constant-time property list operations.

   Namespace-prefixes are now always resolved at compile-time, never at
run-time.

   ‘(define-namespace PREFIX <CLASS>)’ is loosely the same as
‘(define-namespace PREFIX "class:CLASS")’ but does the right thing for
classes defined in this module, including nested or non-simple classes.

   Macros capture proper scope automatically, not just when using
require.  This allows some internal macros to become private.

   Major re-write of the macro-handling and hygiene framework.  Usable
support for ‘syntax-case’; in fact some of the primitives (such as ‘if’)
are now implemented using ‘syntax-case’.  ‘(syntax form)’ (or the
short-cut ‘#!form)’ evaluates to a syntax object.  ‘(define-syntax (mac
x) tr)’ same as ‘(define-syntax mac (lambda (x) tr))’.  The following
non-hygienic forms are equivalent:

  (define-macro (macro-name (param ...) transformer)
  (define-macro macro-name (lambda (param ...) transformer))
  (defmacro macro-name (PARAM ...) transformer)

   Allow vectors and more general ellipsis-forms in patterns and
templates.

   A new configure switch ‘--with-java-source=version’ allows you to
tweak the Kawa sources to match Java compiler and libraries you’re
using.  The default (and how the sources are distributed) is ‘2’ (for
"Java 2" – jdk 1.2 or better), but you can also select "‘1’" (for jdk
1.1.x), and "‘5’" for Java 5 (jdk 1.5).  You can also specify a jdk
version number: "‘1.4.1’" is equivalent to "2" (for now).  Note the
default source-base is incompatible with Java 5 (or more generally JAXB
1.3 or DOM 3), unless you also ‘--disable-xml’.

   Configure argument ‘--with-servlet’[‘=servlet-api.jar’] replaces
‘--enable-servlet’.

   Function argument in error message are now numbered starting at one.
Type errors now give better error messages.

   A new function calling convention, used for ‘--full-tailcalls’.  A
function call is split up in two parts: A ‘match0’/.../‘matchN’ method
checks that the actual arguments match the expected formal arguments,
and leaves them in the per-thread ‘CallContext’
(api/gnu/mapping/CallContext.html).  Then after the calling function
returns, a zero-argument ‘apply()’ methods evaluates the function body.
This new convention has long-term advantages (performance, full
continuations), but the most immediate benefit is better handling of
generic (otherloaded) functions.  There are also improved error
messages.

   Real numbers, characters, Lisp/Scheme strings (‘FString’
(api/gnu/lists/FString.html)) and symbols all now implement the
‘Comparable’ interface.

   In ‘define-class’/‘define-simple-class’: [Most of this work was
funded by Merced Systems (http://www.mercedsystems.com/).]

   • You can specify ‘access:
     ’[‘'private’|‘'protected’|‘'publi’c|‘'package’] to set the Java
     access permissions of fields and methods.
   • Methods can be static by using the ‘access: 'static’ specifier.
   • The reflective routines ‘invoke’ , ‘field’ , ‘static-field’ ,
     ‘slot-ref’ , ‘slot-set!’ can now access non-public methods/fields
     when appropriate.
   • Such classes are no longer initialized when the containing module
     is loaded.
   • The ‘expr’ in ‘init-form: expr’ is now evaluated in the outer
     scope.
   • A new ‘init: expr’ evalues ‘expr’ in the inner scope.
   • An option name following ‘allocation:’ can now be a string literal
     or a quoted symbol.  The latter is preferred: ‘allocation: 'class’.
   • Added ‘'static’ as a synonym for ‘'class’ following ‘allocation:’.
   • Initialization of static field (‘allocation: 'class init: expr’)
     now works, and is performed at class initialization time.
   • You can use unnamed “dummy fields” to add initialization-time
     actions not tied to a field:

       (define-simple-class Foo ()
         (:init (perform-some-action)))

Kawa 1.7.90 (2003)
------------------

Various fixes and better error messages in number parsing.  Some
optimizations for the divide function.

   New framework for controlling compiler warnings and other features,
supporting command-line flags, and the Scheme forms
‘with-compile-options’ and ‘module-compile-options’.  The flag
‘--warn-undefined-variable’ is useful for catching typos.
Implementation funded by Merced Systems (http://www.mercedsystems.com/).

   New ‘invoke-special’ syntax form (implemented by Chris Dean).

   New ‘define-variable’ form (similar to Common Lisp’s ‘defvar’).

Kawa 1.7 (June 7, 2003)
-----------------------

‘KawaPageServlet’ (api/gnu/kawa/servlet/KawaPageServlet.html) allows
automatic loading and on-the-fly compilation in a servlet engine.  See
http://www.gnu.org/software/qexo/simple-xquery-webapp.html
(../qexo/simple-xquery-webapp.html).

   The default source-base requires various Java 2 features, such as
collection.  However, ‘make-select1’ will comment out Java2
dependencies, allowing you to build Kawa with an older Java
implementation.

   The ‘-f’ flag and the load function can take an absolute URL. New
Scheme functions ‘load-relative’ and ‘base-uri’.

   Imported implementation of cut and cute from SRFI-26
(http://srfi.schemers.org/srfi-26/srfi-26.html) (Notation for
Specializing Parameters without Currying).

   The way top-level definitions (including Scheme procedures) are
mapped into Java fields is changed to use a mostly reversible mapping.
(The mapping to method names remains more natural but non-reversible.)

   ‘define-alias’ of types can now be exported from a module.

   New ‘--no-inline’ and ‘--inline=none’ options.

   You can use ‘define-namespace’ to define “namespace aliases”.  This
is used for the new short-hard syntax for method invocation:
‘(define-namespace Int32 "class:java.lang.Integer")’
‘(Int32:toHexString 255)’ => ‘"ff"’
‘(Int32:toString (Int32:new "00255"))’ => ‘"255"’
Alternatively, you can write:
‘(java.lang.Integer:toHexString 255)’ => ‘"ff"’

   SRFI-9 (http://srfi.schemers.org/srfi-9/srfi-9.html)
(define-record-type) has been implemented, and compiled to a
‘define-class’, with efficient code.

   The configure option ‘--with-collections’ is now the default.

   Unknowns are no longer automatically static.

   If type not specified in a declaration, don’t infer it from it
initial value.  If no return type is specified for a function, default
to ‘Object’, rather than the return type of the body.  (The latter leads
to undesirable different behaviour if definitions are re-arranged.)

   You can now define and use classes defined using ‘object’,
‘define-class’, and ‘define-simple-class’ from the “interpreter”, as
well as the compiler.  Also, a bug where inherited fields did not get
initialized has been fixed.

   There are several new procedures useful for servlets.

   Numerical comparisions (‘<’, ‘<=’, etc) now generates optimized
bytecode if the types of the operands have certain known types.
including efficient code for ‘<int>’, ‘<long>’, ‘<double>’, and
‘<integer>’.  Much more code can now (with type declaration) be written
just as efficiently in Scheme as in Java.

   There have been some internal re-arranging of how Expressions are
processed.  The Scheme-specific Translator type now inherits from
Compilation, which replaces the old Parser class.  A Complation is now
allocated much earlier, as part of parsing, and includes a
SourceMessages object.  SourcesMessages now includes (default) line
number, which is used by Compilation for the "current" line numbers.
The ExpWalker class includes a SourceMessages instance (which it gets
from the Compilation).  CanInline.inline method now takes ExpWalker
parameter.  Checking of the number or parameters, and mapping known
procedures to Java methods are now both done during the inlining pass.

   The user-visible effect is that Kawa can now emit error mesages more
cleanly more places; the inlining pass can be more agressive, and can
emit better error messages, which yields better type information.  This
gives us better code with fewer warnings about unknown methods.

Changes from Kawa 1.6.98 to 1.6.99.
-----------------------------------

A new language front-end handles a tiny subset of XSLT. An example is
the check-format-users test in gnu/xquery/testsuite/Makefile.

   There are now converters between SAX2 and Consumer events, and a
basic implementation of XMLReader based on XMLParser.

   The function as-xml prints a value in XML format.

   Srfi-0 (cond-expand), srfi-8 (receive), and srfi-25
(multi-dimensional arrays) are now implemented.  So is srfi-1 (list
library), though that requires doing (require ’list-lib).

   The JEmacs code is being re-organized, splitting out the
Swing-dependent code into a separate gnu.jemacs.swing package.  This
should make it easier to add JEmacs implementation without Swing.

   The class gnu.expr.Interpreter has various new ’eval’ methods that
are useful for evaluating Scheme/BRL/XQuery/...  expressions from Java.

   Kawa now uses current versions of autoconf, autoamke, and libtool,
allowing the use of automake file inclusion.

   The comparisons ‘<<’, ‘<=’, ‘-’, ‘>’, and ‘=>’ now compile to
optimized Java arithmetic if both operands are ‘<int>’ or a literal that
fits in ‘<int>’.

Changes from Kawa 1.6.97 to 1.6.98
----------------------------------

Generated HTML and Postscrpt documents are no longer included in the
source distribution.  Get ‘kawa-doc-version.tar.gz’ instead.

   (format #t ...)  and (format PORT ...)  now returns #!void instead of
#t.

   Support fluid bindings (fluid-let) for any thread, not just Future
and main.

   A Unix script header ‘#!/PROGRAM’ is ignored.

   You can now take the same Kawa "web" program (written in Scheme,
KRL/BRL, or XQuery) and run it as either a servlet or a CGI script.

   There are a number of new functions for accessing HTTP requests and
generating HTTP responses.

   Kawa now supports a new experimental programming KRL (the "Kawa
Report Language").  You select this language using –krl on the Kawa
command link.  It allows Scheme code to be inside template files, like
HTML pages, using a syntax based on BRL (brl.sourceforge.net).  However,
KRL has soem experimental changes to both BRL and standard Scheme.
There is also a BRL-compatibile mode, selected using –brl, though that
currently only supports a subset of BRL functions.

   If language is not explicitly specified and you’re running a source
file (e.g.  "java kawa.repl myscript.xql"), Kawa tried to derive the
language from the the filename extension (e.g.  "xql").  It still
defaults to Scheme if there is no extension or the extension is
unrecognized.

   New command-line option –output-format alias –format can be used to
over-ride the format used to write out top-level (repl, load) values.

   XMLPrinter can now print in (non-well-formed-XML) HTML.

Changes from Kawa 1.6.96 to 1.6.97
----------------------------------

Changed lots of error messages to use pairs of single quotes rather than
starting with a backquote (accent grave): ’name’ instead of ‘name’.
Many newer fonts make the latter look bad, so it is now discouraged.

   The types ‘<String>’ and ‘<java.lang.String>’ new behave differently.
The type ‘<java.lang.String>’ now works just like (say)
‘<java.util.Hashtable>’.  Converting an object to a ‘<java.lang.String>’
is done by a simple coercion, so the incoming value must be a
java.lang.String reference or null.  The special type ‘<String>’
converts any object to a java.string.String by calling toString; it also
handles null by specially testing for it.

   For convenience (and backwards compatibility) Kawa uses the type
‘<String>’ (rather than ‘<java.lang.String>’) when it sees the Java type
‘java.lang’.String, for example in the argument to an ‘invoke’.

   The default behaviour of ’[’ and ’] was changed back to be token
(word) constituents, matching R5RS and Common Lisp.  However, you can
easily change this behaviour using the new setBrackMode method or the
defaultBracketMode static field in ReadTable.

   You can now build Kawa from source using the Ant build system (from
Apache’s Jakarta project), as an alternative to using the traditional
configure+make system.  An advantage of Ant is that it works on most
Java systems, without requiring a Unix shell and commands.
Specifically, this makes it easy to build Kawa under MS-Windows.  Thanks
to James White for contributing this support.

   Added (current-error-port) which does the obvious.

   The new let-values and let-values* macros from srfi-11 provide a more
convenient way to use multiple values.

   All the abstract apply* and eval* methods now specify ’throws
Throwable’.  A bunch of code was changed to match.  The main visible
advantage is that the throw and primitive-throw procedures work for any
Throwable without requiring it to be (confusingly) wrapped.

Changes from Kawa 1.6.95 to 1.6.96
----------------------------------

A new compilation flag –servlet generates a Servlet which can be
deployed in a servlet engin like Tomcat.  This is experimental, but it
seesm to work for both Scheme source and XQuery source.

   The interface gnu.lists.CharSequence was renamed to avoid conflitcs
with the (similar) interface java.lang.CharSequence in JDK 1.4beta.

   New –help option (contributed by Andreas Schlapbach).

   Changed the code generation used when –full-tailcalls.  It now is
closer to that used by default, in that we don’t generate a class for
each non-inlined procedure.  In both cases calling an unknown procedure
involves executing a switch statement to select a method.  In addition
to generating fewer classes and simplifying one of the more fragile
parts of Kawa, it is also a step towards how full continuations will be
implemented.

   Changed the convention for name "mangling" - i.e.  how Scheme names
are mapped into Java names.  Now, if a Scheme name is a valid Java name
it is used as is; otherwise a reversible mangling using "$" characters
is used.  Thus the Scheme names ‘'<’ and ‘'$Leq’ are both mapped into
the same Java name ‘"$Leq"’.  However, other names not containing "‘$’"
should no longer clash, including pairs like "‘char-letter?’" and
"‘charLetter?’" and "‘isCharLetter’" which used to be all mapped to
"‘isCharLetter’".  Now only names containing "‘$’" can be ambiguous.

   If the compiler can determine that all the operands of (+ ...)  or (-
...)  are floating-point, then it will generate optimized code using
Java primitive arithmetic.

   Guile-style keyword syntax ’#:KEYWORD’ is recognized.  (Note this
conflicts with Common Lisp syntax for uninterned symbols.)

   New syntax forms define-class and define-simple-class allow you to
define classes more easily.  define-class supports true multiple
inheritance and first class class values, where each Scheme class is
compiled to a pair of an inteface and a class.  define-simple-class
generates more efficient and Java-compatible classes.

Changes from Kawa 1.6.94 to 1.6.95.
-----------------------------------

A new language "xquery" implements a (so far small subset of) XQuery,
the draft XML Query languaage.

   Various internal (Java API) changes: Changes to gnu.expr.Interpreter
to make it easier to add non-Lisp-like languages; gnu.lists.Consumer now
has an endAttribute method that need to be called after each attribute,
rather than endAttributes that was called after all of them.

   If configured with –with-gcj, Kawa builds and intalls a ’gckawa’
script to simlify linking with needed libraries.

   The ‘setter’ function is now inlined, and ‘(set! (field X 'N) V)’ and
‘(set! (static-field <T> "N) V)’ are now inlined.

   If configured ‘--with-gcj’, then a ‘gckawa’ helper script is
installed, to make it easier to link Kawa+gcj-compiled applications.

Changes from Kawa 1.6.92 to 1.6.94
----------------------------------

The JEmacs code now depends on CommonLisp, rather than vice versa, which
means Commonlisp no longer depends on Swing, and can be built with GCJ.
CommonLisp and JEmacs symbols are now implemented using Binding, not
String.

Changes from Kawa 1.6.90 to 1.6.92
----------------------------------

Kawa now installs as a .jar file (kawa.jar symlinked to
kawa-VERSION.jar), rather than a collection of .class files.

   The Kawa manual includes instructions for how to build Kawa using
GCJ, and how to compile Scheme code to a native executable using GCJ.

   Kawa now has builtin pretty-printer support, using an algorithm from
Steel Bank Common Lisp converted from Lisp to Java.  The high-level
Common Lisp pretty-printing features are mostly not yet implemented, but
the low-level support is there.  The standard output and error ports
default to pretty-printing.

   A new formatting framework uses the Consumer interface from
gnu.lists.  You can associate a format with an output port.  Common Lisp
and JEmacs finally print using their respective syntaxes.

   All output ports (OutPort instances) are now automatically flushed on
program exit, using a new WriterManager helper class.

   The new commmand-line option –debug-print-expr causes the Expression
for each expression to be printed.  The option –debug-print-final-expr
is similar, but prints Expressions after optimization and just before
compilation.  They are printed using the new pretty-printer.

   Changed calling convention for –full-tailcalls to write results to a
Consumer, usually a TreeList or something to be printed.  A top-level
ModuleBody now uses the same CpsProcedure convention.  This is useful
for generating xml or html.

   New libtool support allows kawa to be built as a shared library.

   The new configure flag –with-gcj uses gcj to compile Kawa to both
.class files and native code.  This is experimental.

Changes from Kawa 1.6.70 to 1.6.90
----------------------------------

The reader (for Scheme and Lisp) has been re-written to be table-driven,
based on the design of Common Lisp readtables.

   The new gnu.lists package has new implementations of sequence-related
classes.  It replaces most of gnu.kawa.util.  See the package.html file.

   If the expected type of a non-unary ‘+’ or ‘-’ is ‘<int>’ or ‘<long>’
and the operands are integeral types, then the operands will converted
to the primitive integer type and the addition or subtraction done using
primitive arithmetic.  Similarly if the expected type is ‘<float>’ or
‘<long>’ and the operands have appropriate type.  This optimization an
make a big performance difference.  (We still need to also optimize
compare operations like ‘(< x y)’ to really benefit from ‘<int>’
declarations of loop variables.)

   The implementation of procedure closures has been changed to
basically be the same as top-level procedures (except when
–full-tailcalls is specified): Each procedure is now an instance of a
ModuleMethod, which each "frame" is an instance of ModuleBody, just like
for top-level functions.  This sometimes reduces the number of classes
generated, but more importantly it simplifies the implementation.

   A new ‘gnu.xml’ (api/gnu/xml/package-summary.html) package contains
XML-related code, currently an XML parser and printer, plus some XPath
support.  The class ‘gnu.lists.TreeList’ (api/gnu/lists/TreeList.html)
(alias ‘<document>’) is useful for compactly representing nested
structures, including XML documents.  If you ‘(require 'xml)’ you will
get Scheme interfaces (‘print-as-xml’ and ‘parse-xml-from-url’) to these
classes.

   New package gnu.kawa.functions, for primitive functions (written in
Java).

   The map and for-each procedure is now inlined.  This is most
especially beneficial when it allows the mapped-over procedure to also
be inlined, such as when that procedure is a lambda expression.

   Added documentation on compiling with Jikes.  Renamed some classes to
avoid warning when compiling with Jikes.

   The reverse!  procedure was added.

   Internal changes: * If a variable reference is unknown, create a
Declaration instance with the IS_UNKNOWN flag to represent an imported
binding.  * The ExpWalker framework for "tree walking" Expressions had a
bit of reorganization.  * New package gnu.kawa.functions, for primitive
functions (written in Java).

   Added a hook for constant-folding and other optimization/inlining at
traversal (ExpWalker) time.  Optimization of + and - procedures to use
primitive Java operations when the operands are primitive types.

   Implementation of SRFI-17.  Change the definitions of (set!  (f x
...)  val) to ((setter f) x ...  val), rather then the old ((setter f)
val x ...).  You can now associate a setter with a procedure, either
using make-procedure or set-procedure-property!.  Also, (setter f) is
now inlined, when possible.

   Internally, Syntax (and hence Macro) no longer extend Declaration.

   Various Java-level changes, which may be reflected in Scheme later: *
gnu.kawa.util.Consumer interface is similar to ObjectOutput and SAX’s
ContentHandler interfaces.  * A gnu.expr.ConsumerTarget is used when
evaluating to an implicit Consumer.  * These interfaces will make it
easy to write functional-style but efficient code for transforming data
streams, including XML. * gnu.kawa.util.FString is now variable-size.

Changes from Kawa 1.6.68 to 1.6.70
----------------------------------

The bare beginnings of Common Lisp support, enabled by the –commonlisp
(or –clisp) command line option.  This is so far little more than a hack
of the EmacsLisp support, but with lexical scoping and CL-style format.

Changes from Kawa 1.6.66 to 1.6.68
----------------------------------

JEmacs news:

   • Define emacs-version as Kawa version but with leading 0 instead of
     1.  For example, the current value is "0.6.68 JEmacs".
   • New testsuite directory.
   • Improved autoload framework.  Handle ELisp autoload comments.
   • Handle escape and meta-key.
   • Handle lot more of ELisp.
   • Lots more is now done in ELisp, using .el files imported from
     XEmacs.
   • Incomplete support for setting mark, including using selection.
   • Basic (but incomplete) implementation of (interactive spec).
   • Common Lisp extensions: typep, default arguments.
   • A new status.html file to note what works and what doesn’t.

   You can now specify in ‘define’ and ‘define-private’ the type of a
variable.  If the variable is module-level, ‘(define name :: <type>
value)’ creates a field named “‘name’” having the specified type and
initial value.  (If type is not specified, the default is not ‘Object’,
but rather a ‘Binding’ that _contains_ the variable’s value.)

   You can now define the type of a module-level variable: In
(define[-private] :: type expression) New (define-constant name [::
type] expression) definition form.

   A procedure can now have arbitrary properties associated with it.
Use procedure-property and set-procedure-property!  to get and set them.

   The new procedure make-procedure creates a generic procedure that may
contain one or more methods, as well as specified properties.

   New declaration form define-base-unit.  Both it and define-unit have
been re-implemented to be module-safe.  Basically ’(define-unit ft
12in)’ is sugar for ’(define-constant ft$unit (...  (* 12 in$unit)))’,
where ft$unit and in$unit are standard identifiers managed by the module
system.  Also, the output syntax for units and quantities is cleaner.

   The new declaration (module-export name ...)  allows control over the
names exported from a module.  The new declaration (module-static ...)
allows control over which definitions are static and which are
non-static.  This makes it easier to use a module as a Java class.

   Procedures names that accidentally clash with inherited method names
(such as "run") are now re-named.

   Simple aliases (define-aliases defining an alias for a variable name)
are implemented more efficiently.

   The package hierarchy is getter cleaner, with fewer cyclic
dependencies: The gnu.math package no longer has any dependencies on
kawa.* or gnu.*.  Two classes were moved from gnu.text to other classes,
avoiding another cyclic package dependency between gnu.text and
gnu.mapping.  The new gnu.kawa.lispexpr is for compile-time handling of
Lisp-like languages.

   Compliation of literals has been re-done.  A class that can be used
in a literal no longer needs to be declared as Compilable.  Instead, you
declare it as implementaing java.io.Externalizable, and make sure it has
appropriate methods.

   All the standard "data" types (i.e.  not procedures or ports) now
implement java.io.Externalizable, and can thus be serialized.  If they
appear in literals, they can also be compiled.

   Created a new class gnu.kawa.util.AbstractString, with the Scheme
alias ‘<abstract-string>’.  The old gnu.kawa.util.FString now extends
AbstractString.  A new class CharBuffer provides an growable buffer,
with markers (automatically-adjusted positions).  Many of the Scheme
‘<string>’ procedures now work on ‘<abstract-string>’.  The JEmacs
BufferContnat class (contains the characters of a buffer) now extends
CharBuffer.

   Some JEmacs changes to support a "mode" concept, as well as
preliminary support for inferior-process and telnet modes.

   New section in manual / web page for projects using Kawa.

   The record feasture (make-record-type etc) how handles "funny" type
and fields names that need to be "mangled" to Java names.

   Re-did implementation of define-alias.  For example, you can define
type-aliases:
‘(define-alias <marker> <gnu.jemacs.buffer.Marker>)’
and then use <marker> instead of <gnu.jemacs.buffer.Marker>.

   ‘(field array 'length)’ now works.

Changes from Kawa 1.6.64 to 1.6.66
----------------------------------

Added documentation to the manual for Homogeneous numeric vector
datatypes (SRFI-4).

   You can now specify characters using their Unicode value: #\u05d0 is
alef.

   Kawa now uses a more mnemonic name mangling Scheme.  For example, a
Scheme function named ‘<=’ would get compiled to method ‘$Ls$Eq’.

   There is now working and useful module support, thought not all
features are implemented.  The basic idea is that a module can be any
class that has a default constructor (or all of whose fields and methods
are static); the public fields and methods of such a class are its
exported definitions.  Compiling a Scheme file produces such a module.
Doing:
‘ (require <classname>)’
will create an anonymous instance of ‘<classname>’ (if needed), and add
all its exported definitions to the current environment.  Note that if
you import a class in a module you are compiling, then an instance of
the module will be created at compile-time, and imported definitions are
not re-imported.  (For now you must compile a module, you cannot just
load it.)

   The define-private keyword creates a module-local definition.

   New syntax to override some properties of the current module:
‘(module-name <name>)’ overrides the default name for a module.
‘(module-extends <class>)’ specifies the super-class.
‘(module-implements <interface> ...)’ specfies the implemented
interfaces.

   The syntax: (require ’keyword) is syntactic sugar for (require
<classname>) where the classname is find is a "module catalog"
(currently hard-wired).  This provides compatibility with Slib.  The
Slib "features" gen-write, pretty-print, pprint-file, and printf are now
available in Kawa; more will be added, depending on time and demand.
See the package directory gnu/kawa/slib for what is available.

Changes from Kawa 1.6.62 to 1.6.64
----------------------------------

A lot of improvements to JEmacs (see JEmacs.SourceForge.net).

   kawa-compiled-VERSION.zip is replaced by kawa-compiled-VERSION.jar.

   You can now use Kawa to generate applets, using the new –applet
switch, Check the "Applet compilation" section in the manual.
Generating an application using the –main flag should work again.
Neither –applet nor –main has Scheme hard-wired any more.

   A new macro ‘(this)’ evaluates to the "this object" - the current
instance of the current class.  The current implementation is
incomplete, and buggy, but it will have to do for now.

   The command-line argument -f FILENAME will load the same files types
as load.

   When a source file is compiled, the top-level definitions
(procedures, variables, and macros) are compiled to final fields on the
resulting class.  This are not automatically entered into the current
environment; instead that is the responsibility of whoever loads the
compiled class.  This is a major step towards a module system for Kawa.

   There is a new form define-private which is like define, except that
the defined name is not exported from the current module.

   A procedure that has optional arguments is now typically compiled
into multiple methods.  If it’s a top-level procedure, these will be
methods in the modules "ModuleBody" class, with the same (mangled) name.
The compiler can in many cases call the appropriate method directly.
Usually, each method takes a fixed number of arguments, which means we
save the overhead of creating an array for the arguments.

   A top-level procedure declared using the form (define (NAME ARS ...)
BODY ..)  is assumed to be "constant" if it isn’t assigned to in the
current compilation unit.  A call in the same compilation unit will now
be implemented as a direct method call.  This is not done if the
prcedure is declared with the form: (define NAME (lambda (ARGS ,,,) BODY
...)

   gnu.expr.Declaration no longer inherits from gnu.bytecode.Variable.

   A gnu.mapping.Environment now resolves hash index collisions using
"double hashing" and "open addressing" instead of "chaining" through
Binding.  This allows a Binding to appear in multiple Environments.

   The classes Sequence, Pair, PairWithPosition, FString, and Char were
moved from kawa.lang to the new package gnu.kawa.util.  It seems that
these classes (except perhaps Char) belong together.  The classes List
and Vector were also moved, and at the same time renamed to LList and
FVector, respectively, to avoid clashed with classes in java.util.

   New data types and procedures for "uniform vectors" of primitive
types were implemented.  These follow the SRFI-4 specification, which
you can find at http://srfi.schemers.org/srfi-4/srfi-4.html .

   You can now use the syntax ‘name :: type’ to specify the type of a
parameter.  For example:
‘(define (vector-length x :: <vector>) (invoke x 'length))’
The following also works:
‘(define (vector-length (x :: <vector>)) ...)’.

   ‘(define-member-alias name object [fname])’ is new syntactic sugar
for ‘(define-alias name (field object fname))’, where the default for
‘fname’ is the mangling of ‘name’.

Changes from Kawa 1.6.60 to 1.6.62
----------------------------------

The new function ‘invoke’ allows you to call a Java method.  All of
‘invoke’, ‘invoke-static’ and ‘make’ now select the bets method.  They
are also inlined at compile time in many cases.  Specifically, if there
is a method known to be definitely applicable, based on compile-time
types of the argument expressions, the compiler will choose the most
specific such method.

   The functions slot-ref, slot-set!, field, and static-field are now
inlined by the compiler when it can.

   Added open-input-string, open-output-string, get-output-string from
SRFI-6.  See http://srfi.schemers.org/srfi-6/srfi-6.html.

   The manual has a new section "Mapping Scheme names to Java names",
and a new chapter "Types".  The chapters "Extensions", "Objects and
Classes", and "Low-level functions" have been extensivley re-organized.

   The Kawa license has been simplified.  There used to be two licenses:
One for the packages gnu.*, and one for the packages kawa.*.  There
latter has been replaced by the former.  The "License" section of the
manual was also improved.

Changes from Kawa 1.6.59 to 1.6.60
----------------------------------

There is a new package gnu.kawa.reflect.  Some classes that used to be
in kawa.lang or kawa.standard are now there.

   The procedures slot-ref and slot-set!  are now available.  They are
equivalent to the existing ‘field’, but reading a field ‘x’ will look
for ‘getX’ method if there is no public ‘x’ field; writing to a field
will look for ‘setX’.

   The procedure ‘make’ makes it convenient to create new objects.

   There is now a teaser screen snapshot of "JEmacs" at
http://www.bothner.com/~per/papers/jemacs.png.

   The html version of the manual now has a primitive index.  The manual
has been slightly re-organized, with a new "Classes and Objects"
chapter.

   The new functions invoke-static and class-methods allow you to call
an arbitary Java method.  They both take a class specification and a
method name.  The result of class-methods is a generic procedure
consisting of those methods whose names match.  (Instance methods are
also matched; they are treated the asme as class methods with an extra
initial argument.)  The invoke-static function also takes extra
arguments, and actually calls the "best"-matching method.  An example:

        (invoke-static <java.lang.Thread> 'sleep 100)

   Many fewer classes are now generated when compiling a Scheme file.
It used to be that each top-level procedure got compiled to its own
class; that is no longer the case.  The change should lead to faster
startup and less resource use, but procedure application will probably
be noticably slower (though not so much slower as when reflection is
used).  The reason for the slowdown is that we in the general case now
do an extra method call, plus a not-yet-optimized switch statement.
This change is part of the new Kawa module system.  That will allow the
compiler to substitute direct methods calls in more cases, which I hope
will more than make up for the slowdown.

   A Scheme procedure is now in general compiled to a Java method whose
name is a "mangling" of the Scheme procedure’s name.  If the procedure
takes a variable number of parameters, then "$V" is added to the name;
this indicates that the last argument is a Java array containing the
rest of the arguments.  Conversely, calling a Java method whose name
ends in "$V" passes any excess arguments in the last argument, which
must be an array type.

   Many changes to the "Emacs-emulation" library in gnu.jemacs.buffer: *
Implemented commands to read and save files.  * We ask for file and
buffer names using a dialog pop-up window.  * Split windows correctly,
so that the windows that are not split keep their sizes, the windows
being split gets split as specified, and the frame does not change size.
Now also handles horizonal splits.  * Fairly good support for
buffer-local keymaps and Emacs-style keymap search order.  A new class
BufferKeymap manages the active keymaps of a buffer.  Multi-key
key-sequences are handled.  Pending prefix keys are remembered on a
per-buffer basis (whereas Emacs does it globally).

   There is now some low-level support for generic procedures.

   The R5RS primitives let-syntax and letrec-syntax for defining local
syntax extensions (macros) should now work.  Also define-syntax works as
an internal definition.  All of these should now be properly "hygienic".
(There is one known exception: symbols listed among the literals lists
are matched as raw symbols, rather that checking that the symbol has the
same binding, if any, as at the defining site.)  The plan is to support
general functions as hygienic rewriters, as in the Chez Scheme
"syntax-case" system; as one part of that plan, the syntax-case
primitive is available, but so far without any of the supporting
machinary to support hygiene.

   The read-line procedure was added.  This allows you to efficiently
read a line from an input port.  The interface is the same as scsh and
Guile.

Changes from Kawa 1.6.58 to 1.6.59
----------------------------------

define-alias now works both top-level and inside a function.

   Optimized eqv?  so if one of the arguments is constant and not Char
or Numeric, inline it the same way eq?  is.  (This helps case when the
labels are symbols, which help the "lattice" benchmark.)  ???

   The Emacs-related packages are now grouped under a new gnu.jemacs
package.

   Improved framework for catching errors.  This means improved error
messages when passing a parameter of the wrong type.  Many standard
procedures have been improved.

   Simplified, documented, and tested (!)  procedure for building Kawa
from source under Windows (95/98/NT).

   New macros trace and untrace for tracing procedures.  After executing
(trace PROCEDURE), debugging output will be written (to the standard
error port) every time PROCEDURE is called, with the parameters and
return value.  Use (untrace PROCEDURE) to turn tracing off.

   New utility functions (system-tmpdir) and (make-temporary-file
[format]).

   A new (unfinished) framework supports multiple languages.  The
command-line option –elisp selects Emacs Lisp, while –scheme (the
default) selects Scheme.  (The only difference so far is the reader
syntax; that will change.)

   The ‘format’ function now provides fairly complete functionality for
CommonLisp-style formatting.  (See the Comon Lisp hyperspec at
http://www.harlequin.com/education/books/HyperSpec/Body/sec_22-3.html.)
The floating point formatters (~F, ~E, ~G, ~$) now pass the formatst.scm
test (from Slib, but with some "fixes"; in the testsuite directory).
Also, output ports now track column numbers, so ‘~T’ and ‘~&’ also work
correctly.

   A new package gnu.emacs provides various building blocks for building
an Emacs-like text editor.  These classes are only compiled when Kawa is
configured with the new –with-swing configuration option.  This is a
large initial step towards "JEmacs" - an Emacs re-implemented to use
Kawa, Java, and Swing, but with full support (using gnu.elisp) for
traditional Emacs Lisp.  For more imformation see
gnu/emacs/overview.html.

   A new configuration option –with-swing can be used if Swing is
available.  It is currently only used in gnu.emacs, but that may change.

Changes from Kawa 1.6.56 to 1.6.58
----------------------------------

Kawa is now "properly tail-recursive" if you invoke it with the
–full-tail-calls flag.  (Exception: the eval procedure does not perform
proper tail calls, in violation of R5RS. This will be fixed in a future
release.)  Code compiled when –full-tail-calls is in effect is also
properly tail-recursive.  Procedures compiled with –full-tail-calls can
call procedures compiled without it, and vice versa (but of course
without doing proper tail calls).  The default is still
–no-full-tail-calls, partly because of performance concerns, partly
because that provides better compatibility with Java conventions and
tools.

   The keywords let (including named let), let*, and letrec support type
specifiers for the declared variables For example:

    (let ((lst :: <list> (foo x))) (reverse lst))

   Square brackets [ ...  ]  are allowed as a synonym of parentheses (
...  ).

Changes from Kawa 1.6.55 to 1.6.57
----------------------------------

A new command-line flag –server PORT specifies that Kawa should run as a
telnet server on the specified PORT, creating a new read-eval-print loop
for each connection.  This allows you to connect using any telnet client
program to a remote "Kawa server".

   A new front-end program, written in C, that provides editing of input
lines, using the GNU readline library.  This is a friendlier interface
than the plain "java kawa.repl".  However, because kawa.c needs readline
and suitable networking library support, it is not built by default, but
only when you configure Kawa with the –enable-kawa-frontend flag.

   The way Scheme names are mapped ("mangled") into Java identifiers is
now more natural.  E.g.  "foo-bar?"  now is mapped to "isFooBar".

   New syntax (object (SUPERS ...)  FIELD-AND-METHODS ...)  for creating
a new object instance of an anonymous class.  Now fairly powerful.

   New procedures field and static-field for more convenient field
access.

   Syntactic sugar: ‘(lambda args <type> body)’ -> ‘(lambda args (as
<type> body))’.  This is especially useful for declaring methods in
classes.

   A new synchonized form allows you to synchronize on an arbitrary Java
object, and execute some forms while having an exclusive lock on the
object.  (The syntax matches that used by Skij.)

Changes from Kawa 1.6.53 to 1.6.55
----------------------------------

New –debug-dump-zip option writes out a .zip file for compilation.
(Useful for debugging Kawa.)

   You can now declare parameter types.

   Lot of work on more efficient procedure representation and calling
convention: Inlining, directly callable statics method, plus some
procedures no longer generate a separate Class.

   Local functions that are only called from one locations, except for
tail-recursion, are now inlined.  This inlines do loops, and most "named
let" loops.

   New representation of closures (closures with captured local
variables).  We no longer use an array for the closure.  Instead we
store the captured variables in the Procedure itself.  This should be
faster (since we can use field accesses rather than array indexing,
which requires bounds checking), and avoids a separate environment
object.

   If the compiler sees a function call whose (non-lexically-bound) name
matches an existing (globally-defined) procedure, and that procedure
instance has a static method named either "apply" or the mangled
procedure name, them the compiler emits a direct call to that method.
This can make a very noticable speed difference, though it may violate
strict Scheme sementics, and some code may break.

   Partial support for first-class "location" variables.

Changes from Kawa 1.6.53 to 1.6.54
----------------------------------

Created new packages gnu.mapping and gnu.expr.  Many classes were moved
from kawa.lang to the new packages.  (This is part of the long-term
process of splitting Kawa into more manageable chunks, separating the
Scheme-specific code from the language-independent code, and moving
classes under the gnu hierarchy.)

   You can now write keywords with the colon first (e.g.  :KEYWORD),
which has exactly the same effect and meaning as putting the colon last
(e.g.  KEYWORD:).  The latter is preferred is being more consistent with
normal English use of punctuation, but the former is allowed for
compatibility with soem other Scheme implementations and Common Lisp.

Changes from Kawa 1.6.52 to 1.6.53
----------------------------------

The new package gnu.text contains facilities for reading, formatting,
and manipulating text.  Some classes in kawa.lang where moved to there.

   Added string-upcase!, string-downcase!, string-capitalize!,
string-upcase, string-downcase, and string-capitalize; compatible with
Slib.

   Character constants can now use octal notation (as in Guile).
Writing a character uses octal format when that seems best.

   A format function, similar to that in Common Lisp (and Slib) has been
added.

   The default parameter of a #!optional or #!key parameter can now be
#!null.

Changes since Kawa 1.6.51
-------------------------

The "record" feature has been changed to that a "record-type descriptor"
is now a gnu.bytecode.ClassType (a ‘<record-type>’), rather than a
java.lang.Class.  Thus make-record-type now returns a ‘<record-typee>’,
not a Class, and ‘record-type-descriptor’ takes a ‘<record-typee>’, not
a Class.

   More robust Eval interfaces.

   New Lexer abstract class.  New ScmRead class (which extends Lexer)
now contains the Scheme reader (moved from Inport).  Now read errors are
kept in queue, and can be recovered from.

   Comparing an exact rational and an inexact real (double) is now done
as if by first converting the double to exact, to satisfy R5RS.

Changes since Kawa 1.6.1
------------------------

The compile virtual method in Expression now takes a Target object,
representing the "destination".  The special ConditionalTarget is used
to evaluate the test of an ’if expression.  This allows us to generate
much better code for and, or, eq?, not and nested if inside an if.

   Added port-line, port-column, and set-port-line!  to match Guile.

   The Makefiles have been written so all out-of-date .java (or .scm).
files in a directory are compiled using a single invocation of javac (or
kawa).  Building Kawa should now be much faster.  (But note that this
depends on unreleased recent autoamke changes.)

   How the Kawa version number is compiled into Kawa was changed to make
it easier for people who want to build from source on non-Unix-like
systems.

   A new gnu.ecmascript package contains an extremely incomplete
implementation of ECMSScript, the ECMA standardized version of
JavaScript.  It includes an ECMAScript lexer (basically complete),
parser (the framework is there but most of the language is missing),
incomplete expression evaluation, and a read-eval-print-loop (for
testing only).

Changes in Kawa 1.6.1
---------------------

Improved Kawa home page with extra links, pointer to Java-generated api
docs, and homepages for gnu.math and gnu.bytecode.

   Implemented system, make-process, and some related procedures.

   Added macros for primitive access to object fields, static fields,
and Java arrays.  Added constant-fold syntax, and used it for the other
macros.

   The –main flag compiles Scheme code to an application (containing a
main method), which can be be invoked directly by a Java interpreter.

   Implemented –version (following GNU standards) as kawa.repl
command-line flag.

Changes since Kawa 1.5.93
-------------------------

Adding make procedure to create new objects/records.

   Extended (set!  (f .  args) value) to be equivalent to ((setter f)
value .  args).  Implemented setter, as well as (setter car) and (setter
cdr).

   Can now get and set a record field value using an application: (rec
’fname) gets the value of the field named fname in record rec.  (set!
(rec ’fname) value) sets the value of the field named fname in rec.

   A partial re-write of the implementation of input ports and the
Scheme reader, to fix some problems, add some features, and improve
performance.

   Compiled .class files are now installed in $(datadir)/java, rather
than $(prefix)/java.  By default, that means they are installed in
/usr/local/shared/java, rather than /usr/local/java.

   There is now internal infrastructure to support inlining of
procedures, and general procedure-specific optimized code generation.

   There is better testing that the right number of arguments are passed
to a procedure, and better error messages when you don’t.  If the
procedure is inlined, you get a compile-time error message.

   The functions created by primitive-constructor,
primitive-virtual-method, primitive-static-method, and
primitive-interface-method are now first-class procedure values.  They
use the Java reflection facily, except when the compiler can directly
inline them (in which case it generates the same efficient bytecodes as
before).

   New functions instance?  (tests type membership) and as (converts).

   The kawa.html is now split into several files, one per chapter.  The
table of contents is now kawa_toc.html.

   The syntactic form try-catch provides low-level exception handler
support.  It is basically the same as Java’s try/catch form, but in
Scheme syntax.  The new procedure primitive-throw throws an exception
object.

   The higher-level catch and throw procedures implement exception
handling where the handler is specified with a "key" (a symbol).  These
functions were taken from Guile.

   The error function has been generalized to take multiple arguments
(as in Guile).  It is now a wrapper around (throw ’misc-error ...).

   There is a new "friendly" GUI access to the Kawa command-line.  If
you invoke kawa.repl with the -w flag, a new interaction window is
created.  This is uses the AWT TextArea class.  You can create multiple
"consoles".  They can either share top-level enevironments, or have
separate environments.  This window interface has some nice features,
including editing.  Added a scheme-window procedure, which is another
way to create a window.

Changes since Kawa 1.5
----------------------

The default prompt now shows continuations lines differently.

   The copy-file function was added.

   The variable port-char-encoding controls how external files are
converted to/from internal Unicode characters.  It also controls whether
CR and CR-LF are converted to LF.

   The reader by default no longer down-cases letters in symbols.  A new
variable symbol-read-case control how case is handled: ’P (the default)
preserves case; ’U upper-cases letters; ’D or -" down-cases letters; and
’I inverts case.

   The gnu.bytecode package now supports exception handlers.  The new
syntactic form try-finally supports a cleanup hook that is run after
some other code finishes (normally or abnormally).  Try-finally is used
to implement dynamic-wind and fluid-let.

   The environment handling has been improved to support thread-specific
environments, a thread-safe fluid-let, and multiple top-levels.  (The
latter still needs a bit of work.)

   The gnu.bytecode package has been extensively changed.  There are new
classes representing the various standard Attributes, and data
associated with an attribute is now stored there.

   Added new procedures environment-bound?  and
scheme-implementation-version.

   Scheme symbols are represented as java.lang.String objects.  Interned
symbols are interned Strings; uninterned symbols are uninterned Strings.
Note that Java strings literals are automatically interned in JDK 1.1.
This change makes symbols slightly more efficient, and moves Kawa closer
to Java.

   Ports now use the JDK 1.1 character-based Reader and Writer classes,
rather than the byte-oriented InputStream and OutputStream classes.
This supports different reading and writing different character
encodings [in theory - there is no support yet for other than Ascii or
binary files].

   An interactive input port now has a prompt function associated with
it.  It is settable with set-input-port-prompter!.  The prompt function
takes one argument (the input port), and returns a prompt string.  There
are also user functions for inquiring about the current line and column
number of an input port.

   The R4RS procedures transcript-on and transcript-off are implemented.

   Standard types can be referred to using syntax similar to RScheme.
For example Scheme strings now have the type ‘<string>’ which is
preferred to "‘kawa.lang.FString’" (which in addition to being longer,
is also more suspectible to changes in internal implementation).  Though
these types are first-class values, this is so far mainly useful for
invoking primitive methods.

Changes from Kawa 1.4 to 1.5
----------------------------

Execute a ~/.kawarc.scm file on startup, if it exists.

   Add a number of functions for testing, renaming, and deleting files.
These are meant to be compatible with scsh, Guile, and MIT Scheme:
file-exists?, file-directory?, file-readable?, file-writable?,
delete-file, rename-file, create-diretory, and the variable
home-directory.

   Fixed some small bugs, mainly in gnu.math and in load.

   Generalize apply to accept an arbitrary Sequence, or a primitive Java
array.

Changes from Kawa 1.2 to 1.4
----------------------------

The codegen package has been renamed gnu.bytecode.  The kawa.math
package has been moved to gnu.math.  Both packages have new license: No
restrictions if you use an unmodified release, but GNU General Public
License.  Let me know if that causes problems.  The rest of Kawa still
has the old license.

   Implement defmacro and gentemp.

   Implement make-record-type and related functions to create and use
new record types.  A record type is implemented as a java.lang.Class
object, and this feature depends on the new reflection features of JDK
1.1.

   Implement keywords, and extend lambda parameter lists to support
#!optional #!rest and #!keyword parameters (following DSSSL).

   Added more primitives to call arbitrary interface and constructor
methods.

Changes from Kawa 1.0 to 1.2
----------------------------

Added primitives to make it easy to call arbitrary Java methods from
Scheme.

   Exact rational arithetic is now fully implemented.  All integer
functions now believed to correctly handle bignums.  Logical operations
on exact integers have been implemented.  These include all the logical
functions from Guile.

   Complex numbers are implemented (except {,a}{sin,cos,tan}).
Quantities (with units) are implemented (as in DSSSL).

   Eval is available, as specified for R5RS. Also implemented are
scheme-report-environment, null-environment, and
interaction-environment.

   Internal define is implemented.

   Rough support for multiple threads is implemented.

   Moved kawa class to kawa/repl.  Merged in kawac (compiler)
functionality.  A ’kawa’ shell-script is now created.  This is now the
preferred interface to both the interactive evaluator and the compiler
(on Unix-like systems).

   Now builds "without a snag" using Cafe 1.51 under Win95.  (Symantec
JIT (ver 2.00b19) requires disabling JIT - ‘JAVA_COMPCMD=disable’.)
Compiles under JDK 1.1 beta (with some warnings).

   A testsuite (and testing framework) was added.

   Documentation moved to doc directory.  There is now an internals
overview, in doc/kawa-tour.ps.

Changes since 0.4
-----------------

The numeric classes have been re-written.  There is partial support for
bignums (infinite-precision integers), but divide (for example) has not
been implemented yet.  The representation of bignums uses 2’s
complement, where the "big digits" are laid out so as to be compatible
with the mpn functions of the GNU Multi-Precision library (gmp).  (The
intent is that a future version of Kawa will support an option to use
gmp native functions for speed.)

   The kawa application takes a number of useful command-line switches.

   Basically all of R4RS has been implemented.  All the essential forms
and functions are implemented.  Almost all of the optional forms are
implemented.  The exceptions are transcript-on, transcript-off, and the
functions for complex numbers, and fractions (exact non-integer
rationals).

   Loading a source file with load now wraps the entire file in a lambda
(named "atFileLevel").  This is for better error reporting, and
consistency with compile-file.

Changes since 0.3
-----------------

The hygienic macros described in the appendix to R4RS are now impemented
(but only the define-syntax form).  They are used to implement the
standard "do" form.

   The R5RS multiple value functions ‘values’ and ‘call-with-values’ are
implemented.

   Macros (and primitive syntax) can now be autoloaded as well as
procedures.

   New kawac application compiles to one or more .class files.

   Compile time errors include line numbers.  Uncaught exceptions cause
a stack trace that includes .scm line numbers.  This makes it more
practical to debug Kawa with a Java debugger.

   Quasiquotation is implemented.

   Various minor bug fixes and optimizations.

Changes since 0.2
-----------------

The biggest single change is that Scheme procedures are now compiled to
Java bytecodes.  This is mainly for efficiency, but it also allows us to
do tail-recursion-elimination in some cases.

   The "codegen" library is included.  This is a toolkit that handles
most of the details needed to generate Java bytecode (.class) files.

   The internal structure of Kawa has been extensively re-written,
especially how syntax transforms, eval, and apply are done, largely due
to the needs for compilation.

   Almost all the R4RS procedures are now implemented, except that there
are still large gaps in Section 6.5 "Numbers".


File: kawa.info,  Node: Features,  Next: Community,  Prev: News,  Up: Top

2 Features
**********

Runs on the Java platform, with no native code needed.

   Extends the Scheme language
(http://en.wikipedia.org/wiki/Scheme_%28programming_language%29),
following the R7RS (http://r7rs.org/) specification from 2013.  Scheme
has many implementations, and is much used in research and teaching.

   Programs run fast
(http://per.bothner.com/blog/2010/Kawa-in-shootout/) - roughly as fast
as Java programs, and much faster than other “scripting languages”.
This is due to a sophisticated compiler, compile-time transformations,
type inference, and optional type declarations.

   Full, convenient, and efficient access to the huge set of Java
libraries means you can access objects, methods, fields, and classes
without run-time overhead.

   Start-up times are fast.  You don’t have to wait for a lot of
initialization.  Even if you start with source code, the parser and
compiler are fast.

   *note Scripts:: are simple Kawa source files that can run as an
application or command.  These are simple to write, start, and run
efficiently, since they’re automatically compiled before execution.

   Alternatively, you can embed Kawa as a *note scripting language for
Java applications: Evaluating Scheme expressions from Java.

   Deployment is easy and flexible.  You just need the Kawa jar file.

   *note Macros:: and *note custom named literals: Named quasi-literals.
make it easy to extend the syntax and implement Domain-Specific
Languages.

   Kawa provides the usual *note read-eval-print loop: REPL Console, as
well as batch modes.

   Kawa has builtin *note pretty-printer: Pretty-printing. support, and
fancy formatting.

   Kawa supports class-definition facilities, and separately-compiled
modules.

   You can *note allocate and initialize objects: Allocating objects.
with a compact “builder” syntax.  It works out-of-the-box (with no
run-time overhead) on many classes and APIs, but can be customized if
need be.

   A library for functional *note composable pictures: Composable
pictures. lets you create “picture” objects, display them, transform
them, combine them, convert to SVG or images, and more.  This can be
“printed” directly in the Kawa console (either the DomTerm console or
the Swing one).

   *note JavaFX programming: Building JavaFX applications. is simpler.

   You can *note run Kawa programs on Android: Building for Android, and
there is special handling to make *note constructing View objects:
Android view construction. easier.

   Flexible shell-like functionality, including *note process
literals::.

   *note Web page scripts: Server-side scripts. are easy to write and
install with *note self-configuring web servers: Self-configuring page
scripts, optionally using *note servlets: Servlets. and *note XML
literals::.

   *note Arrays:: and sequences have a lot of flexibility: Arrays can be
multi-dimensional; you can use an array as an index (which generalizes
slices and permutations); you can define a lazy array using a function
that maps indexes to values; you can re-map the indexes to yield a
transformed array.

   Many useful features for mathematics and numerics:
   • The full “numeric tower” includes infinite-precision rational
     numbers and complex numbers.
   • Compile-time optimization of arithmetic with the use of type
     declarations and inference.
   • A *note “quantity”: Quantities. is a real number with a unit, such
     as ‘3cm’.
   • *note Quaternions:: are a 4-dimensional generalization of complex
     numbers.  Unsigned primitive integer types (‘ubyte’, ‘ushort’,
     ‘uint’, ‘ulong’) are implemented efficiently without object
     allocation.

   A *note lazy value: Lazy evaluation. wraps an expression which is
evaluated only when it is needed.

   Kawa provides a *note framework: Framework. for implementing other
programming languages, and comes with incomplete support for CommonLisp,
Emacs Lisp, and EcmaScript, and XQuery
(http://www.gnu.org/software/qexo/).

* Menu:

* Implemented SRFIs::
* Compatibility::        Compatibility with standards


File: kawa.info,  Node: Implemented SRFIs,  Next: Compatibility,  Up: Features

2.1 Implemented SRFIs
=====================

Kawa implements the following semi-standard SRFIs (Scheme Request for
Implementation (http://srfi.schemers.org/)):
   • SRFI 0 (http://srfi.schemers.org/srfi-0/srfi-0.html): Feature-based
     conditional expansion construct, using ‘cond-expand’ - *note Syntax
     and conditional compilation::.
   • SRFI 1 (http://srfi.schemers.org/srfi-1/srfi-1.html): List Library,
     if ‘(require 'list-lib)’ - *note SRFI-1::.
   • SRFI 2 (http://srfi.schemers.org/srfi-2/srfi-2.html): AND-LET*: an
     AND with local bindings, a guarded LET* special form.
   • SRFI 4 (http://srfi.schemers.org/srfi-4/srfi-4.html): Homogeneous
     numeric vector datatypes - *note Uniform vectors::.
   • SRFI 6 (http://srfi.schemers.org/srfi-6/srfi-6.html): Basic String
     Ports - *note Ports::.
   • SRFI 8 (http://srfi.schemers.org/srfi-8/srfi-8.html): ‘receive’:
     Binding to multiple values - *note Multiple values::.
   • SRFI 9 (http://srfi.schemers.org/srfi-9/srfi-9.html): Defining
     Record Types, using ‘define-record-type’ - *note Record types::.
   • SRFI 10 (http://srfi.schemers.org/srfi-10/srfi-10.html): ‘#,’
     external form for special named types.  This is deprecated for
     various reasons, including that it conflicts with syntax-case
     ‘unsyntax’.  Better to use srfi-108 *note Named quasi-literals::.
   • SRFI 11 (http://srfi.schemers.org/srfi-11/srfi-11.html): Syntax for
     receiving multiple values, using ‘let-values’ and ‘let*-value’ -
     *note Multiple values::.
   • SRFI 13 (http://srfi.schemers.org/srfi-13/srfi-13.html): String
     Library.  Needs some polishing.
   • SRFI 14 (http://srfi.schemers.org/srfi-14/srfi-14.html):
     Character-set Library - *note Character sets::.
   • SRFI 16 (http://srfi.schemers.org/srfi-16/srfi-16.html): Syntax for
     procedures of variable arity, using ‘case-lambda’
     (http://srfi.schemers.org/srfi-16/srfi-16.html).
   • SRFI 17 (http://srfi.schemers.org/srfi-17/srfi-17.html):
     Generalized ‘set!’ - *note Locations::.
   • SRFI 23 (http://srfi.schemers.org/srfi-23/srfi-23.html): Error
     reporting mechanism, using ‘error’ - *note Exceptions::.
   • SRFI 25 (http://srfi.schemers.org/srfi-25/srfi-25.html):
     Multi-dimensional Array Primitives - *note Arrays::.
   • SRFI 26 (http://srfi.schemers.org/srfi-26/srfi-26.html): Notation
     for Specializing Parameters without Currying - *note Procedures::.
   • SRFI 28 (http://srfi.schemers.org/srfi-28/srfi-28.html): Basic
     Format Strings - *note Format::.
   • SRFI 30 (http://srfi.schemers.org/srfi-30/srfi-30.html): Nested
     Multi-line Comments.
   • SRFI 35 (http://srfi.schemers.org/srfi-35/srfi-35.html):
     Conditions.
   • SRFI 37 (http://srfi.schemers.org/srfi-37/srfi-37.html):
     ‘args-fold’ - a program argument processor
     (http://srfi.schemers.org/srfi-37/srfi-37.html), if ‘(require
     'args-fold)’.
   • SRFI 38 (http://srfi.schemers.org/srfi-38/srfi-38.html): External
     Representation for Data With Shared Structure.  The
     ‘read-with-shared-structure’ is missing, but subsumed by ‘read’.
   • SRFI 39 (http://srfi.schemers.org/srfi-39/srfi-39.html): *Note
     Parameter objects::.
   • SRFI 41 (http://srfi.schemers.org/srfi-41/srfi-41.html): Streams -
     *note Streams::.
   • SRFI 45 (http://srfi.schemers.org/srfi-45/srfi-45.html): Primitives
     for Expressing Iterative Lazy Algorithms - *note Lazy evaluation::.
   • SRFI 60 (http://srfi.schemers.org/srfi-60/srfi-60.html): Integers
     as Bits.  - *note Logical Number Operations::.
   • SRFI 62 (http://srfi.schemers.org/srfi-62/srfi-62.html):
     S-expression comments.
   • SRFI 64 (http://srfi.schemers.org/srfi-64/srfi-64.html): A Scheme
     API for test suites.
   • SRFI 69 (http://srfi.schemers.org/srfi-69/srfi-69.html): Basic hash
     tables - *note Hash tables::.
   • SRFI 87 (http://srfi.schemers.org/srfi-87/srfi-87.html): ‘=>’ in
     ‘case’ clauses.
   • SRFI 88 (http://srfi.schemers.org/srfi-88/srfi-88.html): Keyword
     objects - *note Keywords::.
   • SRFI 95 (http://srfi.schemers.org/srfi-95/srfi-95.html): Sorting
     and Merging.
   • SRFI 97 (http://srfi.schemers.org/srfi-97/srfi-97.html): Names for
     SRFI Libraries.
   • SRFI 98 (http://srfi.schemers.org/srfi-98/srfi-98.html): An
     interface to access environment variables
   • SRFI 101 (http://srfi.schemers.org/srfi-101/srfi-101.html): Purely
     Functional Random-Access Pairs and Lists - *note SRFI-101::.
   • SRFI 107 (http://srfi.schemers.org/srfi-107/): XML reader syntax -
     *note XML literals::.
   • SRFI 108 (http://srfi.schemers.org/srfi-108/): Named quasi-literal
     constructors - *note Named quasi-literals::.
   • SRFI-109 (http://srfi.schemers.org/srfi-109/srfi-109.html):
     Extended string quasi-literals - *note string quasi-literals::.
   • SRFI-118 (http://srfi.schemers.org/srfi-118/srfi-118.html): Simple
     adjustable-size strings (‘string-append!’ and ‘string-replace!’).
   • SRFI-140 (http://srfi.schemers.org/srfi-140/srfi-140.html):
     Immutable Strings.
   • SRFI-163 (http://srfi.schemers.org/srfi-163/srfi-163.html):
     Enhanced array literals.
   • SRFI-164 (http://srfi.schemers.org/srfi-164/srfi-164.html):
     Enhanced multi-dimensional Arrays
   • SRFI-197 (http://srfi.schemers.org/srfi-197/srfi-197.html):
     Pipeline Operators.


File: kawa.info,  Node: Compatibility,  Prev: Implemented SRFIs,  Up: Features

2.2 Compatibility with standards
================================

Kawa implements all the required and optional features of R7RS, with the
following exceptions.

   The entire “numeric tower" is implemented.  However, some
transcendental functions only work on reals.  Integral functions do not
necessarily work on inexact (floating-point) integers.  (The whole idea
of “inexact integer" in R5RS seems rather pointless ...)

   Also, ‘call-with-current-continuation’ is only “upwards" (?).  I.e.
once a continuation has been exited, it cannot be invoked.  These
restricted continuations can be used to implement catch/throw (such as
the examples in R4RS), but not co-routines or backtracking.

   Kawa now does general tail-call elimination, but only if you use the
flag ‘--full-tailcalls’.  (Currently, the ‘eval’ function itself is not
fully tail-recursive, in violation of R5RS.) The ‘--full-tailcalls’ flag
is not on by default, partly because it is noticably slower (though I
have not measured how much), and partly I think it is more useful for
Kawa to be compatible with standard Java calling conventions and tools.
Code compiled with ‘--full-tailcalls’ can call code compiled without it
and vice versa.

   Even without ‘--full-tailcalls’, if the compiler can prove that the
procedure being called is the current function, then the tail call will
be replaced by a jump.  This includes must “obvious” cases of calls to
the current function named using ‘define’ or ‘letrec’, and many cases of
mutual tail-recursion (including state-machines using ‘letrec’).

   By default, symbols are case sensitive.

   Kawa implements most of the features of the expression language of
DSSSL, the Scheme-derived ISO-standard Document Style Semantics and
Specification Language for SGML. Of the core expression language, the
only features missing are character properties, ‘external-procedure’,
the time-relationed procedures, and character name escapes in string
literals.  From the full expression language, Kawa additionally is
missing ‘format-number’, ‘format-number-list’, and language objects.
Quantities, keyword values, and the expanded ‘lambda’ form (with
optional and keyword parameters) are supported.


File: kawa.info,  Node: Community,  Next: Installation,  Prev: Features,  Up: Top

3 The Kawa Community
********************

* Menu:

* Reporting bugs::       Where to report bugs
* Mailing lists::        Where to discuss changes, etc
* Acknowledgements::     Acknowledgements and thanks
* Support::              Technical support for Kawa
* Projects::             Projects using Kawa
* Ideas and tasks::      Ideas and tasks for contributing to Kawa


File: kawa.info,  Node: Reporting bugs,  Next: Mailing lists,  Up: Community

3.1 Reporting bugs
==================

To report a bug or a feature request use the Issue Tracker
(https://gitlab.com/kashell/Kawa/issues).  This does require a GitLab
(https://gitlab.com/) account; if this is a problem you can use the
Savannah bug tracker.

Older Savannah bug tracker
..........................

The older bug tracker for Kawa on Savannah is still available, but we
request you use the GitLab Issue Tracker
(https://gitlab.com/kashell/Kawa/issues) for new issues.

   To report a bug or feature request for Kawa (including Qexo or
JEmacs) through Savannah, use the bug-submission page
(http://savannah.gnu.org/bugs/?func=additem&group=kawa).  You can browse
and comment on existing bug reports using the Kawa Bugzilla page
(http://savannah.gnu.org/bugs/?group=kawa).

   When a bug report is created or modified, mail is automatically sent
to the <bug-kawa@gnu.org> list.  You can subscribe, unsubscribe, or
browse the archives through the ‘bug-kawa’ web interface
(http://mail.gnu.org/mailman/listinfo/bug-kawa).


File: kawa.info,  Node: Mailing lists,  Next: Acknowledgements,  Prev: Reporting bugs,  Up: Community

3.2 General Kawa email and discussion
=====================================

The general Kawa email list is <kawa@sourceware.org>.  This mailing list
is used for announcements, questions, patches, and general discussion
relating to Kawa.  If you wish to subscribe, send a blank message
request to <kawa-subscribe@sourceware.org>.  To unsubscribe, send a
blank message to <kawa-unsubscribe@sourceware.org>.  (If your mail is
forwarded and you’re not sure which email address you’re subscribed as,
send mail to the address following ‘mailto:’ in the ‘List-Unsubscribe’
line in the headers of the messages you get from the list.)

   You can browse the archive of past messages
(http://sourceware.org/ml/kawa/).


File: kawa.info,  Node: Acknowledgements,  Next: Support,  Prev: Mailing lists,  Up: Community

3.3 Acknowledgements and thanks
===============================

The author and project leader of Kawa is Per Bothner
(http://per.bothner.com/) <per@bothner.com>.

   Kawa is a re-write of Kawa 0.2, which was a Scheme interpreter
written by R. Alexander Milowski <alex@milowski.com>.

   Thanks to Cygnus Solutions (now part of Red Hat) for sponsoring the
initial development of Kawa, and then transferring their ownership
interest to Per.

Financial support
.................

Ean Schuessler and Brainfood (http://www.brainfood.com/) provided
financial support and encouragement.

   Thanks to Chris Dean, Dean Ferreyra, and others at Merced Systems
(http://www.mercedsystems.com/) for financial support and other
contributions.

   Google (http://google.com/) through their Summer of Code
(http://code.google.com/soc/) project sponsored Charles Turner during
Summer 2011 and 2012, Andrea Bernardini Summer 2014 and 2015, and Tom
Bousso Summer 2017.

   Thomas Kirk and AT&T provided financial support, and useful bug
reports.

Various contributions
.....................

Jakub Jankiewicz (http://jcubic.pl/) contributed the Kawa logo.

   Helmut Eller provided SLIME support, syntaxutils.scm, and many bug
reports.

   Daniel Bonniot for multiple small improvements to gnu.bytecode and
gnu.expr.

   Jamison Hope for multiple contributions, including quaternion
support, the SRFI-14 implementation, Ant improvements, and Google Summer
of Code mentoring.

   Jim White for Ant support and other improvements.

   Bruce R. Lewis implemented *note KRL: KRL. and made other
contributions.

   Geoff Berry: Handle Exceptions attribute.  Other improvements.

   Tom Bousso re-implemented ‘gnu.bytecode’ to make use of ASM
(asm.ow2.org); plus other changes,

   Shad Gregory improved JEmacs.

   Al Petrofsky improved gnu.math printing and added some IntNum
methods.

   Marco Vezzoli: SRFI-1 tailoring for Kawa.

   Albert Ting - old GuiConsole code.

   Christian Surlykke ported JEmacs to use SWT.

   Geoff Berry for various gnu.bytecode improvements.

   Ivelin Ivanov and Tom Reilly for servlet support.

   Anthony Green for Fedora packaging.

   Charles Turner for pretty-printer improvements, improvements in the
Common Lips support, and other changes.

   Andrea Bernardini optimized the implementation of ‘case’, and
implemented full continuation support (in experimental ‘callcc’ branch.

   Julien Rousseau and Marius Kjeldahl contributed to Android support.

   Peter Lane for many documentation improvements.

   William D Clinger for test-cases.

Small fixes and improvements
............................

Patrick Barta; Joseph Bowbeer; Dominique Boucher; Alexander Bunkenburg;
Harold Carr; Emmanuel Castro; Álvaro Castro-Castilla; Sudarshan S
Chawathe; Heather Downs; Francisco Vides Fernández; Nic Ferrier; Oliver
Flasch; Weiqi Gao; Luke Gorrie; Mario Domenech Goulart; Zvi Har’E; Jeff
Haynes; Ethan Herdrick; Joerg-Cyril Hoehle; Elliott Hughes; Mike Kenne;
Brian Jones; Gerardo Jorvilleur; Simon Josefsson (JEmacs menu); Shiro
Kawai; Thomas Kirk; Jay Krell; Timo Myyrä; Edouard Parmelan; Walter C.
Pelissero; Rafael Jesus Alcantara Perez; Lynn Quam; Marcus Otto; Terje
Pedersen (some XQuery functions); Matthias Radestock; Jim Rees; Ola
Rinta-Koski; Andreas Schlapbach; Robert D. Skeels; Benny Tsai; Vladimir
Tsichevski; Matthieu Vachon; Vasantha Ganesh; Phil Walker; Knut
Wannheden; Chris Wegrzyn; Kay Zheng; Michael Zucchi.

Bug reports and test cases
..........................

Seth Alves; Khairul Azhar; Bob Bane; Hans Boehm; Adrián Medraño Calvo;
Brian D. Carlstrom; Luis Casillas; Sudarshan S Chawathe; Ken Dickey
(format tests); Helge Dietert; Allan Erskine; Marc Feeley
(polytype.scm); Margus Freudenthal; Weiqi Gao; Andrea Girotto; Norman
Hard; Gerardo Horvilleur; Yaroslav Kavenchuk; Felix S Klock II; Francois
Leygues; Mirko Luedde; Leonardo Valeri Manera; Kjetil S. Matheussen;
Alex Mitchell; Alex Moiseenko; Marc Nieper-Wißkirchen; Okumura Yuki;
Edouard Parmelan; Walter C. Pelissero; Stephen L. Peters; François
Pinard; Bill Robinson; Dan Stanger (Eaton Vance); Hallvard Traetteberg;
Taylor Venable; Alessandro Vernet; Tony White John Whittaker; Robert
Yokota.

Code ported from other packages
...............................

Kawa includes Free Software originally written for other purposes, but
incorporated into Kawa, perhaps with some porting.  A partial list:

   Dorai Sitaram wrote pregexp.

   The ‘rationalize’ algorithm is by Alan Bawden and Marc Feeley.

   Lars T Hansen wrote SRFI-11 (let-values, let*-values macros).

   Olin Shivers wrote the SRFI-1 list-processing library, and the
SRFI-13 reference impementation.

   John David Stone wrote SRFI-8 (receive macro)

   Jussi Piitulainen wrote the SRFI-25 specification and tests.

   Richard Kelsey and Michael Sperber wrote SRFI-34.

   Anthony Carrico wrote the SRFI-37 reference implementation.

   Panu Kalliokoski wrote the SRFI-69 reference implementation.

   Donovan Kolbly wrote the srfi-64 “meta” testsuite.  Alex Shinn
improved SRFI-64 portability.

   Philip L. Bewig wrote the SRFI-41 (streams) specification and
reference implementation.

   Simon Tatham wrote listsort.

   Aubrey Jaffer wrote much of SLIB, some of which has been imported
into gnu.kawa.slib.  He also wrote some tests we’re using.


File: kawa.info,  Node: Support,  Next: Projects,  Prev: Acknowledgements,  Up: Community

3.4 Technical Support for Kawa
==============================

If you have a project that depends on Kawa or one of its component
packages, you might do well to get paid priority support from Kawa’s
author.

   The base price is $2400 for one year.  This entitles you to basic
support by email or phone.  Per <per@bothner.com> will answer techical
questions about Kawa or its implementation, investigate bug reports, and
suggest work-arounds.  I may (at my discretion) provide fixes and
enhancements (patches) for simple problems.  Response for support
requests received during the day (California time) will normally be
within a few hours.

   All support requests must come through a single designated contact
person.  If Kawa is important to your business, you probably want at
least two contact people, doubling the price.

   If the support contract is cancelled (by either party), remaining
time will be prorated and refunded.

   Per is also available for development projects.


File: kawa.info,  Node: Projects,  Next: Ideas and tasks,  Prev: Support,  Up: Community

3.5 Projects using Kawa
=======================

MIT App Inventor (http://appinventor.mit.edu/) for Android (formerly
Google App Inventor) uses Kawa to translate its visual blocks language.

   The HypeDyn (http://www.narrativeandplay.org/hypedyn/) hypertext
fiction authoring tool is written in Kawa.  HypeDyn (pronounced "hyped
in") is a procedural hypertext fiction authoring tool for people who
want to create text-based interactive stories that adapt to reader
choice.  HypeDyn is free to download and open source, and runs on Linux,
MacOS and Windows.  This is a research project carried out at the
Department of Communications and New Media, National University of
Singapore.

   Nü Echo (http://www.nuecho.com) develops high-performance speech
enabled applications.  Nü Echo uses Kawa for the development of
innovative speech application development tools, like a complete grammar
IDE (http://www.nuecho.com/en/services/grammar.shtml).

   Merced Systems, Inc.  (http://www.mercedsystems.com/) uses Kawa
extensively in their contact center performance management product
Merced Peformance Suite.  Kawa Scheme is used for all development and
has allowed Merced to realize the large productivity gains that come
with using Scheme while still maintaining tight integration with a large
number of Java libraries.

   JEmacs is included in the Kawa distribution.  It is a project to
re-implement Emacs, allowing a mix of Java, Scheme, and Emacs Lisp.  It
has its own home-page (https://jemacs.sourceforge.net/).

   BRL (“the Beautiful Report Language") is a database-oriented language
to embed in HTML and other markup.  BRL (https://brl.sourceforge.net/)
allows you to embed Scheme in an HTML file on a web server.

   The SchemeWay Project (https://schemeway.sourceforge.net) is a set of
Eclipse (http://www.eclipse.org) plug-ins for professional Scheme
programming.  The first plugin released, SchemeScript, is a
fully-featured Scheme editor customizable in Scheme.  It embeds the Kawa
Scheme system and has many features that ease Kawa Scheme programming
(like code completion on variable names, class and method names,
namespaces, etc).

   The Health Media Research Laboratory, part of the Comprehensive
Cancer Center at the University of Michigan, is using Kawa as an
integral part of its core tailoring technologies.  Java programs using
Kawa libraries are used to administer customized web-based surveys,
generate tailored feedback, validate data, and "characterize," or
transform, data.  Kawa code is embedded directly in XML-formatted
surveys and data dictionaries.  Performance and ease of implementation
has far exceeded expectations.  For more information contact Paul R.
Potts, Technical Director, Health Media Research Lab,
‘<potts@umich.edu>’.

   Mike Dillon (‘mdillon@gjt.org’) did the preliminary work of creating
a Kawa plugin for jEdit.  It is called SchemeShell and provides a REPL
inside of the jEdit console for executing expressions in Kawa (much as
the BeanShell plugin does with the BeanShell scripting language).  It is
currently available only via CVS from:
     CVSROOT=:pserver:anonymous@cvs.jedit.sourceforge.net:/cvsroot/jedit
     MODULE=plugins/SchemeShell

   STMicroelectronics (‘marco.vezzoli@st.com’) uses Kawa in a prototypal
intranet 3tier information retrieval system as a communication protocol
between server and clients, and to do server agents programming.


File: kawa.info,  Node: Ideas and tasks,  Prev: Projects,  Up: Community

3.6 Ideas and tasks for contributing to Kawa
============================================

Kawa (like other Free Software projects) has no lack of tasks and
projects to work on.  Here are some ideas.

   The ones marked (GSoC) are probably most suitable for a Google Summer
of Code project, in being a reasonable size, self-contained, and not
depending on other tasks.

3.6.1 Recusively initialized data structures
--------------------------------------------

(GSoC)

   Kawa has convenient syntax to *note allocate and initialize objects:
Allocating objects, but it gets messier it you want to initialize
multiple objects that reference each other.  Likewise for a single
object “tree” which contains links to the root.  In this example, we
will looks at two vectors, but the feature is more useful for tree
structures.  Assume:
     (define-constant list1 [1 2 list2])
     (define-constant list2 ['a 'b list1])
   The compiler translates this to:
     (define-constant list1
        (let ((t (object[] length: 3))) ;; allocate native Java array
           (set! (t 0) 1)
           (set! (t 1) 2)
           (set! (t 2) list2)
           (FVector:makeConstant t)))
     (define-constant list2
        (let ((t (object[] length: 3))) ;; allocate native Java array
           (set! (t 0) 'a)
           (set! (t 1) 'b)
           (set! (t 2) list1)
           (FVector:makeConstant t)))
   The problem is that ‘list2’ has not been created when we evaluate the
initializing expression for ‘list’.

   We can solve the problem by re-writing:
     (define-private tmp1 (object[] length: 3))
     (define-constant list1 (FVector:makeConstant tmp1)
     (define-private tmp2 (object[] length: 3))
     (define-constant list2 (FVector:makeConstant tmp2)
     (set! (tmp1 0) 1)
     (set! (tmp1 1) 2)
     (set! (tmp1 2) list2)
     (set! (tmp2 0) 1)
     (set! (tmp2 1) 2)
     (set! (tmp2 2) list1)

   The complication is that the code for re-writing vector and object
constructors is spread out (depending on the result type), and not where
we deal with initializing the variables.  One solution is to introduce
an inlineable helper function ‘$build$’ defined as:
     (define ($build$ raw-value create init)
       (let ((result (create raw-value))
         (init raw-value result)
         result))
   Then we can re-write the above code to:
     (define-constant list1
       ($build$
         (object[] length: 3)
         (lambda (raw) (FVector:makeConstant raw))
         (lambda (raw result)
           ($init-raw-array$ raw 1 2 list2))))
     (define-constant list2
       ($build$
         (object[] length: 3)
         (lambda (raw) (FVector:makeConstant raw))
         (lambda (raw result)
           ($init-raw-array$ raw 'a 'b list1))))
   Note that the call to ‘$build$’, as well as the generated ‘lambda’
expressions, are all easily inlineable.

   Now assume if at the top-level BODY if there is a sequence of
‘define-constant’ definitions initialized with calls to ‘$build$’.  Now
it is relatively easy to move all the ‘init’ calls after all ‘alloc’ and
‘create’ expressions.  The ‘$init-raw-array$’ calls are expanded after
the code has been re-ordered.

   The project includes both implementing the above framework, as well
as updating type-specific (and default) object creation to use the
framework.  It would also be good to have compiler warnings if accessing
an uninitialized object.

3.6.2 Enhance texinfo-js documentation browser for Kawa documentation
---------------------------------------------------------------------

(GSoC)

3.6.3 Run interactive process in separate Java Virtual Machine:
---------------------------------------------------------------

(GSoC)

   When developing and testing it is useful for the REPL to support
hot-swapping (replacing functions on-the-fly) and debugging.  The main
goal being able to smoothly reload changed modules (files or functions),
and have other modules not break.  Debugging (such as setting
breakpoints) would not be a priority for this project, but could be a
follow-on project.  Skills: Should be experienced with Java, and
interested in learning about JVM TI
(https://docs.oracle.com/javase/8/docs/technotes/guides/jvmti/index.html)
and similar low-level parts of the platform.  Difficulty: Challenging,
but you can study how Java-9’s new jshell
(https://en.wikipedia.org/wiki/Jshell) uses the JVM TI.

3.6.4 Better dynamic reload
---------------------------

(GSoC - this is related to the previous item)

   Kawa does a lot of optimizations and inlining.  This conflicts with
being able to “reload” a module into an already-running interactive
environment.

   We could add an option to load a module in “reloadable” mode.  Kawa
already patches an old function object (a ‘ModuleMethod’) so existing
references to the function get automatically updated.  However, there
are problems if the “signature” of the function changes - for example if
the return type (declared or inferred) becomes more general.  In those
cases the best thing is to re-compile any code that depends on the
modified function.

   Reloading a module that defines a class is even trickier, at least if
there are existing instances that should work as the updated class.  We
can handle the special case where only method bodies change: In
reloadable mode, each method body is compiled to a separate function,
the actual body indirects to the function.  We must also recognize when
compiling a new version of the same class, which requires a textual
comparison between the old and new versions, or a structural comparison
between the old class and the new code.

   When it comes to top-level variables, an issue is when to re-evaluate
the initializing expression.  It is reasonable to do so if and only if
the expression is modified, which again requires a textual comparison.

3.6.5 Easier Access to Native Libraries using JNA/JNR
-----------------------------------------------------

(GSoC)

   The traditional way to access native (C/C++) functions is using JNI,
but it’s very awkward.  JNA and JNR (https://github.com/jnr) are much
easier to use
(http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf).
This project would design and implement an easy-to-use Kawa wrapper for
for JNR. You should study existing JNR wrappers, such as that for JRuby.
Difficulty: Medium.  Need to study existing wrappers and "foreign
function interfaces" (in multiple languages) and design one suitable for
Kawa.  Some Scheme (Kawa) experience would be helpful.

3.6.6 Types for units
---------------------

(GSoC)

   Kawa supports units (such as ‘cm^2’ for square centimeters) and *note
quantities: Quantities. (such as ‘4cm^2’).  We would like to integrate
these into the type system, both for performance and compile-time type
checking.

   For syntax we can use a pseudo-parameterized type ‘quantity’.  For
example:
     (define a1 ::quantity[cm^2] 4cm^2)
     (* 2.0 a1) ;; ⇒ 8cm^2
     (+ 2.0 a1) ;; compile-time error
   The run-time type of the variable ‘a1’ should be a primitive
‘double’, without object allocation.  Of course when ‘a1’ is converted
to an object, we create a ‘Quantity’, not a ‘Double’.  We can build on
Kawa’s existing framework for non-standard primitive types such as
‘character’ and ‘ulong’.  Skills: Need good Java experience, and
somewhat familiar with the Java Virtual Machine.  You will need to
become comfortable reading ‘javap’ output.  Difficulty: Modest.

3.6.7 Compiler should use class-file reading instead of reflection
------------------------------------------------------------------

The Kawa compiler currently uses reflection to determine properties
(such as exported function definitions) from referenced classes.  It
would be better to read class files.  This should not be too difficult,
since the ‘gnu.bytecode’ library abstracts over class information read
by reflection or class reading.

3.6.8 Mutually dependent Java and Scheme modules
------------------------------------------------

(GSoC - maybe)

   We’d like a command for compiling a list of Java and Scheme source
files that may have mutual dependencies.  A good way to do this is to
hook into ‘javac’, which is quite extensible and pluggable.

   One could do something like:
  1. Read the “header" of each Kawa source file, to determine the name
     of the generated main class.
  2. Enter these class names into the javac tables as “uncompleted”
     classes.
  3. Start compiling the Java files.  When this requires the members of
     the Kawa classes, switch to the Kawa files.  From javac, treat
     these as pre-compiled .class files.  I.e.  we treat the Kawa
     compiler as a black box that produces Symbols in the same way as
     reading class files.  At this point we should only need the initial
     “scan” phase on Kawa.
  4. If necessary, finish compiling remaining Kawa files.

   This approach may not immediately provide as robust mixed-language
support as is ideal, but it is more amenable to incremental improvement
than a standalone stub-generator.

   This project is good if you know or want to learn how ‘javac’ works.

3.6.9 Use Java-7 MethodHandles and invokedynamic
------------------------------------------------

Java 7 supports MethodHandles which are meant to provide better
performance (ultimately) for dynamic languages.  See JSR 292
(http://jcp.org/en/jsr/detail?id=292) and the Da Vinci Machine Project
(http://openjdk.java.net/projects/mlvm/).  Kawa makes limited use of
MethodHandles, and no use of invokedynamic.  There is more to be done.
For example, we can start by optimizing arithmetic when the types are
unknown at compile-time.  They could make implementing generic functions
(multimethods) more efficient.  At some point we want to compile lambdas
in the same way as Java 8 does.  This can potentially be more efficient
than Kawa’s current mechanism.

   Remi Forax’s vmboiler (https://github.com/forax/vmboiler) is a small
library on top of ASM that generates optimistically typed bytecodes.  It
could be useful for ideas.

3.6.10 Parameterized types
--------------------------

(GSoC)

   Kawa has some limited support for parameterized types, but it’s not
used much.  Improve type inferencing.  Support definition of
parameterized classes.  Better use of parameterized types for sequence
class.  Support wildcards.  (It might be better to have wild-carding be
associated with declarations, as in Scala or proposed for Java
(http://openjdk.java.net/jeps/300), rather than uses.)  See also
<http://openjdk.java.net/jeps/8043488>.

3.6.11 Optimized function types and values using MethodHandles
--------------------------------------------------------------

(GSoC)

   Kawa doesn’t have true function types: Parameter and result types are
only handled for “known” functions.  The general case with optional and
keyword parameter is complicated, but simple fixed-arity procedure types
would be very useful.

   The following syntax is suggested:
     procedure[(T1 .. TN) TR]
   T1 through T1 are types of the parameters, and TR is the type of the
result.  For example: ‘procedure[(vector int) string]’.  We call this a
typed-procedure type (in contrast to plain ‘procedure’).

   If a value has a typed-procedure type then its run-time
representation is a just a ‘MethodHandle’.  If such a procedure is
called, the generated bytecode is to just call its ‘invokeExact’ method.
The argument expressions are converted (and type-checked) the same way
as if we were calling a statically-known procedure.

   Note that passing an ‘int’ argument of to ‘procedure[(vector int)
string]’ value does _not_ require allocating an object to “box” the
‘int’; we can pass a plain ‘int’ as-is.  Thus using typed-procedure
types can lead to major speed-up.  For example the ‘lib-test.scm’ should
become much faster.

   Converting a known procedure to a typed-procedure type is usually
just a matter of creating a ‘MethodHandle’ that references the method
implementing the procedure.  Some glue code may be needed if the types
aren’t identical, or if the procedure is a closure.

   Converting a type-procedure value ‘p’ to generic value (such as
untyped ‘procedure’ or ‘object’) can be though of as wrapping it in a
‘lambda’:
     ((lambda (arg1::vector arg2::int)::string (p arg1 arg2))

   Coercing a generic value or an untyped procedure to a typed-procedure
would need to generate a method whose signature matches the
typed-procedure type, and in the body of the method use a generic apply.

   Coercing from one typed-procedure type to a different typed-procedure
type is a combination of the above techniques (as if converting first to
object and then to the target type), though some optimizations are worth
doing.

   Adding varargs support can be done later.

   We need a fall-back mechanism for platforms (such as Android) that
don’t support ‘MethodHandle’s.  The easiest is to just treat a
typed-procedure type as plain ‘procedure’ at run-time, though we still
want the compile-time type-checking,

3.6.12 Full continuations
-------------------------

_Currently being worked on._

   Add support for full continuations, which is the major feature
missing for Kawa to qualify as a “true Scheme”.  One way to implement
continuations is to add a add that converts the abstract syntax tree to
continuation-passing-style, and then expand the existing full-tail-call
support to manage a stack.  There are other ways to solve the problem.
This may benefit from *note Faster tailcalls: task-faster-tailcalls.

3.6.13 Faster tailcalls
-----------------------

Make ‘--full-tailcalls’ run faster.  This may depend on (or incorporate)
*note TreeList-optimization: task-TreeList-optimization.

3.6.14 TreeList-optimization
----------------------------

The TreeList
(http://www.gnu.org/software/kawa/api/gnu/lists/TreeList.html) class is
a data structure for “flattened” trees.  It is used for XML-style nodes,
for multiple values, and for the full-tail-call API. The basic concept
is fine, but it could do with some re-thinking to make make
random-access indexing fast.  Also, support for updating is
insufficient.  (This needs someone into designing and hacking on
low-level data-structures, along with lots of profiling and testing.)

3.6.15 Asynchronous evaluation
------------------------------

C# has ‘async’ and ‘await’ keywords for asynchronous programming
(https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
Kawa’s recently improved support for lazy programming seems like a good
framework for equivalent functionality: Instead of an ‘async’ method
that returns a ‘Task<T>’, the Kawa programmer would write a function
that returns a ‘lazy[T]’.  This involves some design work, and modifying
the compiler to rewrite the function body as needed.

   This is related to full continuations, as the re-writing is similar.

3.6.16 REPL console and other REPL improvement
----------------------------------------------

_Currently being worked on._

   Improvements to the read-eval-print console.  In addition to a
traditional Swing console, it would be useful to support using a web
browser as a remote terminal, possibly using web-sockets.  (This allows
“printing” HTML-expressions, which can be a useful way to learn and
experiment with web technologies.)  See here
(http://per.bothner.com/blog/2007/ReplPane/) for an article on the
existing Swing REPL, along with some to-do items.  Being able to hide
and show different parts of the output might be nice.  Being able to
link from error messages to source might be nice.  Better handling of
redefinitions is discussed here in the context of JavaXF Script
(http://per.bothner.com/blog/2009/REPL-for-JavaFX/); this is a general
REPL issue, mostly independent of the GUI for it.

   An interesting possibility is to use the IPython
(http://ipython.org/) framework.  There are existing ports for Scala:
either IScala (https://github.com/mattpap/IScala) or Scala Notebook
(https://github.com/Bridgewater/scala-notebook).

3.6.17 XQuery-3.0 functionality
-------------------------------

(GSoC, for some subset)

   It would be nice to update the XQuery (Qexo) support to some subset
of XQuery 3.0 (http://www.w3.org/TR/xquery-30/).

3.6.18 XQuery-updates
---------------------

It would be nice to support XQuery updates
(http://www.w3.org/TR/xquery-update-10/).  This depends on *note
TreeList-optimization: task-TreeList-optimization.

3.6.19 Common Lisp support
--------------------------

Kawa supports a small subset of the Common Lisp language, but it
supports a much larger subset of core Common Lisp concepts and data
structures, some designed with Common Lisp functionality in mind.
Examples include packages, arrays, expanded function declarations, type
specifications, and format.  A lot could be done to improve the Common
Lisp support with modest effort.  Some Common Lisp features could also
be useful for Scheme: Documentation strings (or markup) as Java
annotations, better MOP-like introspection, and generic methods a la
defmethod (i.e.  with multiple definition statements, possibly in
separate files, as opposed to the current make-procedure) all come to
mind.  Being able to run some existing Common Lisp code bases with at
most modest changes should be the goal.  One such package to start with
might be an existing test framework
(http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html),
perhaps FivaAM (http://common-lisp.net/project/bese/FiveAM.html).  Full
Common Lisp compatibility is nice, but let’s walk before we can run.

3.6.20 JEmacs improvements
--------------------------

(GSoC, for some subset)

   A lot of work is needed to make JEmacs
(http://jemacs.sourceforge.net/) useful.  One could try to import a
useful package and see what works and what fails.  Or one may look at
basic editing primitives.  Enhancements may be needed to core Emacs Lisp
language primitives (enhancing *note Common Lisp support:
task-common-lisp. may help), or to the display engine.

   Emacs now supports lexical bindings
(http://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html)
- we should do the same.

3.6.21 Improved IDE integration
-------------------------------

There is some Kawa support for Eclipse (Schemeway), and possibly other
IDEs (NetBeans, IntelliJ). But many improvements are desirable.  *note
REPL improvements: task-REPL-improvements. may be a component of this.

3.6.21.1 Plugin for NetBeans IDE
................................

Kawa-Scheme support for the NetBeans IDE would be useful.  One could
perhaps build on the Clojure plugin.

3.6.21.2 Plugin for Eclipse IDE
...............................

Kawa-Scheme support for the Eclipse IDE would be useful.  Probably makes
sense to enhance SchemeWay (http://sourceforge.net/projects/schemeway/).
It may also make sense to build on the Dynamic Languages Toolkit
(http://www.eclipse.org/dltk/), possibly making use of Schemeide
(http://schemeide.sourceforge.net/), though DLTk seems more oriented
towards interpreted non-JVM-based languages.

3.6.21.3 Improve Emacs integration
..................................

SLIME (http://en.wikipedia.org/wiki/SLIME) is an Emacs mode that
provides IDE-like functionality.  It supports Kawa.

   JDEE (http://jdee.sourceforge.net/) is a Java development
environment, so might have better hooks to the JVM and Java debugging
architecture.

   CEDET (http://cedet.sourceforge.net/) is a more general framework of
development tools.

3.6.22 Hop-style web programming
--------------------------------

Hop (http://hop.inria.fr/) is an interesting design for integrating
server-side and client-side programming using a Scheme dialect.  These
ideas seem like they would port quite well to Kawa.

3.6.23 String localization
--------------------------

(GSoC)

   Support localization by extending the SRFI_109
(http://srfi.schemers.org/srfi-109/srfi-109.html) syntax, in the manner
of (and compatible with) GNU gettext
(http://www.gnu.org/software/gettext/).  I.e.  optionally specify a
localization key (to use as an index in the translation database); if
there is no key specified, default to using the literal parts of the
string.

3.6.24 Data binding
-------------------

Implement a “bind” mechanism similar to that of JavaFX Script
(http://docs.oracle.com/javafx/1.3/tutorials/core/dataBinding/).  The
idea is that when you initialize a variable or field, instead of
initializing it to a fixed value, you bind it to an expression depending
on other variables.  We install “listeners” on those variables, so when
those variables change, we update the bound variable.  This feature is
useful in many applications, but the initial focus could be GUI
programming and perhaps web programming.

3.6.25 Decimal arithmetic and repeated decimals
-----------------------------------------------

(GSoC. Possibly a bit light for a full Summer project, but can be
extended or combined with other projects.)

   Exact decimal arithmetic is a variation of exact rational arithmetic,
but may be more user-friendly.  In particular, printing using decimals
is generally nicer than fractions.  It is also sometimes useful to
specify an explicit scale, so we can distinguish 0.2 from 0.20.  We can
use the Java ‘BigDecimal’ class, but run into problems with division -
for example ‘(/ 1.0 3.0)’.  We should implement a subclass of ‘RatNum’
that generalizes ‘BigDecimal’ to also handle repeating decimals.  We
need a lexical syntax for repeating decimals.  Possible ideas: ‘0._81_’
or ‘0.#81’.  If a Scheme number literal is specified as exact and has
either a decimal point or an exponent (for example ‘#e1.25’), then it
should read as an exact decimal, not a fraction.

3.6.26 Optional strict typing along with an explicit ‘dynamic’ type
-------------------------------------------------------------------

(GSoC)

   Kawa currently implements “optimistic” typing: The compiler only
complains if an expression has no values in common with the target type
- for example, if assigning a ‘string’ expression to an ‘integer’
variable.  It would be interesting to experiment with a
‘--strict-typing’ option (which would never be the default): Strict
typing would only allow “widening” conversions - i.e.  that the
expression type be a subtype of the target type.  For example it would
complain if assigning a ‘number’ to an ‘integer’ unless you used an
explicit cast.

   To make this easier to work with we’d make use of the *note ‘dynamic’
type: dynamic-type, similar to what ‘C#’ does
(https://msdn.microsoft.com/en-us/library/dd264736.aspx): Any expression
can be converted to or from ‘dynamic’ without the compiler complaining.
Similarly, if ‘x’ is ‘dynamic’ then ‘x:name’ is allowed by the compiler
regardless of ‘name’, with all checking being deferred to run-time.  If
a variable is declared without a type, it should default to ‘dynamic’.
The ‘dynamic’ type is represented in the VM as ‘object’ but with an
annotation (like we do with ‘character’).

   The type-checker might need some changes to better distinguish
implicit conversions from explicit casts.


File: kawa.info,  Node: Installation,  Next: Tutorial,  Prev: Community,  Up: Top

4 Getting and installing Kawa
*****************************

* Menu:

* Getting Kawa::
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution


File: kawa.info,  Node: Getting Kawa,  Next: Running Java,  Up: Installation

4.1 Getting Kawa
================

You can compile Kawa from the source distribution.  Alternatively, you
can install the pre-compiled binary distribution.

   You can get Kawa sources and binaries from the Kawa ftp site
<ftp://ftp.gnu.org/pub/gnu/kawa/>, or from a mirror site
(http://www.gnu.org/order/ftp.html).

   The current release of the Kawa source code is
<ftp://ftp.gnu.org/pub/gnu/kawa/kawa-3.1.1.tar.gz>.  (To unpack
‘.tar.gz’ files Windows users can use 7-Zip (http://www.7-zip.org/),
which is Free Software.)

   The corresponding pre-compiled release is
<ftp://ftp.gnu.org/pub/gnu/kawa/kawa-3.1.1.zip>.  The most recent
snapshot is <ftp://ftp.gnu.org/pub/gnu/kawa/kawa-latest.zip>.
Instructions for using either are *note here: Binary distribution.

4.1.1 Getting the development sources using Git
-----------------------------------------------

The Kawa sources are managed using a git
(https://gitlab.com/kashell/Kawa) repository.  If you want the very
latest version grab a git client (https://git-scm.com/downloads), and
then check out the source using this command:
     git clone https://gitlab.com/kashell/Kawa.git

   After a checkout you will need to run:
     ./autogen.sh
   before proceding with instructions for *note building the source
distribution: Source distribution.

   Once you have it checked out, you can keep it up-to-date with ‘git
pull’.

   You can also browse the git archive
(https://gitlab.com/kashell/Kawa/tree/master) online.


File: kawa.info,  Node: Running Java,  Next: Binary distribution,  Prev: Getting Kawa,  Up: Installation

4.2 Getting and running Java
============================

Before installing Kawa, you will need a working Java system.  The
released Kawa jar file assumes Java 8 or newer.  You need to build Kawa
from source if you have Java 5, Java 6, or are targeting Android.
(Older versions of Kawa have been reported to work with JDK from 1.1,
Kaffe, Symantec Cafe, J++, and GCJ, but these are no longer supported.)

   The discussion below assumes you are using the Java Developer’s Kit
(JDK) from Oracle.  You can download free copies of JDK 8
(http://www.oracle.com/technetwork/java/javase/downloads/index.html) for
various platforms.

   The program ‘java’ is the Java interpreter.  The program ‘javac’ is
the Java compiler, and is needed if you want to compile the source
release yourself.  Both programs must be in your ‘PATH’.  If you have
the JDK in directory ‘$JAVA_HOME’, and you are using a Bourne-shell
compatible shell (/bin/sh, ksh, bash, and some others) you can set
‘PATH’ thus:
     PATH=$JAVA_HOME/bin:$PATH
     export PATH


File: kawa.info,  Node: Binary distribution,  Next: Source distribution,  Prev: Running Java,  Up: Installation

4.3 Installing and using the binary distribution
================================================

The binary release comes as a ‘.zip’ archive that includes Kawa itself
(as a ‘.jar’ file ‘kawa-VERSION.jar’), some third-party helper
libraries, ‘kawa’ command scripts (for GNU/Linux/Unix/MacOS or Windows),
and documentation (basically this manual).

   After downloading (see *note Getting Kawa::), extract the files from
the ‘.zip’ archive using a suitable ‘unzip’ program, which will create a
directory ‘kawa-VERSION’, with ‘lib’, ‘bin’, and ‘doc’ sub-directories.
In the following, we assume the environment variable ‘KAWA_HOME’ refers
to this directory:
     unzip ~/Downloads/kawa-VERSION.zip
     export KAWA_HOME=`pwd`/kawa-VERSION

   The binary release requires Java 8 or later.  If you have an older
Java implementation, or build for a mobile environment like Android,
then you will need to get the source distribution.

   If you want to use Kawa as part of some other application, you just
need the ‘$KAWA_HOME/lib/kawa.jar’.

Running the ‘kawa’ command
..........................

To run a Kawa script file or the Kawa read-eval-print-loop run the Kawa
application.  There are various way to do so.

   The recommended way is to execute the ‘$KAWA_HOME/bin/kawa’ Bash
shell script.  This should work on most Unix-like platforms that have
Bash installed, including GNU/Linux, BSD, MacOS, and Cygwin/MingW.
(Please report if you have problems.)

   The script assumes that either a suitable ‘java’ program is in your
‘PATH’; or the ‘JAVA’ environment variable names a suitable ‘java’
executable; or that ‘JAVA_HOME’ is set so ‘$JAVA_HOME/bin/java’ is
suitable.

   If you want to put ‘kawa’ in your search path you can of course do:
     PATH=$KAWA_HOME/bin:$PATH
   Alternatively you can create a symbolic link in an already-searched
directory.  For example:
     cd /usr/local/bin
     ln -s $KAWA_HOME/bin/kawa kawa

   The ‘bin/kawa.bat’ script works on Windows.

   Both scripts add some helper libraries, including support for input
editing.

   It is also possible to run Kawa using ‘java’ directly:
     java -jar $KAWA_HOME/lib/kawa.jar
   or:
     CLASSPATH=$KAWA_HOME/lib/kawa.jar
     export CLASSPATH
     java kawa.repl
   On Windows:
     set classpath=%KAWA_HOME%\lib\kawa.jar

   To run Kawa in a fresh window use the -w flag:
     kawa -w
   or
     java kawa.repl -w

Reading the documentation
.........................

The file ‘doc/kawa-manual.epub’ contains the Kawa documention packaged
as an electronic book, which is readable by most e-book readers.
Plugins are also available for common browsers, for example EPUBReader
(http://www.epubread.com) for ‘firefox’.

   Even easier is to invoke *note ‘bin/kawa --browse-manual’:
browse-manual-option. (or on Windows: ‘bin\kawa.bat --browse-manual’).

   An ‘epub’ is essentially a zip archive, which you can unzip:
     cd $KAWA_HOME/doc
     unzip kawa-manual.epub
   Then you can use a plain browser with the URL
‘file:$KAWA_HOME/doc/OEBPS/index.html’.


File: kawa.info,  Node: Source distribution,  Prev: Binary distribution,  Up: Installation

4.4 Installing and using the source distribution
================================================

The Kawa release normally comes as a gzip-compressed tar file named
‘kawa-3.1.1.tar.gz’.  Two methods are supporting for compiling the Kawa
sources; choose whichever is most convenient for you.

   One method uses the traditional GNU ‘configure’ script, followed by
running ‘make’.  This works well on Unix-like systems, such as
GNU/Linux.  You can also use this method on Microsoft Windows, with the
help of tools from MinGW (http://www.MinGW.org/) or Cygwin
(http://www.cygwin.org/).

   The other method uses the ‘ant’ command, a Java-based build system
released by Apache’s Jakarta project.  This uses an ‘build.xml’ file in
place of ‘Makefile’s, and works on non-Unix systems such as Microsoft
Windows.  However, the ‘ant’ method does not support all the features of
the ‘configure’+‘make’ method.

4.4.1 Build Kawa using ‘configure’ and ‘make’
---------------------------------------------

(See *note below: building-on-Windows-with-make. for some notes for
building on Microsoft Windows.)

   If you have a ‘tar.gz’ file, first unpack that in your build
directory:
     tar xzf kawa-3.1.1.tar.gz
     cd kawa-3.1.1

   If you’re building from the Git repository, you need to generate
‘configure’ and some other files.  This is easiest done with the
‘autogen.sh’ script:
     ./autogen.sh

   Then you must configure the sources.  This you do in the same way you
configure most other GNU software.  Normally you can just run the
configure script with no arguments:

     ./configure
   The ‘configure’ script takes a number of *note options: configure
options.

   If you have installed Kawa before, make sure your ‘CLASSPATH’ does
not include old versions of Kawa, or other classes that may conflict
with the new ones.

   Then you need to compile all the .java source files.  Just run make:
     make
   This assumes that ‘java’ and ‘javac’ are the java interpreter and
compiler, respectively.

   It has been reported that parallel make doesn’t work, so don’t use
the ‘-j2’ or above options.

   You can now test the system by running Kawa in place:
     java kawa.repl

   or you can run the test suite:
     make check

   or you can install the compiled files:
     make install

   This will install your classes into ‘$PREFIX/share/java’ (and its
sub-directories).  Here ‘$PREFIX’ is the directory you specified to
configure with the ‘--prefix’ option, or ‘/usr/local’ if you did not
specify a ‘--prefix’ option.

   To use the installed files, you need to set ‘CLASSPATH’ so that
‘$PREFIX/share/java/kawa.jar’ is in the path:
     CLASSPATH=$PREFIX/share/java/kawa.jar
     export CLASSPATH
   This is done automatically if you use the ‘kawa’ script.

4.4.1.1 Configure options
.........................

The ‘configure’ script takes a number of options.  The ‘--help’ switch
gives you a list of options.  The following are some of the more common
or important ones.

‘--prefix=INSTALL-DIR’
‘--prefix INSTALL-DIR’
     By default ‘make install’ will install the compiled ‘.jar’ files
     info ‘/usr/local/share/java’, the ‘kawa’ command into
     ‘/usr/local/bin’, and so on in ‘/usr/local’.  The ‘--prefix’ option
     causes the files to be installed under ‘INSTALL-DIR’ instead of
     ‘/usr/local’.  For example to install the ‘.jar’ in
     ‘/opt/kawa/share/java’ and otherwise use ‘/opt/kawa’ do:
          ./configure --prefix=/opt/kawa

‘--with-java-source=VERSION’
     As distributed, the Kawa source code requires Java 8.  If you only
     have Java 7, Java 6, or Java 5, use the ‘--with-java-source’
     option:
          ./configure --with-java-source=6

     Kawa no longer supports older verisons of Java (JDK 1.4 or older).
     It might be possible to use a tool like Retroweaver
     (http://retroweaver.sourceforge.net/) on the Kawa ‘.jar’ to fix up
     Java 5 dependencies.  Contact the Kawa author if you want to be a
     tester for this.

‘--with-docbook-stylesheets[=PATH]’
     Build the documentation (this manual) as an electronic book (in
     ebook format) or a website, using the DocBook xslt stylesheets.
     (You can build the documentation without DocBook, but using it
     enables nicer-looking and more functional documentation.)

     The stylesheets are found using PATH; the file
     ‘PATH/epub3/chunk.xsl’ needs to exist.  (For example, on Fedora 25
     PATH can be ‘/usr/share/sgml/docbook/xsl-ns-stylesheets’, while on
     Debian use ‘/usr/share/xml/docbook/stylesheet/docbook-xsl-ns’.)

‘--with-domterm’
‘--with-domterm=DOMTERM_HOME’
     Compile with extra support for the *note DomTerm: Using DomTerm.
     terminal emulator library, where ‘DOMTERM_HOME’ is such that
     ‘DOMTERM_HOME/lib/domterm.jar’ exists.  (Some DomTerm support is
     built-in regardless.)

     If you use this option along with ‘--with-javafx’ then creating a
     new *note REPL: REPL Console. window will create a DomTerm window.

     As an optional convenience, you can use the ‘domterm.jar’ in the
     Kawa binary distribution.

‘--with-jline3’
‘--with-jline3=JLINE3.JAR’
     Build support for using JLine 3 (https://github.com/jline/jline3),
     which is a library for handling console input, similar to GNU
     readline.  If specified, the JLINE3.JAR is added to the classpath
     of the generated ‘kawa.sh’ or ‘kawa’ shell program.

     An advantage of ‘--with-jline3’ (compared to
     ‘--enable-kawa-frontend’) is that the former works without native
     code (on most Unix-like platforms), and it does not require a C
     wrapper program.

     As an optional convenience, you can use the ‘jline.jar’ in the Kawa
     binary distribution.

‘--with-domterm’
‘--with-domterm=DOMTERM.JAR’
     Compile with extra support for the *note DomTerm: Using DomTerm.
     terminal emulator library.  (Some DomTerm support is built-in
     regardless.)

     If you use this option along with ‘--with-javafx’ then creating a
     new *note REPL: REPL Console. window will create a DomTerm window.

     As an optional convenience, you can use the ‘domterm.jar’ in the
     Kawa binary distribution.

‘--with-servlet’
‘--with-servlet=SERVLET-JAR’
     Build support for *note servlets: Servlets, which are used in web
     servers.  This requires the ‘servlet-api.jar’ (available various
     places including Tomcat (http://tomcat.apache.org/) or Glassfish
     (https://glassfish.java.net/)), for ‘javax.servlet.Servlet’ and
     related classes.  If this class isn’t in your classpath, specify
     its location as ‘SERVLET-JAR’.  For example:
          ./configure --with-servlet=/path/to/servlet-api.jar

‘--enable-jemacs’
     Build JEmacs (enable Emacs-like text editor) and support (a subset
     of) the Emacs Lisp language.  JEmacs is a proof of concept - not
     really usable or maintained.

‘--with-javafx’
‘--with-javafx=JAVAFX-HOME’
     Set this flag to enable the convenience features for *note JavaFX:
     Building JavaFX applications.  The JavaFX classes are included in
     JDK 8 (but not OpenJDK 8), and you don’t need to specify
     ‘JAVAFX-HOME’.  JDK 11 or later does not include JavaFX, so you
     need to specify the location of the modular OpenJFX SDK as
     ‘JAVAFX-HOME’.

‘--with-android=ANDROID-JAR’
     Build for the Android platform.  This requires *note special
     instructons: Building for Android.

‘--enable-kawa-frontend’
     If you have the GNU ‘readline’ library installed, you might try
     adding the ‘--enable-kawa-frontend’ flag.  This will build the
     ‘kawa’ front-end program, which provides input-line editing and an
     input history.  You can get ‘readline’ from archives of GNU
     programs, including <ftp://www.gnu.org/>.

     Note that using JLine, enabled by ‘--with-jline3’, is now
     recommended instead of using the ‘readline’ frontend.

     You may need to specify to ‘make’ where to find the ‘readline’
     include files (with ‘READLINE_INCLUDE_PATH’) and the library (with
     ‘READINE_LIB_PATH’).  For example on OS/X you need to do:
          make READLINE_INCLUDE_PATH=-I/usr/local/unix/readline/include \
               READLINE_LIB_PATH=-L/usr/local/unix/readline/lib

4.4.1.2 Building on Windows using MinGW
.......................................

The Kawa ‘configure’ and ‘make’ process assumes Unix-like tools, which
you can get from the MinGW project (http://mingw.org).  Download the
MingGW Installation Manager, and use it to install at least
‘mingw-developer-toolkit’.  (Also installing ‘msys-groff’ avoids a minor
problem building the documentation.)

   The ‘C:\MinGW\msys\1.0\msys.bat’ script creates a command window with
the ‘bash’ shell and the ‘PATH’ set up as needed.  Alternatively, you
can use the standard Windows command prompt if you set your ‘PATH’ as
described in here (http://mingw.org/wiki/Getting_Started).

4.4.1.3 Building on Windows using Cygwin
........................................

The free Cygwin (http://sourceware.org/cygwin/) environment can be used
for building Kawa: The Kawa configure script recognizes Cygwin, and
modifies the classpath to use Windows-style path separators.

   Beyond the base packages, you probably want to install ‘autoconf’,
‘automake’, ‘git’, ‘texinfo’, ‘groff’, ‘make’, and ‘diffutils’.

   Cygwin (unlike MinGW) has a current version of ‘makeinfo’, but an
undiagnosed bug still prevents building ‘kawa.info’.  You can work
around that problem with ‘touch doc/kawa.info’.

4.4.2 Building the documentation
--------------------------------

4.4.2.1 Plain HTML documentation
................................

You can build a plain HTML version of the documentation (using
‘makeinfo’ from the ‘texinfo’ distribution):
     cd doc && make kawa-html/index.html

   In this case, point your browser at
‘file:/KAWA_SRCDIR/doc/kawa-html/index.html’.

4.4.2.2 Fancier HTML documentation
..................................

To build the documentation in a nicer form suitable for a web-site you
need ‘makeinfo’ _and_ the DocBook XSLT tools (and to have run
‘configure’ with the ‘--with-docbook-stylesheets’ option):
     cd doc && make web/index.html

   You can then point your browser at
‘file:/KAWA_SRCDIR/doc/web/index.html’.

4.4.2.3 Using ebook readers or the –browse-manual option
........................................................

To build an ‘EPUB’ file suitable for ebook readers, as well as enabling
support for the *note ‘kawa --browse-manual’ option:
browse-manual-option, do:

     cd doc && make kawa-manual.epub

   This also requires the DocBook XSLT tools.

4.4.2.4 Building a printable PDF file
.....................................

To build a ‘pdf’ file suitable for printing or online viewing do:
     cd doc && make kawa.pdf

   The resulting ‘kawa.pdf’ is somewhat unsatisfactory - when viewed
online, links aren’t clickable.  Furthermore, box drawing characters are
missing.

4.4.3 Build Kawa using ‘ant’
----------------------------

Kawa now includes an Ant buildfile (‘build.xml’).  Ant
(http://ant.apache.org) is a part of the Apache Jakarta project.  If you
don’t hava Ant installed, get it from
<http://ant.apache.org/bindownload.cgi>.  The build is entirely Java
based and works equally well on *nix, Windows, and presumably most any
other operating system.

   Once Ant has been installed and configured (you may need to set the
‘JAVA_HOME’, and ‘ANT_HOME’ environment variables), you should be able
to change to the directory containing the ‘build.xml’ file, and invoke
the ‘ant’ command.  With the default settings, a successful build will
result in a ‘kawa-3.1.1.jar’ in the current directory.

   There are a few Ant "targets" of interest (they can be supplied on
the Ant command line):

‘all’
     This is the default, it does ‘classes’ and ‘jar’.
‘classes’
     Compiles all the files into ‘*.class’ files into the directory
     specified by the ‘build.dir’ property.
‘jar’
     Builds a jar into into the directory specified by the ‘dist.dir’
     property.
‘runw’
     Run Kawa in a GUI window.
‘clean’
     Deletes all files generated by the build, including the jar.

   There is not yet a ‘test’ target for running the testsuite.

   There are various “properties" that control what ‘ant’ does.  You can
override these on the command line or by editing the ‘build.properties’
file in the same directory as ‘build.xml’.  For example, the ‘build.dir’
property tells ‘ant’ where to build temporary files, and where to leave
the resulting ‘.jar’ file.  For example, to leave the generated files in
the sub-directory named ‘BUILD’ do:
     ant -Dbuild.dir=BUILD
   A sample ‘build.properties’ is provided and it contains comments
explaining many of the options.

   Here are a few general properties that help to customize your build:
‘build.dir’
     Path to put the temporary files used for building.
‘dist.dir’
     Path to put the resulting jar file.
‘version.local’
     A suffix to add to the version label for your customized version.
‘debug’
     Whether (true/false) the Javac "-g" option is enabled.
‘optimize’
     Whether (true/false) the Javac "-O" option is enabled.

   Here are some Kawa-specific ones (all ‘true’/‘false’):
‘with-collections’, ‘with-references’, ‘with-awt’, ‘with-swing’,
‘enable-jemacs’, and ‘enable-servlet’> See the sample ‘build.properties’
for more information on these.

   If you change any of the build properties, you will generally want to
do an ‘ant clean’ before building again as the build is often not able
to notice that kind of change.  In the case of changing a directory
path, you would want to do the ‘clean’ before changing the path.

   A special note for NetBeans users: For some reason the build-tools
target which compiles an Ant task won’t compile with the classpath
provided by NetBeans.  You may do ‘ant build-tools’ from the command
line outside of NetBeans, in which case you will not want to use the
‘clean’ target as that will delete the tool files as well.  You can use
the ‘clean-build’ and/or ‘clean-dist’ targets as appropriate.
Alternatively you can add ‘ant.jar’ to the ‘build-tools’ classpath by
copying or linking it into a ‘lib/ext’ directory in Kawa’s source
directory (the one containing the ‘build.xml’ file).


File: kawa.info,  Node: Tutorial,  Next: Running,  Prev: Installation,  Up: Top

5 Kawa Scheme Tutorial
**********************

_This is obviously incomplete, but it may be useful, especially if
you’re starting with Kawa from scratch._  If you’re new to Scheme you
might also check out one of these tutorials: Takafumi Shido’s Yet
Another Scheme Tutorial (http://www.shido.info/lisp/idx_scm_e.html);
Dorai Sitaram’s Teach Yourself Scheme in Fixnum Days
(http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html); or
Paul Wilson’s An Introduction to Scheme and its Implementation
(ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html).

* Menu:

* Tutorial - Introduction::      Introduction
* Tutorial - Booleans::          Booleans
* Tutorial - Numbers::           Numbers
* Tutorial - Functions::         Functions
* Tutorial - Variables::         Variables
* Tutorial - Pictures::          Pictures
* Tutorial - Sequences::         Lists and sequences
* Tutorial - Objects::           Creating and using objects
* Tutorial - Types::             Types and declarations
* Tutorial - Exceptions and errors::
* Tutorial - Classes::           Classes
* Tutorial - Other Java features::


File: kawa.info,  Node: Tutorial - Introduction,  Next: Tutorial - Booleans,  Up: Tutorial

5.1 Introduction
================

You’ve heard about all the hot scripting languages – you might even be
tired of hearing about them.  But Kawa offers you something different
than the scripting-language du-jour can.  You may be interested in one
that runs on the Java virtual machine, either because you have to
interact with other Java tools, or because you like having access to all
the Java packages out there.  Or maybe you don’t care about Java, but
you care about performance.  If so, let me tell you about Kawa, which is
actually one of the very oldest language implementations running on the
Java Virtual Machine, dating back to 1996.

   The Kawa language is a dialect/implementation of the Scheme language.
(The Kawa project also supports other languages, including XQuery
(http://www.w3.org/XML/Query) and Emacs Lisp
(http://jemacs.sourceforge.net), as well as tools for implementing mew
programming languages, but we won’t cover that in this tutorial.)

   Scheme (http://www.schemers.org/) is an established language with
many implementations
(http://community.schemewiki.org/?scheme-faq-standards#implementations),
a standard (http://www.schemers.org/Documents/Standards/) specification
(the traditional R5RS
(http://www.schemers.org/Documents/Standards/R5RS/), R6RS
(http://www.r6rs.org/) which was ratified in 2007, and R7RS
(http://www.r7rs.org/) which was ratified in 2013), and is used by
universities for both teaching and research.  Scheme also has a
reputation for being difficult to learn, with a weird parenthesis-heavy
syntax, and hard-to-understand concepts like continuations
(http://en.wikipedia.org/wiki/Continuation).  Luckily, you don’t need to
understand continuations!  (Kawa doesn’t fully implement them anyway.)

   The following assumes that Kawa is already installed on your
computer; if not see these *note installation instructions:
Installation.  Running the ‘kawa’ command in interactive mode is a good
way start learning Kawa:
     $ kawa
     #|kawa:1|#
   If you don’t have ‘kawa’ but you have a Kawa “jar” and you have Java
installed you can instead do:

     $ java -jar kawa-VERSION-NUMBER.jar
     #|kawa:1|#

   The prompt string has the form of a Scheme comment, to make it easier
to cut-and-paste.  Kawa is expecting you type in an expression or
command, which it will evaluate, and then print out the result.  For
example, a quoted string is a simple expression that evaluates to a
string value, which will print as itself, before printing the next
prompt:

     #|kawa:1|# "Hello, world!"
     Hello, world!
     #|kawa:2|#

   The most noticable difference from most other programming languages
is that Scheme uses “prefix” notation for function calls.  For example
Kawa has a function ‘max’ which returns the largest value of the
arguments.  Instead of ‘max(5, 7, 3)’ you write ‘(max 5 7 3)’:

     (max 5 7 3) ⇒ 7

   (We use the ‘⇒’ symbol above to indicate that the expression ‘(max 5
7 3)’ evaluates to the value ‘7’.)

   The prefix notation may feel a bit weird, but you quickly get used to
it, and it has some advantages.  One is consistency: What are special
infix operators in most languages are just regular functions in Scheme.
For example, addition is just a regular function call, and ‘+’ is just a
regular function name:
     (+ 2.5 1.2) ⇒ 3.7

   The same prefix notation is used for special operations like
assignments:
     #|kawa:1|# (set! sqrt-of-2 (sqrt 2))
     #|kawa:2|# sqrt-of-2
     1.4142135623730951


File: kawa.info,  Node: Tutorial - Booleans,  Next: Tutorial - Numbers,  Prev: Tutorial - Introduction,  Up: Tutorial

5.2 Booleans
============

Scheme uses the syntax ‘#t’ and ‘#f’ for Boolean true and false value,
respectively.  For example, the “less-than” function is named ‘<’.  Its
result is true if the first argument is less than the second (or, if
there are more than two arguments, that they are in increasing order):
     (< 3 4) ⇒ #t
     (< -3 -4) ⇒ #f
     (< 2 3 5 7 11)) ⇒ #t

   The ‘if’ special form takes two or three sub-expressions: It
evaluates the first expression.  If that is true it evaluates the second
expression; otherwise it evaluates the third expression, if provided:
     (if (< 3 4) (+ 5 5) (+ 5 6)) ⇒ 10

   We call ‘if’ a special form rather than a function, because for a
function all the arguments are evaluated before the function is called,
but in a special form that is not neceassarily the case.

   In addition to ‘#t’ any value except ‘#f’ (and the Kawa-specific
‘#!null’) counts as “true” when evaluating the first expression of an
‘if’.  Unlike C or JavaScript both (zero) and ‘""’ (the empty string)
are true:

     (if 0 (+ 5 5) (+ 5 6)) ⇒ 10

   You can use ‘and’, ‘or’, and ‘not’ to create complex boolean
expressions.  Of these ‘and’ and ‘or’ are special forms that only
evaluate as many of the sub-expressions as needed.
     (if (not (and (>= i 0) (<= i 9)))
         (display "error"))

   You can use the ‘cond’ form as an alternative to ‘if’:
     (cond ((< 3 3) 'greater)
           ((> 3 3) 'less)
           (else ’equal))       ⇒ equal

   The null value (written as ‘#!null’ in Kawa or ‘null’ in Java) is
also considered as false.


File: kawa.info,  Node: Tutorial - Numbers,  Next: Tutorial - Functions,  Prev: Tutorial - Booleans,  Up: Tutorial

5.3 Numbers
===========

Exact integers and fractions
----------------------------

Kawa has the usual syntax for decimal integers.  Addition, subtraction,
and multiplication are written using the usual ‘+’, ‘-’, and ‘*’, but
these are all prefix functions that take a variable number of arguments:

     (+ 1 2 3) ⇒ 6
     (- 10 3 4) ⇒ (- (- 10 3) 4)  ⇒ 3
     (* 2 -6)  ⇒ -12

   Kawa has arbitrary-precision integers.

   Let us implement the factorial
(http://en.wikipedia.org/wiki/Factorial) function.  Type in the
following (we’ll look at the syntax shortly):
     #|kawa:1|# (define (factorial x)
     #|(---:2|#   (if (< x 1) 1
     #|(---:3|#     (* x (factorial (- x 1)))))

   (The prompt changes to indicate a continuation line.)  This binds the
name ‘factorial’ to a new function, with formal parameter ‘x’.  This new
function is immediately compiled to Java bytecodes, and later a JIT
compiler may compile it to native code.

   A few tests:
     #|kawa:4|# (list (factorial 3) (factorial 4))
     (6 24)
     #|kawa:5|# (factorial 30)
     265252859812191058636308480000000

Floating-point real numbers
---------------------------

Given what was said above about being able to add, subtract and multiply
integers, the following may be unexpected:

     #|kawa:1|# (/ 2 3)
     2/3
     #|kawa:2|# (+ (/ 1 3) (/ 2 3))
     1

   In many languages, dividing two integers, as 2/3, would result in 0.
At best, the result would be a floating point number, similar to
0.666667.  Instead, Kawa has a _rational_ number type, which holds the
results of divisions _exactly_, as a proper fraction.  Hence, adding one
third to two thirds will always result in exactly one.

   Floating-point real numbers are known in Kawa as _inexact_ numbers,
as they cannot be stored exactly.  Consider:

     #|kawa:3|# (exact? 2/3)
     #t
     #|kawa:4|# (exact? 0.33333333)
     #f
     #|kawa:5|# (exact->inexact 2/3)
     0.6666666666666666

   The first two examples check numbers for being ‘exact?’; there is a
corresponding ‘inexact?’ test.  The last shows how an exact number can
be converted to an inexact form.

   Numbers are converted between exact and inexact versions when
required within operations or procedures:

     #|kawa:6|# (+ 0.33333333 2/3)
     0.9999999966666666
     #|kawa:7|# (inexact? (+ 0.33333333 2/3))
     #t
     #|kawa:8|# (sin 2/3)
     0.618369803069737

Complex numbers
---------------

A _complex_ number is made from two parts: a _real_ part and an
_imaginary_ part.  They are written ‘2+3i’.  A complex number can be
manipulated just like other numbers:

     #|kawa:9|# (+ 2+3i 5+2i)
     7+5i
     #|kawa:10|# (* 2+3i 4-3i)
     17+6i
     #|kawa:11|# (integer? (+ 2+3i -3i))
     #t

   Notice how in the last example the result is an integer, which Kawa
recognises.

   Kawa also includes *note quaternion: Quaternions. numbers.

Units and dimensions
--------------------

In many applications, numbers have a _unit_.  For example, 5 might be a
number of dollar bills, a weight on a scale, or a speed.  Kawa enables
us to represent numbers as _quantities_: numbers along with their unit.
For example, with weight, we might measure weight in pounds and ounces,
where an ounce is 1/16 of a pound.

   Using Kawa, we can define units for our weight measurements, and
specify the units along with numbers:

     #|kawa:12|# (define-base-unit pound "Weight")
     #|kawa:13|# (define-unit ounce 0.0625pound)
     #|kawa:14|# 3pound
     3.0pound
     #|kawa:15|# (+ 1pound 5ounce)
     1.3125pound

   In this example we define a base unit, the pound, and a unit based on
it, the ounce, which is valued at 0.0625 pounds (one sixteenth).
Numbers can then be written along with their unit (making them
quantities).  Arithmetic is possible with quantities, as shown in the
last line, and Kawa will do the smart thing when combining units.  In
this case, 1 pound and 5 ounces is combined to make 1.3125 pounds.


File: kawa.info,  Node: Tutorial - Functions,  Next: Tutorial - Variables,  Prev: Tutorial - Numbers,  Up: Tutorial

5.4 Functions
=============

To declare a new function use ‘define’, which has the following form:
     (define (FUNCTION-NAME PARAMETER-NAMES) BODY)

   This creates a new function named FUNCTION-NAME, which takes
PARAMETER-NAMES as parameters.  When the function is called, the
PARAMETER-NAMES are initialized with the actual arguments.  Then BODY is
evaluated, and its value becomes the result of the call.

   For example, in the ‘factorial’ function we looked at recently, the
FUNCTION-NAME is ‘factorial’, and the PARAMETER-NAMES is ‘x’:

     (define (factorial x)
       (if (< x 1) 1
       (* x (factorial (- x 1)))))

Anonymous functions
-------------------

An _anonymous_ function is simply a function which does not have a name.
We define an anonymous function using a “lambda expression”, which has
the following form:
     (lambda (PARAMETER-NAMES) BODY)

   The lambda expression has the PARAMETER-NAMES and BODY of a function,
but it has no name.  What is the point of this?

   An important example is creating a function to act on a list, perhaps
using ‘map’.  The ‘map’ function takes two parameters: the first is a
function which takes a value and returns a value; the second is a list.
Here, we want to double every number in the list.

   The usual way of doing this is to create a named function, called
‘double’, and then apply it to a list:

     #|kawa:1|# (define (double x)
     #|.....2|#    (* 2 x))
     #|kawa:3|# (map double (list 1 2 3 4 5))
     (2 4 6 8 10)

   Instead, anonymous functions make it easy to create a function to
work on a list, without having to define it in advance:

     #|kawa:4|# (map (lambda (x) (* 2 x)) (list 1 2 3 4 5))
     (2 4 6 8 10)
     #|kawa:5|# (define y 3)
     #|kawa:6|# (map (lambda (x) (* x y)) (list 1 2 3 4 5))
     (3 6 9 12 15)

   The first example shows the double example rewritten as an anonymous
function.  The second example shows how the anonymous function can be
changed to fit the place in which it is used: here, the value of Y
determines the value by which the list values are multiplied.

   Notice that we can name our anonymous functions, in just the same way
we name any value in Kawa, using ‘define’:

     (define double
        (lambda (n)
            (* 2 n)))

   although more frequently we use the short-hand for defining
functions, which we have already met:

     (define (double n)
       (* 2 n))

   Anonymous functions are “first-class values” in Kawa, and can be
passed to other functions as arguments (like we did with ‘map’), and
they can even be created and returned by functions as results.

Optional, rest and keyword parameters
-------------------------------------

You can declare a function that takes optional arguments, or a variable
number of arguments.  You can also use keyword parameters.

   The following function illustrates the use of _optional_ arguments.
The function identifies an optional argument ‘z’: if the function is
called with 3 arguments, ‘z’ will be bound to the third value, otherwise
it will be ‘#f’.

     (define (addup x y #!optional z)
       (if z
         (+ x y z)
         (+ x y)))

   The following examples show ‘addup’ applied to 2, 3 and invalid
arguments.  It is an error to pass just one argument or more than three:
‘x’ and ‘y’ are compulsory, but ‘z’ is optional.

     #|kawa:12|# (addup 1 2)
     3
     #|kawa:13|# (addup 1 2 3)
     6
     #|kawa:14|# (addup 1)
     /dev/stdin:14:1: call to 'addup' has too few arguments (1; min=2, max=3)
     #|kawa:15|# (addup 1 2 3 4)
     /dev/stdin:15:1: call to 'addup' has too many arguments (4; min=2, max=3)

   In this example, a better way to define the function would be to
include a default value for ‘z’, for when its value is not given by the
caller.  This is done as follows, with the same behavior as above:

     (define (addup x y #!optional (z 0))
       (+ x y z))

   You can include as many optional parameters as you wish, after the
‘#!optional’.

   _Rest_ arguments are an alternative way to pass an undefined number
of arguments to a function.  Here is ‘addup’ written with rest
arguments, notice the variable name after the .  (dot):

     (define (addup x y . args)
       (+ x y (apply + args)))

   The ‘args’ are simply a list of all remaining values.  The following
now all work, as the function only requires a minimum of two numbers:

     #|kawa:4|# (addup 1 2)
     3
     #|kawa:5|# (addup 1 2 3)
     6
     #|kawa:6|# (addup 1 2 3 4 5 6 7 8)
     36

   An alternative way to identify the rest args is with ‘#!rest’:

     (define (addup x y #!rest args)
       (+ x y (apply + args)))

   Finally, it can be useful to identify parameters by name and, for
this, Kawa provides _keyword_ arguments.  Consider the following
function:

     #|kawa:38|# (define (vector-3d #!key x y z)
     #|.....39|#   (vector x y z))
     #|kawa:40|# (vector-3d #:x 2 #:z 3 #:y 4)
     #(2 4 3)

   ‘vector-3d’ is defined with three keyword arguments: ‘x’, ‘y’, and
‘z’.  When the function is called, we identify the name for each value
by writing ‘#:’ at the start of the name.  This allows us to write the
arguments in any order.  Keyword parameters can also be given default
values, as with optional parameters.  Keyword parameters with no default
value, and no value in the caller, will get the value ‘#f’.

   In the caller, keywords are symbols with ‘#:’ at the front (or ‘:’ at
the end): *note read more here: Keywords.

   All these extended types of arguments are available both for “named”
and for “anonymous” functions.  Optional, rest and keyword arguments can
be mixed together, along with the usual arguments.  For details *note
read more here.: Extended formals.


File: kawa.info,  Node: Tutorial - Variables,  Next: Tutorial - Pictures,  Prev: Tutorial - Functions,  Up: Tutorial

5.5 Variables
=============

You can declare a variable using a ‘!’ form.  This takes a variable
name, and an expression.  It declares a new variable with the given
name, and gives it the value of the expression.
     #|kawa:1|# (! binary-kilo 1024)
     #|kawa:2|# (! binary-mega (* binary-kilo binary-kilo))
     #|kawa:3|# binary-mega
     1048576

   If you prefer, you can use ‘define’ instead of ‘!’:

     #|kawa:1|# (define binary-kilo 1024)
     #|kawa:2|# (define binary-mega (* binary-kilo binary-kilo))
     #|kawa:3|# binary-mega
     1048576

   The advantage of using ‘define’ is that it is portable to other
Scheme implementations.  The advantages of using ‘!’ is that it is
shorter; it generalizes to patterns (see later); and it guards against
accidentally “shadowing” a variable by a nested variable with the same
name.

   A ‘!’ (or ‘define’) typed into the command-line defines a top-level
variable.

   You can also declare local variables, which are variables defined for
a given block of code.  For example, in the following code ‘let’ is used
to set up a local binding of ‘x’ to 3: this does not affect the outer
binding of ‘x’ to 5:

     (define x 5)

     (let ((x 3))
       (display x))  ⇒ 3

     (display x)     ⇒ 5

   Alternative forms for defining local variables are ‘let’, ‘let*’, or
‘letrec’/‘letrec*’.

   The differences are in the order in which definitions are made.
‘let’ evaluates all its definitions in the environment holding at the
start of the ‘let’ statement.  In the following example, the local
variables are defined using values from the global variables:

     (define x 5)
     (define y 2)

     (let ((x (+ 2 y))  ; uses value of global y, i.e. 2
           (y (+ 3 x))) ; uses value of global x, i.e. 5
       (display (list x y)))  ⇒ (4 8)

   ‘let*’ instead evaluates each definition in the environment holding
at the start of the ‘let*’ statement, along with all _previous_ local
definitions.  In the following example, ‘y’ is now defined with the
_local_ value of ‘x’:

     (define x 5)
     (define y 2)

     (let* ((x (+ 2 y))  ; uses value of global y, i.e. 2
            (y (+ 3 x))) ; uses value of local x, i.e. 4
       (display (list x y)))  ⇒ (4 7)

   ‘letrec/letrec*’ are similar, but allow the definition of recursive
functions:

     (letrec ((is-even? (lambda (n) (and (not (= 1 n))
                                         (or (zero? n)
                                             (is-odd? (- n 1))))))
              (is-odd? (lambda (n) (and (not (zero? n))
                                        (or (= 1 n)
                                            (is-even? (- n 1)))))))
       (display (is-even? 11)))   ⇒ #f


File: kawa.info,  Node: Tutorial - Pictures,  Next: Tutorial - Sequences,  Prev: Tutorial - Variables,  Up: Tutorial

5.6 Composable pictures
=======================

The ‘pictures’ library lets you create geometric shapes and images, and
combine them in interesting ways.  You first need to import the library:
     (import (kawa pictures))
   The easiest way to use and learn the library is with a suitable REPL,
where you can type expressions that evaluate to pictures values, and
view the resulting pictures directly on the console.  The easiest way is
to start the ‘kawa’ command with the ‘-w’ flag.  Alternatively, you can
use a *note DomTerm: Using DomTerm.-based terminal emulator such as
‘qtdomterm’ (which is shown in the image below), and then the ‘kawa’
command.

 [image src="images/domterm-pictures-1.png" ]


   The above image shows two simple examples: a filled circle (radius 30
pixels, color magenta), and a non-filled rotated rectangle (color maroon
3-pixel wide strokes).

   See *note Composable pictures:: for details and more examples.

Shapes and coordinates
----------------------

A “shape” is a geometrical figure consisting of one or more curves and
lines.  One kind of shape is a circle; you can create one with the
‘circle’ procedure, specifying the radius in “pixels”.

     #|kawa:1|# (import (kawa pictures))
     #|kawa:2|# (circle 30)
      [image src="images/fill-circ-1.png" ]
   It you print a shape, it will show it as a thin black curve.

   A “point” has two real-numbered parts: the point’s x-coordinate, and
its y-coordinate.  The x-coordinate increases as you move right along
the page/screen, while the y-coordinate increases as you move _down_.
(Unlike traditional mathematics, where the y-coordinate increases as you
go up.)  The unit distance is one “pixel”, which is defined as CSS or
HTML. You can create a point with ‘&P’ operator.  For example:
     &P[30 20]
   is a point 30 pixels right and 20 pixels down from the origin point.
To create a circle centered on that point do ‘(center 30 &P[30 20])’.

   The expression ‘(rectangle &P[10 20] &P[50 40])’ creates a rectangle
whose upper left corner is (10,20) and whose lower right corner is
(50,40).

   A “dimension” is a pair, a width and height, and is written:
     &D[WIDTH HEIGHT]
   In addition to being used for sizes, a dimension is also used for
relative offsets.  For example, the previous rectangle could also be
written ‘(rectangle &P[10 20] &D[40 20])’.

   You can use ‘line’ to create a line.  More generally, if you specify
N points you get a “polyline” of N-1 line segments:
     #|kawa:3|# (line &P[10 20] &P[50 60] &P[90 0])
      [image src="images/polyline-1.png" ]
   The same line using dimensions for relative offsets:
     #|kawa:4|# (line &P[10 20] &D[40 20] &D[40 -60])

   A “closed shape” is one whose end point is the same as its start
point.  The ‘polygon’ function creates one using straight line segments
     #|kawa:5|# (polygon &P[10 20] &P[50 60] &P[90 0])
      [image src="images/polygon-1.png" ]

Colors and filling
------------------

You can override the default color (black) using the ‘with-paint’
procedure, which takes a color and a picture to produce a new picture:
     #|kawa:6|# (with-paint 'red (circle 32))

   The first argument can be either one of the standard CSS/HTML5 color
names (such as ‘'red’ or ‘'medium-slate-blue’), or an integer
representing an sRGB color, usually written as a hex literal in the form
‘#xRRGGBB’:
     #|kawa:7|# (with-paint #x0808FF (circle 32))

   The name ‘with-paint’ is because the first argument can be not just a
color, but a general “paint”, such as a gradient or a background image.
However, we won’t go into that.

   If the shape is closed, you can “fill” its inside:
     (fill (circle 32))

   You can change the color using ‘with-paint’:
     (with-paint 'goldenrod (fill (circle 32)))
   or as an extra argument to ‘fill’:
     (fill 'goldenrod (circle 32))

   draw TODO

Images
------

An image is a picture represented as a rectangular grid of color values.
It may be a photograph from a camera, or be created by a painting
program like Photoshop or gimp.  You can use ‘image-read’ to read an
image from a file, typically a ‘.png’ or ‘.jpg’ file.

     #|kawa:10|# (define img1 (image-read "http://pics.bothner.com/2013/Cats/06t.jpg"))
     #|kawa:11|# img1
      [image src="images/image-cat-1a.png" ]

Transforms TODO
---------------

     #|kawa:12|# (scale 0.6 (rotate 30 img1))
      [image src="images/image-cat-1b.png" ]

Combining and adjusting pictures TODO
-------------------------------------

Using and combining pictures TODO
---------------------------------


File: kawa.info,  Node: Tutorial - Sequences,  Next: Tutorial - Objects,  Prev: Tutorial - Pictures,  Up: Tutorial

5.7 Lists and sequences
=======================

A “sequence” is a generalized array or list: Zero or more values treated
as a compound value.  Sequences have certain common operations,
including indexing and iteration.  (Technical note: Sequences generally
implement the ‘java.util.List’ interface, but Kawa will also treat
strings and native Java arrays as sequences.)

Creating sequences
------------------

The general syntax for creating a sequence of type SEQ-TYPE with values
give by expressions A, B ...  Z is:
     (SEQ-TYPE A B ... Z)
   For example to create a 3-element list of the first 3 natural
numbers, you can write:
     (vector 1 (+ 1 1) 3)

   A “splice operator” ‘@’SEQ can be used as one the arguments to append
or convert sequences:
     (vector 1 @lst)

Lists
-----

In traditional Lisp-family languages, the “list” is the most important
kind of sequence.  (Don’t confuse Java’s ‘List’ interface with Kawa’s
use of the word list.  They’re related, in that a Kawa “list” implements
the ‘List’ interface, so any list is also ‘List’, but not vice versa.)

   A list is implemented as a chain of linked “pairs”.  You can create a
constant list by quoting a parenthesized list:
     '(3 4 (10 20 30) "a string")

   See *note Lists:: for details and operations.

Vectors
-------

A “vector” is a sequence that is implemented by storing the elements
side-by-side in memory.  A vector uses less space than a list of the
same length, and is generally more efficient than a list.

   To create a vector you can use a bracketed list:
     (! vec1 ['A 'B 'C 'D 'E 'F])
   This creates a vector of 6 symbols and binds it to ‘vec1’.  To select
an element you can use the traditional ‘vector-ref’ procedure:
     (vector-ref vec1 3) ⇒ 'D
   Alternatively, in Kawa you can use function-call notation:
     (vec1 3) ⇒ 'D

   You can also create a vector using the traditional ‘vector’
constructor:
     (! vec2 (vector 'A 'B 'C 'D 'E 'F))
   There is one important difference between ‘vec1’ and ‘vec2’: You can
modify ‘vec2’ by changing some or all of its elements.  You can’t do
that for ‘vec1’.  (We say that ‘vec1’ is an “immutable” or “constant”
vector, while ‘vec1’ is a “mutable” or “modifiable” vector.)  To change
an element use either the traditional ‘vector-set!’ procedure, or
function-call notation:
     (vector-set! vec2 2 'Y)
     (set! (vec2 4) 'Z)
     vec2 ⇒ ['A 'B 'Y 'D 'Z 'F]
     (vector-set! vec1 2 'Y) ⇒ throws exception

   See *note Vectors:: for details and operations.

Java arrays and primitive vectors
---------------------------------

See *note Using Java arrays: Array operations. for examples.

Indexing of general sequences
-----------------------------

You can use function-call notation to index a generalized sequence,
whether it is a list, vector, any ‘java.util.List’, native Java array,
or string:
     ((list 'A 'B 'C 'D) 2)  ⇒ 'C
     ("abcdef" 3)  ⇒  #\d
     (! farr (float[] 1.5 3 4.5))  ;; native Java array
     (farr 2) ⇒ 4.5

   Note that indexing a list with an index I will be slow, since it has
to step through the list I times.  (So don’t do that!)

Ranges
------

A “range” is a sequence of numbers in order, spaced uniformly apart.
Usually, these are (exact) integers that increase by one.  The usual
notation is:
     [START <: END]
   This is the sequence of integers starting with the integer START
(inclusive) and ending with the integer END (exclusive).  For example
‘[3 <: 7]’ is the sequence ‘[3 4 5 6]’.

   The ‘<:’ is a keyword; the ‘<’ is a mnemonic for the set of integers
that are ‘<’ the end value 6.  You can also use ‘<=:’ if you want to
include the upper bound: ‘[4 <=: 8]’ is ‘[4 5 6 7 8]’.

   You can use ‘>=:’ or ‘>:’ for a decreasing range.  ‘[5 >=: 1]’ or ‘[5
>: 0]’ both evaluate to ‘[5 4 3 2 1]’.  You can also specifify a step
value: ‘[1 by: 2 <=: 9]’, which evaluates to ‘[1 3 5 7 9]’.  (*note
Details here: Ranges.)

Using vector and ranges indexes
-------------------------------

If an index is a sequence of integers, the result is a new sequence (of
the same type) selecting only the elements matching the index values.
For example:
     #|kawa:2|# (vec1 [3 5 2])
     #(D F C)
   In general, ‘((V1 V2) I)’ is ‘(V1 (V2 I))’.

   You can use a range to create a slice - a contiguous subset of a
list.
     #|kawa:3|# (vec1 [2 <: 6])
     #(C D E F)

   A range is different from a vector integer in that you can use a
range as the index in the LHS of a set!:

     #|kawa:4|# (set! (vec1 [2 <: 4]) #(a b c d e))
     #|kawa:5|# vec1
     #(A B a b c d e E F)

   Notice how the number of replaced elements can be different then the
number of elements in the replacement value.  I.e.  you can do insertion
and deletion this way.

     #|kawa:7|# (! str1 (string-copy "ABCDEF"))
     #|kawa:8|# (set! (str1 [2 <: 5]) "98")
     AB98F


File: kawa.info,  Node: Tutorial - Objects,  Next: Tutorial - Types,  Prev: Tutorial - Sequences,  Up: Tutorial

5.8 Creating and using objects
==============================

An “object” is a value that has the following features:
   • class - each object is an instance of a specific class, making it
     part of the class hierarchy, which is an important aspect of the
     type system;
   • properties - various fields and methods, depending on the class;
   • identity - it is distinct from all other objects, even if all the
     properties are the same.

   We later discuss *note how to write a new class: Tutorial - Classes.
Here we assume you’re using an existing class, which could be written in
Java or Scheme.

Creating a new object
---------------------

To create a new object of class ‘T’ you call ‘T’ as if it were a
function, passing it the various constructor arguments:
     (java.io.File "src" "build.xml")

   If there are keyword arguments they are used to initialize the
corresponding named properties:
     (! button1 (javax.swing.JButton text: "Do it!" tool-tip-text:  "do it"))
   This creates a new ‘JButton’ object (using ‘JButton’’s default
constructor), and sets the ‘text’ and ‘tool-tip-text’ properties (by
calling ‘JButton’’s ‘setText’ and ‘setToolTipText’ methods).  If there
are constructor arguments, they must come before the keywords.

   For objects that have components or elements, you can list these at
the end.  For example:
     (java.util.ArrayList 11 22 33)
   This creates a fresh ‘java.util.ArrayList’ (using the default
constructor), and then calls the ‘add’ method 3 times.

   If you prefer you can use the ‘make’ procedure, but that only handles
simple constructor calls:
     (make java.io.File "src" "build.xml")

   See *note Allocating objects:: for details.

Calling instance methods
------------------------

Given an object OBJ of a class that has a method METH, you can call it
with argumens V1 ...  V2 using *note Colon notation:::
     (OBJ:METH V1 ... V2)
   For example:
     (button1:paintImmediately 10 10 30 20)

   If you prefer, you can use the ‘invoke’ procedure, normally with a
quoted method name:
     (invoke button1 'paintImmediately 10 10 30 20)
   You need to use ‘invoke’ (rather than colon notation) if OBJ is a
‘Class’ or a type expression, or its class implements
‘gnu.mapping.HasNamedParts’.

   See *note Method operations:: for details.

Accessing properties
--------------------

If OBJ has a field or property named FLD you can also use colon
notation:
     OBJ:FLD

   You use the same syntax whether FLD is an actual field in the object,
or a “property” (in the Java Beans sense).  The latter is implemented
using a getter/setter pair: Methods named ‘getF’ and ‘setF’,
respectively.  For example:
     button1:tool-tip-text
   is equivalent to:
     (button1:getToolTipText)

   You can also change a field or property using colon notation:
     (set! OBJ:FLD VALUE)
   For example:
     (set! button1:tool-tip-text "really do it!")
   This is equivalent to:
     (button1:setToolTipText "really do it!")

   Instead of colon notation, you can use the ‘field’ procedure.

   See *note Field operations:: for details.

Static fields and methods
-------------------------

Kawa views static properties and methods as properties and methods of
the class itself.  To call a static method use the syntax:
     (CLAS:METH V1 ... VN)
   For example:
     (java.math.BigDecimal:valueOf 12345 2) ⇒ 123.45

   To access a static field do ‘CLAS:FLD’.  For example:
     java.awt.Color:RED

   You can also use the ‘static-field’ and ‘invoke-static’ procedures.


File: kawa.info,  Node: Tutorial - Types,  Next: Tutorial - Exceptions and errors,  Prev: Tutorial - Objects,  Up: Tutorial

5.9 Types and declarations
==========================

A “type” is a named value for a set of objects with related properties.
For example, ‘vector’ is the type for standard Scheme vectors.  You can
use a type to specify that a variable can only have values of the
specified type:

     #|kawa:5|# (define v ::vector #(3 4 5))
     #|kawa:6|# v
     #(3 4 5)
     #|kawa:7|# (set! v 12)
     /dev/stdin:7:1: warning - cannot convert literal (of type gnu.math.IntNum) to vector
     Value (12) for variable 'v' has wrong type (gnu.math.IntNum) (gnu.math.IntNum cannot be cast to gnu.lists.FVector)
     	at atInteractiveLevel$7.run(stdin:7)
     	at gnu.expr.ModuleExp.evalModule(ModuleExp.java:302)
     	at kawa.Shell.run(Shell.java:275)
     	at kawa.Shell.run(Shell.java:186)
     	at kawa.Shell.run(Shell.java:167)
     	at kawa.repl.main(repl.java:870)
     Caused by: java.lang.ClassCastException: gnu.math.IntNum cannot be cast to gnu.lists.FVector
     	... 6 more

   Using a type specification catches errors, and makes your programs
more readable.  It can also allow the Kawa compiler to generate code
that runs faster.

   You can use a type to check that a value is an instance of the type,
using either the ‘instance?’ function:

     (instance? #(3 4 5) vector) ⇒ #t
     (instance? '(3 4 5) vector) ⇒ #f

   As a convenience, you can use a type-name followed by a “‘?’”:
     (TYPE? VAL) == (instance? VAL TYPE)

   You can “call” a type as if it were a function, which constructs a
new instance of the type.  The following example shows how to construct
a normal Scheme vector, and a Java array of ints:

     #|kawa:1|# (vector)
     #()
     #|kawa:2|# (instance? (vector) vector)
     #t
     #|kawa:3|# (define x (int[] 1 2 3))
     #|kawa:4|# x
     [1 2 3]
     #|kawa:5|# (instance? x int[])
     #t

   A fully-qualified Java class is a type name.  So are the names of
Java primitive types.  So are Java array types, as shown above.

   e.g.  a JFrame is constructed by using its class name as a function:

     #|kawa:6|# (javax.swing.JFrame)
     javax.swing.JFrame[frame0,0,25,0x0,invalid,hidden,layout=java.awt.BorderLayout,
     title=,resizable,normal,defaultCloseOperation=HIDE_ON_CLOSE,
     rootPane=javax.swing.JRootPane[,0,0,0x0,invalid,
     layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,
     flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]

   A type is a true run-time value:

     (define mytypes (list vector list string))
     (instance? #(3 4 5) (car mytypes) ⇒ #t

   The ‘define-alias’ form is useful for defining shorter names for
types, like a generalization of Java’s ‘import’ statement:

     (define-alias jframe javax.swing.JFrame)


File: kawa.info,  Node: Tutorial - Exceptions and errors,  Next: Tutorial - Classes,  Prev: Tutorial - Types,  Up: Tutorial

5.10 Exceptions and errors
==========================

Kawa supports the exception framework and forms from R6RS and R7RS. See
*note Exceptions:: for details.

Native exception handling
-------------------------

You can also work with native Java exceptions at a low level.

   The ‘primitive-throw’ procedure throws a ‘Throwable’ value.  It is
implemented just like Java’s ‘throw’.
     (primitive-throw (java.lang.IndexOutOfBoundsException "bad index"))

   You can catch an exception with the ‘try-catch’ syntax.  For example:
     (try-catch
       (do-a-bunch-of-stuff)
       (ex java.lang.Throwable
         (format #f "caught ~a~%~!" ex)
         (exit)))

   A ‘try-finally’ does the obvious:
     (define (call-with-port port proc)
       (try-finally
        (proc port)
        (close-port port)))

   Both ‘try-catch’ and ‘try-finally’ are expression forms that can
return values, while the corresponding Java forms are statements that
cannot return values.


File: kawa.info,  Node: Tutorial - Classes,  Next: Tutorial - Other Java features,  Prev: Tutorial - Exceptions and errors,  Up: Tutorial

5.11 Classes
============

See *note Defining new classes:: for the gory details; no tutorial yet.


File: kawa.info,  Node: Tutorial - Other Java features,  Prev: Tutorial - Classes,  Up: Tutorial

5.12 Other Java features
========================

Import
------

The ‘import’ form can be used to avoid having to write fully-qualified
class names.  For example:
     (import (class java.util
                    Map
                    (HashMap HMap)))
   This defines aliases for two classes in the ‘java.util’ package, one
with renaming: ‘Map’ is an alias for ‘java.util.Map’, and ‘HMap’ is an
alias for ‘java.util.HashMap’.

   The ‘class’ keyword is needed because the ‘import’ form is also used
for Kawa’s module system.  See *note importing-class-names:: and *note
Importing:: for details.

Synchronized blocks
-------------------

You can use a ‘synchronized’ expression:

     (synchronized obj form1 ... formn)
   This waits until it can get an exclusive lock on OBJ and then
evaluates FORM1 through FORMN.  Unlike Java, this is an expression and
returns the value of FORMN.

Annotations
-----------

You can write annotation declarations - see *note Annotations:: for
details.

   Kawa does not yet support annotations on types, or declaring new
annotation classes.


File: kawa.info,  Node: Running,  Next: Syntax,  Prev: Tutorial,  Up: Top

6 How to start up and run Kawa
******************************

The easiest way to start up Kawa is to run the ‘kawa’ program.  This
finds your Java interpreter, and sets up ‘CLASSPATH’ correctly.  If you
have installed Kawa such that ‘$PREFIX/bin’ is in your ‘$PATH’, just do:
     kawa
   However, ‘kawa’ only works if you have a Unix-like environment.  On
some platforms, ‘kawa’ is a program that uses the GNU ‘readline’ library
to provide input line editing.

   To run Kawa manually, you must start a Java Virtual Machine.  How you
do this depends on the Java implementation.  For Oracle’s JDK, and some
other implementations, you must have the Java evaluator (usually named
‘java’) in your ‘PATH’.  You must also make sure that the
‘kawa/repl.class’ file, the rest of the Kawa packages, and the standard
Java packages can be found by searching CLASSPATH. *Note Running Java::.

   Then you do:
     java kawa.repl

   In either case, you will then get the ‘#|kawa:1|#’ prompt, which
means you are in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the result (if
there is a non-"void" result).

* Menu:

* Options::      Command-line arguments
* Scripts::      Running Command Scripts
* REPL Console:: The REPL (read-eval-print-loop) console
* Exiting::      Exiting Kawa
* Compiling::    Compiling to byte-code


File: kawa.info,  Node: Options,  Next: Scripts,  Prev: Running,  Up: Running

6.1 Command-line arguments
==========================

You can pass various flags to Kawa, for example:
     kawa -e '(display (+ 12 4))(newline)'
   or:
     java kawa.repl -e '(display (+ 12 4))(newline)'
   Either causes Kawa to print ‘16’, and then exit.

   At startup, Kawa executes an init file from the user’s home
directory.  The init file is named ‘.kawarc.scm’ on Unix-like systems
(those for which the file separator is ‘'/'’), and ‘kawarc.scm’ on other
systems.  This is done before the read-eval-print loop or before the
first ‘-f’ or ‘-c’ argument.  (It is not run for a ‘-e’ command, to
allow you to set options to override the defaults.)

6.1.1 Argument processing
-------------------------

Kawa processes the command-line arguments in order.  Options (which
either start with ‘-’ or contain a ‘=’) may “use up” one or more command
arguments.  Some of the options (‘-c’, ‘-e’, ‘-f’, ‘-s’, ‘-C’, ‘-w’,
‘--’, ‘--browse-manual’) are “action options”; others set various
properties.

   When all the command-line arguments have been “used up” and if no
action options have been seen, then Kawa enters an interactive
read-eval-print loop.  (If an action option has been seen, we’re done.)

   If the next command-line argument is not an option (does not start
with ‘-’ nor contains a ‘=’) then we’re done if we’ve seen an action
option (and the last action option wasn’t preceded by
‘--with-arg-count’).  (Presumably any remaining arguments were
command-line-arguments used by the action option.)

   Otherwise, the first remaining argument names either a file that is
read and evaluated, or a compiled class.  In the former case, the whole
file is read and compiled as a module before being loaded (unlike the
‘-f’ flag which reads and evaluates the file command by command.)  If
the argument is the fully-qualified name of a class, then the class is
loaded, an instance allocated, and its ‘run’ method invoked.  If the
class was compiled from a Kawa Scheme module, then invoking ‘run’ has
the effect of evaluating the module body.  The ‘command-line-arguments’
vector is set to any remaining arguments after the file/class name.
(This can be overridden with the ‘--with-arg-count’ option.
Command-line processing continues if there are any further arguments.)

6.1.2 General options
---------------------

‘-e EXPR’
     Kawa evaluates EXPR, which contains one or more Scheme expressions.
     Does not cause the ‘~/.kawarc.scm’ init file to be run.
‘-c EXPR’
     Same as ‘-e EXPR’, except that it does cause the ‘~/.kawarc.scm’
     init file to be run.
‘-f FILENAME-OR-URL’
     Kawa reads and evaluates expressions from the file named by
     FILENAME-OR-URL.  If the latter is ‘-’, standard input is read
     (with no prompting).  Otherwise, it is equivalent to evaluating
     ‘(load "FILENAME-OR-URL")’.  The FILENAME-OR-URL is interpreted as
     a URL if it is absolute - it starts with a "URI scheme" like
     ‘http:’.
‘-s’
‘--’
     The remaining arguments (if any) are passed to
     ‘command-line-arguments’ and (the ‘cdr’ of) ‘(command-line’), and
     an interactive read-eval-print loop is started.  This uses the same
     "console" as where you started up Kawa; use ‘-w’ to get a new
     window.
‘--script FILENAME-OR-URL’
‘--scriptN FILENAME-OR-URL’
     The global variable ‘command-line-arguments’ is set to the
     remaining arguments (if any).  Kawa reads and evaluates expressions
     from the file named by FILENAME-OR-URL.  If ‘script’ is followed by
     an integer N, then N lines are skipped first.

     Skipping some initial lines is useful if you want to have a
     non-Kawa preamble before the actual Kawa code.  One use for this is
     for Kawa shell scripts (*note Scripts::).

‘-w’
‘-wSUB-OPTION’
     Creates a new top-level window, and runs an interactive
     read-eval-print in the new window.  See *note New-Window::.  Same
     as ‘-e (scheme-window #t)’.  You can specify multiple ‘-w’ options,
     and also use ‘-s’.
‘--help’
     Prints out some help.
‘--version’
     Prints out the Kawa version number, and then exits.

     If Kawa was built with a ‘.git’ repository present, also prints the
     result of ‘git describe’.
‘--browse-manual’
‘--browse-manual=COMMAND’
     Browse a local copy of the documentation (this manual).

     This creates a mini web-server that reads from
     ‘doc/kawa-manual.epub’, which is included in the binary
     distributions, but not built by default from source.

     If no COMMAND is specified, creates a new mini-browser-window using
     JavaFX (if the JavaFX modules are available), or creates a new
     window or tab in your default web browser (otherwise).  If COMMAND
     is a string containing ‘%U’, then Kawa replaces ‘%U’ with a URL
     that references itself, and then executes the resulting command.
     If COMMAND does not contain ‘%U’, then COMMAND becomes COMMAND‘"
     %U"’.  For example to use the Firefox browser to browse the manual
     do either of:
          kawa --browse-manual=firefox
          kawa --browse-manual="firefox %U"

‘--server PORTNUM’
     Start a server listening from connections on the specified PORTNUM.
     Each connection using the Telnet protocol causes a new
     read-eval-print-loop to start.  This option allows you to connect
     using any Telnet client program to a remote "Kawa server".
‘--with-arg-count=ARGC’
     This option is used before an action option (such as ‘-f’).  The
     ARGC arguments after the action become the value of the
     ‘command-line-arguments’ during the action.  When the action is
     finished, command-line-processing resumes after skipping the ARGC
     arguments.

     For example:
          $ kawa -f a.scm -f b.scm x y
     When evaluating ‘a.scm’ the ‘command-line-arguments’ by default is
     _all_ the remaining arguments: ‘["-f" "b.scm" "x" "y"]’.  Then
     ‘b.scm’ is evaluated with ‘command-line-arguments’ set to ‘["x"
     "y"]’

          $ kawa --with-arg-count=0 -f a.scm -f b.scm x y
     In this case ‘a.scm’ is evaluated with ‘command-line-arguments’ set
     to the empty vector ‘[]’, and then ‘b.scm’ is evaluated with
     ‘command-line-arguments’ set to ‘["x" "y"]’

          $ kawa --with-arg-count=4 -f a.scm -f b.scm x y
     In this case ‘a.scm’ is evaluated with ‘command-line-arguments’ set
     to ‘["-f" "b.scm" "x" "y"]’.  Since command-line processing skips
     the arguments specified by ‘--with-arg-count=4’, in this case
     ‘b.scm’ is not evaluated.

6.1.3 Options for language selection
------------------------------------

‘--scheme’
     Set the default language to Scheme.  (This is the default unless
     you select another language, or you name a file with a known
     extension on the command-line.)
‘--r5rs’
‘--r6rs’
‘--r7rs’
     Provide better compatibility with the specified Scheme standards.
     (This is a work-in-progress.)  For example ‘--r6rs’ aims to disable
     Kawa extensions that conflict with R6RS. It does not aim to disable
     all extensions, only incompatible extensions.  These extensions
     disable the colon operator and keyword literals, as well as the use
     of initial ‘@’ as a splicing operator.  The “‘l’” exponent suffix
     of a number literal creates a floating-point double, rather than a
     ‘BigInteger’.  Selecting ‘--r5rs’ makes symbols by default
     case-insensitive.
‘--elisp’
‘--emacs’
‘--emacs-lisp’
     Set the default language to Emacs Lisp.  (The implementation is
     quite incomplete.)
‘--lisp’
‘--clisp’
‘--clisp’
‘--commonlisp’
‘--common-lisp’
     Set the default language to CommonLisp.  (The implementation is
     _very_ incomplete.)
‘--krl’
     Set the default language to KRL. See *note KRL::.
‘--brl’
     Set the default language to KRL, in BRL-compatibility mode.  See
     *note KRL::.
‘--xquery’
     Set the default language to the draft XML Query language.  See the
     Kawa-XQuery page (http://www.gnu.org/software/qexo/) for more
     information.
‘--xslt’
     Set the default language to XSLT (XML Stylesheet Language
     Transformations).  (The implementation is _very_ incomplete.)  See
     the Kawa-XSLT page (http://www.gnu.org/software/qexo/xslt.html) for
     more information.
‘--pedantic’
     Try to follow the approprate language specification to the letter,
     even in corner cases, and even if it means giving up some Kawa
     convenience features.  This flag so far only affects the XQuery
     parser, but that will hopefully change.

6.1.4 Options for warnings and errors
-------------------------------------

‘--warn-undefined-variable’
     Emit a warning if the code references a variable which is neither
     in lexical scope nor in the compile-time dynamic (global)
     environment.  This is useful for catching typos.  (A
     ‘define-variable’ form can be used to silence warnings.  It
     declares to the compiler that a variable is to be resolved
     dynamically.)  This defaults to on; to turn it off use the
     ‘--no-warn-undefined-variable’ flag.
‘--warn-unknown-member’
     Emit a warning if the code references a named member (field or
     method) for which there is no match in the compile-time type of the
     receiver.  This defaults to on; to turn it off use the
     ‘--no-warn-unknown-member’ flag.
‘--warn-invoke-unknown-method’
     Emit a warning if the ‘invoke’ function calls a named method for
     which there is no matching method in the compile-time type of the
     receiver.  This defaults to the value of ‘--warn-unknown-member’,
     to turn it off use the ‘--no-warn-invoke-unknown-method’ flag.
‘--warn-unused’
     Emit a warning if a variable is unused or code never executed.
     This defaults to on; to turn it off use the ‘--no-warn-unused’
     flag.
‘--warn-uninitialized’
     Warn if accessing an uninitialized variable.  This defaults to on;
     to turn it off use the ‘--no-warn-uninitialized’ flag.
‘--warn-unreachable’
     Emit a warning if the code can never be executed.  This defaults to
     on; to turn it off use the ‘--no-warn-unreachable’ flag.
‘--warn-void-used’
     Emit a warning if an expression depends on an expression that is
     void (always has zero values), including call to ‘void’ functions
     and method.  Also warn if an expression depends on a conditional
     (‘if’) that has no “else” clause.  Examples include using the value
     of ‘set-car!’ as an argument to a function, or to initialize a
     variable.  This defaults to on; to turn it off use the
     ‘--no-warn-void-used’ flag.
‘--warn-as-error’
     Treat a compilation warning as if it were an error and halt
     compilation.
‘--max-errors=VALUE’
     Print no more than VALUE errors or warnings (at a time).  The value
     ‘-1’ removes the limit.  The initial default is 20.  (A single
     error may so confuse Kawa that it prints very many useless error
     messages.)

   An option can be followed by a value, as in
‘--warn-invoke-unknown-method=no’.  For boolean options, the values
‘yes’, ‘true’, ‘on’, or ‘1’ enable the option, while ‘no’, ‘false’,
‘off’, or ‘0’ disable it.  You can also negate an option by prefixing it
with ‘no-’: The option ‘--no-warn-unknown-member’ is the same as
‘--warn-unknown-member=no’.

   These options can also be used in the module source, using
‘module-compile-options’ or ‘with-compile-options’.  (In that case they
override the options on the command line.)

6.1.5 Options for setting variables
-----------------------------------

‘NAME=VALUE’
     Set the global variable with the specified NAME to the given VALUE.
     The type of the VALUE is currently unspecified; the plan is for it
     to be like XQuery’s “untyped atomic” which can be coerced as
     needed.
‘{NAMESPACE-URI}LOCAL-NAME=VALUE’
     Set the global variable with the specified namespace uri and
     namespace-local name to the given value.

   These options are processed when invoking the ‘kawa’ application
(i.e.  the ‘kawa.repl’ application).  If you want a Kawa application
compiled with ‘--main’ to process these these assignments, call the
‘process-command-line-assignments’ utility function.

‘-DVARIABLE-NAME=VARIABLE-VALUE’
     Sets the JVM property VARIABLE-NAME to VARIABLE-VALUE, using the
     ‘setProperty’ method of ‘java.lang.System’.

6.1.6 Options for the REPL console
----------------------------------

‘--console’
‘--no-console’
     Usually Kawa can detect when the standard input port is a “console”
     or “terminal”, but these are useful for overriding that detection.
     The ‘--console’ flag is useful when the standard input is a pipe,
     but you want to direct Kawa to treat it as an interactive terminal.
     The ‘--no-console’ flag was useful for older pre-Java-6
     implementations that did not have the ‘java.lang.Console’ class.
‘console:type=’CONSOLE-TYPES
‘console:use-jline=’[‘yes’|‘no’]
‘console:jline-mouse=’[‘yes’|‘no’]
     See the *note REPL Console:: section.
‘console:prompt1=PROMPT1’
‘console:prompt2=PROMPT2’
     Initialize *note ‘input-prompt1’ and ‘input-prompt2’:
     input-prompt1, respectively.
   See also the ‘--output-format’ flag.

6.1.7 Options for controlling output formatting
-----------------------------------------------

‘--output-format FORMAT’
‘--format FORMAT’
     Change the default output format to that specified by FORMAT.  See
     *note Named output formats:: for more information and a list.

‘out:base=INTEGER’
     The number base (radix) to use by default when printing rational
     numbers.  Must be an integer between 2 and 36, and the default is
     of course 10.  For example the option ‘out:base=16’ produces
     hexadecimal output.  Equivalent to setting the ‘*print-base*’
     variable.
‘out:radix=no|yes’
     If true, prints an indicator of the radix used when printing
     rational numbers.  The default is ‘no’.  Equivalent to setting the
     ‘*print-radix*’ variable.
‘out:doctype-system=SYSTEM-IDENTIFIER’
     If ‘out:doctype-system’ is specified then a ‘DOCTYPE’ declaration
     is written before writing a top-level XML element, using the
     specified SYSTEM-IDENTIFIER.
‘out:doctype-public=PUBLIC-IDENTIFIER’
     Ignored unless ‘out:doctype-system’ is also specified, in which
     case the PUBLIC-IDENTIFIER is written as the public identifiers of
     the ‘DOCTYPE’ declaration.
‘out:xml-indent=KIND’
     Controls whether extra line breaks and indentation are added when
     printing XML. If KIND is ‘always’ or ‘yes’ then newlines and
     appropriate indentation are added before and after each element.
     If KIND is ‘pretty’ then the pretty-printer is used to only add new
     lines when an element otherwise won’t fit on a single line.  If
     KIND is ‘no’ (the default) then no extra line breaks or indentation
     are added.
‘out:line-length=COLUMNS’
‘out:right-margin=COLUMNS’
     Specifies the maximum number of number of columns in a line when
     the pretty-printer decides where to break a line.  (The two options
     are equivalent.)

6.1.8 Options for compiling and optimizing
------------------------------------------

‘--target VERSION’
     The VERSION can be a JDK or Java specification version: ‘5’, ‘6’,
     or ‘7’.  The JDK versions ‘1.5’ and ‘1.6’ are equivalent to ‘5’ or
     ‘6’, respectively.  Specify a JVM (classfile) version to target.
     This is useful if (for example) you use Java 6, but want to create
     ‘.class’ files that can run on Java 5.  In that case specify
     ‘--target 5’.

   The following options control which calling conventions are used:
‘--full-tailcalls’
     Use a calling convention that supports proper tail recursion.
‘--no-full-tailcalls’
     Use a calling convention that does not support proper tail
     recursion.  Self-tail-recursion (i.e.  a recursive call to the
     current function) is still implemented correctly, assuming that the
     called function is known at compile time.
‘--no-inline’
     Disable inlining of known functions and methods.  The generated
     code runs slower, but you can more reliably trace procedures.
     Normally Kawa will assume that a procedure ‘fn’ declared using a
     ‘(define (fn args) body)’ form is constant, assuming it isn’t
     modified in the current module.  However, it is possible some other
     module might modify the binding of ‘fn’.  You can use the
     ‘--no-inline’ to disable the assumption that ‘fn’ is constant.

   The default is currently ‘--no-full-tailcalls’ because it is usually
faster.  It is also closer to the Java call model, so may be better for
people primarily interested in using Kawa for scripting Java systems.

   Both calling conventions can co-exist: Code compiled with
‘--full-tailcalls’ can call code compiled with ‘--no-full-tailcalls’ and
vice versa.

   These options can also be used in the module source, using
‘module-compile-options’ or ‘with-compile-options’.  (In that case they
override the options on the command line.)

   The options ‘-C’, ‘-d’, ‘-T’, ‘-P’, ‘--main’ ‘--applet’, and
‘--servlet’ are used to compile a Scheme file; see *note Files
compilation::.  The options ‘--module-static’, ‘--module-nonstatic’,
‘--no-module-static’, and ‘--module-static-run’ control how a module is
mapped to a Java class; see *note static-or-non-modules::.  The option
‘--connect PORTNUM’ is only used by the ‘kawa’ front-end program.

6.1.9 Options for debugging
---------------------------

The following options are useful if you want to debug or understand how
Kawa works.
‘--debug-dump-zip’
     Normally, when Kawa loads a source file, or evaluates a non-trivial
     expression, it generates new internal Java classes but does not
     write them out.  This option asks it to write out generated classes
     in a ‘.zip’ archive whose name has the prefix ‘kawa-zip-dump-’.
‘--debug-print-expr’
     Kawa translates source language forms into an internal ‘Expression’
     data structure.  This option causes that data structure to be
     written out in a readable format to the standard output.
‘--debug-print-final-expr’
     Similar to the previous option, but prints out the ‘Expression’
     after various transformations and optimizations have been done, and
     just before code generation.
‘--debug-syntax-pattern-match’
     Prints logging information to standard error when a ‘syntax-rules’
     or ‘syntax-case’ pattern matches.
‘--debug-error-prints-stack-trace’
     Prints a stack trace with any error found during compilation.
‘--debug-warning-prints-stack-trace’
     Prints a stack trace with any warning found during compilation.
‘--langserver’
     Starts Kawa in server mode, responding to requests using the
     Language Server Protocol (https://langserver.org).  This is used by
     editors and IDEs for on-the-fly syntax checking and more.  Highly
     experimental.

6.1.10 Options for web servers
------------------------------

JDK 6 (or later) includes a complete web server library.

‘--http-auto-handler CONTEXT-PATH APPDIR’
     Register a web application handler that uses files in the directory
     APPDIR to handle HTTP (web) requests containing the given
     CONTEXT-PATH.  That is it handles requests that start with
     ‘http://localhost:PORTCONTEXT-PATH’.  (This assumes the
     CONTEXT-PATH starts with a ‘/’.)  *Note Self-configuring page
     scripts::.
‘--http-start PORT’
     Start the web server, listing on the specified PORT.

6.1.11 Options for the JVM
--------------------------

The ‘kawa’ front-end can pass options to the ‘java’ launcher, using ‘-J’
or ‘-D’ options.  These must be given _before_ any other arguments.  For
example:
     kawa -J-Xms48m -Dkawa.command.name=foo foo.scm
   is equivalent to (ignoring classpath issues):
     java -Xms48m -Dkawa.command.name=foo kawa.repl foo.scm
   You can also pass a ‘-D’ option (but not a ‘-J’ option) after the
class name, in which case it is processed by the Kawa command-line
processor rather than the ‘java’ launcher.  The effect is normally the
same.

‘-JJVM-OPTION’
     Passes the JVM-OPTION to the ‘java’ command, before the class-name
     (‘kawa.repl’) and Kawa options.
‘-DVARIABLE-NAME=VARIABLE-VALUE’
     Sets the JVM property VARIABLE-NAME to VARIABLE-VALUE.  Equivalent
     to ‘-J-DVARIABLE-NAME=VARIABLE-VALUE’.


File: kawa.info,  Node: Scripts,  Next: REPL Console,  Prev: Options,  Up: Running

6.2 Running Command Scripts
===========================

If you write a Kawa application, it is convenient to be able to execute
it directly (from the command line or clicking an icon, say), without
have to explicitly run ‘kawa’ or ‘java’.  On Unix-like systems the
easiest way to do this is to write a small shell script that runs your
Kawa application.

   For modest-sized applications it is convenient if the shell script
and the Kawa code can be in the same file.  Unix-like systems support a
mechanism where a “script” can specify a program that should execute it.
The convention is that the first line of the file should start with the
two characters ‘#!’ followed by the absolute path of the program that
should process (interpret) the script.

   (Windows has “batch files”, which are similar.)

   This convention works well for script languages that use ‘#’ to
indicate the start of a comment, since the interpreter will
automatically ignore the line specifying the interpreter filename.
Scheme, however, uses ‘#’ as a multi-purpose prefix, and Kawa
specifically uses ‘#!’ as a prefix for various *note Special named
constants:: such as ‘#!optional’.

   Kawa does recognize the three-character sequence ‘#!/’ at the
beginning of a file as special, and ignores it.  Here is an example:
     #!/usr/local/bin/kawa
     (format #t "The command-line was:~{ ~w~}~%" (command-line))

   If you copy this text to a file named ‘/home/me/bin/scm-echo’, set
the execute permission, and make sure it is in your ‘PATH’, then you can
execute it just by naming it on command line:
     $ chmod +x /home/me/bin/scm-echo
     $ PATH=/home/me/bin:$PATH
     $ scm-env a b
     The command-line was: "/home/me/bin/scm-echo" "a" "b"
   The system kernel will automatically execute ‘kawa’, passing it the
filename as an argument.

   Note that the full path-name of the ‘kawa’ interpreter must be
hard-wired into the script.  This means you may have to edit the script
depending on where Kawa is installed on your system.  Another possible
problem is that the interpreter must be an actual program, not a shell
script.  Depending on how you configure and install Kawa, ‘kawa’ can be
a real program or a script.  You can avoid both problems by the ‘env’
program, available on most modern Unix-like systems:

     #!/usr/bin/env kawa
     (format #t "The command-line was:~{ ~w~}~%" (command-line))

   This works the same way, but assumes ‘kawa’ is in the command ‘PATH’.

6.2.1 Setting kawa options in the script
----------------------------------------

If you need to specify extra arguments to ‘kawa’, you can run arbitrary
shell command inside Scheme block comments.  Here is an example:
     #!/bin/sh
     #|
     exec kawa out:base=16 out:radix=yes "$0" "$*"
     |#
     (format #t "The command-line is:~{ ~w~}.~%" (command-line))
     (display "It has ")
     (display (apply + (map string-length (command-line))))
     (display " characters.")
     (newline)

   The trick is to hide the shell code from Kawa inside a ‘#|...|#’
block-comment.  The start of the block comment is a line starting with a
‘#’, so it is treated as a comment by the shell.  You can then invoke
‘kawa’ (or ‘java’ directly) as you prefer, setting up class-path and
jars as needed, and passing whatever arguments you want.  (The shell
replaces the ‘"$0"’ by the name of the script, and replaces the ‘"$@"’
by the remaining arguments passed to the script.)  You need to make sure
the shell finishes before it reaches the end of the block comment or the
Scheme code, which would confuse it.  The example uses ‘exec’, which
tells the shell to _replace_ itself by KAWA; an alternative is to use
the shell ‘exit’ command.

   If you copy the above file to ‘/tmp/sch-echo’ and make that file
executable, you can run it directly:
     $ /tmp/scm-echo "a b" "c d"
     The command-line is: "/tmp/scm-echo" "a b c d".
     It has #x14 characters.

   When the Kawa reader sees the initial ‘#/’ it sets the command name
to the file name, so it can be used by a future call to
‘(command-name)’.  If you want to override this you can use the
‘-Dkawa.command.name=NAME’ option.

   Using comments this way has the advantage that you have the option of
running the script “manually” if you prefer:
     $ kawa /tmp/scm-echo out:base=8 "x y"
     The command-line is: "/tmp/scm-echo" "out:base=8" "x y".
     It has 26 characters.

6.2.2 Other ways to pass options using meta-arg or –script
----------------------------------------------------------

An argument consisting of just a ‘\’ (backslash) causes Kawa to read the
_second_ line looking for options.  (Quotes and backslashes work like in
the shell.)  These replace the backslash in the command line.

   This is a less verbose mechanism, but it requires an absolute path to
‘kawa’, due to shell limitations.

     #!/usr/bin/kawa \
       --scheme --full-tailcalls
     (format #t "The command-line is:~{ ~w~}.~%" (command-line))

   In this case the effective command line received by Kawa will be
‘--scheme’, ‘--full-tailcalls’, followed by the script filename,
followed by other arguments specified when running the script.

   The backslash used this way originated in scsh (http://www.scsh.net)
where it is called the “meta-arg”.  (Unlike scsh, Kawa’s ‘#!’ is not a
block comment, but a rest-of-line, though the backslash causes the
following line to also be skipped.)

   An alternative method is to use the ‘--script2’ option, which tells
Kawa to execute the script after ignoring the initial two lines.  For
example:

     #!/bin/sh
     exec kawa --commonlisp out:base=16 --script2 "$0" "$@"
     (setq xx 20) (display xx) (newline)

   This is slightly more compact than using block-comments as shown
earlier, but it has the disadvantage that you can’t explicitly use
‘kawa’ or ‘java’ to run the script unless you make sure to pass it the
‘--script2’ option.

6.2.3 Scripts for compiled code
-------------------------------

If you compile your Kawa application to class files (or better: a ‘jar’
file), you probably still want to write a small shell script to set
things up.  Here is one method:

     #!/bin/sh
     export CLASSPATH=/my/path
     exec kawa -Dkawa.command.name="$0" foo "$@"

   Using the ‘kawa’ front-end is a convenience, since it automatically
sets up the paths for the Kawa classes, and (if enabled) it provides
readline support for the default input port.

   Setting the ‘kawa.command.name’ property to ‘"$0"’ (the filename used
to invoke the script) enables ‘(command-line’) to use the script name as
the command name.

   You can invoke ‘java’ directly, which is necessary when running a
‘jar’ file:

     #!/bin/sh
     exec java -cp /path/to/kawa -Dkawa.command.name="$0" foo.jar "$@"


File: kawa.info,  Node: REPL Console,  Next: Exiting,  Prev: Scripts,  Up: Running

6.3 The REPL (read-eval-print-loop) console
===========================================

The read-eval-print-loop (REPL) console is a convenient way to do simple
programming, test out things, and experiment.  As the name implies, the
REPL repeatedly (in a loop) prints out a prompt, reads an input command,
evaluates it, then prints the result.

   The REPL is started when you invoke the ‘kawa’ command with no
arguments.  For example:

     $ kawa
     #|kawa:1|# (define pi (* 2 (asin 1)))
     #|kawa:2|# (list pi (sqrt pi))
     (3.141592653589793 1.7724538509055159)
     #|kawa:3|#

   The colors and styles used for the prompt and the user input depend
on user preference and the capabilities of the console device.  (If you
read this on a color screen you should see pale green for the prompt and
pale yellow for the user input; this matches the defaults for the
DomTerm console.)

   You can *note change the prompt string: Prompts. if you want.  The
default format depends on the (programming) language used; the one shown
above is used for Scheme.  It has the form of a comment, which can be
convenient for copying and pasting lines.

   You can *note change the output formatting: Named output formats.
with the ‘--output-format’ command-line option.

   The basic console has few frills, but should work in any enviroment
where you have a console or terminal.  It has no dependencies, except
the kawa ‘.jar’ file (and Java):
     $ java kawa-3.1.1.jar
     #|kawa:2|#

   On rare occason you may need to specify the ‘--console’ flag.

6.3.1 Input line editing and history
------------------------------------

When typing a command in a console it is helpful to go back and correct
mistakes, repeat and edit previous commands, and so on.  How well you
can do this varies a lot depending on which tools you use.  Kawa
delegates input editing to an external tool.  The recommended and
default input-editing tool is the JLine3 library
(https://github.com/jline/jline3), which is bundled with the Kawa binary
distribution.

   JLine3 handles the normal editing comands, including arrow keys for
moving around in the input, and deleting with backspace or delete.  In
general, JLine3 uses the same keybindings as GNU readline, which are
based on Emacs key-bindings.

   You can use the up-arrow to move to previous commands in the input
history and down-arrow to go forwards.  Control-R (“reverse search”
searches backwards in the history for a previous command that contains
the search string.

   Multi-line commands are treated as a unit by JLine3: If Kawa
determines that input is “incomplete” it will ask for continuation lines
- and you can go back and edit previous lines in the same command.  You
can explicitly create a multi-line command with Escape-Space.  An entry
in the command history may be multiple lines.

   Tab-completion works for Kawa-Scheme identifiers: If you type TAB
after an identifier, Kawa will present a list of possible completions.

   There are multiple alternatives to using JLine3.  You can use GNU
readline (if you configured with ‘--enable-kawa-frontend’).  You can use
a front-end program like ‘rlfe’ or ‘fep’.  You can use Emacs shell or
scheme mode.  You can also use DomTerm in line-edit mode, where the
browser handles the editing.

‘console:use-jline=’[‘yes’|‘no’]
     Disable (with ‘no’) or enable (with ‘yes’, which is the default)
     input line editing with JLine.
‘console:console:jline-mouse=’[‘yes’|‘no’]
     Enable (with ‘yes’) mouse click reporting from most xterm-like
     terminals to JLine, which means you can move the input cursor with
     the mouse.  This is disabled by default because it conflicts with
     other useful mouse actions (text selection using drag;
     middle-button paste; right-button context menu; and wheel mouse
     scrolling).  If you enable mouse-reporting, on most terminals you
     can get the standard behavior when pressing the shift key.  E.g.
     to enable selection, drag with the shift key pressed.  (However,
     mouse-wheel scrolling may not work even with shift pressed.)

6.3.2 Running a Command Interpreter in a new Window
---------------------------------------------------

Instead of using an existing terminal window for Kawa’s REPL console,
you can request a new window.  The command-line options ‘-w’ creates a
new window.  Kawa also creates a new window when it needs to create a
REPL (for example if invoked with no options) and it is not running in a
console.

   You have a number of options for how the window appears and what it
supports, controlled by text following ‘-w’.  All except ‘-wswing’ (and
‘-wconsole’) use DomTerm, so they depend on some kind of web browser
technology.  All except ‘-wswing’ by default use JLine3 input editing,
if available.

‘-w’
     Pick the default/preferred console implementation.  You can specify
     your preference with the ‘console:type=’ option, which is followed
     by one of the options below (without the ‘"-w"’ prefix), It can
     also be list of options separated by semi-colons, in which case
     they are tried in order.

     The current default (it may change) is as if you specified:
          console:type="google-chrome;browser;javafx;swing;console"

‘-wbrowser’
     Creates a Kawa window or tab in your preferred desktop browser.
     Kawa starts a builtin HTTP and WebSocket server to communicate with
     the browser.
‘-wbrowser=COMMAND’
     Uses COMMAND to display the Kawa REPL. The COMMAND should include
     the pattern ‘%U’, which Kawa replaces with a URL that it listens
     to.  (Alternatively, it can use the pattern ‘%W’, which Kawa
     replaces with the port number of its WebSocket server.  However,
     this feature may be removed.)  If the is no ‘%’ in the COMMAND,
     Kawa add ‘" %U"’.  Thus ‘-wbrowser=firefox’ is the same as
     ‘-wbrowser="firefox %U"’.
‘-wgoogle-chrome’
     Creates a new Google Chrome window in “app mode” - i.e.  with no
     location or menu bar.  This is the same as
     ‘-wbrowser="google-chrome --app=%U"’.
‘-wjavafx’
     Creates a new window using JavaFX WebView, which runs in the same
     JVM as Kawa.  While this doesn’t currently have much in the way of
     Kawa-specific menus or other features, it has the most potential
     for adding them in the future.  However, it does require JavaFX,
     which is not always available, and which does not see a lot of love
     from Oracle.  (It uses an old version of WebKit.)
‘-wswing’
     Create a console using the Swing toolkit.  This is the old
     implementation of ‘-w’.  It is deprecated because it only supports
     the builtin Swing line editing.  (I.e.  neither DomTerm or JLine3
     features are available, though “printing” *note pictures:
     Composable pictures. does work.)
‘-wserve’
‘-wserve=’PORT
     Starts up an HTTP server (along with a WebSocket server), but does
     not automatically create any browser windows.  Instead you can use
     any modern browser to load ‘http://localhost:PORT/’.  If PORT is
     not specified, the systems selects it (and prints it out).
‘-wconsole’
     Same as ‘"--"’ - i.e.  it uses the existing console.
‘console:type=’PREFERENCE-LIST
     Specify the behavior of plain ‘-w’.

6.3.3 Using DomTerm
-------------------

DomTerm (http://domterm.org) is a family of terminal emulators that use
the DomTerm JavaScript library.

   You can either have Kawa start DomTerm:
     $ kawa OPTIONS -w
   or start a DomTerm terminal emulator and have it start Kawa:
     $ domterm kawa OPTIONS --
   (You can also start a shell in a ‘domterm’ window, and then start
‘kawa’.)

   Either approach works and both give you the benefits of DomTerm:
   • A xterm/ansi-compatible terminal emulator, which means you can use
     (for example) JLine3 for input editing.
   • You can “print” images, *note pictures: Composable pictures, or
     HTML elements.
   • Pretty-printing is handled by the terminal, which means
     line-breaking is re-computed when window width changes.
   • Hide/show buttons allow you to temporarily hide/unhide the output
     from a specific command.
   • You can save a session as an HTML file, which can be viewed later.
     (Still with dynamic line-breaking and pretty-printing, as well as
     working hide/show buttons.)  The file is actually XHTML, so it can
     be processed with XML-reading tools.
   • Distinct styles for prompts, input, error output and regular
     output, which can be customized with CSS.

   For now it is recommended to use both DomTerm and JLine3.

 -- Procedure: domterm-load-stylesheet stylesheet [name]
     The string STYLESHEET should be a literal CSS stylesheet which is
     downloaded into the current DomTerm console.  The new stylesheet is
     given the attribute ‘name=NAME’, where NAME defaults to ‘"Kawa"’.
     If there is an existing stylesheey whose ‘name’ attribute is NAME,
     it is replaced.  In this example we change the background color to
     light gray:
          (domterm-load-stylesheet "div.domterm { background-color: lightgray}")


File: kawa.info,  Node: Exiting,  Next: Compiling,  Prev: REPL Console,  Up: Running

6.4 Exiting Kawa
================

Kawa normally keeps running as long as there is an active
read-eval-print loop still awaiting input or there is an unfinished
other computation (such as requested by a ‘-e’ or ‘-f’ option).

   To close a read-eval-print-loop, you can type the special literal
‘#!eof’ at top level.  This is recognized as end-of-file.  Typing an
end-of-file character (normally ctrl-D under Unix) should also work, but
that depends on your operating system and terminal interface.

   If the read-eval-print-loop is in a new window, you can select
‘Close’ from the ‘File’ menu.

   To exit the entire Kawa session, call the *note ‘exit’ procedure:
Exiting the current process. (with 0 or 1 integer arguments).


File: kawa.info,  Node: Compiling,  Up: Running

6.5 Compiling to byte-code
==========================

All Scheme functions and source files are invisibly compiled into
internal Java byte-codes.  (A traditional interpreter is used for
macro-expansion.  Kawa used to also interpret “simple” expressions in
interactive mode, but always compiling makes things more consistent, and
allows for better stack traces on errors.)

   To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.  There are
two ways to do this.

   You can compile a Scheme source file to a single archive file.  You
do this using the ‘compile-file’ function.  The result is a single file
that you can move around and ‘load’ just like the ‘.scm’ source file.
You just specify the name of the archive file to the ‘load’ procedure.
Currently, the archive is a "zip" archive and has extension ".zip"; a
future release will probably use "Java Archive" (jar) files.  The
advantage of compiling to an archive is that it is simple and
transparent.

   Alternatively, you can compile a Scheme source file to a collection
of ‘.class’ files.  You then use the standard Java class loading
mechanism to load the code.  The compiled class files do have to be
installed somewhere in the ‘CLASSPATH’.

* Menu:

* Files compilation::           Compiling to a set of .class files
* Archive compilation::         Compiling to an archive file
* Compiling using Ant::
* Application compilation::     Compiling to a standalone application
* Applet compilation::          Compiling to an applet
* Compiling to executable::     Compiling to a native executable


File: kawa.info,  Node: Files compilation,  Next: Archive compilation,  Up: Compiling

6.5.1 Compiling to a set of .class files
----------------------------------------

Invoking ‘kawa’ (or ‘java kawa.repl’) with the ‘-C’ flag will compile a
‘.scm’ source file into one or more ‘.class’ files:
     kawa --main -C myprog.scm

   You run it as follows:
     kawa [-d OUTDIRECTORY] [-P PREFIX] [-T TOPNAME] [--main | --applet | --servlet] -C INFILE ...

   Note the ‘-C’ must come last, because ‘Kawa’ processes the arguments
and options in order,

   Here:
‘-C INFILE ...’
     The Scheme source files we want to compile.
‘-d OUTDIRECTORY’
     The directory under which the resulting ‘.class’ files will be.
     The default is the current directory.
‘-P PREFIX’
     A string to prepend to the generated class names.  The default is
     the empty string.
‘-T TOPNAME’
     The name of the "top" class - i.e.  the one that contains the code
     for the top-level expressions and definitions.  The default is
     generated from the INFILE and PREFIX.
‘--main’
     Generate a ‘main’ method so that the resulting "top" class can be
     used as a stand-alone application.  *Note Application
     compilation::.
‘--applet’
     The resulting class inherits from ‘java.applet.Applet’, and can be
     used as an applet.  *Note Applet compilation::.
‘--servlet’
     The resulting class implements ‘javax.servlet.http.HttpServlet’,
     and can be used as a servlet in a servlet container like Tomcat.

   When you actually want to load the classes, the OUTDIRECTORY must be
in your ‘CLASSPATH’.  You can use the ‘require’ syntax or the ‘load’
function to load the code, by specifying the top-level class, either as
a file name (relative to OUTDIRECTORY) or as a class name.  E.g.  if you
did:
     kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
   you can use either:
     (require my.lib.foo)
   or:
     (load "my.lib.foo")
   Using ‘require’ is preferred as it imports the definitions from
‘my.lib.foo’ into the compile-time environment, while ‘load’ only
imports the definitions into the run-time environment.

   If you are compiling a Scheme source file (say ‘foosrc.scm’) that
uses macros defined in some other file (say ‘macs.scm’), you need to
make sure the definitions are visible to the compiler.  One way to do
that is with the ‘-f’:
     kawa -f macs.scm -C foosrc.scm

   Many of the options *note described earlier: Options. are relevant
when compiling.  Commonly used options include language selection, the
‘--warn-xxx’ options, and ‘--full-tailcalls’.


File: kawa.info,  Node: Archive compilation,  Next: Compiling using Ant,  Prev: Files compilation,  Up: Compiling

6.5.2 Compiling to an archive file
----------------------------------

 -- Procedure: compile-file source-file compiled-archive
     Compile the SOURCE-FILE, producing a ‘.zip’ archive COMPILED-FILE.

     For example, to byte-compile a file ‘foo.scm’ do:
          (compile-file "foo.scm" "foo")

     This will create ‘foo.zip’, which contains byte-compiled JVM
     ‘.class’ files.  You can move this file around, without worrying
     about class paths.  To load the compiled file, you can later ‘load’
     the named file, as in either ‘(load "foo")’ or ‘(load "foo.zip")’.
     This should have the same effect as loading ‘foo.scm’, except you
     will get the faster byte-compiled versions.


File: kawa.info,  Node: Compiling using Ant,  Next: Application compilation,  Prev: Archive compilation,  Up: Compiling

6.5.3 Compiling using Ant
-------------------------

Many Java projects use Ant (http://ant.apache.org) for building Java
projects.  Kawa includes a ‘<kawac>’ Ant task that simplifies compiling
Kawa source files to classes.  See the ‘build.xml’ in the Kawa source
distribution for examples.  See the ‘kawac’ task documentation
(ant-kawac.html) for details.


File: kawa.info,  Node: Application compilation,  Next: Applet compilation,  Prev: Compiling using Ant,  Up: Compiling

6.5.4 Compiling to a standalone application
-------------------------------------------

A Java application is a Java class with a special method (whose name is
‘main’).  The application can be invoked directly by naming it in the
Java command.  If you want to generate an application from a Scheme
program, create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.

   For example, assuming your Scheme file is ‘MyProgram.scm’, you have
two ways at your disposal to compile this Scheme program to a standalone
application:
  1. Compile in the regular way described in the previous section, but
     add the ‘--main’ option.
          kawa --main -C MyProgram.scm

     The ‘--main’ option will compile all Scheme programs received in
     arguments to standalone applications.
  2. Compile in the regular way decribed in the previous section, but
     add the ‘main: #t’ module compile option to your module.
          ;; MyProgram.scm
          (module-name <myprogram>)
          (module-compile-options main: #t)

          kawa -C MyProgram.scm

     This way you can compile multiple Scheme programs at once, and
     still control which one(s) will compile to standalone
     application(s).

   Both methods will create a ‘MyProgram.class’ which you can either
‘load’ (as described in the previous section), or invoke as an
application:
     java MyProgram [ARGS]
   Your Scheme program can access the command-line arguments ARGS by
using the global variable ‘command-line-arguments’, or the R6RS function
‘command-line’.

   If there is no explicit ‘module-export’ in a module compiled with
‘--main’ then no names are exported.  (The default otherwise is for all
names to be exported.)


File: kawa.info,  Node: Applet compilation,  Next: Compiling to executable,  Prev: Application compilation,  Up: Compiling

6.5.5 Compiling to an applet (obsolete)
---------------------------------------

*Applets are obsolete, not supported by modern browsers, and Kawa
support may be removed at any time.*

   An applet is a Java class that inherits from ‘java.applet.Applet’.
The applet can be downloaded and run in a Java-capable web-browser.  To
generate an applet from a Scheme program, write the Scheme program with
appropriate definitions of the functions ‘init’, ‘start’, ‘stop’ and
‘destroy’.  You must declare these as zero-argument functions with a
‘<void>’ return-type.

   Here is an example, based on the scribble applet in Flanagan’s "Java
Examples in a Nutshell" (O’Reilly, 1997):
     (define-private last-x 0)
     (define-private last-y 0)

     (define (init) :: void
       (let ((applet (this)))
         (applet:addMouseListener
          (object (java.awt.event.MouseAdapter)
     	     ((mousePressed e)
     	      (set! last-x (e:getX))
     	      (set! last-y (e:getY)))))
         (applet:addMouseMotionListener
          (object (java.awt.event.MouseMotionAdapter)
     	     ((mouseDragged e)
     	      (let ((g (applet:getGraphics))
     		    (x (e:getX))
     		    (y (e:getY)))
     		(g:drawLine last-x last-y x y)
     		(set! last-x x)
     		(set! last-y y)))))))

     (define (start) :: void (format #t "called start.~%~!"))
     (define (stop) :: void (format #t "called stop.~%~!"))
     (define (destroy) :: void (format #t "called destroy.~%~!"))

   You compile the program with the ‘--applet’ flag in addition to the
normal ‘-C’ flag:
     java kawa.repl --applet -C scribble.scm

   You can then create a ‘.jar’ archive containing your applet:
     jar cf scribble.jar scribble*.class

   Finally, you create an ‘.html’ page referencing your applet and its
support ‘jar’s:
     <html><head><title>Scribble testapp</title></head>
     <body><h1>Scribble testapp</h1>
     You can scribble here:
     <br>
     <applet code="scribble.class" archive="scribble.jar, kawa-3.1.1.jar" width=200 height=200>
     Sorry, Java is needed.</applet>
     </body></html>

   The problem with using Kawa to write applets is that the Kawa ‘.jar’
file is quite big, and may take a while to download over a network
connection.  Some possible solutions:

   • Try to strip out of the Kawa ‘.jar’ any classes your applet doesn’t
     need.
   • Java 2 provides a mechanism to install a download extension
     (http://java.sun.com/docs/books/tutorial/ext/basics/download.html).
   • Consider some alternative to applets, such as Java Web Start
     (http://java.sun.com/products/javawebstart/).


File: kawa.info,  Node: Compiling to executable,  Prev: Applet compilation,  Up: Compiling

6.5.6 Compiling to a native executable
--------------------------------------

In the past it was possible to compile a Scheme program to native code
using GCJ. However, using GCJ with Kawa is no longer supported, as GCJ
is no longer being actively maintained.


File: kawa.info,  Node: Syntax,  Next: Program structure,  Prev: Running,  Up: Top

7 Syntax
********

* Menu:

* Syntax notation::
* Lexical and datum syntax::
* Lexical syntax::
* Datum syntax::
* Hash-prefixed forms::
* Primitive expression syntax::
* Colon notation:: Property access using colon notation
* Bodies::
* Syntax and conditional compilation::
* Macros::
* Named quasi-literals::


File: kawa.info,  Node: Syntax notation,  Next: Lexical and datum syntax,  Up: Syntax

7.1 Notation
============

The formal syntax for Kawa Scheme is written in an extended BNF.
Non–terminals are written LIKE-THIS.  Case is insignificant for
non–terminal names.  Literal text (terminals) are written ‘like this’.

   All spaces in the grammar are for legibility.

   The following extensions to BNF are used to make the description more
concise: THING^{*} or THING‘...’ both mean zero or more occurrences of
THING, and THING^{+} means at least one THING.

   Some non-terminal names refer to the Unicode scalar values of the
same name: CHARACTER-TABULATION (U+0009), LINEFEED (U+000A),
CARRIAGE-RETURN (U+000D), LINE-TABULATION (U+000B), FORM-FEED (U+000C),
SPACE (U+0020), NEXT-LINE (U+0085), LINE-SEPARATOR (U+2028), and
PARAGRAPH-SEPARATOR (U+2029).


File: kawa.info,  Node: Lexical and datum syntax,  Next: Lexical syntax,  Prev: Syntax notation,  Up: Syntax

7.2 Lexical and datum syntax
============================

The syntax of Scheme code is organized in three levels:

  1. the _lexical syntax_ that describes how a program text is split
     into a sequence of lexemes,

  2. the _datum syntax_, formulated in terms of the lexical syntax, that
     structures the lexeme sequence as a sequence of _syntactic data_,
     where a syntactic datum is a recursively structured entity,

  3. the _program syntax_ formulated in terms of the datum syntax,
     imposing further structure and assigning meaning to syntactic data.

   Syntactic data (also called _external representations_) double as a
notation for objects, and the ‘read’ and ‘write’ procedures can be used
for reading and writing syntactic data, converting between their textual
representation and the corresponding objects.  Each syntactic datum
represents a corresponding _datum value_.  A syntactic datum can be used
in a program to obtain the corresponding datum value using ‘quote’.

   Scheme source code consists of syntactic data and (non–significant)
comments.  Syntactic data in Scheme source code are called _forms_.  (A
form nested inside another form is called a _subform_.)  Consequently,
Scheme’s syntax has the property that any sequence of characters that is
a form is also a syntactic datum representing some object.  This can
lead to confusion, since it may not be obvious out of context whether a
given sequence of characters is intended to be a representation of
objects or the text of a program.  It is also a source of power, since
it facilitates writing programs such as interpreters or compilers that
treat programs as objects (or vice versa).

   A datum value may have several different external representations.
For example, both ‘#e28.000’ and ‘#x1c’ are syntactic data representing
the exact integer object 28, and the syntactic data ‘(8 13)’, ‘( 08 13
)’, ‘(8 . (13 . ()))’ all represent a list containing the exact integer
objects 8 and 13.  Syntactic data that represent equal objects (in the
sense of ‘equal?’) are always equivalent as forms of a program.

   Because of the close correspondence between syntactic data and datum
values, we sometimes uses the term _datum_ for either a syntactic datum
or a datum value when the exact meaning is apparent from the context.


File: kawa.info,  Node: Lexical syntax,  Next: Datum syntax,  Prev: Lexical and datum syntax,  Up: Syntax

7.3 Lexical syntax
==================

The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non–significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the Unicode standard (http://unicode.org/).  Some of the lexemes,
such as identifiers, representations of number objects, strings etc., of
the lexical syntax are syntactic data in the datum syntax, and thus
represent objects.  Besides the formal account of the syntax, this
section also describes what datum values are represented by these
syntactic data.

   The lexical syntax, in the description of comments, contains a
forward reference to DATUM, which is described as part of the datum
syntax.  Being comments, however, these DATUMs do not play a significant
role in the syntax.

   Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, ‘#x1A’ and ‘#X1a’ are equivalent.  The identifier ‘Foo’ is,
however, distinct from the identifier ‘FOO’.

7.3.1 Formal account
--------------------

INTERLEXEME-SPACE may occur on either side of any lexeme, but not within
a lexeme.

   IDENTIFIERs, ‘.’, NUMBERs, CHARACTERs, and BOOLEANs, must be
terminated by a DELIMITER or by the end of the input.

     LEXEME ::= IDENTIFIER | BOOLEAN | NUMBER
              | CHARACTER | STRING
              | ‘(’ |  ‘)’ |  ‘[’ |  ‘]’ |  ‘#(’
              | ‘’’ | ‘‘’ | ‘,’ | ‘,@’ | ‘.’
              | ‘#’’ |  ‘#‘’ |  ‘#,’ |  ‘#,@’
     DELIMITER ::= ‘(’ |  ‘)’ |  ‘[’ | ‘]’ | ‘"’ | ‘;’ | ‘#’
              | WHITESPACE

   ((UNFINISHED))

7.3.2 Line endings
------------------

Line endings are significant in Scheme in single–line comments and
within string literals.  In Scheme source code, any of the line endings
in LINE-ENDING marks the end of a line.  Moreover, the two–character
line endings CARRIAGE-RETURN LINEFEED and CARRIAGE-RETURN NEXT-LINE each
count as a single line ending.

   In a string literal, a LINE-ENDING not preceded by a ‘\’ stands for a
linefeed character, which is the standard line–ending character of
Scheme.

7.3.3 Whitespace and comments
-----------------------------

     INTRALINE-WHITESPACE ::= SPACE | CHARACTER-TABULATION
     WHITESPACE ::=  INTRALINE-WHITESPACE
              | LINEFEED | LINE-TABULATION | FORM-FEED
              | CARRIAGE-RETURN | NEXT-LINE
              | any character whose category is Zs, Zl, or Zp
     LINE-ENDING ::= LINEFEED | CARRIAGE RETURN
              | CARRIAGE-RETURN LINEFEED | NEXT-LINE
              | CARRIAGE-RETURN NEXT-LINE | LINE-SEPARATOR
     COMMENT ::=  ‘;’ all subsequent characters up to a LINE-ENDING
                     or PARAGRAPH-SEPARATOR
              | NESTED-COMMENT
              | ‘#;’ INTERLEXEME-SPACE DATUM
              | SHEBANG-COMMENT
     NESTED-COMMENT ::=  ‘#|’ COMMENT-TEXT COMMENT-CONT* ‘|#’
     COMMENT-TEXT ::= character sequence not containing ‘#|’ or ‘|#’
     COMMENT-CONT ::= NESTED-COMMENT COMMENT-TEXT
     ATMOSPHERE ::= WHITESPACE | COMMENT
     INTERLEXEME-SPACE ::= ATMOSPHERE^{*}

   As a special case the characters ‘#!/’ are treated as starting a
comment, but only at the beginning of file.  These characters are used
on Unix systems as an Shebang interpreter directive
(http://en.wikipedia.org/wiki/Shebang_(Unix)).  The Kawa reader skips
the entire line.  If the last non-whitespace character is ‘\’
(backslash) then the following line is also skipped, and so on.
     SHEBANG-COMMENT ::= ‘#!’ ABSOLUTE-FILENAME text up to non-escaped LINE-ENDING

_Whitespace_ characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

   The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

   A semicolon (‘;’) indicates the start of a line comment.  The comment
continues to the end of the line on which the semicolon appears.

   Another way to indicate a comment is to prefix a DATUM with ‘#;’,
possibly with INTERLEXEME-SPACE before the DATUM.  The comment consists
of the comment prefix ‘#;’ and the DATUM together.  This notation is
useful for “commenting out” sections of code.

   Block comments may be indicated with properly nested ‘#|’ and ‘|#’
pairs.
     #|
        The FACT procedure computes the factorial of a
        non-negative integer.
     |#
     (define fact
       (lambda (n)
         ;; base case
         (if (= n 0)
             #;(= n 1)
             1       ; identity of *
             (* n (fact (- n 1))))))

7.3.4 Identifiers
-----------------

     IDENTIFIER ::= INITIAL SUBSEQUENT*
              | PECULIAR-IDENTIFIER
     INITIAL ::= CONSTITUENT | SPECIAL-INITIAL
              | INLINE-HEX-ESCAPE
     LETTER ::= ‘a’ | ‘b’ | ‘c’ | ... | ‘z’
              | ‘A’ | ‘B’ | ‘C’ | ... | ‘Z’
     CONSTITUENT ::= LETTER
              | any character whose Unicode scalar value is greater than
                  127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
                  Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co
     SPECIAL-INITIAL ::= ‘!’ | ‘$’ | ‘%’ | ‘&’ | ‘*’ | ‘/’ | ‘<’ | ‘=’
              | ‘>’ | ‘?’ | ‘^’ | ‘_’ | ‘~’
     SUBSEQUENT ::= INITIAL | DIGIT
              | any character whose category is Nd, Mc, or Me
              | SPECIAL-SUBSEQUENT
     DIGIT ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’ | ‘8’ | ‘9’
     OCT-DIGIT ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’
     HEX-DIGIT ::= DIGIT
              | ‘a’ | ‘A’ | ‘b’ | ‘B’ | ‘c’ | ‘C’ | ‘d’ | ‘D’ | ‘e’ | ‘E’ | ‘f’ | ‘F’
     SPECIAL-SUBSEQUENT ::= ‘+’ | ‘-’ | ‘.’ | ‘@’
     ESCAPE-SEQUENCE ::= INLINE-HEX-ESCAPE
              | ‘\’CHARACTER-EXCEPT-X
              | MULTI-ESCAPE-SEQUENCE
     INLINE-HEX-ESCAPE ::= ‘\x’HEX-SCALAR-VALUE‘;’
     HEX-SCALAR-VALUE ::= HEX-DIGIT+
     MULTI-ESCAPE-SEQUENCE ::= ‘|’SYMBOL-ELEMENT^{*}‘|’
     SYMBOL-ELEMENT ::=  any character except ‘|’ or ‘\’
              | INLINE-HEX-ESCAPE | MNEMONIC-ESCAPE | ‘\|’

     CHARACTER-EXCEPT-X ::= any character except ‘x’
     PECULIAR-IDENTIFIER ::= ‘+’ | ‘-’ | ‘...’ | ‘->’ SUBSEQUENT^{*}

   Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
“extended alphabetic characters” is an identifier when it begins with a
character that cannot begin a representation of a number object.  In
addition, ‘+’, ‘-’, and ‘...’ are identifiers, as is a sequence of
letters, digits, and extended alphabetic characters that begins with the
two–character sequence ‘->’.  Here are some examples of identifiers:

     lambda         q                soup
     list->vector   +                V17a
     <=             a34kTMNs         ->-
     the-word-recursion-has-many-meanings

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

     ! $ % & * + - . / < = > ? @ ^ _ ~

   Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified using an ESCAPE-SEQUENCE.  For example, the
identifier ‘H\x65;llo’ is the same as the identifier ‘Hello’.

   Kawa supports two additional non-R6RS ways of making identifiers
using special characters, both taken from Common Lisp: Any character
(except ‘x’) following a backslash is treated as if it were a LETTER; as
is any character between a pair of vertical bars.

   Identifiers have two uses within Scheme programs:
   • Any identifier may be used as a *note variable: variable-reference.
     or as a *note syntactic keyword: macro-reference.
   • When an identifier appears as or with in *note literal:
     literal-expression, it is being used to denote a *note symbol:
     Simple symbols.

   In contrast with older versions of Scheme, the syntax distinguishes
between upper and lower case in identifiers and in characters specified
via their names, but not in numbers, nor in inline hex escapes used in
the syntax of identifiers, characters, or strings.  The following
directives give explicit control over case folding.

 -- Syntax: #!fold-case
 -- Syntax: #!no-fold-case

     These directives may appear anywhere comments are permitted and are
     treated as comments, except that they affect the reading of
     subsequent data.  The ‘#!fold-case’ directive causes the ‘read’
     procedure to case-fold (as if by ‘string-foldcase’) each identifier
     and character name subsequently read from the same port.  The
     ‘#!no-fold-case’ directive causes the ‘read’ procedure to return to
     the default, non-folding behavior.

   Note that colon ‘:’ is treated specially for *note colon notation:
Colon notation. in Kawa Scheme, though it is a SPECIAL-INITIAL in
standard Scheme (R6RS).

7.3.5 Numbers
-------------

((INCOMPLETE))

     NUMBER ::= ((TODO))
       | QUANTITY
     DECIMAL ::= DIGIT+ OPTIONAL-EXPONENT
       | ‘.’ DIGIT+ OPTIONAL-EXPONENT
       | DIGIT+ ‘.’ DIGIT+ OPTIONAL-EXPONENT

     OPTIONAL-EXPONENT ::= empty
       | EXPONENT-MARKER OPTIONAL-SIGN DIGIT+
     EXPONENT-MARKER ::= ‘e’ | ‘s’ | ‘f’ | ‘d’ | ‘l’
   The letter used for the exponent in a floating-point literal
determines its type:
‘e’
     Returns a ‘gnu.math.DFloat’ - for example ‘12e2’.  Note this
     matches the default when there is no EXPONENT-MARKER.
‘s’ or ‘f’
     Returns a primitive ‘float’ (or ‘java.lang.Float’ when boxed as an
     object) - for example ‘12s2’ or ‘12f2’.
‘d’
     Returns a primitive ‘double’ (or ‘java.lang.Double’ when boxed) -
     for example ‘12d2’.
‘l’
     Returns a ‘java.math.BigDecimal’ - for example ‘12l2’.
     OPTIONAL-SIGN ::= empty | ‘+’ | ‘-’
     DIGIT-2 ::= ‘0’ | ‘1’
     DIGIT-8 ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’
     DIGIT-10 ::= DIGIT
     DIGIT-16 ::= DIGIT-10 | ‘a’ | ‘b’ | ‘c’ | ‘d’ | ‘e’ | ‘f’

