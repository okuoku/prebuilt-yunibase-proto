This is vicare-typed.info, produced by makeinfo version 6.5 from
vicare-typed.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.  The focus of this document is
over the typed language extension.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2016-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-typed: (vicare-typed). Vicare Scheme's Typed Language.
END-INFO-DIR-ENTRY


File: vicare-typed.info,  Node: built-in ports labels texou,  Prev: built-in ports labels texin,  Up: built-in ports labels

6.23.8.9 Textual output port labels
...................................

 -- Label Type: <textual-input-port>
     Label-type for all the textual ports.  Its parent is the type
     annotation:

          (or <textual-input-only-port> <textual-input/output-port>)

 -- Constructor on '<textual-input-port>': <textual-input-port>
          type-constructor PORT
     Validate PORT as instance of '<textual-input-port>' and return it.

 -- Type predicate on '<textual-input-port>': <boolean> type-predicate
          OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<textual-input-port>': <boolean>
          equality-predicate THIS {PORT <textual-input-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<textual-input-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<textual-output-port>': <boolean> open? THIS
 -- Method on '<textual-output-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<textual-output-port>': () set-non-blocking-mode THIS
 -- Method on '<textual-output-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<textual-output-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<textual-output-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<textual-output-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<textual-output-port>': <non-negative-exact-integer>
          position THIS
 -- Method on '<textual-output-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<textual-output-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<textual-output-port>': (or <false> <file-descriptor>) fd
          THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<textual-output-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<textual-output-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<textual-output-port>': (or <transcoder> <false>)
          transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<textual-output-port>': () putprop THIS {KEY <symbol>}
          VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<textual-output-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<textual-output-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<textual-output-port>': (alist <symbol> <top>)
          property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<textual-output-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<textual-output-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: output ports
.....................

 -- Method on '<textual-output-port>': () flush THIS
     Apply 'flush-output-port' to the instance.


File: vicare-typed.info,  Node: built-in ports misc,  Prev: built-in ports labels,  Up: built-in ports

6.23.9 Miscellaneous types
--------------------------

 -- Core Type: <reader-input-port-mode>
     Scheme reader mode for textual input ports.  Its definition is
     equivalent to:

          (define-type <reader-input-port-mode>
            (enumeration vicare r6rs))

 -- Type annotation: <output-port-buffer-mode>
     Buffer mode for output ports.  Its definition is equivalent to:

          (define-type <output-port-buffer-mode>
            (enumeration none line block))


File: vicare-typed.info,  Node: built-in enum-set,  Next: built-in time,  Prev: built-in ports,  Up: built-in

6.24 Type of enumeration sets
=============================

 -- Core Type: <enum-set>
 -- Parent Type: <struct>
     Type of enumeration sets as defined by R6RS.

 -- Type constructor on '<enum-set>': <enum-set> type-constructor
          SYMBOL-LIST
     The constructor is 'make-enumeration'.

 -- Type predicate on '<enum-set>': <boolean> type-predicate OBJ
     The type predicate is 'enum-set?'.

 -- Equality predicate on '<enum-set>': <boolean> equality-predicate
          THIS {ES <enum-set>}
     The equality predicate is 'enum-set=?'.

 -- Hash function on '<enum-set>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'enum-set-hash'.

Auxiliary types
...............

 -- Core Type: <enum-set-indexer>
     A type annotation with the following definition:

          (lambda (<symbol>) => ((or <false> <non-negative-fixnum>)))

 -- Core Type: <enum-set-constructor>
     A type annotation with the following definition:

          (lambda ((list-of <symbol>)) => (<enum-set>))

Methods: constructors
.....................

 -- Method on '<enum-set>': <enum-set> universe THIS
     Apply 'enum-set-universe' to the arguments and return its return
     value.

 -- Method on '<enum-set>': <enum-set-indexer> indexer THIS
     Apply 'enum-set-indexer' to the arguments and return its return
     value.

 -- Method on '<enum-set>': <enum-set-constructor> constructor THIS
     Apply 'enum-set-constructor' to the arguments and return its return
     value.

 -- Method on '<enum-set>': (list-of <symbol>) list THIS
     Apply 'enum-set->list' to the arguments and return its return
     value.

Methods: comparison
...................

Notice that '<symbol>' has a method 'member?' that applies
'enum-set-member?' to its arguments.

 -- Method on '<enum-set>': <boolean> subset? THIS {ES <enum-set>}
     Apply 'enum-set-subset?' to the arguments and return its return
     value.

 -- Method on '<enum-set>': <boolean> = THIS {ES <enum-set>}
     Apply 'enum-set=?' to the arguments and return its return value.

Methods: set operations
.......................

 -- Method on '<enum-set>': <enum-set> union THIS {ES <enum-set>}
     Apply 'enum-set-union' to the arguments and return its return
     value.

 -- Method on '<enum-set>': <enum-set> intersection THIS {ES <enum-set>}
     Apply 'enum-set-intersection' to the arguments and return its
     return value.

 -- Method on '<enum-set>': <enum-set> difference THIS {ES <enum-set>}
     Apply 'enum-set-difference' to the arguments and return its return
     value.

 -- Method on '<enum-set>': <enum-set> complement THIS
     Apply 'enum-set-complement' to the arguments and return its return
     value.

 -- Method on '<enum-set>': <enum-set> projection THIS {ES <enum-set>}
     Apply 'enum-set-projection' to the arguments and return its return
     value.


File: vicare-typed.info,  Node: built-in time,  Next: built-in promises,  Prev: built-in enum-set,  Up: built-in

6.25 Type of time objects
=========================

* Menu:

* built-in time time::          Time spans object-type.
* built-in time epoch::         Time spans since the Epoch.


File: vicare-typed.info,  Node: built-in time time,  Next: built-in time epoch,  Up: built-in time

6.25.1 Time spans object-type
-----------------------------

 -- Built-in Type: <time>
 -- Parent Type: <record>
     Type name of time objects.  It can represent both absolute times
     (typically elapsed times since the Epoch) and positive and negative
     time spans relative to an arbitrary origin.  The internal time
     representation has nanosecond resolution and it is immutable.

Operations
..........

 -- Constructor on <time>: <time> constructor {SECONDS <exact-integer>}
          {NANOSECONDS <exact-integer>}
 -- Constructor on <time>: <time> constructor {MEGASECONDS
          <exact-integer>} {SECONDS <exact-integer>} {NANOSECONDS
          <exact-integer>}
     Build and return a new '<time>' object.  If NANOSECONDS exceeds
     '#e1e9' its value is normalised and the excess added to SECONDS.
     If SECONDS exceeds '#e1e6' its value is normalised and the excess
     added to MEGASECONDS.

 -- Type predicate on <time>: <boolean> type-predicate OBJ
     Return '#t' if OBJ is a '<time>' object; otherwise return '#f'.

 -- Equality predicate on <time>: <boolean> equality-predicate THIS {T
          <time>}
     Return '#t' if the '<time>' objects are true, otherwise return
     '#f'.  This equality predicate is used by 'equal?'.

 -- Comparison procedure on <time>: <fixnum> comparison-procedure THIS
          {T <time>}
     Return '-1' if T1 is less than T2; return '0' if T1 is equal to T2;
     return '+1' if T1 is greater than T2.

 -- Hash function on <time>: <fixnum> hash-function THIS
     Return a non-negative fixnum representing the hash value for T.
     This hash function is used by the syntax 'hash'.

Accessors
.........

 -- Method on <time>: <exact-integer> seconds THIS
     The number of seconds in the represented time span.

 -- Method on <time>: <fixnum> nanoseconds THIS
     The number of nanoseconds in the represented time span.

 -- Method on <time>: <ratnum> ratnum THIS
 -- Method on <time>: <flonum> flonum THIS
     Return a real number representing the time in seconds.  This single
     number is built from seconds and nanoseconds.

Arithmetics
...........

 -- Method on <time>: <time> + THIS {T <time>} ...
     Compute the addition between time objects: 'THIS + T + ...' and
     return a time object representing it.

 -- Method on <time>: <time> - THIS {T <time>} ...
     When only the instance THIS is given: return the negation of the
     time object.  When additional arguments T are given, compute the
     difference between time objects: 'THIS - (T + ...)' and return a
     time object representing it.

Time comparison
...............

 -- Method on <time>: <boolean> = THIS {T <time>} ...
     Return '#t' if the time objects are equal, else return '#f'.

 -- Method on <time>: <boolean> != THIS {T <time>} ...
     Return '#t' if the arguments are all different: no two arguments
     are equal; otherwise return '#f'.  When THIS is the only argument:
     return '#f'.

 -- Method on <time>: <boolean> < THIS {T <time>} ...
     Return '#t' if the time objects are monotonically increasing; else
     return '#f'.

 -- Method on <time>: <boolean> <= THIS {T <time>} ...
     Return '#t' if the time objects are monotonically non-decreasing;
     else return '#f'.

 -- Method on <time>: <boolean> > THIS {T <time>} ...
     Return '#t' if the time objects are monotonically decreasing; else
     return '#f'.

 -- Method on <time>: <boolean> >= THIS {T <time>} ...
     Return '#t' if the time objects are monotonically non-increasing;
     else return '#f'.

 -- Method on <time>: <boolean> max THIS {T <time>} ...
 -- Method on <time>: <boolean> min THIS {T <time>} ...
     Return the maximum or minimum between the arguments.


File: vicare-typed.info,  Node: built-in time epoch,  Prev: built-in time time,  Up: built-in time

6.25.2 Time spans since the Epoch
---------------------------------

 -- Built-in Type: <epoch-time>
 -- Parent Type: <time>
     Type name of time objects representing the time elapsed since the
     Epoch.  The time is internally represented with nanosecond
     resolution.

     Objects of this type representing the current time are returned by
     the function 'epoch-time' and built using the POSIX function
     'clock_gettime()' with the argument 'CLOCK_REALTIME'; *note Clock
     and time functions: (*manpages*)clock_gettime.

 -- Constructor on <epoch-time>: <epoch-time> constructor {SECONDS
          <exact-integer>} {NANOSECONDS <fixnum>}
     Build and return a new '<epoch-time>' object.  The arguments are
     normalised as explained for the constructor of '<time>'.

 -- Type predicate on <epoch-time>: <boolean> type-predicate OBJ
     Return '#t' if OBJ is a '<epoch-time>' object; otherwise return
     '#f'.

 -- Method on <epoch-time>: <epoch-time> + THIS {T <time>}
     Add T to THIS and return the result.

 -- Method on <epoch-time>: <epoch-time> - THIS {T <time>}
     Subtract T from THIS and return the result.


File: vicare-typed.info,  Node: built-in promises,  Next: built-in utsname,  Prev: built-in time,  Up: built-in

6.26 Type of promise objects
============================

 -- Core Type: <promise>
 -- Parent Type: <struct>
     Type of promises.

 -- Type constructor on '<promise>': <promise> type-constructor THUNK
     Build and return a new '<promise>' object using THUNK to generate
     the value.  The code:

          (delay 3)

     is equivalent to:

          (new <promise> (lambda () 3))

 -- Type predicate on '<promise>': <boolean> type-predicate OBJ
     The type predicate is 'promise?'.

 -- Equality predicate on '<promise>': <boolean> equality-predicate THIS
          {PROM <promise>}
     The equality predicate is 'eq?'.

 -- Hash function on '<promise>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'promise-hash'.

Methods
.......

 -- Method on '<promise>': <top> force THIS
     Apply 'force' to the instance and return its return value.


File: vicare-typed.info,  Node: built-in utsname,  Next: built-in memory-block,  Prev: built-in promises,  Up: built-in

6.27 Type of utsname objects
============================

 -- Core Type: <utsname>
 -- Parent Type: <struct>
     Type of object used to represent the informations returned by the
     POSIX function 'uname()'.

 -- Type constructor on '<utsname>': <utsname> type-constructor
     The type constructor is 'uname'.

 -- Type predicate on '<utsname>': <boolean> type-predicate OBJ
     The type predicate is 'utsname?'.

 -- Equality predicate on '<utsname>': <boolean> equality-predicate THIS
          {NAME <utsname>}
     The equality predicate is 'utsname=?'.

 -- Hash function on '<utsname>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'struct-hash'.

Methods
.......

 -- Method on '<utsname>': <string> sysname THIS
     Apply 'utsname-sysname' to the instance and return its return
     value.

 -- Method on '<utsname>': <string> nodename THIS
     Apply 'utsname-nodename' to the instance and return its return
     value.

 -- Method on '<utsname>': <string> release THIS
     Apply 'utsname-release' to the instance and return its return
     value.

 -- Method on '<utsname>': <string> version THIS
     Apply 'utsname-version' to the instance and return its return
     value.

 -- Method on '<utsname>': <string> machine THIS
     Apply 'utsname-machine' to the instance and return its return
     value.


File: vicare-typed.info,  Node: built-in memory-block,  Next: built-in reader-annotation,  Prev: built-in utsname,  Up: built-in

6.28 Type of memory block objects
=================================

 -- Core Type: <memory-block>
 -- Parent Type: <struct>
     Type of objects representing memory blocks.

 -- Type constructor on '<memory-block>': <memory-block>
          type-constructor POINTER SIZE
     The type constructor is 'make-memory-block'.

 -- Type predicate on '<memory-block>': <boolean> type-predicate OBJ
     The type predicate is 'memory-block?'.

 -- Equality predicate on '<memory-block>': <boolean> equality-predicate
          THIS {MB <memory-block>}
     The equality predicate is 'memory-block=?'.

 -- Hash function on '<memory-block>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'struct-hash'.

Methods
.......

 -- Method on '<memory-block>': <pointer> pointer THIS
     Apply 'memory-block-pointer' to the instance and return its return
     value.

 -- Method on '<memory-block>': <non-negative-exact-integer> size THIS
     Apply 'memory-block-size' to the instance and return its return
     value.

 -- Method on '<memory-block>': <void> reset THIS
     Apply 'memory-block-reset' to the instance.


File: vicare-typed.info,  Node: built-in reader-annotation,  Next: built-in stats,  Prev: built-in memory-block,  Up: built-in

6.29 Type of reader annotation objects
======================================

 -- Core type: '<reader-annotation>'
 -- Parent Type: <struct>
     Type representing source code read from a textual input port, with
     annotations about the position in the source file.

 -- Type constructor on '<reader-annotation>': <reader-annotation>
          type-constructor {PORT <textual-input-port>}
     The type constructor is 'get-annotated-datum'.

 -- Type predicate on '<reader-annotation>': <boolean> type-predicate
          OBJ
     The type predicate is 'reader-annotation?'.

 -- Equality predicate on '<reader-annotation>': <boolean>
          equality-predicate THIS {ANN <reader-annotation>}
     The equality predicate is 'struct=?'.

 -- Hash function on '<reader-annotation>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'struct-hash'.

Methods
.......

 -- Method on '<reader-annotation>': <top> expression THIS
     Apply 'reader-annotation-expression' to the instance and return its
     return value.

 -- Method on '<reader-annotation>': '<top>' stripped THIS
     Apply 'reader-annotation-stripped' to the instance and return its
     return value.

 -- Method on '<reader-annotation>': &source-position textual-position
          THIS
     Apply 'reader-annotation-textual-position' to the instance and
     return its return value.

 -- Method on '<reader-annotation>': '<reader-annotation>' source THIS
     Apply 'reader-annotation-source' to the instance and return its
     return value.


File: vicare-typed.info,  Node: built-in stats,  Next: built-in misc,  Prev: built-in reader-annotation,  Up: built-in

6.30 Type of stats objects
==========================

 -- Core Type: <stats>
 -- Parent Type: <struct>
     Type of objects representing expression evaluation statistics.

 -- Type constructor on '<stats>': <stats> type-constructor OBJ
     Validate OBJ as instance of '<stats>' and return it.

 -- Type predicate on '<stats>': <boolean> type-predicate OBJ
     The type predicate is 'stats?'.

 -- Equality predicate on '<stats>': <boolean> equality-predicate THIS
          {STATS <stats>}
     The equality predicate is 'struct=?'.

 -- Hash function on '<stats>': <non-negative-fixnum> hash-function THIS
     The hash function is 'struct-hash'.

Methods
.......

 -- Method on '<stats>': <non-negative-exact-integer> user-secs THIS
     Apply 'stats-user-secs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> user-usecs THIS
     Apply 'stats-user-usecs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> sys-secs THIS
     Apply 'stats-sys-secs' to the instance and return its return value.

 -- Method on '<stats>': <non-negative-exact-integer> sys-usecs THIS
     Apply 'stats-sys-usecs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> real-secs THIS
     Apply 'stats-real-secs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> real-usecs THIS
     Apply 'stats-real-usecs' to the instance and return its return
     value.

 -- Method on '<stats>': <top> collection-id THIS
     Apply 'stats-collection-id' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> gc-user-secs THIS
     Apply 'stats-gc-user-secs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> gc-user-usecs THIS
     Apply 'stats-gc-user-usecs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> gc-sys-secs THIS
     Apply 'stats-gc-sys-secs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> gc-sys-usecs THIS
     Apply 'stats-gc-sys-usecs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> gc-real-secs THIS
     Apply 'stats-gc-real-secs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> gc-real-usecs THIS
     Apply 'stats-gc-real-usecs' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> bytes-minor THIS
     Apply 'stats-bytes-minor' to the instance and return its return
     value.

 -- Method on '<stats>': <non-negative-exact-integer> bytes-major THIS
     Apply 'stats-bytes-major' to the instance and return its return
     value.


File: vicare-typed.info,  Node: built-in misc,  Prev: built-in stats,  Up: built-in

6.31 Miscellaneous built-in types
=================================

 -- Type annotation: <&who-value>
     The type of the field in the built-in condition object type '&who'.
     Its definition is equivalent to:

          (define-type <&who-value>
            (or <false> <symbol> <string>))

 -- Type annotation: <file-descriptor>
     The type of file descriptor values.  Its definition is equivalent
     to:

          (define-type <file-descriptor>
            <non-negative-fixnum>)

 -- Type annotation: <type-descriptor>
     Type annotation of type descriptors.  Its definition is equivalent
     to:

          (define-type <type-descriptor>
            (or <core-type-descriptor> <struct-type-descriptor>
                <record-type-descriptor> <record-constructor-descriptor>
                <pair-type-descr> <pair-of-type-descr>
                <list-type-descr> <list-of-type-descr>
                <vector-type-descr>
                <vector-of-type-descr>
                <nevector-of-type-descr>
                <enumeration-type-descr>
                <closure-type-descr>
                <ancestor-of-type-descr>
                <hashtable-type-descr>
                <alist-type-descr>
                <union-type-descr>
                <intersection-type-descr>
                <complement-type-descr>
                <interface-type-descr>))


File: vicare-typed.info,  Node: methods,  Next: protlev,  Prev: built-in,  Up: Top

7 Methods and virtual methods
*****************************

Methods are possibly overloaded typed functions whose syntactic binding
resides in a namespace reserved to an object-type and that are
accessible only through an instance of such object-type.

   The syntactic bindings 'method', 'virtual-method' and 'seal-method'
are used as clause keywords in uses of 'define-record-type' to define
methods and virtual methods for a record-type; they can be used any
number of times in the same 'define-record-type' macro use.

   The clause 'method' is also accepted by 'define-label-type',
'define-interface-type' and 'define-mixin-type'.

   The clauses 'virtual-method' and 'seal-method' are also accepted by
'define-mixin-type'.

* Menu:

* methods concrete::      Concrete methods.
* methods virtual::       Virtual methods.
* methods sealing::       Sealing methods.
* methods calling::       Calling object-type methods.


File: vicare-typed.info,  Node: methods concrete,  Next: methods virtual,  Up: methods

7.1 Concrete methods
====================

We can think of 'method' as acting like 'define/checked' with regard to
the syntax of arguments to function; the first argument to a method is
the record itself, but it is implicit: we can access it using the fluid
syntax 'this'.  For example, using the procedural coding style:

     (define-record-type <duo>
       (strip-angular-parentheses)
       (fields one two)
       (method (sum-them)
         (+ (duo-one this)
            (duo-two this)))
       (method (mul-them)
         (* (duo-one this)
            (duo-two this))))

     (define O
       (make-duo 1 2))

     (method-call sum-them O)        => 3

and using the object-oriented syntax style:

     (define-record-type <duo>
       (fields one two)
       (method (sum-them)
         (+ (.one this)
            (.two this)))
       (method (mul-them)
         (* (.one this)
            (.two this))))

     (define O
       (new <duo> 1 2))

     (.sum-them O)   => 3

   The syntax 'method-call' searches for a record-type's methods by
using 'eq?' to search for the method's name, as symbol, in the
record-type's internal table of methods (it does *not* use the syntactic
identifiers with 'free-identifier=?').  *note Calling object-type
methods: methods calling.

* Menu:

* methods concrete overloaded::  Overloaded methods.
* methods concrete fields::      Field methods.
* methods concrete override::    Overriding methods.


File: vicare-typed.info,  Node: methods concrete overloaded,  Next: methods concrete fields,  Up: methods concrete

7.1.1 Overloaded methods
------------------------

The clause 'method' allows the definition of overloaded functions, with
multiple function specialisations associated to the same method name.
Example:

     (define-record-type <alpha>
       (fields a b)

       (method ({doit <list>} {A <fixnum>})
         (list (.a this) (.b this) 'fixnum A))

       (method ({doit <list>} {A <symbol>})
         (list (.a this) (.b this) 'symbol A))

       (method ({doit <list>} {A <number>} {B <number>})
         (list (.a this) (.b this) 'numbers A B)))

     (define O
       (new <alpha> 1 2))

     (.doit O 123)           => (1 2 fixnum 123)
     (.doit O 'ciao)         => (1 2 symbol ciao)
     (.doit O 3 4)           => (1 2 numbers 3 4)

we can think of the methods defined above as expanding to the following
definitions:

     (define/overload ({doit <list>} {subject <alpha>}
                           {A <fixnum>})
       (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
         (list (.a this) (.b this) 'fixnum A)))

     (define/overload ({doit <list>} {subject <alpha>}
                           {A <symbol>})
       (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
         (list (.a this) (.b this) 'symbol A)))

     (define/overload ({doit <list>} {subject <alpha>}
                           {A <number>} {B <number>})
       (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
         (list (.a this) (.b this) 'numbers A B)))

where SUBJECT is a non-accessible identifier.


File: vicare-typed.info,  Node: methods concrete fields,  Next: methods concrete override,  Prev: methods concrete overloaded,  Up: methods concrete

7.1.2 Field methods
-------------------

When methods are defined for record-types: method names cannot be equal
to field names; field accessors and mutators are accessible as methods
automatically, with a method name equal to the field name.  The syntax
of 'method-call' is:

     (method-call ?NAME ?SUBJECT-EXPR ?ARG ...)

when there are no ?ARG operand the syntax is compatible with a field
accessor call; when there is a single ?ARG operand the syntax is
compatible with a field mutator call.

   So we can access and mutate fields as follows:

     (define-record-type <alpha>
       (fields (mutable a)))

     (define O
       (new <alpha> 1))

     (.a O)          => 1
     (.a O 2)
     (.a O)          => 2


File: vicare-typed.info,  Node: methods concrete override,  Prev: methods concrete fields,  Up: methods concrete

7.1.3 Overriding methods
------------------------

When a hierarchy of record-types is defined: the sub-types can override
the super-type's concrete methods by defining methods with the same
name.  Example:

     (define-record-type <super>
       (method (doit)
         1))

     (define-record-type <sub>
       (parent <super>)
       (method (doit)
         2))

     (define (super-fun {O <super>})
       (.doit O))

     (define (sub-fun   {O <sub>})
       (.doit O))

     (define O
       (new <sub>))

     (super-fun O)   => 1
     (sub-fun   O)   => 2

   The method of the super-type is still accessible if we "see" the
object instance through the super-type's type specification.

   The sub-type's method is in no way limited by the super-type's
method: the two methods are allowed to have completely different type
signatures.


File: vicare-typed.info,  Node: methods virtual,  Next: methods sealing,  Prev: methods concrete,  Up: methods

7.2 Virtual methods
===================

The clause 'virtual-method' allows the definition of virtual methods
associated to a record-type.  Virtual methods work almost like concrete
methods, but the rules of overriding are different: with virtual methods
we request run-time dynamic dispatching, to have the methods of the
sub-types take precedence over the methods of the super-types.

     *NOTE* Virtual methods must have an implementation, there are no
     abstract methods.

   Example:

     (define-record-type <super>
       (virtual-method (doit)
         1))

     (define-record-type <sub>
       (parent <super>)
       (method (doit)
         2))

     (define (super-fun {O <super>})
       (.doit O))

     (define (sub-fun   {O <sub>})
       (.doit O))

     (define O
       (new <sub>))

     (super-fun O)   => 2
     (sub-fun   O)   => 2

we see that even though the function 'super-fun' accesses the instance
of '<sub>' with the type specification '<super>', the actually called
method is the one defined by '<sub>'.

   The overriding method's type signature must be a sub-type of the
overridden method's type signature.  For example, the following
definitions are fine:

     (define-record-type <super>
       (fields value)
       (virtual-method ({doit <number>} {S <nestring>})
         (.value this)))

     (define-record-type <sub>
       (parent <super>)
       (virtual-method ({doit <fixnum>} {S <string>})
         (.value this)))

because:

     (type-annotation-super-and-sub?
        (lambda (<nestring>) => (<number>))
        (lambda (<string>)   => (<fixnum>)))
     => #t

while the following definitions will cause a syntax violation exception
at expand-time:

     (define-record-type <super>
       (fields value)
       (virtual-method ({doit <number>} {S <nestring>})
         (.value this)))

     (define-record-type <sub>
       (parent <super>)
       (virtual-method ({doit <fixnum>} {S <vector>})
         (.value this)))

because:

     (type-annotation-super-and-sub?
        (lambda (<nestring>) => (<number>))
        (lambda (<string>)   => (<vector>)))
     => #f

   Once a method has been defined as virtual in a super-type, it does
not matter if the sub-type makes use of 'method', 'virtual-method' or
'seal-method': all these clauses will override the super-type's method
if they use the same name.  Example:

     (define-record-type <super>
       (virtual-method (darkness)
         1)
       (virtual-method (light)
         2))

     (define-record-type <sub>
       (parent <super>)
       (method (darkness)
         11)
       (virtual-method (light)
         22))

     (define {P <super>}
       (new <sub>))

     (.darkness P)   => 11
     (.light    P)   => 22

   Notice that it is not possible to define a sub-type having a field
with the same name of a super-type's virtual method; the following
definitions will cause an expand-time exception:

     (define-record-type <super>
       (method (doit)
         1))

     (define-record-type <sub>
       (parent <super>)
       (fields doit))
     error-> &syntax

   The clause 'seal-method' seals a method name so that the sub-types
can no more use it; it does not matter if the super-types actually use
it or not.


File: vicare-typed.info,  Node: methods sealing,  Next: methods calling,  Prev: methods virtual,  Up: methods

7.3 Sealing methods
===================

It happens that we want to define virtual methods in a super-type,
override them in a sub-type and then forbid further overriding in the
sub-types of the sub-type.  This is possible with sealing methods.

   The clause 'seal-method' allows the definition of methods associated
to a record-type that might override the super-type's methods, but that
forbid the sub-types from overriding them.  For everything else: sealing
methods work like concrete methods.

   In the following example everything works as usual, with '<sub>'
overriding the implementation of 'doit' in '<super>':

     (define-record-type <super>
       (virtual-method (doit)
         1))

     (define-record-type <sub>
       (parent <super>)
       (seal-method (doit)
         2))

     (define (super-fun {O <super>})
       (.doit O))

     (define (sub-fun   {O <sub>})
       (.doit O))

     (define O
       (new <sub>))

     (super-fun O)   => 2
     (sub-fun   O)   => 2

but adding the following definition will cause an expand-time exception,
because sub-types of '<sub>' are forbidden from having a method named
'doit':

     (define-record-type <sub-sub>
       (parent <sub>)
       (method (doit)
         3))
     error-> &syntax

the following definition will also cause an expand-time exception,
because sub-types of '<sub>' are forbidden from having a field named
'doit':

     (define-record-type <sub-sub>
       (parent <sub>)
       (fields doit))
     error-> &syntax


File: vicare-typed.info,  Node: methods calling,  Prev: methods sealing,  Up: methods

7.4 Calling object-type methods
===============================

The following keyword syntactic bindings are involved in the definition
and use of methods: 'method', 'virtual-method', 'seal-method',
'method-call'.  In addition the function 'method-call-late-binding'
performs a method call with "late binding" (run-time dispatching).

   The keyword 'method' is used in 'define-record-type' to define
methods for a record-type (*note Record-type methods:
(vicare-scheme)iklib records defs methods.).  For example:

     (define-record-type duo
       (fields one two)
       (method (sum-them)
         (+ (duo-one this)
            (duo-two this)))
       (method (mul-them)
         (* (duo-one this)
            (duo-two this))))

the syntax 'method-call' is then used to call a record's methods:

     (define {O duo}
       (new duo 3 5))

     (method-call sum-them O)        => 8
     (method-call mul-them O)        => 15

   When defining a record or struct: Vicare automatically adds a method
to the methods table, for each field, with the same name of the field.
When the field is mutable: if the method is called with one argument, it
behaves as a field accessor; if the method is called with two arguments,
it behaves as a field mutator.  When the field is immutable: the method
can be called with one argument only.  Example:

     (define-record-type duo
       (fields (immutable one)
               (mutable   two)))

     (define {O duo}
       (new duo 1 2))

     (method-call one O)     => 1
     (method-call one O 123) error-> &syntax
     (method-call two O)     => 2
     (method-call two O 9)
     (method-call two O)     => 9

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Syntax: method-call ?NAME ?SUBJECT-EXPR ?ARG ...
     Apply an object-type's method to the return value of ?SUBJECT-EXPR
     and the optional arguments ?ARG.

     ?NAME must be a symbol representing a method or field name.
     ?SUBJECT-EXPR must be a Scheme expression which, expanded and
     evaluated at run-time, returns a single value.  Each ?ARG must be a
     Scheme expression which, expanded and evaluated at run-time,
     returns a single value.

     When possible, 'method-call' determines at expand-time the type of
     the expression ?SUBJECT-EXPR and searches for a method with equal
     name, according to 'eq?'.  If the method is found, the syntactic
     identifier to which the implementation procedure is bound is
     inserted in the macro expansion:

          (?PROCEDURE ?SUBJECT-EXPR ?ARG ...)

     If the object-type of ?SUBJECT-EXPR has no matching method: its
     super-type is inspected, then the super-type of the super-type and
     so on.  If no method is found in the types hierarchy: an exception
     is raised.

     'method-call' is able to retrieve the type of its second argument
     at expand-time only when the typed language is enabled.  If
     'method-call' cannot determine the type of ?SUBJECT-EXPR at
     expand-time, the macro use is expanded to:

          (method-call-late-binding (quote ?NAME) #f
                                    ?SUBJECT-EXPR ?ARG ...)

     and the function 'method-call-late-binding' attempts to determine a
     suitable method at run-time.

 -- Function: method-call-late-binding NAME TD SUBJECT ARG ...
     Apply an object-type's method to SUBJECT and the optional arguments
     ?ARG.  Return the application results.

     The argument NAME must be a symbol representing a method or field
     name.  The argument SUBJECT must be a Scheme object implementing a
     set of methods.  The optional ?ARG arguments can be any value.

     The argument TD must be '#f' or a predetermined type descriptor for
     SUBJECT; this argument is usually '#f'.

     This function attempts to determine the type of SUBJECT at run-time
     and searches the object-type's table of methods, if any, for a
     method whose name equals NAME according to 'eq?'.  If a method is
     found, its implementation procedure is retrieved and applied to
     SUBJECT and the ARG values.

     If the object-type of SUBJECT has no matching method: its
     super-type is inspected, then the super-type of the super-type and
     so on.  If no method is found in the type's hierarchy: an exception
     is raised.

     Usually we do not need to call this function explicitly; however,
     it is useful for debugging purposes.

Dot notation
............

When the Scheme reader's textual input port is configured in '#!vicare'
mode: if a list starts with a symbol; the name of the symbol is a string
of length at least 2; the first character of the string is a dot; the
second character of the string is *not* a dot, then a 'method-call'
symbol is inserted and the symbol stripped of the dot.

   We can try it at the REPL:

     vicare> '(.ciao)
     $1 = (method-call ciao)

   Notice that R6RS forbids symbols starting with a dot, with the
exception of the ellipsis; so this transformation does not influence the
other reader operations.

   We can use this notation to call an object-type's methods as in the
following program:

     #!vicare
     (program (demo)
       (options typed-language)
       (import (vicare))

       (define-record-type duo
         (fields one two)

         (method (sum-them)
           (+ (.one this) (.two this)))

         (method (mul-them)
           (* (.one this) (.two this)))

         (method (display port)
           (display this port)))

       (define {O duo}
         (new duo 3 4))

       (pretty-print (.sum-them O)
                     (current-error-port))

       (pretty-print (.mul-them O)
                     (current-error-port))

       (.display O (current-error-port))
       (newline (current-error-port))

       #| end of program |# )


File: vicare-typed.info,  Node: protlev,  Next: mixins,  Prev: methods,  Up: Top

8 Protection levels
*******************

When the typed language is enabled, record-type definitions support
protection levels for fields and methods.  Protection levels limit the
way fields and methods can be used both from other types in the
record-type hierarchy and from outside a record-type's definition.

   Three protection levels are supported: 'public', 'protected' and
'private'; they are loosely modeled after the ones defined in the C++
language.

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Auxiliary Syntax: public
     Select the 'public' protection level for the associated fields and
     methods.  When a member of record-type '<T>' is given the 'public'
     protection level: sub-types of '<T>' can access it; instances of
     '<T>' can access it from outside methods.

     When no protection level is specified for a member in a record-type
     definition: the protection level defaults to 'public'.

 -- Auxiliary Syntax: protected
     Select the 'protected' protection level for the associated fields
     and methods.  When a member of record-type '<T>' is given the
     'protected' protection level: sub-types of '<T>' can access it;
     instances of '<T>' cannot access it from outside methods.

 -- Auxiliary Syntax: private
     Select the 'private' protection level for the associated fields and
     methods.  When a member of record-type '<T>' is given the 'private'
     protection level: sub-types of '<T>' cannot access it; instances of
     '<T>' cannot access it from outside methods.

Access                     public   protected   private
----------------------------------------------------------
Members of the same type   yes      yes         yes
Members of sub-type        yes      yes         no
Not members                yes      no          no

Table: Summary of protection levels.

   The protection level keywords can be used either as "enclosing
syntaxes" as in:

     (define-record-type <duo>
       (public
         (fields one two)
         (method (add)
           (+ (.one this) (.two this)))))

or as "attribute syntaxes" as in:

     (define-record-type <duo>
       (fields public one two)
       (method public (add)
         (+ (.one this) (.two this))))

   The only clauses that can be put in an enclosing syntax and that
accept an attribute syntax are: 'fields', 'method', 'virtual-method',
'seal-method'.

Usage and limitations by examples
.................................

The protection levels limit the access to members from outside a
method's body:

     (define-record-type <blue>
       (method public    (pub)  1)
       (method protected (pro)  2)
       (method private   (pri)  3))

     (define O
       (new <blue>))

     (.pub O)        => 1
     (.pro O)        error-> not a public method
     (.pri O)        error-> not a public method

   When super-type's members are 'public', everything works as usual:

     (define-record-type <blue>
       (fields public light))

     (define-record-type <dark-blue>
       (parent <blue>)
       (method public (doit)
         (.light this)))

     (define O
       (new <dark-blue> 1))

     (define {X <blue>}
       O)

     (.doit  O)      => 1
     (.light X)      => 1

   When super-type's members are 'protected', we can access them from
the super-type's methods and from the sub-type's methods:

     (define-record-type <blue>
       (fields protected light)
       (method public (doit)
         (.light this)))

     (define-record-type <dark-blue>
       (parent <blue>)
       (method public (doit)
         (.light this)))

     (define O
       (new <dark-blue> 1))

     (.doit O)       => 1

     (define {X <blue>}
       O)

     (.light X)      error-> not a public method
     (.doit  X)      => 1

   When super-type's members are 'private', we can access them from the
super-type's methods only:

     (define-record-type <blue>
       (fields private light)
       (method public (doit)
         (.light this)))

     (define X
       (new <blue> 1))

     (.light X)      error-> not a public method
     (.doit  X)      => 1

     (define-record-type <dark-blue>
       (parent <blue>)
       (method public (doit)
         (.light this)))     error-> not a public or protected method

   It is not an error to define a private virtual method, but such
method cannot be overridden by the sub-types:

     (define-record-type <blue>
       (virtual-method private (doit) 1))

     (define-record-type <dark-blue>
       (parent <blue>)
       (method (doit) 2))    error-> cannot override private method

   Virtual methods overriding and sealing is possible only among methods
of the same protection level:

     (define-record-type <blue>
       (protected
         (virtual-method (over)
           'over-blue))
       (method (doit)
         (.over this)))

     (define-record-type <dark-blue>
       (parent <blue>)
       (protected
         (method (over)
           'over-dark-blue)))

     (define O
       (new <dark-blue>))

     (define (fun {X <blue>})
       (.doit X))

     (fun O)         => over-dark-blue


File: vicare-typed.info,  Node: mixins,  Next: interfaces,  Prev: protlev,  Up: Top

9 Sharing object-type definition clauses
****************************************

"Mixins" are a way to add definition clauses to record-types and labels.
Interfaces are implemented half in the boot image and half in the
library '(vicare language-extensions mixins)'.

   Let's consider this situation:

     (define-record-type <alpha>
       (fields a))

     (define-record-type <beta>
       (fields b))

     (define-record-type <delta>
       (parent <alpha>)
       (fields v)
       (method (doit)
         (+ 1 (.v this))))

     (define-record-type <gamma>
       (parent <beta>)
       (fields v)
       (method (doit)
         (+ 1 (.v this))))

the definitions of '<delta>' and '<gamma>' share some clauses; both of
them already have a parent type and multiple inheritance is not
supported by Vicare.  Is it possible to write the shared clauses only
once and attach them to the record-type definitions?  Yes, with mixins.
The example above is equivalent to the following:

     (define-record-type <alpha>
       (field a))

     (define-record-type <beta>
       (field b))

     (define-mixin-type <stuff>
       (field v)
       (method (doit)
         (+ 1 (.v this))))

     (define-record-type <delta>
       (parent <alpha>)
       (mixins <stuff>))

     (define-record-type <gamma>
       (parent <beta>)
       (mixins <stuff>))

the syntax use of 'define-mixin-type' associates a set of clauses to the
identifier '<stuff>'; when the 'mixins' clause is used in the body of a
record-type definition:

  1. The clauses associated to the selected mixin identifier are
     retrieved as syntax object.

  2. All the instances of the identifier '<stuff>' are substituted with
     the identifier of the enclosing record-type; '<delta>' and
     '<gamma>' in the example.

  3. The resulting clauses are added to the enclosing definition.

 -- Auxiliary Syntax: mixins ?MIXIN-NAME ...
     Compose the enclosing record-type, label or mixin definition with
     the given list of mixins.  This clause can be used multiple times.
     This syntactic binding is exported by the library '(vicare)'.

     The syntactic identifiers ?MIXIN-NAME are used to reference the
     mixins to be imported.  The clauses are included in the same order
     in which the ?MIXIN-NAME identifiers are present in the 'mixins'
     clause and in the same place in which the 'mixins' clause is
     present in the enclosing definition.

     It is a syntax violation if a mixin identifier name is not already
     associated to a set of clauses at the time the receiving definition
     is expanded.

 -- Syntax: define-mixin-type ?MIXIN-NAME ?CLAUSE0 ?CLAUSE ...
     Associate a set of mixin clauses to the identifier ?MIXIN-NAME,
     which can be later referenced by a 'mixins' clause in the body of a
     class or label definition.  This syntactic binding is exported by
     the library '(vicare language-extensions mixins)'.

     The 'mixins' clause can be used in the body of a mixin definition;
     the result is that the clauses of the imported mixins are added to
     the enclosing mixin definition.

     The following clauses are accepted in the body of a
     'define-mixin-type':

          define-type-descriptors strip-angular-parentheses
          nongenerative sealed opaque protocol super-protocol fields
          method virtual-method seal-method
          custom-printer type-predicate equality-predicate
          comparison-procedure hash-function
          public protected private
          implements


File: vicare-typed.info,  Node: interfaces,  Next: labels,  Prev: mixins,  Up: Top

10 Interface types
******************

The "interfaces" are a mechanism to verify, at expand-time, that
instances of an object-type can be used in a generic expression, because
they implement all the needed methods and such methods can be called at
run-time through dynamic dispatching.

   Interfaces are implemented half in the boot image and half in the
library '(vicare language-extensions interfaces)'.

* Menu:

* interfaces intro::      Introduction to interfaces.
* interfaces defs::       Defining interfaces.
* interfaces descr::      Interfaces type descriptors.
* interfaces examples::   Interfaces by examples.


File: vicare-typed.info,  Node: interfaces intro,  Next: interfaces defs,  Up: interfaces

10.1 Introduction to interfaces
===============================

Let's consider this code:

     (define-record-type <a-vector>
       (fields {vec <nevector>})
       (method ({first <top>})
         (vector-ref (.vec this) 0)))

     (define-record-type <a-string>
       (fields {vec <nestring>})
       (method ({first <top>})
         (string-ref (.vec this) 0)))

     (define-record-type <a-list>
       (fields {vec <nelist>})
       (method ({first <top>})
         (car (.vec this))))

     (define (fun O)
       (.first O))

     (fun (new <a-vector> '#(1 2 3)))        => 1
     (fun (new <a-string> "ABC"))            => #\A
     (fun (new <a-list> '(a b c)))           => a

everything works fine in the function 'fun' because all of '<a-vector>',
'<a-string>' and '<a-list>' implement the method 'first'.  The code
'(.first O)' expands into a call to 'method-call-late-binding', which,
at run-time, finds the method implementation functions in the type
descriptors of '<a-vector>', '<a-string>' and '<a-list>'.

   Fine, but the code is not type-checked at expand-time.  Enter
interfaces.  Let's modify the code as follows:

     (define-interface-type <Sequence>
       (method-prototype first
         (lambda () => (<top>))))

     (define-record-type <a-vector>
       (implements <Sequence>)
       (fields {vec <nevector>})
       (method ({first <top>})
         (vector-ref (.vec this) 0)))

     (define-record-type <a-string>
       (implements <Sequence>)
       (fields {vec <nestring>})
       (method ({first <top>})
         (string-ref (.vec this) 0)))

     (define-record-type <a-list>
       (implements <Sequence>)
       (fields {vec <nelist>})
       (method ({first <top>})
         (car (.vec this))))

     (define (fun {O <Sequence>})
       (.first O))

     (fun (new <a-vector> '#(1 2 3)))        => 1
     (fun (new <a-string> "ABC"))            => #\A
     (fun (new <a-list> '(a b c)))           => a

everything works almost as before, but the record-type definition clause
'(implements <Sequence>)' causes the expander to validate, at
expand-time, that the record-types actually implement a method 'first'
with the correct type signature.

   Also, the function application '(fun ?OPERAND)' is validated at
expand-time to verify that the type of ?OPERAND is an object-type that
implements '<Sequence>'.  Such validation can happen *only* if the
expander is able to determine the type of ?OPERAND; this validation
cannot happen at run-time, so, for example, it is impossible for label
types to implement interfaces.


File: vicare-typed.info,  Node: interfaces defs,  Next: interfaces descr,  Prev: interfaces intro,  Up: interfaces

10.2 Defining interfaces
========================

The following syntactic bindings are exported by the library '(vicare
language-extensions interfaces)'.

 -- Syntax: define-interface-type ?NAME ?CLAUSE ...
 -- Auxiliary Syntax: nongenerative
 -- Auxiliary Syntax: parent
 -- Auxiliary Syntax: implements
 -- Auxiliary Syntax: method-prototype
 -- Auxiliary Syntax: method
     Define a new interface-type bound to the syntactic identifier
     ?NAME.  The syntactic bindings 'nongenerative', 'parent',
     'implements', 'method' are the same ones exported by '(vicare)' and
     are reexported by the library '(vicare language-extensions
     interfaces)'.

     Interfaces cannot be instantiated: attempting to do it will raise
     an expand-time exception.

     A use of the clause 'nongenerative' must have one of the formats:

          (nongenerative)
          (nongenerative ?UID)

     when used it causes the interface-type to be non-generative.  This
     concept is the same as for record-types, so usually we do want to
     define non-generative interface-types.

     A use of the clause 'parent' must have the format:

          (parent ?PARENT-NAME)

     and causes the new interface-type to become a sub-type of
     ?PARENT-NAME, which must be a syntactic identifier representing the
     name of an already defined interface-type.  An object-type
     implementing the interface ?NAME must also implement all the
     methods required by the interface ?PARENT-NAME.

     A use of the clause 'implements' must have format:

          (implements ?IFACE-NAME ...)

     and declares that an object-type implementing the interface-type
     ?NAME also implements all the methods in the interface-types
     ?IFACE-NAME.  The definition of ?NAME must include a
     'method-prototype' clause for each method required by the
     interfaces ?IFACE-NAME, with matching type signatures.

     A use of the clause 'method-prototype' must have format:

          (method-prototype ?METHOD-NAME ?SIGNATURE)

     where ?METHOD-NAME is an identifier representing the name of the
     method and ?SIGNATURE is a 'lambda' or 'case-lambda' type
     annotation representing the type signature of the method.  Any
     object-type that implements an interface, must implement all the
     methods with signatures that are sub-types of the method
     prototypes.

     A use of the clause 'method' must have format:

          (method (?WHO . ?TYPED-FORMALS)
            . ?BODY)

          (method ((brace ?WHO . ?RV-TYPES) . ?TYPED-FORMALS)
            . ?BODY)

     which is the same syntax for 'define-record-type'.  The clause
     'method' defines a required method prototype which also has a
     default implementation.  An object-type implementing the interface
     ?NAME is allowed not to implement a method matching an interface
     prototype with default implementation.


File: vicare-typed.info,  Node: interfaces descr,  Next: interfaces examples,  Prev: interfaces defs,  Up: interfaces

10.3 Interfaces type descriptors
================================

Interfaces have run-time type descriptors, accessible through the
'type-descriptor' syntax, *note Interface type descriptors: descriptors
other interface.  Example:

     (import (prefix (vicare system type-descriptors)
                     td::))

     (define-interface-type <Stuff>
       (method-prototype red
         (lambda () => (<top>)))
       (method (blue)
         2))

     (define itd
       (type-descriptor <Stuff>))

     (td::interface-type-descr? itd)
     => #t

     (td::interface-type-descr.type-name itd)
     => <Stuff>


File: vicare-typed.info,  Node: interfaces examples,  Prev: interfaces descr,  Up: interfaces

10.4 Interfaces by examples
===========================

Let's illustrate the features and limitations of interface-types by
examples.

   Whenever an interface inherits from another interface, it obviously
becomes its sub-type:

     (define-interface-type <IParent>
       (method-prototype doit
         (lambda (<number>) => (<string>))))

     (define-interface-type <IChild>
       (parent <IParent>))

     (type-annotation-super-and-sub? <IParent> <IChild>) => #t
     (type-annotation-super-and-sub? <IChild> <IParent>) => #f

   An interface can implement another interface; the implementer must
declare a matching method prototype for every method prototype of the
implemented.  The method prototype of the implementer must be a sub-type
of the method prototype of the implemented.  Given that:

     (type-annotation-super-and-sub?
       (lambda (<nestring>) => (<number>))
       (lambda (<string>)   => (<fixnum>)))
     => #t

we can define:

     (define-interface-type <IOne>
       (method-prototype doit
         (lambda (<nestring>) => (<number>))))

     (define-interface-type <ITwo>
       (implements <IOne>)
       (method-prototype doit
         (lambda (<string>) => (<fixnum>))))

     (type-annotation-super-and-sub? <IOne> <ITwo>) => #t
     (type-annotation-super-and-sub? <ITwo> <IOne>) => #f

   An interface can inherit method prototypes from another interface and
use those to implement another interface:

     (define-interface-type <I>
       (method-prototype doit
         (lambda (<string>) => (<number>))))

     (define-interface-type <A>
       (method-prototype doit
         (lambda (<string>) => (<number>))))

     (define-interface-type <B>
       (parent <A>)
       (implements <I>))

     (type-annotation-super-and-sub? <I> <A>) => #f
     (type-annotation-super-and-sub? <I> <B>) => #t
     (type-annotation-super-and-sub? <A> <I>) => #f
     (type-annotation-super-and-sub? <B> <I>) => #f

   If the interface '<ISub>' inherits from '<ISuper>', to implement
'<ISub>' the interface '<A>' has to declare a method for every method in
'<ISub>' and '<ISuper>':

     (define-interface-type <ISuper>
       (method-prototype super-doit
         (lambda (<string>) => (<number>))))

     (define-interface-type <ISub>
       (parent <ISuper>)
       (method-prototype sub-doit
         (lambda (<string>) => (<fixnum>))))

     (define-interface-type <A>
       (implements <ISub>)
       (method-prototype super-doit
         (lambda (<string>) => (<number>)))
       (method-prototype sub-doit
         (lambda (<string>) => (<fixnum>))))

     (type-annotation-super-and-sub? <ISuper> <A>) => #t
     (type-annotation-super-and-sub? <ISub>   <A>) => #t
     (type-annotation-super-and-sub? <A> <ISuper>) => #f
     (type-annotation-super-and-sub? <A> <ISub>)   => #f

   Interface '<B>' implements interface '<A>'; interface '<C>'
implements interface '<B>'; automatically, interface '<C>' implements
interface '<A>':

     (define-interface-type <A>
       (method-prototype red         (lambda () => (<fixnum>))))

     (define-interface-type <B>
       (implements <A>)
       (method-prototype red         (lambda () => (<fixnum>)))
       (method-prototype blue        (lambda () => (<symbol>))))

     (define-interface-type <C>
       (implements <B>)
       (method-prototype red         (lambda () => (<fixnum>)))
       (method-prototype blue        (lambda () => (<symbol>))))

     (type-annotation-super-and-sub? <A> <B>) => #t
     (type-annotation-super-and-sub? <A> <C>) => #t
     (type-annotation-super-and-sub? <B> <A>) => #f
     (type-annotation-super-and-sub? <B> <C>) => #t
     (type-annotation-super-and-sub? <C> <A>) => #f
     (type-annotation-super-and-sub? <C> <B>) => #f

   An interface that inherits from another interface can "extend" its
method prototypes with additional signatures.  The interface '<IThree>'
implements the interfaces '<IOne>' and '<ITwo>'.  '<IThree>' implements
the "composite" method from '<IOne>' and '<ITwo>' with multiple
'method-prototype' clauses:

     ;;
     ;;                 <IOne>
     ;;                    ^
     ;;                    |
     ;;   <IThree> +++> <ITwo>
     ;;
     (define-interface-type <IOne>
       (method-prototype doit
         (lambda (<fixnum>) => (<string>))))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method-prototype doit
         (lambda (<flonum>) => (<string>))))

     (define-interface-type <IThree>
       (implements <ITwo>)
       (method-prototype doit (lambda (<fixnum>) => (<string>)))
       (method-prototype doit (lambda (<flonum>) => (<string>))))

     (type-annotation-super-and-sub? <IOne>   <IThree>) => #t
     (type-annotation-super-and-sub? <IOne>   <ITwo>)   => #t
     (type-annotation-super-and-sub? <ITwo>   <IThree>) => #t
     (type-annotation-super-and-sub? <IThree> <IOne>)   => #f
     (type-annotation-super-and-sub? <ITwo>   <IOne>)   => #f
     (type-annotation-super-and-sub? <IThree> <ITwo>)   => #f

the same as above, but with a single 'method-prototype' clause:

     (define-interface-type <IOne>
       (method-prototype doit
         (lambda (<fixnum>) => (<string>))))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method-prototype doit
         (lambda (<flonum>) => (<string>))))

     (define-interface-type <IThree>
       (implements <ITwo>)
       (method-prototype doit
         (case-lambda
           ((<fixnum>) => (<string>))
           ((<flonum>) => (<string>)))))

   A record-type can implement an interface by defining a concrete
method for every method prototype:

     (define-interface-type <IOne>
       (method-prototype doit
         (lambda (<string>) => (<number>))))

     (define-record-type <blue>
       (implements <IOne>)
       (method ({doit <number>} {S <string>})
         1))

     (type-annotation-super-and-sub? <IOne> <blue>) => #t
     (type-annotation-super-and-sub? <blue> <IOne>) => #f

   A record-type can inherit from another record-type and use its
parent's methods to implement an interface:

     (define-interface-type <I>
       (method-prototype doit
         (lambda (<string>) => (<number>))))

     (define-record-type <A>
       (method ({doit <number>} {S <string>})
         1))

     (define-record-type <B>
       (parent <A>)
       (implements <I>))

     (type-annotation-super-and-sub? <I> <A>) => #f
     (type-annotation-super-and-sub? <I> <B>) => #t
     (type-annotation-super-and-sub? <A> <I>) => #f
     (type-annotation-super-and-sub? <B> <I>) => #f

   A record-type must implement a method for every method prototype in
the interface and its parents:

     (define-interface-type <ISuper>
       (method-prototype super-doit
         (lambda (<string>) => (<number>))))

     (define-interface-type <ISub>
       (parent <ISuper>)
       (method-prototype sub-doit
         (lambda (<string>) => (<fixnum>))))

     (define-record-type <A>
       (implements <ISub>)
       (method ({super-doit <number>} {S <string>})
         1)
       (method ({sub-doit <fixnum>} {S <string>})
         1))

     (type-annotation-super-and-sub? <ISuper> <A>) => #t
     (type-annotation-super-and-sub? <ISub>   <A>) => #t
     (type-annotation-super-and-sub? <A> <ISuper>) => #f
     (type-annotation-super-and-sub? <A> <ISub>)   => #f

   The record-type '<C>' implements interface '<B>'; the interface '<B>'
implements interface '<A>'; automatically, '<C>' implements '<A>':

     (define-interface-type <A>
       (method-prototype red
         (lambda () => (<fixnum>))))

     (define-interface-type <B>
       (implements <A>)
       (method-prototype red
         (lambda () => (<fixnum>)))
       (method-prototype blue
         (lambda () => (<symbol>))))

     (define-record-type <C>
       (implements <B>)
       (method ({red  <fixnum>})
         1)
       (method ({blue <symbol>})
         'ciao))

     (type-annotation-super-and-sub? <A> <B>) => #t
     (type-annotation-super-and-sub? <A> <C>) => #t
     (type-annotation-super-and-sub? <B> <A>) => #f
     (type-annotation-super-and-sub? <B> <C>) => #t
     (type-annotation-super-and-sub? <C> <A>) => #f
     (type-annotation-super-and-sub? <C> <B>) => #f

   The record-type '<dark-blue>' inherits from '<blue>' the
implementation of the interfaces '<IOne>' and '<ITwo>':

     ;;
     ;;               <IOne>
     ;;                  ^
     ;;                  |
     ;;   <blue> +++> <ITwo>
     ;;     ^
     ;;     |
     ;;   <dark-blue>

     (define-interface-type <IOne>
       (method-prototype ione-doit
         (lambda () => (<number>))))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method-prototype itwo-doit
         (lambda () => (<symbol>))))

     (define-record-type <blue>
       (implements <ITwo>)
       (fields val)
       (method ({ione-doit <number>})
         (+ 10 (.val this)))
       (method ({itwo-doit <symbol>})
         'ciao))

     (define-record-type <dark-blue>
       (parent <blue>))

     (define (fun-1 {O <IOne>})
       (.ione-doit O))

     (define (fun-2 {O <ITwo>})
       (vector (.ione-doit O)
               (.itwo-doit O)))

     (define O
       (new <dark-blue> 1))

     (fun-1 O)       => 11
     (fun-2 O)       => #(11 ciao)

   The record-type '<dark-blue>' implements the interface '<ITwo>' and
inherits from '<blue>' the implementation of the interface '<IOne>':

     ;;   <blue> +++> <IOne>
     ;;     ^
     ;;     |
     ;;   <dark-blue> +++> <ITwo>

     (define-interface-type <IOne>
       (method-prototype ione-doit
         (lambda () => (<number>))))

     (define-interface-type <ITwo>
       (method-prototype itwo-doit
         (lambda () => (<symbol>))))

     (define-record-type <blue>
       (implements <IOne>)
       (fields val)
       (method ({ione-doit <number>})
         (+ 10 (.val this))))

     (define-record-type <dark-blue>
       (parent <blue>)
       (implements <ITwo>)
       (method ({itwo-doit <symbol>})
         'ciao))

     (define (fun-1 {O <IOne>})
       (.ione-doit O))

     (define (fun-2 {O <ITwo>})
       (.itwo-doit O))

     (define O
       (new <dark-blue> 1))

     (fun-1 O)       => 11
     (fun-2 O)       => ciao

   The record-type '<blue>' implements the interface '<ITwo>', its
parent '<IOne>', and automatically the interface '<IThree>' implemented
by '<IOne>':

     ;;               <IOne> +++> <IThree>
     ;;                  ^
     ;;                  |
     ;;   <blue> +++> <ITwo>

     (define-interface-type <IThree>
       (method-prototype ithree-doit
         (lambda () => (<string>))))

     (define-interface-type <IOne>
       (implements <IThree>)
       (method-prototype ione-doit
         (lambda () => (<number>)))
       (method-prototype ithree-doit
         (lambda () => (<string>))))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method-prototype itwo-doit
         (lambda () => (<symbol>))))

     (define-record-type <blue>
       (implements <ITwo>)
       (fields val)
       (method ({ione-doit <number>})
         (+ 10 (.val this)))
       (method ({itwo-doit <symbol>})
         'ciao)
       (method ({ithree-doit <string>})
         "hello"))

     (define (fun-1 {O <IOne>})
       (vector (.ione-doit O)
               (.ithree-doit O)))

     (define (fun-2 {O <ITwo>})
       (vector (.ione-doit O)
               (.itwo-doit O)
               (.ithree-doit O)))

     (define (fun-3 {O <IThree>})
       (.ithree-doit O))

     (define O
       (new <blue> 1))

     (fun-1 O)       => #(11 "hello")
     (fun-2 O)       => #(11 ciao "hello")
     (fun-3 O)       => "hello"

   Two record-types in a hierarchy both implement the same interface:

     (define-interface-type <Arith>
       (method-prototype add
         (lambda () => (<number>))))

     (define-record-type <duo>
       (implements <Arith>)
       (fields one two)
       (method ({add <number>})
         (+ (.one this) (.two this))))

     (define-record-type <trio>
       (parent <duo>)
       (implements <Arith>)
       (fields three)
       (method ({add <number>})
         (+ (.one this) (.two this) (.three this))))

     (define (fun {O <Arith>})
       (.add O))

     (fun (new <duo>  1 2))          => 3
     (fun (new <trio> 1 2 3))        => 6

   The record-type '<duo>' implements the interface '<Stringer>' which
has a default method 'to-string':

     (define-interface-type <Stringer>
       (method (to-string)
         (with-output-to-string
           (lambda ()
             (display this)))))

     (define-record-type <duo>
       (implements <Stringer>)
       (fields one two)
       (custom-printer
         (lambda ({this <duo>} port sub-printer)
           (display "#[duo "    port)
           (display (.one this) port)
           (display #\space     port)
           (display (.two this) port)
           (display #\]         port))))

     (define (fun {O <Stringer>})
       (.to-string O))

     (fun (new <duo> 1 2))   => "#[duo 1 2]"

   The record-type '<duo>' implements the interface '<Stringer>' which
has a default method 'to-string'; '<duo>' implements the method by
itself:

     (define-interface-type <Stringer>
       (method ({to-string <string>})
         (with-output-to-string
           (lambda ()
             (display this)))))

     (define-record-type <duo>
       (implements <Stringer>)
       (fields one two)
       (method ({to-string <string>})
         (with-output-to-string
           (lambda ()
             (display "#[duo ")
             (display (.one this))
             (display #\space)
             (display (.two this))
             (display #\])))))

     (define (fun {O <Stringer>})
       (.to-string O))

     (fun (new <duo> 1 2))   => "#[duo 1 2]"

   Default methods have a limitation: they cannot extend other methods.
The following definitions will raise an expand-time exception:

     (define-interface-type <IOne>
       (method ({doit <number>})
         1))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method-prototype doit
         (lambda (<string>) => (<number>))))

because we cannot extend the default method 'doit' in '<IOne>' with a
method prototype in '<ITwo>'.  The following definitions will raise an
expand-time exception:

     (define-interface-type <IOne>
       (method-prototype doit
         (lambda (<string>) => (<number>))))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method ({doit <number>})
         1))

because we cannot extend the method prototype 'doit' in '<IOne>' with a
default method in '<ITwo>'.  The following definitions will raise an
expand-time exception:

     (define-interface-type <IOne>
       (method ({doit <number>})
         1))

     (define-interface-type <ITwo>
       (parent <IOne>)
       (method ({doit <number>} {S <string>})
         2))

because we cannot extend the default method 'doit' in '<IOne>' with the
default method 'doit' in '<ITwo>'.

   Here we use an "instantiable body" to define a "generic"
interface-type:

     (import (vicare language-extensions instantiable-bodies))

     (define-instantiable-body define-iface-arith
       (define-interface-type <Iface>
         (method-prototype add
           (lambda () => (<type-name>)))))

     (begin
       (define-iface-arith
         ((<Iface>             <NumberArith>)
          (<type-name>         <number>)))
       (define (nfun {O <NumberArith>})
         (.add O)))

     (begin
       (define-iface-arith
         ((<Iface>             <StringArith>)
          (<type-name>         <string>)))
       (define (sfun {O <StringArith>})
         (.add O)))

     (define-record-type <duo>
       (implements <NumberArith>)
       (fields one two)
       (method ({add <number>})
         (+ (.one this) (.two this))))

     (define-record-type <string-duo>
       (implements <StringArith>)
       (fields one two)
       (method ({add <string>})
         (string-append (.one this) (.two this))))

     (nfun (new <duo> 1 2))                  => 3
     (sfun (new <string-duo> "hel" "lo"))    => "hello"


File: vicare-typed.info,  Node: labels,  Next: friends,  Prev: interfaces,  Up: Top

11 Sub-typing with labels
*************************

"Labels" are types built on top of other types: we put label-types on
values of a parent type to handle them locally in a special way.  There
are two kinds of labels:

   * Labels without custom type predicate.  They are synonyms of their
     parent type and add methods to it.  A value matches the label-type
     if it matches the parent type.

   * Labels with custom type predicate.  A value matches the label-type
     if it satisfies the label's type predicate; it is possible to
     establish when a value matches the label-type only at run-time.

   The following syntactic bindings are exported by the library '(vicare
language-extensions labels)'.  All the auxiliary syntaxes are exported
by the library '(vicare)' and reexported by the library '(vicare
language-extensions labels)'.

 -- Syntax: define-label-type ?TYPE-NAME ?CLAUSE ...
 -- Auxiliary Syntax: nongenerative
 -- Auxiliary Syntax: parent
 -- Auxiliary Syntax: constructor
 -- Auxiliary Syntax: destructor
 -- Auxiliary Syntax: type-predicate
 -- Auxiliary Syntax: equality-predicate
 -- Auxiliary Syntax: comparison-procedure
 -- Auxiliary Syntax: hash-function
 -- Auxiliary Syntax: method
 -- Auxiliary Syntax: mixins
     Define a new label type.  ?TYPE-NAME must be a syntactic identifier
     representing the label name.

     The clause 'parent' is mandatory and its single argument must be a
     type annotation.

     The following clauses can be used in the same way they are used in
     'define-record-type':

          parent type-predicate
          equality-predicate comparison-procedure hash-function
          method mixins

     notice that labels *cannot* implement interfaces.

     The clause 'constructor' may appear zero, one or more times; these
     clauses define a constructor function to be used with the syntax
     'new'.  The 'constructor' clause has a syntax similar to
     'lambda/checked'; it must have the format:

          (constructor ?TYPED-FORMALS ?BODY0 ?BODY ...)

     ?TYPED-FORMALS must *not* specify a return value: the constructor
     returns a single value of type TYPE-NAME, and its specification is
     automatically generated.

     The clause 'destructor' may appear zero or one time; this clause
     defines a destructor function to be used with the syntax 'delete';
     this destructor is *not* used by the garbage collector.  The
     'destructor' clause has a syntax similar to 'lambda'; it must have
     the format:

          (destructor ?FORMALS ?BODY0 ?BODY ...)

     where ?FORMALS must specify a single argument of type ?TYPE-NAME.
     ?FORMALS must *not* specify a return value: the destructor should
     return unspecified values.

     The optional clause 'nongenerative' must be used with a single
     argument being a symbol representing a UID associated with the
     label type; such symbol is used by 'type-unique-identifiers' and so
     it allows multimethods to use label types.

Examples of simple labels
.........................

The following example defines a label '<String>' that is just a synonym
for '<string>':

     (define-label-type <String>
       (parent <string>))

     (define {O <String>}
       "ciao")

     (.length O)     => 4
     (hash    O)     ==> (string-hash O)

   The following example defines a label to represent fixnums returned
by comparison procedures ('-1', '0', '+1'):

     (define-label-type <comparison-fixnum>
       (parent (or <non-negative-fixnum> <negative-fixnum>))
       (type-predicate
         (lambda ({parent-pred <type-predicate>})
           (lambda (obj)
             (and (parent-pred obj)
                  (fx<=? obj +1)
                  (fx>=? obj -1))))))

     (is-a? +1 <comparison-fixnum>)  => #t
     (is-a? -1 <comparison-fixnum>)  => #t
     (is-a?  0 <comparison-fixnum>)  => #t

     (is-a? +2 <comparison-fixnum>)  => #f
     (is-a? -2 <comparison-fixnum>)  => #f

Examples of hash function
.........................

Now let's define a custom hash function (we ignore the parent hash
function that gets passed as PARENT-HASH argument):

     (define-label-type <String>
       (parent <string>)
       (hash-function
         (lambda (parent-hash)
           (lambda (S)
             (if (string-empty? S)
                 0
               (char-hash (string-ref S 0)))))))

     (define {O <String>}
       "ciao")

     (hash O)     == (char-hash #\c)

Examples of methods
...................

Let's define a label with a method to increment a fixnum.

     (define-label-type <fx>
       (parent <fixnum>)
       (method (incr)
         (fxadd1 this)))

     (define {O <fx>}
       10)

     (.incr O)       => 11

   Now let's define a method for adding prefixes and suffixes:

     (define-label-type <String>
       (parent <string>)
       (method ({append <String>} {suff <String>})
         (string-append this suff))
       (method ({append <String>} {pref <String>} {suff <String>})
         (string-append pref this suff)))

     (define {O <String>}
       "ciao")

     (.append O "-suff")             => "ciao-suff"
     (.append O "pref-" "-suff")     => "pref-ciao-suff"

     (.length (.append O "pref-" "-suff"))
     => 14

Defining a constructor function
...............................

In the following example:

     (define-label-type <vec>
       (parent <nevector>)
       (constructor (a b)
         (vector a b))
       (constructor (a b c)
         (vector a b c)))

     (new <vec> 1 2)         => #(1 2)
     (new <vec> 1 2 3)       => #(1 2 3)

we can think of the 'constructor' clauses as generating the following
functions definition:

     (define/overload ({<vec>-constructor <vec>} a b)
       (vector a b))

     (define/overload ({<vec>-constructor <vec>} a b c)
       (vector a b c))

notice that a type signature for the return value has been automatically
inserted.

Defining a destructor function
..............................

Here we define a bogus destructor function:

     (define-label-type <vec>
       (parent <vector>)
       (destructor ({O <vec>})
         `(deleted ,O)))

     (define {O <vec>}
       '#(1 2))

     (delete O)      => (deleted #(1 2))

we can think of the 'destructor' clauses as generating the following
function definition:

     (define (<vec>-destructor {O <vec>})
       `(deleted ,O))

Example of mixin
................

Here we show how to include mixin clauses in a label definition:

     (define-mixin-type <stuff>
       (method (pussy)
         (list 'pussy (.name this))))

     (define-label-type <peluche>
       (parent (list <symbol>))
       (method (name)
         (car this))
       (mixins <stuff>))

     (define {O <peluche>}
       '(cat))

     (.name  O)      => cat
     (.pussy O)      => (pussy cat)


File: vicare-typed.info,  Node: friends,  Next: Package License,  Prev: labels,  Up: Top

12 Friend functions
*******************

Friend functions are used to access private, public and protected
members of a record-type from outside of the record-type's methods.

 -- Syntax: define/friend (?TYPED-WHO (brace ?SUBJECT ?TYPE) . ?FORMALS)
          . ?BODY
     Define a function like 'define/checked' would do, but give private
     access to the members of the record-type ?TYPE for the argument
     ?SUBJECT.

     The new function is not a member of the record-type, so it does not
     influence the compliance of the record-type with interface types.

   Usage example:

     (define-record-type <duo>
       (private
         (fields one two)))

     (define/friend ({add <number>} {O <duo>})
       (+ (.one O) (.two O)))

     (define O
       (new <duo> 1 2))

     (add O)  => 3


File: vicare-typed.info,  Node: Package License,  Next: references,  Prev: friends,  Up: Top

Appendix A GNU General Public License
*************************************

                        Version 3, 29 June 2007

     Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     "This License" refers to version 3 of the GNU General Public
     License.

     "Copyright" also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     "The Program" refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as "you".  "Licensees" and
     "recipients" may be individuals or organizations.

     To "modify" a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a "modified
     version" of the earlier work or a work "based on" the earlier work.

     A "covered work" means either the unmodified Program or a work
     based on the Program.

     To "propagate" a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it on
     a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To "convey" a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays "Appropriate Legal Notices"
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may convey
     the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The "source code" for a work means the preferred form of the work
     for making modifications to it.  "Object code" means any non-source
     form of a work.

     A "Standard Interface" means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The "System Libraries" of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work with
     that Major Component, or to implement a Standard Interface for
     which an implementation is available to the public in source code
     form.  A "Major Component", in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The "Corresponding Source" for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including scripts
     to control those activities.  However, it does not include the
     work's System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files associated
     with source files for the work, and the source code for shared
     libraries and dynamically linked subprograms that the work is
     specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output, given
     its content, constitutes a covered work.  This License acknowledges
     your rights of fair use or other equivalent, as provided by
     copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for you,
     or provide you with facilities for running those works, provided
     that you comply with the terms of this License in conveying all
     material for which you do not control copyright.  Those thus making
     or running the covered works for you must do so exclusively on your
     behalf, under your direction and control, on terms that prohibit
     them from making any copies of your copyrighted material outside
     their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention to
     limit operation or modification of the work as a means of
     enforcing, against the work's users, your or third parties' legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program's source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to "keep intact all notices".

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an "aggregate" if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation's users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for as
          long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of the
          written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access to
          the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated by
          you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to the
          object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long as
          needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.

     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A "User Product" is either (1) a "consumer product", which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product is
     a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     "normally used" refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     "Installation Information" for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or installed
     by the recipient, or for the User Product in which it has been
     modified or installed.  Access to a network may be denied when the
     modification itself materially and adversely affects the operation
     of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     "Additional permissions" are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License with
     terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be marked
          in reasonable ways as different from the original version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered "further
     restrictions" within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or conveying
     under this License, you may add to a covered work material governed
     by the terms of that license document, provided that the further
     restriction does not survive such relicensing or conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under the
     third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, you do not qualify to receive new licenses
     for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An "entity transaction" is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party's predecessor in interest had or
     could give under the previous paragraph, plus a right to possession
     of the Corresponding Source of the work from the predecessor in
     interest, if the predecessor has it or can get it with reasonable
     efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for exercise
     of rights granted under this License, and you may not initiate
     litigation (including a cross-claim or counterclaim in a lawsuit)
     alleging that any patent claim is infringed by making, using,
     selling, offering for sale, or importing the Program or any portion
     of it.

  11. Patents.

     A "contributor" is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor's "contributor
     version".

     A contributor's "essential patent claims" are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, "control"
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor's essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its contributor
     version.

     In the following three paragraphs, a "patent license" is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To "grant"
     such a patent license to a party means to make such an agreement or
     commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  "Knowingly relying" means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient's use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is "discriminatory" if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under which
     you make payment to the third party based on the extent of your
     activity of conveying the work, and under which the third party
     grants, to any of the parties who would receive the covered work
     from you, a discriminatory patent license (a) in connection with
     copies of the covered work conveyed by you (or copies made from
     those copies), or (b) primarily for and in connection with specific
     products or compilations that contain the covered work, unless you
     entered into that arrangement, or that patent license was granted,
     prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

     If conditions are imposed on you (whether by court order, agreement
     or otherwise) that contradict the conditions of this License, they
     do not excuse you from the conditions of this License.  If you
     cannot convey a covered work so as to satisfy simultaneously your
     obligations under this License and any other pertinent obligations,
     then as a consequence you may not convey it at all.  For example,
     if you agree to terms that obligate you to collect a royalty for
     further conveying from those to whom you convey the Program, the
     only way you could satisfy both those terms and this License would
     be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

  14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the Free
     Software Foundation.  If the Program does not specify a version
     number of the GNU General Public License, you may choose any
     version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

  15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
     DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type 'show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.


File: vicare-typed.info,  Node: references,  Next: concept index,  Prev: Package License,  Up: Top

Appendix B Bibliography and references
**************************************


File: vicare-typed.info,  Node: concept index,  Next: function index,  Prev: references,  Up: Top

Appendix C An entry for each concept
************************************

 [index ]
* Menu:

* (vicare language-extensions interfaces), library: interfaces. (line 6)
* (vicare language-extensions labels), library: labels.         (line 6)
* (vicare language-extensions mixins), library: mixins.         (line 6)
* (vicare system type-descriptors), library: descriptors.       (line 6)
* Concrete methods:                      methods.               (line 6)
* Friend functions:                      friends.               (line 6)
* Functions, overloaded:                 syntaxes overloads.    (line 6)
* Library (vicare language-extensions interfaces): interfaces.  (line 6)
* Library (vicare language-extensions labels): labels.          (line 6)
* Library (vicare language-extensions mixins): mixins.          (line 6)
* Library (vicare system type-descriptors): descriptors.        (line 6)
* method, interface-type definition clause: methods.            (line 6)
* method, label-type definition clause:  methods.               (line 6)
* method, mixin definition clause:       methods.               (line 6)
* method, record-type definition clause: methods.               (line 6)
* Methods:                               methods.               (line 6)
* Overloaded functions:                  syntaxes overloads.    (line 6)
* Protection levels for record-type's members: protlev.         (line 6)
* Record-types, friend functions:        friends.               (line 6)
* Record-types, protection levels for members: protlev.         (line 6)
* seal-method, mixin definition clause:  methods.               (line 6)
* seal-method, record-type definition clause: methods.          (line 6)
* Sealing methods:                       methods.               (line 6)
* Virtual methods:                       methods.               (line 6)
* virtual-method, mixin definition clause: methods.             (line 6)
* virtual-method, record-type definition clause: methods.       (line 6)


File: vicare-typed.info,  Node: function index,  Next: variable index,  Prev: concept index,  Up: Top

Appendix D An entry for each function.
**************************************

 [index ]
* Menu:

* != on <char>:                          built-in chars.      (line  49)
* != on <number>:                        built-in numerics number.
                                                              (line  78)
* != on <pointer>:                       built-in pointers.   (line  42)
* != on <record>:                        built-in records base.
                                                              (line  30)
* != on <string>:                        built-in strings base.
                                                              (line  81)
* != on <struct>:                        built-in structs base.
                                                              (line  54)
* != on <symbol>:                        built-in symbols symbols.
                                                              (line  47)
* != on <time>:                          built-in time time.  (line  76)
* * on <number>:                         built-in numerics number.
                                                              (line  90)
* + on <epoch-time>:                     built-in time epoch. (line  26)
* + on <number>:                         built-in numerics number.
                                                              (line  84)
* + on <time>:                           built-in time time.  (line  60)
* - on <epoch-time>:                     built-in time epoch. (line  29)
* - on <number>:                         built-in numerics number.
                                                              (line  87)
* - on <time>:                           built-in time time.  (line  64)
* / on <number>:                         built-in numerics number.
                                                              (line  93)
* < on <char>:                           built-in chars.      (line  52)
* < on <pointer>:                        built-in pointers.   (line  46)
* < on <real>:                           built-in numerics real base.
                                                              (line  38)
* < on <string>:                         built-in strings base.
                                                              (line  82)
* < on <symbol>:                         built-in symbols symbols.
                                                              (line  51)
* < on <time>:                           built-in time time.  (line  81)
* <= on <char>:                          built-in chars.      (line  58)
* <= on <pointer>:                       built-in pointers.   (line  54)
* <= on <real>:                          built-in numerics real base.
                                                              (line  44)
* <= on <real> <1>:                      built-in numerics real base.
                                                              (line  47)
* <= on <string>:                        built-in strings base.
                                                              (line  84)
* <= on <symbol>:                        built-in symbols symbols.
                                                              (line  59)
* <= on <time>:                          built-in time time.  (line  85)
* = on <char>:                           built-in chars.      (line  46)
* = on <enum-set>:                       built-in enum-set.   (line  67)
* = on <number>:                         built-in numerics number.
                                                              (line  75)
* = on <pointer>:                        built-in pointers.   (line  38)
* = on <record>:                         built-in records base.
                                                              (line  27)
* = on <string>:                         built-in strings base.
                                                              (line  80)
* = on <struct>:                         built-in structs base.
                                                              (line  51)
* = on <symbol>:                         built-in symbols symbols.
                                                              (line  43)
* = on <time>:                           built-in time time.  (line  73)
* =>:                                    syntaxes case-type.  (line   9)
* > on <char>:                           built-in chars.      (line  55)
* > on <pointer>:                        built-in pointers.   (line  50)
* > on <real>:                           built-in numerics real base.
                                                              (line  41)
* > on <string>:                         built-in strings base.
                                                              (line  83)
* > on <symbol>:                         built-in symbols symbols.
                                                              (line  55)
* > on <time>:                           built-in time time.  (line  89)
* >= on <char>:                          built-in chars.      (line  61)
* >= on <pointer>:                       built-in pointers.   (line  58)
* >= on <string>:                        built-in strings base.
                                                              (line  85)
* >= on <symbol>:                        built-in symbols symbols.
                                                              (line  63)
* >= on <time>:                          built-in time time.  (line  93)
* _:                                     syntaxes predicates. (line  10)
* abs on <real>:                         built-in numerics real base.
                                                              (line  53)
* acos on <number>:                      built-in numerics number.
                                                              (line 137)
* acosh on <number>:                     built-in numerics number.
                                                              (line 153)
* add on <pointer>:                      built-in pointers.   (line  65)
* add1 on <number>:                      built-in numerics number.
                                                              (line  96)
* alist-type-descr.key-des:              descriptors compound alist.
                                                              (line  26)
* alist-type-descr.val-des:              descriptors compound alist.
                                                              (line  27)
* alist-type-descr?:                     descriptors compound alist.
                                                              (line  22)
* all-field-names on <record-type-descriptor>: built-in records rtd.
                                                              (line  55)
* alphabetic? on <char>:                 built-in chars.      (line 104)
* ancestor-of-type-descr.ancestor-des*:  descriptors compound ancestor.
                                                              (line  28)
* ancestor-of-type-descr.item-des:       descriptors compound ancestor.
                                                              (line  27)
* ancestor-of-type-descr?:               descriptors compound ancestor.
                                                              (line  23)
* angle on <number>:                     built-in numerics number.
                                                              (line  59)
* append on <bytevector>:                built-in bytevectors base.
                                                              (line  39)
* append on <list>:                      built-in lists base. (line  39)
* append on <string>:                    built-in strings base.
                                                              (line  50)
* append on <vector>:                    built-in vectors base.
                                                              (line  43)
* ascii on <string>:                     built-in strings base.
                                                              (line 163)
* ascii-encoded? on <string>:            built-in strings base.
                                                              (line  62)
* asin on <number>:                      built-in numerics number.
                                                              (line 136)
* asinh on <number>:                     built-in numerics number.
                                                              (line 152)
* assert-signature:                      syntaxes assert.     (line   8)
* assert-signature-and-return:           syntaxes assert.     (line   9)
* atan on <number>:                      built-in numerics number.
                                                              (line 138)
* atan on <number> <1>:                  built-in numerics number.
                                                              (line 139)
* atanh on <number>:                     built-in numerics number.
                                                              (line 154)
* base64->bytevector on <string>:        built-in strings base.
                                                              (line 178)
* bound? on <symbol>:                    built-in symbols symbols.
                                                              (line  26)
* brace:                                 syntaxes overloads.  (line 155)
* buffer-mode on <textual-input/output-port>: built-in ports texio.
                                                              (line  41)
* buffer-mode on <textual-input/output-port> <1>: built-in ports texio.
                                                              (line  43)
* buffer-mode on <textual-output-only-port>: built-in ports texou.
                                                              (line  22)
* buffer-mode on <textual-output-only-port> <1>: built-in ports texou.
                                                              (line  24)
* bytes-major on <stats>:                built-in stats.      (line  81)
* bytes-minor on <stats>:                built-in stats.      (line  77)
* bytevector on <bignum>:                built-in numerics bignums base.
                                                              (line  25)
* bytevector on <string>:                built-in strings base.
                                                              (line 159)
* bytevector on <string> <1>:            built-in strings base.
                                                              (line 160)
* car on <ipair>:                        built-in pairs immutable.
                                                              (line  28)
* car on <nelist>:                       built-in lists non-empty.
                                                              (line  23)
* car on <pair>:                         built-in pairs base. (line  28)
* case-define/checked:                   syntaxes variables.  (line 171)
* case-define/std:                       syntaxes variables.  (line  89)
* case-define/typed:                     syntaxes variables.  (line 308)
* case-lambda-descriptors.clause-signature*: descriptors signatures case-lambda.
                                                              (line  24)
* case-lambda-descriptors?:              descriptors signatures case-lambda.
                                                              (line  20)
* case-lambda/checked:                   syntaxes variables.  (line 225)
* case-lambda/std:                       syntaxes variables.  (line 107)
* case-lambda/typed:                     syntaxes variables.  (line 329)
* case-type:                             syntaxes case-type.  (line   8)
* cast-signature:                        syntaxes assert.     (line  10)
* cbrt on <number>:                      built-in numerics number.
                                                              (line 124)
* cdr on <ipair>:                        built-in pairs immutable.
                                                              (line  31)
* cdr on <nelist>:                       built-in lists non-empty.
                                                              (line  26)
* cdr on <pair>:                         built-in pairs base. (line  31)
* ceiling on <real>:                     built-in numerics real base.
                                                              (line  71)
* ci!= on <char>:                        built-in chars.      (line  67)
* ci< on <char>:                         built-in chars.      (line  70)
* ci< on <string>:                       built-in strings base.
                                                              (line  91)
* ci<= on <char>:                        built-in chars.      (line  76)
* ci<= on <string>:                      built-in strings base.
                                                              (line  93)
* ci= on <char>:                         built-in chars.      (line  64)
* ci= on <string>:                       built-in strings base.
                                                              (line  90)
* ci> on <char>:                         built-in chars.      (line  73)
* ci> on <string>:                       built-in strings base.
                                                              (line  92)
* ci>= on <char>:                        built-in chars.      (line  79)
* ci>= on <string>:                      built-in strings base.
                                                              (line  94)
* circular? on <list>:                   built-in lists base. (line  29)
* clone on <pointer>:                    built-in pointers.   (line  71)
* close on <binary-input-port>:          built-in ports labels binin.
                                                              (line 111)
* close on <binary-output-port>:         built-in ports labels binou.
                                                              (line 111)
* close on <binary-port>:                built-in ports labels binary.
                                                              (line 106)
* close on <input-port>:                 built-in ports labels input.
                                                              (line 105)
* close on <input/output-port>:          built-in ports labels input/output.
                                                              (line 111)
* close on <output-port>:                built-in ports labels output.
                                                              (line 106)
* close on <port>:                       built-in ports base. (line 100)
* close on <textual-input-port>:         built-in ports labels texin.
                                                              (line 111)
* close on <textual-output-port>:        built-in ports labels texou.
                                                              (line 111)
* close on <textual-port>:               built-in ports labels textual.
                                                              (line 109)
* closed? on <binary-input-port>:        built-in ports labels binin.
                                                              (line  33)
* closed? on <binary-output-port>:       built-in ports labels binou.
                                                              (line  33)
* closed? on <binary-port>:              built-in ports labels binary.
                                                              (line  32)
* closed? on <input-port>:               built-in ports labels input.
                                                              (line  32)
* closed? on <input/output-port>:        built-in ports labels input/output.
                                                              (line  33)
* closed? on <output-port>:              built-in ports labels output.
                                                              (line  32)
* closed? on <port>:                     built-in ports base. (line  27)
* closed? on <textual-input-port>:       built-in ports labels texin.
                                                              (line  33)
* closed? on <textual-output-port>:      built-in ports labels texou.
                                                              (line  33)
* closed? on <textual-port>:             built-in ports labels textual.
                                                              (line  33)
* closure-type-descr.signature:          descriptors compound closure.
                                                              (line  24)
* closure-type-descr?:                   descriptors compound closure.
                                                              (line  20)
* codec on <transcoder>:                 built-in transcoders.
                                                              (line  28)
* collection-id on <stats>:              built-in stats.      (line  49)
* comparison-procedure:                  syntaxes operations. (line  46)
* comparison-procedure <1>:              labels.              (line  30)
* comparison-procedure on <real>:        built-in numerics real base.
                                                              (line  18)
* comparison-procedure on <string>:      built-in strings base.
                                                              (line  21)
* comparison-procedure on <time>:        built-in time time.  (line  34)
* complement on <enum-set>:              built-in enum-set.   (line  85)
* complement-type-descr.item-des:        descriptors compound complem.
                                                              (line  23)
* complement-type-descr?:                descriptors compound complem.
                                                              (line  19)
* complex-conjugate on <number>:         built-in numerics number.
                                                              (line  68)
* compound-condition-type-descr.component-des*: descriptors compound condobj.
                                                              (line  25)
* compound-condition-type-descr?:        descriptors compound condobj.
                                                              (line  21)
* constructor:                           labels.              (line  26)
* constructor on <enum-set>:             built-in enum-set.   (line  49)
* constructor on <epoch-time>:           built-in time epoch. (line  17)
* constructor on <struct-type-descriptor>: built-in structs std.
                                                              (line  36)
* constructor on <time>:                 built-in time time.  (line  16)
* constructor on <time> <1>:             built-in time time.  (line  18)
* copy on <bytevector>:                  built-in bytevectors base.
                                                              (line  44)
* copy on <string>:                      built-in strings base.
                                                              (line  47)
* copy! on <bytevector>:                 built-in bytevectors base.
                                                              (line  48)
* core-type-descriptor.comparison-procedure: descriptors core.
                                                              (line  82)
* core-type-descriptor.equality-predicate: descriptors core.  (line  81)
* core-type-descriptor.hash-function:    descriptors core.    (line  83)
* core-type-descriptor.method-retriever: descriptors core.    (line  84)
* core-type-descriptor.name:             descriptors core.    (line  77)
* core-type-descriptor.parent:           descriptors core.    (line  78)
* core-type-descriptor.type-predicate:   descriptors core.    (line  80)
* core-type-descriptor.uid:              descriptors core.    (line  87)
* core-type-descriptor.uids-list:        descriptors core.    (line  79)
* core-type-descriptor?:                 descriptors core.    (line  73)
* cos on <number>:                       built-in numerics number.
                                                              (line 131)
* cosh on <number>:                      built-in numerics number.
                                                              (line 147)
* cube on <number>:                      built-in numerics number.
                                                              (line 118)
* define-interface-type:                 interfaces defs.     (line   9)
* define-label-type:                     labels.              (line  23)
* define-mixin-type:                     mixins.              (line  83)
* define-type:                           syntaxes define.     (line   8)
* define-type <1>:                       syntaxes define.     (line   9)
* define/checked:                        syntaxes variables.  (line 140)
* define/checked <1>:                    syntaxes variables.  (line 141)
* define/checked <2>:                    syntaxes variables.  (line 142)
* define/friend:                         friends.             (line   9)
* define/overload:                       syntaxes overloads.  (line 152)
* define/overload <1>:                   syntaxes overloads.  (line 153)
* define/std:                            syntaxes variables.  (line  82)
* define/std <1>:                        syntaxes variables.  (line  83)
* define/std <2>:                        syntaxes variables.  (line  84)
* define/typed:                          syntaxes variables.  (line 291)
* define/typed <1>:                      syntaxes variables.  (line 292)
* define/typed <2>:                      syntaxes variables.  (line 293)
* delete:                                syntaxes new-delete. (line  31)
* denominator on <real>:                 built-in numerics real base.
                                                              (line  59)
* descriptors-signature-matching:        descriptors relations.
                                                              (line 107)
* descriptors-signature.object-type-descrs: descriptors signatures descriptors.
                                                              (line  24)
* descriptors-signature?:                descriptors signatures descriptors.
                                                              (line  20)
* destructor:                            labels.              (line  27)
* destructor on <struct-type-descriptor>: built-in structs std.
                                                              (line  49)
* destructor on <struct>:                built-in structs base.
                                                              (line  44)
* diff on <pointer>:                     built-in pointers.   (line  68)
* difference on <enum-set>:              built-in enum-set.   (line  81)
* div on <exact-integer>:                built-in numerics exact-integer base.
                                                              (line  26)
* div-and-mod on <exact-integer>:        built-in numerics exact-integer base.
                                                              (line  34)
* div0 on <exact-integer>:               built-in numerics exact-integer base.
                                                              (line  38)
* div0-and-mod0 on <exact-integer>:      built-in numerics exact-integer base.
                                                              (line  46)
* downcase on <char>:                    built-in chars.      (line  88)
* downcase on <string>:                  built-in strings base.
                                                              (line 108)
* dump-status on <binary-input-port>:    built-in ports labels binin.
                                                              (line  81)
* dump-status on <binary-output-port>:   built-in ports labels binou.
                                                              (line  81)
* dump-status on <binary-port>:          built-in ports labels binary.
                                                              (line  79)
* dump-status on <input-port>:           built-in ports labels input.
                                                              (line  78)
* dump-status on <input/output-port>:    built-in ports labels input/output.
                                                              (line  81)
* dump-status on <output-port>:          built-in ports labels output.
                                                              (line  79)
* dump-status on <port>:                 built-in ports base. (line  73)
* dump-status on <textual-input-port>:   built-in ports labels texin.
                                                              (line  81)
* dump-status on <textual-output-port>:  built-in ports labels texou.
                                                              (line  81)
* dump-status on <textual-port>:         built-in ports labels textual.
                                                              (line  80)
* else:                                  syntaxes case-type.  (line  10)
* empty? on <string>:                    built-in strings base.
                                                              (line  32)
* enumeration-type-descr.symbols*:       descriptors compound enum.
                                                              (line  23)
* enumeration-type-descr?:               descriptors compound enum.
                                                              (line  19)
* eof? on <binary-input-only-port>:      built-in ports binin.
                                                              (line  22)
* eof? on <binary-input-port>:           built-in ports labels binin.
                                                              (line 120)
* eof? on <binary-input/output-port>:    built-in ports binio.
                                                              (line  22)
* eof? on <input-port>:                  built-in ports labels input.
                                                              (line 114)
* eof? on <input/output-port>:           built-in ports labels input/output.
                                                              (line 120)
* eof? on <textual-input-only-port>:     built-in ports texin.
                                                              (line  35)
* eof? on <textual-input-port>:          built-in ports labels texin.
                                                              (line 120)
* eof? on <textual-input/output-port>:   built-in ports texio.
                                                              (line  35)
* eol-style on <transcoder>:             built-in transcoders.
                                                              (line  32)
* equality-predicate:                    syntaxes operations. (line  39)
* equality-predicate <1>:                labels.              (line  29)
* equality-predicate on <binary-input-port>: built-in ports labels binin.
                                                              (line  21)
* equality-predicate on <binary-input-port> <1>: built-in ports labels binou.
                                                              (line  21)
* equality-predicate on <binary-port>:   built-in ports labels binary.
                                                              (line  20)
* equality-predicate on <bytevector>:    built-in bytevectors base.
                                                              (line  19)
* equality-predicate on <enum-set>:      built-in enum-set.   (line  17)
* equality-predicate on <eof>:           built-in unique eof. (line  17)
* equality-predicate on <input-port>:    built-in ports labels input.
                                                              (line  20)
* equality-predicate on <input/output-port>: built-in ports labels input/output.
                                                              (line  21)
* equality-predicate on <ipair>:         built-in pairs immutable.
                                                              (line  18)
* equality-predicate on <keyword>:       built-in keywords.   (line  21)
* equality-predicate on <list>:          built-in lists base. (line  20)
* equality-predicate on <memory-block>:  built-in memory-block.
                                                              (line  17)
* equality-predicate on <number>:        built-in numerics number.
                                                              (line  18)
* equality-predicate on <output-port>:   built-in ports labels output.
                                                              (line  20)
* equality-predicate on <pair>:          built-in pairs base. (line  18)
* equality-predicate on <pointer>:       built-in pointers.   (line  18)
* equality-predicate on <port>:          built-in ports base. (line  16)
* equality-predicate on <promise>:       built-in promises.   (line  23)
* equality-predicate on <reader-annotation>: built-in reader-annotation.
                                                              (line  19)
* equality-predicate on <record>:        built-in records base.
                                                              (line  16)
* equality-predicate on <sentinel>:      built-in unique sentinel.
                                                              (line  17)
* equality-predicate on <stats>:         built-in stats.      (line  16)
* equality-predicate on <string>:        built-in strings base.
                                                              (line  17)
* equality-predicate on <struct>:        built-in structs base.
                                                              (line  17)
* equality-predicate on <tcbucket>:      built-in hashtables tcbucket.
                                                              (line  15)
* equality-predicate on <textual-input-port>: built-in ports labels texin.
                                                              (line  21)
* equality-predicate on <textual-input-port> <1>: built-in ports labels texou.
                                                              (line  21)
* equality-predicate on <textual-port>:  built-in ports labels textual.
                                                              (line  21)
* equality-predicate on <time>:          built-in time time.  (line  29)
* equality-predicate on <utsname>:       built-in utsname.    (line  17)
* equality-predicate on <vector>:        built-in vectors base.
                                                              (line  17)
* equality-predicate on <would-block>:   built-in unique would-block.
                                                              (line  17)
* even? on <bignum>:                     built-in numerics bignums base.
                                                              (line  32)
* even? on <number>:                     built-in numerics number.
                                                              (line  41)
* exact on <number>:                     built-in numerics number.
                                                              (line  47)
* exact-integer-sqrt on <exact-integer>: built-in numerics exact-integer base.
                                                              (line  50)
* exists on <vector>:                    built-in vectors base.
                                                              (line  62)
* exp on <number>:                       built-in numerics number.
                                                              (line 105)
* expression on <reader-annotation>:     built-in reader-annotation.
                                                              (line  30)
* expt on <number>:                      built-in numerics number.
                                                              (line 112)
* factorial on <integer>:                built-in numerics integer.
                                                              (line  40)
* fd on <binary-input-port>:             built-in ports labels binin.
                                                              (line  74)
* fd on <binary-output-port>:            built-in ports labels binou.
                                                              (line  74)
* fd on <binary-port>:                   built-in ports labels binary.
                                                              (line  73)
* fd on <input-port>:                    built-in ports labels input.
                                                              (line  72)
* fd on <input/output-port>:             built-in ports labels input/output.
                                                              (line  74)
* fd on <output-port>:                   built-in ports labels output.
                                                              (line  73)
* fd on <port>:                          built-in ports base. (line  67)
* fd on <textual-input-port>:            built-in ports labels texin.
                                                              (line  74)
* fd on <textual-output-port>:           built-in ports labels texou.
                                                              (line  74)
* fd on <textual-port>:                  built-in ports labels textual.
                                                              (line  74)
* field-accessor on <struct-type-descriptor>: built-in structs std.
                                                              (line  54)
* field-accessor on <struct-type-descriptor> <1>: built-in structs std.
                                                              (line  56)
* field-method on <struct-type-descriptor>: built-in structs std.
                                                              (line  68)
* field-method on <struct-type-descriptor> <1>: built-in structs std.
                                                              (line  70)
* field-mutator on <struct-type-descriptor>: built-in structs std.
                                                              (line  61)
* field-mutator on <struct-type-descriptor> <1>: built-in structs std.
                                                              (line  63)
* field-names on <record-type-descriptor>: built-in records rtd.
                                                              (line  50)
* field-names on <struct-type-descriptor>: built-in structs std.
                                                              (line  31)
* field-names on <struct>:               built-in structs base.
                                                              (line  37)
* fill! on <bytevector>:                 built-in bytevectors base.
                                                              (line  54)
* fill! on <string>:                     built-in strings base.
                                                              (line  56)
* fill! on <vector>:                     built-in vectors base.
                                                              (line  34)
* find on <vector>:                      built-in vectors base.
                                                              (line  65)
* finite? on <number>:                   built-in numerics number.
                                                              (line  35)
* fixnum on <char>:                      built-in chars.      (line  41)
* flonum on <string>:                    built-in strings base.
                                                              (line 132)
* flonum on <time>:                      built-in time time.  (line  53)
* floor on <real>:                       built-in numerics real base.
                                                              (line  68)
* flush on <binary-input/output-port>:   built-in ports binio.
                                                              (line  28)
* flush on <binary-output-only-port>:    built-in ports binou.
                                                              (line  22)
* flush on <binary-output-port>:         built-in ports labels binou.
                                                              (line 120)
* flush on <input/output-port>:          built-in ports labels input/output.
                                                              (line 126)
* flush on <output-port>:                built-in ports labels output.
                                                              (line 115)
* flush on <textual-input/output-port>:  built-in ports texio.
                                                              (line  49)
* flush on <textual-output-only-port>:   built-in ports texou.
                                                              (line  30)
* flush on <textual-output-port>:        built-in ports labels texou.
                                                              (line 120)
* fold-left on <vector>:                 built-in vectors base.
                                                              (line  68)
* fold-right on <vector>:                built-in vectors base.
                                                              (line  71)
* foldcase on <char>:                    built-in chars.      (line  91)
* foldcase on <string>:                  built-in strings base.
                                                              (line 111)
* for-all on <vector>:                   built-in vectors base.
                                                              (line  59)
* for-each on <string>:                  built-in strings base.
                                                              (line  38)
* for-each on <vector>:                  built-in vectors base.
                                                              (line  56)
* force on <promise>:                    built-in promises.   (line  34)
* gc-real-secs on <stats>:               built-in stats.      (line  69)
* gc-real-usecs on <stats>:              built-in stats.      (line  73)
* gc-sys-secs on <stats>:                built-in stats.      (line  61)
* gc-sys-usecs on <stats>:               built-in stats.      (line  65)
* gc-user-secs on <stats>:               built-in stats.      (line  53)
* gc-user-usecs on <stats>:              built-in stats.      (line  57)
* gcd on <integer>:                      built-in numerics integer.
                                                              (line  20)
* general-category on <char>:            built-in chars.      (line 100)
* generative? on <record-type-descriptor>: built-in records rtd.
                                                              (line  34)
* generative? on <record-type-descriptor> <1>: built-in records rtd.
                                                              (line  46)
* getprop on <binary-input-port>:        built-in ports labels binin.
                                                              (line  97)
* getprop on <binary-output-port>:       built-in ports labels binou.
                                                              (line  97)
* getprop on <binary-port>:              built-in ports labels binary.
                                                              (line  93)
* getprop on <input-port>:               built-in ports labels input.
                                                              (line  92)
* getprop on <input/output-port>:        built-in ports labels input/output.
                                                              (line  97)
* getprop on <output-port>:              built-in ports labels output.
                                                              (line  93)
* getprop on <port>:                     built-in ports base. (line  87)
* getprop on <symbol>:                   built-in symbols symbols.
                                                              (line  79)
* getprop on <textual-input-port>:       built-in ports labels texin.
                                                              (line  97)
* getprop on <textual-output-port>:      built-in ports labels texou.
                                                              (line  97)
* getprop on <textual-port>:             built-in ports labels textual.
                                                              (line  95)
* handling-mode on <transcoder>:         built-in transcoders.
                                                              (line  36)
* has-position? on <binary-input-port>:  built-in ports labels binin.
                                                              (line  53)
* has-position? on <binary-output-port>: built-in ports labels binou.
                                                              (line  53)
* has-position? on <binary-port>:        built-in ports labels binary.
                                                              (line  52)
* has-position? on <input-port>:         built-in ports labels input.
                                                              (line  52)
* has-position? on <input/output-port>:  built-in ports labels input/output.
                                                              (line  53)
* has-position? on <output-port>:        built-in ports labels output.
                                                              (line  52)
* has-position? on <port>:               built-in ports base. (line  47)
* has-position? on <textual-input-port>: built-in ports labels texin.
                                                              (line  53)
* has-position? on <textual-output-port>: built-in ports labels texou.
                                                              (line  53)
* has-position? on <textual-port>:       built-in ports labels textual.
                                                              (line  53)
* has-set-position? on <binary-input-port>: built-in ports labels binin.
                                                              (line  57)
* has-set-position? on <binary-output-port>: built-in ports labels binou.
                                                              (line  57)
* has-set-position? on <binary-port>:    built-in ports labels binary.
                                                              (line  56)
* has-set-position? on <input-port>:     built-in ports labels input.
                                                              (line  56)
* has-set-position? on <input/output-port>: built-in ports labels input/output.
                                                              (line  57)
* has-set-position? on <output-port>:    built-in ports labels output.
                                                              (line  56)
* has-set-position? on <port>:           built-in ports base. (line  51)
* has-set-position? on <textual-input-port>: built-in ports labels texin.
                                                              (line  57)
* has-set-position? on <textual-output-port>: built-in ports labels texou.
                                                              (line  57)
* has-set-position? on <textual-port>:   built-in ports labels textual.
                                                              (line  57)
* hash:                                  syntaxes operations. (line  60)
* hash-function:                         syntaxes operations. (line  53)
* hash-function <1>:                     labels.              (line  31)
* hash-function on <bignum>:             built-in numerics bignums base.
                                                              (line  18)
* hash-function on <binary-input-port>:  built-in ports labels binin.
                                                              (line  25)
* hash-function on <binary-input-port> <1>: built-in ports labels binou.
                                                              (line  25)
* hash-function on <binary-port>:        built-in ports labels binary.
                                                              (line  24)
* hash-function on <boolean>:            built-in booleans boolean.
                                                              (line  25)
* hash-function on <bytevector>:         built-in bytevectors base.
                                                              (line  23)
* hash-function on <cflonum>:            built-in numerics cflonums base.
                                                              (line  17)
* hash-function on <char>:               built-in chars.      (line  23)
* hash-function on <compnum>:            built-in numerics compnums base.
                                                              (line  17)
* hash-function on <enum-set>:           built-in enum-set.   (line  21)
* hash-function on <eof>:                built-in unique eof. (line  21)
* hash-function on <exact-integer>:      built-in numerics exact-integer base.
                                                              (line  19)
* hash-function on <false>:              built-in booleans false.
                                                              (line  22)
* hash-function on <fixnum>:             built-in numerics fixnums base.
                                                              (line  17)
* hash-function on <flonum>:             built-in numerics flonums base.
                                                              (line  17)
* hash-function on <input-port>:         built-in ports labels input.
                                                              (line  24)
* hash-function on <input/output-port>:  built-in ports labels input/output.
                                                              (line  25)
* hash-function on <ipair>:              built-in pairs immutable.
                                                              (line  22)
* hash-function on <keyword>:            built-in keywords.   (line  17)
* hash-function on <list>:               built-in lists base. (line  23)
* hash-function on <memory-block>:       built-in memory-block.
                                                              (line  21)
* hash-function on <number>:             built-in numerics number.
                                                              (line  22)
* hash-function on <output-port>:        built-in ports labels output.
                                                              (line  24)
* hash-function on <pair>:               built-in pairs base. (line  22)
* hash-function on <pointer>:            built-in pointers.   (line  22)
* hash-function on <port>:               built-in ports base. (line  20)
* hash-function on <promise>:            built-in promises.   (line  27)
* hash-function on <ratnum>:             built-in numerics ratnums base.
                                                              (line  17)
* hash-function on <reader-annotation>:  built-in reader-annotation.
                                                              (line  23)
* hash-function on <record>:             built-in records base.
                                                              (line  20)
* hash-function on <sentinel>:           built-in unique sentinel.
                                                              (line  21)
* hash-function on <stats>:              built-in stats.      (line  20)
* hash-function on <string>:             built-in strings base.
                                                              (line  25)
* hash-function on <struct>:             built-in structs base.
                                                              (line  21)
* hash-function on <symbol>:             built-in symbols symbols.
                                                              (line  17)
* hash-function on <textual-input-port>: built-in ports labels texin.
                                                              (line  25)
* hash-function on <textual-input-port> <1>: built-in ports labels texou.
                                                              (line  25)
* hash-function on <textual-port>:       built-in ports labels textual.
                                                              (line  25)
* hash-function on <time>:               built-in time time.  (line  39)
* hash-function on <transcoder>:         built-in transcoders.
                                                              (line  21)
* hash-function on <true>:               built-in booleans true.
                                                              (line  22)
* hash-function on <utsname>:            built-in utsname.    (line  21)
* hash-function on <vector>:             built-in vectors base.
                                                              (line  21)
* hash-function on <would-block>:        built-in unique would-block.
                                                              (line  21)
* hashtable-type-descr.key-des:          descriptors compound hashtable.
                                                              (line  26)
* hashtable-type-descr.val-des:          descriptors compound hashtable.
                                                              (line  27)
* hashtable-type-descr?:                 descriptors compound hashtable.
                                                              (line  22)
* hex->bytevector on <string>:           built-in strings base.
                                                              (line 181)
* id on <binary-input-port>:             built-in ports labels binin.
                                                              (line  71)
* id on <binary-output-port>:            built-in ports labels binou.
                                                              (line  71)
* id on <binary-port>:                   built-in ports labels binary.
                                                              (line  70)
* id on <input-port>:                    built-in ports labels input.
                                                              (line  69)
* id on <input/output-port>:             built-in ports labels input/output.
                                                              (line  71)
* id on <output-port>:                   built-in ports labels output.
                                                              (line  70)
* id on <port>:                          built-in ports base. (line  64)
* id on <textual-input-port>:            built-in ports labels texin.
                                                              (line  71)
* id on <textual-output-port>:           built-in ports labels texou.
                                                              (line  71)
* id on <textual-port>:                  built-in ports labels textual.
                                                              (line  71)
* imag-part on <number>:                 built-in numerics number.
                                                              (line  65)
* implemented-interfaces on <record-type-descriptor>: built-in records rtd.
                                                              (line  65)
* implements:                            interfaces defs.     (line  12)
* indexer on <enum-set>:                 built-in enum-set.   (line  45)
* inexact on <number>:                   built-in numerics number.
                                                              (line  50)
* infinite? on <number>:                 built-in numerics number.
                                                              (line  36)
* integer on <char>:                     built-in chars.      (line  36)
* integer on <pointer>:                  built-in pointers.   (line  32)
* interface-type-descr.implemented-interface-uids: descriptors other interface.
                                                              (line  50)
* interface-type-descr.method-prototype-names: descriptors other interface.
                                                              (line  51)
* interface-type-descr.method-retriever: descriptors other interface.
                                                              (line  52)
* interface-type-descr.parent-type-descriptor: descriptors other interface.
                                                              (line  49)
* interface-type-descr.type-name:        descriptors other interface.
                                                              (line  47)
* interface-type-descr.uid:              descriptors other interface.
                                                              (line  48)
* interface-type-descr?:                 descriptors other interface.
                                                              (line  43)
* intersection on <enum-set>:            built-in enum-set.   (line  77)
* intersection-type-descr.item-des*:     descriptors compound intersect.
                                                              (line  24)
* intersection-type-descr?:              descriptors compound intersect.
                                                              (line  20)
* is-a?:                                 syntaxes predicates. (line   8)
* is-a? <1>:                             syntaxes predicates. (line   9)
* keyword on <string>:                   built-in strings base.
                                                              (line 187)
* lambda-descriptors.argvals:            descriptors signatures lambda.
                                                              (line  29)
* lambda-descriptors.retvals:            descriptors signatures lambda.
                                                              (line  28)
* lambda-descriptors?:                   descriptors signatures lambda.
                                                              (line  24)
* lambda/checked:                        syntaxes variables.  (line 193)
* lambda/std:                            syntaxes variables.  (line  96)
* lambda/typed:                          syntaxes variables.  (line 313)
* last-pair on <nelist>:                 built-in lists non-empty.
                                                              (line  29)
* latin1 on <string>:                    built-in strings base.
                                                              (line 166)
* latin1-encoded? on <string>:           built-in strings base.
                                                              (line  65)
* lcm on <integer>:                      built-in numerics integer.
                                                              (line  23)
* length on <bytevector>:                built-in bytevectors base.
                                                              (line  30)
* length on <string>:                    built-in strings base.
                                                              (line  35)
* length on <struct>:                    built-in structs base.
                                                              (line  34)
* length on <vector>:                    built-in vectors base.
                                                              (line  28)
* let*/checked:                          syntaxes variables.  (line 248)
* let*/std:                              syntaxes variables.  (line 120)
* let/checked:                           syntaxes variables.  (line 246)
* let/checked <1>:                       syntaxes variables.  (line 247)
* let/std:                               syntaxes variables.  (line 119)
* letrec*/checked:                       syntaxes variables.  (line 250)
* letrec*/std:                           syntaxes variables.  (line 122)
* letrec/checked:                        syntaxes variables.  (line 249)
* letrec/std:                            syntaxes variables.  (line 121)
* list on <enum-set>:                    built-in enum-set.   (line  53)
* list on <string>:                      built-in strings base.
                                                              (line 190)
* list on <vector>:                      built-in vectors base.
                                                              (line  85)
* list-of-type-descr.item-des:           descriptors compound list-of.
                                                              (line  23)
* list-of-type-descr?:                   descriptors compound list-of.
                                                              (line  19)
* list-tail on <list>:                   built-in lists non-empty.
                                                              (line  32)
* list-type-descr.item-des*:             descriptors compound list.
                                                              (line  23)
* list-type-descr.length:                descriptors compound list.
                                                              (line  26)
* list-type-descr?:                      descriptors compound list.
                                                              (line  19)
* log on <number>:                       built-in numerics number.
                                                              (line 108)
* log on <number> <1>:                   built-in numerics number.
                                                              (line 109)
* lower-case? on <char>:                 built-in chars.      (line 108)
* machine on <utsname>:                  built-in utsname.    (line  44)
* magnitude on <number>:                 built-in numerics number.
                                                              (line  56)
* make-alist-type-descr:                 descriptors compound alist.
                                                              (line  19)
* make-ancestor-of-type-descr:           descriptors compound ancestor.
                                                              (line  20)
* make-case-lambda-descriptors:          descriptors signatures case-lambda.
                                                              (line  17)
* make-closure-type-descr:               descriptors compound closure.
                                                              (line  17)
* make-complement-type-descr:            descriptors compound complem.
                                                              (line  16)
* make-compound-condition-type-descr:    descriptors compound condobj.
                                                              (line  17)
* make-descriptors-signature:            descriptors signatures descriptors.
                                                              (line  17)
* make-enumeration-type-descr:           descriptors compound enum.
                                                              (line  16)
* make-hashtable-type-descr:             descriptors compound hashtable.
                                                              (line  19)
* make-interface-type-descr:             descriptors other interface.
                                                              (line  38)
* make-intersection-type-descr:          descriptors compound intersect.
                                                              (line  17)
* make-lambda-descriptors:               descriptors signatures lambda.
                                                              (line  21)
* make-list-of-type-descr:               descriptors compound list-of.
                                                              (line  16)
* make-list-type-descr:                  descriptors compound list.
                                                              (line  16)
* make-pair-of-type-descr:               descriptors compound pair-of.
                                                              (line  16)
* make-pair-type-descr:                  descriptors compound pair.
                                                              (line  19)
* make-union-type-descr:                 descriptors compound union.
                                                              (line  17)
* make-vector-of-type-descr:             descriptors compound vector-of.
                                                              (line  16)
* make-vector-type-descr:                descriptors compound vector.
                                                              (line  16)
* map on <vector>:                       built-in vectors base.
                                                              (line  53)
* max on <char>:                         built-in chars.      (line  85)
* max on <symbol>:                       built-in symbols symbols.
                                                              (line  70)
* max on <time>:                         built-in time time.  (line  97)
* member? on <symbol>:                   built-in symbols symbols.
                                                              (line  36)
* method:                                interfaces defs.     (line  14)
* method <1>:                            labels.              (line  32)
* method-call:                           methods calling.     (line  55)
* method-call-late-binding:              methods calling.     (line  89)
* method-prototype:                      interfaces defs.     (line  13)
* min on <char>:                         built-in chars.      (line  82)
* min on <symbol>:                       built-in symbols symbols.
                                                              (line  67)
* min on <time>:                         built-in time time.  (line  98)
* mixins:                                mixins.              (line  68)
* mixins <1>:                            labels.              (line  33)
* mod on <exact-integer>:                built-in numerics exact-integer base.
                                                              (line  30)
* mod0 on <exact-integer>:               built-in numerics exact-integer base.
                                                              (line  42)
* mode on <textual-input-only-port>:     built-in ports texin.
                                                              (line  22)
* mode on <textual-input-only-port> <1>: built-in ports texin.
                                                              (line  24)
* mode on <textual-input/output-port>:   built-in ports texio.
                                                              (line  22)
* mode on <textual-input/output-port> <1>: built-in ports texio.
                                                              (line  24)
* modulo on <integer>:                   built-in numerics integer.
                                                              (line  37)
* name on <record-type-descriptor>:      built-in records rtd.
                                                              (line  21)
* name on <struct-type-descriptor>:      built-in structs std.
                                                              (line  23)
* name on <struct>:                      built-in structs base.
                                                              (line  31)
* named-case-lambda/checked:             syntaxes variables.  (line 239)
* named-case-lambda/std:                 syntaxes variables.  (line 112)
* named-case-lambda/typed:               syntaxes variables.  (line 333)
* named-lambda/checked:                  syntaxes variables.  (line 214)
* named-lambda/std:                      syntaxes variables.  (line 101)
* named-lambda/typed:                    syntaxes variables.  (line 323)
* nan? on <number>:                      built-in numerics number.
                                                              (line  32)
* nanoseconds on <time>:                 built-in time time.  (line  49)
* negative? on <real>:                   built-in numerics real base.
                                                              (line  26)
* new:                                   syntaxes new-delete. (line  26)
* nodename on <utsname>:                 built-in utsname.    (line  32)
* non-blocking-mode? on <binary-input-port>: built-in ports labels binin.
                                                              (line  46)
* non-blocking-mode? on <binary-output-port>: built-in ports labels binou.
                                                              (line  46)
* non-blocking-mode? on <binary-port>:   built-in ports labels binary.
                                                              (line  45)
* non-blocking-mode? on <input-port>:    built-in ports labels input.
                                                              (line  45)
* non-blocking-mode? on <input/output-port>: built-in ports labels input/output.
                                                              (line  46)
* non-blocking-mode? on <output-port>:   built-in ports labels output.
                                                              (line  45)
* non-blocking-mode? on <port>:          built-in ports base. (line  40)
* non-blocking-mode? on <textual-input-port>: built-in ports labels texin.
                                                              (line  46)
* non-blocking-mode? on <textual-output-port>: built-in ports labels texou.
                                                              (line  46)
* non-blocking-mode? on <textual-port>:  built-in ports labels textual.
                                                              (line  46)
* non-negative? on <real>:               built-in numerics real base.
                                                              (line  31)
* non-positive? on <real>:               built-in numerics real base.
                                                              (line  30)
* nongenerative:                         interfaces defs.     (line  10)
* nongenerative <1>:                     labels.              (line  24)
* normalize-nfc on <string>:             built-in strings base.
                                                              (line 117)
* normalize-nfd on <string>:             built-in strings base.
                                                              (line 120)
* normalize-nfkc on <string>:            built-in strings base.
                                                              (line 123)
* normalize-nfkd on <string>:            built-in strings base.
                                                              (line 126)
* null? on <pointer>:                    built-in pointers.   (line  29)
* number on <string>:                    built-in strings base.
                                                              (line 135)
* number on <string> <1>:                built-in strings base.
                                                              (line 136)
* numerator on <real>:                   built-in numerics real base.
                                                              (line  56)
* numeric? on <char>:                    built-in chars.      (line 112)
* object-type-implements-interface?:     descriptors other interface.
                                                              (line  55)
* octets on <string>:                    built-in strings base.
                                                              (line 169)
* octets-encoded? on <string>:           built-in strings base.
                                                              (line  68)
* odd? on <bignum>:                      built-in numerics bignums base.
                                                              (line  29)
* odd? on <number>:                      built-in numerics number.
                                                              (line  40)
* opaque? on <record-type-descriptor>:   built-in records rtd.
                                                              (line  42)
* open? on <binary-input-port>:          built-in ports labels binin.
                                                              (line  32)
* open? on <binary-output-port>:         built-in ports labels binou.
                                                              (line  32)
* open? on <binary-port>:                built-in ports labels binary.
                                                              (line  31)
* open? on <input-port>:                 built-in ports labels input.
                                                              (line  31)
* open? on <input/output-port>:          built-in ports labels input/output.
                                                              (line  32)
* open? on <output-port>:                built-in ports labels output.
                                                              (line  31)
* open? on <port>:                       built-in ports base. (line  26)
* open? on <textual-input-port>:         built-in ports labels texin.
                                                              (line  32)
* open? on <textual-output-port>:        built-in ports labels texou.
                                                              (line  32)
* open? on <textual-port>:               built-in ports labels textual.
                                                              (line  32)
* pair-of-type-descr.item-des:           descriptors compound pair-of.
                                                              (line  23)
* pair-of-type-descr?:                   descriptors compound pair-of.
                                                              (line  19)
* pair-type-descr.car-des:               descriptors compound pair.
                                                              (line  26)
* pair-type-descr.cdr-des:               descriptors compound pair.
                                                              (line  27)
* pair-type-descr?:                      descriptors compound pair.
                                                              (line  22)
* parent:                                interfaces defs.     (line  11)
* parent <1>:                            labels.              (line  25)
* parent on <record-constructor-descriptor>: built-in records rcd.
                                                              (line  30)
* parent on <record-type-descriptor>:    built-in records rtd.
                                                              (line  25)
* pencent-encoded? on <string>:          built-in strings base.
                                                              (line  74)
* percent-encoding on <string>:          built-in strings base.
                                                              (line 172)
* pointer on <memory-block>:             built-in memory-block.
                                                              (line  28)
* position on <binary-input-port>:       built-in ports labels binin.
                                                              (line  61)
* position on <binary-input-port> <1>:   built-in ports labels binin.
                                                              (line  63)
* position on <binary-output-port>:      built-in ports labels binou.
                                                              (line  61)
* position on <binary-output-port> <1>:  built-in ports labels binou.
                                                              (line  63)
* position on <binary-port>:             built-in ports labels binary.
                                                              (line  60)
* position on <binary-port> <1>:         built-in ports labels binary.
                                                              (line  62)
* position on <input-port>:              built-in ports labels input.
                                                              (line  60)
* position on <input-port> <1>:          built-in ports labels input.
                                                              (line  61)
* position on <input/output-port>:       built-in ports labels input/output.
                                                              (line  61)
* position on <input/output-port> <1>:   built-in ports labels input/output.
                                                              (line  63)
* position on <output-port>:             built-in ports labels output.
                                                              (line  60)
* position on <output-port> <1>:         built-in ports labels output.
                                                              (line  62)
* position on <port>:                    built-in ports base. (line  55)
* position on <port> <1>:                built-in ports base. (line  56)
* position on <textual-input-port>:      built-in ports labels texin.
                                                              (line  61)
* position on <textual-input-port> <1>:  built-in ports labels texin.
                                                              (line  63)
* position on <textual-output-port>:     built-in ports labels texou.
                                                              (line  61)
* position on <textual-output-port> <1>: built-in ports labels texou.
                                                              (line  63)
* position on <textual-port>:            built-in ports labels textual.
                                                              (line  61)
* position on <textual-port> <1>:        built-in ports labels textual.
                                                              (line  63)
* positive? on <real>:                   built-in numerics real base.
                                                              (line  25)
* predicate on <struct-type-descriptor>: built-in structs std.
                                                              (line  40)
* print on <condition>:                  built-in conditions base.
                                                              (line  21)
* print on <condition> <1>:              built-in conditions base.
                                                              (line  22)
* printer on <struct-type-descriptor>:   built-in structs std.
                                                              (line  45)
* printer on <struct>:                   built-in structs base.
                                                              (line  41)
* private:                               protlev.             (line  33)
* projection on <enum-set>:              built-in enum-set.   (line  89)
* property-list on <binary-input-port>:  built-in ports labels binin.
                                                              (line 103)
* property-list on <binary-output-port>: built-in ports labels binou.
                                                              (line 103)
* property-list on <binary-port>:        built-in ports labels binary.
                                                              (line  99)
* property-list on <input-port>:         built-in ports labels input.
                                                              (line  98)
* property-list on <input/output-port>:  built-in ports labels input/output.
                                                              (line 103)
* property-list on <output-port>:        built-in ports labels output.
                                                              (line  99)
* property-list on <port>:               built-in ports base. (line  93)
* property-list on <symbol>:             built-in symbols symbols.
                                                              (line  85)
* property-list on <textual-input-port>: built-in ports labels texin.
                                                              (line 103)
* property-list on <textual-output-port>: built-in ports labels texou.
                                                              (line 103)
* property-list on <textual-port>:       built-in ports labels textual.
                                                              (line 101)
* protected:                             protlev.             (line  27)
* public:                                protlev.             (line  18)
* putprop on <binary-input-port>:        built-in ports labels binin.
                                                              (line  93)
* putprop on <binary-output-port>:       built-in ports labels binou.
                                                              (line  93)
* putprop on <binary-port>:              built-in ports labels binary.
                                                              (line  90)
* putprop on <input-port>:               built-in ports labels input.
                                                              (line  89)
* putprop on <input/output-port>:        built-in ports labels input/output.
                                                              (line  93)
* putprop on <output-port>:              built-in ports labels output.
                                                              (line  90)
* putprop on <port>:                     built-in ports base. (line  84)
* putprop on <symbol>:                   built-in symbols symbols.
                                                              (line  76)
* putprop on <textual-input-port>:       built-in ports labels texin.
                                                              (line  93)
* putprop on <textual-output-port>:      built-in ports labels texou.
                                                              (line  93)
* putprop on <textual-port>:             built-in ports labels textual.
                                                              (line  92)
* quotient on <integer>:                 built-in numerics integer.
                                                              (line  26)
* quotient+remainder on <integer>:       built-in numerics integer.
                                                              (line  32)
* rationalize on <real>:                 built-in numerics real base.
                                                              (line  80)
* ratnum on <time>:                      built-in time time.  (line  52)
* real-part on <number>:                 built-in numerics number.
                                                              (line  62)
* real-secs on <stats>:                  built-in stats.      (line  41)
* real-usecs on <stats>:                 built-in stats.      (line  45)
* receive-and-return/checked:            syntaxes variables.  (line 280)
* receive-and-return/std:                syntaxes variables.  (line 129)
* receive/checked:                       syntaxes variables.  (line 279)
* receive/std:                           syntaxes variables.  (line 128)
* ref on <list>:                         built-in lists non-empty.
                                                              (line  36)
* ref on <nestring>:                     built-in strings non-empty.
                                                              (line  21)
* ref on <nevector>:                     built-in vectors non-empty.
                                                              (line  21)
* ref on <record>:                       built-in records base.
                                                              (line  36)
* ref on <struct>:                       built-in structs base.
                                                              (line  60)
* release on <utsname>:                  built-in utsname.    (line  36)
* remainder on <integer>:                built-in numerics integer.
                                                              (line  29)
* remprop on <binary-input-port>:        built-in ports labels binin.
                                                              (line 100)
* remprop on <binary-output-port>:       built-in ports labels binou.
                                                              (line 100)
* remprop on <binary-port>:              built-in ports labels binary.
                                                              (line  96)
* remprop on <input-port>:               built-in ports labels input.
                                                              (line  95)
* remprop on <input/output-port>:        built-in ports labels input/output.
                                                              (line 100)
* remprop on <output-port>:              built-in ports labels output.
                                                              (line  96)
* remprop on <port>:                     built-in ports base. (line  90)
* remprop on <symbol>:                   built-in symbols symbols.
                                                              (line  82)
* remprop on <textual-input-port>:       built-in ports labels texin.
                                                              (line 100)
* remprop on <textual-output-port>:      built-in ports labels texou.
                                                              (line 100)
* remprop on <textual-port>:             built-in ports labels textual.
                                                              (line  98)
* reset on <binary-input-port>:          built-in ports labels binin.
                                                              (line 114)
* reset on <binary-output-port>:         built-in ports labels binou.
                                                              (line 114)
* reset on <binary-port>:                built-in ports labels binary.
                                                              (line 109)
* reset on <input-port>:                 built-in ports labels input.
                                                              (line 108)
* reset on <input/output-port>:          built-in ports labels input/output.
                                                              (line 114)
* reset on <memory-block>:               built-in memory-block.
                                                              (line  36)
* reset on <output-port>:                built-in ports labels output.
                                                              (line 109)
* reset on <port>:                       built-in ports base. (line 103)
* reset on <record>:                     built-in records base.
                                                              (line  39)
* reset on <struct>:                     built-in structs base.
                                                              (line  66)
* reset on <textual-input-port>:         built-in ports labels texin.
                                                              (line 114)
* reset on <textual-output-port>:        built-in ports labels texou.
                                                              (line 114)
* reset on <textual-port>:               built-in ports labels textual.
                                                              (line 112)
* resize on <vector>:                    built-in vectors base.
                                                              (line  46)
* resize on <vector> <1>:                built-in vectors base.
                                                              (line  47)
* reverse on <list>:                     built-in lists base. (line  42)
* round on <real>:                       built-in numerics real base.
                                                              (line  77)
* rtd on <record-constructor-descriptor>: built-in records rcd.
                                                              (line  25)
* sealed? on <record-type-descriptor>:   built-in records rtd.
                                                              (line  38)
* seconds on <time>:                     built-in time time.  (line  46)
* set! on <nestring>:                    built-in strings non-empty.
                                                              (line  24)
* set! on <nevector>:                    built-in vectors non-empty.
                                                              (line  24)
* set! on <struct>:                      built-in structs base.
                                                              (line  63)
* set-non-blocking-mode on <binary-input-port>: built-in ports labels binin.
                                                              (line  40)
* set-non-blocking-mode on <binary-output-port>: built-in ports labels binou.
                                                              (line  40)
* set-non-blocking-mode on <binary-port>: built-in ports labels binary.
                                                              (line  39)
* set-non-blocking-mode on <input-port>: built-in ports labels input.
                                                              (line  39)
* set-non-blocking-mode on <input/output-port>: built-in ports labels input/output.
                                                              (line  40)
* set-non-blocking-mode on <output-port>: built-in ports labels output.
                                                              (line  39)
* set-non-blocking-mode on <port>:       built-in ports base. (line  34)
* set-non-blocking-mode on <textual-input-port>: built-in ports labels texin.
                                                              (line  40)
* set-non-blocking-mode on <textual-output-port>: built-in ports labels texou.
                                                              (line  40)
* set-non-blocking-mode on <textual-port>: built-in ports labels textual.
                                                              (line  40)
* set-null! on <pointer>:                built-in pointers.   (line  74)
* sign on <real>:                        built-in numerics real base.
                                                              (line  62)
* sin on <number>:                       built-in numerics number.
                                                              (line 130)
* single-item? on <list>:                built-in lists base. (line  32)
* sinh on <number>:                      built-in numerics number.
                                                              (line 146)
* size on <memory-block>:                built-in memory-block.
                                                              (line  32)
* sort on <vector>:                      built-in vectors base.
                                                              (line  77)
* sort! on <vector>:                     built-in vectors base.
                                                              (line  78)
* source on <reader-annotation>:         built-in reader-annotation.
                                                              (line  43)
* sqrt on <number>:                      built-in numerics number.
                                                              (line 121)
* square on <number>:                    built-in numerics number.
                                                              (line 115)
* std on <struct>:                       built-in structs base.
                                                              (line  28)
* string on <char>:                      built-in chars.      (line  31)
* string on <keyword>:                   built-in keywords.   (line  31)
* string on <symbol>:                    built-in symbols symbols.
                                                              (line  23)
* stripped on <reader-annotation>:       built-in reader-annotation.
                                                              (line  34)
* sub1 on <number>:                      built-in numerics number.
                                                              (line  99)
* subset? on <enum-set>:                 built-in enum-set.   (line  63)
* subvector on <vector>:                 built-in vectors base.
                                                              (line  40)
* symbol on <keyword>:                   built-in keywords.   (line  28)
* symbol on <string>:                    built-in strings base.
                                                              (line 184)
* sys-secs on <stats>:                   built-in stats.      (line  34)
* sys-usecs on <stats>:                  built-in stats.      (line  37)
* sysname on <utsname>:                  built-in utsname.    (line  28)
* tan on <number>:                       built-in numerics number.
                                                              (line 132)
* tanh on <number>:                      built-in numerics number.
                                                              (line 148)
* textual-position on <reader-annotation>: built-in reader-annotation.
                                                              (line  38)
* textual-position on <textual-input-only-port>: built-in ports texin.
                                                              (line  30)
* textual-position on <textual-input/output-port>: built-in ports texio.
                                                              (line  30)
* textual-position on <textual-input/output-port> <1>: built-in ports texio.
                                                              (line  52)
* textual-position on <textual-output-only-port>: built-in ports texou.
                                                              (line  33)
* THIS on <bytevector>:                  built-in bytevectors base.
                                                              (line  34)
* THIS on <bytevector> <1>:              built-in bytevectors base.
                                                              (line  35)
* title-case? on <char>:                 built-in chars.      (line 115)
* titlecase on <char>:                   built-in chars.      (line  94)
* titlecase on <string>:                 built-in strings base.
                                                              (line 102)
* transcoder on <binary-input-port>:     built-in ports labels binin.
                                                              (line  85)
* transcoder on <binary-output-port>:    built-in ports labels binou.
                                                              (line  85)
* transcoder on <binary-port>:           built-in ports labels binary.
                                                              (line  83)
* transcoder on <input-port>:            built-in ports labels input.
                                                              (line  82)
* transcoder on <input/output-port>:     built-in ports labels input/output.
                                                              (line  85)
* transcoder on <output-port>:           built-in ports labels output.
                                                              (line  83)
* transcoder on <port>:                  built-in ports base. (line  77)
* transcoder on <textual-input-port>:    built-in ports labels texin.
                                                              (line  85)
* transcoder on <textual-output-port>:   built-in ports labels texou.
                                                              (line  85)
* transcoder on <textual-port>:          built-in ports labels textual.
                                                              (line  84)
* truncate on <real>:                    built-in numerics real base.
                                                              (line  74)
* type-annotation-ancestors:             annotations relations.
                                                              (line 113)
* type-annotation-common-ancestor:       annotations relations.
                                                              (line  97)
* type-annotation-matching:              annotations relations.
                                                              (line  77)
* type-annotation-super-and-sub?:        annotations relations.
                                                              (line  39)
* type-annotation-syntax:                annotations relations.
                                                              (line   9)
* type-annotation=?:                     annotations relations.
                                                              (line  23)
* type-constructor on <bignum>:          built-in numerics bignums base.
                                                              (line  11)
* type-constructor on <binary-input-only-port>: built-in ports binin.
                                                              (line  10)
* type-constructor on <binary-input-port>: built-in ports labels binin.
                                                              (line  12)
* type-constructor on <binary-input-port> <1>: built-in ports labels binou.
                                                              (line  12)
* type-constructor on <binary-input/output-port>: built-in ports binio.
                                                              (line  10)
* type-constructor on <binary-output-only-port>: built-in ports binou.
                                                              (line  10)
* type-constructor on <binary-port>:     built-in ports labels binary.
                                                              (line  13)
* type-constructor on <boolean>:         built-in booleans boolean.
                                                              (line  10)
* type-constructor on <byte>:            built-in numerics bytes base.
                                                              (line  11)
* type-constructor on <bytevector>:      built-in bytevectors base.
                                                              (line  10)
* type-constructor on <bytevector> <1>:  built-in bytevectors base.
                                                              (line  12)
* type-constructor on <cflonum>:         built-in numerics cflonums base.
                                                              (line  10)
* type-constructor on <char>:            built-in chars.      (line  10)
* type-constructor on <complex>:         built-in numerics complex.
                                                              (line  10)
* type-constructor on <compnum>:         built-in numerics compnums base.
                                                              (line  10)
* type-constructor on <compound-condition>: built-in conditions compound.
                                                              (line  10)
* type-constructor on <condition>:       built-in conditions base.
                                                              (line  12)
* type-constructor on <empty-bytevector>: built-in bytevectors empty.
                                                              (line  10)
* type-constructor on <empty-string>:    built-in strings empty.
                                                              (line  10)
* type-constructor on <empty-vector>:    built-in vectors empty.
                                                              (line  10)
* type-constructor on <enum-set>:        built-in enum-set.   (line  10)
* type-constructor on <eof>:             built-in unique eof. (line  11)
* type-constructor on <exact-compnum>:   built-in numerics compnums exact.
                                                              (line  21)
* type-constructor on <exact-integer>:   built-in numerics exact-integer base.
                                                              (line  11)
* type-constructor on <false>:           built-in booleans false.
                                                              (line  10)
* type-constructor on <fixnum>:          built-in numerics fixnums base.
                                                              (line  10)
* type-constructor on <flonum>:          built-in numerics flonums base.
                                                              (line  10)
* type-constructor on <gensym>:          built-in symbols gensyms.
                                                              (line  10)
* type-constructor on <gensym> <1>:      built-in symbols gensyms.
                                                              (line  11)
* type-constructor on <gensym> <2>:      built-in symbols gensyms.
                                                              (line  12)
* type-constructor on <hashtable-eq>:    built-in hashtables eq.
                                                              (line  10)
* type-constructor on <hashtable-eq> <1>: built-in hashtables eq.
                                                              (line  11)
* type-constructor on <hashtable-equiv>: built-in hashtables equiv.
                                                              (line  10)
* type-constructor on <hashtable-equiv> <1>: built-in hashtables equiv.
                                                              (line  12)
* type-constructor on <hashtable-eqv>:   built-in hashtables eqv.
                                                              (line  10)
* type-constructor on <hashtable-eqv> <1>: built-in hashtables eqv.
                                                              (line  11)
* type-constructor on <hashtable>:       built-in hashtables base.
                                                              (line  10)
* type-constructor on <inexact-compnum>: built-in numerics compnums inexact.
                                                              (line  14)
* type-constructor on <input-port>:      built-in ports labels input.
                                                              (line  13)
* type-constructor on <input/output-port>: built-in ports labels input/output.
                                                              (line  12)
* type-constructor on <integer-valued>:  built-in numerics integer-valued.
                                                              (line  10)
* type-constructor on <integer>:         built-in numerics integer.
                                                              (line  10)
* type-constructor on <ipair>:           built-in pairs immutable.
                                                              (line  10)
* type-constructor on <keyword>:         built-in keywords.   (line  10)
* type-constructor on <list>:            built-in lists base. (line  12)
* type-constructor on <memory-block>:    built-in memory-block.
                                                              (line  10)
* type-constructor on <nebytevector>:    built-in bytevectors non-empty.
                                                              (line  10)
* type-constructor on <nebytevector> <1>: built-in bytevectors non-empty.
                                                              (line  12)
* type-constructor on <negative-bignum>: built-in numerics bignums negative.
                                                              (line  10)
* type-constructor on <negative-byte>:   built-in numerics bytes negative.
                                                              (line  10)
* type-constructor on <negative-fixnum>: built-in numerics fixnums negative.
                                                              (line  10)
* type-constructor on <negative-flonum>: built-in numerics flonums negative.
                                                              (line  11)
* type-constructor on <negative-ratnum>: built-in numerics ratnums negative.
                                                              (line  10)
* type-constructor on <negative-zero-flonum>: built-in numerics flonums negative-zero.
                                                              (line  10)
* type-constructor on <nelist>:          built-in lists non-empty.
                                                              (line  12)
* type-constructor on <nestring>:        built-in strings non-empty.
                                                              (line  10)
* type-constructor on <nevector>:        built-in vectors non-empty.
                                                              (line  10)
* type-constructor on <non-zero-cflonum>: built-in numerics cflonums non-zero.
                                                              (line  11)
* type-constructor on <non-zero-inexact-compnum>: built-in numerics compnums non-zero-inexact.
                                                              (line  11)
* type-constructor on <null>:            built-in lists null. (line  16)
* type-constructor on <number>:          built-in numerics number.
                                                              (line  10)
* type-constructor on <octet>:           built-in numerics octets base.
                                                              (line  11)
* type-constructor on <output-port>:     built-in ports labels output.
                                                              (line  13)
* type-constructor on <pair>:            built-in pairs base. (line  10)
* type-constructor on <pointer>:         built-in pointers.   (line  10)
* type-constructor on <port>:            built-in ports base. (line  10)
* type-constructor on <positive-bignum>: built-in numerics bignums positive.
                                                              (line  10)
* type-constructor on <positive-byte>:   built-in numerics bytes positive.
                                                              (line  10)
* type-constructor on <positive-fixnum>: built-in numerics fixnums positive.
                                                              (line  10)
* type-constructor on <positive-flonum>: built-in numerics flonums positive.
                                                              (line  11)
* type-constructor on <positive-octet>:  built-in numerics octets positive.
                                                              (line  10)
* type-constructor on <positive-ratnum>: built-in numerics ratnums positive.
                                                              (line  10)
* type-constructor on <positive-zero-flonum>: built-in numerics flonums positive-zero.
                                                              (line  10)
* type-constructor on <promise>:         built-in promises.   (line  10)
* type-constructor on <rational-valued>: built-in numerics rational-valued.
                                                              (line  10)
* type-constructor on <rational>:        built-in numerics rational base.
                                                              (line  10)
* type-constructor on <ratnum>:          built-in numerics ratnums base.
                                                              (line  10)
* type-constructor on <reader-annotation>: built-in reader-annotation.
                                                              (line  11)
* type-constructor on <real-valued>:     built-in numerics real-valued.
                                                              (line  10)
* type-constructor on <real>:            built-in numerics real base.
                                                              (line  11)
* type-constructor on <record-constructor-descriptor>: built-in records rcd.
                                                              (line  10)
* type-constructor on <record-type-descriptor>: built-in records rtd.
                                                              (line  10)
* type-constructor on <record>:          built-in records base.
                                                              (line  10)
* type-constructor on <sentinel>:        built-in unique sentinel.
                                                              (line  11)
* type-constructor on <stats>:           built-in stats.      (line  10)
* type-constructor on <string>:          built-in strings base.
                                                              (line  10)
* type-constructor on <struct-type-descriptor>: built-in structs std.
                                                              (line  10)
* type-constructor on <struct-type-descriptor> <1>: built-in structs std.
                                                              (line  12)
* type-constructor on <struct>:          built-in structs base.
                                                              (line  11)
* type-constructor on <symbol>:          built-in symbols symbols.
                                                              (line  10)
* type-constructor on <textual-input-only-port>: built-in ports texin.
                                                              (line  10)
* type-constructor on <textual-input-port>: built-in ports labels texin.
                                                              (line  12)
* type-constructor on <textual-input-port> <1>: built-in ports labels texou.
                                                              (line  12)
* type-constructor on <textual-input/output-port>: built-in ports texio.
                                                              (line  10)
* type-constructor on <textual-output-only-port>: built-in ports texou.
                                                              (line  10)
* type-constructor on <textual-port>:    built-in ports labels textual.
                                                              (line  13)
* type-constructor on <top>:             built-in top.        (line  10)
* type-constructor on <transcoder>:      built-in transcoders.
                                                              (line  10)
* type-constructor on <transcoder> <1>:  built-in transcoders.
                                                              (line  11)
* type-constructor on <transcoder> <2>:  built-in transcoders.
                                                              (line  13)
* type-constructor on <true>:            built-in booleans true.
                                                              (line  10)
* type-constructor on <utsname>:         built-in utsname.    (line  11)
* type-constructor on <vector>:          built-in vectors base.
                                                              (line  10)
* type-constructor on <void>:            built-in void.       (line  58)
* type-constructor on <weak-pair>:       built-in pairs weak. (line  10)
* type-constructor on <would-block>:     built-in unique would-block.
                                                              (line  11)
* type-constructor on <zero-byte>:       built-in numerics bytes zero.
                                                              (line  10)
* type-constructor on <zero-cflonum>:    built-in numerics cflonums zero.
                                                              (line  14)
* type-constructor on <zero-compnum>:    built-in numerics compnums zero.
                                                              (line  27)
* type-constructor on <zero-fixnum>:     built-in numerics fixnums zero.
                                                              (line  10)
* type-constructor on <zero-flonum>:     built-in numerics flonums zero.
                                                              (line  10)
* type-constructor on <zero-octet>:      built-in numerics octets zero.
                                                              (line  10)
* type-descriptor:                       descriptors retrieving.
                                                              (line   8)
* type-descriptor-ancestors:             descriptors relations.
                                                              (line  29)
* type-descriptor-matching:              descriptors relations.
                                                              (line  85)
* type-descriptor-of:                    descriptors retrieving.
                                                              (line  21)
* type-descriptor-parent:                descriptors relations.
                                                              (line   9)
* type-descriptor-super-and-sub?:        descriptors relations.
                                                              (line  62)
* type-descriptor=?:                     descriptors relations.
                                                              (line  47)
* type-of:                               syntaxes type-of.    (line   8)
* type-predicate:                        labels.              (line  28)
* type-predicate on <bignum>:            built-in numerics bignums base.
                                                              (line  14)
* type-predicate on <binary-input-only-port>: built-in ports binin.
                                                              (line  15)
* type-predicate on <binary-input-port>: built-in ports labels binin.
                                                              (line  16)
* type-predicate on <binary-input-port> <1>: built-in ports labels binou.
                                                              (line  16)
* type-predicate on <binary-input/output-port>: built-in ports binio.
                                                              (line  15)
* type-predicate on <binary-output-only-port>: built-in ports binou.
                                                              (line  15)
* type-predicate on <binary-port>:       built-in ports labels binary.
                                                              (line  16)
* type-predicate on <boolean>:           built-in booleans boolean.
                                                              (line  17)
* type-predicate on <byte>:              built-in numerics bytes base.
                                                              (line  14)
* type-predicate on <bytevector>:        built-in bytevectors base.
                                                              (line  16)
* type-predicate on <cflonum>:           built-in numerics cflonums base.
                                                              (line  13)
* type-predicate on <char>:              built-in chars.      (line  16)
* type-predicate on <complex>:           built-in numerics complex.
                                                              (line  14)
* type-predicate on <compnum>:           built-in numerics compnums base.
                                                              (line  13)
* type-predicate on <compound-condition>: built-in conditions compound.
                                                              (line  14)
* type-predicate on <condition>:         built-in conditions base.
                                                              (line  15)
* type-predicate on <empty-bytevector>:  built-in bytevectors empty.
                                                              (line  14)
* type-predicate on <empty-string>:      built-in strings empty.
                                                              (line  13)
* type-predicate on <empty-vector>:      built-in vectors empty.
                                                              (line  13)
* type-predicate on <enum-set>:          built-in enum-set.   (line  14)
* type-predicate on <eof>:               built-in unique eof. (line  14)
* type-predicate on <epoch-time>:        built-in time epoch. (line  22)
* type-predicate on <exact-compnum>:     built-in numerics compnums exact.
                                                              (line  26)
* type-predicate on <exact-integer>:     built-in numerics exact-integer base.
                                                              (line  15)
* type-predicate on <false>:             built-in booleans false.
                                                              (line  16)
* type-predicate on <fixnum>:            built-in numerics fixnums base.
                                                              (line  13)
* type-predicate on <flonum>:            built-in numerics flonums base.
                                                              (line  13)
* type-predicate on <gensym>:            built-in symbols gensyms.
                                                              (line  15)
* type-predicate on <hashtable-eq>:      built-in hashtables eq.
                                                              (line  14)
* type-predicate on <hashtable-equiv>:   built-in hashtables equiv.
                                                              (line  16)
* type-predicate on <hashtable-eqv>:     built-in hashtables eqv.
                                                              (line  14)
* type-predicate on <hashtable>:         built-in hashtables base.
                                                              (line  13)
* type-predicate on <inexact-compnum>:   built-in numerics compnums inexact.
                                                              (line  19)
* type-predicate on <input-port>:        built-in ports labels input.
                                                              (line  16)
* type-predicate on <input/output-port>: built-in ports labels input/output.
                                                              (line  16)
* type-predicate on <integer-valued>:    built-in numerics integer-valued.
                                                              (line  14)
* type-predicate on <integer>:           built-in numerics integer.
                                                              (line  13)
* type-predicate on <ipair>:             built-in pairs immutable.
                                                              (line  14)
* type-predicate on <keyword>:           built-in keywords.   (line  13)
* type-predicate on <list>:              built-in lists base. (line  16)
* type-predicate on <memory-block>:      built-in memory-block.
                                                              (line  14)
* type-predicate on <nebytevector>:      built-in bytevectors non-empty.
                                                              (line  16)
* type-predicate on <negative-bignum>:   built-in numerics bignums negative.
                                                              (line  14)
* type-predicate on <negative-byte>:     built-in numerics bytes negative.
                                                              (line  15)
* type-predicate on <negative-fixnum>:   built-in numerics fixnums negative.
                                                              (line  14)
* type-predicate on <negative-flonum>:   built-in numerics flonums negative.
                                                              (line  16)
* type-predicate on <negative-ratnum>:   built-in numerics ratnums negative.
                                                              (line  15)
* type-predicate on <negative-zero-flonum>: built-in numerics flonums negative-zero.
                                                              (line  15)
* type-predicate on <nelist>:            built-in lists non-empty.
                                                              (line  16)
* type-predicate on <nestring>:          built-in strings non-empty.
                                                              (line  14)
* type-predicate on <nevector>:          built-in vectors non-empty.
                                                              (line  14)
* type-predicate on <non-zero-cflonum>:  built-in numerics cflonums non-zero.
                                                              (line  16)
* type-predicate on <non-zero-inexact-compnum>: built-in numerics compnums non-zero-inexact.
                                                              (line  16)
* type-predicate on <null>:              built-in lists null. (line  19)
* type-predicate on <number>:            built-in numerics number.
                                                              (line  14)
* type-predicate on <octet>:             built-in numerics octets base.
                                                              (line  14)
* type-predicate on <output-port>:       built-in ports labels output.
                                                              (line  16)
* type-predicate on <pair>:              built-in pairs base. (line  14)
* type-predicate on <pointer>:           built-in pointers.   (line  14)
* type-predicate on <port>:              built-in ports base. (line  13)
* type-predicate on <positive-bignum>:   built-in numerics bignums positive.
                                                              (line  14)
* type-predicate on <positive-byte>:     built-in numerics bytes positive.
                                                              (line  15)
* type-predicate on <positive-fixnum>:   built-in numerics fixnums positive.
                                                              (line  14)
* type-predicate on <positive-flonum>:   built-in numerics flonums positive.
                                                              (line  16)
* type-predicate on <positive-octet>:    built-in numerics octets positive.
                                                              (line  15)
* type-predicate on <positive-ratnum>:   built-in numerics ratnums positive.
                                                              (line  15)
* type-predicate on <positive-zero-flonum>: built-in numerics flonums positive-zero.
                                                              (line  15)
* type-predicate on <procedure>:         built-in procedures procedures.
                                                              (line  10)
* type-predicate on <promise>:           built-in promises.   (line  20)
* type-predicate on <rational-valued>:   built-in numerics rational-valued.
                                                              (line  14)
* type-predicate on <rational>:          built-in numerics rational base.
                                                              (line  13)
* type-predicate on <ratnum>:            built-in numerics ratnums base.
                                                              (line  13)
* type-predicate on <reader-annotation>: built-in reader-annotation.
                                                              (line  15)
* type-predicate on <real-valued>:       built-in numerics real-valued.
                                                              (line  13)
* type-predicate on <real>:              built-in numerics real base.
                                                              (line  14)
* type-predicate on <record-constructor-descriptor>: built-in records rcd.
                                                              (line  17)
* type-predicate on <record-type-descriptor>: built-in records rtd.
                                                              (line  14)
* type-predicate on <record>:            built-in records base.
                                                              (line  13)
* type-predicate on <sentinel>:          built-in unique sentinel.
                                                              (line  14)
* type-predicate on <stats>:             built-in stats.      (line  13)
* type-predicate on <string>:            built-in strings base.
                                                              (line  13)
* type-predicate on <struct-type-descriptor>: built-in structs std.
                                                              (line  16)
* type-predicate on <struct>:            built-in structs base.
                                                              (line  14)
* type-predicate on <symbol>:            built-in symbols symbols.
                                                              (line  13)
* type-predicate on <tcbucket>:          built-in hashtables tcbucket.
                                                              (line  11)
* type-predicate on <textual-input-only-port>: built-in ports texin.
                                                              (line  15)
* type-predicate on <textual-input-port>: built-in ports labels texin.
                                                              (line  16)
* type-predicate on <textual-input-port> <1>: built-in ports labels texou.
                                                              (line  16)
* type-predicate on <textual-input/output-port>: built-in ports texio.
                                                              (line  15)
* type-predicate on <textual-output-only-port>: built-in ports texou.
                                                              (line  15)
* type-predicate on <textual-port>:      built-in ports labels textual.
                                                              (line  17)
* type-predicate on <time>:              built-in time time.  (line  26)
* type-predicate on <top>:               built-in top.        (line  13)
* type-predicate on <transcoder>:        built-in transcoders.
                                                              (line  17)
* type-predicate on <true>:              built-in booleans true.
                                                              (line  16)
* type-predicate on <utsname>:           built-in utsname.    (line  14)
* type-predicate on <vector>:            built-in vectors base.
                                                              (line  13)
* type-predicate on <void>:              built-in void.       (line  61)
* type-predicate on <weak-pair>:         built-in pairs weak. (line  14)
* type-predicate on <would-block>:       built-in unique would-block.
                                                              (line  14)
* type-predicate on <zero-byte>:         built-in numerics bytes zero.
                                                              (line  13)
* type-predicate on <zero-cflonum>:      built-in numerics cflonums zero.
                                                              (line  18)
* type-predicate on <zero-compnum>:      built-in numerics compnums zero.
                                                              (line  31)
* type-predicate on <zero-fixnum>:       built-in numerics fixnums zero.
                                                              (line  13)
* type-predicate on <zero-flonum>:       built-in numerics flonums zero.
                                                              (line  13)
* type-predicate on <zero-octet>:        built-in numerics octets zero.
                                                              (line  13)
* type-signature-common-ancestor:        annotations signatures.
                                                              (line  75)
* type-signature-matching:               annotations signatures.
                                                              (line  39)
* type-signature-super-and-sub?:         annotations signatures.
                                                              (line   9)
* type-signature-union:                  annotations signatures.
                                                              (line  91)
* type-unique-identifiers:               syntaxes type-of.    (line  42)
* uid on <binary-input-port>:            built-in ports labels binin.
                                                              (line  78)
* uid on <binary-output-port>:           built-in ports labels binou.
                                                              (line  78)
* uid on <binary-port>:                  built-in ports labels binary.
                                                              (line  76)
* uid on <input-port>:                   built-in ports labels input.
                                                              (line  75)
* uid on <input/output-port>:            built-in ports labels input/output.
                                                              (line  78)
* uid on <output-port>:                  built-in ports labels output.
                                                              (line  76)
* uid on <port>:                         built-in ports base. (line  70)
* uid on <record-type-descriptor>:       built-in records rtd.
                                                              (line  30)
* uid on <struct-type-descriptor>:       built-in structs std.
                                                              (line  27)
* uid on <textual-input-port>:           built-in ports labels texin.
                                                              (line  78)
* uid on <textual-output-port>:          built-in ports labels texou.
                                                              (line  78)
* uid on <textual-port>:                 built-in ports labels textual.
                                                              (line  77)
* uids-list on <record-type-descriptor>: built-in records rtd.
                                                              (line  60)
* union on <enum-set>:                   built-in enum-set.   (line  73)
* union-type-descr.item-des*:            descriptors compound union.
                                                              (line  24)
* union-type-descr?:                     descriptors compound union.
                                                              (line  20)
* universe on <enum-set>:                built-in enum-set.   (line  41)
* unsafe-cast-signature:                 syntaxes unsafe-cast.
                                                              (line  56)
* unset-non-blocking-mode on <binary-input-port>: built-in ports labels binin.
                                                              (line  41)
* unset-non-blocking-mode on <binary-output-port>: built-in ports labels binou.
                                                              (line  41)
* unset-non-blocking-mode on <binary-port>: built-in ports labels binary.
                                                              (line  40)
* unset-non-blocking-mode on <input-port>: built-in ports labels input.
                                                              (line  40)
* unset-non-blocking-mode on <input/output-port>: built-in ports labels input/output.
                                                              (line  41)
* unset-non-blocking-mode on <output-port>: built-in ports labels output.
                                                              (line  40)
* unset-non-blocking-mode on <port>:     built-in ports base. (line  35)
* unset-non-blocking-mode on <textual-input-port>: built-in ports labels texin.
                                                              (line  41)
* unset-non-blocking-mode on <textual-output-port>: built-in ports labels texou.
                                                              (line  41)
* unset-non-blocking-mode on <textual-port>: built-in ports labels textual.
                                                              (line  41)
* upcase on <char>:                      built-in chars.      (line  97)
* upcase on <string>:                    built-in strings base.
                                                              (line 105)
* upper-case? on <char>:                 built-in chars.      (line 119)
* uri-encoded? on <string>:              built-in strings base.
                                                              (line  71)
* uri-encoding on <string>:              built-in strings base.
                                                              (line 175)
* user-secs on <stats>:                  built-in stats.      (line  26)
* user-usecs on <stats>:                 built-in stats.      (line  30)
* utf16 on <string>:                     built-in strings base.
                                                              (line 142)
* utf16 on <string> <1>:                 built-in strings base.
                                                              (line 143)
* utf16be on <string>:                   built-in strings base.
                                                              (line 146)
* utf16le on <string>:                   built-in strings base.
                                                              (line 149)
* utf16n on <string>:                    built-in strings base.
                                                              (line 152)
* utf32 on <string>:                     built-in strings base.
                                                              (line 155)
* utf32 on <string> <1>:                 built-in strings base.
                                                              (line 156)
* utf8 on <string>:                      built-in strings base.
                                                              (line 139)
* value on <symbol>:                     built-in symbols symbols.
                                                              (line  29)
* value on <symbol> <1>:                 built-in symbols symbols.
                                                              (line  30)
* vector-of-type-descr.item-des:         descriptors compound vector-of.
                                                              (line  23)
* vector-of-type-descr?:                 descriptors compound vector-of.
                                                              (line  19)
* vector-type-descr.item-des*:           descriptors compound vector.
                                                              (line  23)
* vector-type-descr.length:              descriptors compound vector.
                                                              (line  26)
* vector-type-descr?:                    descriptors compound vector.
                                                              (line  19)
* version on <utsname>:                  built-in utsname.    (line  40)
* whitespace? on <char>:                 built-in chars.      (line 123)
* zero? on <number>:                     built-in numerics number.
                                                              (line  29)


File: vicare-typed.info,  Node: variable index,  Next: type index,  Prev: function index,  Up: Top

Appendix E An entry for each variable.
**************************************


File: vicare-typed.info,  Node: type index,  Prev: variable index,  Up: Top

Appendix F An entry for each type.
**********************************

 [index ]
* Menu:

* <&who-value>:                          built-in misc.       (line   6)
* <alist-type-descr>:                    descriptors compound alist.
                                                              (line   9)
* <ancestor-of-type-descr>:              descriptors compound ancestor.
                                                              (line   9)
* <bignum>:                              built-in numerics bignums base.
                                                              (line   6)
* <bignum> <1>:                          built-in numerics bignums positive.
                                                              (line   7)
* <bignum> <2>:                          built-in numerics bignums negative.
                                                              (line   7)
* <binary-input-only-port>:              built-in ports binin.
                                                              (line   6)
* <binary-input-port>:                   built-in ports labels binin.
                                                              (line   6)
* <binary-input-port> <1>:               built-in ports labels binou.
                                                              (line   6)
* <binary-input/output-port>:            built-in ports binio.
                                                              (line   6)
* <binary-output-only-port>:             built-in ports binou.
                                                              (line   6)
* <binary-port>:                         built-in ports labels binary.
                                                              (line   6)
* <boolean>:                             built-in booleans boolean.
                                                              (line   6)
* <boolean> <1>:                         built-in booleans true.
                                                              (line   7)
* <boolean> <2>:                         built-in booleans false.
                                                              (line   7)
* <bottom>:                              built-in bottom.     (line   6)
* <byte>:                                built-in numerics bytes base.
                                                              (line   6)
* <byte> <1>:                            built-in numerics bytes zero.
                                                              (line   7)
* <byte> <2>:                            built-in numerics bytes positive.
                                                              (line   7)
* <byte> <3>:                            built-in numerics bytes negative.
                                                              (line   7)
* <bytevector>:                          built-in bytevectors base.
                                                              (line   6)
* <bytevector> <1>:                      built-in bytevectors empty.
                                                              (line   7)
* <bytevector> <2>:                      built-in bytevectors non-empty.
                                                              (line   7)
* <case-lambda-descriptors>:             descriptors signatures case-lambda.
                                                              (line   9)
* <cflonum>:                             built-in numerics cflonums base.
                                                              (line   6)
* <cflonum> <1>:                         built-in numerics cflonums zero.
                                                              (line   7)
* <cflonum> <2>:                         built-in numerics cflonums non-zero.
                                                              (line   7)
* <char>:                                built-in chars.      (line   6)
* <closure-type-descr>:                  descriptors compound closure.
                                                              (line   9)
* <comparison-procedure>:                built-in procedures comparison-procedure.
                                                              (line   6)
* <complement-type-descr>:               descriptors compound complem.
                                                              (line   9)
* <complex>:                             built-in numerics complex.
                                                              (line   6)
* <complex> <1>:                         built-in numerics real-valued.
                                                              (line   7)
* <complex> <2>:                         built-in numerics compnums base.
                                                              (line   7)
* <complex> <3>:                         built-in numerics cflonums base.
                                                              (line   7)
* <compnum>:                             built-in numerics compnums base.
                                                              (line   6)
* <compnum> <1>:                         built-in numerics compnums exact.
                                                              (line   7)
* <compnum> <2>:                         built-in numerics compnums inexact.
                                                              (line   7)
* <compound-condition-type-descr>:       descriptors compound condobj.
                                                              (line   9)
* <compound-condition>:                  annotations syntaxes.
                                                              (line 167)
* <compound-condition> <1>:              built-in conditions compound.
                                                              (line   6)
* <condition>:                           built-in conditions base.
                                                              (line   6)
* <condition> <1>:                       built-in conditions compound.
                                                              (line   7)
* <core-type-descriptor>:                descriptors core.    (line  37)
* <descriptors-signature>:               descriptors signatures descriptors.
                                                              (line   9)
* <empty-bytevector>:                    built-in bytevectors empty.
                                                              (line   6)
* <empty-string>:                        built-in strings empty.
                                                              (line   6)
* <empty-vector>:                        built-in vectors empty.
                                                              (line   6)
* <enum-set-constructor>:                built-in enum-set.   (line  33)
* <enum-set-indexer>:                    built-in enum-set.   (line  28)
* <enum-set>:                            built-in enum-set.   (line   6)
* <enumeration-type-descr>:              descriptors compound enum.
                                                              (line   9)
* <eof>:                                 built-in unique eof. (line   6)
* <epoch-time>:                          built-in time epoch. (line   6)
* <equality-predicate>:                  built-in procedures equality-predicate.
                                                              (line   6)
* <exact-compnum>:                       built-in numerics compnums exact.
                                                              (line   6)
* <exact-integer>:                       built-in numerics exact-integer base.
                                                              (line   6)
* <exact-integer> <1>:                   built-in numerics fixnums base.
                                                              (line   7)
* <exact-integer> <2>:                   built-in numerics bignums base.
                                                              (line   7)
* <exact-rational>:                      built-in numerics rational exact.
                                                              (line   6)
* <exact>:                               built-in numerics exactness.
                                                              (line   6)
* <false>:                               built-in booleans false.
                                                              (line   6)
* <file-descriptor>:                     built-in misc.       (line  13)
* <fixnum>:                              built-in numerics fixnums base.
                                                              (line   6)
* <fixnum> <1>:                          built-in numerics fixnums positive.
                                                              (line   7)
* <fixnum> <2>:                          built-in numerics fixnums negative.
                                                              (line   7)
* <fixnum> <3>:                          built-in numerics fixnums zero.
                                                              (line   7)
* <fixnum> <4>:                          built-in numerics bytes base.
                                                              (line   7)
* <flonum>:                              built-in numerics flonums base.
                                                              (line   6)
* <flonum> <1>:                          built-in numerics flonums zero.
                                                              (line   7)
* <flonum> <2>:                          built-in numerics flonums positive.
                                                              (line   7)
* <flonum> <3>:                          built-in numerics flonums negative.
                                                              (line   7)
* <flonum> <4>:                          built-in numerics flonums non-positive.
                                                              (line   7)
* <flonum> <5>:                          built-in numerics flonums non-negative.
                                                              (line   7)
* <gensym>:                              built-in symbols gensyms.
                                                              (line   6)
* <hash-function>:                       built-in procedures hash-function.
                                                              (line   6)
* <hashtable-eq>:                        built-in hashtables eq.
                                                              (line   6)
* <hashtable-equiv>:                     built-in hashtables equiv.
                                                              (line   6)
* <hashtable-eqv>:                       built-in hashtables eqv.
                                                              (line   6)
* <hashtable-type-descr>:                descriptors compound hashtable.
                                                              (line   9)
* <hashtable>:                           annotations syntaxes.
                                                              (line 121)
* <hashtable> <1>:                       built-in hashtables base.
                                                              (line   6)
* <hashtable> <2>:                       built-in hashtables eq.
                                                              (line   7)
* <hashtable> <3>:                       built-in hashtables eqv.
                                                              (line   7)
* <hashtable> <4>:                       built-in hashtables equiv.
                                                              (line   7)
* <inexact-compnum>:                     built-in numerics compnums inexact.
                                                              (line   6)
* <inexact-compnum> <1>:                 built-in numerics compnums zero.
                                                              (line   7)
* <inexact-compnum> <2>:                 built-in numerics compnums non-zero-inexact.
                                                              (line   7)
* <inexact>:                             built-in numerics exactness.
                                                              (line  12)
* <input-port>:                          built-in ports labels input.
                                                              (line   6)
* <input/output-port>:                   built-in ports labels input/output.
                                                              (line   6)
* <integer-valued>:                      built-in numerics integer-valued.
                                                              (line   6)
* <integer>:                             built-in numerics integer.
                                                              (line   6)
* <integer> <1>:                         built-in numerics exact-integer base.
                                                              (line   7)
* <interface-type-descr>:                descriptors other interface.
                                                              (line   9)
* <intersection-type-descr>:             descriptors compound intersect.
                                                              (line   9)
* <ipair>:                               built-in pairs immutable.
                                                              (line   6)
* <keyword>:                             built-in keywords.   (line   6)
* <lambda-descriptors>:                  descriptors signatures lambda.
                                                              (line   9)
* <list-of-type-descr>:                  descriptors compound list-of.
                                                              (line   9)
* <list-type-descr>:                     descriptors compound list.
                                                              (line   9)
* <list>:                                annotations syntaxes.
                                                              (line  61)
* <list> <1>:                            annotations syntaxes.
                                                              (line  87)
* <list> <2>:                            annotations syntaxes.
                                                              (line 161)
* <list> <3>:                            built-in lists base. (line   6)
* <list> <4>:                            built-in lists null. (line   7)
* <list> <5>:                            built-in lists non-empty.
                                                              (line   7)
* <memory-block>:                        built-in memory-block.
                                                              (line   6)
* <nebytevector>:                        built-in bytevectors non-empty.
                                                              (line   6)
* <negative-bignum>:                     built-in numerics bignums negative.
                                                              (line   6)
* <negative-byte>:                       built-in numerics bytes negative.
                                                              (line   6)
* <negative-exact-integer>:              built-in numerics exact-integer negative.
                                                              (line   6)
* <negative-fixnum>:                     built-in numerics fixnums negative.
                                                              (line   6)
* <negative-flonum>:                     built-in numerics flonums negative.
                                                              (line   6)
* <negative-ratnum>:                     built-in numerics ratnums negative.
                                                              (line   6)
* <negative-real>:                       built-in numerics real negative.
                                                              (line   6)
* <negative-zero-flonum>:                built-in numerics flonums negative-zero.
                                                              (line   6)
* <negative>:                            built-in numerics sign.
                                                              (line  13)
* <nelist>:                              built-in lists non-empty.
                                                              (line   6)
* <nestring>:                            built-in strings non-empty.
                                                              (line   6)
* <nevector>:                            annotations syntaxes.
                                                              (line 113)
* <nevector> <1>:                        built-in vectors non-empty.
                                                              (line   6)
* <non-negative-byte>:                   built-in numerics bytes non-negative.
                                                              (line   6)
* <non-negative-exact-integer>:          built-in numerics exact-integer non-negative.
                                                              (line   6)
* <non-negative-exact-rational>:         built-in numerics rational non-negative.
                                                              (line   6)
* <non-negative-fixnum>:                 built-in numerics fixnums non-positive.
                                                              (line   6)
* <non-negative-fixnum> <1>:             built-in numerics octets base.
                                                              (line   7)
* <non-negative-fixnum> <2>:             built-in numerics octets positive.
                                                              (line   7)
* <non-negative-flonum>:                 built-in numerics flonums non-negative.
                                                              (line   6)
* <non-negative-real>:                   built-in numerics real non-negative.
                                                              (line   6)
* <non-negative>:                        built-in numerics sign.
                                                              (line  20)
* <non-positive-byte>:                   built-in numerics bytes non-positive.
                                                              (line   6)
* <non-positive-exact-integer>:          built-in numerics exact-integer non-positive.
                                                              (line   6)
* <non-positive-fixnum>:                 built-in numerics fixnums non-negative.
                                                              (line   6)
* <non-positive-flonum>:                 built-in numerics flonums non-positive.
                                                              (line   6)
* <non-positive>:                        built-in numerics sign.
                                                              (line  28)
* <non-zero-cflonum>:                    built-in numerics cflonums non-zero.
                                                              (line   6)
* <non-zero-compnum>:                    built-in numerics compnums non-zero.
                                                              (line   6)
* <non-zero-exact-integer>:              built-in numerics exact-integer non-zero.
                                                              (line   6)
* <non-zero-exact-rational>:             built-in numerics rational non-zero.
                                                              (line   6)
* <non-zero-fixnum>:                     built-in numerics fixnums non-zero.
                                                              (line   6)
* <non-zero-flonum>:                     built-in numerics flonums non-zero.
                                                              (line   6)
* <non-zero-inexact-compnum>:            built-in numerics compnums non-zero-inexact.
                                                              (line   6)
* <non-zero-real>:                       built-in numerics real non-zero.
                                                              (line   6)
* <null>:                                built-in lists null. (line   6)
* <number>:                              built-in numerics number.
                                                              (line   6)
* <number> <1>:                          built-in numerics complex.
                                                              (line   7)
* <octet>:                               built-in numerics octets base.
                                                              (line   6)
* <octet> <1>:                           built-in numerics octets zero.
                                                              (line   7)
* <output-port-buffer-mode>:             built-in ports misc. (line  13)
* <output-port>:                         built-in ports labels output.
                                                              (line   6)
* <pair-of-type-descr>:                  descriptors compound pair-of.
                                                              (line   9)
* <pair-type-descr>:                     descriptors compound pair.
                                                              (line   9)
* <pair>:                                annotations syntaxes.
                                                              (line  52)
* <pair> <1>:                            annotations syntaxes.
                                                              (line  79)
* <pair> <2>:                            annotations syntaxes.
                                                              (line  96)
* <pair> <3>:                            built-in pairs base. (line   6)
* <pair> <4>:                            built-in pairs weak. (line   7)
* <parameter-procedure>:                 built-in procedures parameter.
                                                              (line   6)
* <pointer>:                             built-in pointers.   (line   6)
* <port>:                                built-in ports base. (line   6)
* <port> <1>:                            built-in ports texin.
                                                              (line   7)
* <port> <2>:                            built-in ports texou.
                                                              (line   7)
* <port> <3>:                            built-in ports texio.
                                                              (line   7)
* <port> <4>:                            built-in ports binin.
                                                              (line   7)
* <port> <5>:                            built-in ports binou.
                                                              (line   7)
* <port> <6>:                            built-in ports binio.
                                                              (line   7)
* <positive-bignum>:                     built-in numerics bignums positive.
                                                              (line   6)
* <positive-byte>:                       built-in numerics bytes positive.
                                                              (line   6)
* <positive-exact-integer>:              built-in numerics exact-integer positive.
                                                              (line   6)
* <positive-fixnum>:                     built-in numerics fixnums positive.
                                                              (line   6)
* <positive-flonum>:                     built-in numerics flonums positive.
                                                              (line   6)
* <positive-octet>:                      built-in numerics octets positive.
                                                              (line   6)
* <positive-ratnum>:                     built-in numerics ratnums positive.
                                                              (line   6)
* <positive-real>:                       built-in numerics real positive.
                                                              (line   6)
* <positive-zero-flonum>:                built-in numerics flonums positive-zero.
                                                              (line   6)
* <positive>:                            built-in numerics sign.
                                                              (line   6)
* <procedure>:                           annotations syntaxes.
                                                              (line 184)
* <procedure> <1>:                       annotations syntaxes.
                                                              (line 195)
* <procedure> <2>:                       built-in procedures procedures.
                                                              (line   6)
* <promise>:                             built-in promises.   (line   6)
* <rational-valued>:                     built-in numerics rational-valued.
                                                              (line   6)
* <rational-valued> <1>:                 built-in numerics rational base.
                                                              (line   7)
* <rational-valued> <2>:                 built-in numerics integer-valued.
                                                              (line   7)
* <rational>:                            built-in numerics rational base.
                                                              (line   6)
* <rational> <1>:                        built-in numerics integer.
                                                              (line   7)
* <rational> <2>:                        built-in numerics ratnums base.
                                                              (line   7)
* <ratnum>:                              built-in numerics ratnums base.
                                                              (line   6)
* <ratnum> <1>:                          built-in numerics ratnums positive.
                                                              (line   7)
* <ratnum> <2>:                          built-in numerics ratnums negative.
                                                              (line   7)
* <reader-annotation>:                   built-in reader-annotation.
                                                              (line   6)
* <reader-input-port-mode>:              built-in ports misc. (line   6)
* <real-valued>:                         built-in numerics real-valued.
                                                              (line   6)
* <real-valued> <1>:                     built-in numerics real base.
                                                              (line   7)
* <real>:                                built-in numerics real base.
                                                              (line   6)
* <real> <1>:                            built-in numerics rational-valued.
                                                              (line   7)
* <real> <2>:                            built-in numerics flonums base.
                                                              (line   7)
* <record-constructor-descriptor>:       built-in records rcd.
                                                              (line   6)
* <record-type-descriptor>:              built-in records rtd.
                                                              (line   6)
* <record>:                              built-in records base.
                                                              (line   6)
* <record> <1>:                          built-in conditions base.
                                                              (line   7)
* <record> <2>:                          built-in time time.  (line   7)
* <sentinel>:                            built-in unique sentinel.
                                                              (line   6)
* <stats>:                               built-in stats.      (line   6)
* <string>:                              built-in strings base.
                                                              (line   6)
* <string> <1>:                          built-in strings empty.
                                                              (line   7)
* <string> <2>:                          built-in strings non-empty.
                                                              (line   7)
* <struct-type-descriptor>:              built-in structs std.
                                                              (line   6)
* <struct>:                              built-in unique sentinel.
                                                              (line   7)
* <struct> <1>:                          built-in unique eof. (line   7)
* <struct> <2>:                          built-in unique would-block.
                                                              (line   7)
* <struct> <3>:                          built-in pairs immutable.
                                                              (line   7)
* <struct> <4>:                          built-in structs base.
                                                              (line   6)
* <struct> <5>:                          built-in structs std.
                                                              (line   7)
* <struct> <6>:                          built-in records base.
                                                              (line   7)
* <struct> <7>:                          built-in records rtd.
                                                              (line   7)
* <struct> <8>:                          built-in records rcd.
                                                              (line   7)
* <struct> <9>:                          built-in enum-set.   (line   7)
* <struct> <10>:                         built-in promises.   (line   7)
* <struct> <11>:                         built-in utsname.    (line   7)
* <struct> <12>:                         built-in memory-block.
                                                              (line   7)
* <struct> <13>:                         built-in reader-annotation.
                                                              (line   7)
* <struct> <14>:                         built-in stats.      (line   7)
* <symbol>:                              annotations syntaxes.
                                                              (line 127)
* <symbol> <1>:                          built-in symbols symbols.
                                                              (line   6)
* <symbol> <2>:                          built-in symbols gensyms.
                                                              (line   7)
* <tcbucket>:                            built-in hashtables tcbucket.
                                                              (line   6)
* <textual-input-only-port>:             built-in ports texin.
                                                              (line   6)
* <textual-input-port>:                  built-in ports labels texin.
                                                              (line   6)
* <textual-input-port> <1>:              built-in ports labels texou.
                                                              (line   6)
* <textual-input/output-port>:           built-in ports texio.
                                                              (line   6)
* <textual-output-only-port>:            built-in ports texou.
                                                              (line   6)
* <textual-port>:                        built-in ports labels textual.
                                                              (line   6)
* <thunk>:                               built-in procedures thunk.
                                                              (line   6)
* <time>:                                built-in time time.  (line   6)
* <time> <1>:                            built-in time epoch. (line   7)
* <top>:                                 annotations syntaxes.
                                                              (line 210)
* <top> <1>:                             annotations syntaxes.
                                                              (line 220)
* <top> <2>:                             annotations syntaxes.
                                                              (line 230)
* <top> <3>:                             annotations syntaxes.
                                                              (line 236)
* <top> <4>:                             annotations syntaxes.
                                                              (line 251)
* <top> <5>:                             annotations syntaxes.
                                                              (line 265)
* <top> <6>:                             built-in top.        (line   6)
* <top> <7>:                             built-in booleans boolean.
                                                              (line   7)
* <top> <8>:                             built-in chars.      (line   7)
* <top> <9>:                             built-in symbols symbols.
                                                              (line   7)
* <top> <10>:                            built-in keywords.   (line   7)
* <top> <11>:                            built-in pointers.   (line   7)
* <top> <12>:                            built-in transcoders.
                                                              (line   7)
* <top> <13>:                            built-in procedures procedures.
                                                              (line   7)
* <top> <14>:                            built-in numerics number.
                                                              (line   7)
* <top> <15>:                            built-in strings base.
                                                              (line   7)
* <top> <16>:                            built-in vectors base.
                                                              (line   7)
* <top> <17>:                            built-in lists base. (line   7)
* <top> <18>:                            built-in pairs base. (line   7)
* <top> <19>:                            built-in bytevectors base.
                                                              (line   7)
* <top> <20>:                            built-in hashtables base.
                                                              (line   7)
* <top> <21>:                            built-in hashtables tcbucket.
                                                              (line   7)
* <top> <22>:                            built-in structs base.
                                                              (line   7)
* <top> <23>:                            built-in ports base. (line   7)
* <transcoder>:                          built-in transcoders.
                                                              (line   6)
* <true>:                                built-in booleans true.
                                                              (line   6)
* <type-descriptor>:                     built-in misc.       (line  20)
* <type-destructor>:                     built-in procedures type-destructor.
                                                              (line   6)
* <type-method-retriever>:               built-in procedures type-method-retriever.
                                                              (line   6)
* <type-predicate>:                      built-in procedures type-predicate.
                                                              (line   6)
* <type-printer>:                        built-in procedures type-printer.
                                                              (line   6)
* <union-type-descr>:                    descriptors compound union.
                                                              (line   9)
* <utsname>:                             built-in utsname.    (line   6)
* <vector-of-type-descr>:                descriptors compound vector-of.
                                                              (line   9)
* <vector-type-descr>:                   descriptors compound vector.
                                                              (line   9)
* <vector>:                              annotations syntaxes.
                                                              (line  70)
* <vector> <1>:                          annotations syntaxes.
                                                              (line 104)
* <vector> <2>:                          built-in vectors base.
                                                              (line   6)
* <vector> <3>:                          built-in vectors empty.
                                                              (line   7)
* <vector> <4>:                          built-in vectors non-empty.
                                                              (line   7)
* <void>:                                built-in void.       (line  53)
* <weak-pair>:                           built-in pairs weak. (line   6)
* <wildcard>:                            built-in wildcard.   (line   6)
* <would-block>:                         built-in unique would-block.
                                                              (line   6)
* <zero-byte>:                           built-in numerics bytes zero.
                                                              (line   6)
* <zero-cflonum>:                        built-in numerics cflonums zero.
                                                              (line   6)
* <zero-compnum>:                        built-in numerics compnums zero.
                                                              (line   6)
* <zero-fixnum>:                         built-in numerics fixnums zero.
                                                              (line   6)
* <zero-flonum>:                         built-in numerics flonums zero.
                                                              (line   6)
* <zero-flonum> <1>:                     built-in numerics flonums positive-zero.
                                                              (line   7)
* <zero-flonum> <2>:                     built-in numerics flonums negative-zero.
                                                              (line   7)
* <zero-octet>:                          built-in numerics octets zero.
                                                              (line   6)
* <zero-real>:                           built-in numerics real zero.
                                                              (line   6)
* <zero>:                                built-in numerics sign.
                                                              (line  36)
* _:                                     built-in wildcard.   (line   7)
* alist:                                 annotations syntaxes.
                                                              (line 160)
* ancestor-of:                           annotations syntaxes.
                                                              (line 264)
* case-lambda:                           annotations syntaxes.
                                                              (line 194)
* comparison-procedure:                  annotations syntaxes.
                                                              (line 314)
* condition:                             annotations syntaxes.
                                                              (line 166)
* enumeration:                           annotations syntaxes.
                                                              (line 126)
* equality-predicate:                    annotations syntaxes.
                                                              (line 309)
* hash-function:                         annotations syntaxes.
                                                              (line 319)
* hashtable:                             annotations syntaxes.
                                                              (line 120)
* lambda:                                annotations syntaxes.
                                                              (line 183)
* list:                                  annotations syntaxes.
                                                              (line  60)
* list-of:                               annotations syntaxes.
                                                              (line  86)
* maybe:                                 annotations syntaxes.
                                                              (line 229)
* nelist-of:                             annotations syntaxes.
                                                              (line  95)
* nevector-of:                           annotations syntaxes.
                                                              (line 112)
* not:                                   annotations syntaxes.
                                                              (line 235)
* or:                                    annotations syntaxes.
                                                              (line 209)
* or <1>:                                annotations syntaxes.
                                                              (line 219)
* pair:                                  annotations syntaxes.
                                                              (line  51)
* pair-of:                               annotations syntaxes.
                                                              (line  78)
* parent-of:                             annotations syntaxes.
                                                              (line 250)
* type-of:                               annotations syntaxes.
                                                              (line 324)
* type-predicate:                        annotations syntaxes.
                                                              (line 304)
* vector:                                annotations syntaxes.
                                                              (line  69)
* vector-of:                             annotations syntaxes.
                                                              (line 103)

