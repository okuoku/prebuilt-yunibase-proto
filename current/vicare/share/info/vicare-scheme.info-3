This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: stdlib arithmetic flonums,  Next: stdlib arithmetic exact bitwise,  Prev: stdlib arithmetic fixnums,  Up: stdlib arithmetic

5.11.3 Flonums
--------------

This section describes the '(rnrs arithmetic flonums (6))' library.

   This section uses FL, FL1, FL2, etc., as parameter names for
arguments that must be flonums, and IFL as a name for arguments that
must be integer-valued flonums, i.e., flonums for which the
'integer-valued?' predicate returns true.

 -- Procedure: flonum? OBJ
     Return '#t' if OBJ is a flonum, '#f' otherwise.

 -- Procedure: real->flonum X
     Return the best flonum representation of X.

     The value returned is a flonum that is numerically closest to the
     argument.

          *NOTE* If flonums are represented in binary floating point,
          then implementations should break ties by preferring the
          floating-point representation whose least significant bit is
          zero.

 -- Procedure: fl=? FL1 FL2 FL3 ...
 -- Procedure: fl<? FL1 FL2 FL3 ...
 -- Procedure: fl<=? FL1 FL2 FL3 ...
 -- Procedure: fl>? FL1 FL2 FL3 ...
 -- Procedure: fl>=? FL1 FL2 FL3 ...
     These procedures return '#t' if their arguments are (respectively):
     equal, monotonically increasing, monotonically decreasing,
     monotonically nondecreasing, or monotonically nonincreasing, '#f'
     otherwise.  These predicates must be transitive.

          (fl=? +inf.0 +inf.0)            => #t
          (fl=? -inf.0 +inf.0)            => #f
          (fl=? -inf.0 -inf.0)            => #t
          (fl=? 0.0 -0.0)                 => #t
          (fl<? 0.0 -0.0)                 => #f
          (fl=? +nan.0 fl)                => #f
          (fl<? +nan.0 fl)                => #f

 -- Procedure: flinteger? FL
 -- Procedure: flzero? FL
 -- Procedure: flpositive? FL
 -- Procedure: flnegative? FL
 -- Procedure: flodd? IFL
 -- Procedure: fleven? IFL
 -- Procedure: flfinite? FL
 -- Procedure: flinfinite? FL
 -- Procedure: flnan? FL
     These numerical predicates test a flonum for a particular property,
     returning '#t' or '#f':

     'flinteger?'
          procedure tests whether the number object is an integer,

     'flzero?'
          tests whether it is 'fl=?' to zero,

     'flpositive?'
          tests whether it is greater than zero,

     'flnegative?'
          tests whether it is less than zero,

     'flodd?'
          tests whether it is odd,

     'fleven?'
          tests whether it is even,

     'flfinite?'
          tests whether it is not an infinity and not a NaN,

     'flinfinite?'
          tests whether it is an infinity,

     'flnan?'
          tests whether it is a NaN.

          (flnegative? -0.0)              => #f
          (flfinite?   +inf.0)            => #f
          (flfinite?   5.0)               => #t
          (flinfinite? 5.0)               => #f
          (flinfinite? +inf.0)            => #t

          *NOTE* '(flnegative? -0.0)' must return '#f', else it would
          lose the correspondence with '(fl< -0.0 0.0)', which is '#f'
          according to IEEE 754.

 -- Procedure: flmax FL1 FL2 ...
 -- Procedure: flmin FL1 FL2 ...
     These procedures return the maximum or minimum of their arguments.
     They always return a NaN when one or more of the arguments is a
     NaN.

 -- Procedure: fl+ FL1 ...
 -- Procedure: fl* FL1 ...
     These procedures return the flonum sum or product of their flonum
     arguments.  In general, they should return the flonum that best
     approximates the mathematical sum or product.  (For implementations
     that represent flonums using IEEE binary floating point, the
     meaning of "best" is defined by the IEEE standards.)

          (fl+ +inf.0 -inf.0)             =>  +nan.0
          (fl+ +nan.0 FL)           =>  +nan.0
          (fl* +nan.0 FL)           =>  +nan.0

 -- Procedure: fl- FL1 FL2 ...
 -- Procedure: fl- FL
 -- Procedure: fl/ FL1 FL2 ...
 -- Procedure: fl/ FL
     With two or more arguments, these procedures return the flonum
     difference or quotient of their flonum arguments, associating to
     the left.

     With one argument, however, they return the additive or
     multiplicative flonum inverse of their argument.

     In general, they should return the flonum that best approximates
     the mathematical difference or quotient.  (For implementations that
     represent flonums using IEEE binary floating point, the meaning of
     "best" is reasonably well-defined by the IEEE standards.)

          (fl- +inf.0 +inf.0)             =>  +nan.0

     For undefined quotients, 'fl/' behaves as specified by the IEEE
     standards:

          (fl/ 1.0 0.0)                   => +inf.0
          (fl/ -1.0 0.0)                  => -inf.0
          (fl/ 0.0 0.0)                   => +nan.0

 -- Procedure: flabs FL
     Return the absolute value of FL.

 -- Procedure: fldiv-and-mod FL1 FL2
 -- Procedure: fldiv FL1 FL2
 -- Procedure: flmod FL1 FL2
 -- Procedure: fldiv0-and-mod0 FL1 FL2
 -- Procedure: fldiv0 FL1 FL2
 -- Procedure: flmod0 FL1 FL2
     These procedures implement number-theoretic integer division and
     return the results of the corresponding mathematical operations
     specified in report section *note baselib math semantics integer::.

     In the cases where the mathematical requirements in *note baselib
     math semantics:: cannot be satisfied by any number object, either
     an exception is raised with condition type
     '&implementation-restriction', or unspecified flonums (one for
     'fldiv', 'flmod', 'fldiv0' and 'flmod0', two for 'fldiv-and-mod'
     and 'fldiv0-and-mod0') are returned.

          (fldiv FL1 FL2)         => FL1 div FL2
          (flmod FL1 FL2)         => FL1 mod FL2
          (fldiv-and-mod FL1 FL2) => FL1 div FL2, FL1 mod FL2
                                                  ; two return values
          (fldiv0 FL1 FL2)        => FL1 div_0 FL2
          (flmod0 FL1 FL2)        => FL1 mod_0 FL2
          (fldiv0-and-mod0 FL1 FL2)
          => FL1 div_0 FL2, FL1 mod_0 FL2
             ; two return values

 -- Procedure: flnumerator FL
 -- Procedure: fldenominator FL
     These procedures return the numerator or denominator of FL as a
     flonum; the result is computed as if FL was represented as a
     fraction in lowest terms.  The denominator is always positive.  The
     denominator of 0.0 is defined to be 1.0.

          (flnumerator +inf.0)           => +inf.0
          (flnumerator -inf.0)           => -inf.0
          (fldenominator +inf.0)         => 1.0
          (fldenominator -inf.0)         => 1.0
          (flnumerator 0.75)             => 3.0 ; probably
          (fldenominator 0.75)           => 4.0 ; probably

     Implementations should implement following behavior:

          (flnumerator -0.0)             => -0.0

 -- Procedure: flfloor FL
 -- Procedure: flceiling FL
 -- Procedure: fltruncate FL
 -- Procedure: flround FL
     These procedures return integral flonums for flonum arguments that
     are not infinities or NaNs.

     'flfloor'
          Returns the largest integral flonum not larger than FL.

     'flceiling'
          Returns the smallest integral flonum not smaller than FL.

     'fltruncate'
          Returns the integral flonum closest to FL whose absolute value
          is not larger than the absolute value of FL.

     'flround'
          Returns the closest integral flonum to FL, rounding to even
          when FL represents a number halfway between two integers.

     Although infinities and NaNs are not integer objects, these
     procedures return an infinity when given an infinity as an
     argument, and a NaN when given a NaN:

          (flfloor +inf.0)                => +inf.0
          (flceiling -inf.0)              => -inf.0
          (fltruncate +nan.0)             => +nan.0

 -- Procedure: flexp FL
 -- Procedure: fllog FL
 -- Procedure: fllog FL1 FL2
 -- Procedure: flsin FL
 -- Procedure: flcos FL
 -- Procedure: fltan FL
 -- Procedure: flasin FL
 -- Procedure: flacos FL
 -- Procedure: flatan FL
 -- Procedure: flatan FL1 FL2
     These procedures compute the usual transcendental functions.

     'flexp'
          Computes the base-E exponential of FL.

     'fllog'
          With a single argument computes the natural logarithm of FL
          (not the base ten logarithm); '(fllog FL1 FL2)' computes the
          base-FL2 logarithm of FL1.

     'flasin'
     'flacos'
     'flatan'
          Compute arcsine, arccosine, and arctangent, respectively.
          '(flatan FL1 FL2)' computes the arc tangent of FL1/FL2.

     *note baselib math ops trascend:: for the underlying mathematical
     operations.  In the event that these operations do not yield a real
     result for the given arguments, the result may be a NaN, or may be
     some unspecified flonum.

     Implementations that use IEEE binary floating-point arithmetic
     should follow the relevant standards for these procedures.

          (flexp +inf.0)          => +inf.0
          (flexp -inf.0)          => 0.0
          (fllog +inf.0)          => +inf.0
          (fllog 0.0)             => -inf.0
          (fllog -0.0)            => unspecified ; if -0.0 is distinguished
          (fllog -inf.0)          => +nan.0
          (flatan -inf.0)         => -1.5707963267948965  ; approximately
          (flatan +inf.0)         => 1.5707963267948965   ; approximately

 -- Procedure: flsqrt FL
     Returns the principal square root of FL.  For -0.0, 'flsqrt' should
     return -0.0; for other negative arguments, the result may be a NaN
     or some unspecified flonum.

          (flsqrt +inf.0)         => +inf.0
          (flsqrt -0.0)           => -0.0

 -- Procedure: flexpt FL1 FL2
     Either FL1 should be non-negative, or, if FL1 is negative, FL2
     should be an integer object.

     The 'flexpt' procedure returns FL1 raised to the power FL2.  If FL1
     is negative and FL2 is not an integer object, the result may be a
     NaN, or may be some unspecified flonum.

     If FL1 and FL2 are both zero, the result is 1.0.  If FL1 is zero
     and FL2 is positive, the result is zero.  If FL1 is negative, the
     result may be a NaN, or may be some unspecified flonum.

 -- Condition Type: &no-infinities
 -- Procedure: make-no-infinities-violation
 -- Procedure: no-infinities-violation? OBJ
 -- Condition Type: &no-nans
 -- Procedure: make-no-nans-violation
 -- Procedure: no-nans-violation? OBJ
     These condition types could be defined by the following code:

          (define-condition-type &no-infinities
              &implementation-restriction
            make-no-infinities-violation
            no-infinities-violation?)

          (define-condition-type &no-nans
              &implementation-restriction
            make-no-nans-violation no-nans-violation?)

     These types describe that a program has executed an arithmetic
     operations that is specified to return an infinity or a NaN,
     respectively, on a Scheme implementation that is not able to
     represent the infinity or NaN. *note baselib math infinities::.

 -- Procedure: fixnum->flonum FX
     Return a flonum that is numerically closest to FX.

          *NOTE* The result of this procedure may not be numerically
          equal to FX, because the fixnum precision may be greater than
          the flonum precision.


File: vicare-scheme.info,  Node: stdlib arithmetic exact bitwise,  Prev: stdlib arithmetic flonums,  Up: stdlib arithmetic

5.11.4 Exact bitwise arithmetic
-------------------------------

This section describes the '(rnrs arithmetic bitwise (6))' library.  The
exact bitwise arithmetic provides generic operations on exact integer
objects.  This section uses EI, EI1, EI2, etc., as parameter names that
must be exact integer objects.

 -- Procedure: bitwise-not EI
     Returns the exact integer object whose two's complement
     representation is the one's complement of the two's complement
     representation of EI.

 -- Procedure: bitwise-and EI1 ...
 -- Procedure: bitwise-ior EI1 ...
 -- Procedure: bitwise-xor EI1 ...
     These procedures return the exact integer object that is the
     bit-wise "and", "inclusive or", or "exclusive or" of the two's
     complement representations of their arguments.  If they are passed
     only one argument, they return that argument.  If they are passed
     no arguments, they return the integer object (either -1 or 0) that
     acts as identity for the operation.

 -- Procedure: bitwise-if EI1 EI2 EI3
     Return the exact integer object that is the bit-wise "if" of the
     two's complement representations of its arguments, i.e.  for each
     bit, if it is 1 in EI1, the corresponding bit in EI2 becomes the
     value of the corresponding bit in the result, and if it is 0, the
     corresponding bit in EI3 becomes the corresponding bit in the value
     of the result.  This is the result of the following computation:

          (bitwise-ior (bitwise-and EI1 EI2)
                       (bitwise-and (bitwise-not EI1) EI3))

 -- Procedure: bitwise-bit-count EI
     If EI is non-negative, this procedure returns the number of 1 bits
     in the two's complement representation of EI.  Otherwise it returns
     the result of the following computation:

          (bitwise-not (bitwise-bit-count (bitwise-not EI)))

 -- Procedure: bitwise-length EI
     Return the number of bits needed to represent EI if it is positive,
     and the number of bits needed to represent '(bitwise-not EI)' if it
     is negative, which is the exact integer object that is the result
     of the following computation:

          (do ((result 0 (+ result 1))
               (bits (if (negative? EI)
                         (bitwise-not EI)
                         EI)
                     (bitwise-arithmetic-shift bits -1)))
              ((zero? bits)
               result))

 -- Procedure: bitwise-first-bit-set EI
     Returns the index of the least significant 1 bit in the two's
     complement representation of EI.  If EI is 0, then -1 is returned.

          (bitwise-first-bit-set 0)        => -1
          (bitwise-first-bit-set 1)        => 0
          (bitwise-first-bit-set -4)       => 2

 -- Procedure: bitwise-bit-set? EI1 EI2
     EI2 must be non-negative.

     The 'bitwise-bit-set?' procedure returns '#t' if the EI2th bit is 1
     in the two's complement representation of EI1, and '#f' otherwise.
     This is the result of the following computation:

          (not (zero?
                 (bitwise-and
                   (bitwise-arithmetic-shift-left 1 EI2)
                   EI1)))

 -- Procedure: bitwise-copy-bit EI1 EI2 EI3
     EI2 must be non-negative, and EI3 must be either 0 or 1.

     The 'bitwise-copy-bit' procedure returns the result of replacing
     the EI2th bit of EI1 by EI3, which is the result of the following
     computation:

          (let* ((mask (bitwise-arithmetic-shift-left 1 EI2)))
            (bitwise-if mask
                      (bitwise-arithmetic-shift-left EI3 EI2)
                      EI1))

 -- Procedure: bitwise-bit-field EI1 EI2 EI3
     EI2 and EI3 must be non-negative, and EI2 must be less than or
     equal to EI3.

     The 'bitwise-bit-field' procedure returns the number represented by
     the bits at the positions from EI2 (inclusive) to EI3 (exclusive),
     which is the result of the following computation:

          (let ((mask
                 (bitwise-not
                  (bitwise-arithmetic-shift-left -1 EI3))))
            (bitwise-arithmetic-shift-right
              (bitwise-and EI1 mask)
              EI2))

 -- Procedure: bitwise-copy-bit-field EI1 EI2 EI3 EI4
     EI2 and EI3 must be non-negative, and EI2 must be less than or
     equal to EI3.

     The 'bitwise-copy-bit-field' procedure returns the result of
     replacing in EI1 the bits at positions from EI2 (inclusive) to EI3
     (exclusive) by the bits in EI4 from position 0 (inclusive) to
     position EI3 - EI2 (exclusive) which is the result of the following
     computation:

          (let* ((to    EI1)
                 (start EI2)
                 (end   EI3)
                 (from  EI4)
                 (mask1
                   (bitwise-arithmetic-shift-left -1 start))
                 (mask2
                   (bitwise-not
                     (bitwise-arithmetic-shift-left -1 end)))
                 (mask (bitwise-and mask1 mask2)))
            (bitwise-if mask
                        (bitwise-arithmetic-shift-left from
                                                       start)
                        to))

 -- Procedure: bitwise-arithmetic-shift EI1 EI2
     Return the result of the following computation:

          (floor (* EI1 (expt 2 EI2)))

     Examples:

          (bitwise-arithmetic-shift -6 -1)    => -3
          (bitwise-arithmetic-shift -5 -1)    => -3
          (bitwise-arithmetic-shift -4 -1)    => -2
          (bitwise-arithmetic-shift -3 -1)    => -2
          (bitwise-arithmetic-shift -2 -1)    => -1
          (bitwise-arithmetic-shift -1 -1)    => -1

 -- Procedure: bitwise-arithmetic-shift-left EI1 EI2
 -- Procedure: bitwise-arithmetic-shift-right EI1 EI2
     EI2 must be non-negative.

     The 'bitwise-arithmetic-shift-left' procedure returns the same
     result as 'bitwise-arithmetic-shift', and:

          (bitwise-arithmetic-shift-right EI1 EI2)

     returns the same result as:

          (bitwise-arithmetic-shift EI1 (- EI2))

 -- Procedure: bitwise-rotate-bit-field EI1 EI2 EI3 EI4
     EI2, EI3, EI4 must be non-negative, EI2 must be less than or equal
     to EI3.

     The procedure returns the result of cyclically permuting in EI1 the
     bits at positions from EI2 (inclusive) to EI3 (exclusive) by EI4
     bits towards the more significant bits, which is the result of the
     following computation:

          (let* ((n     EI1)
                 (start EI2)
                 (end   EI3)
                 (count EI4)
                 (width (- end start)))
            (if (positive? width)
                (let* ((count (mod count width))
                       (field0
                         (bitwise-bit-field n start end))
                       (field1 (bitwise-arithmetic-shift-left
                                 field0 count))
                       (field2 (bitwise-arithmetic-shift-right
                                 field0
                                 (- width count)))
                       (field (bitwise-ior field1 field2)))
                  (bitwise-copy-bit-field n start end field))
                n))

 -- Procedure: bitwise-reverse-bit-field EI1 EI2 EI3
     EI2 and EI3 must be non-negative, and EI2 must be less than or
     equal to EI3.

     The 'bitwise-reverse-bit-field' procedure returns the result
     obtained from EI1 by reversing the order of the bits at positions
     from EI2 (inclusive) to EI3 (exclusive).

          (bitwise-reverse-bit-field #b1010010 1 4)
          =>  88 ; #b1011000


File: vicare-scheme.info,  Node: stdlib syntax-case,  Next: stdlib hashtable,  Prev: stdlib arithmetic,  Up: stdlib

5.12 Syntax-case
================

The '(rnrs syntax-case (6))' library provides support for writing
low-level macros in a high-level style, with automatic syntax checking,
input destructuring, output restructuring, maintenance of lexical
scoping and referential transparency (hygiene), and support for
controlled identifier capture.

* Menu:

* stdlib syntax-case intro::            Informal introduction
                                        for beginners.
* stdlib syntax-case hygiene::          Hygiene.
* stdlib syntax-case objects::          Syntax objects.
* stdlib syntax-case transformers::     Transformers.
* stdlib syntax-case parsing::          Parsing input and producing
                                        output.
* stdlib syntax-case identifier::       Identifier predicates.
* stdlib syntax-case conversion::       Syntax-object and datum
                                        conversions.
* stdlib syntax-case temporaries::      Generating lists of temporaries.
* stdlib syntax-case derived::          Derived forms and procedures.
* stdlib syntax-case violations::       Syntax violations.

Examples

* stdlib syntax-case lisp::             Common Lisp style macros.


File: vicare-scheme.info,  Node: stdlib syntax-case intro,  Next: stdlib syntax-case hygiene,  Up: stdlib syntax-case

5.12.1 Informal introduction for beginners
------------------------------------------

A macro system allows us to give symbols in the S-expression of a Scheme
program the role of "syntactic keywords"; this means that a
subexpression is extracted from the program's S-expression and can be
processed by an appropriate function, called "transformer", before being
put back.

* Menu:

* stdlib syntax-case intro use::    An example of macro use.
* stdlib syntax-case intro unwrap:: Unwrapping syntax objects.
* stdlib syntax-case intro ex::     A transformer example.
* stdlib syntax-case intro more::   More on wrapped and unwrapped
                                    syntax objects.
* stdlib syntax-case intro expand:: A quick look at the expander.


File: vicare-scheme.info,  Node: stdlib syntax-case intro use,  Next: stdlib syntax-case intro unwrap,  Up: stdlib syntax-case intro

5.12.1.1 An example of macro use
................................

Let's say that 'infix' is a syntactic keyword; we may have a library
like this:

     (library (infix)
       (export infix)
       (import (rnrs))
       (define-syntax infix
         (lambda (use) ---) ;this is the transformer function
         ))

then in the following program S-expression:

     (import (rnrs) (infix))

     (let-values (((port getter) (open-string-output-port)))
       (display (infix 1 + 2) port)
       (getter))

the subexpression:

     (infix 1 + 2)

is a "macro use" of the 'infix' syntax and it becomes the "input form"
of the transformer function of 'infix'; the input form is extracted from
the whole S-expression, transformed, let's say, into the "output form":

     (begin 3)

and put back:

     (import (rnrs) (infix))

     (let-values (((port getter) (open-string-output-port)))
       (display (begin 3) port)
       (getter))

   A number of rules are used not to mess up bidings in the input and
output forms; these are introduced in *note Hygiene: stdlib syntax-case
hygiene.

   The single argument transformer functions are applied to is a "syntax
object" representing the input form; the standard defines "wrapped
syntax objects" and "unwrapped syntax objects".  Both wrapped and
unwrapped objects can be used to represent the same informations, but
wrapped objects can be more efficient in terms of consumed resources.


File: vicare-scheme.info,  Node: stdlib syntax-case intro unwrap,  Next: stdlib syntax-case intro ex,  Prev: stdlib syntax-case intro use,  Up: stdlib syntax-case intro

5.12.1.2 Unwrapping syntax objects
..................................

Let's focus on unwrapped syntax objects, which are easier to deal with;
it is always possible to convert a wrapped syntax object into an
unwrapped one by applying the 'unwrap' function defined in the following
library (it is *not* important to understand it at first reading):

     (library (syntax-utilities)
       (export unwrap)
       (import (rnrs))
       (define (unwrap stx)
         (syntax-case stx ()
           (()
            '())
           ((?car . ?cdr)
            (cons (unwrap (syntax ?car))
                  (unwrap (syntax ?cdr))))
           (#(?item ...)
            (list->vector (unwrap (syntax (?item ...)))))
           (?atom
            (identifier? (syntax ?atom))
            (syntax ?atom))
           (?atom
            (syntax->datum (syntax ?atom))))))

it is possible to define alternative versions of this function with
different properties, depending on the intended usage.

   Now let's define the following library:

     (library (try-it-macros)
       (export the-macro)
       (import (rnrs)
         (for (syntax-utilities) expand))
       (define-syntax the-macro
         (lambda (stx)
           (let ((sexp (unwrap stx)))
             (write sexp)(newline)
             #f))))

the macro use in the following program:

     (import (rnrs) (try-it-macros))

     (the-macro 1 hello #(ciao 2) 3 salut)

will cause the input form to be unwrapped and bound to 'sexp', then the
S-expression is displayed as something like:

     (#<syntax the-macro>
      1
      #<syntax hello>
      #(#<syntax ciao> 2)
      3
      #<syntax salut>)

we see that where symbols appear in the input form, in the unwrapped
syntax object we have "identifiers": syntax objects holding only a
symbol marked with its originating lexical context.  We can process
'sexp' with the ordinary Scheme functions, then return an S-expression
holding datums and identifiers that do what we want.


File: vicare-scheme.info,  Node: stdlib syntax-case intro ex,  Next: stdlib syntax-case intro more,  Prev: stdlib syntax-case intro unwrap,  Up: stdlib syntax-case intro

5.12.1.3 A transformer example
..............................

Here is an example implementation of the 'receive' syntax, giving a
condensed interface to 'call-with-values':

     (import (rnrs) (for (syntax-utilities) expand))

     (define-syntax receive
       (lambda (use)
         (let ((sexp (unwrap use)))
           (let ((formals          (cadr  sexp))
                 (expression       (caddr sexp))
                 (body             (cdddr sexp)))
             `(,(syntax call-with-values)
                   (,(syntax lambda) () ,expression)
                   (,(syntax lambda) ,formals . ,body))))))

     (receive (a b)
         (values 1 2)
       (write 'ciao)
       (list a b))
     ==> (call-with-values
             (lambda ()
               (values 1 2))
           (lambda (a b)
             (write 'ciao)
             (list a b)))

   The transformer of the 'receive' macro extracts datums and
identifiers from the input form using the common list functions 'car',
'cdr', ... and, for simplicity, it performs no checks to verify that the
input form has the required structure (for example: it does not check
that the first element after the syntactic keyword 'receive' is a list
of identifiers).

   The 'syntax-case' macro, exported by the library '(rnrs syntax-case
(6))', provides a way to both extract elements from a syntax object and
to perform basic checks on its structure; it is usually more convenient
and efficient to use 'syntax-case' for macro-specific processing, rather
than to unwrap the input form and process the result.


File: vicare-scheme.info,  Node: stdlib syntax-case intro more,  Next: stdlib syntax-case intro expand,  Prev: stdlib syntax-case intro ex,  Up: stdlib syntax-case intro

5.12.1.4 More on wrapped and unwrapped syntax objects
.....................................................

A wrapped syntax object can be implemented as a record instance
containing an S-expression and lexical context informations; wrapped
syntax objects are a disjoint type of values.  An unwrapped object is an
S-expression, a structure of pairs and/or vectors, holding datums and
syntax objects.

   Fully unwrapping a syntax object means to convert it into an
S-expression in which all the symbols are turned into identifiers and
the identifiers are the only syntax objects.  The identifier is the
simplest syntax object with lexical informations in it; the symbol is
the only element of an input form which needs lexical informations; so
the wrapped syntax object:

     #<syntax (1 ciao)>

is unwrapped to:

     (1 #<syntax ciao>)

   A syntax object can be partially unwrapped, for example:

     #<syntax (the-macro 1 hello #(ciao 2) 3 salut)>

can be unwrapped to:

     (#<syntax the-macro>
      1
      #<syntax hello>
      #<syntax #(ciao 2)>
      3
      #<syntax salut>)

which still contains the wrapped syntax object '#<syntax #(ciao 2)>'.

   The function 'unwrap' defined above fully unwraps its argument;
notice that it will unwrap also quoted S-expressions, for example:

     #<syntax (a b '(1 2 #\c d))>

is unwrapped to:

     (#<syntax a>
      #<syntax b>
      (#<syntax quote>
       (1 2 #\c #<syntax d>)))

this is not always what we want.


File: vicare-scheme.info,  Node: stdlib syntax-case intro expand,  Prev: stdlib syntax-case intro more,  Up: stdlib syntax-case intro

5.12.1.5 A quick look at the expander
.....................................

Macro transformers are ordinary Scheme functions, which are written in
an R6RS-compatible Scheme language; the only difference from ordinary
functions, is that: transformer definitions are evaluated at "expand
time", while ordinary function definitions are evaluated at "run time".
We take a look at how the expander works, avoiding almost all the
details and focusing on the languages.

   Let's define a simple library to be used as language for run time:

     #!r6rs
     (library (language-for-run)
       (export write newline quote define)
       (import (rnrs)))

and a simple library to be used as language for expand time:

     #!r6rs
     (library (language-for-expand)
       (export lambda syntax)
       (import (rnrs)))

we use them in the following library, where we also import
'define-syntax' for run time:

     #!r6rs
     (library (the-library)
       (export doit)
       (import (for (language-for-run) run)
         (for (language-for-expand) expand)
         (for (only (rnrs) define-syntax) run))

       (define (doit)
         (write (the-macro))
         (newline))

       (define-syntax the-macro
         (lambda (stx)
           (syntax (quote (1 2 3)))))
       )

we can run the code with the following program:

     #!r6rs
     (import (the-library))
     (doit)

   Let's point our attention to '(the-library)'.  After parsing the
'import' and 'export' clauses, the expander scans the library body; the
'define-syntax' identifier is recognised as the one from '(rnrs)', so
the transformer expression on its right-hand side:

     (lambda (stx)
       (syntax (quote (1 2 3))))

is extracted and (not true, but we have to start from somewhere) we can
imagine it being evaluated with (notice the import levels):

     (define the-transformer
       (eval '(lambda (stx)
                (syntax (quote (1 2 3))))
             (environment
               '(for (language-for-run)    (meta -1))
               '(for (language-for-expand) run))))

what's left of the library's body is:

     (define (doit)
       (write (the-macro))
       (newline))

which is scanned for uses of 'the-macro'; the use is found and the
transformer function applied to a syntax object holding '(the-macro)';
the return value is a syntax object holding the quoted list '(1 2 3)',
which is inserted in the body:

     (define (doit)
       (write (quote (1 2 3)))
       (newline))

   The body can now be evaluated using bindings from
'(language-for-run)'.


File: vicare-scheme.info,  Node: stdlib syntax-case hygiene,  Next: stdlib syntax-case objects,  Prev: stdlib syntax-case intro,  Up: stdlib syntax-case

5.12.2 Hygiene
--------------

Barendregt's _hygiene condition_ for the lambda calculus is an informal
notion that requires the free variables of an expression _N_ that is to
be substituted into another expression _M_ not to be captured by
bindings in _M_ when such capture is not intended.

   Kohlbecker, et al.  propose a corresponding _hygiene condition for
macro expansion_ that applies in all situations where capturing is not
explicit: "Generated identifiers that become binding instances in the
completely expanded program must only bind variables that are generated
at the same transcription step".  In the terminology of this document,
the "generated identifiers" are those introduced by a transformer rather
than those present in the form passed to the transformer, and a "macro
transcription step" corresponds to a single call by the expander to a
transformer.  Also, the hygiene condition applies to all introduced
bindings rather than to introduced variable bindings alone.

   This leaves open what happens to an introduced identifier that
appears outside the scope of a binding introduced by the same call.
Such an identifier refers to the lexical binding in effect where it
appears (within a 'syntax' ?TEMPLATE) inside the transformer body or one
of the helpers it calls.  This is essentially the referential
transparency property described by Clinger and Rees.  Thus, the hygiene
condition can be restated as follows:

     A binding for an identifier introduced into the output of a
     transformer call from the expander must capture only references to
     the identifier introduced into the output of the same transformer
     call.

     A reference to an identifier introduced into the output of a
     transformer refers to the closest enclosing binding for the
     introduced identifier or, if it appears outside of any enclosing
     binding for the introduced identifier, the closest enclosing
     lexical binding where the identifier appears (within a 'syntax'
     ?TEMPLATE) inside the transformer body or one of the helpers it
     calls.

   Explicit captures are handled via 'datum->syntax'.

   Operationally, the expander can maintain hygiene with the help of
_marks_.  Marks are applied selectively by the expander to the output of
each transformer it invokes, and substitutions are applied to the
portions of each binding form that are supposed to be within the scope
of the bound identifiers.  Marks are used to distinguish like-named
identifiers that are introduced at different times (either present in
the source or introduced into the output of a particular transformer
call), and substitutions are used to map identifiers to their
expand-time values.

   Each time the expander encounters a macro use, it applies an
_antimark_ to the input form, invokes the associated transformer, then
applies a fresh mark to the output.  Marks and antimarks cancel, so the
portions of the input that appear in the output are effectively left
unmarked, while the portions of the output that are introduced are
marked with the fresh mark.

   Each time the expander encounters a binding form it creates a set of
substitutions, each mapping one of the (possibly marked) bound
identifiers to information about the binding.  (For a 'lambda'
expression, the expander might map each bound identifier to a
representation of the formal parameter in the output of the expander.
For a 'let-syntax' form, the expander might map each bound identifier to
the associated transformer.)  These substitutions are applied to the
portions of the input form in which the binding is supposed to be
visible.

   Marks and substitutions together form a _wrap_ that is layered on the
form being processed by the expander and pushed down toward the leaves
as necessary.  A wrapped form is referred to as a _wrapped syntax
object_.  Ultimately, the wrap may rest on a leaf that represents an
identifier, in which case the wrapped syntax object is also referred to
as an _identifier_.  An identifier contains a name along with the wrap.
(Names are typically represented by symbols.)

   When a substitution is created to map an identifier to an expand-time
value, the substitution records the name of the identifier and the set
of marks that have been applied to that identifier, along with the
associated expand-time value.  The expander resolves identifier
references by looking for the latest matching substitution to be applied
to the identifier, i.e., the outermost substitution in the wrap whose
name and marks match the name and marks recorded in the substitution.
The name matches if it is the same name (if using symbols, then by
'eq?'), and the marks match if the marks recorded with the substitution
are the same as those that appear _below_ the substitution in the wrap,
i.e., those that were applied _before_ the substitution.  Marks applied
after a substitution, i.e., appear over the substitution in the wrap,
are not relevant and are ignored.

   An algebra that defines how marks and substitutions work more
precisely is given in section 2.4 of Oscar Waddell's PhD thesis.  Note,
however, that Waddell's thesis describes slightly different semantics
for 'bound-identifier=?', it specifies that for two identifiers to be
equal in the sense of 'bound-identifier=?', they must have the same
marks and be equal in the sense of 'free-identifier=?', whereas this
report requires instead that they must have the same marks and have the
same name.


File: vicare-scheme.info,  Node: stdlib syntax-case objects,  Next: stdlib syntax-case transformers,  Prev: stdlib syntax-case hygiene,  Up: stdlib syntax-case

5.12.3 Syntax objects
---------------------

A _syntax object_ is a representation of a Scheme form that contains
contextual information about the form in addition to its structure.
This contextual information is used by the expander to maintain lexical
scoping and may also be used by an implementation to maintain
source-object correlation.

   A syntax object may be wrapped.  It may also be unwrapped, fully or
partially, i.e., consist of list and vector structure with wrapped
syntax objects or nonsymbol values at the leaves.  More formally, a
syntax object is:

   * a pair of syntax objects,

   * a vector of syntax objects,

   * a nonpair, nonvector, nonsymbol value, or

   * a wrapped syntax object.

   The distinction between the terms "syntax object" and "wrapped syntax
object" is important.  For example, when invoked by the expander, a
transformer must accept a wrapped syntax object but may return any
syntax object, including an unwrapped syntax object.

   Syntax objects representing identifiers are always wrapped and are
distinct from other types of values.  Wrapped syntax objects that are
not identifiers may or may not be distinct from other types of values.


File: vicare-scheme.info,  Node: stdlib syntax-case transformers,  Next: stdlib syntax-case parsing,  Prev: stdlib syntax-case objects,  Up: stdlib syntax-case

5.12.4 Transformers
-------------------

In 'define-syntax', 'let-syntax', and 'letrec-syntax' forms, a binding
for a syntactic keyword is an expression that evaluates to a
"transformer".

   A transformer is a "transformation procedure" or a "variable
transformer".  A transformation procedure is a procedure that must
accept one argument, a wrapped syntax object representing the input, and
return a syntax object representing the output.  The transformer is
called by the expander whenever a reference to a keyword with which it
has been associated is found.  If the keyword appears in the car of a
list-structured input form, the transformer receives the entire
list-structured form, and its output replaces the entire form.

   Except with variable transformers (see below), if the keyword is
found in any other definition or expression context, the transformer
receives a wrapped syntax object representing just the keyword
reference, and its output replaces just the reference.  Except with
variable transformers, an exception with condition type '&syntax' is
raised if the keyword appears on the left-hand side of a 'set!'
expression.

   Let's set what this means with an example:

     (import (rnrs))

     (define a 1)
     (define (b arg) (list 2 arg))

     (define-syntax doit
       (lambda (stx)
         (syntax-case stx ()
           (?x
            (identifier? #'?x)
            #'a)
           ((?x ?arg)
            #'(b ?arg)))))

     doit            => 1
     (doit 3)        => (2 3)
     (set! doit 5)   error-> &syntax

when the macro use '(doit 3)' is expanded: the transformer receives the
whole form '(doit 3)' in the syntax object argument; when the macro use
'doit' is expanded: the transformer receives only the identifier 'doit'
in the syntax object argument; when the keyword 'doit' is used in 'set!
doit 1': the expander recognises this situation as invalid, rather than
a reference to 'doit', and it raises an exception.

 -- Procedure: make-variable-transformer PROC
     PROC should accept one argument, a wrapped syntax object, and
     return a syntax object.

     The 'make-variable-transformer' procedure creates a "variable
     transformer".  A variable transformer is like an ordinary
     transformer except that, if a keyword associated with a variable
     transformer appears on the left-hand side of a 'set!' expression,
     an exception is not raised.  Instead, PROC is called with a wrapped
     syntax object representing the entire 'set!' expression as its
     argument, and its return value replaces the entire 'set!'
     expression.

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC only to the extent performed by applying
     it as described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

   The following example shows the difference between a common
transformer and a transformer wrapped by 'make-variable-transformer':

     (import (rnrs))

     (define a 1)
     (define (b arg) (list 2 arg))
     (define (c arg) (list 4 arg))

     (define-syntax doit
       (make-variable-transformer
         (lambda (stx)
           (syntax-case stx (set!)
             (?x
              (identifier? #'?x)
              #'a)
             ((?x ?arg)
              #'(b ?arg))
             ((set! ?x ?expr)
              #'(c ?expr))
             ))))

     doit            => 1
     (doit 3)        => (2 3)
     (set! doit 5)   => (4 5)

   The following is another meaningless example using the 'unwrap'
function defined in *note stdlib syntax-case intro:::

     (import (rnrs) (for (syntax-utilities) expand))

     (define-syntax alpha
       (make-variable-transformer
        (lambda (use)
          (write (unwrap use))
          (newline)
          #f)))

     (set! alpha 123)
     -| (#<syntax set!> #<syntax alpha> 123)

     alpha
     -| #<syntax alpha>

   Notice that 'syntax-rules' accepts only patterns being lists or
vectors; the following definition will raise a syntax violation:

     (define-syntax doit
       (syntax-rules () (x a))) error-> &syntax


File: vicare-scheme.info,  Node: stdlib syntax-case parsing,  Next: stdlib syntax-case identifier,  Prev: stdlib syntax-case transformers,  Up: stdlib syntax-case

5.12.5 Parsing input and producing output
-----------------------------------------

Transformers can destructure their input with 'syntax-case' and rebuild
their output with 'syntax'.

 -- Syntax: syntax-case ?EXPRESSION (?LITERAL ...) ?SYNTAX-CASE-CLAUSE
          ...
 -- Auxiliary Syntax: _
 -- Auxiliary Syntax: ...
     Each ?LITERAL must be an identifier.  Each ?SYNTAX-CASE-CLAUSE must
     take one of the following two forms.

          (?PATTERN ?OUTPUT-EXPRESSION)
          (?PATTERN ?FENDER ?OUTPUT-EXPRESSION)

     ?FENDER and ?OUTPUT-EXPRESSION must be ?EXPRESSIONs.

     A ?PATTERN is an identifier, constant, or one of the following.

          (?PATTERN ...)
          (?PATTERN ?PATTERN ... . ?PATTERN)
          (?PATTERN ... ?PATTERN ?ELLIPSIS ?PATTERN ...)
          (?PATTERN ... ?PATTERN ?ELLIPSIS ?PATTERN ... . ?PATTERN)
          #(?PATTERN ...)
          #(?PATTERN ... ?PATTERN ?ELLIPSIS ?PATTERN ...)

     An ?ELLIPSIS is the identifier '...' (three periods).

     An identifier appearing within a ?PATTERN may be an underscore '_',
     an ellipsis '...' or a literal identifier listed in the list of
     literals '(?LITERAL ...)'.  All other identifiers appearing within
     a ?PATTERN are "pattern variables".  It is a syntax violation if an
     ellipsis or underscore appears in '(?LITERAL ...)'.

     '_' and '...' are the same as in the '(rnrs base (6))' library.

     Pattern variables match arbitrary input subforms and are used to
     refer to elements of the input.  It is a syntax violation if the
     same pattern variable appears more than once in a ?PATTERN.

     Underscores also match arbitrary input subforms but are not pattern
     variables and so cannot be used to refer to those elements.
     Multiple underscores may appear in a ?PATTERN.

     A literal identifier matches an input subform if and only if the
     input subform is an identifier and either both its occurrence in
     the input expression and its occurrence in the list of literals
     have the same lexical binding, or the two identifiers have the same
     name and both have no lexical binding.

     A subpattern followed by an ellipsis can match zero or more
     elements of the input.

     More formally, an input form F matches a pattern P if and only if
     one of the following holds:

        * P is an underscore.

        * P is a pattern variable.

        * P is a literal identifier and F is an equivalent identifier in
          the sense of 'free-identifier=?'.

        * P is of the form:

               (P_1 ... P_n)

          and F is a list of n elements that match P_1 through P_n.

        * P is of the form:

               (P_1 ... P_n . P_x)

          and F is a list or improper list of n or more elements whose
          first n elements match P_1 through P_n and whose nth cdr
          matches P_x.

        * P is of the form:

               (P_1 ... P_k P_e ?ELLIPSIS P_(m+1) ... P_n)

          where ?ELLIPSIS is the identifier '...' and F is a proper list
          of n elements whose first k elements match P_1 through P_k,
          whose next m-k elements each match P_e, and whose remaining
          n-m elements match P_(m+1) through P_n.

        * P is of the form:

               (P_1 ... P_k P_e ?ELLIPSIS P_(m+1) ... P_n . P_x)

          where ?ELLIPSIS is the identifier '...' and F is a list or
          improper list of n elements whose first k elements match P_1
          through P_k, whose next m-k elements each match P_e, whose
          next n-m elements match P_(m+1) through P_n, and whose nth and
          final cdr matches P_x.

        * P is of the form:

               #(P_1 ... P_n)

          and F is a vector of n elements that match P_1 through P_n.

        * P is of the form:

               #(P_1 ... P_k P_e ?ELLIPSIS P_(m+1) ... P_n)

          where ?ELLIPSIS is the identifier '...' and F is a vector of n
          or more elements whose first k elements match P_1 through P_k,
          whose next m-k elements each match P_e, and whose remaining
          n-m elements match P_(m+1) through P_n.

        * P is a pattern datum (any nonlist, nonvector, nonsymbol datum)
          and F is equal to P in the sense of the 'equal?' procedure.

     A 'syntax-case' expression first evaluates ?EXPRESSION.  It then
     attempts to match the ?PATTERN from the first ?SYNTAX-CASE-CLAUSE
     against the resulting value, which is unwrapped as necessary to
     perform the match.  If the pattern matches the value and no ?FENDER
     is present, ?OUTPUT-EXPRESSION is evaluated and its value returned
     as the value of the 'syntax-case' expression.  If the pattern does
     not match the value, 'syntax-case' tries the second
     ?SYNTAX-CASE-CLAUSE, then the third, and so on.  It is a syntax
     violation if the value does not match any of the patterns.

     If the optional ?FENDER is present, it serves as an additional
     constraint on acceptance of a clause.  If the ?PATTERN of a given
     ?SYNTAX-CASE-CLAUSE matches the input value, the corresponding
     ?FENDER is evaluated.  If ?FENDER evaluates to a true value, the
     clause is accepted; otherwise, the clause is rejected as if the
     pattern had failed to match the value.  Fenders are logically a
     part of the matching process, i.e., they specify additional
     matching constraints beyond the basic structure of the input.

     Pattern variables contained within a clause's ?PATTERN are bound to
     the corresponding pieces of the input value within the clause's
     ?FENDER (if present) and ?OUTPUT-EXPRESSION.  Pattern variables can
     be referenced only within 'syntax' expressions (see below).
     Pattern variables occupy the same name space as program variables
     and keywords.

     If the 'syntax-case' form is in tail context, the
     ?OUTPUT-EXPRESSIONs are also in tail position.

 -- Syntax: syntax ?TEMPLATE
     A 'syntax' expression is similar to a 'quote' expression except
     that:

       1. The values of pattern variables appearing within ?TEMPLATE are
          inserted into ?TEMPLATE.

       2. Contextual information associated both with the input and with
          the template is retained in the output to support lexical
          scoping.

       3. The value of a 'syntax' expression is a syntax object.

     The following sharp-quote expression:

          #'?TEMPLATE

     is equivalent to:

          (syntax ?TEMPLATE)

     *note scheme lex datum abbreviations:: for the other abbreviations.

     A ?TEMPLATE can be one among: a pattern variable, an identifier
     that is not a pattern variable, a pattern datum, or one of the
     following.

          (?SUBTEMPLATE ...)
          (?SUBTEMPLATE ... . ?TEMPLATE)
          #(?SUBTEMPLATE ...)

     A ?SUBTEMPLATE is a ?TEMPLATE followed by zero or more ellipses.

     The value of a 'syntax' form is a copy of ?TEMPLATE in which the
     pattern variables appearing within the template are replaced with
     the input subforms to which they are bound:

        * Pattern data and identifiers that are not pattern variables or
          ellipses are copied directly into the output.

        * A subtemplate followed by an ellipsis expands into zero or
          more occurrences of the subtemplate.

        * Pattern variables that occur in subpatterns followed by one or
          more ellipses may occur only in subtemplates that are followed
          by (at least) as many ellipses:

             - These pattern variables are replaced in the output by the
               input subforms to which they are bound, distributed as
               specified.

             - If a pattern variable is followed by more ellipses in the
               subtemplate than in the associated subpattern, the input
               form is replicated as necessary.

             - The subtemplate must contain at least one pattern
               variable from a subpattern followed by an ellipsis, and
               for at least one such pattern variable, the subtemplate
               must be followed by exactly as many ellipses as the
               subpattern in which the pattern variable appears
               (otherwise, the expander would not be able to determine
               how many times the subform should be repeated in the
               output).

     It is a syntax violation if the above constraints are not met.

     A template of the form '(?ELLIPSIS ?TEMPLATE)' is identical to
     ?TEMPLATE, except that ellipses within the template have no special
     meaning.  That is, any ellipses contained within ?TEMPLATE are
     treated as ordinary identifiers.  In particular, the template '(...
     ...)' produces a single ellipsis.  This allows macro uses to expand
     into forms containing ellipses.

     The output produced by 'syntax' is wrapped or unwrapped according
     to the following rules:

        * The copy of '(?T1 . ?T2)' is a pair if ?T1 or ?T2 contain any
          pattern variables.

        * The copy of '(?T ?ELLIPSIS)' is a list if ?T contains any
          pattern variables.

        * The copy of '#(?T1 ... ?TN)' is a vector if any of ?T1, ...,
          ?TN contain any pattern variables.

        * The copy of any portion of ?T not containing any pattern
          variables is a wrapped syntax object.

     The input subforms inserted in place of the pattern variables are
     wrapped if and only if the corresponding input subforms are
     wrapped.

   The following definitions of 'or' illustrate 'syntax-case' and
'syntax'; the second is equivalent to the first but uses the sharp-quote
prefix instead of the full 'syntax' form:

     (define-syntax or
       (lambda (x)
         (syntax-case x ()
           ((_)
            (syntax #f))
           ((_ e)
            (syntax e))
           ((_ e1 e2 e3 ...)
            (syntax (let ((t e1))
                      (if t t (or e2 e3 ...))))))))

     (define-syntax or
       (lambda (x)
         (syntax-case x ()
           ((_)
            #'#f)
           ((_ e)
            #'e)
           ((_ e1 e2 e3 ...)
            #'(let ((t e1))
                (if t t (or e2 e3 ...)))))))

   The examples below define "identifier macros", macro uses supporting
keyword references that do not necessarily appear in the first position
of a list-structured form; the second example uses
'make-variable-transformer' to handle the case where the keyword appears
on the left-hand side of a 'set!' expression:

     (define p (cons 4 5))
     (define-syntax p.car
       (lambda (x)
         (syntax-case x ()

           ((_ . rest)
            #'((car p) . rest))

           (_
            #'(car p)))))

     p.car                   => 4
     (set! p.car 15)         error-> exception &syntax

     (define p (cons 4 5))
     (define-syntax p.car
       (make-variable-transformer
         (lambda (x)
           (syntax-case x (set!)

             ((set! _ e)
              #'(set-car! p e))

             ((_ . rest)
              #'((car p) . rest))

             (_
              #'(car p))))))

     (set! p.car 15)

     p.car                   => 15
     p                       => (15 . 5)

   Any 'syntax-rules' form can be expressed with 'syntax-case' by making
the 'lambda' expression and 'syntax' expressions explicit, and
'syntax-rules' may be defined in terms of 'syntax-case' as follows.

     (define-syntax syntax-rules
       (lambda (x)
         (syntax-case x ()
           ((_ (lit ...) ((k . p) t) ...)
            (for-all identifier? #'(lit ... k ...))
            #'(lambda (x)
                (syntax-case x (lit ...)
                  ((_ . p) #'t) ...))))))

   The 'identifier-syntax' form of the base library (*note baselib
transformers::) may be defined in terms of 'syntax-case', 'syntax', and
'make-variable-transformer' as follows.

     (define-syntax identifier-syntax
       (syntax-rules (set!)
         ((_ e)
          (lambda (x)
            (syntax-case x ()
              (id (identifier? #'id) #'e)
              ((_ x (... ...)) #'(e x (... ...))))))
         ((_ (id exp1) ((set! var val) exp2))
          (and (identifier? #'id) (identifier? #'var))
          (make-variable-transformer
            (lambda (x)
              (syntax-case x (set!)
                ((set! var val) #'exp2)
                ((id x (... ...)) #'(exp1 x (... ...)))
                (id (identifier? #'id) #'exp1)))))))


File: vicare-scheme.info,  Node: stdlib syntax-case identifier,  Next: stdlib syntax-case conversion,  Prev: stdlib syntax-case parsing,  Up: stdlib syntax-case

5.12.6 Identifier predicates
----------------------------

Identifiers are a basic concept of hygienic macro expansion: it is
possible to write macros with confidence only with a through
understanding of identifiers.  Let's analyse a simple form, which we can
imagine (for now) to appear at the top level of a program body:

     (let ((alpha 123))
       alpha)

in it appear two distinct Scheme symbols: 'let' once, 'alpha' twice;
none of them appears in a quoted form, so all of them are identifiers.
We have to acknowledge that the number of distinct identifiers is three;
the two instances of 'alpha' are *different* identifiers.

   Moreover, the first instance of 'alpha' appears at the left side of a
?BINDINGS element of the 'let' syntax, so it is said to be in "binding
position"; the second instance does not appear in a binding position, so
it is said to be in "reference position".  *note Binding constructs:
baselib expressions binding.

     *NOTE* In the following descriptions, the procedure arguments with
     name ID are meant to be syntax objects, each holding only an
     identifier.

 -- Procedure: identifier? OBJ
     Return '#t' if OBJ is an identifier, i.e., a syntax object
     representing an identifier, and '#f' otherwise.

     The 'identifier?' procedure is often used within a fender to verify
     that certain subforms of an input form are identifiers, as in the
     definition of 'rec', which creates self-contained recursive
     objects, below.

          (define-syntax rec
            (lambda (x)
              (syntax-case x ()
                ((_ x e)
                 (identifier? #'x)
                 #'(letrec ((x e)) x)))))

          (map (rec fact
                 (lambda (n)
                   (if (= n 0)
                       1
                       (* n (fact (- n 1))))))
               '(1 2 3 4 5))
          => (1 2 6 24 120)

          (rec 5 (lambda (x) x))
          error-> exception &syntax

   The procedures 'bound-identifier=?' and 'free-identifier=?' each take
two identifier arguments and return '#t' if their arguments are
equivalent and '#f' otherwise.  These predicates are used to compare
identifiers according to their _intended use_ as free references or
bound identifiers in a given context.

 -- Procedure: bound-identifier=? ID1 ID2
     Return '#t' if a binding for one would capture a reference to the
     other in the output of the transformer, assuming that the reference
     appears within the scope of the binding; return '#f' otherwise.

     In general, two identifiers are 'bound-identifier=?' only if both
     are present in the original program or both are introduced by the
     same transformer application (perhaps implicitly, see
     'datum->syntax').

     Operationally, two identifiers are considered equivalent by
     'bound-identifier=?' if and only if they have the same name and the
     same marks.

     The 'bound-identifier=?' procedure can be used for detecting
     duplicate identifiers in a binding construct or for other
     preprocessing of a binding construct that requires detecting
     instances of the bound identifiers.

     For example, let's consider this macro:

          (define-syntax doit
            (lambda (stx)
              (syntax-case stx ()
                ((_ id1 id2)
                 (begin
                   (display (bound-identifier=? #'id1 #'id2))
                   #'(let ((id1 123)) id2))))))

     in the following macro use the identifiers are
     'bound-identifier=?':

          (doit alpha alpha)
          => 123
          -| #t

     because binding one in the output form of the macro use, "captures"
     the reference of the other one; in the following macro use the
     identifiers are not 'bound-identifier=?':

          (let ((beta 456))
            (doit alpha beta))
          => 456
          -| #f

     because binding one does not capture the reference of the other.

 -- Procedure: free-identifier=? ID1 ID2
     Return '#t' if and only if the two identifiers would resolve to the
     same binding if both were to appear in the output of a transformer,
     outside of any bindings inserted by the transformer.  Here is an
     example showing that it is the origin of the bindings that matters,
     not the actual symbol in the identifier:

          (import (rnrs)
            (prefix (only (rnrs) vector) that:))

          (define-syntax doit
            (lambda (stx)
              (syntax-case stx ()
                ((_ id1 id2)
                 (begin
                   (display (free-identifier=? #'id1 #'id2))
                   #f)))))

          (doit vector that:vector)
          -| #t

     If neither of two like-named identifiers resolves to a binding,
     i.e., both are unbound, they are considered to resolve to the same
     binding; example:

          (import (rnrs))

          (define-syntax doit
            (lambda (stx)
              (syntax-case stx ()
                ((_ id1 id2)
                 (begin
                   (display (free-identifier=? #'id1 #'id2))
                   #f)))))

          ;; ALPHA and BETA are unbound here

          (doit alpha alpha)
          -| #t

          (doit alpha beta)
          -| #f

     Operationally, two identifiers are considered equivalent by
     'free-identifier=?' if and only if: the topmost matching
     substitution for each maps to the same binding or the identifiers
     have the same name and no matching substitution.  Let's consider
     this program:

          (import (rnrs))
          (let ((alpha 123))
            (list alpha alpha))

     if we substitute 'alpha' with 'beta' in the 'let' form:

          (import (rnrs))
          (let ((beta 123))
            (list beta beta))

     we obtain an equivalent program; this is because the two 'alpha'
     identifiers in the 'list' form of the original program are
     'free-identifier=?'.

     As last examples, notice that in the following program:

          (import (rnrs))

          (let ((alpha 123))
            (define beta alpha)
            (list alpha beta))

     'alpha' and 'beta' in the 'list' form are *not*
     'free-identifiers=?'; in the following program:

          (import (rnrs))

          (let ((alpha 123))
            (let-syntax ((beta (identifier-syntax alpha)))
              (list alpha beta)))

     'alpha' and 'beta' in the 'list' form are still *not*
     'free-identifiers=?'.

   The 'syntax-case' and 'syntax-rules' forms internally use
'free-identifier=?' to compare identifiers listed in the literals list
against input identifiers:

     (let ((fred 17))
       (define-syntax a
         (lambda (x)
           (syntax-case x ()
             ((_ id) #'(b id fred)))))
       (define-syntax b
         (lambda (x)
           (syntax-case x ()
             ((_ id1 id2)
              #`(list
                  #,(free-identifier=? #'id1 #'id2)
                  #,(bound-identifier=? #'id1 #'id2))))))
       (a fred))
     => (#t #f)

   The following definition of unnamed 'let' uses 'bound-identifier=?'
to detect duplicate identifiers:

     (define-syntax let
       (lambda (x)
         (define (unique-ids? ls)
           (or (null? ls)
               (and (let notmem? ((x  (car ls))
                                  (ls (cdr ls)))
                      (or (null? ls)
                          (and (not (bound-identifier=? x (car ls)))
                               (notmem? x (cdr ls)))))
                    (unique-ids? (cdr ls)))))
         (syntax-case x ()
           ((_ ((i v) ...) e1 e2 ...)
            (unique-ids? #'(i ...))
            #'((lambda (i ...) e1 e2 ...) v ...)))))

the argument '#'(i ...)' to 'unique-ids?' is guaranteed to be a list by
the rules given in the description of 'syntax'.

   With this definition of 'let':

     (let ((a 3) (a 4))
       (+ a a))
     error-> exception &syntax

however:

     (let-syntax
         ((dolet (lambda (x)
                   (syntax-case x ()
                     ((_ b)
                      #'(let ((a 3) (b 4)) (+ a b)))))))
       (dolet a))
     => 7

since the identifier 'a' introduced by 'dolet' and the identifier 'a'
extracted from the input form are not 'bound-identifier=?'.

   Rather than including 'else' in the literals list as before, this
version of 'case' explicitly tests for 'else' using 'free-identifier=?'.

     (define-syntax case
       (lambda (x)
         (syntax-case x ()
           ((_ e0 ((k ...) e1 e2 ...) ...
                   (else-key else-e1 else-e2 ...))
            (and (identifier? #'else-key)
                 (free-identifier=? #'else-key #'else))
            #'(let ((t e0))
                (cond
                  ((memv t '(k ...)) e1 e2 ...)
                  ...
                  (else else-e1 else-e2 ...))))
           ((_ e0 ((ka ...) e1a e2a ...)
                   ((kb ...) e1b e2b ...) ...)
            #'(let ((t e0))
                (cond
                  ((memv t '(ka ...)) e1a e2a ...)
                  ((memv t '(kb ...)) e1b e2b ...)
                  ...))))))

   With either definition of 'case', 'else' is not recognized as an
auxiliary keyword if an enclosing lexical binding for 'else' exists.
For example,

     (let ((else #f))
       (case 0 (else (write "oops"))))
     error-> exception &syntax

since 'else' is bound lexically and is therefore not the same 'else'
that appears in the definition of 'case'.


File: vicare-scheme.info,  Node: stdlib syntax-case conversion,  Next: stdlib syntax-case temporaries,  Prev: stdlib syntax-case identifier,  Up: stdlib syntax-case

5.12.7 Syntax-object and datum conversions
------------------------------------------

 -- Procedure: syntax->datum SYNTAX-OBJECT
     Strip all syntactic information from a syntax object and returns
     the corresponding Scheme datum.

     Identifiers stripped in this manner are converted to their symbolic
     names, which can then be compared with 'eq?'.  Thus, a predicate
     'symbolic-identifier=?' might be defined as follows.

          (define (symbolic-identifier=? x y)
            (eq? (syntax->datum x)
                 (syntax->datum y)))

 -- Procedure: datum->syntax TEMPLATE-ID DATUM
     TEMPLATE-ID must be a template identifier and DATUM should be a
     datum value.

     The 'datum->syntax' procedure returns a syntax-object
     representation of DATUM that contains the same contextual
     information as TEMPLATE-ID, with the effect that the syntax object
     behaves as if it were introduced into the code when TEMPLATE-ID was
     introduced.

     The 'datum->syntax' procedure allows a transformer to "bend"
     lexical scoping rules by creating _implicit identifiers_ that
     behave as if they were present in the input form, thus permitting
     the definition of macros that introduce visible bindings for, or
     references to, identifiers that do not appear explicitly in the
     input form.

   In the following example, 'green' and 'red' have the role of
TEMPLATE-ID in the 'alpha' and 'beta' macro uses at the end of the
'(test)' library:

     (library (lib)
       (export beta red)
       (import (rnrs))

       (define red  #t)
       (define data 'in-lib)

       (define-syntax beta
         (lambda (stx)
           (syntax-case stx ()
             ((_ ?context)
              #`(begin #,(datum->syntax #'?context 'data)))))))

     (library (test)
       (export)
       (import (rnrs) (lib))

       (define green #t)
       (define data  'in-test)

       (define-syntax alpha
         (lambda (stx)
           (syntax-case stx ()
             ((_ ?context)
              #`(begin #,(datum->syntax #'?context 'data))))))

       (display (alpha green))       -| in-test
       (display (alpha red))         -| in-test
       (display (beta  green))       -| in-test
       (display (beta  red)))        -| in-test

in both the macro uses: the identifier syntax objects representing
'green' and 'red' are created in the '(test)' library, so both the
macros reach for 'data' in the context of the '(test)' library.

   The following example demonstrates why, when macro uses are nested,
we cannot rely on the macro keyword syntax object to carry the context
of the "outer" macro use:

     (library (sublib)
       (export beta)
       (import (rnrs))
       (define data 33)
       (define-syntax beta
         (lambda (stx)
           (syntax-case stx ()
             ((?context)
              #`(begin #,(datum->syntax #'?context 'data)))))))

     (library (lib)
       (export alpha)
       (import (rnrs) (sublib))
       (define data 22)
       (define-syntax alpha
         (lambda (stx)
           (syntax-case stx ()
             ((_)
              #'(beta))))))

     (library (test)
       (export)
       (import (rnrs) (lib))
       (define data 11)
       (display (alpha))) -| 22

in the body of the 'beta' macro: '?context' is bound to a syntax object
carrying reference to the lexical context of the body of 'alpha'; from
the body of 'beta' it is impossible to reach the lexical context of the
'(test)' library, where 'alpha' is used.

   The following example defines a 'loop' expression that uses this
controlled form of identifier capture to bind the variable 'break' to an
escape procedure within the loop body.  (The derived 'with-syntax' form
is like 'let' but binds pattern variables.)

     (import (rnrs))

     (define-syntax loop
       (lambda (x)
         (syntax-case x ()
           ((k e ...)
            (with-syntax ((break (datum->syntax #'k 'break)))
              #'(call-with-current-continuation
                  (lambda (break)
                    (let f () e ... (f)))))))))

     (let ((n 3) (ls '()))
       (loop
         (when (= n 0)
           (break ls))
         (set! ls (cons 'a ls))
         (set! n (- n 1))))
     => (a a a)

   Were 'loop' to be defined as:

     (define-syntax loop
       (lambda (x)
         (syntax-case x ()
           ((_ e ...)
            #'(call-with-current-continuation
                (lambda (break)
                  (let f () e ... (f))))))))

the variable 'break' would not be visible in 'e ...'.

   The datum argument DATUM may also represent an arbitrary Scheme form,
as demonstrated by the following definition of 'include'.

     (define-syntax include
       (lambda (x)

         (define (read-file fn k)
           (let ((p (open-file-input-port fn)))
             (let loop ((x (get-datum p)))
               (if (eof-object? x)
                   (begin
                     (close-port p)
                     '())
                 (cons (datum->syntax k x)
                       (loop (get-datum p)))))))

         (syntax-case x ()
           ((k filename)
            (let ((fn (syntax->datum #'filename)))
              (with-syntax (((exp ...) (read-file fn #'k)))
                #'(begin exp ...)))))))

'(include "filename")' expands into a 'begin' expression containing the
forms found in the file named by '"filename"'.  For example, if the file
'flib.ss' contains:

     (define f (lambda (x) (g (* x x))))

and the file 'glib.ss' contains:

     (define g (lambda (x) (+ x x)))

the expression:

     (let ()
       (include "flib.ss")
       (include "glib.ss")
       (f 5))

evaluates to 50.

   The definition of 'include' uses 'datum->syntax' to convert the
objects read from the file into syntax objects in the proper lexical
context, so that identifier references and definitions within those
expressions are scoped where the 'include' form appears.


File: vicare-scheme.info,  Node: stdlib syntax-case temporaries,  Next: stdlib syntax-case derived,  Prev: stdlib syntax-case conversion,  Up: stdlib syntax-case

5.12.8 Generating lists of temporaries
--------------------------------------

Transformers can introduce a fixed number of identifiers into their
output simply by naming each identifier.  In some cases, however, the
number of identifiers to be introduced depends upon some characteristic
of the input expression.  A straightforward definition of 'letrec', for
example, requires as many temporary identifiers as there are binding
pairs in the input expression.  The procedure 'generate-temporaries' is
used to construct lists of temporary identifiers.

 -- Procedure: generate-temporaries L
     L must be be a list or syntax object representing a list-structured
     form; its contents are not important.

     The number of temporaries generated is the number of elements in L.
     Each temporary is guaranteed to be unique, i.e., different from all
     other identifiers.

     A definition of 'letrec' equivalent to the one using 'syntax-rules'
     given in *note scheme derived:: is shown below.

          (define-syntax letrec
            (lambda (x)
              (syntax-case x ()
                ((_ ((i e) ...) b1 b2 ...)
                 (with-syntax (((T ...)
                                (generate-temporaries #'(i ...))))
                   #'(let ((i #f) ...)
                       (let ((T e) ...)
                         (set! i T) ...
                         (let () b1 b2 ...))))))))

     This version uses 'generate-temporaries' instead of recursively
     defined helper to generate the necessary temporaries.


File: vicare-scheme.info,  Node: stdlib syntax-case derived,  Next: stdlib syntax-case violations,  Prev: stdlib syntax-case temporaries,  Up: stdlib syntax-case

5.12.9 Derived forms and procedures
-----------------------------------

The forms and procedures described in this section can be defined in
terms of the forms and procedures described in earlier sections of this
chapter.

 -- Syntax: with-syntax ((?PATTERN ?EXPRESSION) ...) ?BODY
     The 'with-syntax' form is used to bind pattern variables, just as
     'let' is used to bind variables.  This allows a transformer to
     construct its output in separate pieces, then put the pieces
     together.

     Each ?PATTERN is identical in form to a 'syntax-case' pattern.  The
     value of each ?EXPRESSION is computed and destructured according to
     the corresponding ?PATTERN, and pattern variables within the
     ?PATTERN are bound as with 'syntax-case' to the corresponding
     portions of the value within ?BODY.

     The 'with-syntax' form may be defined in terms of 'syntax-case' as
     follows.

          (define-syntax with-syntax
            (lambda (x)
              (syntax-case x ()
                ((_ ((p e0) ...) e1 e2 ...)
                 (syntax (syntax-case (list e0 ...) ()
                           ((p ...) (let () e1 e2 ...))))))))

     As example of deconstructing a syntax object:

          (define stx
            (datum->syntax #'display '(1 2 3)))

          (with-syntax (((a b ...) stx))
            (syntax->datum #'a))
          => 1

     The following definition of 'cond' demonstrates the use of
     'with-syntax' to support transformers that employ recursion
     internally to construct their output.  It handles all 'cond' clause
     variations and takes care to produce one-armed 'if' expressions
     where appropriate.

          (define-syntax cond
            (lambda (x)
              (syntax-case x ()
                ((_ c1 c2 ...)
                 (let f ((c1 #'c1) (c2* #'(c2 ...)))
                   (syntax-case c2* ()
                     (()
                      (syntax-case c1 (else =>)
                        ((else e1 e2 ...) #'(begin e1 e2 ...))
                        ((e0) #'e0)
                        ((e0 => e1)
                         #'(let ((t e0)) (if t (e1 t))))
                        ((e0 e1 e2 ...)
                         #'(if e0 (begin e1 e2 ...)))))
                     ((c2 c3 ...)
                      (with-syntax ((rest (f #'c2 #'(c3 ...))))
                        (syntax-case c1 (=>)
                          ((e0) #'(let ((t e0)) (if t t rest)))
                          ((e0 => e1)
                           #'(let ((t e0)) (if t (e1 t) rest)))
                          ((e0 e1 e2 ...)
                           #'(if e0
                                 (begin e1 e2 ...)
                               rest)))))))))))

 -- Syntax: quasisyntax ?TEMPLATE
 -- Auxiliary Syntax: unsyntax
 -- Auxiliary Syntax: unsyntax-splicing
     The 'quasisyntax' form is similar to 'syntax', but it allows parts
     of the quoted text to be evaluated, in a manner similar to the
     operation of 'quasiquote' (*note baselib quasiquotation::).

     Within a 'quasisyntax' TEMPLATE, subforms of 'unsyntax' and
     'unsyntax-splicing' forms are evaluated, and everything else is
     treated as ordinary template material, as with 'syntax'.

     The value of each 'unsyntax' subform is inserted into the output in
     place of the 'unsyntax' form, while the value of each
     'unsyntax-splicing' subform is spliced into the surrounding list or
     vector structure.  Uses of 'unsyntax' and 'unsyntax-splicing' are
     valid only within 'quasisyntax' expressions.

     A 'quasisyntax' expression may be nested, with each 'quasisyntax'
     introducing a new level of syntax quotation and each 'unsyntax' or
     'unsyntax-splicing' taking away a level of quotation.  An
     expression nested within n 'quasisyntax' expressions must be within
     n 'unsyntax' or 'unsyntax-splicing' expressions to be evaluated.

     As noted in *note scheme lex datum abbreviations:::

          #`?TEMPLATE   == (quasisyntax ?TEMPLATE)
          #,?TEMPLATE   == (unsyntax ?TEMPLATE)
          #,@?TEMPLATE  == (unsyntax-splicing ?TEMPLATE)

     The 'quasisyntax' keyword can be used in place of 'with-syntax' in
     many cases.  For example, the definition of 'case' shown under the
     description of 'with-syntax' above can be rewritten using
     'quasisyntax' as follows.

          (define-syntax case
            (lambda (x)
              (syntax-case x ()
                ((_ e c1 c2 ...)
                 #`(let ((t e))
                     #,(let f ((c1 #'c1) (cmore #'(c2 ...)))
                         (if (null? cmore)
                             (syntax-case c1 (else)
                               ((else e1 e2 ...)
                                #'(begin e1 e2 ...))
                               (((k ...) e1 e2 ...)
                                #'(when (memv t '(k ...))
                                    (begin e1 e2 ...))))
                             (syntax-case c1 ()
                               (((k ...) e1 e2 ...)
                                #`(if (memv t '(k ...))
                                      (begin e1 e2 ...)
                                    #,(f (car cmore)
                                         (cdr cmore))))))))))))

     Uses of 'unsyntax' and 'unsyntax-splicing' with zero or more than
     one subform are valid only in splicing (list or vector) contexts.
     '(unsyntax TEMPLATE ...)' is equivalent to '(unsyntax TEMPLATE)
     ...', and '(unsyntax-splicing TEMPLATE ...)' is equivalent to
     '(unsyntax-splicing TEMPLATE) ...'.  These forms are primarily
     useful as intermediate forms in the output of the 'quasisyntax'
     expander.

          *NOTE* Uses of 'unsyntax' and 'unsyntax-splicing' with zero or
          more than one subform enable certain idioms, such as '#,@#,@',
          which has the effect of a doubly indirect splicing when used
          within a doubly nested and doubly evaluated 'quasisyntax'
          expression, as with the nested 'quasiquote' examples shown in
          section *note baselib quasiquotation::.


File: vicare-scheme.info,  Node: stdlib syntax-case violations,  Next: stdlib syntax-case lisp,  Prev: stdlib syntax-case derived,  Up: stdlib syntax-case

5.12.10 Syntax violations
-------------------------

 -- Procedure: syntax-violation WHO MESSAGE FORM
 -- Procedure: syntax-violation WHO MESSAGE FORM SUBFORM
     WHO must be '#f' or a string or a symbol.  MESSAGE must be a
     string.  FORM must be a syntax object or a datum value.  SUBFORM
     must be a syntax object or a datum value.

     The 'syntax-violation' procedure raises an exception, reporting a
     syntax violation.  WHO should describe the macro transformer that
     detected the exception.  The MESSAGE argument should describe the
     violation.  FORM should be the erroneous source syntax object or a
     datum value representing a form.  The optional SUBFORM argument
     should be a syntax object or datum value representing a form that
     more precisely locates the violation.

     If WHO is '#f', 'syntax-violation' attempts to infer an appropriate
     value for the condition object (see below) as follows: When FORM is
     either an identifier or a list-structured syntax object containing
     an identifier as its first element, then the inferred value is the
     identifier's symbol.  Otherwise, no value for WHO is provided as
     part of the condition object.

     The condition object provided with the exception has the following
     condition types:

        * If WHO is not '#f' or can be inferred, the condition has
          condition type '&who', with WHO as the value of its field.  In
          that case, WHO should identify the procedure or entity that
          detected the exception.  If it is '#f', the condition does not
          have condition type '&who'.

        * The condition has condition type '&message', with MESSAGE as
          the value of its field.

        * The condition has condition type '&syntax' with FORM and
          SUBFORM as the value of its fields.  If SUBFORM is not
          provided, the value of the subform field is '#f'.


File: vicare-scheme.info,  Node: stdlib syntax-case lisp,  Prev: stdlib syntax-case violations,  Up: stdlib syntax-case

5.12.11 Common Lisp style macros
--------------------------------

Using 'datum->syntax', it is even possible to break hygiene entirely and
write macros in the style of old Lisp macros.  The 'lisp-transformer'
procedure defined below creates a transformer that converts its input
into a datum, calls the programmer's procedure on this datum, and
converts the result back into a syntax object scoped where the original
macro use appeared:

     (define (lisp-transformer proc)
       (lambda (stx)
         (syntax-case stx ()
           ((key . rest)
            (datum->syntax #'key (proc (syntax->datum stx)))))))

   This transformer can be used as follows, first create a library with
the definition in it:

     (library (lisp-trans)
       (export lisp-transformer)
       (import (rnrs))

       (define (lisp-transformer proc)
         (lambda (stx)
           (syntax-case stx ()
             ((key . rest)
              (datum->syntax #'key (proc (syntax->datum stx))))))))

then import the library for the 'expand' phase; the following example
shows what is handed to the client procedure:

     (import (rnrs)
       (for (lisp-trans) expand))

     (define-syntax print-it
       (lisp-transformer (lambda (thing)
                           (write thing)
                           (newline)
                           #f)))

     (print-it (1 2 3))
     -| (print-it (1 2 3))

notice that the macro use prints the value of THING, then returns '#f'
which is evaulated in place of the macro use and the result is '#f'
itself.

   Now we shold understand the following:

     (import (rnrs)
       (for (lisp-trans) expand))

     (define-syntax even
       (lisp-transformer
         (lambda (thing)
           `(begin
              (write (quote ,(map even? (cadr thing))))
              (newline)))))

     (even (1 2 3))
     -| (#f #t #f)

the macro use '(even (1 2 3))' is equivalent to:

     (begin
       (write (quote (#f #t #f)))
       (newline))

that is, the form returned by the client procedure is evaluated in place
of the macro use.


File: vicare-scheme.info,  Node: stdlib hashtable,  Next: stdlib enum,  Prev: stdlib syntax-case,  Up: stdlib

5.13 Hashtables
===============

The '(rnrs hashtables (6))' library provides a set of operations on
hashtables.

   A _hashtable_ is a data structure that associates keys with values.
Any object can be used as a key, provided a _hash function_ and a
suitable _equivalence function_ is available.

   A hash function is a procedure that maps keys to exact integer
objects.  It is the programmer's responsibility to ensure that the hash
function is compatible with the equivalence function, which is a
procedure that accepts two keys and returns true if they are equivalent
and '#f' otherwise.

   Standard hashtables for arbitrary objects based on the 'eq?' and
'eqv?' predicates (*note baselib predicates::) are provided.  Also, hash
functions for arbitrary objects, strings, and symbols are provided.

   This section uses the HASHTABLE parameter name for arguments that
must be hashtables, and the KEY parameter name for arguments that must
be hashtable keys.

* Menu:

* stdlib hashtable constructors::       Constructors.
* stdlib hashtable procedures::         Procedures.
* stdlib hashtable inspection::         Inspection.
* stdlib hashtable hash functions::     Hash functions.


File: vicare-scheme.info,  Node: stdlib hashtable constructors,  Next: stdlib hashtable procedures,  Up: stdlib hashtable

5.13.1 Constructors
-------------------

 -- Procedure: make-eq-hashtable
 -- Procedure: make-eq-hashtable K
     Return a newly allocated mutable hashtable that accepts arbitrary
     objects as keys, and compares those keys with 'eq?'.  If an
     argument is given, the initial capacity of the hashtable is set to
     approximately K elements.

 -- Procedure: make-eqv-hashtable
 -- Procedure: make-eqv-hashtable K
     Return a newly allocated mutable hashtable that accepts arbitrary
     objects as keys, and compares those keys with 'eqv?'.  If an
     argument is given, the initial capacity of the hashtable is set to
     approximately K elements.

 -- Procedure: make-hashtable HASH-FUNCTION EQUIV
 -- Procedure: make-hashtable HASH-FUNCTION EQUIV K
     HASH-FUNCTION and EQUIV must be procedures.  HASH-FUNCTION should
     accept a key as an argument and should return a non-negative exact
     integer object.  EQUIV should accept two keys as arguments and
     return a single value.  Neither procedure should mutate the
     hashtable returned by 'make-hashtable'.

     The 'make-hashtable' procedure returns a newly allocated mutable
     hashtable using HASH-FUNCTION as the hash function and EQUIV as the
     equivalence function used to compare keys.  If a third argument is
     given, the initial capacity of the hashtable is set to
     approximately K elements.

     Both HASH-FUNCTION and EQUIV should behave like pure functions on
     the domain of keys.  For example, the 'string-hash' and 'string=?'
     procedures are permissible only if all keys are strings and the
     contents of those strings are never changed so long as any of them
     continues to serve as a key in the hashtable.  Furthermore, any
     pair of keys for which EQUIV returns true should be hashed to the
     same exact integer objects by HASH-FUNCTION.

     *Implementation responsibilities:* The implementation must check
     the restrictions on HASH-FUNCTION and EQUIV to the extent performed
     by applying them as described.

          *NOTE* Hashtables are allowed to cache the results of calling
          the hash function and equivalence function, so programs cannot
          rely on the hash function being called for every lookup or
          update.  Furthermore any hashtable operation may call the hash
          function more than once.


File: vicare-scheme.info,  Node: stdlib hashtable procedures,  Next: stdlib hashtable inspection,  Prev: stdlib hashtable constructors,  Up: stdlib hashtable

5.13.2 Procedures
-----------------

 -- Procedure: hashtable? OBJ
     Return '#t' if OBJ is a hashtable, '#f' otherwise.

 -- Procedure: hashtable-size HASHTABLE
     Return the number of keys contained in HASHTABLE as an exact
     integer object.

 -- Procedure: hashtable-ref HASHTABLE KEY
 -- Procedure: hashtable-ref HASHTABLE KEY DEFAULT
     Return the value in HASHTABLE associated with KEY.  If HASHTABLE
     does not contain an association for KEY, DEFAULT is returned.

          As Vicare extension: when DEFAULT is not used, it defaults to
          the sentinel object.  When in doubt: we should always use the
          sentinel object as DEFAULT argument.  *Note The sentinel
          object: iklib sentinel.

 -- Procedure: hashtable-set! HASHTABLE KEY OBJ
     Change HASHTABLE to associate KEY with OBJ, adding a new
     association or replacing any existing association for KEY, and
     returns unspecified values.

     As Vicare extension: if OBJ is '(void)' an exception is raised with
     condition object type '&procedure-argument-violation'; the void
     value is to be used as sentinel value for hash tables.

 -- Procedure: hashtable-delete! HASHTABLE KEY
     Remove any association for KEY within HASHTABLE; if there is no
     association for KEY: do nothing.

     As Vicare extension return two values:

        * If an association is found: the original key and value.

        * If no association is found: '#f' and '#f'.

 -- Procedure: hashtable-contains? HASHTABLE KEY
     Return '#t' if HASHTABLE contains an association for KEY, '#f'
     otherwise.

 -- Procedure: hashtable-update! HASHTABLE KEY PROC DEFAULT
     PROC should accept one argument, should return a single value, and
     should not mutate HASHTABLE.

     The 'hashtable-update!' procedure applies PROC to the value in
     HASHTABLE associated with KEY, or to DEFAULT if HASHTABLE does not
     contain an association for KEY.  The HASHTABLE is then changed to
     associate KEY with the value returned by PROC.

     The behavior of 'hashtable-update!' is equivalent to the following
     code, but may be implemented more efficiently in cases where the
     implementation can avoid multiple lookups of the same key:

          (hashtable-set!
            hashtable key
            (proc (hashtable-ref
                   hashtable key default)))

 -- Procedure: hashtable-copy HASHTABLE
 -- Procedure: hashtable-copy HASHTABLE MUTABLE
     Return a copy of HASHTABLE.  If the MUTABLE argument is provided
     and is true, the returned hashtable is mutable; otherwise it is
     immutable.

 -- Procedure: hashtable-clear! HASHTABLE
 -- Procedure: hashtable-clear! HASHTABLE K
     Remove all associations from HASHTABLE and returns unspecified
     values.

     If a second argument is given, the current capacity of the
     hashtable is reset to approximately K elements.

 -- Procedure: hashtable-keys HASHTABLE
     Return a vector of all keys in HASHTABLE.  The order of the vector
     is unspecified.

 -- Procedure: hashtable-entries HASHTABLE
     Return two values, a vector of the keys in HASHTABLE, and a vector
     of the corresponding values.

     Example:

          (let ((h (make-eqv-hashtable)))
            (hashtable-set! h 1 'one)
            (hashtable-set! h 2 'two)
            (hashtable-set! h 3 'three)
            (hashtable-entries h))
          => #(1 2 3) #(one two three) ; two return values

     the order of the entries in the result vectors is not known.


File: vicare-scheme.info,  Node: stdlib hashtable inspection,  Next: stdlib hashtable hash functions,  Prev: stdlib hashtable procedures,  Up: stdlib hashtable

5.13.3 Inspection
-----------------

 -- Procedure: hashtable-equivalence-function HASHTABLE
     Return the equivalence function used by HASHTABLE to compare keys.
     For hashtables created with 'make-eq-hashtable' and
     'make-eqv-hashtable', returns 'eq?' and 'eqv?' respectively.

 -- Procedure: hashtable-hash-function HASHTABLE
     Return the hash function used by HASHTABLE.  For hashtables created
     by 'make-eq-hashtable' or 'make-eqv-hashtable', '#f' is returned.

 -- Procedure: hashtable-mutable? HASHTABLE
     Return '#t' if HASHTABLE is mutable, otherwise '#f'.


File: vicare-scheme.info,  Node: stdlib hashtable hash functions,  Prev: stdlib hashtable inspection,  Up: stdlib hashtable

5.13.4 Hash functions
---------------------

The 'equal-hash', 'string-hash', and 'string-ci-hash' procedures of this
section are acceptable as the hash functions of a hashtable only if the
keys on which they are called are not mutated while they remain in use
as keys in the hashtable.

 -- Procedure: equal-hash OBJ
     Return an integer hash value for OBJ, based on its structure and
     current contents.  This hash function is suitable for use with
     'equal?' as an equivalence function.

          *NOTE* Like 'equal?', the 'equal-hash' procedure must always
          terminate, even if its arguments contain cycles.

 -- Procedure: string-hash STRING
 -- Procedure: string-hash STRING MAX-LEN
     Return an integer hash value for STRING, based on its current
     contents.  This hash function is suitable for use with 'string=?'
     as an equivalence function.

     As Vicare extension:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of characters to use to compute the hash value,
          starting from the beginning of STRING.  If the length of
          STRING is greater than MAX-LEN: only the first MAX-LEN
          characters are used.  If the length of STRING is less than or
          equal to MAX-LEN: all the bytes in STRING are used.

        * When MAX-LEN is '#f' or not present: if the length of STRING
          is greater than 64 characters, only the first 64 bytes are
          used to compute the hash.

        * When MAX-LEN is '#t': all the bytes in STRING are used.

     *NOTE* When the hash value is computed using a number of characters
     N less than the string length: applications *must not* assume that
     two strings having the first N characters equal will have the same
     hash value.

 -- Procedure: string-ci-hash STRING
 -- Procedure: string-ci-hash STRING MAX-LEN
     Return an integer hash value for STRING based on its current
     contents, ignoring case.  This hash function is suitable for use
     with 'string-ci=?' as an equivalence function.

     The optional argument MAX-LEN is used as in 'string-hash'.

 -- Procedure: symbol-hash SYMBOL
     Return an integer hash value for SYMBOL.


File: vicare-scheme.info,  Node: stdlib enum,  Next: stdlib complib,  Prev: stdlib hashtable,  Up: stdlib

5.14 Enumerations
=================

This chapter describes the '(rnrs enums (6))' library for dealing with
enumerated values and sets of enumerated values.  Enumerated values are
represented by ordinary symbols, while finite sets of enumerated values
form a separate type, known as the "enumeration sets".  The enumeration
sets are further partitioned into sets that share the same "universe"
and "enumeration type".  These universes and enumeration types are
created by the 'make-enumeration' procedure.  Each call to that
procedure creates a new enumeration type.

   This library interprets each enumeration set with respect to its
specific universe of symbols and enumeration type.  This facilitates
efficient implementation of enumeration sets and enables the complement
operation.

   In the descriptions of the following procedures, ENUM-SET ranges over
the enumeration sets, which are defined as the subsets of the universes
that can be defined using 'make-enumeration'.

 -- Procedure: make-enumeration SYMBOL-LIST
     SYMBOL-LIST must be a list of symbols.

     The 'make-enumeration' procedure creates a new enumeration type
     whose universe consists of those symbols (in canonical order of
     their first appearance in the list) and returns that universe as an
     enumeration set whose universe is itself and whose enumeration type
     is the newly created enumeration type.

 -- Procedure: enum-set-universe ENUM-SET
     Return the set of all symbols that comprise the universe of its
     argument, as an enumeration set.

 -- Procedure: enum-set-indexer ENUM-SET
     Return a unary procedure that, given a symbol that is in the
     universe of ENUM-SET, returns its 0-origin index within the
     canonical ordering of the symbols in the universe; given a symbol
     not in the universe, the unary procedure returns '#f'.

          (let* ((e (make-enumeration '(red green blue)))
                 (i (enum-set-indexer e)))
            (list (i 'red) (i 'green) (i 'blue) (i 'yellow)))
          => (0 1 2 #f)

     The 'enum-set-indexer' procedure could be defined as follows using
     the 'memq' procedure from the '(rnrs lists (6))' library:

          (define (enum-set-indexer set)
            (let* ((symbols (enum-set->list
                              (enum-set-universe set)))
                   (cardinality (length symbols)))
              (lambda (x)
                (cond
                 ((memq x symbols)
                  => (lambda (probe)
                       (- cardinality (length probe))))
                 (else #f)))))

 -- Procedure: enum-set-constructor ENUM-SET
     Return a unary procedure that, given a list of symbols that belong
     to the universe of ENUM-SET, returns a subset of that universe that
     contains exactly the symbols in the list.  The values in the list
     must all belong to the universe.

 -- Procedure: enum-set->list ENUM-SET
     Return a list of the symbols that belong to its argument, in the
     canonical order of the universe of ENUM-SET.

          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (enum-set->list (c '(blue red))))    => (red blue)

 -- Procedure: enum-set-member? SYMBOL ENUM-SET
 -- Procedure: enum-set-subset? ENUM-SET1 ENUM-SET2
 -- Procedure: enum-set=? ENUM-SET1 ENUM-SET2
     The 'enum-set-member?' procedure returns '#t' if its first argument
     is an element of its second argument, '#f' otherwise.

     The 'enum-set-subset?' procedure returns '#t' if the universe of
     ENUM-SET1 is a subset of the universe of ENUM-SET2 (considered as
     sets of symbols) and every element of ENUM-SET1 is a member of
     ENUM-SET2.  It returns '#f' otherwise.

     The 'enum-set=?' procedure returns '#t' if ENUM-SET1 is a subset of
     ENUM-SET2 and vice versa, as determined by the 'enum-set-subset?'
     procedure.  This implies that the universes of the two sets are
     equal as sets of symbols, but does not imply that they are equal as
     enumeration types.  Otherwise, '#f' is returned.

          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (list
             (enum-set-member? 'blue (c '(red blue)))
             (enum-set-member? 'green (c '(red blue)))
             (enum-set-subset? (c '(red blue)) e)
             (enum-set-subset? (c '(red blue)) (c '(blue red)))
             (enum-set-subset? (c '(red blue)) (c '(red)))
             (enum-set=? (c '(red blue)) (c '(blue red)))))
          => (#t #f #t #t #f #t)

 -- Procedure: enum-set-union ENUM-SET1 ENUM-SET2
 -- Procedure: enum-set-intersection ENUM-SET1 ENUM-SET2
 -- Procedure: enum-set-difference ENUM-SET1 ENUM-SET2
     ENUM-SET1 and ENUM-SET2 must be enumeration sets that have the same
     enumeration type.

     The 'enum-set-union' procedure returns the union of ENUM-SET1 and
     ENUM-SET2.  The 'enum-set-intersection' procedure returns the
     intersection of ENUM-SET1 and ENUM-SET2.  The 'enum-set-difference'
     procedure returns the difference of ENUM-SET1 and ENUM-SET2.

          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (list (enum-set->list
                   (enum-set-union (c '(blue)) (c '(red))))
                  (enum-set->list
                   (enum-set-intersection (c '(red green))
                                          (c '(red blue))))
                  (enum-set->list
                   (enum-set-difference (c '(red green))
                                        (c '(red blue))))))
          => ((red blue) (red) (green))

 -- Procedure: enum-set-complement ENUM-SET
     Return ENUM-SET's complement with respect to its universe.

          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (enum-set->list
              (enum-set-complement (c '(red)))))
          => (green blue)

 -- Procedure: enum-set-projection ENUM-SET1 ENUM-SET2
     Project ENUM-SET1 into the universe of ENUM-SET2, dropping any
     elements of ENUM-SET1 that do not belong to the universe of
     ENUM-SET2.  (If ENUM-SET1 is a subset of the universe of ENUM-SET2,
     no elements are dropped, and the injection is returned.)

          (let ((e1 (make-enumeration
                      '(red green blue black)))
                (e2 (make-enumeration
                      '(red black white))))
            (enum-set->list
              (enum-set-projection e1 e2))))
          => (red black)

 -- Syntax: define-enumeration ?TYPE-NAME (?SYMBOL ...)
          ?CONSTRUCTOR-SYNTAX
     The 'define-enumeration' form defines an enumeration type and
     provides two macros for constructing its members and sets of its
     members.

     A 'define-enumeration' form is a definition and can appear anywhere
     any other ?DEFINITION can appear.

     ?TYPE-NAME is an identifier that is bound as a syntactic keyword;
     ?SYMBOL ... are the symbols that comprise the universe of the
     enumeration (in order).

     '(?TYPE-NAME ?SYMBOL)' checks at macro-expansion time whether the
     name of ?SYMBOL is in the universe associated with ?TYPE-NAME.  If
     it is, '(?TYPE-NAME ?SYMBOL)' is equivalent to '?SYMBOL'.  It is a
     syntax violation if it is not.

     ?CONSTRUCTOR-SYNTAX is an identifier that is bound to a macro that,
     given any finite sequence of the symbols in the universe, possibly
     with duplicates, expands into an expression that evaluates to the
     enumeration set of those symbols.

     '(?CONSTRUCTOR-SYNTAX ?SYMBOL ...)' checks at macro-expansion time
     whether every ?SYMBOL ...  is in the universe associated with
     ?TYPE-NAME.  It is a syntax violation if one or more is not.
     Otherwise:

          (?CONSTRUCTOR-SYNTAX ?SYMBOL ...)

     is equivalent to:

          ((enum-set-constructor (?CONSTRUCTOR-SYNTAX))
           '(?SYMBOL ...))

     Example:

          (define-enumeration color
            (black white purple maroon)
            color-set)

          (color black)                      => black
          (color purpel)                     => exception &syntax
          (enum-set->list (color-set))       => ()
          (enum-set->list
            (color-set maroon white))        => (white maroon)

          *NOTE* In the forms:

               (?TYPE-NAME ?SYMBOL)
               (?CONSTRUCTOR-SYNTAX ?SYMBOL ...)

          only the names of the ?SYMBOLs are significant.


File: vicare-scheme.info,  Node: stdlib complib,  Next: stdlib eval,  Prev: stdlib enum,  Up: stdlib

5.15 Composite library
======================

The '(rnrs (6))' library is a composite of most of the libraries
described in this report.  The only exceptions are:

'(rnrs eval (6))'
'(rnrs mutable-pairs (6))'
'(rnrs mutable-strings (6))'
'(rnrs r5rs (6))'

   The library exports all procedures and syntactic forms provided by
the component libraries.

   All of the bindings exported by '(rnrs (6))' are exported for both
'run' and 'expand'; *note scheme library import export::.


File: vicare-scheme.info,  Node: stdlib eval,  Next: stdlib mutable pairs,  Prev: stdlib complib,  Up: stdlib

5.16 Evaluation
===============

The '(rnrs eval (6))' library allows a program to create Scheme
expressions as data at run time and evaluate them.

 -- Procedure: eval EXPRESSION ENVIRONMENT
     Evaluate EXPRESSION in the specified environment and returns its
     value.  EXPRESSION must be a syntactically valid Scheme expression
     represented as a datum value, and ENVIRONMENT must be an
     _environment_, which can be created using the 'environment'
     procedure described below.

     If the first argument to 'eval' is determined not to be a
     syntactically correct expression, then 'eval' must raise an
     exception with condition type '&syntax'.  Specifically, if the
     first argument to 'eval' is a definition or a splicing 'begin' form
     containing a definition, it must raise an exception with condition
     type '&syntax'.

 -- Procedure: environment IMPORT-SPEC ...
     IMPORT-SPEC must be a datum representing an ?IMPORT-SPEC (*note
     scheme library form::).

     The 'environment' procedure returns an environment corresponding to
     IMPORT-SPEC.

     The bindings of the environment represented by the specifier are
     immutable: If 'eval' is applied to an expression that is determined
     to contain an assignment to one of the variables of the
     environment, then 'eval' must raise an exception with a condition
     type '&syntax'.

          (library (foo)
            (export)
            (import (rnrs)
                    (rnrs eval))
            (write
              (eval '(let ((x 3)) x)
                    (environment '(rnrs)))))      ;; writes 3

          (library (foo)
            (export)
            (import (rnrs)
                    (rnrs eval))
            (write
              (eval
                '(eval:car (eval:cons 2 4))
                (environment
                  '(prefix (only (rnrs) car cdr cons null?)
                           eval:)))))             ;; writes 2


File: vicare-scheme.info,  Node: stdlib mutable pairs,  Next: stdlib mutable strings,  Prev: stdlib eval,  Up: stdlib

5.17 Mutable pairs
==================

The procedures provided by the '(rnrs mutable-pairs (6))' library allow
new values to be assigned to the car and cdr fields of previously
allocated pairs.

 -- Procedure: set-car! PAIR OBJ
     Store OBJ in the car field of PAIR.  The 'set-car!' procedure
     returns unspecified values.

          (define (f) (list 'not-a-constant-list))
          (define (g) '(constant-list))
          (set-car! (f) 3)        => unspecified
          (set-car! (g) 3)        => unspecified
                                  ; should raise exception &assertion

     If an immutable pair is passed to 'set-car!', an exception with
     condition type '&assertion' should be raised.

 -- Procedure: set-cdr! PAIR OBJ
     Store OBJ in the cdr field of PAIR.  The 'set-cdr!' procedure
     returns unspecified values.

     If an immutable pair is passed to 'set-cdr!', an exception with
     condition type '&assertion' should be raised.

          (let ((x (list 'a 'b 'c 'a))
                (y (list 'a 'b 'c 'a 'b 'c 'a)))
            (set-cdr! (list-tail x 2) x)
            (set-cdr! (list-tail y 5) y)
            (list
             (equal? x x)
             (equal? x y)
             (equal? (list x y 'a) (list y x 'b))))
          =>  (#t #t #f)


File: vicare-scheme.info,  Node: stdlib mutable strings,  Next: stdlib rfive compat,  Prev: stdlib mutable pairs,  Up: stdlib

5.18 Mutable strings
====================

The 'string-set!' procedure provided by the '(rnrs mutable-strings (6))'
library allows mutating the characters of a string in-place.

 -- Procedure: string-set! STRING K CHAR
     K must be a valid index of STRING.

     The 'string-set!' procedure stores CHAR in element K of STRING and
     returns unspecified values.

     Passing an immutable string to 'string-set!' should cause an
     exception with condition type '&assertion' to be raised.

          (define (f) (make-string 3 #\*))
          (define (g) "***")
          (string-set! (f) 0 #\?)         => unspecified
          (string-set! (g) 0 #\?)         => unspecified
                                          ; should raise exception &assertion

          (string-set! (symbol->string 'immutable)
                       0
                       #\?)               => unspecified
                                          ; should raise exception &assertion

          *NOTE* Implementors should make 'string-set!' run in constant
          time.

 -- Procedure: string-fill! STRING CHAR
     Store CHAR in every element of the given STRING.  As Vicare
     extension: the return value is STRING itself.


File: vicare-scheme.info,  Node: stdlib rfive compat,  Prev: stdlib mutable strings,  Up: stdlib

5.19 R5RS compatibility
=======================

The features described in this chapter are exported from the '(rnrs r5rs
(6))' library and provide some functionality of the preceding revision
of this report that was omitted from the main part of the current
report.

 -- Procedure: exact->inexact Z
 -- Procedure: inexact->exact Z
     These are the same as the 'inexact' and 'exact' procedures; *note
     baselib math ops exactness::.

 -- Procedure: quotient N1 N2
 -- Procedure: remainder N1 N2
 -- Procedure: modulo N1 N2
     These procedures implement number-theoretic (integer) division.  N2
     must be non-zero.  All three procedures return integer objects.  If
     N1/N2 is an integer object:

          (quotient N1 N2)   => N1/N2
          (remainder N1 N2)  => 0
          (modulo N1 N2)     => 0

     If N1/N2 is not an integer object:

          (quotient N1 N2)   => N_Q
          (remainder N1 N2)  => N_R
          (modulo N1 N2)     => N_M

     where N_Q is N1/N2 rounded towards zero,

          0 < |N_R| < |N2|
          0 < |N_M| < |N2|

     N_R and N_M differ from N1 by a multiple of N2, N_R has the same
     sign as N1, and N_M has the same sign as N2.

     Consequently, for integer objects N1 and N2 with N2 not equal to 0,

          (= N1 (+ (* N2 (quotient N1 N2))
                         (remainder N1 N2)))
          => #t

     provided all number object involved in that computation are exact.

          (modulo 13 4)           =>  1
          (remainder 13 4)        =>  1

          (modulo -13 4)          =>  3
          (remainder -13 4)       =>  -1

          (modulo 13 -4)          =>  -3
          (remainder 13 -4)       =>  1

          (modulo -13 -4)         =>  -1
          (remainder -13 -4)      =>  -1

          (remainder -13 -4.0)    =>  -1.0

          *NOTE* These procedures could be defined in terms of 'div' and
          'mod' (*note baselib math ops arithmetic::) as follows
          (without checking of the argument types):

               (define (sign n)
                 (cond
                   ((negative? n) -1)
                   ((positive? n) 1)
                   (else 0)))

               (define (quotient n1 n2)
                 (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

               (define (remainder n1 n2)
                 (* (sign n1) (mod (abs n1) (abs n2))))

               (define (modulo n1 n2)
                 (* (sign n2) (mod (* (sign n2) n1) (abs n2))))

 -- Syntax: delay ?EXPRESSION
     The 'delay' construct is used together with the procedure 'force'
     to implement _lazy evaluation_ or _call by need_.

     '(delay ?EXPRESSION)' returns an object called a _promise_ which at
     some point in the future may be asked (by the 'force' procedure) to
     evaluate ?EXPRESSION, and deliver the resulting value.  The effect
     of ?EXPRESSION returning multiple values is unspecified.

 -- Procedure: force PROMISE
     PROMISE must be a promise.

     The 'force' procedure forces the value of PROMISE.  If no value has
     been computed for the promise, then a value is computed and
     returned.  The value of the promise is cached (or "memoized") so
     that if it is forced a second time, the previously computed value
     is returned.

          (force (delay (+ 1 2)))                 =>  3

          (let ((p (delay (+ 1 2))))
            (list (force p) (force p)))           =>  (3 3)

          (define a-stream
            (letrec ((next
                      (lambda (n)
                        (cons n (delay (next (+ n 1)))))))
              (next 0)))
          (define head car)
          (define tail
            (lambda (stream) (force (cdr stream))))

          (head (tail (tail a-stream)))           =>  2

     Promises are mainly intended for programs written in functional
     style.  The following examples should not be considered to
     illustrate good programming style, but they illustrate the property
     that only one value is computed for a promise, no matter how many
     times it is forced.

          (define count 0)
          (define p
            (delay (begin (set! count (+ count 1))
                          (if (> count x)
                              count
                              (force p)))))
          (define x 5)
          p                     =>  a promise
          (force p)             =>  6
          p                     =>  a promise, still
          (begin (set! x 10)
                 (force p))     =>  6

     Here is a possible implementation of 'delay' and 'force'.  Promises
     are implemented here as procedures of no arguments, and 'force'
     simply calls its argument:

          (define force
            (lambda (object)
              (object)))

     The expression:

          (delay ?EXPRESSION)

     has the same meaning as the procedure call:

          (make-promise (lambda () ?EXPRESSION))

     as follows:

          (define-syntax delay
            (syntax-rules ()
              ((delay expression)
               (make-promise (lambda () expression)))))

     where 'make-promise' is defined as follows:

          (define make-promise
            (lambda (proc)
              (let ((result-ready?  #f)
                    (result         #f))
                (lambda ()
                  (if result-ready?
                      result
                      (let ((x (proc)))
                        (if result-ready?
                            result
                            (begin (set! result-ready? #t)
                                   (set! result x)
                                   result))))))))

 -- Procedure: null-environment N
     N must be the exact integer object 5.

     The 'null-environment' procedure returns an environment specifier
     suitable for use with 'eval' representing an environment that is
     empty except for the (syntactic) bindings for all keywords
     described in the previous revision of this report, including
     bindings for '=>', '...', 'else' and '_' that are the same as those
     in the '(rnrs base (6))' library.

 -- Procedure: scheme-report-environment N
     N must be the exact integer object 5.

     The 'scheme-report-environment' procedure returns an environment
     specifier for an environment that is empty except for the bindings
     for the identifiers described in the previous revision of this
     report, omitting 'load', 'interaction-environment',
     'transcript-on', 'transcript-off', and 'char-ready?'.

     The variable bindings have as values the procedures of the same
     names described in this report, and the keyword bindings, including
     '=>', '...', 'else' and '_' are the same as those described in this
     report.


File: vicare-scheme.info,  Node: iklib,  Next: libutils,  Prev: stdlib,  Up: Top

6 Language extensions
*********************

In addition to the libraries listed in the R6RS standard, Vicare offers
more libraries which provide additional features; here is a list of some
of them:

'(vicare)'
     It is a composite library, it exports a superset of all the
     supported bindings of R6RS.

'(vicare language-extensions)'
     It exports all the bindings exported by '(vicare)' that are *not*
     exported by '(rnrs (6))'.

'(vicare platform constants)'
     Exports one syntax identifier binding for each platform constant
     that makes sense to access from Scheme.

'(vicare platform utilities)'
     Defines helper functions to deal with platform specific issues;
     *note Hosting platform utilities: (vicare-libs)platform. for
     details.

'(vicare platform features)'
     Exports an identifier syntax for every 'HAVE_' symbol defined by
     the configuration script 'configure'; such syntaxes expand to a
     boolean value: '#t' if the feature is available, '#f' otherwise.

* Menu:

* iklib libraries::             Extended 'library' syntax.
* iklib programs::              Extended program syntax.
* iklib runtime::               Run-time configuration.
* iklib progname::              Finding the 'vicare' executable.
* iklib config::                Configuration options inspection.
* iklib cmdline::               Command line arguments.
* iklib env-inquiry::           Environment inquiry.
* iklib syntaxes::              Additional syntaxes.
* iklib unwind-protect::        The unwind-protection mechanism.
* iklib compensations::         Compensation stacks.
* iklib coroutines::            Running coroutines.
* iklib conditions::            Additional condition types.
* iklib reader::                Extensions to the reader.
* iklib expander::              Interface to the expander.
* iklib shared::                Shared structures graph notation.
* iklib environment::           Environments.
* iklib eval::                  Extended code evaluation.
* iklib cafe::                  Cafe.
* iklib records::               Extensions to R6RS records.
* iklib promises::              Delay, force and promises.
* iklib booleans::              Additional boolean functions.
* iklib chars::                 Additional character functions.
* iklib keywords::              Keyword objects.
* iklib ipairs::                Immutable pairs.
* iklib lists::                 Additional list functions.
* iklib bytevectors::           Additional bytevector functions.
* iklib strings::               Additional string functions.
* iklib vectors::               Additional vector functions.
* iklib symbols::               Additional symbol functions.
* iklib fixnums::               Additional functions on fixnums.
* iklib flonums::               Additional functions on flonums.
* iklib numerics::              Additional functions on numbers.
* iklib enumerations::          Additional functions on enumerations.
* iklib hashtables::            Additional functions on hash tables.
* iklib load::                  Loading source files.
* iklib modules::               Local modules.
* iklib parameters::            Parameters.
* iklib gensym::                Gensyms.
* iklib printing::              Printing.
* iklib timing::                Timing.
* iklib gc::                    Interfacing with garbage collection.
* iklib guardians::             Guardians and garbage collection.
* iklib engines::               Engines.
* iklib io::                    Input/output library.
* iklib pointers::              Handling pointer objects.
* iklib memory::                Memory management.
* iklib cstrings::              Raw C strings.
* iklib errno::                 Interface to 'errno'.
* iklib time::                  Basic time and date functions.
* iklib readline::              Readline interface.
* iklib debug::                 Debugging utilities.
* iklib sentinel::              The sentinel object.
* iklib misc::                  Miscellaneous functions.


File: vicare-scheme.info,  Node: iklib libraries,  Next: iklib programs,  Up: iklib

6.1 Extended 'library' syntax
=============================

* Menu:

* iklib libraries options::     Library-specific options.
* iklib libraries foreign::     Loading host's foreign libraries.


File: vicare-scheme.info,  Node: iklib libraries options,  Next: iklib libraries foreign,  Up: iklib libraries

6.1.1 Library-specific options
------------------------------

Vicare extends the format of 'library' forms by allowing an optional
'options' clause:

     (library ?LIBRARY-NAME
       (options ?OPTION ...)
       (export  ?EXPORT-SPEC ...)
       (import  ?IMPORT-SPEC ...)
       . ?LIBRARY-BODY)

where each ?OPTION is a symbolic expression.  There can be a single
'options' clause, before the 'export' one.

 -- Library Option: typed-language
     Turn on the typed language extensions (*note The typed language:
     (vicare-typed)Top.).

 -- Library Option: strict-r6rs
     Turn on strict support for R6RS language.

 -- Library Option: strict-type-checking
     Turn on strict type checking warnings when the typed language is
     enabled (*note The typed language: (vicare-typed)Top.).


File: vicare-scheme.info,  Node: iklib libraries foreign,  Prev: iklib libraries options,  Up: iklib libraries

6.1.2 Loading host's foreign libraries
--------------------------------------

Vicare extends the format of 'library' forms by allowing an optional
'foreign-library' clause:

     (library ?LIBRARY-NAME
       (foreign-library ?SHARED-OBJECT-ID)
       (export  ?EXPORT-SPEC ...)
       (import  ?IMPORT-SPEC ...)
       . ?LIBRARY-BODY)

where each ?SHARED-OBJECT-ID is a Scheme string object.  There can be
any number of 'foreign-library' clauses, before the 'export' one.

   The clause 'foreign-library' allows us to associate a host's shared
object to the Scheme library, so that, whenever the library is expanded
from source code or loaded from a FASL file: the shared object is
dynamically loaded with a call to the operating system's function
'dlopen()'.  *note foreign:: for details.


File: vicare-scheme.info,  Node: iklib programs,  Next: iklib runtime,  Prev: iklib libraries,  Up: iklib

6.2 Extended program syntax
===========================

* Menu:

* iklib programs form::         Top-level program form.
* iklib programs options::      Program-specific options.
* iklib programs foreign::      Loading host's foreign libraries.


File: vicare-scheme.info,  Node: iklib programs form,  Next: iklib programs options,  Up: iklib programs

6.2.1 Top-level program form
----------------------------

The R6RS document specifies a compliant top-level program as:

     ... a delimited piece of text, typically a file, that has the
     following form:

          ?IMPORT-FORM ?TOP-LEVEL-BODY

so it only specifies that it is "delimited"; it means:

   * Any form can come before ?IMPORT-FORM.

   * Any form can come after ?TOP-LEVEL-BODY.

   * The delimited sequence can be wrapped into an
     implementation-defined enclosing form.

   Vicare gathers this freedom to accept two formats of top-level
programs:

  1. The standalone delimited sequence:

          (import ?IMPORT-SPEC ...) ?BODY ...

  2. A 'program' form with the following syntax:

          (program ?PROGRAM-NAME
            ?CONFIG-FORM ...
            (import ?IMPORT-SPEC ...)
            . ?PROGRAM-BODY)

where ?PROGRAM-NAME is meant to be a descriptive list of symbols and the
?CONFIG-FORM clauses allow additional configuration and behaviour
specification.


File: vicare-scheme.info,  Node: iklib programs options,  Next: iklib programs foreign,  Prev: iklib programs form,  Up: iklib programs

6.2.2 Program-specific options
------------------------------

Vicare extends the format of top-level programs by allowing an optional
'options' clause:

     (program ?PROGRAM-NAME
       (options ?OPTION ...)
       (import  ?IMPORT-SPEC ...)
       . ?PROGRAM-BODY)

where each ?OPTION is a symbolic expression.  There can be only one
'options' clause, before the 'import' one.

   The following options are supported.

 -- Program Option: typed-language
     Turn on the typed language extensions (*note The typed language:
     (vicare-typed)Top.).

 -- Program Option: strict-r6rs
     Turn on strict support for R6RS language.

 -- Library Option: strict-type-checking
     Turn on strict type checking warnings when the typed language is
     enabled (*note The typed language: (vicare-typed)Top.).


File: vicare-scheme.info,  Node: iklib programs foreign,  Prev: iklib programs options,  Up: iklib programs

6.2.3 Loading host's foreign libraries
--------------------------------------

Vicare extends the format of top-level programs by allowing an optional
'foreign-library' clause:

     (program ?PROGRAM-NAME
       (foreign-library ?SHARED-OBJECT-ID)
       (import  ?IMPORT-SPEC ...)
       . ?PROGRAM-BODY)

where each ?SHARED-OBJECT-ID is a Scheme string object.  There can be
any number of 'foreign-library' clauses, before the 'import' one.

   The clause 'foreign-library' allows us to associate a host's shared
object to the Scheme program, so that, whenever the program is expanded
from source code or loaded from a FASL file: the shared object is
dynamically loaded with a call to the operating system's function
'dlopen()'.  *note foreign:: for details.


File: vicare-scheme.info,  Node: iklib runtime,  Next: iklib progname,  Prev: iklib programs,  Up: iklib

6.3 Run-time configuration
==========================

The following syntactic bindings are exported by the library '(vicare
system $runtime)'.

 -- Function: scheme-heap-nursery-size
 -- Function: scheme-heap-nursery-size NUM-OF-BYTES
     Getter and setter for the size of the Scheme heap nursery's hot
     block memory segment.  When called without arguments: return the
     current size.  When called with one argument: set a new size.

     The exact integer NUM-OF-BYTES must fit into a platform's 'unsigned
     long' value, it must be positive and greater than 3 Vicare's page
     sizes, 4096 * 3 = 12288.  The given NUM-OF-BYTES value is
     normalised by rounding it to the least exact multiple of 4096
     greater than NUM-OF-BYTES.

     The Scheme heap nursery's hot block memory segment is allocated at
     process start-up, before loading the boot image.  While loading the
     boot image: the hot block may be reallocated.  These first
     allocation and reallocations cannot be configured with this
     function, we have to use a command line argument (*note
     scheme-heap-nursery-size: using invoking.).

     After boot image loading, if the Scheme heap nursery's hot block
     memory segment is reallocated: the new hot block has the size
     configured with this function.  Notice that, after boot image
     loading: hot block reallocation may never happen (most likely it
     will never happen).

     The default size for the heap nursery is: on 32-bit platforms
     4096*1024=4194304, that is 4 MiB; on 64-bit platforms
     '4096*1024*2=8388608', that is 8 MiB.

 -- Function: scheme-stack-size
 -- Function: scheme-stack-size NUM-OF-BYTES
     Getter and setter for the size of the Scheme stack memory segment.
     When called without arguments: return the current size.  When
     called with one argument: set a new size.

     The exact integer NUM-OF-BYTES must fit into a platform's 'unsigned
     long' value, it must be positive and greater than 3 Vicare's page
     sizes, 4096 * 3 = 12288.  The given NUM-OF-BYTES value is
     normalised by rounding it to the least exact multiple of 4096
     greater than NUM-OF-BYTES.

     The Scheme heap stack memory segment is allocated at process
     start-up, before loading the boot image.  While loading the boot
     image: the stack segment may be reallocated.  These first
     allocation and reallocations cannot be configured with this
     function, we have to use a command line argument (*note
     scheme-stack-size: using invoking.).

     After boot image loading, when the Scheme stack segment is
     reallocated: the new segment has the size configured with this
     function.

     The default size for the stack is: on 32-bit platforms
     4096*1024=4194304, that is 4 MiB; on 64-bit platforms
     '4096*1024*2=8388608', that is 8 MiB.


File: vicare-scheme.info,  Node: iklib progname,  Next: iklib config,  Prev: iklib runtime,  Up: iklib

6.4 Finding the 'vicare' executable
===================================

The following bindings are exported by the library '(vicare)'.

 -- Function: vicare-argv0
     Return a bytevector holding the C string in the 'argv[0]' argument
     to the 'main()' function of the current Vicare process.

 -- Function: vicare-argv0-string
     Return a Scheme string holding the C string in the 'argv[0]'
     argument to the 'main()' function of the current Vicare process.


File: vicare-scheme.info,  Node: iklib config,  Next: iklib cmdline,  Prev: iklib progname,  Up: iklib

6.5 Configuration options inspection
====================================

The following bindings are exported by the library '(vicare system
options)'.

 -- Function: vicare-built-with-arguments-validation-enabled
     Return '#t' if the package was installed along with procedure
     arguments validation enabled; otherwise return '#f'.

 -- Function: vicare-built-with-descriptive-labels-generation
     Return '#t' if the package was installed along with descriptive
     labels generation; otherwise return '#f'.

 -- Function: vicare-built-with-srfi-enabled
     Return '#t' if the package was installed along with the SRFI
     libraries; otherwise return '#f'.

 -- Function: vicare-built-with-iconv-enabled
     Return '#t' if the package was configured with bindings to Libiconv
     enabled; otherwise return '#f'.

 -- Function: vicare-built-with-ffi-enabled
     Return '#t' if the package was configured with bindings to Libffi
     enabled; otherwise return '#f'.

 -- Function: vicare-built-with-posix-enabled
     Return '#t' if the package was configured with POSIX features
     enabled; otherwise return '#f'.

 -- Function: vicare-built-with-glibc-enabled
     Return '#t' if the package was configured with GNU C Library
     features enabled; otherwise return '#f'.

 -- Function: vicare-built-with-linux-enabled
     Return '#t' if the package was configured with Linux features
     enabled; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib cmdline,  Next: iklib env-inquiry,  Prev: iklib config,  Up: iklib

6.6 Command line arguments
==========================

The following bindings are exported by the library '(vicare)'.

 -- Parameter: command-line-arguments
     Hold the value returned by 'command-line' as defined by R6RS.  It
     is initialised to the actual command line arguments from the Vicare
     process execution.


File: vicare-scheme.info,  Node: iklib env-inquiry,  Next: iklib syntaxes,  Prev: iklib cmdline,  Up: iklib

6.7 Environment inquiry
=======================

 -- Function: host-info
     Return a string being the value GNU Autoconf assigned to the
     'target' variable.  Examples: 'i686-pc-linux-gnu',
     'x86_64-unknown-linux-gnu'.

   The POSIX function 'uname()' fills a data structure of type 'struct
utsname' with strings representing a description of the underlying
platform.  Vicare defines objects of type '<utsname>' to provide at the
Scheme level such informations; '<utsname>' objects are disjoint from
all the other types.

 -- Function: uname
     Interface to the C function 'uname()', *note Get name and
     information about current kernel: (*manpages*)uname.  Build and
     return a new object of type '<utsname>'.  If successful return the
     object, otherwise raise an exception.

 -- Function: utsname? OBJ
     Return '#t' if OBJ is an object of type '<utsname>', otherwise
     return '#f'.

 -- Function: utsname=? UTSNAME0 UTSNAME1 ...
     All the arguments must be '<utsname>' objects.  Return '#t' if all
     the arguments are equal.  When applied to a single argument: return
     '#t'.

 -- Function: utsname!=? UTSNAME0 UTSNAME1 ...
     The arguments must be '<utsname>' objects.  Return '#t' if the
     arguments are all different: no two arguments are equal; otherwise
     return '#f'.  When applied to a single argument: return '#f'.

 -- Function: utsname-sysname UTSNAME
 -- Function: utsname-nodename UTSNAME
 -- Function: utsname-release UTSNAME
 -- Function: utsname-version UTSNAME
 -- Function: utsname-machine UTSNAME
     Accessors for the fields of the UTSNAME object.  All the returned
     values are strings.

   The following bindings are specified by SRFI-112, exported by
'(vicare)' and reexported by the SRFI's libraries, *note Specification:
(vicare-libs)srfi env-inquiry spec.

 -- Function: implementation-name
     Return the string '"vicare-scheme"'.

 -- Function: implementation-version
     Return the Vicare version string.  Example:

          (import (vicare))
          (implementation-version)        => "0.3d4"

 -- Function: cpu-architecture
     Return a Scheme string representing the contents of the field
     'machine' of the 'struct utsname' filled by 'uname()'.  Example:

          (import (vicare))
          (cpu-architecture)      => "x86_64"

 -- Function: machine-name
     Return a Scheme string representing the contents of the field
     'nodename' of the 'struct utsname' filled by 'uname()'.  Example:

          (import (vicare))
          (machine-name)          => "governatore"

 -- Function: os-name
     Return a Scheme string representing the contents of the field
     'sysname' of the 'struct utsname' filled by 'uname()'.  Example:

          (import (vicare))
          (os-name)               => "Linux"

 -- Function: os-version
     Return a Scheme string representing the contents of the field
     'version' of the 'struct utsname' filled by 'uname()'.  Example:

          (import (vicare))
          (os-version)
          => "#2 SMP Mon Sep 17 14:19:22 CDT 2012"


File: vicare-scheme.info,  Node: iklib syntaxes,  Next: iklib unwind-protect,  Prev: iklib env-inquiry,  Up: iklib

6.8 Additional syntaxes
=======================

* Menu:

* iklib syntaxes libraries::    Local libraries.
* iklib syntaxes lambdas::      'lambda'-like additional syntaxes.
* iklib syntaxes defines::      'define'-like additional syntaxes.
* iklib syntaxes defstxs::      'define-syntax'-like additional syntaxes.
* iklib syntaxes bindings::     Additional binding syntaxes.
* iklib syntaxes control::      Additional control flow syntaxes.
* iklib syntaxes loops::        Additional loop syntaxes.
* iklib syntaxes returnable::   Early return from code blocks.
* iklib syntaxes blocking::     Blocking raised exceptions.
* iklib syntaxes dynenv::       Capturing the current dynamic
                                environment.
* iklib syntaxes integrable::   Integrable expressions and functions.
* iklib syntaxes stale::        Declaring compiled library in
                                stale state.
* iklib syntaxes body::         Internal body.
* iklib syntaxes try::          The 'try', 'catch', 'finally' syntaxes.
* iklib syntaxes splice1st::    Splice first form syntax.
* iklib syntaxes infix::        Infix to prefix transformer.
* iklib syntaxes increments::   Incrementing and decrementing.
* iklib syntaxes delimcc::      Delimited continuations.
* iklib syntaxes misc::         Miscellaneous syntaxes.
* iklib syntaxes properties::   Syntactic binding properties.
* iklib syntaxes expansion-of:: Inspecting expansion results.
* iklib syntaxes optim-of::     Inspecting optimisation results.
* iklib syntaxes assembly-of::  Inspecting assembly language results.


File: vicare-scheme.info,  Node: iklib syntaxes libraries,  Next: iklib syntaxes lambdas,  Up: iklib syntaxes

6.8.1 Local libraries
---------------------

R6RS defines libraries to be top-level symbolic expressions; the form
'library' can appear only at the top-level; *note Library form: scheme
library form.  Vicare extends the notion of libraries by having the
library '(vicare)' export a 'library' syntax; such syntax can be used
anywhere a definition can be used and the defined library can be
imported in its region of visibility.

   The following is a perfectly valid Vicare program:

     (import (vicare))

     (let ()
       (library (ciao)
         (export a)
         (import (rnrs))
         (define a 1))

       (library (hello)
         (export b)
         (import (rnrs))
         (define b 1))

       (import (ciao))
       (import (hello))

       (display (list a b)))


File: vicare-scheme.info,  Node: iklib syntaxes lambdas,  Next: iklib syntaxes defines,  Prev: iklib syntaxes libraries,  Up: iklib syntaxes

6.8.2 'lambda'-like additional syntaxes
---------------------------------------

* Menu:

* iklib syntaxes lambdas named::  Named 'lambda' syntaxes.
* iklib syntaxes lambdas star::   Validating 'lambda' syntaxes.


File: vicare-scheme.info,  Node: iklib syntaxes lambdas named,  Next: iklib syntaxes lambdas star,  Up: iklib syntaxes lambdas

6.8.2.1 Named 'lambda' syntaxes
...............................

 -- Syntax: named-lambda ?WHO ?FORMALS . ?LAMBDA-BODY
     Like 'lambda', but allows the specification of the identifier ?WHO,
     which is bound, as identifier syntax, to the fluid syntax
     '__who__'.

          (define func
            (named-lambda it ()
              __who__))

          (func)          => it

 -- Syntax: named-case-lambda ?WHO . ?CASE-LAMBDA-CLAUSES
     Like 'case-lambda', but allows the specification of the identifier
     ?WHO, which is bound, as identifier syntax, to the fluid syntax
     '__who__'.

          (define func
            (named-case-lambda it
              (()
                __who__)))

          (func)          => it


File: vicare-scheme.info,  Node: iklib syntaxes lambdas star,  Prev: iklib syntaxes lambdas named,  Up: iklib syntaxes lambdas

6.8.2.2 Validating 'lambda' syntaxes
....................................

The syntaxes 'lambda*' and 'case-lambda*' are similar to 'lambda' and
'case-lambda' as defined by R6RS, but they allow the specification of
logic predicates to validate the arguments and the return values; a
logic predicate is a composition of predicate expressions.  Examples:

     #!vicare
     (import (vicare)
       (vicare system $fx))

     (define add
       ;;Fail if called with a non-fixnum argument.
       (lambda* ({a fixnum?} {b fixnum?})
         ($fx+ a b)))

     (define vec
       ;;Fail if attempting to return a non-vector.
       (lambda* ({_ vector?} fun)
         (fun 1 2)))

     (add 1 2)       => 3
     (add 1 #\2)     error-> &procedure-argument-violation

     (vec vector)    => #(1 2)
     (vec list)      error-> &expression-return-value-violation

in the definition of the function bound to 'vec': notice that '{_
vector?}' is not a function argument, it is a special notation used to
select a predicate to validate the return value.

   In the extended 'lambda*' and 'case-lambda*' syntaxes the
?PRED-FORMALS can have any of the forms:

     (?VAR ...)
     (?VAR0 ?VAR ... . ?REST)
     ?ARGS

   Where in the standard 'lambda' and 'case-lambda' syntaxes an
identifier is used to name a formal argument, in the extended 'lambda*'
and 'case-lambda*' syntaxes each formal argument ?VAR can have any of
the forms:

     ?ID
     (brace ?ID ?LOGIC-PRED)

where: 'brace' is the identifier exported by '(vicare)'; ?ID is an
identifier naming the formal argument.  ?LOGIC-PRED must have one of the
following recursive formats:

     ?LOGIC-PRED = ?PRED-ID
                 | (and ?LOGIC-PRED0 ?LOGIC-PRED ...)
                 | (or  ?LOGIC-PRED0 ?LOGIC-PRED ...)
                 | (xor ?LOGIC-PRED0 ?LOGIC-PRED ...)
                 | (not ?LOGIC-PRED)

where: ?PRED-ID is an identifier expanding and evaluating to a predicate
function accepting a single argument and returning true or '#f'; 'and',
'or', 'xor', 'not' are the identifiers exported by '(vicare)'.

   The formal argument ?REST can have only one of the following forms:

     ?REST-ID
     (brace ?REST-ID ?LOGIC-PRED)

and the formal argument ?ARGS can have one of the following forms:

     ?ARGS-ID
     (brace ?ARGS-ID ?LOGIC-PRED)

the ?LOGIC-PRED for ?REST and ?ARGS is applied to each item in the
proper list bound to ?REST-ID and ?ARGS-ID.

   The first item in the ?PRED-FORMALS can have the special syntax:

     (brace _ ?LOGIC-PRED0 ?LOGIC-PRED ...)

where '_' is the binding exported by '(rnrs base (6))'; in this case
such item does *not* represent a formal argument, it just selects
predicates to validate the values returned by the last ?BODY form.

 -- Syntax: lambda* ?PRED-FORMALS ?BODY0 ?BODY ...
 -- Syntax: named-lambda* ?WHO ?PRED-FORMALS ?BODY0 ?BODY ...
     Like the standard 'lambda' and additionally allow the specification
     of predicate functions to validate the arguments and the return
     value.  The formal arguments are handled according to the following
     rules:

        * When all the items in ?PRED-FORMALS are as specified for the
          standard 'lambda': this syntax is equivalent to 'lambda' as
          defined by R6RS.

        * If the boot image has been compiled with procedure arguments
          validation *enabled*, and ?PRED-FORMALS selects predicates to
          validate the arguments: if a predicate fails for its formal
          argument, an exception is raised using
          '&procedure-argument-violation'.

        * If the boot image has been compiled with procedure arguments
          validation *disabled*, the predicate selections in
          ?PRED-FORMALS are ignored and 'lambda*' behaves like the
          standard 'lambda'.

        * If the first element of ?PRED-FORMALS has the format:

               (brace _ ?LOGIC-PRED0 ?LOGIC-PRED ...)

          the values returned by the last ?BODY form are validated using
          the given ?LOGIC-PRED: if a predicate fails for its returned
          value, an exception is raised using a compound condition
          object with component of type
          '&expression-return-value-violation'.

     When using 'lambda*', in addition the behaviour of 'lambda', the
     fluid identifier syntax '__who__' is bound to the quoted symbol
     '_'; the 'named-lambda*' variant allows to specify an identifier
     ?WHO to be used as value for the '__who__' fluid syntax.

     Usage examples:

        * Function with two predicate arguments:

               #!vicare
               (import (vicare))
               (define f
                 (lambda* ({a number?} {b number?})
                   (list (number->string a) (number->string b))))

               (f 1 2)         => ("1" "2")

        * Function with two mandatory arguments and the rest argument:

               #!vicare
               (import (vicare))

               (define f
                 (lambda* ({a number?} {b number?} . {rest number?})
                   (list (number->string a)
                         (number->string b)
                         (length rest))))

               (f 1 2 3 4 5)           => ("1" "2" 3)

        * Function with the ?ARGS argument:

               #!vicare
               (import (vicare))

               (define f
                 (lambda* {args number?}
                   (length args)))

               (f 1 2 3)               => 3

        * Function with a single validated return value:

               #!vicare
               (import (vicare))

               (define f
                 (lambda* ({_ fixnum?} val)
                   val))

               (f 1)                   => 1

        * Function with multiple validated return values:

               #!vicare
               (import (vicare))

               (define f
                 (lambda* ({_ fixnum? string?} a b)
                   (values a b)))

               (f 1 "2")               => 1, "2"

 -- Syntax: case-lambda* ?PRED-CL-CLAUSE ...
 -- Syntax: named-case-lambda* ?WHO ?PRED-CL-CLAUSE ...
     Like the standard 'case-lambda' and additionally allow the
     specification of logic predicates to validate the arguments and the
     return values.  Clause by clause the formals are handled as
     explained for 'lambda*'.

     When using 'case-lambda*', in addition to the behaviour of
     'lambda', the fluid identifier syntax '__who__' is bound to the
     quoted symbol '_'; the 'named-case-lamba*' variant allows to
     specify an identifier ?WHO to be used as value for the '__who__'
     fluid syntax.

     Usage examples:

          #!vicare
          (import (vicare))

          (define f
            (case-lambda*
             (({a number?})
              (number->string a))))

          (define g
            (case-lambda*
             ({args list?}
              (length args))))

          (f 123)                 => "123"
          (g 1 2 3)               => 3


File: vicare-scheme.info,  Node: iklib syntaxes defines,  Next: iklib syntaxes defstxs,  Prev: iklib syntaxes lambdas,  Up: iklib syntaxes

6.8.3 'define'-like additional syntaxes
---------------------------------------

 -- Syntax: case-define ?WHO ?CL-CLAUSE0 ?CL-CLAUSE ...
     Convenience syntax which expands as follows:

          (case-define ?WHO ?CL-CLAUSE0 ?CL-CLAUSE ...)
          ==> (define ?WHO
                (case-lambda ?CL-CLAUSE0 ?CL-CLAUSE ...))

 -- Syntax: define* ?WHO ?EXPRESSION
 -- Syntax: define* ?WHO
 -- Syntax: define* (?WHO . ?FORMALS) ?BODY0 ?BODY ...
 -- Syntax: define* (?PRED-WHO . ?FORMALS) ?BODY0 ?BODY ...
     Like the standard 'define' as defined by R6RS, but when defining a
     function: allow the specification of logic predicates to validate
     the arguments and return values.

     Logic predicates specification is performed as explained for the
     'lambda*' extended syntax (*note iklib syntaxes lambdas::).  There
     is an exception, where 'lambda*' uses the '_' symbol to select
     predicates for the returned values, 'define*' uses the binding
     identifier ?WHO.

     In addition, when defining a function or a variable with non-empty
     right-hand side, the fluid identifier syntax '__who__' is bound to
     the quoted symbol ?WHO.

     Usage examples:

        * Function with two predicate arguments:

               #!vicare
               (import (vicare))

               (define* (f {a number?} {b number?})
                 (list (number->string a) (number->string b)))

               (f 1 2)         => ("1" "2")

        * Function with two mandatory arguments and the rest argument:

               #!vicare
               (import (vicare))

               (define* (f {a number?} {b number?} . {rest number?})
                 (list (number->string a)
                       (number->string b)
                       (length rest)))

               (f 1 2 3 4 5)           => ("1" "2" 3)

        * Function with the ?ARGS argument:

               #!vicare
               (import (vicare))

               (define* (f . {args number?})
                 (length args))

               (f 1 2 3)               => 3

        * Function with a single validated return value:

               #!vicare
               (import (vicare))

               (define* ({f fixnum?} val)
                 val)

               (f 1)                   => 1

        * Function with multiple validated return values:

               #!vicare
               (import (vicare))

               (define* ({f fixnum? string?} a b)
                 (values a b))

               (f 1 "2")               => 1, "2"

        * Accessing the function name:

               (import (vicare))

               (define* (f)
                 __who__)

               (f)     => f

        * Accessing the variable name:

               (import (vicare))

               (define* a (list 'name __who__))
               a       => (name a)

 -- Syntax: case-define* ?WHO ?PRED-CL-CLAUSE0 ?CASE-CLAUSE ...
     Convenience syntax that expands to something similar to:

          (case-define* ?WHO ?PRED-CL-CLAUSE0 ?PRED-CL-CLAUSE ...)
          ==> (define ?WHO
                (case-lambda* ?PRED-CL-CLAUSE0 ?PRED-CL-CLAUSE ...))

     In addition the fluid identifier syntax '__who__' is bound to the
     quoted symbol ?WHO.

 -- Syntax: define-values ?FORMALS ?FORM0 ?FORM ...
     Evaluate the given forms and bind the, possibly multiple, result of
     the last one to the given ?VAR identifiers.  FORMALS has the same
     syntax of the 'lambda' formals.

          (define-values (a b c)
            (values 1 2 3))

          (list a b c)    => (1 2 3)

 -- Syntax: define-constant-values FORMALS ?FORM0 ?FORM ...
     Evaluate the given forms and bind the, possibly multiple, result of
     the last one to the given formals identifiers; make the formals
     identifiers immutable.  FORMALS has the same syntax of the 'lambda'
     formals.

          (define-constant-values (a b c)
            (values 1 2 3))

          (list a b c)    => (1 2 3)
          (set! a 99)     error-> &syntax

 -- Syntax: define-inline (?NAME ?ARG ... . ?REST) ?BODY0 ?BODY ...
     Similar to 'define', but create a binding that is always expanded
     inline and can *neither* be invoked recursively *nor* used as
     function rgument.  This syntax only defines a syntax.

          (define-inline (incr x)
            (+ x 1))

          (incr 2)        => 3

     In the example above, we can think of '(incr 2)' as expanding to:

          (let ((x 2))
            (+ x 1))

 -- Syntax: define-inline-constant ?NAME ?EXPR
     ?EXPR is evaluated only once at expand time, the result is returned
     by the macro transformer bound to ?NAME.  It is impossible to
     modify the result of the expansion of ?NAME by acting upon ?NAME.

 -- Syntax: define-integrable (?NAME ?ARG ... . ?REST) ?BODY0 ?BODY ...
     Similar to 'define', but create a binding that is always expanded
     inline and *can* be both invoked recursively and used as function
     argument.  This syntax defines both a syntax and a function.

          (define-integrable (incr x)
            (+ x 1))

          (incr 2)
          => 3

          (map incr '(10 20 30)))
          => (11 21 31)

     In the example above, we can think of '(incr 2)' as expanding to:

          ((lambda (x)
             (+ x 1))
           2)


File: vicare-scheme.info,  Node: iklib syntaxes defstxs,  Next: iklib syntaxes bindings,  Prev: iklib syntaxes defines,  Up: iklib syntaxes

6.8.4 'define-syntax'-like additional syntaxes
----------------------------------------------

 -- Syntax: define-syntax ?NAME
 -- Syntax: define-syntax ?NAME ?TRANSFORMER
 -- Syntax: define-syntax (?NAME ?ARG) ?BODY0 ?BODY ...
     Vicare extends 'define-syntax' as defined by R6RS; it additionally
     accepts the syntax:

          (define-syntax (?NAME ?ARG) ?BODY0 ?BODY ...)
          ==> (define-syntax ?NAME (lambda (?ARG) ?BODY0 ?BODY ...))

     and the syntax:

          (define-syntax ?NAME)
          ==> (define-syntax ?NAME (syntax-rules ()))

     Additionally, when the last form is used:

        * The fluid identifier syntax '__who__' is bound to the quoted
          ?NAME.

        * The fluid syntax '__synner__' is bound to a function we can
          use to raise syntax violation exceptions; the function looks
          as follows:

               (case-define synner
                 ((message)
                  (syntax-violation (quote ?NAME) message ?ARG #f))
                 ((message subform)
                  (syntax-violation (quote ?NAME) message ?ARG subform)))

 -- Syntax: define-constant ?VAR ?EXPR
     Like 'define' but create an immutable binding.

          (define-constant X 1)
          X               => 1
          (set! X 2)      error-> &syntax

 -- Syntax: define-syntax-rule (?NAME ?PATTERN ... . ?REST) ?BODY0 ?BODY
          ...
     Convenience syntax to define a 'syntax-rules' transformer with a
     single clause.  Expand to:

          (define-syntax-rule (?NAME ?PATTERN ... . ?REST)
            ?BODY0 ?BODY ...)
          ==> (define-syntax ?NAME
                (syntax-rules ()
                  ((_ ?PATTERN ... . ?REST)
                   (begin ?BODY0 ?BODY ...))))

 -- Syntax: define-auxiliary-syntaxes ?NAME0 ?NAME ...
     Define auxiliary syntaxes to be used as literal identifiers by
     'syntax-rules', 'syntax-case' and similar macros; expand to:

          (define-syntax ?NAME0 (syntax-rules ()))
          (define-syntax ?NAME  (syntax-rules ()))
          ...

 -- Syntax: define-alias ?ALIAS-ID ?OLD-ID
     Define a new binding for ?ALIAS-ID as an alias for ?OLD-ID, which
     must be a bound identifier in the current lexical environment.

          (let ((a 1))
            (define-alias b a)
            b)
          => 1


File: vicare-scheme.info,  Node: iklib syntaxes bindings,  Next: iklib syntaxes control,  Prev: iklib syntaxes defstxs,  Up: iklib syntaxes

6.8.5 Additional binding syntaxes
---------------------------------

 -- Syntax: receive ?FORMALS ?EXPRESSION ?BODY0 ?BODY ...
     Expect ?EXPRESSION to evaluate to multiple values and bind such
     values as specified by the ?FORMALS; evaluate the ?BODY in the
     region of such bindings.  The expansion is:

          (receive ?FORMALS
              ?EXPRESSION
            ?BODY0 ?BODY ...)
          ==> (call-with-values
                  (lambda ()
                    ?EXPRESSION)
                (lambda ?FORMALS
                  ?BODY0 ?BODY ...))

 -- Syntax: receive-and-return (?RETVAL ...) ?EXPRESSION ?BODY0 ?BODY
          ...
     Expect ?EXPRESSION to evaluate to multiple values and bind such
     values to the identifiers ?RETVAL; evaluate the ?BODY forms in the
     region of such bindings; return the values bound to ?RETVAL.  The
     expansion is:

          (receive-and-return (?RETVAL ...)
              ?EXPRESSION
            ?BODY0 ?BODY ...)
          ==> (call-with-values
                  (lambda ()
                    ?EXPRESSION)
                (lambda (?RETVAL ...)
                  ?BODY0 ?BODY ...
                  (values ?RETVAL ...)))

 -- Syntax: let*-syntax ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
     Similar to 'let-syntax', expands into nested 'let-syntax' forms:

          (let*-syntax () ?BODY0 ?BODY ...)
          ==> (begin ?BODY0 ?BODY ...)

          (let*-syntax ((?LHS ?RHS)) ?BODY0 ?BODY ...)
          ==> (let-syntax ((?LHS ?RHS)) ?BODY0 ?BODY ...)

          (let*-syntax ((?LHS0 ?RHS0)
                        (?LHS ?RHS)
                        ...)
            ?BODY0 ?BODY ...)
          ==> (let-syntax ((?LHS0 ?RHS0))
                (let*-syntax ((?LHS ?RHS) ...) ?BODY0 ?BODY ...))

 -- Syntax: let-constants ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
     Like 'let' but create immutable bindings.  Attempting to mutate the
     bindings with 'set!' will result in an expand time syntax
     violation.

 -- Syntax: let*-constants ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
     Like 'let*' but create immutable bindings.  Attempting to mutate
     the bindings with 'set!' will result in an expand time syntax
     violation.

 -- Syntax: letrec-constants ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
     Like 'letrec' but create immutable bindings.  Attempting to mutate
     the bindings with 'set!' will result in an expand time syntax
     violation.

 -- Syntax: letrec*-constants ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
     Like 'letrec*' but create immutable bindings.  Attempting to mutate
     the bindings with 'set!' will result in an expand time syntax
     violation.


File: vicare-scheme.info,  Node: iklib syntaxes control,  Next: iklib syntaxes loops,  Prev: iklib syntaxes bindings,  Up: iklib syntaxes

6.8.6 Additional control flow syntaxes
--------------------------------------

 -- Syntax: begin0 ?EXPR0 ?EXPR ...
     Evaluate all the expressions in the given order and return the
     return values of ?EXPR0.  This syntax comes from the R6RS original
     document, Appendix A "Formal semantics".

          (begin0
              1
            2)
          => 1

 -- Syntax: xor ?EXPR ...
     Exclusive 'or'.  When expanded with no expressions: evaluate to
     '#f'.

 -- Macro: case-identifiers ?EXPR ?CLAUSE0 ?CLAUSE ...
 -- Auxiliary Syntax: else
 -- Auxiliary Syntax: =>
     Special implementation of 'case' expecting only syntactic
     identifiers as datums; identifiers are compared with
     'free-identifier=?'.  The syntactic identifiers 'else' and '=>'
     must be the syntactic bindings exported by '(rnrs)' and '(vicare)'.

     Each ?CLAUSE must have one of the formats:

          ((?IDENTIFIER0 ?IDENTIFIER ...) ?BODY0 ?BODY ...)
          ((?IDENTIFIER0 ?IDENTIFIER ...) => ?BODY)
          (else ?BODY0 ?BODY ...)
          (else => ?BODY)

     where the 'else' clauses may appear only as last clause.

     ?EXPR must be an expression evaluating to an identifier, otherwise
     the 'else' clause is evaluated.


File: vicare-scheme.info,  Node: iklib syntaxes loops,  Next: iklib syntaxes returnable,  Prev: iklib syntaxes control,  Up: iklib syntaxes

6.8.7 Additional loop syntaxes
------------------------------

* Menu:

* iklib syntaxes loops while::    Iterating with the 'while' syntax.
* iklib syntaxes loops until::    Iterating with the 'until' syntax.
* iklib syntaxes loops for::      Iterating with the 'for' syntax.
* iklib syntaxes loops do::       Iterating with the 'do' syntax.
* iklib syntaxes loops do*::      Iterating with the 'do*' syntax.
* iklib syntaxes loops dolist::   Iterating with the 'dolist' syntax.
* iklib syntaxes loops dotimes::  Iterating with the 'dotimes' syntax.
* iklib syntaxes loops fluids::   Fluid bindings for loop syntaxes.


File: vicare-scheme.info,  Node: iklib syntaxes loops while,  Next: iklib syntaxes loops until,  Up: iklib syntaxes loops

6.8.7.1 Iterating with the 'while' syntax
.........................................

 -- Syntax: while ?TEST ?BODY ...
 -- Auxiliary Syntax: continue
 -- Auxiliary Syntax: break
     If the expression ?TEST evaluates to true: evaluate the body forms
     ?BODY and recurse; else return unspecified values.  In the body:
     the syntax 'continue' causes immediate looping to next iteration,
     starting with the ?TEST; the syntax 'break' causes immediate
     escaping out of the loop.


File: vicare-scheme.info,  Node: iklib syntaxes loops until,  Next: iklib syntaxes loops for,  Prev: iklib syntaxes loops while,  Up: iklib syntaxes loops

6.8.7.2 Iterating with the 'until' syntax
.........................................

 -- Syntax: until ?TEST ?BODY ...
 -- Auxiliary Syntax: continue
 -- Auxiliary Syntax: break
     If the expression ?TEST evaluates to false: evaluate the body forms
     ?BODY and recurse; else return unspecified values.  In the body:
     the syntax 'continue' causes immediate looping to next iteration,
     starting with the ?TEST; the syntax 'break' causes immediate
     escaping out of the loop.


File: vicare-scheme.info,  Node: iklib syntaxes loops for,  Next: iklib syntaxes loops do,  Prev: iklib syntaxes loops until,  Up: iklib syntaxes loops

6.8.7.3 Iterating with the 'for' syntax
.......................................

 -- Syntax: for (?INIT ?TEST ?POST) ?BODY0 ?BODY ...
 -- Auxiliary Syntax: continue
 -- Auxiliary Syntax: break
     This is an iteration syntax similar to the C language 'for':

          (import (vicare))

          (for ((define i 0) (< i 3) (set! i (+ 1 i)))
            (display i)
            (display #\space))
          -| 0 1 2

          (define i)
          (for ((set! i 0) (< i 3) (set! i (+ 1 i)))
            (display i)
            (display #\space))
          -| 0 1 2

          (for ((begin
                  (define i 5)
                  (define j 10))
                (positive? i)
                (begin
                  (set! i (+ -1 i))
                  (set! j (+ -1 j))))
            (display i)
            (display #\space)
            (display j)
            (display #\space))
          -| 5 10 4 9 3 8 2 7 1 6

     The form ?INIT can be a sequence of definitions and expressions; it
     is evaluated first and only once; its return values are discarded.
     The region of bindings defined by ?INIT includes the ?TEST, ?POST
     and ?BODY forms.

     The form ?TEST must be an expression; it is evaluated at the
     beginning of each iteration: if the result is true the next
     iteration takes place, else the loop terminates.

     The forms ?BODY must be expressions; they are evaluated at each
     iteration when the ?TEST evaluates to true; the return values are
     discarded.

     The form ?POST must be an expression; it is evaluated at the end of
     each iteration after the ?BODY forms; the return values are
     discarded.

     The syntax 'continue' can be used in the body to immediately exit
     from the body and jump directly to the evaluation of ?POST.

     The syntax 'break' can be used in the body to immediately break out
     of the loop and return to the continuation of 'for'.


File: vicare-scheme.info,  Node: iklib syntaxes loops do,  Next: iklib syntaxes loops do*,  Prev: iklib syntaxes loops for,  Up: iklib syntaxes loops

6.8.7.4 Iterating with the 'do' syntax
......................................

 -- Syntax: do ?BODY (while ?TEST)
 -- Syntax: do ?BODY (until ?TEST)
 -- Auxiliary Syntax: while
 -- Auxiliary Syntax: until
 -- Auxiliary Syntax: continue
 -- Auxiliary Syntax: break
     These syntaxes extend the built-in 'do' syntax as defined by R6RS.

     For 'do ... (while ...)':

        * Evaluate ?BODY at least once, then: if the expression ?TEST
          evaluates to non-false loop.

        * Using 'continue' in the body cause a direct jump to the end of
          the current iteration, evaluating the ?TEST.

        * Using the syntax 'break' in the body causes immediate escaping
          out of the loop.  A syntax use of 'break' accepts no
          arguments.

        * A use of this syntax returns no values.

     For 'do ... (until ...)':

        * Evaluate ?BODY at least once, then if the expression ?TEST
          evaluates to false loop.

        * Using 'continue' in the body cause a direct jump to the end of
          the current iteration, evaluating the ?TEST.

        * Using the syntax 'break' in the body causes immediate escaping
          out of the loop.  A syntax use of 'break' accepts no
          arguments.

        * A use of this syntax returns no values.

     For the standard syntax:

        * Using 'continue' in the body cause a direct jump to the end of
          the current iteration, evaluating the ?TEST.

        * Using the syntax 'break' in the body causes immediate escaping
          out of the loop.  A syntax use of 'break' accepts no
          arguments.


File: vicare-scheme.info,  Node: iklib syntaxes loops do*,  Next: iklib syntaxes loops dolist,  Prev: iklib syntaxes loops do,  Up: iklib syntaxes loops

6.8.7.5 Iterating with the 'do*' syntax
.......................................

 -- Syntax: do* ((?VARIABLE1 ?INIT1 ?STEP1) ...) (?TEST ?EXPRESSION ...)
          ?COMMAND ...
     This is like the standard 'do' (*note do: stdlib control.), but the
     bindings and steppings are performed sequentially rather than in
     unspecified order.  This syntax meant to be similar to the Common
     Lisp syntax of the same name.


File: vicare-scheme.info,  Node: iklib syntaxes loops dolist,  Next: iklib syntaxes loops dotimes,  Prev: iklib syntaxes loops do*,  Up: iklib syntaxes loops

6.8.7.6 Iterating with the 'dolist' syntax
..........................................

 -- Syntax: dolist (?VAR ?LIST-EXPR) ?BODY0 ?BODY ...
 -- Syntax: dolist (?VAR ?LIST-EXPR ?RESULT-EXPR) ?BODY0 ?BODY ...
     Iterate of the list returned by ?LIST-EXPR binding, at each
     iteration, the next item from the list to ?VAR; evaluate the ?BODY
     forms in the region of the binding.

     If ?RESULT-EXPR is present: it is evaluated, in the region of ?VAR,
     to produce the return values.  If ?RESULT-EXPR is not present: the
     syntax use returns no values.

     If ?LIST-EXPR returns null and ?RESULT-EXPR is present: when
     ?RESULT-EXPR is evaluated, ?VAR is bound to null.

     This syntax meant to be similar to the Common Lisp syntax of the
     same name.

          (import (vicare) (vicare checks))

          (with-result
            (dolist (A '(1 2 3))
              (add-result A)))
          => (#!void (1 2 3))

          (with-result
            (dolist (A '(1 2 3) A)
              (add-result A)))
          => (() (1 2 3))

          (with-result
            (let ((rv #f))
              (dolist (A '(1 2 3) rv)
                (add-result A)
                (when (even? A)
                  (set! rv A)))))
          => (2 (1 2 3))

          (with-result
            (dolist (A '() A)
              (add-result A)))
          => (() ())


File: vicare-scheme.info,  Node: iklib syntaxes loops dotimes,  Next: iklib syntaxes loops fluids,  Prev: iklib syntaxes loops dolist,  Up: iklib syntaxes loops

6.8.7.7 Iterating with the 'dotimes' syntax
...........................................

 -- Syntax: dotimes (?VAR ?COUNT-EXPR) ?BODY0 ?BODY ...
 -- Syntax: dotimes (?VAR ?COUNT-EXPR ?RESULT-EXPR) ?BODY0 ?BODY ...
     Iterate over exact integers from zero to the return value of
     ?COUNT-EXPR, which must return a non-negative exact integer; at
     each iteration: the next integer is bound to ?VAR; evaluate the
     ?BODY forms in the region of the binding.

     If ?RESULT-EXPR is present: it is evaluated, in the region of ?VAR,
     to produce the return values.  If ?RESULT-EXPR is not present: the
     syntax use returns no values.

     This syntax meant to be similar to the Common Lisp syntax of the
     same name.


File: vicare-scheme.info,  Node: iklib syntaxes loops fluids,  Prev: iklib syntaxes loops dotimes,  Up: iklib syntaxes loops

6.8.7.8 Fluid bindings for loop syntaxes
........................................

 -- Fluid Syntax: continue
     Causes the innermost 'do', 'while', 'until' or 'for' loop to jump
     immediately to the next iteration.  Being a fluid syntax: it is
     possible to use this keyword in custom syntaxes.

 -- Fluid Syntax: break
     Causes the innermost 'do', 'while', 'until' or 'for' loop to exit
     immediately to the continuation of the whole loop syntax.  Being a
     fluid syntax: it is possible to use this keyword in custom
     syntaxes.

   Vicare does *not* bind 'break' and 'continue' in uses of the named
'let' syntax; this is because:

   * Named 'let' is a convenience syntax to define a recursive function;
     recursive functions do not have the 'break' and 'continue'
     operators in other languages.  In Scheme, all the loop syntaxes are
     just convenience for a recursive function definition, but the named
     'let' is more so.

   * The operation performed by 'continue' in a named 'let' is just
     performed by calling the function itself.  Calling the function is
     more flexible because it allows tail calls and non-tail calls.

   * The operation performed by 'break' in a recursive function can be
     performed using 'returnable' and 'return' in the body:

          (returnable
            (let loop ()
              ...
              (return)
              ...))

   * By keeping named 'let' clean of fluid bindings, we can more freely
     use it as building block for custom loop syntaxes.


File: vicare-scheme.info,  Node: iklib syntaxes returnable,  Next: iklib syntaxes blocking,  Prev: iklib syntaxes loops,  Up: iklib syntaxes

6.8.8 Early return from code blocks
-----------------------------------

The standardised Scheme languages do not define the common 'return'
keyword present in many languages, like C and Python.  Despite this, it
is quite easy to obtain the "early return" functionality through the use
of continuations:

     (call/cc
         (lambda (return)
           (display 'before)
           (return 1)
           (display 'never)))
     -| before
     => 1

   Many programmers are used to the 'return' keyword, so Vicare includes
some syntaxes to support it.  The use of all these syntaxes involves the
creation of a continuation, which is a performance penalty.

 -- Fluid Syntax: return ?EXPR ...
     This syntax is meant to be used to return from some enclosing
     block, returning the given optional arguments.  Being a fluid
     syntax: it is possible to rebind this keyword in custom syntaxes.

 -- Syntax: returnable ?BODY0 ?BODY ...
     Like 'begin', but allow the use of the keyword 'return' to return
     values to the enclosing continuation.

          (returnable
            (display 'before)
            (return)
            (display 'never))
          -| before

          (returnable
            (display 'before)
            (return 1)
            (display 'never))
          -| before
          => 1

          (returnable
            (display 'before)
            (return 1 2)
            (display 'never))
          -| before
          => 1 2


File: vicare-scheme.info,  Node: iklib syntaxes blocking,  Next: iklib syntaxes dynenv,  Prev: iklib syntaxes returnable,  Up: iklib syntaxes

6.8.9 Blocking raised exceptions
--------------------------------

Sometimes we want to block raised exceptions, for example when we are
already handling a previously raised exception.

 -- Syntax: with-blocked-exceptions ?THUNK
 -- Syntax: with-blocked-exceptions ?EXCEPTION-RETVALS-MAKER ?THUNK
     Evaluate ?THUNK and return its return values.

     When used with one argument: if ?THUNK raises an exception, return
     the raised object.

     When used with two arguments: if ?THUNK raises an exception, apply
     the procedure ?EXCEPTION-RETVALS-MAKER to the raised object and
     return its return values.  Exceptions raised by
     ?EXCEPTION-RETVALS-MAKER are *not* blocked.

   Usage examples:

     (import (vicare))

     (with-blocked-exceptions
       (lambda ()
         (raise 99)))
     => 99

     (with-blocked-exceptions
         (lambda (E)
           (values E 1 2 3))
       (lambda ()
         (raise 99)))
     => 99 1 2 3


File: vicare-scheme.info,  Node: iklib syntaxes dynenv,  Next: iklib syntaxes integrable,  Prev: iklib syntaxes blocking,  Up: iklib syntaxes

6.8.10 Capturing the current dynamic environment
------------------------------------------------

 -- Syntax: with-current-dynamic-environment ?EXCEPTION-RETVALS-MAKER
          ?THUNK
     Install and return a thunk that, wherever it is called, evaluates
     ?THUNK in the dynamic environment of the macro use and returns its
     return values.  If ?THUNK raises an exception: apply the procedure
     ?EXCEPTION-RETVALS-MAKER to the raised object and return its return
     values.

     Exceptions raised by ?EXCEPTION-RETVALS-MAKER are *not* blocked.

   Usage examples:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define parm
       (make-parameter #f))

     (with-result
       (parametrise ((parm 'outer))
         (let* ((counter 0)
                (thunk   (parametrise ((parm 'inner))
                           (with-current-dynamic-environment
                               values
                             (lambda ()
                               (set! counter (+ 1 counter))
                               (add-result (list 'inside-thunk (parm))))))))
           (add-result (parm))
           (add-result 'calling-thunk-1)
           (thunk)
           (add-result 'calling-thunk-2)
           (thunk)
           counter)))
     => (2 (outer
            calling-thunk-1 (inside-thunk inner)
            calling-thunk-2 (inside-thunk inner)))

     (with-result
       (parametrise ((parm 'outer))
         (let* ((counter 0)
                (thunk   (parametrise ((parm 'inner))
                           (with-current-dynamic-environment
                               values
                             (lambda ()
                               (set! counter (+ 1 counter))
                               (add-result (list 'inside-thunk (parm)))
                               (add-result 'raise-exception)
                               (raise 123))))))
           (add-result (parm))
           (add-result 'calling-thunk-1)
           (thunk)
           (add-result 'calling-thunk-2)
           (thunk)
           counter)))
     => (2 (outer
            calling-thunk-1 (inside-thunk inner) raise-exception
            calling-thunk-2 (inside-thunk inner) raise-exception))


File: vicare-scheme.info,  Node: iklib syntaxes integrable,  Next: iklib syntaxes stale,  Prev: iklib syntaxes dynenv,  Up: iklib syntaxes

6.8.11 Integrable expressions and functions
-------------------------------------------

Compilers act upon "compilation units", which for Vicare are: R6RS
libraries, R6RS programs, symbolic expressions handed to 'eval'; the
latter includes standalone expressions typed at the REPL.  Under Vicare:

   * Whenever a function defined in a compilation unit is called in the
     same compilation unit: the compiler has access to the source code,
     so it *always* attempts to integrate it (expand it inline); such
     integration can succeed or fail depending on the cost of such
     operation.

   * Whenever a function defined in a compilation unit is called in
     another compilation unit: the compiler has *no* access to the
     source code, so it never attempts to integrate it.

this scenario is somewhat different from the one of languages like C,
which make use of object files that allow inlining of functions defined
in other files.

   Sometimes we do want to always integrate expressions, even across
compilation unit boundaries; for this purpose Vicare provides
'define-inline' to integrate expressions and 'define-integrable' to
integrate functions.

 -- Syntax: define-inline (?NAME ?ARG ... . ?REST) ?BODY0 ?BODY ...
     Similar to 'define', but create a binding for an expression that is
     always expanded inline and can *neither* be invoked recursively
     *nor* used as function argument.  This syntax only defines a syntax
     embedding the source code of the expression in a syntax object.

          (define-inline (incr x)
            (+ x 1))

          (incr 2)        => 3

     In the example above, we can think of '(incr 2)' as expanding to:

          (let ((x 2))
            (+ x 1))

 -- Syntax: define-integrable (?NAME ?ARG ... . ?REST) ?BODY0 ?BODY ...
     Similar to 'define', but create a binding that is always expanded
     inline and *can* be both invoked recursively and used as function
     argument.  This syntax defines both a syntax and a function, with
     the syntax embedding the source code of the function in a syntax
     object.

          (define-integrable (incr x)
            (+ x 1))

          (incr 2)
          => 3

          (map incr '(10 20 30)))
          => (11 21 31)

     In the example above, we can think of '(incr 2)' as expanding to:

          ((lambda (x)
             (+ x 1))
           2)


File: vicare-scheme.info,  Node: iklib syntaxes stale,  Next: iklib syntaxes body,  Prev: iklib syntaxes integrable,  Up: iklib syntaxes

6.8.12 Declaring compiled library in stale state
------------------------------------------------

 -- Syntax: stale-when ?STALE-EXPR ?BODY0 ?BODY ...
     Act like 'begin', but in addition causes an expression,
     ?STALE-EXPR, to be registered in the state of a compiled library.
     When such expression evaluates to false: the compiled library is
     stale with respect to some source file.  See for example the
     'include' syntax.


File: vicare-scheme.info,  Node: iklib syntaxes body,  Next: iklib syntaxes try,  Prev: iklib syntaxes stale,  Up: iklib syntaxes

6.8.13 Internal body
--------------------

 -- Syntax: internal-body ?DEFINITION ... ?EXPR0 ?EXPR ...
     Delimits an internal body, evaluating the definitions and then the
     expression.  This syntax must be used in expression context.

          (import (vicare))

          (let ()
            (define a 1)
            (display a)
            (internal-body
              (define b 2)
              (define c 3)
              (display a)
              (display b)
              (display c)))
          -| 1123


File: vicare-scheme.info,  Node: iklib syntaxes try,  Next: iklib syntaxes splice1st,  Prev: iklib syntaxes body,  Up: iklib syntaxes

6.8.14 The 'try', 'catch', 'finally' syntaxes
---------------------------------------------

The syntax 'try' can be used to handle raised exceptions in addition to
the R6RS-defined syntaxes 'with-exception-handler' and 'guard'.  The
syntax is basically a wrapper for 'guard' from '(rnrs exceptions (6))'
(*note guard::).

 -- Syntax: try ?BODY ?CATCH-CLAUSES
 -- Syntax: try ?BODY ?CATCH-CLAUSES ?FINALLY-CLAUSE
 -- Syntax: try ?BODY ?FINALLY-CLAUSE
 -- Auxiliary Syntax: catch
 -- Auxiliary Syntax: finally
 -- Auxiliary Syntax: else
     Evaluate the form ?BODY and return its results.  If no exceptions
     are raised by ?BODY: before returning evaluate the ?FINALLY-CLAUSE.
     If an exception is raised by ?BODY: handle it with the
     ?CATCH-CLAUSES and, before returning, evaluate the ?FINALLY-CLAUSE.

     The ?CATCH-CLAUSES argument must have the format:

          (catch ?VAR ?CATCH-CLAUSE0 ?CATCH-CLAUSE ...)

     where ?VAR must be an identifier and every ?CATCH-CLAUSE has one of
     the forms:

          (?PRED ?TAG-BODY0 ?TAG-BODY ...)
          (else ?ELSE-BODY0 ?ELSE-BODY ...)

     where the optional 'else' clause must appear only once as last one.
     The ?PRED argument must have one of the following recursive
     formats:

          ?PRED = (?TAG)
                | (and ?INNER-PRED0 ?INNER-PRED ...)
                | (or  ?INNER-PRED0 ?INNER-PRED ...)
                | (xor ?INNER-PRED0 ?INNER-PRED ...)
                | (not ?INNER-PRED)

          ?INNER-PRED = ?TAG
                      | (and ?INNER-PRED0 ?INNER-PRED ...)
                      | (or  ?INNER-PRED0 ?INNER-PRED ...)
                      | (xor ?INNER-PRED0 ?INNER-PRED ...)
                      | (not ?INNER-PRED)

     where: ?TAG is a condition object type identifier; 'and', 'or',
     'xor', 'not' are the identifiers exported by '(vicare)'.

     The ?FINALLY-CLAUSE must have the format:

          (finally ?FINALLY-BODY0 ?FINALLY-BODY ...)

     when the 'finally' clause is present: the ?BODY is wrapped into an
     unwind-protection syntax, *Note The unwind-protection mechanism:
     iklib unwind-protect.

     The following expansions take place:

        * No else, no finally.

               (try
                  ?BODY
                 (catch ?VAR
                   ((?TAG)
                    ?TAG-BODY0
                    ?TAG-BODY
                    ...)
                   ...))
               ==> (guard (?VAR
                             ((is-a? ?VAR)
                              ?TAG-BODY0
                              ?TAG-BODY
                              ...)
                             ...)
                     ?BODY)

        * Else, no finally.

               (try
                  ?BODY
                 (catch ?VAR
                   ((?TAG)
                    ?TAG-BODY0
                    ?TAG-BODY
                    ...)
                   ...)
                   (else
                    ?ELSE-BODY0
                    ?ELSE-BODY
                    ...))
               ==> (guard (?VAR
                             ((is-a? ?VAR ?TAG0)
                              ?TAG-BODY0
                              ?TAG-BODY
                              ...)
                              ...
                             (else
                              ?ELSE-BODY0
                              ?ELSE-BODY
                              ...))
                     ?BODY)

        * Finally, no else.

               (try
                  ?BODY
                 (catch ?VAR
                   ((?TAG)
                    ?TAG-BODY0
                    ?TAG-BODY
                    ...)
                   ...)
                 (finally
                   ?FINALLY-BODY0
                   ?FINALLY-BODY
                   ...))
               ==> (with-unwind-protection
                       (lambda (dummy)
                         ?FINALLY-BODY0
                         ?FINALLY-BODY
                         ...)
                     (lambda ()
                       (guard (?VAR
                               ((is-a? ?VAR ?TAG0)
                                ?TAG-BODY0
                                ?TAG-BODY
                                ...)
                               ...)
                           ?BODY)))

        * Finally, no catch.

               (try
                   ?BODY
                 (finally
                   ?FINALLY-BODY0
                   ?FINALLY-BODY
                   ...))
               ==> (with-unwind-protection
                       (lambda (dummy)
                         ?FINALLY-BODY0
                         ?FINALLY-BODY
                         ...)
                     (lambda ()
                       ?BODY))

   Some usage examples without the 'finally' clause:

     (import (vicare))

     (define-condition-type &this
         &error
       make-this-condition
       condition-this?
       (a condition-this.a)
       (b condition-this.b)
       (c condition-this.c))

     (define (doit thunk)
       (try
           (thunk)
         (catch E
           ((&this)
            (list (condition-this.a E)
                  (condition-this.b E)
                  (condition-this.c E)))
           ((&message)
            (condition-message E))
           (else E))))

     (doit (lambda ()
             (raise (make-this-condition 1 2 3))))
     => (1 2 3)

     (doit (lambda ()
             (raise (make-message-condition "ciao"))))
     => "ciao"

     (doit (lambda ()
             (raise 123)))
     => 123

   Evaluation order tracking for 'finally' clauses:

     (with-result
       (try
           (add-result 'body)
         (catch E
           ((&error)   (add-result 'catch-error))
           ((&warning) (add-result 'catch-warning))
           (else       (add-result 'catch-else)))
         (finally
          (add-result 'finally))))
     => (body (body finally))

     (with-result
       (try
           (begin
             (add-result 'body)
             (raise (make-warning)))
         (catch E
           ((&error)   (add-result 'catch-error))
           ((&warning) (add-result 'catch-warning))
           (else       (add-result 'catch-else)))
         (finally
          (add-result 'finally))))
     => (catch-warning (body catch-warning finally))


File: vicare-scheme.info,  Node: iklib syntaxes splice1st,  Next: iklib syntaxes infix,  Prev: iklib syntaxes try,  Up: iklib syntaxes

6.8.15 Splice first form syntax
-------------------------------

 -- Syntax: splice-first-expand ?FORM
     When the use of a 'splice-first-expand' syntax appears as first
     subform of an enclosing form, ?FORM must have the format:

          (?RATOR ?RAND ...)

     and it is spliced in the enclosing form, then the result is
     expanded:

          ((splice-first-expand (?RATOR ?RAND ...) ?ARG ...)
          ==> (?RATOR ?RAND ... ?ARG ...)

     When the use of a 'splice-first-expand' syntax appears as second or
     subsequent subform: it expands into ?FORM itself, which is then
     expanded:

          (splice-first-expand ?FORM)
          ==> ?FORM

     This syntax must be used with care.

   Usage examples:

     (import (vicare))

     (splice-first-expand 123)               => 123
     (splice-first-expand (+ 1 2))           => 3

     ((splice-first-expand (+)) 1 2)           => 3
     ((splice-first-expand (+) 1 2) 3 4)       ==> (+ 1 2 3 4)

     (let-syntax ((doit (syntax-rules ()
                          ((_ ?arg ...)
                           (+ (square ?arg) ...)))))
       ((splice-first-expand (doit 1 2)) 3 4))
     ==> (+ (square 1) (square 2) (square 3) (square 4))

     (let-syntax ((arg1 (identifier-syntax 1))
                  (arg2 (identifier-syntax 2))
                  (doit (syntax-rules ()
                          ((_ ?arg ...)
                           (+ (square ?arg) ...)))))
       ((splice-first-expand (doit arg1 arg2)) 3 4))
     ==> (+ (square 1) (square 2) (square 3) (square 4))

     (let*-syntax ((arg1 (identifier-syntax 1))
                   (arg2 (identifier-syntax 2))
                   (doit (syntax-rules ()
                           ((_ ?arg ...)
                            (+ (square ?arg) ...))))
                   (flop (syntax-rules ()
                           ((_ ?arg ...)
                            (splice-first-expand
                             (doit arg1 ?arg ...))))))
       ((flop arg2) 3 4))
     ==> (+ (square 1) (square 2) (square 3) (square 4))

     (let*-syntax ((arg1 (identifier-syntax 1))
                   (arg2 (identifier-syntax 2))
                   (doit (syntax-rules ()
                           ((_ ?arg ...)
                            (+ (square ?arg) ...))))
                   (flop (syntax-rules ()
                           ((_ ?arg ...)
                            (splice-first-expand
                             (doit arg1 ?arg ...)))))
                   (flip (syntax-rules ()
                           ((_ ?arg ...)
                            (flop ?arg ...)))))
       ((flip arg2) 3 4))
     ==> (+ (square 1) (square 2) (square 3) (square 4))


File: vicare-scheme.info,  Node: iklib syntaxes infix,  Next: iklib syntaxes increments,  Prev: iklib syntaxes splice1st,  Up: iklib syntaxes

6.8.16 Infix to prefix transformer
----------------------------------

 -- Syntax: infix ?OBJ ...
     The 'infix' macro converts the traditional infix notation for
     mathematical expressions to the equivalent Scheme's prefix
     notation.  'infix' expands to a prefix expression to be evaluated
     at run-time, in the lexical context of the macro use; as a special
     case '(infix)' is equivalent to '(values)'.

   The macro allows us to evaluate forms like:

     (infix atan(1, 2))      ==> (atan 1 2)
     (infix 1 + 2 + 3)       ==> (+ (+ 1 2) 3)
     (infix 1 + 2 * 3)       ==> (+ 1 (* 2 3))
     (infix (1 + 2) * 3)     ==> (* (+ 1 2) 3)

     (infix 2 expt 3 expt 4) ==> (expt 2 (expt 3 4))
     (infix 2 ** 3 ** 4)     ==> (expt 2 (expt 3 4))

     (infix - 5)             ==> (- 5)
     (infix + 5)             ==> (+ 5)
     (infix 5 !)             ==> (factorial 5)

     (infix 1 > 2 ? 3 + 4 : 5 * 6)
     ==> (if (> 1 2) (+ 3 4) (* 5 6))

     (define a 1)
     (define b 2)
     (define c 3)
     (infix cos(a) * tan(b) / c)
     ==> (/ (* (cos a) (tan b)) c)

* Menu:

* iklib syntaxes infix syntax:: Notes on the supported syntax.
* iklib syntaxes infix prec::   Operators precedence.
* iklib syntaxes infix notes::  Random notes on the features.


File: vicare-scheme.info,  Node: iklib syntaxes infix syntax,  Next: iklib syntaxes infix prec,  Up: iklib syntaxes infix

6.8.16.1 Notes on the supported syntax
......................................

Some expression syntax interpretation rules:

   * Any Scheme value can be element of the input form; numbers and all
     the other values are just put there as operands.

          #!vicare
          (infix list("ciao", 'hello, '#ve(ascii "salut")))
          => ("ciao" hello #ve(ascii "salut"))

   * The following bound identifiers exported by '(vicare)' are
     interpreted as binary infix operators:

          + - * / div div0 mod mod0 expt
          fl+ fl- fl* fl/ flexpt
          fx+ fx- fx* fxdiv fxdiv0 fxmod fxmod0
          < > <= >= = !=
          fx<? fx>? fx<=? fx>=? fx=?
          fl<? fl>? fl<=? fl>=? fl=?
          eq? eqv? equal?
          and or xor
          bitwise-and bitwise-ior bitwise-xor
          bitwise-arithmetic-shift-left
          bitwise-arithmetic-shift-right
          fxand fxior fxxor
          fxarithmetic-shift-left
          fxarithmetic-shift-right

     in addition the following identifiers are recognised by their
     symbol name and interpreted as aliases of binary infix operators:

          &&              ==> and
          \x23D0;\x23D0;  ==> or
          \x00AC;         ==> not
          \x2227;         ==> and
          \x2228;         ==> or
          \x22BB;         ==> xor
          ==              ==> =
          <>              ==> !=
          \x00D7;         ==> *
          \x22C5;         ==> *
          **              ==> expt
          %               ==> mod
          &               ==> bitwise-and
          \x23D0;         ==> bitwise-ior
          ^               ==> bitwise-xor
          <<              ==> bitwise-arithmetic-shift-left
          >>              ==> bitwise-arithmetic-shift-right

     where the symbols with escape sequences are:

     '\x00AC;'
          Unicode character not sign.

     '\x00D7;'
          Unicode character times.

     '\x2227;'
          Unicode character logical and.

     '\x2228;'
          Unicode character logical or.

     '\x22BB;'
          Unicode character xor.

     '\x22C5;'
          Unicode character dot operator.

     '\x23D0;'
          Unicode character vertical bar extension.

   * The following bound identifiers exported by '(vicare)' are
     interpreted as unary prefix operators:

          + - ++ --
          fx+ fx- fl+ fl-
          not bitwise-not fxnot

     in addition the following identifiers are recognised by their
     symbol name and interpreted as aliases of unary prefix operators:

          !       ==> not
          ~       ==> bitwise-not

   * The following bound identifiers exported by '(vicare)' are
     interpreted as unary postfix operators:

          ++ --

     in addition the following identifiers are recognised by their
     symbol name and interpreted as aliases of unary postfix operators:

          !       ==> factorial

   * Almost all the binary infix operators are left-associative with the
     exception of 'expt' and 'flexpt' which are right-associative:

          ;; left-associative
          (infix 10 - 5 - 3)              ==> (- (- 10 5) 3)
          (infix 10 - 5 - 3)              ==> (- 10 5 3)
          (infix 10 / 5 / 3)              ==> (/ (/ 10 5) 3)
          (infix 10 / 5 / 3)              ==> (/ 10 5 3)

          ;; right-associative
          (infix 10 expt 5 expt 3)        ==> (expt 10 (expt 5 3))

   * The identifiers '++' and '--' are unary operators that can be
     applied to expressions both in prefix and postfix positions.  They
     expand as follows:

          #!vicare
          (infix ++ X)            ==> (pre-incr! X)
          (infix -- X)            ==> (pre-decr! X)
          (infix X ++)            ==> (post-incr! X)
          (infix X --)            ==> (post-decr! X)

     where 'pre-incr!', 'pre-decr!', 'post-incr!' and 'post-decr!' are
     the bindings exported by '(vicare)'.

   * The ternary conditional operator involves the identifiers '?' and
     ':', which are recognised by their symbol name.

          (infix 1 > 2 ? 3 + 4 : 5 * 6)
          ==> (if (> 1 2) (+ 3 4) (* 5 6))

   * Identifiers which are not operators are interpreted as variable
     references.

   * If an identifier is followed by a left parenthesis: it is
     interpreted as the binding of a procedure in a procedure
     application.  Procedure application requires the arguments to be
     grouped in a list, using the comma as separator.

          (define (fun a b c)
            (+ a b c))

          (infix fun (1, 2, 3))   ==> (fun 1 2 3)

          *NOTE* The Scheme reader transforms the sequence:

               , ?FORM

          into:

               (unsyntax ?FORM)

          so the list of arguments is:

               ( ?ARG1 (unsyntax ?ARG) ... )

          R6RS does not define the comma to be a delimiter, so writing:

               func (?ARG1, ?ARG, ...)

          with no space between the ?ARG and the comma is a syntax error
          in strict R6RS implementations.  Vicare extends the reader to
          handle the comma as a delimiter, so the above expression is
          valid in the 'infix' syntax.

   * The identifiers 'quote', 'quasiquote', 'syntax' and 'quasisyntax'
     are not subject to infix to prefix conversion; the use of such
     syntaxes just expands to the prefix object:

          (infix (quote       ciao))  ==> (quote ciao)
          (infix (quasiquote  ciao))  ==> (quasiquote ciao)
          (infix (syntax      ciao))  ==> (syntax ciao)
          (infix (quasisyntax ciao))  ==> (quasisyntax ciao)

   * Matched left and right round parentheses are used to group
     subexpressions, overriding operators precedence rules.


File: vicare-scheme.info,  Node: iklib syntaxes infix prec,  Next: iklib syntaxes infix notes,  Prev: iklib syntaxes infix syntax,  Up: iklib syntaxes infix

6.8.16.2 Operators precedence
.............................

To determine sensible precedences for operators, we make the following
observations:

   * Logical operators ('and', 'or', 'not', ...) are meant to be applied
     to predicate operand expressions and they return a boolean value.

   * Numeric comparison operators ('=', '<', '>', ...) are meant to be
     applied to numeric operand expressions and they return a boolean
     value.

   * Arithmetic operators ('+', '-', '*', '/', ...) are meant to be
     applied to numeric operand expressions and they return a numeric
     value.

   * The C language has established a tradition of writing expressions
     containing bitwise operators '1 & 2 + ~ 3' meaning '(1 & 2) + (~
     3)', in which bitwise operators take precedence over every other
     operator.

   * It makes sense to write expressions like '1 < i and i < 4' meaning
     '(1 < i) and (i < 4)', because it makes no sense to interpret it as
     '1 < (i and i) < 4'.

   * It makes sense to write expressions like '1 + 2 < 3 + 4' meaning
     '(1 + 2) < (3 + 4)', because it makes no sense to interpret it as
     '1 + (2 < 3) + 4'.

   So Vicare defines operators precedence as follows, from high
precedence to low precedence:

  1. Procedure application: the left parenthesis preceeded by an
     identifier starts a procedure application.

  2. Binary infix bitwise shift operators:

          bitwise-arithmetic-shift-left
          bitwise-arithmetic-shift-right
          fxarithmetic-shift-left
          fxarithmetic-shift-right

  3. Unary prefix bitwise operators:

          bitwise-not fxnot

  4. Binary infix bitwise operators:

          bitwise-and bitwise-ior bitwise-xor
          fxand fxior fxxor

  5. Unary prefix arithmetic operators:

          + - ++ -- fx+ fx- fl+ fl-

  6. Unary postfix arithmetic operators:

          ++ -- !

  7. Binary infix arithmetic exponentiation operators:

          expt flexpt

  8. Binary infix arithmetic modulo operators:

          mod mod0 fxmod fxmod0

  9. Binary infix multiplication and division arithmetic operators:

          * / div div0 fl* fl/ fx* fxdiv fxdiv0

  10. Binary infix addition and subtraction arithmetic operators:

          + - fl+ fl- fx+ fx-

  11. Comparison operators:

          < > <= >= = !=
          fx<? fx>? fx<=? fx>=? fx=?
          fl<? fl>? fl<=? fl>=? fl=?
          eq? eqv? equal?

  12. Unary prefix logical operators:

          not

  13. Binary infix logical operators:

          and or xor

  14. Ternary conditional operator '... ? ... : ...'.

  15. Procedure application arguments separator, which is the comma.

   Here some expansion examples:

     (infix ! 2 + 3)         ==> (not (2 + 3))
     (infix (! 2) + 3)       error-> expected numeric argument

     (infix fxnot 3)         => -3
     (infix fxnot 3 + 10)    => 7

     (infix ! cos(3))        ==> (not (cos 3))


File: vicare-scheme.info,  Node: iklib syntaxes infix notes,  Prev: iklib syntaxes infix prec,  Up: iklib syntaxes infix

6.8.16.3 Random notes on the features
.....................................

About the exponentiation and bitwise XOR operators
..................................................

The 'infix' macro uses '**' as exponentiation operator and '^' as
bitwise XOR operator; this is controversial because a lot of people,
especially LaTeX users, is used to think of '^' as exponentiation
operator.  The C language has established a tradition to interpret '^'
as bitwise exclusive OR operator, and the Python language has adopted
it; Vicare sticks to it, too.

About the vertical bar
......................

The C language has established a tradition of interpreting the single
vertical bar '|' as bitwise inclusive OR operator and the double
vertical bar as '||' as logical inclusive OR operator.

   In the R6RS Scheme language the vertical bar is used in the block
comments delimiters '#| ... |#'.  Vicare's source code reader uses the
vertical bar to specify symbols whose name does not comply with R6RS,
*note Miscellaneous additional syntaxes: iklib reader misc.  Some text
editors for software programmers handle the vertical bar specially in
Scheme mode, in particular for syntax highlighting.

   It would be possible to extend Vicare's reader to allow '|' and '||'
to be symbols, but, at present, this confuses some text editors in a way
that is not easy to fix.  So, for now, rather than the vertical bar,
'infix' recognises the Unicode character vertical bar extension
('\x23D0;') as bitwise inclusive OR and the double vertical bar
extension as logical inclusive OR.


File: vicare-scheme.info,  Node: iklib syntaxes increments,  Next: iklib syntaxes delimcc,  Prev: iklib syntaxes infix,  Up: iklib syntaxes

6.8.17 Incrementing and decrementing
------------------------------------

 -- Syntax: ++ ?EXPR
 -- Syntax: ++ ?EXPR ?STEP
     Increment ?EXPR by ?STEP and return the result.  Both ?EXPR and
     ?STEP must be expressions evaluating to a number object; when ?STEP
     is not given: it defaults to the fixnum '1'.

     As special case, when ?EXPR is an identifier: the syntax expands as
     follows:

          #!vicare
          (++ ?ID ?STEP)
          ==> (begin
                (set! ?ID (+ ?ID ?STEP))
                ?ID)

 -- Syntax: pre-incr! ?EXPR
 -- Syntax: pre-incr! ?EXPR ?STEP
     Alias for '++'.

 -- Syntax: post-incr! ?EXPR
 -- Syntax: post-incr! ?EXPR ?STEP
     Increment ?EXPR by ?STEP and return the result.  Both ?EXPR and
     ?STEP must be expressions evaluating to a number object; when ?STEP
     is not given: it defaults to the fixnum '1'.

     As special case, when ?EXPR is an identifier: the syntax expands as
     follows:

          (post-incr! ?ID ?STEP)
          ==> (receive-and-return (v)
                  ?ID
                (set! ?ID (+ ?ID ?STEP)))

 -- Syntax: '--' ?EXPR
 -- Syntax: '--' ?EXPR ?STEP
     Decrement ?EXPR by ?STEP and return the result.  Both ?EXPR and
     ?STEP must be expressions evaluating to a number object; when ?STEP
     is not given: it defaults to the fixnum '1'.

     As special case, when ?EXPR is an identifier: the syntax expands as
     follows:

          #!vicare
          (-- ?ID ?STEP)
          ==> (begin
                (set! ?ID (- ?ID ?STEP))
                ?ID)

 -- Syntax: pre-decr! ?EXPR
 -- Syntax: pre-decr! ?EXPR ?STEP
     Alias for '--'.

 -- Syntax: post-decr! ?EXPR
 -- Syntax: post-decr! ?EXPR ?STEP
     Decrement ?EXPR by ?STEP and return the result.  Both ?EXPR and
     ?STEP must be expressions evaluating to a number object; when ?STEP
     is not given: it defaults to the fixnum '1'.

     As special case, when ?EXPR is an identifier: the syntax expands as
     follows:

          (post-decr! ?ID ?STEP)
          ==> (receive-and-return (v)
                  ?ID
                (set! ?ID (- ?ID ?STEP)))


File: vicare-scheme.info,  Node: iklib syntaxes delimcc,  Next: iklib syntaxes misc,  Prev: iklib syntaxes increments,  Up: iklib syntaxes

6.8.18 Delimited continuations
------------------------------

 -- Syntax: reset ?BODY
     Sets the limit for the delimited continuation and evaluate the
     expression ?BODY.

 -- Syntax: shift ?VAR ?BODY
     Capture the current continuation up to the innermost 'reset' syntax
     use.  The escape function of the delimited continuation is bound to
     ?VAR, the the expression ?BODY is evaluated.

   Examples:

     (+ 1 (reset 2))
     => 3

     (reset (* 2 (shift K (K 3))))
     => 6

     (+ 1 (reset (* 2 (shift K (K 3)))))
     => 7

     (reset (* 2 (shift K (K (K 2)))))
     => 8

     (reset (* 2 (shift K (K (K (K 2))))))
     => 16


File: vicare-scheme.info,  Node: iklib syntaxes misc,  Next: iklib syntaxes properties,  Prev: iklib syntaxes delimcc,  Up: iklib syntaxes

6.8.19 Miscellaneous syntaxes
-----------------------------

 -- Syntax: endianness ?ENDIANNESS-SYMBOL
     Extend the syntax defined by R6RS.  The name of ?ENDIANNESS-SYMBOL
     must be a symbol describing an endianness.  Supported symbols are
     'big', 'little', 'network' an 'native'; 'network' is converted to
     'big', 'native' is converted to the return value of
     '(native-endianness)'.

 -- Fluid Syntax: __who__
     A fluid syntax to be bound to the quoted name of the function being
     executed; it can be used as argument for the '&who' condition
     object.  It is meant to be used as follows:

          (define (func arg)
            (fluid-let-syntax
                ((__who__ (identifier-syntax (quote func))))
              ---))

 -- Fluid Syntax: __synner__
     A fluid syntax to be bound to the synner function in syntax
     transformers.

 -- Fluid Syntax: this
     A fluid syntax to be bound to the "subject" of a method procedure.
     It is meant to be used as follows: given the record method
     definition:

          (define-record-type <duo>
            (fields one two)
            (method (add)
              (+ (.one this) (.two this))))

     the method's implementation procedure is defined as:

          (define (<duo>-add {subject <duo>})
            (fluid-let-syntax
                ((this (make-synonym-transformer #'subject)))
              (+ (.one this) (.two this))))

 -- Identifier Syntax: __file__
     Expand to a quoted string representing the source code location,
     for example the source file pathname.

 -- Identifier Syntax: __line__
     Expand to '#f' or a number representing the line number.

 -- Fluid Syntax: brace
     A fluid syntax which is free to be bound to whatever user code
     needs.  When the Scheme code reader is in '#!vicare' mode: brace
     lists are read as 'brace' forms as follows:

          {}              ==> (brace)
          {1 2 3}         ==> (brace 1 2 3)
          {1 . 2}         ==> (brace 1 . 2)

 -- Fluid Syntax: <>
     A fluid syntax which is free to be bound to whatever user code
     needs.  It is meant to be a placeholder for some expression defined
     by the local context; for example: it is used by the syntaxe
     'is-a?'

 -- Syntax: begin-for-syntax ?BODY0 ?BODY ...
     Evaluate the ?BODY forms at expand time; these syntaxes count as
     definitions in a body.  Notice that definitions in the body are
     visible by other code evaluated for expand:

          (begin-for-syntax
            (define a 1))

          (begin-for-syntax
            (define b 2))

          (begin-for-syntax
            (define c (+ a b)))

          (define-syntax (doit stx)
            #`(quote (#,a #,b #,c)))

          (doit)          => (1 2 3)

 -- Syntax: expand-time-expr ?EXPR
     Evaluated the expression ?EXPR at expand-time, expecting it to
     return a syntax object; then expand such syntax object and insert
     the result in the invoke code.  This syntax can be used both in
     definition context and in expression context.

          (expand-time-expr 1)
          ==> 1

          (expand-time-expr #'1)
          ==> 1

          (expand-time-expr #'(define a 1))
          a   => 1

 -- Syntax: set-cons! ?WHO ?OBJ
     Expand to:

          (set! ?WHO (cons ?OBJ ?WHO))

 -- Syntax: values->list ?EXPR
     Evaluate the expression and return its return values as a list.
     Examples:

          (values->list 123)
          => (123)

          (values->list (values 1 2 3))
          => (1 2 3)


File: vicare-scheme.info,  Node: iklib syntaxes properties,  Next: iklib syntaxes expansion-of,  Prev: iklib syntaxes misc,  Up: iklib syntaxes

6.8.20 Syntactic binding properties
-----------------------------------

It is sometimes useful to attach properties to syntactic bindings; the
following API does so.  The following functions will fail if the
argument ID is not a bound identifier.

 -- Function: syntactic-binding-putprop ID KEY VALUE
     Like 'putprop' for symbols, but set a property for the identifier
     ID.  KEY must be a symbol; VALUE can be any values.  Return
     unspecified values.

 -- Function: syntactic-binding-getprop ID KEY
     Like 'getprop' for symbols, but retrieve a property for the
     identifier ID.  KEY must be a symbol.  Return the property value or
     '#f' if the property is not set.

 -- Function: syntactic-binding-remprop ID KEY
     Like 'remprop' for symbols, but remove a property for the
     identifier ID; nothing happens if the property is not set.  KEY
     must be a symbol.  Return unspecified values.

 -- Function: syntactic-binding-property-list ID
     Like 'property-list' for symbols, but retrieve the property list
     for the identifier ID.  Return the property list or null if no
     property is set.

   We have to remember that when evaluating the syntax:

     (define-syntax ?LHS ?RHS)

the identifier ?LHS is already bound when the expression ?RHS is
evaluated to acquire the transformer function; the same happens for:

     (letrec-syntax ((?LHS ?RHS))
       ?BODY)

but it does *not* happen for:

     (let-syntax ((?LHS ?RHS))
       ?BODY)

when the expression ?RHS is evaluated, the identifier ?LHS is still
unbound.

   So the following example will work:

     (define-syntax ciao
       (let ()
         (syntactic-binding-putprop #'ciao 'a 123)
         (lambda (stx) #t)))

     (define-syntax (doit stx)
       (syntactic-binding-getprop #'ciao 'a))

     (doit)          => 123

notice that here the syntax 'ciao' is never used; the following example
will also work:

     (define-syntax (ciao stx)
       #t)

     (define-syntax (doit stx)
       (syntactic-binding-getprop #'ciao 'a))

     (begin-for-syntax
       (syntactic-binding-putprop #'ciao 'a 123))

     (doit)          => 123

and the following will work, too:

     (letrec-syntax
         ((ciao (let ()
                  (syntactic-binding-putprop #'ciao 'a 123)
                  (lambda (stx) #t))))
       (define-syntax (doit stx)
         (syntactic-binding-getprop #'ciao 'a))
       (doit))
     => 123

to define a binding property for a syntax defined by 'let-syntax' we can
do:

     (let-syntax ((ciao (lambda (stx) #t)))
       (define-syntax (doit stx)
         (syntactic-binding-getprop #'ciao 'a))
       (begin-for-syntax
         (syntactic-binding-putprop #'ciao 'a 123))
       (doit))
     => 123

   To define a binding property for a lexical variable bound by
'define':

     (define ciao "ciao")

     (define-syntax (doit stx)
       (syntactic-binding-getprop #'ciao 'a))

     (begin-for-syntax
       (syntactic-binding-putprop #'ciao 'a 123))

     (doit)          => 123

and for one bound by 'let':

     (let ((ciao "ciao"))
       (define-syntax (doit stx)
         (syntactic-binding-getprop #'ciao 'a))
       (begin-for-syntax
         (syntactic-binding-putprop #'ciao 'a 123))
       (doit))
     => 123


File: vicare-scheme.info,  Node: iklib syntaxes expansion-of,  Next: iklib syntaxes optim-of,  Prev: iklib syntaxes properties,  Up: iklib syntaxes

6.8.21 Inspecting expansion results
-----------------------------------

 -- Syntax: expansion-of ?EXPR
     This syntax is mostly for interactive use.  Fully expand the given
     expression in the current lexical environment and return a symbolic
     expression representing the resulting invoke code.  The expression
     is *not* evaluated, only expanded; this means that the expansion
     side effects are performed.

     As a special case if ?EXPR is recognised as a 'define' or 'define*'
     syntax use:

          (define  . ?STUFF)
          (define* . ?STUFF)

     the expansion will be performed as if ?EXPR is:

          (internal-body (define  . ?STUFF) (void))
          (internal-body (define* . ?STUFF) (void))

     and the definition extracted from the result and reformatted.

     Example session at the REPL:

          vicare> (import (vicare expander tags))
          vicare> (print-gensym #f)

          vicare> (expansion-of (+ 1 2))
          $1 = ((primitive +) (quote 1) (quote 2))

          vicare> (expansion-of (lambda (a b) (+ a b)))
          $1 = (lambda (a b) ((primitive +) a b))

          vicare> (internal-body
                    (define-syntax (doit stx)
                      (syntax-case stx ()
                        ((_ ?a ?b)
                         #'(vector ?a ?b))))
                    (expansion-of (doit 1 2)))
          $1 = ((primitive vector) (quote 1) (quote 2))

          vicare> (expansion-of (define (fun a) (+ 1 a)))
          $1 = (define fun (lambda (a) ((primitive +) (quote 1) a)))

 -- Syntax: visit-code-of ?MACRO-ID
     This syntax is mostly for interactive use.  Given the identifier of
     a locally defined macro keyword: expand into a quoted symbolic
     expression representing the expanded macro transformer.

     Example session at the REPL:

          vicare> (print-gensym #f)
          vicare> (define-syntax syn (lambda (stx) #'(void)))
          vicare> (visit-code-of syn)
          $1 = (lambda (stx) #<syntax expr=(void))

 -- Syntax: expansion-of* ?EXPR0 ?EXPR ...
     Like 'expansion-of', but wrap the input expression as follows:

          (internal-body ?EXPR0 ?EXPR ... (void))

     this allows the expansion of definition forms.


File: vicare-scheme.info,  Node: iklib syntaxes optim-of,  Next: iklib syntaxes assembly-of,  Prev: iklib syntaxes expansion-of,  Up: iklib syntaxes

6.8.22 Inspecting optimisation results
--------------------------------------

 -- Syntax: optimisation-of ?EXPR
     This syntax is mostly for interactive use.  Fully expand the given
     expression in the current lexical environment and apply the
     compiler's optimisator to the resulting core language expression;
     return a symbolic expression representing the resulting invoke
     code.  The expression is *not* evaluated, only expanded and
     optimised; this means that the expansion side effects are
     performed.

          *NOTE* Only expressions are expanded and optimised.  It makes
          no sense to give a standalone 'define' syntax to this macro;
          when a standalone function definition is expanded and
          optimised: the function is never called, so it is removed.

     Example session at the REPL:

          vicare> (print-gensym #f)

          vicare> (optimisation-of (+ 1 2))
          $1 = 3

          *NOTE* The level of optimisation of source code is configured
          by the '-O' options; '-O0' turns off the source optimiser.
          The default is equivalent to '-O2'.

 -- Syntax: optimisation-of* ?EXPR0 ?EXPR ...
     Like 'optimisation-of', but wrap the input expression as follows:

          (internal-body ?EXPR0 ?EXPR ... (void))

     this allows the expansion and optimisation of definition forms.
     Example of REPL session:

          vicare> (pretty-width 65)
          vicare> (print-gensym #f)
          vicare> (optimisation-of*
             (define-record-type frob)
             (define it (make-frob)))
          $1 = (let* ((lex.frob-rtd_0
                  (make-record-type-descriptor 'frob '#f '#f '#f '#f '#()))
                 (lex.frob-rcd_0
                  (make-record-constructor-descriptor lex.frob-rtd_0 '#f
                    '#f))
                 (lex.make-frob_0 (record-constructor lex.frob-rcd_0)))
            (begin (lex.make-frob_0) '#<void>))

 -- Syntax: further-optimisation-of ?EXPR
     Like 'optimisation-of', but in addition perform some compiler
     passes that additionally optimise the code.

     Example session:

          (further-optimisation-of
            (let ((x (read)))
              (when (fixnum? x)
                (gcd x 2))))
          => (let ((x_0 (read)))
               (if (fixnum? x_0)
                   ($gcd-fixnum-fixnum
                      (known x_0
                        (T:fixnum T:non-false T:exact-real T:real
                         T:exact-integer T:exact T:number T:immediate
                         T:object))
                      (known (constant 2)
                        (T:fixnum T:positive T:non-false T:exact-real
                         T:real T:exact-integer T:exact T:number
                         T:immediate T:object)))
                   (constant #<void>)))

 -- Syntax: further-optimisation-of* ?EXPR0 ?EXPR ...
     Like 'further-optimisation-of', but wrap the input expression as
     follows:

          (internal-body ?EXPR0 ?EXPR ... (void))

     this allows the expansion and optimisation of definition forms.
     Example of REPL session:

          vicare> (pretty-width 65)
          vicare> (print-gensym #f)
          vicare> (further-optimisation-of*
             (define-record-type frob)
             (define it (make-frob)))
          $1 = (let* ((lex.frob-rtd_0
                  (make-record-type-descriptor
                    (known 'frob
                      (T:symbol T:non-false T:nonimmediate T:object))
                    (known '#f (T:false T:boolean T:immediate T:object))
                    (known '#f (T:false T:boolean T:immediate T:object))
                    (known '#f (T:false T:boolean T:immediate T:object))
                    (known '#f (T:false T:boolean T:immediate T:object))
                    (known '#()
                      (T:vector T:non-false T:nonimmediate T:object))))
                 (lex.frob-rcd_0
                  (make-record-constructor-descriptor lex.frob-rtd_0
                    (known '#f (T:false T:boolean T:immediate T:object))
                    (known '#f (T:false T:boolean T:immediate T:object))))
                 (lex.make-frob_0 (record-constructor lex.frob-rcd_0)))
            (begin
              ((known lex.make-frob_0
                 (T:procedure T:non-false T:nonimmediate T:object)))
              '#<void>))


File: vicare-scheme.info,  Node: iklib syntaxes assembly-of,  Prev: iklib syntaxes optim-of,  Up: iklib syntaxes

6.8.23 Inspecting assembly language results
-------------------------------------------

 -- Syntax: assembly-of ?EXPR
     This syntax is mostly for interactive use.  Fully expand the given
     expression in the current lexical environment and apply the
     compiler's passes to the resulting core language expression as if
     to produce a code object; return a list of sublists, each sublist
     representing assembly language instructions for a code object.  The
     expression is *not* evaluated, only expanded and compiled to
     assembly; this means that the expansion side effects are performed.

          *NOTE* Only expressions are expanded and compiled.  It makes
          no sense to give a standalone 'define' syntax to this macro;
          when a standalone function definition is expanded and
          optimised: the function is never called, so it is removed.

          *NOTE* At present the return value of this macro is not very
          human friendly; some preprocessing and a specialised printer
          are needed.


File: vicare-scheme.info,  Node: iklib unwind-protect,  Next: iklib compensations,  Prev: iklib syntaxes,  Up: iklib

6.9 The unwind-protection mechanism
===================================

Unwind-protection allows operations to be performed synchronously with
respect to the dynamic extent of a call to thunk; the mechanism is
sophisticated because there are multiple, sophisticated ways to exit the
dynamic extent of a function call.  The typical application is to
release resources, like input/output ports and database connections.
*note Allocating and releasing resources: resources, for an overview of
resource management under Vicare.

   To understand the unwind-protection mechanism we must understand the
concepts "dynamic extent of a function call" and "dynamic environment"
ad defined by R6RS (*note scheme basic dynamic extent::).  *note Notes
on the dynamic environment: dynamic environment.

   The unwind-protection mechanism described here is used by Vicare in:
the implementation of compensations (*note iklib compensations::); the
implementation of the syntax 'try' (*note iklib syntaxes try::); the
implementation of condition handlers and restarts (*note Signalling
conditions and restarts: (vicare-libs)restarts.).

     *NOTE* The unwind protection mechanism may misbehave in some cases,
     so do not trust it blindly (*note iklib unwind-protect problems::).

* Menu:

* iklib unwind-protect intro::       Introduction to the unwind
                                     protection mechanism.
* iklib unwind-protect syntaxes::    Unwind-protection syntaxes.
* iklib unwind-protect dynamic::     On the meaning of dynamic extent
                                     termination.
* iklib unwind-protect except 1::    Raising non-continuable exceptions
                                     from the thunk.
* iklib unwind-protect except 2::    Raising continuable exceptions
                                     from the thunk.
* iklib unwind-protect except 3::    Raising exceptions from the
                                     unwind handler.
* iklib unwind-protect loops::       Use with loop syntaxes.
* iklib unwind-protect returnable::  Use with returnable bodies.
* iklib unwind-protect coroutines::  Use with coroutines.
* iklib unwind-protect reenter::     Handling reentering continuations.
* iklib unwind-protect dyn-env::     Clean-up thunks and the dynamic
                                     environment.
* iklib unwind-protect problems::    Known problems.
* iklib unwind-protect call/cc::     Unwinding 'call/cc'.


File: vicare-scheme.info,  Node: iklib unwind-protect intro,  Next: iklib unwind-protect syntaxes,  Up: iklib unwind-protect

6.9.1 Introduction to the unwind-protection mechanism
-----------------------------------------------------

The syntax 'with-unwind-handler' implements the core mechanism;
'with-unwind-protection' is an alias for it.  'unwind-protect' offers a
syntax similar to the one of the Common Lisp macro with the same name.
The former is meant to be used as follows:

     #!vicare
     (import (vicare))

     (let ((port (open-file-output-port "file.ext")))
       (with-unwind-handler
           (lambda (why)
             (close-output-port port))
         (lambda ()
           (put-bytevector port '#ve(ascii "ciao")))))


and the latter as follows:

     #!vicare
     (import (vicare))

     (let ((port (open-file-output-port "file.ext")))
       (unwind-protect
           (put-bytevector port '#ve(ascii "ciao"))
         (close-output-port port)))

first we allocate a resource (in this case the PORT); then we use it in
the body forms; finally we release it in the clean-up forms.

   When using the mechanism:

   * We have to decide if we trust our code not to raise exceptions
     while evaluating the in-guard and out-guard thunks of
     'dynamic-wind' calls.  These would be nasty errors, because the
     dynamic environment would get corrupted and recovering correctly
     might be impossible; so we must *really* write and debug such
     in-guard and out-guard thunks with care.

   * We have to decide if we trust our code not to raise a second
     exception while serving a first exception in an error handler.
     Raising a continuable exception is fine only if we actually
     continue.  Exceptions while handling exceptions are a hard problem
     to solve in every language; the rough solution is to block
     exceptions raised by exception handlers:

          (with-exception-handler
              (lambda (E)
                (with-blocked-exceptions
                  (lambda ()
                    (handle E))))
            (lambda ()
              (do-something-useful)))

     but it is not very satisfying.  Another possibility is:

          (define-condition-type &originally-raised
              &condition
            make-originally-raised-condition
            originally-raised-condition?
            (object originally-raised-object))

          (with-exception-handler
              (lambda (E)
                (with-exception-handler
                    (lambda (X)
                      (raise-continuable
                        (condition X
                          (make-originally-raised-condition E))))
                  (lambda ()
                    (handle E))))
            (lambda ()
              (do-something-useful)))

   If the bodacious answer to both the decisions is "We trust": we can
nest at will uses of 'with-unwind-protection':

     (define (outer)
       (with-unwind-protection
           (lambda (why)
             (outer-unwind-handler))
         (lambda ()
           (do-something-useful)
           (inner))))

     (define (inner)
       (with-unwind-protection
           (lambda (why)
             (inner-unwind-handler))
         (lambda ()
           (do-some-other-useful-thing))))

     (outer)

*beware*: unwind handlers are evaluated in the dynamic environment of
the use of 'with-unwind-protection'.

   Otherwise we must avoid error handlers to cause the execution flow to
cross an unwind protection boundary; we can do it by using compensations
and the standard 'guard' syntax:

     (define (outer)
       (push-compensation-thunk
         (lambda ()
           (outer-unwind-handler)))
       (do-something-useful)
       (inner))

     (define (inner)
       (push-compensation-thunk
         (lambda ()
           (inner-unwind-handler)))
       (do-some-other-useful-thing))

     (with-compensations
       (with-blocked-exceptions
         (lambda ()
           (guard (E ((type-one-error? E)
                      (handle E))
                     (else
                      (do-something-dammit!!!)))
             (outer)))))

or by using the compensations and the 'try' syntax defined by Vicare:

     (define (outer)
       (push-compensation-thunk
         (lambda ()
           (outer-unwind-handler)))
       (do-something-useful)
       (inner))

     (define (inner)
       (push-compensation-thunk
         (lambda ()
           (inner-unwind-handler)))
       (do-some-other-useful-thing))

     (with-compensations
       (with-blocked-exceptions
         (lambda ()
           (try
               (outer)
             (catch E
               ((&type-one)
                (handle E))
               (else
                (do-something-dammit!!!)))))))

*beware*: compensation handlers are evaluated in the dynamic environment
of the use of 'with-compensations'.


File: vicare-scheme.info,  Node: iklib unwind-protect syntaxes,  Next: iklib unwind-protect dynamic,  Prev: iklib unwind-protect intro,  Up: iklib unwind-protect

6.9.2 Unwind-protection syntaxes
--------------------------------

 -- Syntax: with-unwind-handler ?UNWIND-HANDLER ?THUNK
 -- Syntax: with-unwind-protection ?UNWIND-HANDLER ?THUNK
     These two syntaxes are aliases.  Call ?THUNK and then, when the
     dynamic extent of the call *terminates*, call the procedure
     ?UNWIND-HANDLER.  When ?THUNK performs a normal return: the return
     values of ?THUNK become the return values of 'with-unwind-handler'.

     When called: ?UNWIND-HANDLER is applied to a Scheme symbol
     representing the cause of the call: 'return', 'escape',
     'exception'.  The argument ?UNWIND-HANDLER comes before the
     argument ?THUNK for uniformity with 'with-exception-handler', *note
     with-exception-handler: stdlib exceptions exceptions.

     Notice that a function tail-call in ?THUNK is *not* a tail-call for
     'with-unwind-protection'.

 -- Syntax: unwind-protect ?BODY ?CLEANUP0 ?CLEANUP ...
     Simple wrapper for 'with-unwind-protection' that provides a syntax
     similar to that of Common Lisp's macro.  It is expanded to:

          (with-unwind-protection
              (lambda (dummy) ?CLEANUP0 ?CLEANUP ...)
            (lambda () ?BODY))


File: vicare-scheme.info,  Node: iklib unwind-protect dynamic,  Next: iklib unwind-protect except 1,  Prev: iklib unwind-protect syntaxes,  Up: iklib unwind-protect

6.9.3 On the meaning of dynamic extent termination
--------------------------------------------------

The concept of dynamic extent "termination" is defined by Vicare's
unwind-protection mechanism and it is not a R6RS concept.  In this
discussion, we consider the syntax use:

     (with-unwind-protection ?UNWIND-HANDLER ?THUNK)

the procedure ?UNWIND-HANDLER is called when the dynamic extent of the
invocation of ?THUNK terminates; dynamic extent *termination* is
different from dynamic extent *exiting* as determined by 'dynamic-wind'
(*note dynamic-wind::).  When the execution flow exits the dynamic
extent of a function call: such extent might also terminate, but not all
the exits are also terminations.

   The dynamic extent of a call to ?THUNK *is* terminated, and so
?UNWIND-HANDLER *is* invoked, when:

   * ?THUNK performs a normal return.  ?UNWIND-HANDLER is applied to the
     symbol 'return'.

   * ?THUNK raises a continuable or non-continuable exception that is
     intercepted by a use of 'guard', but only when a clause of 'guard'
     has a test expression returning non-false.

          (guard (E (?TEST ?EXPR))
            (with-unwind-handler ?UNWIND-HANDLER ?THUNK))

     This is what happens:

       1. The clause's ?TEST expression is evaluated in the dynamic
          environment of the use of 'guard' and it returns non-false.

       2. ?UNWIND-HANDLER is applied to the symbol 'exception', in the
          dynamic environment of the use of 'with-unwind-protection',
          and its return values discarded.

       3. The clause's ?EXPR is evaluated in the dynamic environment of
          the use of 'guard' and its return values are returned to the
          continuation of 'guard'.

   * ?THUNK executes a use of the fluid syntaxes 'break', 'continue' or
     'return', as defined by the library '(vicare)', to escape from a
     form that encloses an unwind-protection syntax.  ?UNWIND-HANDLER is
     applied to the symbol 'escape'.

     As bound by the loop syntaxes 'while', 'until', ... and the syntax
     'returnable': these fluid syntaxes reinstate a continuation at the
     beginning or outside of 'while', 'until', ... and 'returnable' and
     perform special operations to terminate the dynamic extent of the
     call to ?THUNK in an unwind-protection form.

   The dynamic extent of a call to ?THUNK is *not* terminated, and so
?UNWIND-HANDLER is *not* invoked, when:

   * ?THUNK raises a continuable exception by calling
     'raise-continuable', and such call performs a normal return to
     ?THUNK.

   * ?THUNK raises a continuable or non-continuable exception and an
     exception handler terminates the process (for example by calling
     'exit').

   * The unwind-protection syntax is used by a coroutine and 'yield' is
     called from within ?THUNK to hand control to another coroutine.

   * An escape procedure is called from within ?THUNK to reinstate a
     continuation outside ?THUNK, and the call to the escape procedure
     is *not* interfaced with the unwind-protection mechanism to
     terminate the dynamic extent of the call to ?THUNK.

   About the termination of the dynamic extent of ?THUNK, we must
acknowledge that:

   * There is *no* guarantee that: after exiting, without terminating,
     the dynamic extent of ?THUNK by reinstating a continuation, such
     extent will be reentered later and continue to termination.

   * If the dynamic extent of ?THUNK is terminated and an attempt to
     reenter ?THUNK is performed: an exception is raised with compound
     condition object containing a '&non-reinstatable' component (*note
     &non-reinstatable::).

   * Obviously, if a call to ?UNWIND-HANDLER raises an exception: the
     clean-up operations performed by ?UNWIND-HANDLER may fail, in whole
     or in part, possibly leaving behind unreleased resources.

   * If the call to ?THUNK raises an exception and a use of 'guard'
     intercepts it: if a test expression in a clause of 'guard' raises
     an exception, the ?UNWIND-HANDLER may not be called.

     While it is possible to 'raise' any object: it is better to always
     raise a condition object (possibly compound), so that the test
     expressions in 'guard' uses can just be condition object type
     predicates; such predicates never raise exceptions.

   If ?UNWIND-HANDLER raises an exception: such exception is blocked and
discarded.


File: vicare-scheme.info,  Node: iklib unwind-protect except 1,  Next: iklib unwind-protect except 2,  Prev: iklib unwind-protect dynamic,  Up: iklib unwind-protect

6.9.4 Raising non-continuable exceptions from the thunk
-------------------------------------------------------

A non-continuable exception is raised with 'raise', which can be applied
to any object; the argument to 'raise' becomes the "raised object".  The
purpose of raising a non-continuable exception is to cause the
application of a function, the current exception handler, to the raised
object; the exception handler is called in the dynamic environment of
the call to 'raise'.

   The execution flow is *not* meant return to the caller of 'raise', so
the exception handler has only two options:

  1. Reinstate a previously saved continuation to jump out of the
     dynamic environment in which the exception was raised.  The
     following example shows the basic mechanism:

          (import (vicare))

          (call/cc
              (lambda (escape)
                (with-exception-handler
                    escape
                  (lambda ()
                    (raise 1)))))
          => 1

     Reinstating a continuation to jump out of the exception handler is
     what the standard 'guard' syntax does when it handles an exception;
     'guard' does more than this.

  2. Raise the exception again, causing the invocation of the upper
     level exception handler.  The following example shows the basic
     mechanism:

          (import (vicare))

          (call/cc
              (lambda (escape)
                (with-exception-handler
                    escape
                  (lambda ()
                    (with-exception-handler
                        (lambda (E)
                          (raise E))
                      (lambda ()
                        (raise 1)))))))
          => 1

Handling exceptions by escaping
...............................

This is *not* the correct way of interfacing with the unwind-protection
mechanism.  In the following example we see that escaping from the
exception handler skips the call to the ?UNWIND-HANDLER.

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (call/cc
           (lambda (escape)
             (with-exception-handler
                 (lambda (E)
                   (add-result 'exception-handler)
                   (escape E))
               (lambda ()
                 (with-unwind-protection
                     (lambda (why)
                       (add-result 'cleanup))
                   (lambda ()
                     (add-result 'thunk-in)
                     (raise 123)
                     (add-result 'thunk-out))))))))
     => (123 (thunk-in exception-handler))

Handling exceptions with 'guard'
................................

This is the correct way of interfacing with the unwind-protection
mechanism.

   In the following example: the ?THUNK raises a non-continuable
exception, which is catched by the 'else' clause of a 'guard' use; this
is equivalent to escaping from an exception handler, but it does
evaluate the ?UNWIND-HANDLER.  We can see the forms evaluation order.

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E (else
                  (add-result 'guard-else)
                  E))
         (with-unwind-protection
             (lambda (why)
               (add-result 'cleanup))
           (lambda ()
             (add-result 'thunk-in)
             (raise 2)
             (add-result 'thunk-out)
             1))))
     => (2 (thunk-in cleanup guard-else))

   In the following example: the ?THUNK raises a non-continuable
exception, which is catched by the clause of a 'guard' use; the clause
has test and expression.  We can see the forms evaluation order.

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E ((begin
                    (add-result 'guard-test)
                    #t)
                  (add-result 'guard-expr)
                  E))
         (with-unwind-protection
             (lambda (why)
               (add-result 'cleanup))
           (lambda ()
             (add-result 'thunk-in)
             (raise 2)
             (add-result 'thunk-out)
             1))))
     => (2 (thunk-in guard-test cleanup guard-expr))

   The following example with two nested 'guard' uses and two nested
'dynamic-wind' calls, makes it even more clear the sequence of forms
evaluation.  The clause of the inner 'guard' has test expression
returning '#f', so the exception is re-raised with 'raise-continuable'.

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E ((begin
                    (add-result 'outer-guard-test)
                    #t)
                  (add-result 'outer-guard-expr)
                  E))
         (guard (E ((begin
                      (add-result 'inner-guard-test)
                      #f)
                    (add-result 'inner-guard-expr)
                    E))
           (dynamic-wind
               (lambda ()
                 (add-result 'outer-before))
               (lambda ()
                 (with-unwind-protection
                     (lambda (why)
                       (add-result 'cleanup))
                   (lambda ()
                     (dynamic-wind
                         (lambda ()
                           (add-result 'inner-before))
                         (lambda ()
                           (add-result 'thunk-in)
                           (raise 2)
                           (add-result 'thunk-out)
                           1)
                         (lambda ()
                           (add-result 'inner-after))))))
               (lambda ()
                 (add-result 'outer-after))))))
     => (2 (outer-before inner-before thunk-in inner-after outer-after
            inner-guard-test
            outer-before inner-before inner-after outer-after
            outer-guard-test
            outer-before inner-before inner-after cleanup outer-after
            outer-guard-expr))

   Let's describe the sequence of operations:

'outer-before inner-before thunk-in'
     Everything goes fine until the ?THUNK reaches 'thunk-in'.

'*'
     The ?THUNK raises an exception.  The exception handler of the inner
     'guard' is applied to the raised object.

'inner-after outer-after'
     The continuation of the inner 'guard' use is reinstated, the
     dynamic extent of the call to ?THUNK is exited: the dynamic
     environment unwinds.

'inner-guard-test'
     The clause test expression of the inner 'guard' is evaluated in the
     dynamic environment of the 'guard' use: it returns '#f'.

'outer-before inner-before'
     The continuation of the inner 'guard' exception handler is
     reinstated, the dynamic extent of the call to ?THUNK is reentered:
     the dynamic environment is restored.

'*'
     The exception is raised again by applying 'raise-continuable' to
     the same raised object.  The exception handler of the outer 'guard'
     is applied to the raised object.

'inner-after outer-after'
     The continuation of the outer 'guard' use is reinstated, the
     dynamic extent of the call to ?THUNK is exited: the dynamic
     environment unwinds.

'outer-guard-test'
     The clause test expression of the outer 'guard' is evaluated in the
     dynamic environment of the outer 'guard': it returns '#t'.

'outer-before inner-before'
     The continuation of the of the outer 'guard' exception handler is
     reinstated, the dynamic extent of the call to ?THUNK is entered:
     the dynamic environment is restored.

'inner-after cleanup outer-after'
     The continuation of the outer 'guard' clause is reinstated, the the
     dynamic extent of the call to ?THUNK is exited: the dynamic
     environment unwinds.  While unwinding: the ?THUNK is found
     terminated and the ?UNWIND-HANDLER is called in the dynamic
     environment of the 'with-unwind-protection' use.

'outer-guard-expr'
     The clause expression of the outer 'guard' is evaluated in the
     dynamic environment of the outer 'guard'.

   That's Scheme!


File: vicare-scheme.info,  Node: iklib unwind-protect except 2,  Next: iklib unwind-protect except 3,  Prev: iklib unwind-protect except 1,  Up: iklib unwind-protect

6.9.5 Raising continuable exceptions from the thunk
---------------------------------------------------

A continuable exception is raised with 'raise-continuable' and it is a
way to resume the execution of a chunk of code after raising an
exception.  This example shows the basic mechanism:

     (import (rnrs))
     (with-exception-handler
         (lambda (E)
           (+ E 2))
       (lambda ()
         (raise-continuable 1)))
     => 3

   The handling of a continuable exception can be the same of the
handling of a non-continuable exception; in addition the exception
handler is allowed to return.  In the latter case the dynamic extent of
the call to ?THUNK is *not* exited, so ?UNWIND-HANDLER is not called.

   The following example shows what happens when ?THUNK raises a
continuable exception:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (with-exception-handler
           (lambda (E)
             (add-result 'exception-handler)
             (+ E 2))
         (lambda ()
           (with-unwind-protection
               (lambda (why)
                 (add-result 'cleanup))
             (lambda ()
               (add-result 'thunk-in)
               (begin0
                   (raise-continuable 1)
                 (add-result 'thunk-out)))))))
     => (3 (thunk-in exception-handler thunk-out cleanup))


File: vicare-scheme.info,  Node: iklib unwind-protect except 3,  Next: iklib unwind-protect loops,  Prev: iklib unwind-protect except 2,  Up: iklib unwind-protect

6.9.6 Raising exceptions from the unwind handler
------------------------------------------------

When a thunk raises an exception and the current exception handler
raises another exception: the original exception is dropped if no
specific action is taken.  This is a common problem.  The following
example shows the mechanism.

     (import (vicare))

     (call/cc
         (lambda (escape)
           (with-exception-handler
               escape
             (lambda ()
               (with-exception-handler
                   (lambda (E)
                     (raise 2))
                 (lambda ()
                   (raise 1)))))))
     => 2

   What happens if ?UNWIND-HANDLER raises an exception?  It was decided
that such exceptions are to be blocked and discarded; ?UNWIND-HANDLER
procedures have to take care of themselves, handling their own errors.
The following example shows the mechanism.

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E (else
                  (add-result 'guard-else)
                  E))
         (with-unwind-protection
             (lambda (why)
               (add-result 'cleanup-in)
               (raise 2)
               (add-result 'cleanup-out))
           (lambda ()
             (add-result 'thunk-in)
             (raise 1)
             (add-result 'thunk-out)))))
     => (1 (thunk-in cleanup-in guard-else))


File: vicare-scheme.info,  Node: iklib unwind-protect loops,  Next: iklib unwind-protect returnable,  Prev: iklib unwind-protect except 3,  Up: iklib unwind-protect

6.9.7 Use with loop syntaxes
----------------------------

The unwind-protection mechanism has special integration with the loop
syntaxes defined by '(vicare)'; if an unwind-protection syntax is used
in the body of a loop as defined by 'do', 'while', 'until', 'for' and
'break' or 'continue' are used in the body forms: the cleanup forms are
evaluated correctly.  We have to remember that 'break' and 'continue'
are implemented by escaping continuations.

   This example shows breaking out of a 'while' syntax; the body and the
unwind handler are evaluated only once; 'exit' is never called.

     #!vicare
     (import (vicare))
     (define x 3)
     (define y #f)
     (while (positive? x)
       (with-unwind-protection
           (lambda (why)
             (set! y #t))
         (lambda ()
           (-- x)
           (break)
           (exit))))
     x => 2
     y => #t

   This example shows using 'continue' in a 'while' syntax; the body and
the unwind handler are evaluated 3 times; 'exit' is never called.

     #!vicare
     (import (vicare))
     (define x 3)
     (define y 0)
     (while (positive? x)
       (with-unwind-protection
           (lambda (why)
             (++ y))
         (lambda ()
           (-- x)
           (continue)
           (exit))))
     x => 0
     y => 3


File: vicare-scheme.info,  Node: iklib unwind-protect returnable,  Next: iklib unwind-protect coroutines,  Prev: iklib unwind-protect loops,  Up: iklib unwind-protect

6.9.8 Use with returnable bodies
--------------------------------

The unwind-protection mechanism has special integration with the
'returnable' syntax defined by '(vicare)'; if an unwind-protection
syntax is used in the body of 'returnable' and 'return' is used in the
body forms: the unwind handler is evaluated correctly.  We have to
remember that 'return' is implemented by an escaping continuation.

     #!vicare
     (import (vicare))
     (define y #f)
     (returnable
       (with-unwind-protection
           (lambda (why)
             (set! y #t))
         (lambda ()
           (return 1))))
     => 1
     y => #t


File: vicare-scheme.info,  Node: iklib unwind-protect coroutines,  Next: iklib unwind-protect reenter,  Prev: iklib unwind-protect returnable,  Up: iklib unwind-protect

6.9.9 Use with coroutines
-------------------------

Using the unwind-protection mechanism with coroutines is fine;
coroutines use 'yield' to save the current continuation, give control to
the next coroutine and come back later; this mechanism does not cause
the ?UNWIND-HANDLER evaluation.

   The following sample code finishes with the given return values and
lines printed:

     (import (vicare))

     (define (print template . args)
       (apply fprintf (current-error-port) template args)
       (yield))

     (define a #f)
     (define b #f)
     (define c #f)

     (concurrently
       (lambda ()
         (unwind-protect
             (begin
               (set! a 1.1)
               (print "unwind-protect sub 1.1: ~a\n" a)
               (set! a 1.2)
               (print "unwind-protect sub 1.2: ~a\n" a)
               (set! a 1.3)
               (print "unwind-protect sub 1.3: ~a\n" a))
           (set! a 1.4)))
       (lambda ()
         (unwind-protect
             (begin
               (set! b 2.1)
               (print "unwind-protect sub 2.1: ~a\n" b)
               (set! b 2.2)
               (print "unwind-protect sub 2.2: ~a\n" b)
               (set! b 2.3)
               (print "unwind-protect sub 2.3: ~a\n" b))
           (set! b 2.4)))
       (lambda ()
         (unwind-protect
             (begin
               (set! c 3.1)
               (print "unwind-protect sub 3.1: ~a\n" c)
               (set! c 3.2)
               (print "unwind-protect sub 3.2: ~a\n" c)
               (set! c 3.3)
               (print "unwind-protect sub 3.3: ~a\n" c))
           (set! c 3.4))))

     (values a b c)
     => 1.4 2.4 3.4
     -| unwind-protect sub 1.1: 1.1
     -| unwind-protect sub 2.1: 2.1
     -| unwind-protect sub 1.2: 1.2
     -| unwind-protect sub 3.1: 3.1
     -| unwind-protect sub 2.2: 2.2
     -| unwind-protect sub 1.3: 1.3
     -| unwind-protect sub 3.2: 3.2
     -| unwind-protect sub 2.3: 2.3
     -| unwind-protect sub 3.3: 3.3


File: vicare-scheme.info,  Node: iklib unwind-protect reenter,  Next: iklib unwind-protect dyn-env,  Prev: iklib unwind-protect coroutines,  Up: iklib unwind-protect

6.9.10 Handling reentering continuations
----------------------------------------

After the ?UNWIND-HANDLER is called: we do *not* want the execution flow
to reenter the ?THUNK in the same dynamic extent.  After the dynamic
extent of a call to ?THUNK terminates, and the ?UNWIND-HANDLER is
called: we are forbidden to reenter the ?THUNK; if we try to reenter: an
exception of type '&non-reinstatable' is raised.

   The first problem with reentering is that the code in the ?THUNK
expects invariants in the state of the process that are no longer true;
for example: if ?UNWIND-HANDLER closes an input/output port, the ?THUNK
still expects it to be open.

   Reentering might happen, for example, when using the 'amb' operator
in the ?THUNK, *note McCarthy's 'amb' operator: (vicare-libs)amb.  This
means we must be careful to use 'amb' in a ?THUNK only when the whole
search never crosses the unwind protection contour.

   The following example shows how calling an escape procedure created
in the ?THUNK of a 'with-unwind-protection' causes the exception to be
raised:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E ((non-reinstatable-violation? E)
                  (add-result 'violation)
                  #t)
                 (else E))
         (let ((rv (with-unwind-protection
                       (lambda (why)
                         (add-result 'cleanup))
                     (lambda ()
                       (add-result 'body-in)
                       (begin0
                           (call/cc values)
                         (add-result 'body-out))))))
           (cond ((procedure? rv)
                  (add-result 'reinstating)
                  (rv 123))
                 (else
                  (add-result 'returning)
                  rv)))))
     => (#t (body-in body-out cleanup reinstating violation))


File: vicare-scheme.info,  Node: iklib unwind-protect dyn-env,  Next: iklib unwind-protect problems,  Prev: iklib unwind-protect reenter,  Up: iklib unwind-protect

6.9.11 Clean-up thunks and the dynamic environment
--------------------------------------------------

As R6RS states:

     Some operations described in the report acquire information in
     addition to their explicit arguments from the _dynamic
     environment_.  For example, 'call/cc' accesses an implicit context
     established by 'dynamic-wind', and the 'raise' procedure accesses
     the current exception handler.

the typical example of values from the dynamic environment is
parameters, which indeed are implemented on top of 'dynamic-wind' (*note
iklib parameters::).  When using the unwind-protection mechanism:

     (with-unwind-protection ?UNWIND-HANDLER ?THUNK)

the procedure ?UNWIND-HANDLER is called in the dynamic environment of
the use of 'with-unwind-protection'.

   For example, when escaping from ?THUNK with 'return':

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define parm
       (make-parameter #f))

     (with-result
       (parametrise ((parm 'outer-parm))
         (returnable
           (parametrise ((parm 'inner-parm))
             (with-unwind-protection
                 (lambda (why)
                   (add-result 'cleanup-in)
                   (add-result (parm))
                   (add-result 'cleanup-out))
               (lambda ()
                 (add-result 'thunk-in)
                 (add-result (parm))
                 (return 2)
                 (add-result 'thunk-out)
                 1))))))
     => (2 (thunk-in inner-parm
            cleanup-in inner-parm cleanup-out))

we see that, even though 'return' reinstates the continuation of
'returnable': ?UNWIND-HANDLER gathers the parameter value from inside
the use of 'returnable'.

   Even more descriptive is the case of raising an exception from ?THUNK
and catching it with 'guard':

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define parm
       (make-parameter #f))

     (with-result
       (parametrise ((parm 'outer-parm))
         (guard (E ((begin
                      (add-result 'guard-test-in)
                      (add-result (parm))
                      (add-result 'guard-test-out)
                      #t)
                    (add-result 'guard-expr-in)
                    (add-result (parm))
                    (add-result 'guard-expr-out)
                    E))
           (parametrise ((parm 'inner-parm))
             (with-unwind-protection
                 (lambda (why)
                   (add-result 'cleanup-in)
                   (add-result (parm))
                   (add-result 'cleanup-out))
               (lambda ()
                 (add-result 'thunk-in)
                 (add-result (parm))
                 (raise 2)
                 (add-result 'thunk-out)
                 1))))))
     => (2 (thunk-in inner-parm
            guard-test-in outer-parm guard-test-out
            cleanup-in inner-parm cleanup-out
            guard-expr-in outer-parm guard-expr-out))

both ?THUNK and ?UNWIND-HANDLER gather the inner value, while the test
and expression of the 'guard' clause gather the outer value, even though
the execution order is intermixed.

   Changing the environment inside ?THUNK does not affect
?UNWIND-HANDLER:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define parm
       (make-parameter #f))

     (with-result
       (parametrise ((parm 'outer-parm))
         (with-unwind-protection
             (lambda (why)
               (add-result 'cleanup-in)
               (add-result (parm))
               (add-result 'cleanup-out))
           (lambda ()
             (parametrise ((parm 'inner-parm))
               (add-result 'thunk-in)
               (add-result (parm))
               (add-result 'thunk-out)
               1)))))
     => (1 (thunk-in inner-parm thunk-out
            cleanup-in outer-parm cleanup-out))

     (with-result
       (returnable
         (parametrise ((parm 'outer-parm))
           (with-unwind-protection
               (lambda (why)
                 (add-result 'cleanup-in)
                 (add-result (parm))
                 (add-result 'cleanup-out))
             (lambda ()
               (parametrise ((parm 'inner-parm))
                 (add-result 'thunk-in)
                 (add-result (parm))
                 (return 2)
                 (add-result 'thunk-out)
                 1))))))
     => (2 (thunk-in inner-parm
            cleanup-in outer-parm cleanup-out))


File: vicare-scheme.info,  Node: iklib unwind-protect problems,  Next: iklib unwind-protect call/cc,  Prev: iklib unwind-protect dyn-env,  Up: iklib unwind-protect

6.9.12 Known problems
---------------------

The unwind protection mechanism may misbehave in some cases.
Specifically the unwind handler may not be called in the following
cases:

   * An exception is raised by a thunk and, while handling it, a second
     exception is raised.

   * An exception is raised by the in-guard or out-guard thunks of a
     call to 'dynamic-wind'.

Raising exceptions from an exception handler
............................................

In the following example an exception is raised by an exception handler:
the unwind handler is called, but the original exception is lost.

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E (else
                  (add-result 'guard-else)
                  E))
         (with-exception-handler
             (lambda (E)
               (add-result 'exception-handler)
               (raise 2))
           (lambda ()
             (with-unwind-protection
                 (lambda (why)
                   (add-result 'unwind-handler))
               (lambda ()
                 (dynamic-wind
                     (lambda ()
                       (add-result 'in-guard))
                     (lambda ()
                       (add-result 'thunk-in)
                       (raise 1)
                       (add-result 'thunk-out))
                     (lambda ()
                       (add-result 'out-guard)))))))))
     => (2 (in-guard
            thunk-in
            exception-handler
            out-guard
            in-guard out-guard unwind-handler
            guard-else))

Raising exceptions from a 'guard''s test
........................................

In the following example an exception is raised from a 'guard''s test
expression: the unwind handler is *not* called and the original
exception is lost.

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (guard (E (else
                  (add-result 'outer-guard-else)
                  E))
         (guard (E ((begin
                      (add-result 'inner-guard-test)
                      (raise 2))
                    E))
           (with-unwind-protection
               (lambda (why)
                 (add-result 'unwind-handler))
             (lambda ()
               (dynamic-wind
                   (lambda ()
                     (add-result 'in-guard))
                   (lambda ()
                     (add-result 'thunk-in)
                     (raise 1)
                     (add-result 'thunk-out))
                   (lambda ()
                     (add-result 'out-guard))))))))
     => (2 (in-guard
            thunk-in
            out-guard
            inner-guard-test
            outer-guard-else))

Raising exceptions from 'dynamic-wind' guards
.............................................

In the following example an exception is raised from a 'dynamic-wind''s
in-guard thunk: the unwind handler is *not* called and the original
exception is lost.

     (with-result
       (guard (E (else
                  (add-result 'guard-else)
                  E))
         (dynamic-wind
             (let ((flag #f))
               (lambda ()
                 (cond (flag
                        (add-result 'in-guard/raise)
                        (raise 2))
                       (else
                        (set! flag #t)
                        (add-result 'in-guard)))))
             (lambda ()
               (with-unwind-handler
                   (lambda (E)
                     (add-result 'unwind-handler))
                 (lambda ()
                   (add-result 'thunk-in)
                   (raise 1))))
             (lambda ()
               (add-result 'out-guard)))))
     => (2 (in-guard
            thunk-in
            out-guard
            in-guard/raise
            guard-else))


File: vicare-scheme.info,  Node: iklib unwind-protect call/cc,  Prev: iklib unwind-protect problems,  Up: iklib unwind-protect

6.9.13 Unwinding 'call/cc'
--------------------------

We have seen that performing a raw escape from an exception handler
skips calling the unwind handlers installed in the body:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (call/cc
           (lambda (escape)
             (with-exception-handler
                 (lambda (E)
                   (add-result 'exception-handler)
                   (escape 2))
               (lambda ()
                 (with-unwind-handler
                     (lambda (why)
                       (add-result 'unwind-handler))
                   (lambda ()
                     (add-result 'body-in)
                     (raise 1))))))))
     => (2 (body-in exception-handler))

this problem can be solved by using 'unwinding-call/cc' rather than the
standard 'call/cc'.

 -- Function: unwinding-call/cc RECEIVER
     Similar to 'call/cc', but calling the escape procedure causes the
     invocation of the unwind handlers installed in the dynamic
     environment up until the saved continuation is restored.

     There are limitations:

        * The escape procedure produced by this primitive *must* be
          called only from the dynamic extent of the call to RECEIVER.
          For example: generating an unwinding escape procedure in a
          coroutine and calling it from another coroutine leads to
          raising an exception of type '&non-reinstatable'.

        * The escape procedure produced by this primitive *must* be
          called only once; an attempt to call it a second time leads to
          raising an exception of type '&non-reinstatable'.

          *NOTE* After some development iterations, the implementation
          of this primitive has taken a shape quite similar to the
          function 'call/cc-escaping' proposed by Will Clinger in
          <http://www.ccs.neu.edu/home/will/UWESC/uwesc.sch>.

   Usage examples:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (unwinding-call/cc
           (lambda (escape)
             (with-unwind-handler
                 (lambda (why)
                   (add-result 'unwind-handler))
               (lambda ()
                 (add-result 'body-in)
                 (escape 1))))))
     => (1 (body-in unwind-handler))

     (with-result
       (unwinding-call/cc
           (lambda (escape)
             (with-exception-handler
                 (lambda (E)
                   (add-result 'exception-handler)
                   (escape 2))
               (lambda ()
                 (with-unwind-handler
                     (lambda (why)
                       (add-result 'unwind-handler))
                   (lambda ()
                     (add-result 'body-in)
                     (raise 1))))))))
     => (2 (body-in exception-handler unwind-handler))

     ;;Calling unwinding escape procedure from outside the
     ;;dynamic extent of the call to the receiver.
     ;;
     (let ((escape-proc #f))
       (unwinding-call/cc
           (lambda (escape)
             (set! escape-proc escape)))
       (escape-proc))
     error-> &non-reinstatable

     ;;Calling unwinding escape procedure twice.
     ;;
     (let ((again-proc #f))
       (unwinding-call/cc
           (lambda (escape)
             (call/cc
                 (lambda (again)
                   (set! again-proc again)))
             (escape)))
       (again-proc))
     error-> &non-reinstatable


File: vicare-scheme.info,  Node: iklib compensations,  Next: iklib coroutines,  Prev: iklib unwind-protect,  Up: iklib

6.10 Compensation stacks
========================

Compensation stacks allow us to write code to allocate resources near
the code that releases them; *note Allocating and releasing resources:
resources, for an overview of resource management under Vicare.
Compensation stacks are described in:

     Westley Weimer, George C. Necula.  "Finding and Preventing Run-Time
     Error Handling Mistakes".  In Proceedings of the ACM Conference on
     Object-Oriented Programming, Systems, Languages, and Applications,
     2004.

   Vicare implements compensation stacks on top of the unwind protection
mechanism, which allows operations to be performed synchronously with
respect to the dynamic extent of a call to thunk.  *note The
unwind-protection mechanism: iklib unwind-protect.

* Menu:

* iklib compensations usage::   Basic compensations usage.
* iklib compensations api::     Compensations API.


File: vicare-scheme.info,  Node: iklib compensations usage,  Next: iklib compensations api,  Up: iklib compensations

6.10.1 Basic compensations usage
--------------------------------

A "compensation" is a chunk of code that undoes a resource allocation
performed in another chunk, example:

     (define port
       (open-file-input-port "/tmp/proof.1"))

must be "compensated" by:

     (close-port port)

with the compensations stack such code can be written:

     (with-compensations
       (letrec
           ((port (compensate
                      (open-file-input-port "/tmp/proof.1")
                    (with
                      (close-port port)))))
         (make-use-of port)))

or:

     (with-compensations
       (define port
         (compensate
             (open-file-input-port "/tmp/proof.1")
           (with
             (close-port port))))
       (make-use-of port))

   Compensation forms are embedded in a closure and pushed on a stack,
so that, in case of error, it is possible to evaluate them in
allocation-reversed order.

   A form that makes use of a compensation stack looks like this:

     (with-compensations
       (compensate
           ALLOC-FORMS-1
         (with RELEASE-FORMS-1))
       (compensate
           ALLOC-FORMS-2
         (with RELEASE-FORMS-2))
       BODY-FORMS)

both 'with-compensations' and 'compensate' are syntaxes.  If no error
occurs the order of evaluation is:

     ALLOC-FORMS-1
     ALLOC-FORMS-2
     BODY-FORMS
     RELEASE-FORMS-2
     RELEASE-FORMS-1

if an error occurs in 'BODY-FORMS', the order of evaluation is:

     ALLOC-FORMS-1
     ALLOC-FORMS-2
     BODY-FORMS
     RELEASE-FORMS-2
     RELEASE-FORMS-1

if an error occurs in 'ALLOC-FORMS-2', the order of evaluation is:

     ALLOC-FORMS-1
     ALLOC-FORMS-2
     RELEASE-FORMS-1

if an error occurs in 'ALLOC-FORMS-1', the order of evaluation is:

     ALLOC-FORMS-1

if an error occurs in 'RELEASE-FORMS-1', the order of evaluation is:

     ALLOC-FORMS-1
     ALLOC-FORMS-2
     BODY-FORMS
     RELEASE-FORMS-2
     RELEASE-FORMS-1

if an error occurs in 'RELEASE-FORMS-2', the order of evaluation is:

     ALLOC-FORMS-1
     ALLOC-FORMS-2
     BODY-FORMS
     RELEASE-FORMS-2
     RELEASE-FORMS-1

   So 'with-compensations' tries to evaluate all the release forms,
despite errors.  Of course if an error occurs in the middle of a set of
forms:

     (first-form)   ;evaluated
     (raise 'here)
     (third-form)   ;not evaluated

the forms before the error are evaluated, while the forms after the
error are not.

   A variant of 'with-compensations' exists to evaluate the compensation
forms only in case of error:

     (with-compensations/on-error
       (compensate
           ALLOC-FORMS-1
         (with RELEASE-FORMS-1))
       (compensate
           ALLOC-FORMS-2
         (with RELEASE-FORMS-2))
       BODY-FORMS)

if no error occurs the order of evaluation is:

     ALLOC-FORMS-1
     ALLOC-FORMS-2
     BODY-FORMS

while if an error occurs the evaluation is equal to the cases of
'with-compensations'.  The "on error" variant is useful in constructors
and initialisation functions, where we want to run the compensations
only if an error occurs; if no error is raised, we just want the
constructor to return.


File: vicare-scheme.info,  Node: iklib compensations api,  Prev: iklib compensations usage,  Up: iklib compensations

6.10.2 Compensations API
------------------------

The compensations mechanism is built on top of the unwind protection
mechanism:

   * All the ?ALLOC and ?BODY forms end in the body of a thunk; the
     compensations are evaluated when the dynamic extent of the call to
     such thunk is terminated, as defined by the unwind protection
     mechanism.

   * All the ?RELEASE forms end in the body of a clean-up procedure;
     such forms are evaluated in the *dynamic environment of the syntax
     use that allocates the compensations stack*.

 -- Syntax: with-compensations ?BODY0 ?BODY ...
     Allocate a new compensations stack, then evaluate all the ?BODY
     forms in the given order.  If no error occurs: call
     'run-compensations', reset the compensations stack to empty,
     finally return the result value of the last ?BODY form.

     If the dynamic extent of the evaluation of the ?BODY forms is
     terminated: the accumulated compensations are evaluated in reverse
     order.

 -- Syntax: with-compensations/on-error ?BODY0 ?BODY ...
     Allocate a new compensations stack, then evaluate all the ?BODY
     forms in the given order.  If no error occurs: reset the
     compensations stack to empty, return the result value of the last
     ?BODY form.

     If the dynamic extent of the evaluation of the ?BODY forms is
     terminated by escaping from the body directly or by escaping from
     the body while handling a raised a exception: the accumulated
     compensations are evaluated in reverse order.

 -- Function: run-compensations
     Evaluate all the compensation thunks in the current stack, in last
     in/first out order; compensation thunks are called in the current
     dynamic environment.  If a compensation thunk raises an exception:
     the exception is blocked and silently discarded.

     This function should be called only inside the dynamic environment
     prepared by 'with-compensations' and similar syntaxes.  It can be
     called multiple times: every time the compensation thunks are
     consumed and removed from the stack.

 -- Syntax: with-compensation-handler ?RELEASE-THUNK ?ALLOC-THUNK
     First push ?RELEASE-THUNK on the current compensations stack,
     *then* evaluate ?ALLOC-THUNK.  Return the results of evaluating
     ?ALLOC-THUNK.

 -- Syntax: compensate ?ALLOC0 ?ALLOC ... (with ?RELEASE0 ?RELEASE ...)
 -- Auxiliary Fluid Syntax: with
 -- Auxiliary Fluid Syntax: <>
     First evaluate all the ?ALLOC expressions then, *only* if they
     perform a normal return: push one thunk holding all the ?RELEASE
     forms on the current compensations stack.  Return the result of the
     last ?ALLOC expression.

     While expanding the ?RELEASE forms: the fluid syntax '<>' is bound
     to an identifier referencing the object returned by the ?ALLOC
     forms; this allows to code:

          (define (make-compensated-object)
            (compensate
                (make-new-object)
              (with
                (destroy-object <>))))

     rather than:

          (define (make-compensated-object)
            (receive-and-return (obj)
              (compensate
                  (make-new-object)
                (with
                  (destroy-object obj)))))

 -- Syntax: push-compensation ?RELEASE0 ?RELEASE ...
     Push a thunk holding the ?RELEASE forms on the current
     compensations stack.

 -- Function: push-compensation-thunk THUNK
     Push the given thunk on the current compensations stack.


File: vicare-scheme.info,  Node: iklib coroutines,  Next: iklib conditions,  Prev: iklib compensations,  Up: iklib

6.11 Running coroutines
=======================

Vicare implements coroutines on top of Scheme continuations.  The
implementation is a simple queue of escape procedures: whenever
coroutine yields control to the "next" coroutine, it enqueues an escape
function to its current continuation and causes the next escape
procedure to be invoked.

   For discussions about other implementations of coroutines and
continuations see *note references: (vicare-scheme)HFWCoro.

* Menu:

* iklib coroutines examples::   Usage examples for coroutines.
* iklib coroutines basic::      Basic coroutine operations.
* iklib coroutines uid::        Coroutine unique identifiers.
* iklib coroutines suspend::    Suspending and resuming coroutines.
* iklib coroutines syntaxes::   Utility syntaxes for coroutines.
* iklib coroutines debug::      Debugging utilities for coroutines.
* iklib coroutines parallel::   Running parallel processes.


File: vicare-scheme.info,  Node: iklib coroutines examples,  Next: iklib coroutines basic,  Up: iklib coroutines

6.11.1 Usage examples for coroutines
------------------------------------

Coroutines are created by the function 'coroutine'; a coroutine in
execution can yield control to the next coroutine with the function
'yield'.  It is possible to enter a loop that runs all the coroutines
until all of them are finished with the function 'finish-coroutines'.

   All the examples in this section are to be considered as Scheme
programs after the prelude:

     #!r6rs
     (import (vicare))

     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode line))

which allows the intertwining of coroutines to be seen by displaying
strings on the current output port.

Two coroutines
..............

The following example runs two coroutines and waits for them to finish:

     (coroutine
         (lambda ()
           (display "one 1\n")
           (yield)
           (display "one 2\n")
           (yield)
           (display "one 3\n")))

     (coroutine
         (lambda ()
           (display "two 1\n")
           (yield)
           (display "two 2\n")
           (yield)
           (display "two 3\n")))

     (finish-coroutines)

the output is:

     one 1
     two 1
     one 2
     two 2
     one 3
     two 3

   We see that to exit a coroutine we just return from its start
function.

The main routine and a subroutine
.................................

We can always consider the ordinary control flow of a program as a
coroutine, the "main routine"; so the following program produces output
similar to the one above:

     (coroutine
         (lambda ()
           (display "sub 1\n")
           (yield)
           (display "sub 2\n")
           (yield)
           (display "sub 3\n")))

     ;;This runs in the main routine.
     (display "main 1\n")
     (yield)
     (display "main 2\n")
     (yield)
     (display "main 3\n")

     (finish-coroutines)

the output is:

     sub 1
     main 1
     sub 2
     main 2
     sub 3
     main 3

Main routine alone
..................

It is perfectly all right to call 'yield' and 'finish-coroutines' from
the main routine even when there are no subroutines:

     (display "main 1\n")
     (yield)
     (display "main 2\n")
     (yield)
     (display "main 3\n")
     (finish-coroutines)

the output of this program is just:

     main 1
     main 2
     main 3

Finishing coroutines
....................

It is possible to call 'finish-coroutines' from any coroutine, but we
must be careful because if we let the main routine exit before all the
routines are finished some computation will not take place.  In the
following program the subroutine has more steps than the main routine:

     (coroutine
         (lambda ()
           (display "sub 1\n")
           (yield)
           (display "sub 2\n")
           (yield)
           (display "sub 3\n")
           (yield)
           (display "sub 4\n")
           (yield)
           (display "sub 5\n")
           (finish-coroutines)))

     ;; This runs in the main routine.
     (display "main 1\n")
     (yield)
     (display "main 2\n")
     (yield)
     (display "main 3\n")

and its output is:

     sub 1
     main 1
     sub 2
     main 2
     sub 3
     main 3

we see that 'sub 4' and 'sub 5' are not displayed.

Finish coroutines as exit hook
..............................

It can be useful to register 'finish-coroutines' as exit hook, so that
upon exiting the process all the pending coroutines are correctly
terminated.

     (coroutine
         (lambda ()
           (display "one 1\n")
           (yield)
           (display "one 2\n")
           (yield)
           (display "one 3\n")))

     (coroutine
         (lambda ()
           (display "two 1\n")
           (yield)
           (display "two 2\n")
           (yield)
           (display "two 3\n")))

     (exit-hooks (cons finish-coroutines (exit-hooks)))
     (exit)


File: vicare-scheme.info,  Node: iklib coroutines basic,  Next: iklib coroutines uid,  Prev: iklib coroutines examples,  Up: iklib coroutines

6.11.2 Basic coroutine operations
---------------------------------

 -- Function: coroutine THUNK
     Create a new coroutine having THUNK as function and enter it;
     return unspecified values.

 -- Function: yield
     Register the current continuation as coroutine, then run the next
     coroutine; return unspecified values.

 -- Function: finish-coroutines
 -- Function: finish-coroutines EXIT-LOOP?
     Loop running the next coroutine until there are no more; return
     unspecified values.

     When the argument EXIT-LOOP? is used: it must be a thunk.  Before
     entering the next coroutine EXIT-LOOP? is called: if it returns
     non-false the loop exits, if it returns '#f' the loop continues.


File: vicare-scheme.info,  Node: iklib coroutines uid,  Next: iklib coroutines suspend,  Prev: iklib coroutines basic,  Up: iklib coroutines

6.11.3 Coroutine unique identifiers
-----------------------------------

 -- Function: coroutine-uid
     Return a gensym acting as unique identifier for the current
     coroutine.  This symbol is bound to an internal data structure.

 -- Function: coroutine-uid? OBJ
     Return '#t' if OBJ is a unique coroutine identifier; otherwise
     return '#f'.


File: vicare-scheme.info,  Node: iklib coroutines suspend,  Next: iklib coroutines syntaxes,  Prev: iklib coroutines uid,  Up: iklib coroutines

6.11.4 Suspending and resuming coroutines
-----------------------------------------

 -- Function: suspend-coroutine
     Suspend the current coroutine by yielding control to the next one.
     The continuation of the current coroutine is *not* enqueued to be
     reinstated later.

 -- Function: resume-coroutine UID
     Given the unique identifier of a suspended coroutine: resume it by
     enqueueing the current continuation and yielding control to the
     suspended coroutine.

 -- Function: suspended-coroutine? UID
     Return '#t' if UID is the unique identifier of a suspended
     coroutine; otherwise return '#f'.  It is an error if UID is not the
     UID of a coroutine.


File: vicare-scheme.info,  Node: iklib coroutines syntaxes,  Next: iklib coroutines debug,  Prev: iklib coroutines suspend,  Up: iklib coroutines

6.11.5 Utility syntaxes for coroutines
--------------------------------------

 -- Syntax: concurrently ?THUNK0 ?THUNK ...
     Evaluate the given thunks each in its own coroutine.  Return
     unspecified values when all the coroutines are finished.

 -- Syntax: monitor ?MAX-COROUTINES-COUNT ?THUNK
     Allow only a maximum number of coroutines to concurrently enter the
     evaluation of ?THUNK.

     The argument ?MAX-COROUTINES-COUNT must be an expression evaluating
     to a positive integer representing the maximum number of
     coroutines.  It is evaluated only once.

     The argument ?THUNK must be an expression evaluating to a thunk.
     It is evaluated only once.


File: vicare-scheme.info,  Node: iklib coroutines debug,  Next: iklib coroutines parallel,  Prev: iklib coroutines syntaxes,  Up: iklib coroutines

6.11.6 Debugging utilities for coroutines
-----------------------------------------

 -- Function: reset-coroutines!
     Reset the internal state of the coroutine mechanism, discarding all
     the enqueued coroutines.  This function should not be used.

 -- Function: dump-coroutines
     Print, on the current error port, a symbolic expression listing the
     currently enqueued coroutine continuation procedures.  This is
     strictly for debugging purposes.


File: vicare-scheme.info,  Node: iklib coroutines parallel,  Prev: iklib coroutines debug,  Up: iklib coroutines

6.11.7 Running parallel processes
---------------------------------

The following example program shows how to run a parallel, child process
waiting for its termination in a coroutine; it assumes that Vicare has
been installed with the POSIX extensions.

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.)
       (prefix (vicare platform constants) const.))

     (define (parent-proc child-pid child-stdin child-stdout child-stderr)
       (with-unwind-protection
           (lambda (why)
             (close-output-port child-stdin)
             (close-input-port  child-stdout)
             (close-input-port  child-stderr))
         (lambda ()
           (let loop ((status (px.waitpid child-pid const.WNOHANG)))
             (cond ((not status)
                    ;;Child still running.
                    (yield)
                    (loop (px.waitpid child-pid const.WNOHANG)))
                   ((px.WIFEXITED status)
                    ;;Child exited.
                    (values status
                            (read-all child-stdout)
                            (get-string-all child-stderr)))
                   (else
                    (error #f
                      "child process exited abnormally" status)))))))

     (define (child-thunk)
       (guard (E (else
                  (print-condition E)
                  (exit 1)))
         (px.close-ports-in-close-on-exec-mode)
         (write '(1 2 3) (console-output-port))
         (write '(4 5 6) (console-output-port))
         (flush-output-port (console-output-port))
         (put-string (console-error-port) "done\n")
         (flush-output-port (console-error-port))
         (exit 0)))

     (define (read-all port)
       (let ((obj (read port)))
         (if (eof-object? obj)
             '()
           (cons obj (read-all port)))))

     (coroutine
         (lambda ()
           (px.flush-ports-in-close-on-exec-mode)
           (receive (status out err)
               (px.fork-with-textual-ports parent-proc child-thunk)
             (printf "out: ~s\n" out)
             (printf "err: ~a\n" err)
             (flush-output-port (current-output-port)))))

     (finish-coroutines)


File: vicare-scheme.info,  Node: iklib conditions,  Next: iklib reader,  Prev: iklib coroutines,  Up: iklib

6.12 Additional condition types
===============================

* Menu:

* iklib conditions core::       Core functions.
* iklib conditions raising::    Raising conditions.
* iklib conditions preds::      Predicates for condition objects.
* iklib conditions spos::       Scheme source code position.
* iklib conditions eagain::     Reporting 'EAGAIN' exceptions.
* iklib conditions errno::      Reporting 'errno' exceptions.
* iklib conditions failexpr::   Failed expression conditions.
* iklib conditions exprindex::  One-based return value index conditions.
* iklib conditions procpre::    Procedure precondition violations.
* iklib conditions procpost::   Procedure postcondition violations.
* iklib conditions procarg::    Procedure argument violations.
* iklib conditions sigarg::     Procedure signature argument violations.
* iklib conditions rvarg::      Procedure signature return value violations.
* iklib conditions proccon::    Procedure argument consistency violations.
* iklib conditions exprret::    Expression return value violations.
* iklib conditions non-reinst:: Non-reinstatable continuations.
* iklib conditions late-bind::  Late binding conditions.
* iklib conditions string::     String encoding and decoding.
* iklib conditions wfs::        Wrong FASL header.
* iklib conditions misc::       Miscellaneous primitives.


File: vicare-scheme.info,  Node: iklib conditions core,  Next: iklib conditions raising,  Up: iklib conditions

6.12.1 Core functions
---------------------

 -- Function: condition-accessor RTD RECORD-ACCESSOR
 -- Function: condition-accessor RTD RECORD-ACCESSOR ACCESSOR-WHO
     Vicare extends the definition of 'condition-accessor' specified by
     R6RS by accepting a third argument: a symbol representing the name
     of the accessor.


File: vicare-scheme.info,  Node: iklib conditions raising,  Next: iklib conditions preds,  Prev: iklib conditions core,  Up: iklib conditions

6.12.2 Raising conditions
-------------------------

 -- Function: raise-non-continuable-standard-condition WHO MESSAGE
          IRRITANTS
 -- Function: raise-non-continuable-standard-condition WHO MESSAGE
          IRRITANTS CND
     Raise a non-continuable exception with a compound condition object
     of types: '&who', '&message', '&irritants'; in addition, when used,
     add the condition object CND to it.

     The argument WHO must be '#f' or a symbol or a string; if WHO is
     '#f': no '&who' condition is included in the raised exception.  The
     argument MESSAGE must be a string.  The argument IRRITANTS must be
     null or a list of objects.  The optional argument CND must be a
     simple or compound condition object.


File: vicare-scheme.info,  Node: iklib conditions preds,  Next: iklib conditions spos,  Prev: iklib conditions raising,  Up: iklib conditions

6.12.3 Predicates for condition objects
---------------------------------------

 -- Function: simple-condition? OBJ
     Return '#t' if OBJ is a simple condition object; otherwise return
     '#f'.

 -- Function: list-of-simple-conditions? OBJ
     Return '#t' if OBJ is a proper list of simple condition objects;
     otherwise return '#f'.

 -- Function: list-of-conditions? OBJ
     Return '#t' if OBJ is a proper list of simple or compound condition
     objects; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions spos,  Next: iklib conditions eagain,  Prev: iklib conditions preds,  Up: iklib conditions

6.12.4 Scheme source code position
----------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Condition Type: &source-position
     Condition type used to represent a position in Scheme source code
     read from a textual input port; it is derived from '&condition'.
     It has the following fields:

     'port-id'
          A Scheme string representing the port identifier, for example
          the file name.

     'byte'
          An exact non-negative zero-based integer representing the byte
          offset of the position in the source.

     'character'
          An exact non-negative zero-based integer representing the
          character offset of the position in the source.

     'line'
          An exact non-negative one-based integer representing the line
          offset of the position in the source.

     'column'
          An exact non-negative one-based integer representing the
          column offset of the position in the source.

 -- Function: make-source-position-condition PORT-ID BYTE CHARACTER LINE
          COLUMN
     Build and return a new condition object of type '&source-position'.

 -- Function: source-position-condition? OBJ
     Return true if OBJ is a condition object with type
     '&source-position'.

 -- Function: source-position-port-id SPOS
 -- Function: source-position-byte SPOS
 -- Function: source-position-character SPOS
 -- Function: source-position-line SPOS
 -- Function: source-position-column SPOS
     Accessors for the fields of condition objects of type
     '&source-position'.


File: vicare-scheme.info,  Node: iklib conditions eagain,  Next: iklib conditions errno,  Prev: iklib conditions spos,  Up: iklib conditions

6.12.5 Reporting 'EAGAIN' exceptions
------------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Condition Type: &i/o-eagain
     Used to signal that a system call returned with 'errno' set to
     'EAGAIN'.  It is derived from '&i/o'.

 -- Function: make-i/o-eagain
     Return a new condition object of type '&i/o-eagain'.

 -- Function: i/o-eagain-error? OBJ
     Return '#t' if OBJ is a condition object of type '&i/o-eagain'.


File: vicare-scheme.info,  Node: iklib conditions errno,  Next: iklib conditions failexpr,  Prev: iklib conditions eagain,  Up: iklib conditions

6.12.6 Reporting 'errno' exceptions
-----------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Condition Type: &errno
     Condition object type representing system errors described by an
     encoded 'errno' value; it is derived from '&condition'.

 -- Function: make-errno-condition ERRNO
     Build and return a new '&errno' condition object holding the given
     encoded ERRNO value.

 -- Function: errno-condition? OBJ
     Return '#t' if OBJ is an instance of '&errno'.

 -- Function: condition-errno OBJ
     Accessor for the encoded 'errno' value in OBJ, which must be an
     instance of '&errno'.


File: vicare-scheme.info,  Node: iklib conditions failexpr,  Next: iklib conditions exprindex,  Prev: iklib conditions errno,  Up: iklib conditions

6.12.7 Failed expression conditions
-----------------------------------

Let's say we need code like this:

     (if (fixnum? obj)
         obj
       (raise-exception))

we might want to raise a condition object holding the failed expression
'(fixnum? obj)'; for this we can use '&failed-expression' as follows:

     (if (fixnum? obj)
         obj
       (raise
         (make-assertion-violation)
         (make-message-condition "failed object validation")
         (make-failed-expression-condition '(fixnum? obj))
         (make-irritants (list obj))))

 -- Condition Object Type: &failed-expression
     Condition type used to describe a failed expression, for example in
     a procedure argument validation predicate.  It is derived from
     '&condition'.  It has the following fields:

     'failed-expression'
          A symbolic expression representing the source code of the
          failed expression.

 -- Function: make-failed-expression-condition SEXP
     Build and return a condition object of type '&failed-expression'.

 -- Function: failed-expression-condition? OBJ
     Return '#t' if OBJ is a condition object of type
     '&failed-expression'; otherwise return '#f'.

 -- Function: condition-failed-expression CND
     Given a condition object of type '&failed-expression' return the
     symbolic expression.


File: vicare-scheme.info,  Node: iklib conditions exprindex,  Next: iklib conditions procpre,  Prev: iklib conditions failexpr,  Up: iklib conditions

6.12.8 One-based return value index conditions
----------------------------------------------

Remembering that every expression may return multiple values, let's say
we need code like this:

     (receive (a b c)
         (expression)
       (unless (fixnum? a) (raise-exception))
       (unless (symbol? b) (raise-exception))
       (unless (string? c) (raise-exception))
       ?BODY)

we might want to raise condition objects holding the index of the
returned value; for this we can use '&one-based-return-value-index' as
follows:

     (receive (a b c)
         (expression)
       (internal-body
         (define (%error sexp idx obj)
           (raise
             (make-assertion-violation)
             (make-message-condition "failed object validation")
             (make-failed-expression-condition sexp)
             (make-one-based-return-value-index-condition idx)
             (make-irritants (list obj))))
         (unless (fixnum? a) (%error '(fixnum? a) 1 a))
         (unless (symbol? b) (%error '(symbol? b) 2 b))
         (unless (string? c) (%error '(string? c) 3 c)))
       ?BODY)

 -- Condition Obect Type: &one-based-return-value-index
     Condition type used to specify the one-based index of a return
     value in a tuple of return values from an expression.  It is
     derived from '&condition'.  It has the following fields:

     'index'
          A positive fixnum representing the one-based index of a return
          value.

 -- Function: make-one-based-return-value-index-condition INDEX
     Build and return a new instance of '&one-based-return-value-index'.

 -- Function: one-based-return-value-index-condition? OBJ
     Return '#t' if OBJ is a condition object with component
     '&one-based-return-value-index'; otherwise return '#f'.

 -- Function: condition-one-based-return-value-index CND
     Given a condition object of type '&one-based-return-value-index'
     return the index.


File: vicare-scheme.info,  Node: iklib conditions procpre,  Next: iklib conditions procpost,  Prev: iklib conditions exprindex,  Up: iklib conditions

6.12.9 Procedure precondition violations
----------------------------------------

 -- Condition Type: &procedure-precondition-violation
     Base condition object type representing invalid state or argument
     for a procedure application; it is derived from '&assertion'.

 -- Function: make-procedure-precondition-violation
     Build and return a new condition object of type
     '&procedure-precondition-violation'.

 -- Function: procedure-precondition-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&procedure-precondition-violation'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions procpost,  Next: iklib conditions procarg,  Prev: iklib conditions procpre,  Up: iklib conditions

6.12.10 Procedure postcondition violations
------------------------------------------

 -- Condition Type: &procedure-postcondition-violation
     Base condition object type representing invalid state or return
     values for a procedure application; it is derived from
     '&assertion'.

 -- Function: make-procedure-postcondition-violation
     Build and return a new condition object of type
     '&procedure-postcondition-violation'.

 -- Function: procedure-postcondition-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&procedure-postcondition-violation'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions procarg,  Next: iklib conditions sigarg,  Prev: iklib conditions procpost,  Up: iklib conditions

6.12.11 Procedure argument violations
-------------------------------------

 -- Condition Type: &procedure-argument-violation
     Condition object type representing, generically, one or more
     invalid values handed as arguments to a procedure application; it
     is derived from '&procedure-precondition-violation'.

 -- Function: make-procedure-argument-violation
     Build and return a new condition object of type
     '&procedure-argument-violation'.

 -- Function: procedure-argument-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&procedure-argument-violation'; otherwise return '#f'.

 -- Function: procedure-argument-violation WHO MESSAGE IRRITANT ...
     Raise a compound condition object as non-continuable exception with
     component types: '&who', '&message', '&irritants',
     '&procedure-argument-violation'.


File: vicare-scheme.info,  Node: iklib conditions sigarg,  Next: iklib conditions rvarg,  Prev: iklib conditions procarg,  Up: iklib conditions

6.12.12 Procedure signature argument violations
-----------------------------------------------

 -- Condition Type: &procedure-signature-argument-violation
     Condition object type representing an invalid value handed as
     argument to a procedure application; it is derived from
     '&procedure-argument-violation'.

     This condition type has the following fields:

     'index'
          One-based index of the offending operand.  It is '#f' when the
          index is unknown.

     'failed-expression'
          Symbolic expression representing the predicate used to
          validate the operand; set to the void object if the expression
          is not available.  When debugging mode is disabled: some code
          might avoid putting symbolic expressions in this field.

     'offending-value'
          The actual value of the operand.  If there are multiple
          offending values: this field can be set to '(void)' and an
          additional condition object of type '&irritants' can be used.

     This condition type is meant to be used to signal a wrong argument
     given to a procedure performing signature validation; for example
     'define*' and 'case-define*' use it to signal a violation of the
     logic predicate specifications.

 -- Function: make-procedure-signature-argument-violation OPERAND-INDEX
          FAILED-EXPRESSION OFFENDING-VALUE
     Build and return a new condition object of type
     '&procedure-signature-argument-violation'.

 -- Function: procedure-signature-argument-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&procedure-signature-argument-violation'; otherwise return '#f'.

 -- Function:
          procedure-signature-argument-violation.one-based-argument-index
          CND
 -- Function: procedure-signature-argument-violation.failed-expression
          CND
 -- Function: procedure-signature-argument-violation.offending-value CND
     Accessors for the fields of condition objects of type
     '&procedure-signature-argument-violation'.

 -- Function: procedure-signature-argument-violation WHO MESSAGE
          OPERAND-INDEX FAILED-EXPRESSION OFFENDING-VALUE
     Raise a compound condition object as non-continuable exception with
     component types: '&who', '&message', '&irritants',
     '&procedure-signature-argument-violation'.


File: vicare-scheme.info,  Node: iklib conditions rvarg,  Next: iklib conditions proccon,  Prev: iklib conditions sigarg,  Up: iklib conditions

6.12.13 Procedure signature return value violations
---------------------------------------------------

 -- Condition Type: &procedure-signature-return-value-violation
     Condition object type representing invalid values returned from an
     expression; it is derived from
     '&procedure-postcondition-violation'.  It has the following fields:

     'index'
          One-based index of the offending return value in the tuple of
          values returned by the expression.  It is '#f' when the index
          is unknown.

     'failed-expression'
          Symbolic expression representing the predicate used to
          validate the return value.

     'offending-value'
          The actual value returned by the expression.

 -- Function: make-procedure-signature-return-value-violation
          RETVAL-INDEX FAILED-EXPRESSION OFFENDING-VALUE
     Build and return a new condition object of type
     '&procedure-signature-return-value-violation'.

 -- Function: procedure-signature-return-value-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&procedure-signature-return-value-violation'; otherwise return
     '#f'.

 -- Function:
          procedure-signature-return-value-violation.one-based-return-value-index
          CND
 -- Function:
          procedure-signature-return-value-violation.failed-expression
          CND
 -- Function: procedure-signature-return-value-violation.offending-value
          CND
     Accessors for the fields of condition objects of type
     '&procedure-signature-return-value-violation'.

 -- Function: procedure-signature-return-value-violation WHO MESSAGE
          RETVAL-INDEX FAILED-EXPRESSION OFFENDING-VALUE IRRITANT ...
     Raise a compound condition object as non-continuable exception with
     component types: '&who', '&message', '&irritants',
     '&procedure-signature-return-value-violation'.

