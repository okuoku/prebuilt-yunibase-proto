This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: posix socket addresses,  Next: posix socket hosts,  Up: posix socket

4.15.1 Network address structures
---------------------------------

* Menu:

* posix socket addresses local:: Local addresses.
* posix socket addresses in::    IPv4 addresses.
* posix socket addresses in6::   IPv6 addresses.
* posix socket addresses rep::   ASCII address representations.
* posix socket addresses info::  Host address informations.


File: vicare-libs.info,  Node: posix socket addresses local,  Next: posix socket addresses in,  Up: posix socket addresses

4.15.1.1 Local addresses
........................

Instances of 'struct sockaddr_un' can be handled at the Scheme level as
follows:

     (import (vicare)
       (prefix (vicare posix) px.))

     (define sockaddr
       (px.make-sockaddr_un "/tmp/the-unix-socket"))

     (px.sockaddr_un.pathname/string sockaddr)
     => "/tmp/the-unix-socket"

care must be taken when handling such raw values.

 -- Function: make-sockaddr_un PATHNAME
     Given a PATHNAME representing the pathname of a local socket, build
     and return a bytevector holding the 'struct sockaddr_un'
     representing it.

 -- Function: sockaddr_un.pathname SOCKET_ADDRESS
 -- Function: sockaddr_un.pathname/string SOCKET_ADDRESS
     Given a bytevector SOCKET_ADDRESS, which must be the return value
     of a previous call to 'make-sockaddr_un', holding a 'struct
     sockaddr_un': 'sockaddr_un.pathname' builds and returns a
     bytevector holding the corresponding socket pathname,
     'sockaddr_un.pathname/string' builds and returns a string holding
     the corresponding socket pathname.  If the data in SOCKET_ADDRESS
     is invalid: an exception is raised.


File: vicare-libs.info,  Node: posix socket addresses in,  Next: posix socket addresses in6,  Prev: posix socket addresses local,  Up: posix socket addresses

4.15.1.2 IPv4 addresses
.......................

Instances of 'struct sockaddr_in' can be handled at the Scheme level as
follows:

     (import (vicare)
       (prefix (vicare posix) px.))

     (define sockaddr
       (px.make-sockaddr_in '#vu8(1 2 3 4) 88))

     (px.sockaddr_in.in_addr sockaddr)  => #vu8(1 2 3 4)
     (px.sockaddr_in.in_port sockaddr)  => 88

and we can use constant values to initialise the fields:

     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (define addr (make-bytevector 4))
     (bytevector-u32-set! bv 0 INADDR_LOOPBACK (endianness big))

     (define sockaddr (px.make-sockaddr_in addr 88))

     (px.sockaddr_in.in_addr sockaddr)  => #vu8(127 0 0 1)
     (px.sockaddr_in.in_port sockaddr)  => 88

care must be taken when handling such raw values.

 -- Function: make-sockaddr_in HOST-ADDRESS PORT
     Given a bytevector HOST-ADDRESS holding a 'struct in_addr' and a
     fixnum PORT representing a network port number, build and return a
     bytevector holding a 'struct sockaddr_in' initialised with this
     data.

     Internally convert PORT to network byte order using 'htons()'
     before storing the value in the data structure.

 -- Function: sockaddr_in.in_addr SOCKET-ADDRESS
 -- Function: sockaddr_in.in_addr.number SOCKET-ADDRESS
 -- Function: sockaddr_in.in_port SOCKET-ADDRESS
     Given a bytevector SOCKET-ADDRESS holding a 'struct sockaddr_in',
     extract the 'in_addr' and 'in_port' fields and return them.  If the
     data in SOCKET_ADDRESS is invalid: an exception is raised.

     'sockaddr_in.in_addr' returns 'in_addr' as bytevector holding the
     corresponding 'struct in_addr'.

          (let ((sockaddr (px.make-sockaddr_in '#vu8(127 0 0 1) 88)))
            (px.sockaddr_in.in_addr sockaddr))
          => #vu8(127 0 0 1)

     'sockaddr_in.in_addr.number' returns 'in_addr' as 32-bit unsigned
     exact integer; internally it converts the address number to host
     byte order using 'ntohl()' after the extraction of the value from
     the data structure.

          (let ((sockaddr (px.make-sockaddr_in '#vu8(127 0 0 1) 88)))
            (px.sockaddr_in.in_addr.number sockaddr))
          => #x7f000001

     'sockaddr_in.in_port' returns 'in_port' as exact integer;
     internally it converts the port number to host byte order using
     'ntohs()' after the extraction of the value from the data
     structure.

          (let ((sockaddr (px.make-sockaddr_in '#vu8(127 0 0 1) 88)))
            (px.sockaddr_in.in_port sockaddr))
          => 88


File: vicare-libs.info,  Node: posix socket addresses in6,  Next: posix socket addresses rep,  Prev: posix socket addresses in,  Up: posix socket addresses

4.15.1.3 IPv6 addresses
.......................

Instances of 'struct sockaddr_in6' can be handled at the Scheme level as
follows:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.))

     (define sockaddr
       (px.make-sockaddr_in6 '#vu16b(1 2 3 4  5 6 7 8) 88))

     (px.sockaddr_in6.in6_addr sockaddr) => #vu16b(1 2 3 4  5 6 7 8)
     (px.sockaddr_in6.in6_port sockaddr) => 88

care must be taken when handling such raw values.

 -- Function: make-sockaddr_in6 HOST-ADDRESS PORT
     Given a bytevector HOST-ADDRESS holding a 'struct in6_addr' and a
     fixnum PORT representing a network port number, build and return a
     bytevector holding a 'struct sockaddr_in6' initialised with this
     data.

 -- Function: sockaddr_in6.in6_addr SOCKET-ADDRESS
 -- Function: sockaddr_in6.in6_port SOCKET-ADDRESS
     Given a bytevector SOCKET-ADDRESS holding a 'struct sockaddr_in6',
     extract the 'in6_addr' and 'in6_port' fields and return them as
     bytevector holding the corresponding 'struct in6_addr' and as
     fixnum.  If the data in SOCKET_ADDRESS is invalid: an exception is
     raised.

     Internally convert the port number to host byte order using
     'ntohs()' after the extraction of the value from the data
     structure.

 -- Function: in6addr_loopback
 -- Function: in6addr_any
     Build and return a bytevector holding the constant structures of
     type 'struct in6_addr' defined by 'in6addr_loopback' and
     'in6addr_any'.


File: vicare-libs.info,  Node: posix socket addresses rep,  Next: posix socket addresses info,  Prev: posix socket addresses in6,  Up: posix socket addresses

4.15.1.4 ASCII address representations
......................................

Dotted quad address representations can be handled as follows:

     (import (vicare)
       (prefix (vicare posix) px.))

     (px.inet-aton "127.0.0.1") => #vu8(127 0 0 1)
     (px.inet-aton "ciao")      error-> invalid argument

     (px.inet-ntoa/string '#vu8(127 0 0 1))
     => "127.0.0.1"

care must be taken when handling such raw values.

 -- Function: inet-aton DOTTED-QUAD
     ASCII to number.  Given the bytevector DOTTED-QUAD holding the
     ASCII dotted quad representation of a host address, build and
     return a bytevector holding the corresponding 'struct in_addr'.  If
     DOTTED-QUAD is invalid: an exception is raised.

 -- Function: inet-ntoa HOST-ADDRESS
 -- Function: inet-ntoa/string HOST-ADDRESS
     Number to ASCII.  Given the bytevector HOST-ADDRESS holding a
     'struct in_addr': 'inet-ntoa' builds and returns a bytevector
     holding the corresponding ASCII dotted quad representation,
     'inet-ntoa/string' builds and returns a string holding the
     corresponding ASCII dotted quad representation.

   Addresses in presentation format can be handled as follows:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (px.inet-pton AF_INET "127.0.0.1") => #vu8(127 0 0 1)
     (px.inet-pton AF_INET "ciao")      error-> invalid arguments

     (px.inet-pton AF_INET6 "1:2:3:4:5:6:7:8")
     => #vu16b(1 2 3 4 5 6 7 8)

     (px.inet-ntop/string AF_INET '#vu8(127 0 0 1))
     => "127.0.0.1"

     (px.inet-ntop/string AF_INET6 '#vu16b(1 2 3 4 5 6 7 8))
     => "1:2:3:4:5:6:7:8"

care must be taken when handling such raw values.

 -- Function: inet-pton AF PRESENTATION
     Given the fixnum AF, being 'AF_INET' or 'AF_INET6', and the string
     or bytevector PRESENTATION holding the ASCII presentation of an
     Internet address, build and return a bytevector holding the
     corresponding 'struct in_addr' or 'struct in6_addr'.  If either AF
     or PRESENTATION is invalid: raise an exception.

 -- Function: inet-ntop AF HOST-ADDRESS
 -- Function: inet-ntop/string AF HOST-ADDRESS
     Given the fixnum AF, being 'AF_INET' or 'AF_INET6', and the
     bytevector HOST-ADDRESS holding a 'struct in_addr' or 'struct
     in6_addr': 'inet-ntop' builds and returns a bytevector holding the
     corresponding ASCII presentation of the Internet address,
     'inet-ntop/string' builds and returns a string holding the
     corresponding ASCII presentation of the Internet address.  If the
     arguments are invalid: an exception is raised.


File: vicare-libs.info,  Node: posix socket addresses info,  Prev: posix socket addresses rep,  Up: posix socket addresses

4.15.1.5 Host address informations
..................................

 -- Structure Type: struct-addrinfo
     Scheme level representation of 'struct addrinfo'.  It has the
     following fields:

     'ai_flags'
          Fixnum.

     'ai_family'
          Fixnum, specifies the Internet address family; 'AF_INET',
          'AF_INET6' of 'AF_UNSPEC'.

     'ai_socktype'
          Fixnum, specifies the socket type; 'SOCK_STREAM', 'SOCK_DGRAM'
          or other 'SOCK_' value.

     'ai_protocol'
          Fixnum, specifies the protocol of the socket address.

     'ai_addrlen'
          Fixnum, the number of bytes in the bytevector referenced by
          'ai_addr'.

     'ai_addr'
          Bytevector, holds an instance of 'struct sockaddr' of
          'ai_addrlen' bytes.

     'ai_canonname'
          False or bytevector, represents the canoncal name of the host
          when available.

 -- Function: make-struct-addrinfo FLAGS FAMILY SOCKTYPE PROTOCOL
          ADDRLEN ADDR CANONNAME
     Build and return an instance of 'struct-addrinfo'.

 -- Function: struct-addrinfo? OBJ
     Return true if OBJ is an instance of 'struct-addrinfo'.

 -- Function: struct-addrinfo-ai_flags ADDRINFO
 -- Function: struct-addrinfo-ai_family ADDRINFO
 -- Function: struct-addrinfo-ai_socktype ADDRINFO
 -- Function: struct-addrinfo-ai_protocol ADDRINFO
 -- Function: struct-addrinfo-ai_addrlen ADDRINFO
 -- Function: struct-addrinfo-ai_addr ADDRINFO
 -- Function: struct-addrinfo-ai_canonname ADDRINFO
     Accessors for the fields of 'struct-addrinfo'.

 -- Function: getaddrinfo NODE SERVICE
 -- Function: getaddrinfo NODE SERVICE HINTS
     Interface to the C function 'getaddrinfo()', see the manual page
     'getaddrinfo(3)'.  Given the strings or bytevectors NODE and
     SERVICE identifying an Internet host and a service, build a list of
     'struct-addrinfo' instances representing addresses to which sockets
     can be bound or connected.

     Both NODE and SERVICE can be false, in which case the corresponding
     arguments handed to the C function are 'NULL'.  The optional
     argument HINTS must be '#f' or an instance of 'struct-addrinfo'
     used to select matching hosts.

     If successful: return the list of data structures, else raise an
     exception.

          (px.getaddrinfo "github.com" "smtp")
          => (#["struct-addrinfo"
                  ai_flags=40             ai_family=AF_INET
                  ai_socktype=SOCK_DGRAM  ai_protocol=17
                  ai_addrlen=16
                  ai_addr=#vu8(2 0 0 25 207 97 227 239 0 0 0 0 0 0 0 0)
                  ai_canonname=#f]
              #["struct-addrinfo"
                  ai_flags=40             ai_family=AF_INET
                  ai_socktype=SOCK_STREAM ai_protocol=6
                  ai_addrlen=16
                  ai_addr=#vu8(2 0 0 25 207 97 227 239 0 0 0 0 0 0 0 0)
                  ai_canonname=#f])


File: vicare-libs.info,  Node: posix socket hosts,  Next: posix socket protocols,  Prev: posix socket addresses,  Up: posix socket

4.15.2 Network hosts database
-----------------------------

 -- Struct Type: struct-hostent
     Data structure type used to represent at the Scheme level 'struct
     hostent' values.  It has the following fields:

     'h_name'
          Bytevector, the official host name.

     'h_aliases'
          List of bytevectors, host name aliases.

     'h_addrtype'
          Fixnum, 'AF_INET' or 'AF_INET6'.

     'h_length'
          Fixnum, number of bytes in each host address bytevector.

     'h_addr_list'
          List of bytevectors each holding 'struct in_addr' or 'struct
          in6_addr'.

     'h_addr'
          Bytevector, it is the first in the list 'h_addr_list'.

 -- Function: make-struct-hostent H_NAME H_ALIASES H_ADDRTYPE H_LENGTH
          H_ADDR_LIST H_ADDR
     Build and return an instance of 'struct-hostent'.

 -- Function: struct-hostent? OBJ
     Return '#t' if OBJ is an instance of 'struct-hostent', otherwise
     return '#f'.

 -- Function: struct-hostent-h_name HOSTENT
 -- Function: struct-hostent-h_aliases HOSTENT
 -- Function: struct-hostent-h_addrtype HOSTENT
 -- Function: struct-hostent-h_length HOSTENT
 -- Function: struct-hostent-h_addr_list HOSTENT
 -- Function: struct-hostent-h_addr HOSTENT
     Accessors for the fields of 'struct-hostent' instances.

 -- Function: gethostbyname HOSTNAME
     Interface to the C function 'gethostbyname()', *note gethostbyname:
     (libc)Host Names.  Given the string or bytevector HOSTNAME holding
     the ASCII representation of a host name, build and return an
     instance of 'struct-hostent'.  If an error occurs, return an
     encoded 'h_errno' value.

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.gethostbyname "github.com")
          => #["struct-hostent"
                 h_name="github.com"
                 h_aliases=()
                 h_addrtype=AF_INET
                 h_length=4
                 h_addr_list=(#vu8(207 97 227 239))
                 h_addr=#vu8(207 97 227 239)]

          (px.gethostbyname "google.com")
          => #["struct-hostent"
                 h_name="google.com"
                 h_aliases=()
                 h_addrtype=AF_INET
                 h_length=4
                 h_addr_list=(#vu8(209 85 148 103)
                              #vu8(209 85 148 99)
                              #vu8(209 85 148 104)
                              #vu8(209 85 148 105)
                              #vu8(209 85 148 106)
                              #vu8(209 85 148 147))
                 h_addr=#vu8(209 85 148 103)]

 -- Function: gethostbyaddr ADDR
     Interface to the C function 'gethostbyaddr()', *note gethostbyaddr:
     (libc)Host Names.  Given the bytevector ADDR holding a 'struct
     in_addr' or a 'struct in6_addr', build and return an instance of
     'struct-hostent'; the type of address is automatically inferred
     from the length of the bytevector.  If an error occurs: an
     exception is raised.

 -- Function: host-entries
     Interface to the C functions 'sethostent()', 'gethostent()' and
     'endhostent()', *note gethostbyaddr: (libc)Host Names.  Build and
     return a list of 'struct-hostent' representing the entries in the
     hosts database.


File: vicare-libs.info,  Node: posix socket protocols,  Next: posix socket services,  Prev: posix socket hosts,  Up: posix socket

4.15.3 Network protocols database
---------------------------------

 -- Structure Type: struct-protoent
     Scheme level representation of 'struct protoent'.  It has the
     following fields:

     'p_name'
          Bytevector, the ASCII coding of the official protocol name.

     'p_aliases'
          Null or list of bytevectors, the ASCII codings of protocol
          name aliases.

     'p_proto'
          Fixnum, the protocol number.

 -- Function: make-struct-protoent NAME ALIASES PROTO
     Build and return an instance of 'struct-protoent'.

 -- Function: struct-protoent-p_name PROTOENT
 -- Function: struct-protoent-p_aliases PROTOENT
 -- Function: struct-protoent-p_proto PROTOENT
     Accessors for the fields of 'struct-protoent'.

 -- Function: getprotobyname NAME
     Interface to the C function 'getprotobyname()', *note
     getprotobyname: (libc)Protocols Database.  Given a string or
     bytevector NAME holding the ASCII coding of a network protocol
     name, query the network protocols database and build an instance of
     'struct-protoent' mirroring the resulting 'struct protoent' entry.
     If successful return the data structure, else raise an exception.

          (px.getprotobyname "udp")
          => #["struct-protoent"
                  p_name="udp"
                  p_aliases=(UDP)
                  p_proto=17]

 -- Function: getprotobynumber PROTO_NUM
     Interface to the C function 'getprotobynumber()', *note
     getprotobynumber: (libc)Protocols Database.  Given a fixnum
     PROTO_NUM being the number of a network protocol, query the network
     protocols database and build an instance of 'struct-protoent'
     mirroring the resulting 'struct protoent' entry.  If successful
     return the data structure, else raise an exception.

          (px.getprotobynumber 17)
          => #["struct-protoent"
                  p_name="udp"
                  p_aliases=(UDP)
                  p_proto=17]

 -- Function: protocol-entries
     Interface to the C functions 'setprotoent()', 'getprotoent()' and
     'endprotoent()', *note setprotoent: (libc)Protocols Database.  Scan
     the network protocol database and build a list of 'struct-protoent'
     mirroring the resulting 'struct protoent' entries.  Return the list
     of structures.


File: vicare-libs.info,  Node: posix socket services,  Next: posix socket networks,  Prev: posix socket protocols,  Up: posix socket

4.15.4 Network services database
--------------------------------

 -- Structure Type: struct-servent
     Scheme level representation of 'struct servent'.  It has the
     following fields:

     's_name'
          Bytevector, the ASCII coding of the official service name.

     's_aliases'
          Null or list of bytevectors, the ASCII codings of service name
          aliases.

     's_port'
          Fixnum, the port number.

     's_proto'
          Bytevector, ASCII coding of the associated protocol name.

 -- Function: make-struct-servent NAME ALIASES PORT PROTO
     Build and return an instance of 'struct-servent'.

 -- Function: struct-servent-s_name SERVENT
 -- Function: struct-servent-s_aliases SERVENT
 -- Function: struct-servent-s_proto SERVENT
 -- Function: struct-servent-s_port SERVENT
     Accessors for the fields of 'struct-servent'.

 -- Function: getservbyname NAME PROTOCOL
     Interface to the C function 'getservbyname()', *note getservbyname:
     (libc)Services Database.  Given the strings or bytevectors NAME and
     PROTOCOL holding the ASCII coding of a network service name and
     protocol, query the network services database and build an instance
     of 'struct-servent' mirroring the resulting 'struct servent' entry.
     If successful return the data structure, else raise an exception.

          (px.getservbyname "smtp" "tcp")
          => #["struct-servent"
                  s_name="smtp"
                  s_aliases=(mail)
                  s_port=25
                  s_proto=tcp]

          (px.getservbyname "ntp" "udp")
          => #["struct-servent"
                  s_name="ntp"
                  s_aliases=()
                  s_port=123
                  s_proto=udp]

 -- Function: getservbynumber PORT PROTOCOL
     Interface to the C function 'getservbynumber()', *note
     getservbynumber: (libc)Services Database.  Given a fixnum PORT and
     a string or bytevector PROTOCOL being the port number and protocol
     name of a network service, query the network services database and
     build an instance of 'struct-servent' mirroring the resulting
     'struct servent' entry.  If successful return the data structure,
     else raise an exception.

          (px.getservbyport 80 "tcp")
          => #["struct-servent"
                  s_name="http"
                  s_aliases=(www-http www)
                  s_port=80
                  s_proto=tcp]

 -- Function: service-entries
     Interface to the C functions 'setservent()', 'getservent()' and
     'endservent()', *note setservent: (libc)Services Database.  Scan
     the network service database and build a list of 'struct-servent'
     mirroring the resulting 'struct servent' entries.  Return the list
     of structures.


File: vicare-libs.info,  Node: posix socket networks,  Next: posix socket socket,  Prev: posix socket services,  Up: posix socket

4.15.5 Networks database
------------------------

 -- Structure Type: struct-netent
     Scheme level representation of 'struct netent'.  It has the
     following fields:

     'n_name'
          Bytevector, ASCII coding of the official network name.

     'n_aliases'
          List of bytevectors, alias names for the network.

     'n_addrtype'
          Fixnum, the network type.

     'n_net'
          32-bit bytevector, the network number in network byte order.

 -- Function: make-struct-netent NAME ALIASES ADDRTYPE NET
     Build and return a new instance of 'struct-netent'.

 -- Function: struct-netent-n_name NETENT
 -- Function: struct-netent-n_aliases NETENT
 -- Function: struct-netent-n_addrtype NETENT
 -- Function: struct-netent-n_net NETENT
     Accessors for the fields of 'struct-netent'.

 -- Function: struct-netent? OBJ
     Return '#t' if OBJ is an instance of 'struct-netent'.

 -- Function: getnetbyname NAME
     Interface to the C function 'getnetbyname()', *note getnetbyname:
     (libc)Networks Database.  Given the bytevector NAME holding the
     ASCII coding of a network name, query the networks database and
     build an instance of 'struct-netent' mirroring the resulting
     'struct netent' entry.  If successful return the data structure,
     else raise an exception.

          (px.getnetbyname "loopback")
          => #["struct-netent"
                  n_name="loopback"
                  n_aliases=()
                  n_addrtype=AF_INET
                  n_net=#vu8(127 0 0 0)]

 -- Function: getnetbyaddr NET TYPE
     Interface to the C function 'getnetbyaddr()', *note getnetbyaddr:
     (libc)Networks Database.  Given an exact integer or bytevector NET
     representing a network number and the fixnum TYPE representing a
     network type, query the networks database and build an instance of
     'struct-netent' mirroring the resulting 'struct netent' entry.  If
     successful return the data structure, else raise an exception.

          (px.getnetbyaddr '#vu8(127 0 0 0) AF_INET)
          => #["struct-netent"
                  n_name="loopback"
                  n_aliases=()
                  n_addrtype=AF_INET
                  n_net=#vu8(127 0 0 0)]

 -- Function: network-entries
     Interface to the C functions 'setnetent()', 'getnetent()' and
     'endnetent()', *note setnetent: (libc)Networks Database.  Scan the
     networks database and build a list of 'struct-netent' mirroring the
     resulting 'struct netent' entries.  Return the list of structures.


File: vicare-libs.info,  Node: posix socket socket,  Next: posix socket misc,  Prev: posix socket networks,  Up: posix socket

4.15.6 Network sockets operations
---------------------------------

 -- Function: socket NAMESPACE STYLE PROTOCOL
     Interface to the C function 'socket()', *note socket:
     (libc)Creating a Socket.  Create a new socket descriptor and return
     it as non-negative fixnum; if an error occurs raise an exception.
     All the arguments must be fixnums.

 -- Function: shutdown SOCK HOW
     Interface to the C function 'shutdown()', *note shutdown:
     (libc)Closing a Socket.  Close the socket SOCK according to HOW,
     which can be one of the constants 'SHUT_RD', 'SHUT_WR' or
     'SHUT_RDWR'.  If successful return unspecified values, else raise
     an exception.

 -- Function: socketpair NAMESPACE STYLE PROTOCOL
     Interface to the C function 'socketpair()', *note socketpair:
     (libc)Socket Pairs.  Create a pairs of connected sockets and return
     two values being the descriptors as non-negative fixnums; if an
     error occurs raise an exception.  All the arguments must be
     fixnums; NAMESPACE must be 'AF_LOCAL'.

          (import (rnrs)
            (prefix (vicare posix) px.)
            (vicare platform constants))

          (let-values (((a b) (px.socketpair AF_LOCAL SOCK_DGRAM 0)))
            (px.write a '#vu8(1 2 3 4) 4)
            (let ((buf (make-bytevector 4)))
              (px.read b buf 4)
              (px.shutdown a SHUT_RDWR)
              (px.shutdown b SHUT_RDWR)
              buf))
          => #vu8(1 2 3 4)

 -- Function: connect SOCK ADDR
     Interface to the C function 'connect()', *note connect:
     (libc)Connecting.  Connect the socket SOCK to the address specified
     by the bytevector ADDR which must hold a concrete instance of
     'struct sockaddr'.  If successful return unspecified values, else
     raise an exception.

 -- Function: listen SOCK PENDING_CONNS
     Interface to the C function 'listen()', *note listen:
     (libc)Listening.  Enable the socket SOCK to accept connections; the
     fixnum PENDING_CONNS specifies the maximum length of the pending
     connection requests queue, it can be at most equal to the platform
     constant 'SOMAXCONN'.  If successful return unspecified values,
     else raise an exception.

 -- Function: accept SOCK
     Interface to the C function 'accept()', *note accept:
     (libc)Accepting Connections.  Accept an incoming connection to the
     server socket SOCK.

     If successful and a connection is accepted return two values: a
     non-negative fixnum representing the socket, a bytevector
     representing the client address as 'struct sockaddr'.

     If successful and no connection is accepted return two values both
     being false; this is the case of 'accept()' returning 'EWOULDBLOCK'
     which means that SOCK is in non-blocking mode and no pending
     connections exist.

     If an error occurs raise an exception.

 -- Function: bind SOCK SOCKADDR
     Interface to the C function 'bind()', *note bind: (libc)Setting
     Address.  Bind the socket descriptor SOCK to the address specified
     by the 'struct sockaddr' in the bytevector SOCKADDR.  If successful
     return unspecified values, else raise an exception.

 -- Function: getpeername SOCK
     Interface to the C function 'getpeername()', *note getpeername:
     (libc)Who is Connected.  Retrieve informations about the address of
     the socket to which the SOCK socket is connected to.  If successful
     return a bytevector holding a 'struct sockaddr', else raise an
     exception.

 -- Function: getsockname SOCK
     Interface to the C function 'getsockanme()', *note getsockname:
     (libc)Setting Address.  Retrieve informations about the address
     bound to the socket descriptor SOCK.  If successful return a
     bytevector holding the 'struct sockaddr', else raise an exception.

 -- Function: send SOCK BUFFER SIZE FLAGS
     Interface to the C function 'send()', *note send: (libc)Sending
     Data.  Like 'write()' but with the additional argument FLAGS which
     must be a fixnum: write data from BUFFER to the socket SOCK.  If
     successful return a non-negative fixnum representing the number of
     bytes actually sent, else raise an exception.

     BUFFER and SIZE must represent a generalised C string, *note
     Introduction to generalised C strings: (vicare-libs)cbuffers
     strings.  When BUFFER is a Scheme string: it is converted to a
     bytevector with 'string->ascii'.

 -- Function: recv SOCK BUFFER SIZE FLAGS
     Interface to the C function 'recv()', *note recv: (libc)Receiving
     Data.  Like 'read()' but with the additional argument FLAGS which
     must be a fixnum: read data from SOCK and store it in BUFFER.  If
     successful return a non-negative fixnum representing the number of
     bytes actually received, else raise an exception.

     BUFFER and SIZE must represent a generalised C buffer, *note
     Introduction to generalised C buffers: (vicare-libs)cbuffers
     buffers.

 -- Function: sendto SOCK BUFFER SIZE FLAGS ADDR
     Interface to the C function 'sendto()', *note sendto: (libc)Sending
     Datagrams.  Like 'send()' but with the additional argument ADDR
     which must be a bytevector holding a 'struct sockaddr': write data
     from BUFFER to the socket SOCK to the destination specified by
     ADDR.

     BUFFER and SIZE must represent a generalised C string, *note
     Introduction to generalised C strings: (vicare-libs)cbuffers
     strings.  When BUFFER is a Scheme string: it is converted to a
     bytevector with 'string->ascii'.

     If successful return a non-negative fixnum representing the number
     of bytes actually sent, else raise an exception.

 -- Function: recvfrom SOCK BUFFER SIZE FLAGS
     Interface to the C function 'recvfrom()', *note recvfrom:
     (libc)Receiving Datagrams.  Like 'recv()' but additionally retrieve
     informations about the address of the sender: read data from SOCK
     and store it in BUFFER.

     BUFFER and SIZE must represent a generalised C buffer, *note
     Introduction to generalised C buffers: (vicare-libs)cbuffers
     buffers.

     If successful return two values: a non-negative fixnum representing
     the number of bytes actually received, a bytevector holding a
     'struct sockaddr' representing the address of the sender; else
     raise an exception.

   The functions 'getsockopt' and 'setsockopt', and their variants, can
be used to configure a number of socket options.  To inspect the list of
available options read the following manual pages (on GNU+Linux)
systems:

   * For generic networking socket options: the LEVEL argument must be
     set to 'SOL_SOCKET'.  *note Socket Options: (*manpages*)socket(7).

   * For packet interface on device level socket options: the LEVEL
     argument must be set to 'SOL_PACKET'.  *note Socket Options:
     (*manpages*)packet(7).

   * For IP specific options: the LEVEL argument must be set to
     'IPPROTO_IP'.  *note Socket Options: (*manpages*)ip(7).

   * For TCP specific options: the LEVEL argument must be set to
     'IPPROTO_TCP'.  *note Socket Options: (*manpages*)tcp(7).

   * For UDP specific options: the LEVEL argument must be set to
     'IPPROTO_UDP'.  *note Socket Options: (*manpages*)udp(7),

   * For raw socket options: the LEVEL argument must be set to
     'IPPROTO_RAW'.  *note Raw sockets: (*manpages*)raw(7).

 -- Function: getsockopt SOCK LEVEL OPTION OPTVAL
     Interface to the C function 'getsockopt()', *note getsockopt:
     (libc)Socket Option Function.  Retrieve the value of OPTION of
     socket SOCK at LEVEL and store it in the bytevector OPTVAL.  OPTION
     and LEVEL must be fixnums.  If successful return unspecified
     values, else raise an exception.

 -- Function: setsockopt SOCK LEVEL OPTION OPTVAL
     Interface to the C function 'setsockopt()', *note setsockopt:
     (libc)Socket Option Function.  Set a new value for OPTION of socket
     SOCK at LEVEL reading it from the bytevector OPTVAL.  OPTION and
     LEVEL must be fixnums.  If successful return unspecified values,
     else raise an exception.

 -- Function: getsockopt/int SOCK LEVEL OPTION
 -- Function: setsockopt/int SOCK LEVEL OPTION OPTVAL
     Like 'getsockopt' and 'setsockopt' but specially handle the case of
     an option with value represented by a C language 'int'.  OPTVAL
     must appropriately be a boolean or an exact integer representable
     as a platform's C language 'int'.

 -- Function: getsockopt/size_t SOCK LEVEL OPTION
 -- Function: setsockopt/size_t SOCK LEVEL OPTION OPTVAL
     Like 'getsockopt' and 'setsockopt' but specially handle the case of
     an option with value represented by a C language 'size_t'.  OPTVAL
     must be an exact integer representable as a platform's C language
     'size_t'.

 -- Function: setsockopt/linger SOCK ONOFF LINGER
     Similar to 'setsockopt', but set the 'SO_LINGER' option by directly
     specifying the values for the fields of the 'struct linger' type.
     *note struct linger: (libc)Socket-Level Options.

     ONOFF must be a boolean.  LINGER must be a fixnum.

 -- Function: getsockopt/linger SOCK
     Similar to 'getsockopt', but inspect directly the option
     'SO_LINGER' by returning the current values of the fields of the
     'struct linger' type.  *note struct linger: (libc)Socket-Level
     Options.

     Return 2 values: a boolean representing the 'onoff' field, an exact
     integer representing the LINGER field.

 -- Function: tcp-connect HOSTNAME SERVICE
 -- Function: tcp-connect HOSTNAME SERVICE LOG-PROC
     Establish a client connection to the remote host identified by the
     string HOSTNAME, connecting to the port associated to the string or
     number SERVICE.

     If successful return a textual input/output port associated to the
     socket file descriptor, configured with 'line' buffer mode, UTF-8
     transcoder, and 'none' end-of-line translation.  Closing the
     returned port will close the connection.

     This function makes use of 'getaddrinfo' to obtain possible network
     interfaces to connect to and attempts to connect to all of them
     stopping at the first success.

     The optional argument LOG-PROC must be a function and it is called
     while attempting to connect to an interface; the arguments are:

          (LOG-PROC ACTION HOSTNAME SERVICE SOCKADDR)

     where: ACTION is one of the symbols 'attempt', 'success', 'fail';
     SOCKADDR is a bytevector holding an instance of 'struct sockaddr'
     from a 'struct addrinfo'.

     To actually attempt a connection: make use of the function
     referenced by the parameter 'tcp-connect.connect-proc', which is
     initialised to 'connect'.

     The following example will download the main page from
     <http://google.it>:

          #!r6rs
          (import (except (vicare)
                          log)
            (prefix (vicare posix) px.))

          (define (log template . args)
            (apply fprintf (current-error-port)
                   template args))

          (define (send line port)
            (log "sending: ~s\n" line)
            (display line port))

          (define (recv in-port)
            (let-values (((str-port getter) (open-string-output-port)))
              (let next ((line (read-line in-port)))
                (if (or (eof-object? line)
                        (string=? line "\r")
                        (string=? line ".\r"))
                    (getter)
                  (begin
                    (log "received: ~s\n" line)
                    (display line str-port)
                    (next (read-line in-port)))))))

          (define p
            (px.tcp-connect "google.it" "http"))

          (send "GET / HTTP/1.0\r\n\r\n" p)
          (recv p)
          (recv p)

          (close-port p)

 -- Function: tcp-connect/binary HOSTNAME SERVICE
 -- Function: tcp-connect/binary HOSTNAME SERVICE LOG-PROC
     Establish a client connection to the remote host identified by the
     string HOSTNAME, connecting to the port associated to the string or
     number SERVICE.  This function is similar to 'tcp-connect', but it
     returns a binary input output port.

 -- Parameter: tcp-connect.connect-proc
     References a function used by 'tcp-connect' to actually attempt a
     TCP connection.  It is initialised to 'connect'.

     This parameter allows us to fake a failed connection attempt by
     registering a function that raises an '&errno' exception with
     'errno' code among:

          EADDRNOTAVAIL   ETIMEDOUT
          ECONNREFUSED    ENETUNREACH


File: vicare-libs.info,  Node: posix socket misc,  Next: posix socket examples,  Prev: posix socket socket,  Up: posix socket

4.15.7 Error and miscellaneous functions
----------------------------------------

 -- Function: h_errno->string H_ERRNO-CODE
     Convert an encoded 'h_errno' value to the corresponding symbolic
     string.

 -- Function: h_strerror H_ERRNO-CODE
     Convert an encoded 'h_errno' value to the corresponding descriptive
     error message string.

 -- Function: gai-strerror ERROR-CODE
     Interface to the C function 'gai_strerror()', see the manual page
     'gai_strerror(3)'.  Convert an 'EAI_' error code into the
     corresponding error message, return a string holding such message.

 -- Function: htonl HOST-LONG
 -- Function: ntohl NET-LONG
     Convert an exact integer, in the range of the C language type
     'uint32_t', between host byte order and network byte order; *note
     ntohl: (libc)Byte Order.

     On the i386 platform: host byte order is least significant byte
     first.  The network byte order is: most significant byte first.

          #!r6rs
          (import (vicare)
            (prefix (vicare posix) px.))

          (px.htonl #xA5B6C7D8)                   => #xD8C7B6A5
          (px.ntohl #xA5B6C7D8)                   => #xD8C7B6A5
          (px.ntohl (px.htonl #xA5B6C7D8))        => #xA5B6C7D8

 -- Function: htons HOST-SHORT
 -- Function: ntohs NET-SHORT
     Convert an exact integer, in the range of the C language type
     'uint16_t', between host byte order and network byte order; *note
     htons: (libc)Byte Order.

     On the i386 platform: host byte order is least significant byte
     first.  The network byte order is: most significant byte first.

          #!r6rs
          (import (vicare)
            (prefix (vicare posix) px.))

          (px.htons #xA5B6)               => #xB6A5
          (px.ntohs #xA5B6)               => #xB6A5
          (px.ntohs (px.htons #xA5B6))    => #xA5B6


File: vicare-libs.info,  Node: posix socket examples,  Next: posix socket oob,  Prev: posix socket misc,  Up: posix socket

4.15.8 Examples of clients and servers
--------------------------------------

Basically a TCP/IP server should do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let ((sockaddr    (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
           (server-sock (px.socket PF_INET SOCK_STREAM 0)))
       (px.bind   server-sock sockaddr)
       (px.listen server-sock 2)
       (let-values (((sock client-address)
                     (px.accept server-sock)))
         ;; ... talk with the client through SOCK ...
         (px.close sock))
       (px.close server-sock))

while a TCP/IP client should to:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let ((sockaddr (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
           (sock     (px.socket PF_INET SOCK_STREAM 0)))
       (px.connect sock sockaddr)
       ;; ... talk to the server through SOCK ...
       (px.close sock))

   A UDP/IP "server" should do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let ((sockaddr   (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
           (sock       (px.socket PF_INET SOCK_DGRAM 0))
           (in-buffer  (make-bytevector 1024))
           (out-buffer (make-bytevector 1024)))
       (px.bind sock sockaddr)
       (let-values (((len sockaddr)
                     (px.recvfrom sock in-buffer #f 0)))
         ;; ... process the received packet ...
         ;; ... prepare the answer ...
         (px.sendto sock out-buffer #f 0 sockaddr))
       (px.close sock))

while a UDP/IP "client" should do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let ((sockaddr   (px.make-sockaddr_in '#vu8(127 0 0 1) 8081))
           (sock       (px.socket PF_INET SOCK_DGRAM 0))
           (out-buffer (make-bytevector 1024))
           (in-buffer  (make-bytevector 1024)))
       (px.bind sock sockaddr)
       ;; ... prepare the request ...
       (px.sendto sock out-buffer #f 0 sockaddr)
       (let-values (((len sockaddr)
                     (px.recvfrom sock in-buffer #f 0)))
         ;; ... process the received packet ...
         )
       (px.close sock))

   A Unix-domain socket server should do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let* ((tmpdir       (px.getenv "TMPDIR"))
            (pathname     (string-append tmpdir "/use-me"))
            (sockaddr     (px.make-sockaddr_un pathname))
            (server-sock  (px.socket PF_LOCAL SOCK_STREAM 0)))
       (px.bind   server-sock sockaddr)
       (px.listen server-sock 2)
       (let-values (((sock client-address)
                     (px.accept server-sock)))
         ;; ... talk to the client through SOCK ...
         (px.close sock))
       (px.close server-sock))

while a Unix-domain socket client should do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let* ((tmpdir    (px.getenv "TMPDIR"))
            (pathname  (string-append tmpdir "/use-me"))
            (sockaddr  (px.make-sockaddr_un pathname))
            (sock      (px.socket PF_LOCAL SOCK_STREAM 0)))
       (px.connect sock sockaddr)
       ;; ... talk to the server through SOCK ...
       (px.close sock))

   To receive incoming data and Out Of Band data, a TCP/IP server should
do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let ((sockaddr    (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
           (server-sock (px.socket PF_INET SOCK_STREAM 0)))
       (px.bind   server-sock sockaddr)
       (px.listen server-sock 2)
       (let*-values
           (((sock client-address) (px.accept server-sock))
            ((bv)                  (make-bytevector 10)))
         (let loop ()
           (let-values (((rd wr ex) (px.select-fd sock 2 0)))
             (cond (ex ;process exceptional conditions first!!!
                    ;; block until OOB data arrives
                    (let ((len (px.recv sock bv #f MSG_OOB)))
                      ;; process data in BV between 0 and LEN,
                      ;; which should be 1
                      (loop)))
                   (rd
                    (let ((len (px.recv sock bv #f 0)))
                      (when (positive? len)
                        ;; process data in BV between 0
                        ;; and LEN
                        (loop))))
                   (else (loop)))))
         (px.close sock))
       (px.close server-sock))

to send outgoing data and Out Of Band data, a TCP/IP client should do:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (let ((sockaddr  (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
           (sock      (px.socket PF_INET SOCK_STREAM 0)))
       (px.connect sock sockaddr)
       (px.send sock '#vu8(1 2 3) #f 0)
       ;; only the single byte 6 (the last) is sent as
       ;; OOB data, 4 and 5 are sent as ordinary data
       (px.send sock '#vu8(4 5 6) #f MSG_OOB)
       (px.send sock '#vu8(7 8 9) #f 0)
       (px.close sock))


File: vicare-libs.info,  Node: posix socket oob,  Prev: posix socket examples,  Up: posix socket

4.15.9 Notes on transmission of OOB data
----------------------------------------

In a TCP/IP stream-oriented client/server architecture, the scenario is
the following:

      --------------------        ------------
     | sending appication |----->| sending OS |
      --------------------        ------------
                                       |
                                       v
      -----------------------     -------------
     | receiving application |<--| receving OS |
      -----------------------     -------------

sending ordinary data works as follows:

  1. The sending application calls (for example) the 'send' function
     asking the sending OS to send data to the remote host.

  2. The sending OS enqueues the data in a FIFO buffer, which it
     progressively fragments in packets for delivery.

  3. The receiving OS orders and enqueues data from received packets in
     a FIFO buffer.

  4. The receiving application calls (for example) the 'recv()' function
     to consume chunks of the input data.

sending a single byte of OOB data works as follows:

  1. The sending application calls the function 'send' specifying the
     'MSG_OOB' flag, asking the sending OS to deliver a single byte of
     OOB data.

  2. The sending OS enqueues the single byte in its FIFO buffer and tags
     the next outgoing packet to announce future delivery of the OOB
     byte.

  3. The receiving OS orders and enqueues data from received packets in
     a FIFO buffer; when it detects a tagged packet announcing the OOB
     byte: it optionally informs the receiving application of its future
     arrival, signaling an exceptional condition on the socket
     descriptor, if requested.

  4. The sending OS proceeds in sending ordinary data from its FIFO
     buffer and whenever it reaches the OOB byte: it sends it in a
     specially tagged packet.

  5. The receiving OS orders and enqueues data from received packets in
     a FIFO buffer; when it detects a tagged packet holding the OOB
     byte: it makes it available to the receiving application.

  6. The receving application calls the function 'recv' specifying the
     'MSG_OOB' flag and retrieves the single OOB byte.

   If we send the OOB byte with the form:

     (px.send sock '#vu8(8) #f MSG_OOB)

the byte '8' will be the OOB byte; if we send the OOB byte with the
form:

     (px.send sock '#vu8(1 2 3) #f MSG_OOB)

the byte '3', the last in the memory block, will be the OOB byte and the
bytes '1' and '2' will be sent as ordinary data; the receiving
application must *not* assume that bytes '1' and '2' will be made
available before the OOB byte '3'.

   When using 'select' to be notified of incoming OOB data: the
receiving application must assume that the exceptional condition is
notified *only once* and not persist in further calls to 'select'; for
this reason the exceptional condition must be recognised and registered
by the application as soon as it is notified by 'select'.

   The socket option 'SO_OOBINLINE' allows the OOB byte to be placed in
the ordinary data FIFO buffer, so that it can be transparently consumed
by a call to 'read' or 'recv' without the 'MSG_OOB' flag.

   Notice that the single OOB byte, although limited, can represent 256
symbols in an appropriate alphabet of commands.


File: vicare-libs.info,  Node: posix users,  Next: posix job,  Prev: posix socket,  Up: posix

4.16 Users and groups
=====================

 -- Function: getuid
     Interface to the C function 'getuid()', *note getuid: (libc)Reading
     Persona.  Return a fixnum representing the real user ID of the
     process.

 -- Function: getgid
     Interface to the C function 'getgid()', *note getgid: (libc)Reading
     Persona.  Return a fixnum representing the real group ID of the
     process.

 -- Function: geteuid
     Interface to the C function 'geteuid()', *note geteuid:
     (libc)Reading Persona.  Return a fixnum representing the effective
     user ID of the process.

 -- Function: getegid
     Interface to the C function 'getegid()', *note getegid:
     (libc)Reading Persona.  Return a fixnum representing the effective
     group ID of the process.

 -- Function: getgroups
     Interface to the C function 'getgroups()', *note getgroups:
     (libc)Reading Persona.  Return a list of fixnums representing the
     supplementary group IDs of the process; if an error occurs an
     exception is raised.

 -- Function: seteuid NEW-UID
     Interface to the C function 'seteuid()', *note seteuid:
     (libc)Setting User ID. Set the effective user ID to NEW-UID, which
     must be a fixnum.  If successful return unspecified values, else
     raise an exception.

 -- Function: setuid NEW-UID
     Interface to the C function 'setuid()', *note setuid: (libc)Setting
     User ID. Set both the real and effective user IDs to NEW-UID, which
     must be a fixnum.  If successful return unspecified values, else
     raise an exception.

 -- Function: setreuid REAL-UID EFFECTIVE-UID
     Interface to the C function 'setreuid()', *note setreuid:
     (libc)Setting User ID. Set the real user ID to REAL_UID and the
     effective user ID to EFFECTIVE_UID, both the arguments must be
     fixnums.  If successful return unspecified values, else raise an
     exception.

 -- Function: setegid NEW-GID
     Interface to the C function 'setegid()', *note setegid:
     (libc)Setting Group.  Set the effective group ID to NEW-GID, which
     must be a fixnum.  If successful return unspecified values, else
     raise an exception.

 -- Function: setgid NEW-GID
     Interface to the C function 'setgid()', *note setgid: (libc)Setting
     Groups.  Set both the real and effective group IDs to NEW-GID,
     which must be a fixnum.  If successful return unspecified values,
     else raise an exception.

 -- Function: setregid REAL-GID EFFECTIVE-GID
     Interface to the C function 'setregid()', *note setregid:
     (libc)Setting Group.  Set the real group ID to REAL_GID and the
     effective group ID to EFFECTIVE_GID, both the arguments must be
     fixnums.  If successful return unspecified values, else raise an
     exception.

 -- Function: getlogin
 -- Function: getlogin/string
     Interface to the C function 'getlogin()', *note getlogin: (libc)Who
     Logged In.  'getlogin' returns a bytevector holding the ASCII
     coding of the name of the user logged in on the controlling
     terminal of the process; 'getlogin/string' returns a string; if the
     name cannot be determined: return false.

 -- Structure Type: struct-passwd
     Scheme level representation of 'struct passwd'.  It has the
     following fields:

     'pw_name'
          Bytevector, user login name.

     'pw_passwd'
          Bytevector, encrypted password.

     'pw_uid'
          Fixnum, user ID.

     'pw_gid'
          Fixnum, group ID.

     'pw_gecos'
          Bytevector, user data.

     'pw_dir'
          Bytevector, user's home directory.

     'pw_shell'
          Bytevector, user's default shell.

 -- Function: make-struct-passwd NAME PASSWD UID GID GECOS DIR SHELL
     Build and return a new instance of 'struct-passwd'.

 -- Function: struct-passwd? OBJ
     Return '#t' if OBJ is an instance of 'struct-passwd'.

 -- Function: struct-passwd-pw_name PASSWD
 -- Function: struct-passwd-pw_passwd PASSWD
 -- Function: struct-passwd-pw_uid PASSWD
 -- Function: struct-passwd-pw_gid PASSWD
 -- Function: struct-passwd-pw_gecos PASSWD
 -- Function: struct-passwd-pw_dir PASSWD
 -- Function: struct-passwd-pw_shell PASSWD
     Accessors for the fields of 'struct-passwd'.

 -- Function: getpwuid UID
     Interface to the C function 'getpwuid()', *note getpwuid:
     (libc)Lookup User.  Retrieve informations on the user with
     identifier UID, which must be a fixnum.  If successful return an
     instance of 'struct-passwd'; if a user with such an ID does not
     exists: return false.

 -- Function: getpwnam NAME
     Interface to the C function 'getpwnam()', *note getpwnam:
     (libc)Lookup User.  Retrieve informations on the user with name
     represented in ASCII coding in the string or bytevector NAME.  If
     successful return an instance of 'struct-passwd'; if a user with
     such an ID does not exists: return false.

 -- Function: user-entries
     Interface to the C functions 'setpwent()', 'getpwent()' and
     'endpwent()', *note setpwent: (libc)Scanning All Users.  Iterate
     the database of users and return a list of 'struct-passwd'
     representing the entries.

 -- Structure Type: struct-group
     Scheme level representation of 'struct group'.  It has the
     following fields:

     'gr_name'
          Bytevector, group name.

     'gr_gid'
          Fixnum, group ID.

     'gr_mem'
          List of bytevectors, user names.

 -- Function: make-struct-group NAME GID MEM
     Build and return a new instance of 'struct-group'.

 -- Function: struct-group-gr_name GROUP
 -- Function: struct-group-gr_gid GROUP
 -- Function: struct-group-gr_mem GROUP
     Accessors for the fields of 'struct-group'.

 -- Function: getgrgid GID
     Interface to the C function 'getgrgid()', *note getgrgid:
     (libc)Lookup Group.  Retrieve informations on the group with
     identifier GID, which must be a fixnum.  If successful return an
     instance of 'struct-group'; if a group with such an ID does not
     exists: return false.

 -- Function: getgrnam NAME
     Interface to the C function 'getgrnam()', *note getgrnam:
     (libc)Lookup Group.  Retrieve informations on the group with name
     represented in ASCII coding in the string or bytevector NAME.  If
     successful return an instance of 'struct-group'; if a group with
     such an ID does not exists: return false.

 -- Function: group-entries
     Interface to the C functions 'setgrent()', 'getgrent()' and
     'endgrent()', *note setgrent: (libc)Scanning All Groups.  Iterate
     the database of groups and return a list of 'struct-group'
     representing the entries.


File: vicare-libs.info,  Node: posix job,  Next: posix time,  Prev: posix users,  Up: posix

4.17 Job control
================

 -- Function: ctermid
 -- Function: ctermid/string
     Interface to the C function 'ctermid()', *note ctermid:
     (libc)Identifying the Terminal.  Return a bytevector or string
     holding the ASCII coded pathname of the controlling terminal of the
     current process; the returned value may be the empty bytevector or
     string.

 -- Function: setsid
     Interface to the C function 'setsid()', *note setsid: (libc)Process
     Group Functions.  Create a new session, making the current process
     the group leader with no controlling terminal.  If successful
     return a fixnum representing the new process group ID, else raise
     an exception.

 -- Function: getsid PID
     Interface to the C function 'getsid()', *note getsid: (libc)Process
     Group Functions.  If successful return a fixnum representing the
     session ID of the process with process ID PID, which must be a
     fixnum; else raise an exception.

 -- Function: getpgrp
     Interface to the C function 'getpgrp()', *note getpgrp:
     (libc)Process Group Functions.  Return a fixnum representing the
     process group ID of the calling process.

 -- Function: setpgid PID PGID
     Interface to the C function 'setpgid()', *note setpgid:
     (libc)Process Group Functions.  Put the process PID in the process
     group PGID; both the arguments must be fixnums.  If successful
     return unspecified values, else raise an exception.

 -- Function: tcgetpgrp FD
     Interface to the C function 'tcgetpgrp()', *note tcgetpgrp:
     (libc)Terminal Access Functions.  If successful return a fixnum
     representing the process group ID of the foreground process group
     associated with the terminal open on descriptor FD, which must be a
     fixnum; else raise an exception.

 -- Function: tcsetpgrp FD PGID
     Interface to the C function 'tcsetpgrp()', *note tcsetpgrp:
     (libc)Terminal Access Functions.  Set to process group ID PGID the
     foreground process group for the terminal open on descriptor FD;
     both the arguments must be fixnums.  If successful return the
     fixnum zero, else raise an exception.

 -- Function: tcgetsid FD
     Interface to the C function 'tcgetsid()', *note tcgetsid:
     (libc)Terminal Access Functions.  If successful return a fixnum
     representing the process group ID of the session for which the
     terminal open on descriptor FD is the controlling terminal; else
     raise an exception.


File: vicare-libs.info,  Node: posix time,  Next: posix timers,  Prev: posix job,  Up: posix

4.18 Date and time
==================

* Menu:

* posix time timeval::          Data structure 'struct-timeval'.
* posix time timespec::         Data structure 'struct-timespec'.
* posix time tms::              Data structure 'struct-tms'.
* posix time tm::               Data structure 'struct-tm'.
* posix time itimerval::        Data structure 'struct-itimerval'.
* posix time itimerspec::       Data structure 'struct-itimerspec'.
* posix time functions::        Date and time functions.


File: vicare-libs.info,  Node: posix time timeval,  Next: posix time timespec,  Up: posix time

4.18.1 Data structure 'struct-timeval'
--------------------------------------

 -- Structure Type: struct-timeval
     Scheme level representation of 'struct timeval', *note struct
     timeval: (libc)Elapsed Time.  It has the following fields:

     'tv_sec'
          Exact integer, represents a count of seconds.

     'tv_usec'
          Exact integer, represents a count of microseconds.

 -- Function: make-struct-timeval SEC USEC
     Build and return a new instance of 'struct-timeval'.

 -- Function: struct-timeval? OBJ
     Return '#t' if OBJ is an instance of 'struct-timeval'.

 -- Function: struct-timeval-tv_sec TIMEVAL
 -- Function: struct-timeval-tv_usec TIMEVAL
     Accessors for the fields of 'struct-timeval'.


File: vicare-libs.info,  Node: posix time timespec,  Next: posix time tms,  Prev: posix time timeval,  Up: posix time

4.18.2 Data structure 'struct-timespec'
---------------------------------------

 -- Structure Type: struct-timespec
     Scheme level representation of 'struct timespec', *note struct
     timeval: (libc)Elapsed Time.  It has the following fields:

     'tv_sec'
          Exact integer, represents a count of seconds.

     'tv_nsec'
          Exact integer, represents a count of nanoseconds.

 -- Function: make-struct-timespec SEC USEC
     Build and return a new instance of 'struct-timespec'.

 -- Function: struct-timespec? OBJ
     Return '#t' if OBJ is an instance of 'struct-timespec'.

 -- Function: struct-timespec-tv_sec TIMESPEC
 -- Function: struct-timespec-tv_nsec TIMESPEC
     Accessors for the fields of 'struct-timespec'.


File: vicare-libs.info,  Node: posix time tms,  Next: posix time tm,  Prev: posix time timespec,  Up: posix time

4.18.3 Data structure 'struct-tms'
----------------------------------

 -- Structure Type: struct-tms
     Scheme level representation of 'struct tms', *note struct tms:
     (libc)Processor Time.  It has the following fields:

     'tms_utime'
          Exact integer.

     'tms_stime'
          Exact integer.

     'tms_cutime'
          Exact integer.

     'tms_cstime'
          Exact integer.

 -- Function: make-struct-tms UTIME STIME CUTIME CSTIME
     Build and return a new instance of 'struct-tms'.

 -- Function: struct-tms? OBJ
     Return '#t' if OBJ is an instance of 'struct-tms'.

 -- Function: struct-tms-tms_utime TMS
 -- Function: struct-tms-tms_stime TMS
 -- Function: struct-tms-tms_cutime TMS
 -- Function: struct-tms-tms_cstime TMS
     Accessors for the fields of 'struct-tms'.


File: vicare-libs.info,  Node: posix time tm,  Next: posix time itimerval,  Prev: posix time tms,  Up: posix time

4.18.4 Data structure 'struct-tm'
---------------------------------

 -- Structure Type: struct-tm
     Scheme level representation of 'struct tm', *note struct tm:
     (libc)Broken-down Time.  It has the following fields:

     'tm_sec'
          Exact integer.

     'tm_min'
          Exact integer.

     'tm_hour'
          Exact integer.

     'tm_mday'
          Exact integer.

     'tm_mon'
          Exact integer.

     'tm_year'
          Exact integer.

     'tm_wday'
          Exact integer.

     'tm_yday'
          Exact integer.

     'tm_isdst'
          Boolean.

     'tm_gmtoff'
          Exact integer.

     'tm_zone'
          Bytevector.

 -- Function: make-struct-tm TM_SEC TM_MIN TM_HOUR TM_MDAY TM_MON
          TM_YEAR TM_WDAY TM_YDAY TM_ISDST TM_GMTOFF TM_ZONE
     Build and return a new instance of 'struct-tm'.

 -- Function: struct-tm? OBJ
     Return '#t' if OBJ is an instance of 'struct-tm'.

 -- Function: struct-tm-tm_sec TM
 -- Function: struct-tm-tm_min TM
 -- Function: struct-tm-tm_hour TM
 -- Function: struct-tm-tm_mday TM
 -- Function: struct-tm-tm_mon TM
 -- Function: struct-tm-tm_year TM
 -- Function: struct-tm-tm_wday TM
 -- Function: struct-tm-tm_yday TM
 -- Function: struct-tm-tm_isdst TM
 -- Function: struct-tm-tm_gmtoff TM
 -- Function: struct-tm-tm_zone TM
     Accessors for instances of STRUCT-TM


File: vicare-libs.info,  Node: posix time itimerval,  Next: posix time itimerspec,  Prev: posix time tm,  Up: posix time

4.18.5 Data structure 'struct-itimerval'
----------------------------------------

Structure representing interval timer values (ITimerVal).

 -- Structure Type: struct-itimerval
     Scheme level representation of 'struct itimerval', *note struct
     itimerval: (libc)Setting an Alarm.  It has the following fields:

     'it_interval'
          An instance of 'struct-timeval' representing the period
          between successive timer interrupts.

     'it_value'
          An instance of 'struct-timeval' representing the time interval
          between now and the first timer interrupt.

 -- Function: make-struct-itimerval
 -- Function: make-struct-itimerval INTERVAL VALUE
     Build and return a new instance of 'struct-itimerval'.  When called
     with no arguments: two new instances of 'struct-timeval' are
     allocated and initialised to zero values, then used as field
     values.

 -- Function: struct-itimerval? OBJ
     Return true if OBJ is an instance of 'struct-itimerval'.

 -- Function: struct-itimerval-it_interval ITIMERVAL
 -- Function: struct-itimerval-it_value ITIMERVAL
     Accessors for the fields of 'struct-itimerval'.


File: vicare-libs.info,  Node: posix time itimerspec,  Next: posix time functions,  Prev: posix time itimerval,  Up: posix time

4.18.6 Data structure 'struct-itimerspec'
-----------------------------------------

Structure representing interval timer specifications (ITimerSpec).

 -- Structure Type: struct-itimerspec
     Scheme level representation of 'struct itimerspec', see the manual
     pages 'timer_create(2)' and 'timerfd_create(2)'.  It has the
     following fields:

     'it_interval'
          An instance of 'struct-timespec' representing the period
          between successive timer interrupts, in seconds and
          nanoseconds.  *note posix time timespec:: for details on
          'struct-timespec'.

     'it_value'
          An instance of 'struct-timespec' representing the time
          interval between now and the first timer interrupt, in seconds
          and nanoseconds.  *note posix time timespec:: for details on
          'struct-timespec'.

 -- Function: make-struct-itimerspec
 -- Function: make-struct-itimerspec INTERVAL VALUE
     Build and return a new instance of 'struct-itimerspec'.  When
     called with no arguments: two new instances of 'struct-timespec'
     are allocated and initialised to zero values, then used as field
     values.

 -- Function: struct-itimerspec? OBJ
     Return true if OBJ is an instance of 'struct-itimerspec'.

 -- Function: struct-itimerspec-it_interval ITIMERSPEC
 -- Function: struct-itimerspec-it_value ITIMERSPEC
     Accessors for the fields of 'struct-itimerspec'.


File: vicare-libs.info,  Node: posix time functions,  Prev: posix time itimerspec,  Up: posix time

4.18.7 Date and time functions
------------------------------

 -- Function: clock
     Interface to the C function 'clock()', *note clock: (libc)CPU Time.
     If successful return an exact integer representing the CPU time for
     the calling process expressed in clock ticks; if the clock time is
     not available return false.

 -- Function: times
     Interface to the C function 'times()', *note times: (libc)Processor
     Time.  If successful return an instance of 'struct-tms'
     representing the current processor time, else return false.

 -- Function: time
     Interface to the C function 'time()', *note time: (libc)Simple
     Calendar Time.  If successful return the calendar time as an exact
     integer, else return false.

 -- Function: gettimeofday
     Interface to the C function 'gettimeofday()', *note gettimeofday:
     (libc)High-Resolution Calendar.  Acquire the current time.  If
     successful return an instance of 'struct-timeval', else raise an
     exception.

 -- Function: localtime TIME
     Interface to the C function 'localtime()', *note localtime:
     (libc)Broken-down Time.  Given an exact integer TIME representing
     the local time as returned by the 'time' function: build and return
     an instance of 'struct-tm' representing the same time in human
     readable form; if an error occurs raise an exception.

 -- Function: gmtime TIME
     Interface to the C function 'gmtime()', *note gmtime:
     (libc)Broken-down Time.  Given an exact integer TIME representing
     the UTC time as returned by the 'time' function: build and return
     an instance of 'struct-tm' representing the same time in human
     readable form; if an error occurs raise an exception.

 -- Function: timelocal TM
     Interface to the C function 'timelocal()', *note timelocal:
     (libc)Broken-down Time.  Given a reference to a 'struct-rm', TM,
     representing a local broken time, convert it into a time value as
     returned by 'time()'.  If successful return an exact integer
     representing the time value, else raise an exception.

 -- Function: timegm TM
     Interface to the C function 'timegm()', *note timegm:
     (libc)Broken-down Time.  Given a reference to a 'struct-rm', TM,
     representing a UTC broken time, convert it into a time value as
     returned by 'time()'.  If successful return an exact integer
     representing the time value, else raise an exception.

 -- Function: strftime TEMPLATE TM
 -- Function: strftime/string TEMPLATE TM
     Interface to the C function 'strftime()', *note strftime:
     (libc)Formatting Calendar Time.  Given a bytevector TEMPLATE
     holding an ASCII coded format string and a 'struct-tm' instance TM:
     build a formatted time string; the resulting time string can be at
     most 4096 bytes wide.  If successful 'strftime' returns a
     bytevector holding the time string in ASCII coding and
     'strftime/string' returns a Scheme string, else raise an exception.

 -- Function: nanosleep SECS NSECS
     Interface to the C function 'nanosleep()', *note nanosleep:
     (libc)Sleeping.  Halt the current process for the specified amount
     of time.

     The count of seconds SECS must be an exact integer in the range [0,
     2^32); the count of nanoseconds NSECS must be an exact integer in
     the range [0, 999999999].

     If successful and the requested time is elapsed: return a pair
     whose car is false and whose cdr is false.  If successful and the
     sleeping was interrupted by an interprocess signal: return a pair
     whose car is an exact integer representing the count of remaining
     seconds and whose cdr is an exact integer representing the count of
     remaining nanoseconds.  If an error occurs an exception is raised.

 -- Function: setitimer WHICH ITIMERVAL
     Interface to the C function 'setitimer()', *note setitimer:
     (libc)Setting an Alarm.  Set the timer specified by WHICH according
     to ITIMERVAL.  If successful return unspecified values, else raise
     an exception.

     WHICH must be a fixnum representing one of the constants:
     'ITIMER_REAL', 'ITIMER_VIRTUAL', 'ITIMER_PROF'.

     ITIMERVAL must be an instance of 'struct-itimerval'.

 -- Function: getitimer WHICH
     Interface to the C function 'getitimer()', *note getitimer:
     (libc)Setting an Alarm.  Build and return a new 'struct-itimerval'
     representing the current timer.

 -- Function: alarm SECONDS
     Interface to the C function 'alarm()', *note alarm: (libc)Setting
     an Alarm.  Set the real-time timer to expire in SECONDS.  Return an
     exact integer representing how many seconds remain before the
     previous alarm would have been sent.

   The following are the real-time clock functions.  They are available
when Vicare is linked with the 'rt' library.

     *NOTE* On GNU+Linux systems the argument CLOCK-ID to the 'clock-*'
     functions can be one among:

          CLOCK_REALTIME
          CLOCK_MONOTONIC                 CLOCK_MONOTONIC_RAW
          CLOCK_PROCESS_CPUTIME_ID        CLOCK_THREAD_CPUTIME_ID

     or a value returned by 'clock-getcpuclockid'.  The code assumes
     that clock identifiers of type 'clockid_t' can be safely converted
     to C language 'long' values.

 -- Function: clock-getres CLOCK-ID TIME
     Interface to the C function 'clock-getres()', see the manual page
     'clock-getres(2)'.  Find the resolution of the clock selected by
     the fixnum CLOCK-ID and store it in TIME, which must be an instance
     of 'struct-timespec'.  If successful return TIME itself, else raise
     an exception.

 -- Function: clock-gettime CLOCK-ID TIME
     Interface to the C function 'clock-gettime()', see the manual page
     'clock-gettime(2)'.  Retrieve the time of the clock selected by the
     fixnum CLOCK-ID and store it in TIME, which must be an instance of
     'struct-timespec'.  If successful return TIME itself, else raise an
     exception.

 -- Function: clock-settime CLOCK-ID TIME
     Interface to the C function 'clock-settime()', see the manual page
     'clock-settime(2)'.  Set the time of the clock selected by the
     fixnum CLOCK-ID acquiring it from TIME, which must be an instance
     of 'struct-timespec'.  If successful return TIME itself, else raise
     an exception.

 -- Function: clock-getcpuclockid PID
     Interface to the C function 'clock_getcpuclockid()', see the manual
     page 'clock_getcpuclockid(3)'.  Obtain the identifier of a process'
     CPU-time clock; if successful return an exact integer representing
     the clock identifier, else raise an exception.  PID must be a
     fixnum representing the process identifier (PID).


File: vicare-libs.info,  Node: posix timers,  Next: posix config,  Prev: posix time,  Up: posix

4.19 POSIX per-process timers
=============================

The POSIX timer API allows the creation of per-process timers triggering
time-periodic events by specification of two time intervals:

  1. Initial expiration: how much time before the first event.

  2. Period: how much time between two time-adjacent events.  When the
     period is zero: only one event notification is delivered.

         time before the
         first event       period      period      period
        |               |           |           |           |
     ---+---------------+-----------+-----------+-----------+----
        ^               ^           ^           ^           ^
       now          1st event   2nd event   3rd event   4th event

   Each timer can be started, stopped, reconfigured and queried for how
much time until the next event.

 -- Function: timer-create CLOCK-ID
     Interface to the C function 'timer_create()', see the manual page
     'timer_create(2)'.  Create a new per-process interval timer,
     initially disarmed; if successful return an exact integer
     representing the timer identifier, else raise an exception.

     CLOCK-ID must be an exact integer representing the identifier of a
     clock to be used to measure time; it can be one of the constants:

          CLOCK_REALTIME                  CLOCK_MONOTONIC
          CLOCK_PROCESS_CPUTIME_ID        CLOCK_THREAD_CPUTIME_ID

     or the return value of 'clock-getcpuclockid'.

     The call sets up the notification as with a C language 'struct
     sigevent' having: 'sigev_notify' set to 'SIGEV_SIGNAL',
     'sigev_signo' set to 'SIGALRM', 'sigev.sival_int' set to the timer
     identifier.  This means the timer expirations are notified to the
     process by delivering 'SIGALRM' signals.

          *NOTE* On GNU+Linux systems: for details on 'struct sigevent'
          see the manual page 'sigevent(7)'.

 -- Function: timer-delete TIMER-ID
     Interface to the C function 'timer_delete()', see the manual page
     'timer_delete(2)'.  Delete the timer referenced by TIMER-ID; if
     successful return unspecified values, else raise an exception.

 -- Function: timer-settime TIMER-ID FLAGS NEW
 -- Function: timer-settime TIMER-ID FLAGS NEW OLD
     Interface to the C function 'timer_settime()', see the manual page
     'timer_settime(2)'.  Arm or disarm the timer referenced by
     TIMER-ID.  If successful return OLD or '#f' when OLD is not given;
     if an error occurs raise an exception.

     FLAGS can be either the fixnum zero or 'TIMER_ABSTIME'.  NEW must
     be a valid instance of 'struct-itimerspec', which is used to set
     the timer.  The optional OLD can be '#f' or a valid instance of
     'struct-itimerspec'; when given: it is filled with the old timer
     specification.

 -- Function: timer-gettime TIMER-ID
 -- Function: timer-gettime TIMER-ID CURR
     Interface to the C function 'timer_gettime()', see the manual page
     'timer_gettime(2)'.  Retrieve the current timer specification
     associated to the timer identifier TIMER-ID.  If successful return
     CURR or a newly built instance of 'struct-itimerspec'; if an error
     occurs: raise an exception.

     The optional CURR must be a valid instance of 'struct-itimerspec',
     when not given a new instance of this structure type is internally
     built: it is filled with the current timer specification.

 -- Function: timer-getoverrun TIMER-ID
     Interface to the C function 'timer_getoverrun()', see the manual
     page 'timer_getoverrun(2)'.  Get overrun count for the timer
     referenced by TIMER-ID; if successful return a non-negative exact
     integer representing the overrun count of the specified timer, else
     raise an exception.

   In the following example program:

  1. We use the BUB API to block all the signals, so including
     'SIGALRM'.

  2. Then we create a POSIX timer whose expirations are notified by
     delivering 'SIGALRM' signals.

  3. Then we use 'sigtimedwait' to count the expirations.

   Note very well that to recognise that a 'SIGALRM' signal is delivered
by the expiration of the timer, we have to check the
'si_value.sival_int' field of the 'struct-siginfo_t', *not* the
'si_timerid' field.

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (px.signal-bub-init)

     (define timer-id
       (px.timer-create CLOCK_REALTIME))
     (px.timer-settime timer-id 0
           (px.make-struct-itimerspec
              ;;one event every 1 seconds
              (px.make-struct-timespec 1 0)
              ;;the first event after 1 nanosecond
              (px.make-struct-timespec 0 1)))

     (unwind-protect
         (let next ((count 0))
           (if (fx= count 3)
               count
             (let-values
                 (((signo info)
                   (px.sigtimedwait SIGALRM
                      (px.make-struct-timespec 2 0))))
               (define was-sigalrm?
                 (= signo SIGALRM))
               (define right-timer?
                 (= timer-id
                    (px.struct-siginfo_t-si_value.sival_int info)))
               (next (if (and was-sigalrm? right-timer?)
                         (+ 1 count)
                       count)))))
       (px.timer-delete timer-id)
       (px.signal-bub-final))
     => 3


File: vicare-libs.info,  Node: posix config,  Next: posix resources,  Prev: posix timers,  Up: posix

4.20 System configuration
=========================

The following bindings are exported by the '(vicare posix)' library.  If
an error occurs: all the following functions raise an exception with
condition components '&errno', '&error', '&who', '&message',
'&irritants'.

 -- Function: sysconf PARAMETER
     Interface to the C function 'sysconf()', *note sysconf:
     (libc)Sysconf Definition.  Query the system for a configuration
     value selected by the exact integer PARAMETER among the '_SC_'
     constants.  If successful and a value is available: return a
     positive exact integer; if successful but no value is available
     return false; if PARAMETER is invalid raise an exception.

     *NOTE* This function assumes that all the validly returnable values
     are non-negative.  If a value is negative, the behaviour is
     unspecified.

 -- Function: pathconf PATHNAME PARAMETER
     Interface to the C function 'pathconf()', *note pathconf:
     (libc)Pathconf.  Query the system for a configuration value
     associated to the file PATHNAME selected by the exact integer
     PARAMETER among the '_PC_' constants.

     PATHNAME must be a string or bytevector; if it is a string: it is
     converted to bytevector with the function referenced by
     'string->filename-func'.

     If successful and a value is available: return a positive exact
     integer; if successful but no value is available return false; if
     PARAMETER is invalid raise an exception.

     *NOTE* This function assumes that all the validly returnable values
     are non-negative.  If a value is negative, the behaviour is
     unspecified.

 -- Function: fpathconf FD PARAMETER
     Interface to the C function 'fpathconf()', *note fpathconf:
     (libc)Pathconf.  Query the system for a configuration value
     associated to the file descriptor FD selected by the exact integer
     PARAMETER among the '_PC_' constants.

     If successful and a value is available: return a positive exact
     integer; if successful but no value is available return false; if
     PARAMETER is invalid raise an exception.

     *NOTE* This function assumes that all the validly returnable values
     are non-negative.  If a value is negative, the behaviour is
     unspecified.

 -- Function: confstr PARAMETER
 -- Function: confstr/string PARAMETER
     Interface to the C function 'confstr()', *note confstr:
     (libc)String Parameters.  Query the system for a configuration
     value selected by the exact integer PARAMETER among the '_CS_'
     constants.  If successful 'confstr' returns a bytevector
     representing the value, 'confstr/string' returns a string
     representing the value; else an exception is raised.

          #!r6rs
          (import (rnrs)
            (prefix (vicare posix) px.)
            (vicare platform constants))

          (px.confstr/string _CS_PATH)
          => "/bin:/usr/bin"


File: vicare-libs.info,  Node: posix resources,  Next: posix mq,  Prev: posix config,  Up: posix

4.21 Resources usage
====================

* Menu:

* posix resources rlimit::      Data structure 'struct-rlimit'.
* posix resources rusage::      Data structure 'struct-rusage'.
* posix resources funcs::       System resources functions.


File: vicare-libs.info,  Node: posix resources rlimit,  Next: posix resources rusage,  Up: posix resources

4.21.1 Data structure 'struct-rlimit'
-------------------------------------

 -- Struct Type: struct-rlimit
     Scheme level representation of the C language type 'struct rlimit',
     *note struct rlimit: (libc)Limits on Resources.  Hold the soft and
     hard limits of a resource.

     'rlim_cur'
          An exact integer representing the soft limit.

     'rlim_max'
          An exact integer representing the hard limit.

 -- Function: make-struct-rlimit
 -- Function: make-struct-rlimit CUR MAX
     Build and return a new instance of 'struct-rlimit'.  When no
     arguments are given: the fields are initialised with the fixnum
     zero.

 -- Function: struct-rlimit? OBJ
     Return '#t' if OBJ is an instance of 'struct-rlimit'.

 -- Function: struct-rlimit-rlim_cur RLIM
 -- Function: struct-rlimit-rlim_max RLIM
     Accessors for the fields of 'struct-rlimit'.

 -- Function: set-struct-rlimit-rlim_cur! RLIM VALUE
 -- Function: set-struct-rlimit-rlim_max! RLIM VALUE
     Mutators for the fields of 'struct-rlimit'.


File: vicare-libs.info,  Node: posix resources rusage,  Next: posix resources funcs,  Prev: posix resources rlimit,  Up: posix resources

4.21.2 Data structure 'struct-rusage'
-------------------------------------

 -- Struct Type: struct-rusage
     Scheme level representation of the C language type 'struct rusage',
     *note struct rusage: (libc)Resource Usage.  It has the following
     fields:

     'ru_utime'
          An instance of 'struct-timeval'.

     'ru_stime'
          An instance of 'struct-timeval'.

     'ru_maxrss'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_ixrss'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_idrss'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_isrss'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_minflt'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_majflt'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_nswap'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_inblock'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_oublock'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_msgsnd'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_msgrcv'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_nsignals'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_nvcsw'
          An exact integer in the range of the C language type 'long
          int'.

     'ru_nivcsw'
          An exact integer in the range of the C language type 'long
          int'.

     Notice some of the fields may be meaningless on some platforms, in
     which case they are set to '#f'.

 -- Function: make-struct-rusage
 -- Function: make-struct-rusage
     Build and return a new instance of 'struct-rusage'.  When no
     arguments are given: the fields 'ru_utime' and 'ru_stime' are set
     to instance of 'struct-timeval' with fields set to zero, all the
     other fields are set to '#f'.

 -- Function: struct-rusage? OBJ
     Return '#t' if OBJ is an instance of 'struct-rusage'.

 -- Function: struct-rusage-ru_utime RUSAGE
 -- Function: struct-rusage-ru_stime RUSAGE
 -- Function: struct-rusage-ru_maxrss RUSAGE
 -- Function: struct-rusage-ru_ixrss RUSAGE
 -- Function: struct-rusage-ru_idrss RUSAGE
 -- Function: struct-rusage-ru_isrss RUSAGE
 -- Function: struct-rusage-ru_minflt RUSAGE
 -- Function: struct-rusage-ru_majflt RUSAGE
 -- Function: struct-rusage-ru_nswap RUSAGE
 -- Function: struct-rusage-ru_inblock RUSAGE
 -- Function: struct-rusage-ru_oublock RUSAGE
 -- Function: struct-rusage-ru_msgsnd RUSAGE
 -- Function: struct-rusage-ru_msgrcv RUSAGE
 -- Function: struct-rusage-ru_nsignals RUSAGE
 -- Function: struct-rusage-ru_nvcsw RUSAGE
 -- Function: struct-rusage-ru_nivcsw RUSAGE
     Accessors for the fields of 'struct-rusage'.

 -- Function: set-struct-rusage-ru_utime! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_stime! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_maxrss! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_ixrss! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_idrss! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_isrss! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_minflt! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_majflt! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_nswap! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_inblock! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_oublock! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_msgsnd! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_msgrcv! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_nsignals! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_nvcsw! RUSAGE VALUE
 -- Function: set-struct-rusage-ru_nivcsw! RUSAGE VALUE
     Mutators for the fields of 'struct-rusage'.


File: vicare-libs.info,  Node: posix resources funcs,  Prev: posix resources rusage,  Up: posix resources

4.21.3 System resources functions
---------------------------------

 -- Identifier Syntax: RLIM_INFINITY
     The value of the corresponding POSIX constant.  If the constant is
     defined: this identifier expands to an unsigned integer, else it
     expands to '#f'.

 -- Function: getrlimit RESOURCE
 -- Function: getrlimit RESOURCE RLIMIT
     Interface to the C function 'getrlimit()', *note getrlimit:
     (libc)Limits on Resources.  Retrieve the soft and hard limits of a
     system resource; if successful return RLIMIT, else raise an
     exception.

     RESOURCE must be an exact integer representing the value of a
     'RLIMIT_' constant.

     The optional RLIMIT must be an instance of 'struct-rlimit': it is
     filled with the requested values and returned; when not given: a
     new instance is allocated, filled and returned.

          #!r6rs
          (import (vicare)
            (prefix (vicare posix) px.)
            (vicare platform constants))

          (px.getrlimit RLIMIT_STACK)
          => #["struct-rlimit" rlim_cur=8388608 rlim_max=4294967295]

 -- Function: setrlimit RESOURCE RLIMIT
     Interface to the C function 'setrlimit()', *note setrlimit:
     (libc)Limits on Resources.  Set the soft and hard limits of a
     system resource; if successful return unspecified values, else
     raise an exception.

     RESOURCE must be an exact integer representing the value of a
     'RLIMIT_' constant.  RLIMIT must be an instance of 'struct-rlimit'
     filled with the selected values.

 -- Function: getrusage PROCESSES
 -- Function: getrusage PROCESSES RUSAGE
     Interface to the C function 'getrusage()', *note getrusage:
     (libc)Resource Usage.  Reports resource usage totals for processes
     specified by PROCESSES; if successful return RUSAGE, else raise an
     exception.

     PROCESSES must be an exact integer in the range of the C language
     type 'int'; it should be one of the 'RUSAGE_' platform constants.

     The optional RUSAGE must be an instance of 'struct-rusage' and it
     is filled with the usage values; when not given: a new instance of
     'struct-rusage' is internally allocated, filled and returned.


File: vicare-libs.info,  Node: posix mq,  Next: posix shm,  Prev: posix resources,  Up: posix

4.22 Message queues
===================

POSIX message queues allow processes to exchange messages composed of
arrays of bytes.

     *NOTE* On GNU+Linux systems, for an introduction to the API we must
     refer to the manual page 'mq_overview(7)'.

* Menu:

* posix mq attr::               Structure type 'struct-mq-attr'.
* posix mq api::                Message queues API.
* posix mq examples::           Simple examples of message queues usage.


File: vicare-libs.info,  Node: posix mq attr,  Next: posix mq api,  Up: posix mq

4.22.1 Structure type 'struct-mq-attr'
--------------------------------------

The following bindings are exported by the '(vicare posix)' library.

 -- Struct Type: struct-mq-attr
     Data structure type used to represent at the Scheme level 'struct
     mq_attr' values, see the manual page 'mq_getattr(3)'.  It has the
     following fields:

     'mq_flags'
          The fixnum zero or the constant 'O_NONBLOCK'.

     'mq_maxmsg'
          Maximum number of messages on the queue.

     'mq_msgsize'
          Maximum message size in bytes.

     'mq_curmsgs'
          Number of messages currently on the queue.

 -- Function: make-struct-mq-attr FLAGS MAXMSG MSGSIZE CURMSGS
     Build and return a new instance of 'struct-mq-attr'.

 -- Function: struct-mq-attr? OBJ
     Return '#t' if OBJ is an instance of 'struct-mq-attr' and its field
     values are valid, return '#f' otherwise.

 -- Function: struct-mq-attr-mq_flags ATTR
 -- Function: struct-mq-attr-mq_maxmsg ATTR
 -- Function: struct-mq-attr-mq_msgsize ATTR
 -- Function: struct-mq-attr-mq_curmsgs ATTR
     Accessors for the fields of 'struct-mq-attr'.

 -- Function: set-struct-mq-attr-mq_flags! ATTR VALUE
 -- Function: set-struct-mq-attr-mq_maxmsg! ATTR VALUE
 -- Function: set-struct-mq-attr-mq_msgsize! ATTR VALUE
 -- Function: set-struct-mq-attr-mq_curmsgs! ATTR VALUE
     Mutators for the fields of 'struct-mq-attr'.


File: vicare-libs.info,  Node: posix mq api,  Next: posix mq examples,  Prev: posix mq attr,  Up: posix mq

4.22.2 Message queues API.
--------------------------

The following bindings are exported by the '(vicare posix)' library.  On
GNU+Linux systems, for an introduction to the API we must refer to the
manual page 'mq_overview(7)' and for the full documentation of each
function we must refer to the manual pages.  Notice that 'mq_notify(3)'
at present is not interfaced.

     *NOTE* The code implementing the interface to POSIX message queues
     assumes that the descriptor 'mqd_t' is a fixnum.  On GNU+Linux
     systems this value is known to be a file descriptor.

 -- Function: mq-open NAME OFLAG MODE
 -- Function: mq-open NAME OFLAG MODE ATTR
     Interface to the C function 'mq_open()', see the manual page
     'mq_open(3)'.  Create a new message queue or open an existing one.
     If successful return a message queue descriptor, else raise an
     exception.

     NAME must be a Scheme string or bytevector holding a pathname in
     ASCII encoding.

     OFLAG must be a fixnum representing the inclusive OR composition of
     some of the following flags:

          O_RDONLY    O_WRONLY  O_RDWR
          O_NONBLOCK  O_CREAT   O_EXCL

     MODE must be a fixnum representing access permissions for the
     message queue pathname; it should be an inclusive OR composition of
     some of the flags:

          S_IRUSR   S_IWUSR   S_IXUSR
          S_IRGRP   S_IWGRP   S_IXGRP
          S_IROTH   S_IWOTH   S_IXOTH

     The optional ATTR must be false or an instance of 'struct-mq-attr';
     when false or not given: the queue is created with
     platform-dependent default attributes.  The fields 'mq_flags' and
     'mq_curmsgs' are ignored in call to this function.

 -- Function: mq-close MQD
     Interface to the C function 'mq_close()', see the manual page
     'mq_close(3)'.  Close the message queue referenced by the
     descriptor MQD, which must be a descriptor returned by a previous
     call to 'mq-open'; notice that the message queue will still exist
     until it is deleted with 'mq_unlink()'.  If successful return
     unspecified values, else raise an exception.

 -- Function: mq-unlink NAME
     Interface to the C function 'mq_unlink()', see the manual page
     'mq_unlink(3)'.  Remove the message queue whose name is NAME, which
     must be a Scheme string or bytevector representing a pathname in
     ASCII encoding; the message queue name is removed immediately,
     while the message queue is removed when all the processes
     referencing it close their descriptors.  If successful return
     unspecified values, else raise an exception.

 -- Function: mq-send MQD MESSAGE PRIORITY
     Interface to the C function 'mq_send()', see the manual page
     'mq_send(3)'.  Add a message to the queue referenced by the
     descriptor MQD, which must be a descriptor returned by a previous
     call to 'mq-open'.  If successful return unspecified values, else
     raise an exception.

     MESSAGE must be a Scheme bytevector representing the message data.
     PRIORITY must be an exact integer, in the range of the C language
     type 'unsigned int', representing the priority of the message.

 -- Function: mq-timedsend MQD MESSAGE PRIORITY EPOCH-TIMEOUT
     Interface to the C function 'mq_timedsend()', see the manual page
     'mq_timedsend(3)'.  Add a message to the queue referenced by the
     descriptor MQD, which must be a descriptor returned by a previous
     call to 'mq-open'.  If successful return unspecified values, else
     raise an exception.

     MESSAGE must be a Scheme bytevector representing the message data.

     PRIORITY must be an exact integer, in the range of the C language
     type 'unsigned int', representing the priority of the message.

     EPOCH-TIMEOUT must be an instance of 'struct-timespec' representing
     an absolute time since the Epoch: if the queue is in blocking mode,
     a call to this function will block until the timeout expires
     waiting to deliver the message.  *note struct-timespec: posix time
     timespec.

 -- Function: mq-receive MQD MESSAGE
     Interface to the C function 'mq_receive()', see the manual page
     'mq_receive(3)'.  Remove the oldest message with the highest
     priority from the message queue referenced by MQD, which must be a
     descriptor returned by a previous call to 'mq-open'.  If successful
     return two values: an exact integer representing the number of
     bytes in the message, a non-negative exact integer representing the
     priority of the message; else raise an exception.

     MESSAGE must be a Scheme bytevector providing the buffer in which
     the function will write the received message; its length must be
     greater than the maximum message length specified in the queue
     attributes.

 -- Function: mq-timedreceive MQD MESSAGE EPOCH-TIMEOUT
     Interface to the C function 'mq_timedreceive()', see the manual
     page 'mq_timedreceive(3)'.  Remove the oldest message with the
     highest priority from the message queue referenced by MQD, which
     must be a descriptor returned by a previous call to 'mq-open'.  If
     successful return two values: an exact integer representing the
     number of bytes in the message, a non-negative exact integer
     representing the priority of the message; else raise an exception.

     MESSAGE must be a Scheme bytevector providing the buffer in which
     the function will write the received message; its length must be
     greater than the maximum message length specified in the queue
     attributes.

     EPOCH-TIMEOUT must be an instance of 'struct-timespec' representing
     an absolute time since the Epoch: if the queue is in blocking mode,
     a call to this function will block until the timeout expires
     waiting to receive the message.  *note struct-timespec: posix time
     timespec.

 -- Function: mq-setattr MQD NEW-ATTR
 -- Function: mq-setattr MQD NEW-ATTR OLD-ATTR
     Interface to the C function 'mq_setattr()', see the manual page
     'mq_setattr(3)'.  Modify the attributes of the message queue
     referenced by MQD, which must be a descriptor returned by a
     previous call to 'mq-open'.  If successful return an instance of
     'struct-mq-attr' representing the old attributes, else raise an
     exception.

     The new values are read from NEW-ATTR, which must be an instance of
     'struct-mq-attr'.  On GNU+Linux: the only attribute that can be
     modified is 'mq_flags', all the other values are ignored (last
     verified on Jul 7, 2012).

     The old values are stored in OLD-ATTR, which must be an instance of
     'struct-mq-attr'; when OLD-ATTR is not given: a new instance of
     'struct-mq-attr' is internally created.  OLD-ATTR or the new
     instance are the return value of this function.

 -- Function: mq-getattr MQD
 -- Function: mq-getattr MQD ATTR
     Interface to the C function 'mq_getattr()', see the manual page
     'mq_getattr(3)'.  Retrieve the attributes of the message queue
     referenced by MQD, which must be a descriptor returned by a
     previous call to 'mq-open'.  If successful return an instance of
     'struct-mq-attr' representing the old attributes, else raise an
     exception.

     The values are stored in ATTR, which must be an instance of
     'struct-mq-attr'; when ATTR is not given: a new instance of
     'struct-mq-attr' is internally created.  ATTR or the new instance
     are the return value of this function.


File: vicare-libs.info,  Node: posix mq examples,  Prev: posix mq api,  Up: posix mq

4.22.3 Simple examples of message queues usage
----------------------------------------------

The following example shows how to create and close a message queue and
how to send and receive a message:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (define name "/vicare-test")

     (define (parent child-pid)
       ;; Create a message queue and block until a message
       ;; is received from the child.
       ;;
       (let ((mqd (px.mq-open name
                              (bitwise-ior O_CREAT O_EXCL O_RDWR)
                              (bitwise-ior S_IRUSR S_IWUSR)
                              (px.make-struct-mq-attr 0 3 16 0)))
             (buf (make-bytevector 16)))
         (unwind-protect
             (let-values (((len priority)
                           (px.mq-receive mqd buf)))
               (px.waitpid child-pid 0)
               (list (subbytevector-u8 buf 0 len)
                     priority))
           (px.mq-close mqd)
           (px.mq-unlink name))))

     (define (child)
       ;; Wait for the parent to create the queue, then
       ;; send a message and exit.
       ;;
       (px.nanosleep 0 900000)
       (let ((mqd (px.mq-open name O_RDWR
                              (bitwise-ior S_IRUSR S_IWUSR)
                              (px.make-struct-mq-attr 0 3 16 0))))
         (unwind-protect
             (px.mq-send mqd '#ve(ascii "ciao") 1)
           (px.mq-close mqd)))
       (exit 0))

     (px.fork parent child)

   The following example shows how to create and close a message queue
and how to send and receive a message with timeout:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (define name "/vicare-test")

     (define timeout
       (let ((T (px.clock-gettime CLOCK_REALTIME
                   (px.make-struct-timespec 0 0))))
         (px.set-struct-timespec-tv_sec! T
            (+ 5 (px.struct-timespec-tv_sec T)))
         T))

     (define (parent child-pid)
       ;; Create a message queue and block with timeout
       ;; until a message is received from the child.
       ;;
       (let ((mqd (px.mq-open name
                              (bitwise-ior O_CREAT O_EXCL O_RDWR)
                              (bitwise-ior S_IRUSR S_IWUSR)
                              (px.make-struct-mq-attr 0 3 16 0)))
             (buf (make-bytevector 16)))
         (unwind-protect
             (let-values (((len priority)
                           (px.mq-timedreceive mqd buf timeout)))
               (px.waitpid child-pid 0)
               (list (subbytevector-u8 buf 0 len)
                     priority))
           (px.mq-close mqd)
           (px.mq-unlink name))))

     (define (child)
       ;; Wait for the parent to create the queue, then
       ;; send a message with timeout and exit.
       ;;
       (px.nanosleep 0 900000)
       (let ((mqd (px.mq-open name
                              O_RDWR
                              (bitwise-ior S_IRUSR S_IWUSR)
                              (px.make-struct-mq-attr 0 3 16 0))))
         (unwind-protect
             (px.mq-timedsend mqd '#ve(ascii "ciao") 1 timeout)
           (px.mq-close mqd)))
       (exit 0))

     (px.fork parent child)


File: vicare-libs.info,  Node: posix shm,  Next: posix sem,  Prev: posix mq,  Up: posix

4.23 Shared memory
==================

The POSIX shared memory API allow processes to communicate informations
by sharing a region of memory.

     *NOTE* On GNU+Linux systems, for an introduction to the API we must
     refer to the manual page 'shm_overview(7)'.

 -- Function: shm-open NAME OFLAG MODE
     Interface to the C function 'shm_open()', see the manual page
     'shm_open(3)'.  Open, and optionally create, a shared memory object
     and return a file descriptor referencing it.  If successful return
     a fixnum representing the file descriptor, else raise an exception.

     NAME must be the pathname representing the shared memory object.
     OFLAG must be the bitwise inclusive OR combination of some of the
     following values:

          O_RDONLY                O_RDWR
          O_CREAT                 O_EXCL
          O_TRUNC

     MODE must be the bitwise inclusive OR combination of some of the
     following values:

          S_IRUSR   S_IWUSR   S_IXUSR
          S_IRGRP   S_IWGRP   S_IXGRP
          S_IROTH   S_IWOTH   S_IXOTH

 -- Function: shm-unlink NAME
     Interface to the C function 'shm_unlink()', see the manual page
     'shm_unlink(3)'.  Remove the shared memory object selected by the
     pathname NAME.  If successful return unspecified values, else raise
     an exception.

   The following example shows how two processes can exchange a signed
integer; notice how the only information shared at the beginning is the
pathname of the shared memory object and the dimension of the mapped
memory.  Also notice that the correct way of synchronising two processes
for shared memory access is with POSIX semaphores, *note posix sem:: for
details.

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (only (vicare language-extensions syntaxes)
             unwind-protect
             callet)

     (define shm.pathname
       "/vicare-posix-shm.test")
     (define shm.dim
       (px.sysconf _SC_PAGESIZE))

     (define (parent child-pid)
       (let ((shm.fd (callet px.shm-open shm.pathname
                             (oflags (fxior O_CREAT O_RDWR))
                             (mode   (fxior S_IRUSR S_IWUSR)))))
         (px.ftruncate shm.fd shm.dim)
         (unwind-protect
             (unwind-protect
                 (let ((shm.base (callet px.mmap
                                   (address #f)
                                   (size    shm.dim)
                                   (prot    (fxior PROT_READ
                                                   PROT_WRITE))
                                   (flags   MAP_SHARED)
                                   (fd      shm.fd)
                                   (offset  0))))
                   (unwind-protect
                       (begin
                         (px.waitpid child-pid 0)
                         (pointer-ref-c-signed-int shm.base 0))
                     (px.munmap shm.base shm.dim)))
               (px.close shm.fd))
           (px.shm-unlink shm.pathname))))

     (define (child)
       ;; Give the parent some time to create and open the
       ;; shared memory object.
       (px.nanosleep 1 0)
       (let ((shm.fd (callet px.shm-open shm.pathname
                             (oflags (fxior O_CREAT O_RDWR))
                             (mode   (fxior S_IRUSR S_IWUSR)))))
         (unwind-protect
             (let ((shm.base (callet px.mmap
                               (address #f)
                               (size    shm.dim)
                               (prot    (fxior PROT_READ
                                               PROT_WRITE))
                               (flags   MAP_SHARED)
                               (fd      shm.fd)
                               (offset  0))))
               (unwind-protect
                   (pointer-set-c-signed-int! shm.base 0 123)
                 (px.munmap shm.base shm.dim)))
           (px.close shm.fd)))
       (exit 0))

     (px.fork parent child)
     => 123


File: vicare-libs.info,  Node: posix sem,  Next: posix misc,  Prev: posix shm,  Up: posix

4.24 POSIX semaphores
=====================

The POSIX semaphores API allow processes to synchronise their actions.

     *NOTE* On GNU+Linux systems, for an introduction to the API we must
     refer to the manual page 'sem_overview(7)'.

* Menu:

* posix sem api::               Semaphores interface.
* posix sem examples::          Usage examples of semaphores.


File: vicare-libs.info,  Node: posix sem api,  Next: posix sem examples,  Up: posix sem

4.24.1 Semaphores interface
---------------------------

 -- Function: sem-open NAME OFLAG MODE
 -- Function: sem-open NAME OFLAG MODE VALUE
     Interface to the C function 'sem_open()', see the manual page
     'sem_open(3)'.  Initialise and open a named semaphore using the
     pathname NAME.  If successful return a pointer object referencing
     the semaphore, else raise an exception.

     OFLAG must be a fixnum representing a bitwise inclusive OR
     combination of some of the following values: 'O_CREAT', 'O_EXCL',
     'O_RDWR'.

     MODE must be a fixnum representing a bitwise inclusive OR
     combination of some of the following values:

          S_IRUSR   S_IWUSR   S_IXUSR
          S_IRGRP   S_IWGRP   S_IXGRP
          S_IROTH   S_IWOTH   S_IXOTH

     The optional VALUE must be a exact integer in the range of the C
     language type 'unsigned int'; when not given it defaults to zero.

     Named semaphores must be closed with 'sem-close' and removed with
     'sem-unlink'.

 -- Function: sem-close SEM
     Interface to the C function 'sem_close()', see the manual page
     'sem_close(3)'.  Close the named semaphore referenced by SEM, which
     must be a pointer object; note that the semaphore will continue to
     exist until 'sem-unlink' is called.  If successful return
     unspecified values, else raise an exception.

 -- Function: sem-unlink NAME
     Interface to the C function 'sem_unlink()', see the manual page
     'sem_unlink(3)'.  Remove the named semaphore referenced by the
     pathname NAME; note that the semaphore name is removed immediately,
     but the semaphore itself will continue to exist until all the
     processes referencing it will call 'sem-close'.  If successful
     return unspecified values, else raise an exception.

 -- Function: sizeof-sem_t
     Return an exact integer representing the value of the C language
     expression 'sizeof(sem_t)'.  This value is needed to allocate
     enough memory for 'sem-init' to initialise a semaphore structure.

 -- Function: sem-init SEM PSHARED
 -- Function: sem-init SEM PSHARED VALUE
     Interface to the C function 'sem_init()', see the manual page
     'sem_init(3)'.  Initialise an unnamed semaphore; if successful
     return SEM itself, else raise an exception.

     SEM must be a pointer object referencing a memory region big enough
     to hold a C language 'sem_t' data structure; such memory region
     must be allocated in such a way that it can be shared among the
     entities interested in accessing the semaphore.

     PSHARED is interpreted as a boolean value: when false, the
     semaphore is meant to be shared among multiple threads in this
     process; when true, the semaphore is meant to be shared among
     multiple processes resulting from forking the current process.

     The optional VALUE must be an exact integer in the range of the C
     language type 'unsigned int': it represents the initial value of
     the semaphore; when not given: it defaults to zero.

     Unnamed semaphores must be finalised with 'sem-destroy'.

 -- Function: sem-destroy SEM
     Interface to the C function 'sem_destroy()', see the manual page
     'sem_destroy(3)'.  Finalise the unnamed semaphore referenced by
     SEM, which must be a pointer object; if successful return
     unspecified values, else raise an exception.

 -- Function: sem-post SEM
     Interface to the C function 'sem_post()', see the manual page
     'sem_post(3)'.  Increment (unlock) the unnamed semaphore referenced
     by SEM, which must be a pointer object; if successful return
     unspecified values, else raise an exception.

 -- Function: sem-wait SEM
     Interface to the C function 'sem_wait()', see the manual page
     'sem_wait(3)'.  Decrement (lock) the unnamed semaphore referenced
     by SEM, which must be a pointer object, until the semaphore is
     unlocked; if successful return unspecified values, else raise an
     exception.

 -- Function: sem-trywait SEM
     Interface to the C function 'sem_trywait()', see the manual page
     'sem_trywait(3)'.  Decrement (lock) the unnamed semaphore
     referenced by SEM, which must be a pointer object; if successful in
     locking return the boolean '#t', if the semaphore is already locked
     return the boolean '#f', else raise an exception.

 -- Function: sem-timedwait SEM ABS-TIMEOUT
     Interface to the C function 'sem_timedwait()', see the manual page
     'sem_timedwait(3)'.  Attempt to decrement (lock) the unnamed
     semaphore referenced by SEM, which must be a pointer object, with a
     timeout.  If successful in locking return the boolean '#t'; if the
     semaphore is already locked and it is not unlocked before the
     timeout expiration: return the boolean '#f'; else raise an
     exception.

     ABS-TIMEOUT must be an instance of 'struct-timespec' representing
     the absolute timeout since the Epoch.  *note struct-timespec: posix
     time timespec.

 -- Function: sem-getvalue SEM
     Interface to the C function 'sem_getvalue()', see the manual page
     'sem_getvalue(3)'.  Retrieve the current value of the semaphore
     referenced by SEM, which must be a pointer object; if successful
     return an exact integer representing the value, else raise an
     exception.


File: vicare-libs.info,  Node: posix sem examples,  Prev: posix sem api,  Up: posix sem

4.24.2 Usage examples of semaphores
-----------------------------------

The following example shows how two processes can synchronise themselves
to exchange a signed integer using a POSIX shared memory object and an
unnamed POSIX semaphore allocated in such an object; the parent process
sets up the shared memory and initialises the semaphore, then it waits
for the semaphore and reads the integer; the child process writes an
integer in the shared memory, then it posts the semaphore.

   Notice that the informations the two processes share are:

  1. The pathname of the shared memory object.

  2. The dimension of the allocated shared memory.

  3. The fact that the semaphore is allocated at the beginning of the
     shared memory.

  4. The fact that the signed integer exchange area is right after the
     semaphore structure in the shared memory.

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (only (vicare language-extensions syntaxes)
             callet))

     (define shm.pathname
       "/vicare.test")
     (define shm.dim
       (px.sysconf _SC_PAGESIZE))

     (define (parent child-pid)
       (let ((shm.fd (callet px.shm-open shm.pathname
                       (oflags   (fxior O_CREAT O_EXCL O_RDWR))
                       (mode     (fxior S_IRUSR S_IWUSR)))))
         (px.ftruncate shm.fd shm.dim)
         (unwind-protect
             (let ((shm.base (callet px.mmap
                               (address #f)
                               (size    shm.dim)
                               (prot    (fxior PROT_READ
                                               PROT_WRITE))
                               (flags   MAP_SHARED)
                               (fd      shm.fd)
                               (offset  0))))
               (unwind-protect
                   (let* ((sem_t     shm.base)
                          (shm.start (pointer-add shm.base
                                       (px.sizeof-sem_t)))
                          (sem_t     (callet px.sem-init sem_t
                                       (pshared? #t)
                                       (value    0))))
                     (define timeout
                       (let ((T (px.clock-gettime CLOCK_REALTIME
                                  (px.make-struct-timespec 0 0))))
                         (px.set-struct-timespec-tv_sec! T
                           (+ 2 (px.struct-timespec-tv_sec T)))
                         T))
                     (unwind-protect
                         (begin
                           (px.sem-timedwait sem_t timeout)
                           (pointer-ref-c-signed-int shm.start 0))
                       (px.sem-destroy sem_t)))
                 (px.munmap shm.base shm.dim)))
           (px.close shm.fd)
           (px.shm-unlink shm.pathname))))

     (define (child)
       ;; Give the parent some time to open the
       ;; shared memory object.
       (px.nanosleep 1 0)
       (let ((shm.fd (callet px.shm-open shm.pathname
                       (oflags   (fxior O_CREAT O_RDWR))
                       (mode     (fxior S_IRUSR S_IWUSR)))))
         (unwind-protect
             (let ((shm.base (callet px.mmap
                               (address #f)
                               (size    shm.dim)
                               (prot    (fxior PROT_READ
                                               PROT_WRITE))
                               (flags   MAP_SHARED)
                               (fd      shm.fd)
                               (offset  0))))
               (unwind-protect
                   (let* ((sem_t     shm.base)
                          (shm.start (pointer-add shm.base
                                       (px.sizeof-sem_t))))
                     (pointer-set-c-signed-int! shm.start 0 123)
                     (px.sem-post sem_t))
                 (px.munmap shm.base shm.dim)))
           (px.close shm.fd)))
       (exit 0))

     (px.fork parent child)  => 123

   The following example shows how two processes can synchronise
themselves to exchange a signed integer using a POSIX shared memory
object and a named POSIX semaphore; the parent process sets up the
shared memory and the semaphore, then it waits for the semaphore and
reads the integer; the child process writes an integer in the shared
memory, then it posts the semaphore.

   Notice that the informations the two processes share are:

  1. The pathname of the shared memory object.

  2. The pathname of the semaphore object.

  3. The dimension of the allocated shared memory.

  4. The fact that the signed integer exchange area is at the beginning
     of the shared memory.

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (only (vicare language-extensions syntaxes)
             unwind-protect
             callet))

     (define sem.pathname
       "/vicare-posix-sem.test")
     (define shm.pathname
       "/vicare-posix-shm.test")
     (define shm.dim
       (px.sysconf _SC_PAGESIZE))

     (define (parent child-pid)
       (let ((sem_t  (callet px.sem-open sem.pathname
                       (oflags (fxior O_CREAT O_EXCL O_RDWR))
                       (mode   (fxior S_IRUSR S_IWUSR))))
             (shm.fd (callet px.shm-open shm.pathname
                       (oflags   (fxior O_CREAT O_EXCL O_RDWR))
                       (mode     (fxior S_IRUSR S_IWUSR)))))
         (px.ftruncate shm.fd shm.dim)
         (unwind-protect
             (let ((shm.base (callet px.mmap
                               (address #f)
                               (size    shm.dim)
                               (prot    (fxior PROT_READ
                                               PROT_WRITE))
                               (flags   MAP_SHARED)
                               (fd      shm.fd)
                               (offset  0))))
               (unwind-protect
                   (begin
                     (px.sem-wait sem_t)
                     (pointer-ref-c-signed-int shm.base 0))
                 (px.munmap shm.base shm.dim)))
           (px.close shm.fd)
           (px.shm-unlink shm.pathname)
           (px.sem-close sem_t)
           (px.sem-unlink sem.pathname))))

     (define (child)
       ;; Give the parent some time to open the
       ;; shared memory object.
       (px.nanosleep 1 0)
       (let ((sem_t  (callet px.sem-open sem.pathname
                       (oflags (fxior O_CREAT O_RDWR))
                       (mode   (fxior S_IRUSR S_IWUSR))))
             (shm.fd (callet px.shm-open shm.pathname
                       (oflags (fxior O_CREAT O_RDWR))
                       (mode   (fxior S_IRUSR S_IWUSR)))))
         (unwind-protect
             (let ((shm.base (callet px.mmap
                               (address #f)
                               (size    shm.dim)
                               (prot    (fxior PROT_READ
                                               PROT_WRITE))
                               (flags   MAP_SHARED)
                               (fd      shm.fd)
                               (offset  0))))
               (unwind-protect
                   (begin
                     (pointer-set-c-signed-int! shm.base 0 123)
                     (px.sem-post sem_t))
                 (px.munmap shm.base shm.dim)))
           (px.close shm.fd)
           (px.sem-close sem_t)))
       (exit 0))

     (px.fork parent child) => 123


File: vicare-libs.info,  Node: posix misc,  Next: posix args,  Prev: posix sem,  Up: posix

4.25 Miscellaneous functions
============================

 -- Function: strerror ERRNO
     Return a string describing the 'errno' code ERRNO.  Makes use of
     the system function 'strerror()'.  If ERRNO is not a valid 'errno'
     value: return a string telling it.  As special cases ERRNO can be
     also '#t', meaning "unknown error", and '#f', meaning "no error".

     *note Error Messages: (libc)Error Messages.

 -- Function: file-descriptor? OBJ
     Return true if OBJ is a non-negative fixnum less than the value of
     'FD_SETSIZE'.

 -- Function: network-port-number? OBJ
     Return true if OBJ is a fixnum integer in the range of network
     ports [1, 65535].


File: vicare-libs.info,  Node: posix args,  Next: posix not,  Prev: posix misc,  Up: posix

4.26 Arguments validation clauses
=================================

The clauses are meant to be used with the features of the library
'(vicare arguments validation)'; notice that the name of the clause is
*not* the name of the exported binding.

 -- Validation Clause: file-descriptor OBJ
 -- Validation Clause: file-descriptor/false OBJ
     Succeed if OBJ satisfies the 'file-descriptor?' predicate or, for
     the second clause, it is '#f'.

 -- Validation Clause: network-port-number OBJ
 -- Validation Clause: network-port-number/false OBJ
     Succeed if OBJ satisfies the 'network-port-number?' predicate or,
     for the second clause, it is '#f'.


File: vicare-libs.info,  Node: posix not,  Next: posix sel,  Prev: posix args,  Up: posix

4.27 POSIX functions not interfaced
===================================

Not all the functions defined by POSIX are exposed by '(vicare posix)';
this section lists some of them along with reasons for not interface
them.  This is not the last word: if good reasons arise to interface
some of the functions, they will.

'popen()'
'pclose()'
     There seems to be no real advantage (in a Scheme API) to use these
     rather than explicitly call 'pipe', 'fork' and 'exec'.  *note pipe:
     posix fd. for details.


File: vicare-libs.info,  Node: posix sel,  Next: posix pid-files,  Prev: posix not,  Up: posix

4.28 Simple event loop (SEL)
============================

The library '(vicare posix simple-event-loop)' implements an event loop
capable of serving: file descriptors, interprocess signals, batch task
execution.  The library is available if Vicare is configured with the
POSIX API enabled.  The SEL makes use of the BUB API for interprocess
signals.

   When importing this library it is suggested to prefix the bindings as
follows:

     (import (vicare)
       (prefix (vicare posix) px.)
       (prefix (vicare posix simple-event-loop) sel.))

in practice the SEL can be used only along with '(vicare posix)'.

   Exceptions raised by registered event handlers are catched with
'guard' and silently discarded; it is our responsibility to handle
errors appropriately in the handlers.

 -- Parameter: log-procedure
     When set to '#t' causes debugging messages to be displayed on the
     current error port.  When set to a procedure: such procedure is
     called with a single argument whenever a log message must be
     reported; such single argument is a string representing a log line
     (*without* terminating newline).  When set to '#f' nothing happens.

 -- Function: initialise
 -- Function: finalise
     Initialise or finalise the infrastructure of SEL.  Prior to
     entering the loop we must call 'initialise'.

     'initialise' calls 'signal-bub-init' and 'finalise' calls
     'signal-bub-final' from '(vicare posix)'.

 -- Function: do-one-event
     Serve all the events associated to pending received interprocess
     signals, then serve a single event from file descriptors or
     fragmented tasks.  Return '#t' if one event from file descriptors
     or fragmented tasks was served, return '#f' otherwise.

 -- Function: enter
 -- Function: leave-asap
     Enter or leave the event loop.  'enter' starts servicing events
     from the registered event sources, indefinitely until 'leave-asap'
     is called.

 -- Function: busy?
     Return a boolean, '#t' if at least one event source is registered.
     In this context: interprocess signals do *not* count as event
     source.

Interprocess signals
....................

 -- Function: receive-signal SIGNUM HANDLER
     Register the thunk HANDLER to be called whenever the signal SIGNUM
     is received.  Any number of handlers can be associated to a single
     signal.  Every handler is called *once* and removed from the loop.

 -- Function: serve-interprocess-signals
     Serve all the pending events for received interprocess signals.
     Return unspecified values.

File descriptor events
......................

SEL can interface with both raw file descriptors and Scheme ports
wrapping a file descriptor; other Scheme port types are not supported.

 -- Function: readable PORT/FD HANDLER
 -- Function: readable PORT/FD HANDLER EXPIRATION-TIME
          EXPIRATION-HANDLER
 -- Function: writable PORT/FD HANDLER
 -- Function: writable PORT/FD HANDLER EXPIRATION-TIME
          EXPIRATION-HANDLER
 -- Function: exception PORT/FD HANDLER
 -- Function: exception PORT/FD HANDLER EXPIRATION-TIME
          EXPIRATION-HANDLER
     Register the thunk HANDLER to be called whenever the port or file
     descriptor PORT/FD becomes readable, writable or receives an
     exceptional notification.  Every handler is called *once* and
     removed from the loop.

     When EXPIRATION-TIME and EXPIRATION-HANDLER are used:
     EXPIRATION-TIME must be a 'time' struct as defined by the library
     '(vicare)'; EXPIRATION-HANDLER must be a thunk.  Whenever the port
     or file descriptor is queried for events: if the event did not
     happen and the current time is past the expiration time, the
     expiration handler is invoked.

 -- Function: forget-fd PORT/FD
     Remove all the registered handlers associated to the port or file
     descriptor PORT/FD.

 -- Function: do-one-fd-event
     Serve one file descriptor event, if any.  Return a boolean, '#t' if
     an event was served.

Fragmented tasks
................

A "fragmented task" is a thunk performing a portion of a job.  If the
thunk returns '#f': the job is finished.  If the thunk returns a
procedure: a portion of job was finished and the returned procedure is a
thunk to call to execute the next portion.

 -- Function: task-fragment THUNK
     Register the THUNK as fragment of a task.  When THUNK is evaluated:
     if its return value is a procedure, that procedure is automatically
     registered as task fragment.

 -- Function: do-one-task-event
     Evaluate one task event, if any.  Return a boolean, '#t' if a task
     was run.


File: vicare-libs.info,  Node: posix pid-files,  Next: posix lock-pid-files,  Prev: posix sel,  Up: posix

4.29 Creating PID files
=======================

The library '(vicare posix pid-files)' implements facilities for the
creation of PID files, built on top of the library '(vicare posix)'.  It
is suggested to import this library prefixing the bindings as follows:

     (import (prefix (vicare posix pid-files)
                     pidfile.))

   Notice that this library only creates PID files, not lock files; when
lock files are needed we should use the library '(vicare posix
lock-pid-files)', *note posix lock-pid-files:: for details.

* Menu:

* posix pid-files intro::       Introduction to PID files.
* posix pid-files config::      Library configuration parameters.
* posix pid-files api::         PID files programming API.
* posix pid-files conditions::  Condition object types.


File: vicare-libs.info,  Node: posix pid-files intro,  Next: posix pid-files config,  Up: posix pid-files

4.29.1 Introduction to PID files
--------------------------------

A PID file is a textual file in ASCII encoding created at process start
time and deleted at process exit time; it contains a string representing
the PID number of the current process followed by a newline character.

   The PID file is especially useful whenever a server is executed as
daemon: it allows for quick retrieval of the PID number, which can be
used to send interprocess signals to the daemon; for example: to shut it
down, to restart it, to update its configuration.

   When a PID file is used: the creator process should refuse to start
if the PID file already exists, because it may mean that a program
instance is already in execution.

   The PID file must be created after a server daemonisation process has
completed: this way we correctly store the PID of the daemon process,
rather than the PID of the starting process.

   The PID file must be created after a process has changed its user and
group IDs to drop special privileges: this way the file is created with
appropriate owner and group.

   All the operations performed by this library are logged.  Logging
operations related to the PID file rely on the function referenced by an
internal parameter; we just need to configure this parameter with an
appropriate function.


File: vicare-libs.info,  Node: posix pid-files config,  Next: posix pid-files api,  Prev: posix pid-files intro,  Up: posix pid-files

4.29.2 Library configuration parameters
---------------------------------------

The following bindings are exported by the library '(vicare posix
pid-files)'.

 -- Parameter: pid-pathname
     Hold '#f' or a string representing the PID file *absolute*
     pathname; beware of setting a relative pathname and then changing
     the current process directory.  When set to '#f': no PID file is
     created.  It is initialised to '#f'.

 -- Parameter: file-existence-procedure
     Hold a function that tests PID file existence.  It is initialised
     to 'file-exists?'.

 -- Parameter: textual-contents-reading-procedure
     Hold a function that reads the PID file contents and returns them
     as a Scheme string.  It is initialised to:

          (lambda (pid-pathname)
            (with-input-from-file pid-pathname
              (lambda ()
                ;;A valid PID file does not contain a lot of
                ;;characters; let's say 32 at most.
                (get-string-n (current-input-port) 32))))

 -- Parameter: textual-contents-writing-procedure
     Hold a function that writes the PID file.  It is initialised to:

          (lambda (pid-pathname contents)
            (with-output-to-file pid-pathname
              (lambda ()
                (display contents))))

 -- Parameter: file-removal-procedure
     Hold a function that removes the PID file.  It is initialised to
     'delete-file'.

 -- Parameter: log-procedure
     Hold a function accepting 'format'-like arguments and logging the
     result:

          ((log-procedure) ?TEMPLATE-STRING ?ARG ...)

     If set to '#f': logging is disabled.  It is initialised to '#f'.


File: vicare-libs.info,  Node: posix pid-files api,  Next: posix pid-files conditions,  Prev: posix pid-files config,  Up: posix pid-files

4.29.3 PID files programming API
--------------------------------

The following bindings are exported by the library '(vicare posix
pid-files)'.

 -- Function: create-pid-file
     If requested: create the PID file and write the PID number in it,
     followed a newline.  Return unspecified values.

     This function makes use of the following parameters:

     'pid-pathname'
          When '#f' do nothing.  Else use the string value as PID file
          pathname.

     'file-existence-procedure'
          Use the referenced procedure to test for PID file existence.

     'textual-contents-writing-procedure'
          Use the referenced procedure to write the PID file contents.

     Raised exceptions:

        * If the file already exists, raise an exception with condition
          components: '&pid-file-already-exists', '&who', '&message',
          '&irritants'.

        * If creating the file fails, add a condition object of type
          '&pid-file-creation' to whatever condition object is raised by
          the underlying procedure.

 -- Function: remove-pid-file
     Remove the PID file, if any; if PID file use is disabled: do
     nothing.  Return unspecified values.

     This function makes use of the following parameters:

     'pid-pathname'
          When '#f' do nothing.  Else use the string value as PID file
          pathname.

     'file-existence-procedure'
          Use the referenced procedure to test for PID file existence.

     'textual-contents-reading-procedure'
          Use the referenced procedure to read the PID file contents.

     'file-removal-procedure'
          Use the referenced procedure to remove the PID file.

     Raised exceptions:

        * If the file does not exist, raise an exception with condition
          components: '&pid-file-missing', '&who', '&message',
          '&irritants'.

        * If reading the file fails, add a condition object of type
          '&pid-file-removal' to whatever condition object is raised by
          the underlying procedure.

        * If the file contents are invalid, raise an exception with
          condition component: '&pid-file-invalid-contents', '&who',
          '&message', '&irritants'.

        * If removing the file fails, add a condition object of type
          '&pid-file-removal' to whatever condition object is raised by
          the underlying procedure.

 -- Function: setup-compensated-pid-file-creation
     Call the function 'create-pid-file' and push a call to
     'remove-pid-file' to the current compensations stack.  *note
     Compensation stacks: (vicare-scheme)iklib compensations.

     Beware of creating the compensation stack *inside* the dynamic
     environment configuration for PID file creation; in the following
     example the 'with-compensations' syntax must be inside the
     'parametrise' syntax:

          (parametrise ((pid-pathname "..."))
            (with-compensations
             (setup-compensated-pid-file-creation)
             ...))


File: vicare-libs.info,  Node: posix pid-files conditions,  Prev: posix pid-files api,  Up: posix pid-files

4.29.4 Condition object types
-----------------------------

The following bindings are exported by the library '(vicare posix
pid-files)'.

PID file errors
...............

 -- Condition Type: &pid-file-error
     Base condition type used to tag compound condition objects as PID
     file errors.  It is derived from '&error'.  It has no fields.

 -- Function: make-pid-file-error-condition
     Build and return a new condition object of type '&pid-file-error'.

 -- Function: pid-file-error-condition? OBJ
     Return '#t' if OBJ is an instance of '&pid-file-error'.

Already exists errors
.....................

 -- Condition Type: &pid-file-already-exists
     Condition type used to tag compound condition objects as "PID file
     already exists" errors: it must be used whenever, upon attempting
     to create a PID file, a file with the selected pathname already
     exists.  It is derived from '&pid-file-error'.  It has no fields.

 -- Function: make-pid-file-already-exists-condition
     Build and return a new condition object of type
     '&pid-file-already-exists'.

 -- Function: pid-file-already-exists-condition? OBJ
     Return '#t' if OBJ is an instance of '&pid-file-already-exists'.

Missing file errors
...................

 -- Condition Type: &pid-file-missing
     Condition type used to tag compound condition objects as "PID file
     missing" errors: it must be used whenever the PID file does not
     exist but it should.  It is derived from '&pid-file-error'.  It has
     no fields.

 -- Function: make-pid-file-missing-condition
     Build and return a new condition object of type
     '&pid-file-missing'.

 -- Function: pid-file-missing-condition? OBJ
     Return '#t' if OBJ is an instance of '&pid-file-missing'.

Creation errors
...............

 -- Condition Type: &pid-file-creation
     Condition type used to tag compound condition objects as "PID file
     creation" errors: it must be used whenever an error occurs while
     creating a PID file.  It is derived from '&pid-file-error'.  It has
     no fields.

 -- Function: make-pid-file-creation-condition
     Build and return a new condition object of type
     '&pid-file-creation'.

 -- Function: pid-file-creation-condition? OBJ
     Return '#t' if OBJ is an instance of '&pid-file-creation'.

Removal errors
..............

 -- Condition Type: &pid-file-removal
     Condition type used to tag compound condition objects as "PID file
     removal" errors: it must be used whenever an error occurs while
     removing a PID file.  It is derived from '&pid-file-error'.  It has
     no fields.

 -- Function: make-pid-file-removal-condition
     Build and return a new condition object of type
     '&pid-file-removal'.

 -- Function: pid-file-removal-condition? OBJ
     Return '#t' if OBJ is an instance of '&pid-file-removal'.

Invalid contents errors
.......................

 -- Condition Type: &pid-file-invalid-contents
     Condition type used to tag compound condition objects as "PID file
     invalid contents" errors: it must be used whenever the PID file
     does not contain the PID of the current process.  It is derived
     from '&pid-file-error'.  It has no fields.

 -- Function: make-pid-file-invalid-contents-condition
     Build and return a new condition object of type
     '&pid-file-invalid-contents'.

 -- Function: pid-file-invalid-contents-condition? OBJ
     Return '#t' if OBJ is an instance of '&pid-file-invalid-contents'.


File: vicare-libs.info,  Node: posix lock-pid-files,  Next: posix log-files,  Prev: posix pid-files,  Up: posix

4.30 Creating lock PID files
============================

The library '(vicare posix lock-pid-files)' implements facilities for
the creation of lock PID files, built on top of the library '(vicare
posix)'.

* Menu:

* posix lock-pid-files intro::  Introduction to lock PID files.
* posix lock-pid-files api::    Programming interface to lock PID files.
* posix lock-pid-files cond::   Condition object types.


File: vicare-libs.info,  Node: posix lock-pid-files intro,  Next: posix lock-pid-files api,  Up: posix lock-pid-files

4.30.1 Introduction to PID files
--------------------------------

A lock PID file is a textual file in ASCII encoding created at process
start time and deleted at process exit time; it contains a string
representing the PID number of the current process followed by a newline
character.

   The lock PID file is especially useful whenever a server is executed
as daemon:

   * It allows the execution of a single instance of the daemon, causing
     instances launched later to recognise themselves as such and so
     exit.

   * It allows for quick retrieval of the PID number, which can be used
     to send interprocess signals to the daemon; for example: to shut it
     down, to restart it, to update its configuration.

   The lock PID file must be created after a server daemonisation
process has completed: this way we correctly store the PID of the daemon
process, rather than the PID of the starting process.

   The lock PID file must be created after a process has changed its
user and group IDs to drop special privileges: this way the file is
created with appropriate owner and group.

   All the operations performed by this library are logged; logging
operations related to the lock PID file rely on a function handed as
argument.


File: vicare-libs.info,  Node: posix lock-pid-files api,  Next: posix lock-pid-files cond,  Prev: posix lock-pid-files intro,  Up: posix lock-pid-files

4.30.2 Programming interface to lock PID files
----------------------------------------------

The following bindings are exported by the library '(vicare posix
lock-pid-files)'.

 -- Function: with-lock-pid-file LOCK-PATHNAME LOG THUNK
     Evaluate THUNK while a lock PID file has been created and locked;
     upon returning from the THUNK the lock file is closed and deleted.
     Return the return value of THUNK; if THUNK raises an exception the
     lock file is closed and deleted, then the exception raised again in
     a non-continuable fashion.

     Reentering the evaluation of THUNK by returning to continuations
     multiple time causes undefined behaviour.

     LOCK-PATHNAME must be a non-empty string representing the pathname
     of the lock file.

     LOG must be a procedure accepting 'format'-like arguments and
     logging the resulting string:

          (LOG ?TEMPLATE-STRING ?ARG ...)


File: vicare-libs.info,  Node: posix lock-pid-files cond,  Prev: posix lock-pid-files api,  Up: posix lock-pid-files

4.30.3 Condition object types
-----------------------------

The following bindings are exported by the library '(vicare posix
lock-pid-files)'.

Generic error
.............

 -- Condition Type: &lock-pid-file-error
     Condition object type used to tag exceptions raised in lock PID
     files operations.  It is derived from '&error'.  It has no fields.

 -- Function: make-lock-pid-file-condition
     Build and return a new instance of '&lock-pid-file-error'.

 -- Function: lock-pid-file-condition? OBJ
     Return '#t' if OBJ is an instance of '&lock-pid-file-error', else
     return '#f'.

Lock file creation error
........................

 -- Condition Type: &lock-pid-file-creation
     Condition object type used to tag exceptions raised in lock PID
     files creation operations.  It is derived from
     '&lock-pid-file-error'.  It has no fields.

 -- Function: make-lock-pid-file-condition
     Build and return a new instance of '&lock-pid-file-creation'.

 -- Function: lock-pid-file-condition? OBJ
     Return '#t' if OBJ is an instance of '&lock-pid-file-creation',
     else return '#f'.

Lock file removal error
.......................

 -- Condition Type: &lock-pid-file-removal
     Condition object type used to tag exceptions raised in lock PID
     files removal operations.  It is derived from
     '&lock-pid-file-error'.  It has no fields.

 -- Function: make-lock-pid-file-condition
     Build and return a new instance of '&lock-pid-file-removal'.

 -- Function: lock-pid-file-condition? OBJ
     Return '#t' if OBJ is an instance of '&lock-pid-file-removal', else
     return '#f'.

Lock file locking error
.......................

 -- Condition Type: &lock-pid-file-locking
     Condition object type used to tag exceptions raised in lock PID
     files locking and content writing operations.  It is derived from
     '&lock-pid-file-error'.  It has no fields.

 -- Function: make-lock-pid-file-condition
     Build and return a new instance of '&lock-pid-file-locking'.

 -- Function: lock-pid-file-condition? OBJ
     Return '#t' if OBJ is an instance of '&lock-pid-file-locking', else
     return '#f'.


File: vicare-libs.info,  Node: posix log-files,  Next: posix daemonisations,  Prev: posix lock-pid-files,  Up: posix

4.31 Logging facilities
=======================

The library '(vicare posix log-files)' implements logging facilities,
optionally to log files; it is built on top of '(vicare posix)'.  When
using a log file for a server: we should open the log file after
daemonising the server and after dropping privileges by changing the
user and group ID.

* Menu:

* posix log-files config::      Configuring logging facilities.
* posix log-files api::         Logging programming interface.


File: vicare-libs.info,  Node: posix log-files config,  Next: posix log-files api,  Up: posix log-files

4.31.1 Configuring logging facilities
-------------------------------------

The following bindings are exported by the library '(vicare posix
log-files)'.

 -- Parameter: logging-enabled?
     Boolean: true if logging is enabled, false otherwise.  It is
     initialised to '#f'.

 -- Parameter: log-port
     A textual output port to which log messages must be written; the
     port is expected to have 'line' buffering, but this is not
     required.  It is initialised to the value of the parameter
     'current-output-port' at the time the library is instantiated.

     This parameter is configured by calls to 'open-logging'.

 -- Parameter: log-prefix
     A string representing the prefix for every log message; it can be
     the empty string.  It is initialised to the empty string.  It is
     useful to include the ID of the current process in this prefix
     string, *note getpid: posix pid.

 -- Parameter: log-pathname
     False or a Scheme string representing the log file pathname.  The
     special string '"-"' means: log to the error port.  It is
     initialised to '"-"'.

     If desired, this parameter should be configured before calling
     'open-logging'.


File: vicare-libs.info,  Node: posix log-files api,  Prev: posix log-files config,  Up: posix log-files

4.31.2 Logging programming interface
------------------------------------

The following bindings are exported by the library '(vicare posix
log-files)'.

 -- Function: open-logging
     If logging is enabled: configure the log port; return unspecified
     values.  If the selected pathname is '-' assume the log messages
     must go to the current error port.  Otherwise open a log file.

     This function makes use of the following parameters:

     'logging-enabled?'
          If set to true consider logging enabled, else do nothing and
          return.

     'log-pathname'
          Used to retrieve the configured log file pathname.

     'log-port'
          Used to store the Scheme textual output port to which log
          messages are sent.

 -- Function: close-logging
     Close the current log port unless it is the console error port or
     the configured log file pathname is a single dash; return
     unspecified values.

     This function makes use of the following parameters:

     'log-pathname'
          Used to retrieve the configured log file pathname and check if
          it is a single dash.

     'log-port'
          Used to retrieve current log port.

     Notice that the 'logging-enabled?' parameter is ignored.

 -- Function: setup-compensated-log-file-creation
     Call 'open-logging' and push a call to 'close-logging' on the
     current compensations stack.

 -- Function: log TEMPLATE ARG ...
     If logging is enabled: format a log message and write it to the
     current log port; return unspecified values.

     TEMPLATE must be a 'format'-like string expecting as many values as
     there are ARG arguments.  It is usual, but not mandatory, to output
     log messages as single lines.

     A log message is composed as follows:

       1. The current prefix referenced by the parameter 'log-prefix'.

       2. A date string, almost in ISO 8601 format.

       3. A colon character followed by a space character.

       4. The result of formatting TEMPLATE with the given ARG
          arguments.

       5. A newline character.

 -- Function: log-condition-message TEMPLATE CONDITION
     If logging is enabled: format a log message extracting the message
     from the condition object CONDITION; return unspecified values.
     The template is expected to contain a '~a' sequence to be replaced
     by the condition message.

 -- Syntax: with-logging-handler (condition-message ?TEMPLATE) ?BODY0
          ?BODY ...
 -- Auxiliary Syntax: condition-message
     Evaluate the ?BODY forms; in case of exception: log a message with
     'log-condition-message' and raise it again.

     'condition-message' must be the identifier exported by the library
     '(rnrs rnrs (6))'.  ?TEMPLATE must be an expression evaluating to a
     string template suitable to be used as first argument to
     'log-condition-message'.


File: vicare-libs.info,  Node: posix daemonisations,  Next: posix tcp-server-sockets,  Prev: posix log-files,  Up: posix

4.32 Turn the process into a daemon
===================================

The library '(vicare posix daemonisations)' implements facilities that
turn a running process into a daemon; it is build on top of '(vicare
posix)'.  A "daemon process" is a process that runs in the background
with no controlling process, usually to provide networking service.

   Process daemonisation is usually performed in the early phase of a
process start up, before the any actual work is performed.  The
daemonisation involves forking a child process and exiting the parent
process; this changes the ID of the surviving process.

   The following bindings are exported by the library '(vicare posix
daemonisations)'.

 -- Function: daemonise
     Turn the current process into a daemon.  If successful: return a
     fixnum representing the new process group ID, else raise an
     exception.  Follow this procedure:

       1. Check the ID of the parent process: if it is '1' assume this
          process is already a daemon and return doing nothing else.
          '1' is the ID of the 'init' process.  *note getppid: posix
          pid.

       2. Block all interprocess signals using 'signal-bub-init' from
          '(vicare posix)'.  *note signal-bub-init: posix signal.

       3. Fork the process using 'fork' from '(vicare posix)'; exit the
          parent process with status code 0.  The daemon process is the
          child.  *note fork: posix process.

       4. Change the current working directory to root.  *note chdir:
          posix dir.

       5. Set the current umask to zero.  *note umask: posix file.

       6. Open a new file descriptor reading from and writing to the
          '/dev/null' device; close the file descriptors '0', '1' and
          '2' replacing them with the new file descriptor.

       7. Detach the process from the controlling terminal and become
          session leader; this is done with a call to 'setsid' from
          '(vicare posix)'.  *note setsid: posix job.

       8. Unblock all interprocess signals using 'signal-bub-final' from
          '(vicare posix)'.  *note signal-bub-final: posix signal.


File: vicare-libs.info,  Node: posix tcp-server-sockets,  Next: posix sendmail,  Prev: posix daemonisations,  Up: posix

4.33 TCP server sockets
=======================

The library '(vicare posix tcp-server-sockets)' implements facilities to
create TCP sockets to be used by networking servers; it is build on top
of '(vicare posix)'.

   The following bindings are exported by the library '(vicare posix
tcp-server-sockets)'.

 -- Function: make-master-sock INTERFACE PORT MAX-PENDING-CONNECTIONS
     Given a string INTERFACE representing a network interface to listen
     to and a network PORT number: open a master server socket, IP
     version 4, TCP protocol, bind it to the interface and port, enable
     it to listen for connections.  Return the master socket descriptor.

     INTERFACE must be a string representing the server interface to
     bind to; for example 'localhost'.  INTERFACE is used as first
     argument in calls to 'getaddrinfo', *note getaddrinfo: posix socket
     addresses info.

     PORT must be an exact integer representing the server port to
     listen to; for example 8081.

     MAX-PENDING-CONNECTIONS must be a non-negative fixnum representing
     the maximum number of pending connections.

     The returned socket is configured to linger for 1 second
     ('SO_LINGER') and the address is configured to be reused
     ('SO_REUSEADDR').

     Whenever the returned socket becomes readable: it means that at
     least one incoming connection is pending.

 -- Function: close-master-sock MASTER-SOCK
     Close the master socket descriptor returned by a previous call to
     'make-master-sock'.

 -- Function: make-server-sock-and-port MASTER-SOCK
     Given the socket descriptor MASTER-SOCK representing a master
     socket descriptor, already bound to an address, with a pending
     connection: accept the connection and configure the resulting
     server socket descriptor to non-blocking mode.

     Return 3 values:

       1. The server socket descriptor.

       2. A Scheme input/output binary port wrapping the descriptor.
          Closing the Scheme port will also close the server socket.

       3. A bytevector representing the client address as 'struct
          sockaddr'.

 -- Function: close-server-port SERVER-PORT
     Close the Scheme port wrapping a server socket descriptor returned
     by a previous call to 'make-server-sock-and-port'.


File: vicare-libs.info,  Node: posix sendmail,  Next: posix mailx,  Prev: posix tcp-server-sockets,  Up: posix

4.34 Sending email with 'sendmail'
==================================

The library '(vicare posix sendmail)' exports a simple API to send email
through the external program 'sendmail'.  This library is a
demonstration of the basic mechanism needed to execute an external
program, write data to its standard input and read data from its
standard output.

     The source distribution of Vicare includes a simple demo program
     'demo-sendmail.sps' in the 'tests' subdirectory of the source tree.

   The executable file 'sendmail' must be reachable in the current
'PATH'; 'sendmail' is executed with the options:

     sendmail -t -i -v

the ASCII text displayed on the standard output is captured for
diagnostic.

 -- Function: sendmail MESSAGE
     Send an email message spawning a subprocess that launches
     'sendmail'.  MESSAGE must be a bytevector representing the message
     in ASCII encoding.  When successful: return a string representing
     the output of 'sendmail'; otherwise raise an exception.

     The source and destination addresses are extracted from the message
     itself.

   Example:

     #!r6rs
     (import (vicare)
       (vicare posix sendmail))

     (define (send-it message)
       (define rv
         (sendmail (string->ascii message)))
       (display rv)
       (newline)
       (flush-output-port (current-output-port)))

     (send-it "From: <marco@localhost>
     To: <marco@localhost>
     Subject: demo 01
     MIME-Version: 1.0
     Content-Type: text/plain

     This is demo 01.
     --\x20;
     Marco Maggi
     ")


File: vicare-libs.info,  Node: posix mailx,  Next: posix curl,  Prev: posix sendmail,  Up: posix

4.35 Sending email with 'mailx'
===============================

The library '(vicare posix mailx)' exports a simple API to send email
through the external program 'mailx'.  This library is a demonstration
of the basic mechanism needed to execute an external program, write data
to its standard input and read data from its standard output and
standard error.

     The source distribution of Vicare includes a simple demo program
     'demo-mailx.sps' in the 'tests' subdirectory of the source tree.

   The executable file 'mailx' must be reachable in the current 'PATH';
'mailx' is executed with the command line:

     MAILRC=/dev/null mailx -t -i -v

the ASCII text displayed on the standard output and standard error is
captured for diagnostic.

 -- Function: mailx MESSAGE
     Send an email message spawning a subprocess that launches 'mailx'.
     MESSAGE must be a bytevector representing the message in ASCII
     encoding.  When successful: return two strings representing the
     output of 'mailx' to, respectively, standard output and standard
     error; otherwise raise an exception.

     The source and destination addresses are extracted from the message
     itself.

   Example:

     #!r6rs
     (import (vicare)
       (vicare posix mailx))

     (define (send-it message)
       (define rv
         (mailx (string->ascii message)))
       (display rv)
       (newline)
       (flush-output-port (current-output-port)))

     (send-it "From: <marco@localhost>
     To: <marco@localhost>
     Subject: demo 01
     MIME-Version: 1.0
     Content-Type: text/plain

     This is demo 01.
     --\x20;
     Marco Maggi
     ")


File: vicare-libs.info,  Node: posix curl,  Next: posix wget,  Prev: posix mailx,  Up: posix

4.36 Downloading files with 'curl'
==================================

The library '(vicare posix curl)' exports a simple API to download files
through the external program 'curl'.  This library is a demonstration of
the basic mechanism needed to execute an external program and read data
from its standard output and standard error.

     The source distribution of Vicare includes a simple demo program
     'demo-curl.sps' in the 'tests' subdirectory of the source tree.

   The executable file 'curl' must be reachable in the current 'PATH';
'curl' is always with the command line:

     curl --silent --show-error

the ASCII text displayed on the standard output and standard error is
captured for diagnostic.  Additional options can be appended to the
command line.

 -- Function: curl URL OPTION ...
     Download a file spawning a subprocess that launches 'curl'.  URL
     must be a string representing the URL in ASCII encoding.  Each
     OPTION must be a string representing a 'curl' command line
     argument.  When successful: return two strings representing the
     output of 'curl' to, respectively, standard output and standard
     error; otherwise raise an exception.

   Example:

     #!r6rs
     (import (vicare)
       (vicare posix curl))

     (define (get-it url)
       (receive (out err)
           (curl url)
         (display out)
         (newline)
         (display err)
         (newline)
         (flush-output-port (current-output-port))))

     (get-it "http://marcomaggi.github.io/index.html")


File: vicare-libs.info,  Node: posix wget,  Next: posix find,  Prev: posix curl,  Up: posix

4.37 Downloading files with 'wget'
==================================

The library '(vicare posix wget)' exports a simple API to download files
through the external program 'wget'.  This library is a demonstration of
the basic mechanism needed to execute an external program and read data
from its standard output and standard error.

     The source distribution of Vicare includes a simple demo program
     'demo-wget.sps' in the 'tests' subdirectory of the source tree.

   The executable file 'wget' must be reachable in the current 'PATH';
the library does *not* use default options for the command line of
'wget'; the ASCII text displayed on the standard output and standard
error is captured for diagnostic.

 -- Function: wget OPTION ...
     Perform an operation spawning a subprocess that launches 'wget'.
     Each OPTION must be a string representing a 'wget' command line
     argument.  When successful: return two strings representing the
     output of 'wget' to, respectively, standard output and standard
     error; otherwise raise an exception.

   Example:

     #!r6rs
     (import (vicare)
       (vicare posix wget))

     (define (get-it url)
       (receive (out err)
           (wget "--output-document=-" url)
         (display out)
         (newline)
         (display err)
         (newline)
         (flush-output-port (current-output-port))))

     (get-it "http://marcomaggi.github.io/index.html")


File: vicare-libs.info,  Node: posix find,  Prev: posix wget,  Up: posix

4.38 Scanning the file system with 'find'
=========================================

The library '(vicare posix find)' exports a simple API to scan file
systems through the external program 'find'.  This library is a
demonstration of the basic mechanism needed to execute an external
program and read data from its standard output and standard error.

     The source distribution of Vicare includes a simple demo program
     'demo-find.sps' in the 'tests' subdirectory of the source tree.

   The executable file 'find' must be reachable in the current 'PATH';
the library does *not* use default options for the command line of
'find'; the ASCII text displayed on the standard output and standard
error is captured for diagnostic.

 -- Function: find OPTION ...
     Perform an operation spawning a subprocess that launches 'find'.
     Each OPTION must be a string representing a 'find' command line
     argument.  When successful return 3 values: a fixnum representing
     the exit status of the subprocess; two strings representing the
     output of 'find' to, respectively, standard output and standard
     error; otherwise raise an exception.

   Example:

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (prefix (vicare posix find) find.)
       (only (vicare containers strings)
             string-tokenise)
       (only (vicare containers char-sets)
             char-set char-set-complement))

     (define (scan-it root)
       (receive (status out err)
           (find.find root "-type" "f"
                      "-and" "-executable"
                      "-and" "-maxdepth" "2"
                      "-and" "-iname" "*bin*"
                      "-and" "-print0")
         (when (string? out)
           (for-each (lambda (hit)
                       (write hit)
                       (newline))
             (string-tokenise out
               (char-set-complement (char-set #\x00)))))
         (display err)
         (newline)
         (flush-output-port (current-output-port))))

     (scan-it "/usr")


File: vicare-libs.info,  Node: glibc,  Next: iconv,  Prev: posix,  Up: Top

5 The GNU C Library interface
*****************************

The functions described in this chapter are exported by the library
'(vicare glibc)'.  The API attempts to create a one-to-one Scheme
functions mapping towards GNU C Library functions, keeping the same
semantics as much as possible; the platform's own documentation is
relevant at the Scheme level.

     *NOTE* These bindings are included and installed by default and
     they can be excluded at compile time by giving the option
     '--disable-glibc' to the 'configure' stript.

   All the constants needed to use the interface are available as
identifier syntaxes exported by the '(vicare platform constants)'
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to '#f'.

   On non-GNU C Library platforms we must avoid calling these functions,
else the behaviour is undefined.

   The availability of the GNU C Library API can be tested at run-time
with the function 'vicare-built-with-glibc-enabled' from '(vicare)'
(*note vicare-built-with-glibc-enabled: (vicare-scheme)iklib config.),
and at expand-time with the clause 'glibc-enabled' of 'cond-expand' from
SRFI-0 (*note glibc-enabled: srfi cond-expand vicare.).

* Menu:

* glibc cond-expand::           Feature-based expansion.
* glibc env::                   Operating system environment
                                variables.
* glibc dir::                   File system directories.
* glibc temp::                  Temporary files and directories.
* glibc sync::                  File system synchronisation.
* glibc socket::                Network sockets.
* glibc net::                   Networking.
* glibc math::                  Mathematics.
* glibc random::                Pseudo-random numbers.
* glibc match::                 Pattern matching, globbing and
                                regular expressions.
* glibc word::                  Performing word expansion.


File: vicare-libs.info,  Node: glibc cond-expand,  Next: glibc env,  Up: glibc

5.1 Feature-based expansion
===========================

 -- Syntax: cond-expand (?FEATURE-REQUIREMENT ?BODY0 ?BODY ...) ...
     Process the given clauses in left-to-right order and expand to the
     sequence of ?BODY forms from the first clause for which the
     ?FEATURE-REQUIREMENT is satisfied.

     This syntax supports all the features defined by 'cond-expand' from
     SRFI-0 (*note Features supported by Vicare: srfi cond-expand
     vicare.), and in addition it supports a feature for each system
     function exported by '(vicare glibc)'; such features use the
     identifier exported by the library as feature requirement.

     As example, some platforms implement 'fdatasync' while others only
     have 'fsync', to select among them we write the following:

          (import (vicare)
            (prefix (vicare glibc) glibc.))

          (glibc.cond-expand
            (glibc.fdatasync
             (do-something))
            (glibc.fsync
             (do-something-else))
            (else
             (raise-error)))


File: vicare-libs.info,  Node: glibc env,  Next: glibc dir,  Prev: glibc cond-expand,  Up: glibc

5.2 Operating system environment variables
==========================================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: clearenv
     Interface to the C function 'clearenv()', *note clearenv:
     (libc)Environment Access.  Remove all the entries from the
     environment.  Return unspecified values.


File: vicare-libs.info,  Node: glibc dir,  Next: glibc temp,  Prev: glibc env,  Up: glibc

5.3 File system directories
===========================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: dirfd STREAM
     Interface to the C function 'dirfd()', *note dirfd: (libc)Opening a
     Directory.  Acquire a file descriptor associated to STREAM, which
     must be an instance of 'directory-stream'; *note posix dir:: for
     details.  If successful return a fixnum representing the file
     descriptor, else raise an exception.


File: vicare-libs.info,  Node: glibc temp,  Next: glibc sync,  Prev: glibc dir,  Up: glibc

5.4 Temporary files and directories
===================================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: mkstemp TEMPLATE
     Interface to the C function 'mkstemp()', *note mkstemp:
     (libc)Temporary Files.  Create a temporary file, create it and open
     a file descriptor for reading and writing.  TEMPLATE must be a
     mutable bytevector holding a template pathname on entering and the
     actual pathname on returning.  If successful return a file
     descriptor, else raise an exception.

 -- Function: mkdtemp TEMPLATE
     Interface to the C function 'mkdtemp()', *note mkdtemp:
     (libc)Temporary Files.  Create a temporary directory for reading
     and writing.  TEMPLATE must be a mutable bytevector holding a
     template pathname on entering and the actual pathname on returning.
     If successful return TEMPLATE itself, else raise an exception.


File: vicare-libs.info,  Node: glibc sync,  Next: glibc socket,  Prev: glibc temp,  Up: glibc

5.5 File system synchronisation
===============================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: sync
     Interface to the C function 'sync()', *note (libc)Synchronizing
     I/O::.  Flush kernel buffer data and meta informations to the file
     system devices.  If successful return unspecified values, else
     raise an exception.

 -- Function: fsync FD
     Interface to the C function 'fsync()', *note (libc)Synchronizing
     I/O::.  Flush kernel buffer data and meta informations to the file
     system device for the file descriptor FD.  If successful return
     unspecified values, else raise an exception.

 -- Function: fdatasync FD
     Interface to the C function 'fdatasync()', *note
     (libc)Synchronizing I/O::.  Flush kernel buffer data to the file
     system device for the file descriptor FD.  If successful return
     unspecified values, else raise an exception.


File: vicare-libs.info,  Node: glibc socket,  Next: glibc net,  Prev: glibc sync,  Up: glibc

5.6 Network sockets
===================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: if-nametoindex NAME
     Interface to the C function 'if_nametoindex()', *note
     if_nametoindex: (libc)Interface Naming.  Convert the string NAME
     representing a network interface to the corresponding internal
     index.  Return a fixnum representing the index or false if NAME is
     invalid.

          (import (vicare)
            (prefix (vicare glibc) glibc.))

          (glibc.if-indextoname 0)      => #f
          (glibc.if-indextoname 1)      => "lo"
          (glibc.if-indextoname 2)      => "eth0"

 -- Function: ikptr if-indextoname INDEX
     Interface to the C function 'if_indextoname()', *note
     if_indextoname: (libc)Interface Naming.  Convert the fixnum INDEX
     associated to an interface to the corresponding string name.
     Return a string holding the name or false if INDEX is invalid.

          (import (vicare)
            (prefix (vicare glibc) glibc.))

          (glibc.if-nametoindex "lo")   => 1
          (glibc.if-nametoindex "eth0") => 2

 -- Function: if-nameindex
     Interface to the C function 'if_nameindex()', *note if_nameindex:
     (libc)Interface Naming.  Build and return an association list
     having fixnums as keys and strings as values; the fixnums are the
     interface indexes, the strings are the corresponding interface
     names.

          (import (vicare)
            (prefix (vicare glibc) glibc.))

          (glibc.if-nameindex)
          => ((4 . "wlan0")
              (2 . "eth0")
              (1 . "lo"))

 -- Function: gethostbyname2 HOSTNAME ADDRTYPE
     Interface to the C function 'gethostbyname2()', *note
     gethostbyname2: (libc)Host Names.  Like 'gethostbyname' but allows
     the selection of the address type with the parameter ADDRTYPE which
     must be 'AF_INET' or 'AF_INET6'.


File: vicare-libs.info,  Node: glibc net,  Next: glibc math,  Prev: glibc socket,  Up: glibc

5.7 Networking
==============

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: IN_CLASSA ADDR
 -- Function: IN_CLASSB ADDR
 -- Function: IN_CLASSC ADDR
 -- Function: IN_CLASSD ADDR
 -- Function: IN_MULTICAST ADDR
 -- Function: IN_EXPERIMENTAL ADDR
 -- Function: IN_BADCLASS ADDR
     Return '#t' if ADDR is an 32-bit exact integer representing, in
     native endianness, an IPv4 host address in the specified address
     class; otherwise return '#f'.

          (import (vicare)
            (prefix (vicare posix) px.)
            (prefix (vicare glibc) glibc.))

          (define host-address.class-B '#vu8(128 0 0 1))
          (define addr
            (px.sockaddr_in.in_addr.number
             (px.make-sockaddr_in host-address.class-B 88)))
          (glibc.IN_CLASSB addr)
          => #t

 -- Function: IN6_IS_ADDR_UNSPECIFIED ADDR
 -- Function: IN6_IS_ADDR_LOOPBACK ADDR
 -- Function: IN6_IS_ADDR_LINKLOCAL ADDR
 -- Function: IN6_IS_ADDR_SITELOCAL ADDR
 -- Function: IN6_IS_ADDR_V4MAPPED ADDR
 -- Function: IN6_IS_ADDR_V4COMPAT ADDR
 -- Function: IN6_IS_ADDR_MULTICAST ADDR
 -- Function: IN6_IS_ADDR_MC_NODELOCAL ADDR
 -- Function: IN6_IS_ADDR_MC_LINKLOCAL ADDR
 -- Function: IN6_IS_ADDR_MC_SITELOCAL ADDR
 -- Function: IN6_IS_ADDR_MC_ORGLOCAL ADDR
 -- Function: IN6_IS_ADDR_MC_GLOBAL ADDR
     Return '#t' if ADDR is a bytevector representing a 'struct
     in6_addr' of the specified type; otherwise return '#f'.

 -- Function: IN6_ARE_ADDR_EQUAL ADDR1 ADDR2
     The arguments ADDR1 and ADDR2 must be bytevectors representing two
     'struct in6_addr'.  Return '#t' if they represent the same address;
     otherwise return '#f'.

 -- Function: bindresvport SOCK SOCKADDR-IN
 -- Function: bindresvport6 SOCK SOCKADDR-IN6
     Interfaces to the C functions 'bindresvport()' and
     'bindresvport6()', see the manual page *note Bind a socket to a
     privileged IP port: (*manpages*)bindresvport.  Bind a socket
     descriptor SOCK to a privileged anonymous IP port, that is, a port
     number arbitrarily selected from the range [512, 1023].  If an
     error occurs: raise an exception.

     SOCKADDR-IN must be a bytevector holding a 'struct sockaddr_in';
     SOCKADDR-IN6 must be a bytevector holding a 'struct sockaddr_in6'.


File: vicare-libs.info,  Node: glibc math,  Next: glibc random,  Prev: glibc net,  Up: glibc

5.8 Mathematics
===============

A binding for each of the following constants is exported by '(vicare
platform constants)':

     M_E         M_LOG2E     M_LOG10E
     M_LN2       M_LN10      M_PI
     M_PI_2      M_PI_4      M_1_PI
     M_2_PI      M_2_SQRTPI  M_SQRT2
     M_SQRT1_2

   The following bindings are exported by the '(vicare glibc)' library.
The functions are implemented by the GNU C library and are probably
faster than the ones implemented by the R6RS libraries.  All the
arguments FL must be flonums, all the arguments CFL must be complex
flonums.

Trigonometric functions
.......................

 -- Function: csin CFL
 -- Function: ccos CFL
 -- Function: ctan CFL
     Trigonometric functions for complex flonums.

 -- Function: casin CFL
 -- Function: cacos CFL
 -- Function: catan CFL
     Inverse trigonometric functions for complex flonums.

Exponents and logarithms
........................

 -- Function: cexp CFL
     Return the base of the natural logarithms raised to the power of
     the operand.

 -- Function: clog CFL
     Return the natural logarithm of the operand.

 -- Function: clog10 CFL
     Return the base 10 logarithm of the operand.

 -- Function: csqrt CFL
     Return the square root of the operand.

 -- Function: cpow CFL1 CFL2
     Return CFL1 raised to the power of CFL2.

Hyperbolic functions
....................

 -- Function: sinh FL
 -- Function: cosh FL
 -- Function: tanh FL
     Hyperbolic functions for flonums.

 -- Function: asinh FL
 -- Function: acosh FL
 -- Function: atanh FL
     Inverse hyperbolic functions for flonums.

 -- Function: csinh CFL
 -- Function: ccosh CFL
 -- Function: ctanh CFL
     Hyperbolic functions for complex flonums.

 -- Function: casinh CFL
 -- Function: cacosh CFL
 -- Function: catanh CFL
     Inverse hyperbolic functions for complex flonums.

Special functions
.................

 -- Function: erf FL
 -- Function: erfc FL
     Interfaces to the C functions 'erf()' and 'erfc()', *note erf:
     (libc)Special Functions.  Compute the error function.

 -- Function: lgamma FL
     Interface to the C function 'lgamma()', *note lgamma: (libc)Special
     Functions.  Compute the natural logarithm of the absolute value of
     the gamma function of the operand.  Return two values: a flonum
     being the result of the function and a fixnum representing the sign
     of the intermediate result.

 -- Function: tgamma FL
     Interface to the C function 'tgamma()', *note lgamma: (libc)Special
     Functions.  Compute the gamma function of the operand.

 -- Function: j0 FL
 -- Function: j1 FL
 -- Function: jn FX FL
     Interfaces to the C functions 'j0()', 'j1()' and 'jn()'; *note j0:
     (libc)Special Functions.  Compute the Bessel functions of the first
     kind.  FX must be a fixnum.

 -- Function: y0 FL
 -- Function: y1 FL
 -- Function: yn FX FL
     Interfaces to the C functions 'y0()', 'y1()' and 'yn()'; *note y0:
     (libc)Special Functions.  Compute the Bessel functions of the
     second kind.  FX must be a fixnum.


File: vicare-libs.info,  Node: glibc random,  Next: glibc match,  Prev: glibc math,  Up: glibc

5.9 Pseudo-random numbers
=========================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: rand
     Interface to the C function 'rand()', *note rand: (libc)ISO Random.
     Return a non-negative exact integer representing the next
     pseudo-random number in the series.  The maximum returned value is
     'RAND_MAX', which is a binding exported by '(vicare platform
     constants)'.

 -- Function: srand SEED
     Interface to the C function 'srand()', *note srand: (libc)ISO
     Random.  Set to the exact integer SEED the seed of the
     pseudo-random numbers series.


File: vicare-libs.info,  Node: glibc match,  Next: glibc word,  Prev: glibc random,  Up: glibc

5.10 Pattern matching, globbing and regular expressions
=======================================================

The following bindings are exported by the '(vicare glibc)' library.

 -- Function: fnmatch PATTERN STRING FLAGS
     Interface to the C function 'fnmatch()', *note fnmatch:
     (libc)Wildcard Matching.  Tests whether STRING matches PATTERN
     according to FLAGS; if it matches return '#t', else return '#f'.

     PATTERN and STRING must be Scheme strings or bytevectors; FLAGS
     must be a fixnum resulting from the bitwise combination ('fxior')
     of the 'FNM_' constants exported by '(vicare platform constants)'.

          #!r6rs
          (import (vicare)
            (prefix (vicare glibc) glibc.)
            (vicare platform constants))

          (glibc.fnmatch "ciao" "ciao"  0)        => #t
          (glibc.fnmatch "ciao" "salut" 0)        => #f

          (glibc.fnmatch "ciao*" "ciao a tutti" 0)
          => #t

          (glibc.fnmatch "*(Ciao)" "CiaoCiao" FNM_EXTMATCH)
          => #t

          (glibc.fnmatch "?(Ciao|Hello)" "Hello" FNM_EXTMATCH)
          => #t

 -- Function: glob PATTERN FLAGS ERROR-HANDLER
 -- Function: glob/string PATTERN FLAGS ERROR-HANDLER
     Interface to the C function 'glob()', *note glob: (libc)Calling
     Glob.  Perform file globbing *in the current directory* using
     PATTERN to select entries according to FLAGS.  If successful 'glob'
     returns a list of bytevectors representing the result,
     'glob/string' returns a list of strings representing the result;
     else both return a fixnum representing one of the error codes:
     'GLOB_ABORTED', 'GLOB_NOMATCH', 'GLOB_NOSPACE'.

     PATTERN must be a string or bytevector.  FLAGS must be a fixnum
     built as bitwise composition ('fxior') of the flags: 'GLOB_ERR',
     'GLOB_MARK', 'GLOB_NOCHECK', 'GLOB_NOSORT', 'GLOB_NOESCAPE',
     'GLOB_PERIOD', 'GLOB_BRACE', 'GLOB_NOMAGIC', 'GLOB_TILDE',
     'GLOB_TILDE_CHECK', 'GLOB_ONLYDIR'.

     ERROR-HANDLER must be '#f' or a callback pointer with the
     signature:

          int ERROR-HANDLER (const char * filename, int error-code)

     called by 'glob' whenever it cannot open a directory; see the
     documentation for 'glob()' and the flag 'GLOB_ERR' for details.

          #!r6rs
          (import (vicare)
            (prefix (vicare glibc) glibc.)
            (vicare platform constants))

          (glibc.glob/string "*" 0 #f)
          => ("bin" "boot" "dev" "etc" "home" "lib"
              "libexec" "lost+found" "media" "mnt" "opt"
              "proc" "root" "sbin" "share" "srv" "sys"
              "tmp" "usr" "var")

          (glibc.glob/string "~marco" GLOB_TILDE #f)
          => ("/home/marco")

POSIX regular expressions
.........................

The following are usage examples of POSIX regular expressions matching:

     #!r6rs
     (import (vicare)
       (prefix (vicare glibc) glibc.)
       (vicare platform constants))

     (let ((rex (glibc.regcomp "abc" 0)))
       (glibc.regexec rex "abc" 0))
     => #((0 . 3)))   ;the regex matched the whole string

     (let ((rex (glibc.regcomp "abc" 0)))
       (glibc.regexec rex "abcdef" 0))
     => #((0 . 3))    ;substring [0, 3) matched

     (let ((rex (glibc.regcomp "ciao" 0)))
       (glibc.regexec rex "abc" 0))
     => #f            ;no match

     (let ((rex (glibc.regcomp "\\(a\\)" 0)))
       (glibc.regexec rex "abc" 0))
     => #((0 . 1)     ;the regexp matched the whole string
          (0 . 1))    ;substring [0, 1) matched the 1st paren

     (let ((rex (glibc.regcomp "\\(a\\)\\(b\\)\\(c\\)" 0)))
       (glibc.regexec rex "abc" 0))
     => #((0 . 3)     ;the regexp matched the whole string
          (0 . 1)     ;substring [0, 1) matched the 1st paren
          (1 . 2)     ;substring [1, 2) matched the 2nd paren
          (2 . 3))    ;substring [2, 3) matched the 3rd paren

     (let ((rex (glibc.regcomp "\\(a\\(b\\(c\\)\\)\\)" 0)))
       (glibc.regexec rex "abc" 0))
     => #((0 . 3)     ;the regexp matched the whole string
          (0 . 3)     ;substring [0, 3) matched the 1st paren
          (1 . 3)     ;substring [1, 3) matched the 2nd paren
          (2 . 3))    ;substring [2, 3) matched the 3rd paren

     (let* ((rex (glibc.regcomp/disown "[a-z]+" REG_EXTENDED))
            (rv  (glibc.regexec rex "abc" 0)))
       (glibc.regfree rex)
       rv)
     => #((0 . 3))

we have to remember that this API can be used only with bytevectors
representing ASCII coded strings and with Scheme strings containing only
characters whose Unicode code points are in the range [0, 255].

   POSIX regular expression patterns are described in the "Base
Definitions" volume of IEEE Std 1003.1-2001, Chapter 9, Regular
Expressions:

     <http://pubs.opengroup.org/onlinepubs/009695399/nframe.html>

URL last verified Dec 9, 2011.

 -- Function: regcomp PATTERN FLAGS
     Interface to the C function 'regcomp()', *note regcomp: (libc)POSIX
     Regexp Compilation.  Compile the regular expression in PATTERN
     accoding to FLAGS.  If successful return a pointer referencing the
     compiled regexp, else raise an exception with condition components
     '&error', '&who', '&message', '&irritants'.

     PATTERN must be a string or bytevector representing the regular
     expression.  FLAGS must be a fixnum resulting from the bitwise
     combination ('fxior') of 'REG_' constants.

     The pointer returned in case of success references a 'regex_t' data
     structure whose fields must be released explicitly by 'regfree', or
     they are automatically released by the garbage collector whenever
     the pointer itself is collected.

 -- Function: regcomp/disown PATTERN FLAGS
     Like 'regcomp', but when the returned pointer object is garbage
     collected nothing happens; we have to explicitly apply 'regfree' to
     the returned pointer object to release the allocated resources.

 -- Function: regexec REGEX STRING FLAGS
     Interface to the C function 'regexec()', *note regexec:
     (libc)Matching POSIX Regexps.  Attempt to match STRING against the
     precompiled regular expression REGEX according to FLAGS.

     REGEX must be a pointer returned by a previous call to 'regcomp';
     STRING must be a string or bytevector in ASCII encoding; FLAGS must
     be a fixnum representing matching flags, we can use zero for no
     flags.

     If one or more matches occur return a vector holding pairs
     describing the portions of STRING that did match; if no match
     occurs return '#f'; if an error occurs raise an exception with
     condition components: '&error', '&who', '&message', '&irritants'.

     The vector returned in case of success contains pairs: the car
     being a fixnum representing the starting offset of a match
     substring, the cdr being a fixnum representing the ending offset of
     a match substring.

     The vector element at index 0 represents the portion of STRING
     which matched the whole regular expression; the vector element at
     index 1 represents the portion of STRING which matched the first
     parenthetical subexpression, the vector element at index 2
     represents the portion of STRING which matched the second
     parenthetical subexpression, and so on.  If STRING matches: the
     returned vector has at least one element.

 -- Function: regfree REGEX
     Interface to the C function 'regfree()', *note regfree:
     (libc)Regexp Cleanup.  Release the resources associated to the
     compiled regular expression REGEX, which must be a pointer.

     It is safe to apply this function multiple times to the same REGEX
     pointer object: releasing occurs only if the first time, subsequent
     applications do nothing.  After the resources have been released:
     REGEX is reset to 'NULL'.


File: vicare-libs.info,  Node: glibc word,  Prev: glibc match,  Up: glibc

5.11 Performing word expansion
==============================

Word expansion is a set of operations acting on a given string and
involving the current system environment variable; it is usually
performed by Unix shell programs.  It works as follows:

     #!r6rs
     (import (rnrs)
       (prefix (vicare posix) px.)
       (prefix (vicare glibc) glibc.)
       (vicare platform constants))

     (px.setenv "CIAO" "BLU")
     (glibc.wordexp/string "$CIAO" 0)        => #("BLU")

     (px.setenv "CIAO" "BLUETTE")
     (glibc.wordexp/string "${CIAO##BLU}" 0) => #("ETTE")

     (glibc.wordexp/string "/bin/ch*" 0)
     => #("/bin/chcon""/bin/chgrp"
          "/bin/chmod" "/bin/chown" "/bin/chroot")


   The following bindings are exported by the '(vicare glibc)' library.

 -- Function: wordexp WORDS FLAGS
 -- Function: wordexp/string WORDS FLAGS
     Interface to the C function 'wordexp()', *note wordexp:
     (libc)Calling Wordexp.  Perform word expansion on WORDS according
     to FLAGS.

     WORDS must be a string or bytevector.  FLAGS must be a fixnum
     resulting from the bitwise combination ('fxior') of the flags:
     'WRDE_NOCMD', 'WRDE_SHOWERR', 'WRDE_UNDEF'.

     If successful 'wordexp' returns a vector holding the resulting
     bytevectors, 'wordexp/string' returns a vector holding the
     resulting strings; else the return value is a fixnum among:
     'WRDE_BADCHAR', 'WRDE_BADVAL', 'WRDE_CMDSUB', 'WRDE_NOSPACE',
     'WRDE_SYNTAX'.


File: vicare-libs.info,  Node: iconv,  Next: linux,  Prev: glibc,  Up: Top

6 Generic character set conversion
**********************************

The Iconv functions allow conversion among character set encodings,
*note Conversion: (libc)Generic Charset Conversion.  This API is
available only if, at package configuration time, it was enabled with
the '--with-iconv' option to the 'configure' script.

   The availability of the Iconv API can be tested at run-time with the
function 'vicare-built-with-iconv-enabled' from '(vicare)' (*note
vicare-built-with-iconv-enabled: (vicare-scheme)iklib config.), and at
expand-time with the clause 'iconv-enabled' of 'cond-expand' from SRFI-0
(*note iconv-enabled: srfi cond-expand vicare.).

* Menu:

* iconv set::                   Encoding enumeration sets.
* iconv conv::                  Conversion functions.


File: vicare-libs.info,  Node: iconv set,  Next: iconv conv,  Up: iconv

6.1 Encoding enumeration sets
=============================

The following bindings are exported by the '(vicare iconv)' library.

 -- Enumeration Type: enum-iconv-encoding
     Enumeration type for the symbols describing supported Iconv
     encodings.  All the encoding symbols are included with the
     exception of '850', '862' and '866' (because they are numbers)
     which are aliases for 'CP850', 'CP862' and 'CP866'.

     Additionally 'TRANSLIT' and 'IGNORE' are included to allow the
     specification of the corresponding modes for 'iconv!'.

 -- Syntax: iconv-encoding ?SYMBOL ...
     Evaluate to an enumeration set holding symbols from the
     'enum-iconv-encoding' enumeration.  It should be used to compose
     sets with a single encoding symbol and optionally none, one or both
     the symbols 'TRANSLIT' and 'IGNORE'.

     Examples:

          (iconv-encoding ISO8859-4)
          (iconv-encoding UTF-16BE IGNORE)
          (iconv-encoding UCS-4 TRANSLIT IGNORE)

 -- Constant: iconv-encoding-universe
     Enumeration set holding all the symbols in the
     'enum-iconv-encoding' enumeration.

 -- Function: iconv-encoding-aliases? SET1 SET2
     Return true if the encodings specified by the enumeration sets SET1
     and SET2 are aliases for the same encoding.  This predicate does
     *not* take into account the 'TRANSLIT' and 'IGNORE' symbols.

 -- Function: iconv-encoding=? SET1 SET2
     Return true if the encodings specified by the enumeration sets SET1
     and SET2 are aliases for the same encoding, taking into account the
     'TRANSLIT' and 'IGNORE' symbols.


File: vicare-libs.info,  Node: iconv conv,  Prev: iconv set,  Up: iconv

6.2 Conversion functions
========================

The basics of the conversion are as follows:

     #!r6rs
     (import (vicare)
       (prefix (vicare iconv) iconv.))

     (let* ((handle    (iconv.iconv-open
                         (iconv.iconv-encoding UTF-16BE) ;from
                         (iconv.iconv-encoding UTF-8)))  ;to
            (in.bv     (string->utf16 "ciao hello salut"
                         (endianness big)))
            (out.bv    (make-bytevector 16)))
       (let-values (((in.start out.start)
                    (iconv.iconv! handle in.bv 0 #f out.bv 0 #f)))
         (utf8->string out.bv)))
     => "ciao hello salut"

   The following bindings are exported by the '(vicare iconv)' library.

 -- Function: iconv-open FROM TO
     Build and return a new conversion context object for the specified
     encodings.  FROM and TO must be enumeration sets of type
     'enum-iconv-encoding'.  The returned handle must be finalised with
     'iconv-close'; this operation is automatically performed when the
     handle is garbage collected.

          *NOTE* Beware of the order of the arguments!  An error may be
          difficult to detect.

 -- Function: iconv? OBJ
     Return true if OBJ is an Iconv context object.  Context objects are
     disjoint from the other Scheme objects.

 -- Function: iconv-closed? CONTEXT
     Return '#t' if CONTEXT is an Iconv context already closed; return
     '#f' otherwise.

 -- Function: iconv-close CONTEXT
     Close the conversion CONTEXT releasing all the associated
     resources.  Applying this function multiple times to the same
     CONTEXT object is safe: the first time the context is finalised,
     the subsequent times nothing happens.

 -- Function: iconv! CONTEXT IN IN.START IN.PAST OUT OUT.START OUT.PAST
     Convert a range of bytes from the bytevector IN and store the
     result into a range of bytes in the bytevector OUT, according to
     the context specified by CONTEXT.

     IN.START is a fixnum representing the input inclusive start index;
     IN.PAST is a fixnum representing the input exclusive end index;
     OUT.START is a fixnum representing the output inclusive start
     index; OUT.PAST is a fixnum representing the output exclusive end
     index.  They must be such that:

          0 <= IN.START  <= IN.PAST  <= length(IN)
          0 <= OUT.START <= OUT.PAST <= length(OUT)

     As special cases: if IN.PAST is false, the input past index is the
     length of IN; if OUT.PAST is false, the output past index is the
     length of OUT.

     If the operation is successful return two values:

       1. A fixnum representing the index of the first byte in IN that
          was not consumed.  If all the input range was processed: this
          value equals IN.PAST.

       2. A fixnum representing the index of the first byte in OUT that
          was not filled with output data.  If all the output range was
          filled with output: this value equals OUT.PAST.

     If an error occurs raise an exception.

          *NOTE* Beware of the order of the arguments!  An error may be
          difficult to detect.


File: vicare-libs.info,  Node: linux,  Next: args,  Prev: iconv,  Up: Top

7 The GNU+Linux interface
*************************

The functions described in this chapter are exported by the library
'(vicare linux)'.  The API attempts to create a one-to-one Scheme
functions mapping towards Linux functions, keeping the same semantics as
much as possible; the platform's own documentation is relevant at the
Scheme level.

     *NOTE* These bindings are included and installed by default and
     they can be excluded at compile time by giving the option
     '--disable-linux' to the 'configure' stript.

   All the constants needed to use the interface are available as
identifier syntaxes exported by the '(vicare platform constants)'
library; if a constant value is not exported, file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to '#f'.

   The library '(vicare platform features)' exports one identifier
syntax for each 'HAVE_' symbol defined by Vicare 'configure' script,
expanding to '#t' or '#f'.

   For a list of Linux-specific system calls, see the 'syscalls(2)'
manual page.

   On non-Linux platforms we must avoid calling these functions, else
the behaviour is undefined.

   The availability of the Linux API can be tested at run-time with the
function 'vicare-built-with-linux-enabled' from '(vicare)' (*note
vicare-built-with-linux-enabled: (vicare-scheme)iklib config.), and at
expand-time with the clause 'linux-enabled' of 'cond-expand' from SRFI-0
(*note linux-enabled: srfi cond-expand vicare.).

* Menu:

* linux cond-expand::           Feature-based expansion.
* linux env::                   Operating system environment variables.
* linux status::                Process termination status.
* linux resources::             Resources usage and limits.
* linux epoll::                 Polling for events on file descriptors.
* linux signalfd::              Accepting signals through
                                file descriptors.
* linux timerfd::               Timer expiration handling through
                                file descriptors.
* linux inotify::               Monitoring file system events.
* linux daemonisation::         Turning a process into a daemon.
* linux ether::                 Ethernet address manipulation routines.


File: vicare-libs.info,  Node: linux cond-expand,  Next: linux env,  Up: linux

7.1 Feature-based expansion
===========================

 -- Syntax: cond-expand (?FEATURE-REQUIREMENT ?BODY0 ?BODY ...) ...
     Process the given clauses in left-to-right order and expand to the
     sequence of ?BODY forms from the first clause for which the
     ?FEATURE-REQUIREMENT is satisfied.

     This syntax supports all the features defined by 'cond-expand' from
     SRFI-0 (*note Features supported by Vicare: srfi cond-expand
     vicare.), and in addition it supports a feature for each system
     function exported by '(vicare linux)'; such features use the
     identifier exported by the library as feature requirement.

     As example, if we want to run code whether or not 'waitid' is
     implemented we write the following:

          (import (vicare)
            (prefix (vicare linux) lx.))

          (lx.cond-expand
            (lx.waitid
             (do-something))
            (else
             (do-something-else)))


File: vicare-libs.info,  Node: linux env,  Next: linux status,  Prev: linux cond-expand,  Up: linux

7.2 Operating system environment variables
==========================================

The following bindings are exported by the '(vicare linux)' library.

 -- Function: clearenv
     Interface to the C function 'clearenv()', *note clearenv:
     (libc)Environment Access.  Remove all the entries from the
     environment.  Return unspecified values.


File: vicare-libs.info,  Node: linux status,  Next: linux resources,  Prev: linux env,  Up: linux

7.3 Process termination status
==============================

The following bindings are exported by the '(vicare linux)' library.

 -- Function: waitid IDTYPE ID OPTIONS
     Interface to the Linux specific C function 'waitid()', see the
     'waitid()' manual page for details.  Wait for the termination of
     one or more child processes with finer control of 'waitpid'.  All
     the arguments must be fixnums.  If successful: return an instance
     of structure 'struct-siginfo_t', else raise an exception.

 -- Struct: struct-siginfo_t
     Data structure used by 'waitid' to report its result; it has the
     following fields:

          si_pid si_uid si_signo si_status si_code

     See the 'waitid()' manual page for details.

 -- Function: make-struct-siginfo_t PID UID SIGNO STATUS CODE
 -- Function: struct-siginfo_t? OBJ
 -- Function: struct-siginfo_t-si_pid
 -- Function: struct-siginfo_t-si_uid
 -- Function: struct-siginfo_t-si_signo
 -- Function: struct-siginfo_t-si_status
 -- Function: struct-siginfo_t-si_code
     Constructor, predicate and field accessors for structures of type
     'struct-siginfo_t'.

   The following functions accept as argument a fixnum representing the
process termination status, for example the return value of 'system()'
or the status acquired by 'waitpid()'.

 -- Function: WIFCONTINUED STATUS
     Interface to the Linux specific C macro 'WIFCONTINUED()'.  Return
     true if the process was resumed by delivery of 'SIGCONT'.


File: vicare-libs.info,  Node: linux resources,  Next: linux epoll,  Prev: linux status,  Up: linux

7.4 Resources usage and limits
==============================

The following bindings are exported by '(vicare posix)' and reexported
by '(vicare linux)'.

     make-struct-rlimit      struct-rlimit?
     struct-rlimit-rlim_cur  set-struct-rlimit-rlim_cur!
     struct-rlimit-rlim_max  set-struct-rlimit-rlim_max!
     RLIM_INFINITY

 -- Function: prlimit PID RESOURCE
 -- Function: prlimit PID RESOURCE NEW-RLIM
 -- Function: prlimit PID RESOURCE NEW-RLIM OLD-RLIM
     Interface to the C function 'prlimit()', see the manual page
     'prlimit(2)'.  Get and/or set the resource limits of an arbitrary
     process; if successful return OLD-RLIM, else raise an exception.

     PID must be a fixnum representing the process identifier of the
     target process.  RESOURCE must be an exact integer representing the
     value of a 'RLIMIT_' constant.

     The optional NEW-RLIM must be '#f' or an instance of
     'struct-rlimit'; when '#f': no new value is set and the function
     only retrieves the current resources usage values; when a structure
     instance: its fields are used to set new resource usage limits.

     The optional OLD-RLIM must an instance of 'struct-rlimit': it is
     filled with the previous values for the resource usage limits and
     returned; when not given: a new instance is built, filled and
     returned.


File: vicare-libs.info,  Node: linux epoll,  Next: linux signalfd,  Prev: linux resources,  Up: linux

7.5 Polling for events on file descriptors
==========================================

For details on the API we should refer to the following manual pages:
'epoll(7)', 'epoll_create(2)', 'epoll_ctl(2)', 'epoll_wait(2)'.  The
following bindings are exported by the '(vicare linux)' library.

 -- Function: epoll-create
 -- Function: epoll-create SIZE
 -- Function: epoll-create1 FLAGS
     Interfaces to the C language functions 'epoll_create()' and
     'epoll_create1()'.  Open an epoll descriptor and return it as
     fixnum.  When SIZE is not used: it defaults to 16.  If an error
     occurs: raise an exception.

 -- Function: epoll-ctl EPFD OP FD
 -- Function: epoll-ctl EPFD OP FD EVENT
     Interface to the C language function 'epoll_ctl()'.  Control
     interface for an epoll descriptor.  Return unspecified values.  If
     an error occurs: raise an exception.

     EPFD is the return value of a previous call to 'epoll-create'.  OP
     is a fixnum representing an OR combination of flags:
     'EPOLL_CTL_ADD', 'EPOLL_CTL_MOD', 'EPOLL_CTL_DEL'.  FD is a fixnum
     representing the file descriptor subject of the action.  EVENT is a
     pointer object referencing a 'struct epoll_event'; when EVENT is
     '#f' or not used: it defaults to the 'NULL' pointer.

 -- Function: epoll-wait EPFD EVENT MAXEVENTS TIMEOUT-MS
     Interface to the C language function 'epoll_wait()'.  Wait for an
     I/O event on an epoll descriptor.  Return a fixnum representing the
     number of file descriptors ready for the requested events; the
     return value is zero if no file descriptors are ready.  If an error
     occurs: raise an exception.

     EPFD is the return value of a previous call to 'epoll-create'.
     EVENT is a poiner object referencing an array of 'struct
     epoll_event' holding MAXEVENTS entries; MAXEVENTS is a non-negative
     fixnum.  TIMEOUT-MS is an exact integer in the range of a C
     language 'int', it represents a timeout time in milliseconds; when
     set to '-1' causes the call to block until at least one file
     descriptor is ready.

   To allow for faster operations, the 'struct epoll_event' instances
handled by the epoll functions are meant to be allocated on raw memory.

 -- Function: epoll-event-alloc NUMBER-OF-ENTRIES
     Allocate with 'malloc()' an array of 'struct epoll_event' capable
     of holding NUMBER-OF-ENTRIES structures.  If successful return a
     pointer object, else raise an exception.

 -- Function: epoll-event-size
     Return the number of bytes needed to hold an instance of 'struct
     epoll_event'.

 -- Function: epoll-event-set-events! EVENTS-ARRAY INDEX NEW-VALUE
 -- Function: epoll-event-ref-events EVENTS-ARRAY INDEX
     Mutator and accessor for the field 'events' of the 'struct
     epoll_event' entry at INDEX.

 -- Function: epoll-event-set-data-ptr! EVENTS-ARRAY INDEX NEW-VALUE
 -- Function: epoll-event-ref-data-ptr EVENTS-ARRAY INDEX
     Mutator and accessor for the field 'data.ptr' of the 'struct
     epoll_event' entry at INDEX.

 -- Function: epoll-event-set-data-fd! EVENTS-ARRAY INDEX NEW-VALUE
 -- Function: epoll-event-ref-data-fd EVENTS-ARRAY INDEX
     Mutator and accessor for the field 'data.fd' of the 'struct
     epoll_event' entry at INDEX.

 -- Function: epoll-event-set-data-u32! EVENTS-ARRAY INDEX NEW-VALUE
 -- Function: epoll-event-ref-data-u32 EVENTS-ARRAY INDEX
     Mutator and accessor for the field 'data.u32' of the 'struct
     epoll_event' entry at INDEX.

 -- Function: epoll-event-set-data-u64! EVENTS-ARRAY INDEX NEW-VALUE
 -- Function: epoll-event-ref-data-u64 EVENTS-ARRAY INDEX
     Mutator and accessor for the field 'data.u4' of the 'struct
     epoll_event' entry at INDEX.

   Here is a meaningless example showing the mechanics of the epoll API:

     (import (vicare)
       (prefix (vicare linux)
               linux.)
       (prefix (vicare posix)
               px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (let-values (((in ou) (px.pipe)))
       (unwind-protect
           (let ((epfd (linux.epoll-create)))
             (unwind-protect
                 (let ((sizeof-struct (vector (linux.epoll-event-size))))
                   (with-local-storage sizeof-struct
                     (lambda (event)
                       (linux.epoll-event-set-events!  event 0 EPOLLIN)
                       (linux.epoll-event-set-data-fd! event 0 in)
                       (linux.epoll-ctl epfd EPOLL_CTL_ADD in event)))
                   (px.write ou '#vu8(1))
                   (with-local-storage sizeof-struct
                     (lambda (events)
                       (linux.epoll-wait epfd events 1 -1)
                       (linux.epoll-event-ref-data-fd events 0) => in
                       (linux.epoll-event-ref-events events 0)  => EPOLLIN
                       ))))
               (px.close epfd)))
         (px.close in)
         (px.close ou))


File: vicare-libs.info,  Node: linux signalfd,  Next: linux timerfd,  Prev: linux epoll,  Up: linux

7.6 Accepting signals through file descriptors
==============================================

The 'signalfd' API transforms interprocess signals into file descriptor
events, this way we can code event loops using 'select' or 'epoll' and a
uniform interface for signal and input/output events.  For the full
documentation see the 'signalfd(2)' manual page.  The following bindings
are exported by the '(vicare linux)' library.

 -- Function: signalfd FD MASK FLAGS
     Interface to the C function 'signalfd()'.  Create a file descriptor
     that can be used to accept interprocess signals.  If successful
     return a fixnum representing the file descriptor, else raise an
     exception.

     FD can be either a fixnum representing the file descriptor or '-1'
     to request a new, unspecified, file descriptor; if FD is the return
     value of a previous call to 'signalfd': this call replaces the
     signal set previously specified.

     MASK must be a Scheme vector of fixnums representing the signal
     numbers to be accepted.  Notice that these signals should have been
     blocked.

     FLAGS can be the fixnum zero or an OR combination ('fxior') of the
     constants: 'SFD_CLOEXEC', 'SFD_NONBLOCK'.

 -- Function: read-signalfd-siginfo FD
     Attempt to read from the file descriptor FD a single instance of
     'struct signalfd_siginfo': if successful return the result as an
     instance of 'struct-signalfd-siginfo'; if no signal is pending, and
     FD is non-blocking, return '#f'; if an error occurs raise an
     exception.

 -- Struct Type: struct-signalfd-siginfo
     Structure type mirroring the C language 'struct signalfd_siginfo'.
     It has the following fields:

          ssi_signo       ssi_errno       ssi_code
          ssi_pid         ssi_uid         ssi_fd
          ssi_tid         ssi_band        ssi_overrun
          ssi_trapno      ssi_status      ssi_int
          ssi_ptr         ssi_utime       ssi_stime
          ssi_addr

 -- make-struct-signalfd-siginfo: SIGNO ERRNO CODE PID UID FD TID BAND
          OVERRUN TRAPNO STATUS INT PTR UTIME STIME ADDR
     Build and return a new instance of 'struct-signalfd-siginfo'.

 -- Function: struct-signalfd-siginfo? OBJ
     Return '#t' if OBJ is an instance of 'struct-signalfd-siginfo',
     else return '#f'.

 -- Function: struct-signalfd-siginfo-ssi_signo INFO
 -- Function: struct-signalfd-siginfo-ssi_errno INFO
 -- Function: struct-signalfd-siginfo-ssi_code INFO
 -- Function: struct-signalfd-siginfo-ssi_pid INFO
 -- Function: struct-signalfd-siginfo-ssi_uid INFO
 -- Function: struct-signalfd-siginfo-ssi_fd INFO
 -- Function: struct-signalfd-siginfo-ssi_tid INFO
 -- Function: struct-signalfd-siginfo-ssi_band INFO
 -- Function: struct-signalfd-siginfo-ssi_overrun INFO
 -- Function: struct-signalfd-siginfo-ssi_trapno INFO
 -- Function: struct-signalfd-siginfo-ssi_status INFO
 -- Function: struct-signalfd-siginfo-ssi_int INFO
 -- Function: struct-signalfd-siginfo-ssi_ptr INFO
 -- Function: struct-signalfd-siginfo-ssi_utime INFO
 -- Function: struct-signalfd-siginfo-ssi_stime INFO
 -- Function: struct-signalfd-siginfo-ssi_addr INFO
     Accessors for the fields of a 'struct-signalfd-siginfo'.

   In the following examples we use 'signal-bub-init', from '(vicare
posix)', to block all the signals.  Let's say no signal is pending:

     #!r6rs
     (import (vicare)
       (prefix (vicare linux) lx.)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (px.signal-bub-init)
     (let* ((mask  (vector SIGUSR1 SIGUSR2)
            (flags (fxior SFD_CLOEXEC SFD_NONBLOCK)))
            (fd    (lx.signalfd -1 mask flags)))
       (lx.read-signalfd-siginfo fd))
     => #f

now we raise a single signal:

     #!r6rs
     (import (vicare)
       (prefix (vicare linux) lx.)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (px.signal-bub-init)
     (let* ((mask  (vector SIGUSR1 SIGUSR2)
            (flags (fxior SFD_CLOEXEC SFD_NONBLOCK)))
            (fd    (lx.signalfd -1 mask flags)))
       (px.raise SIGUSR1)
       (let ((info (lx.read-signalfd-siginfo fd))
             (done (lx.read-signalfd-siginfo fd)))

         (lx.struct-signalfd-siginfo-ssi_signo info)
         => SIGUSR1

         done))
     => #f

now we raise two signals:

     #!r6rs
     (import (vicare)
       (prefix (vicare linux) lx.)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (px.signal-bub-init)
     (let* ((mask  (vector SIGUSR1 SIGUSR2)
            (flags (fxior SFD_CLOEXEC SFD_NONBLOCK)))
            (fd    (lx.signalfd -1 mask flags)))
       (px.raise SIGUSR1)
       (px.raise SIGUSR2)
       (let ((info1 (lx.read-signalfd-siginfo fd))
             (info2 (lx.read-signalfd-siginfo fd))
             (done  (lx.read-signalfd-siginfo fd)))
         (lx.struct-signalfd-siginfo-ssi_signo info1)
         => SIGUSR1

         (lx.struct-signalfd-siginfo-ssi_signo info2)
         => SIGUSR2

         done))
     => #f


File: vicare-libs.info,  Node: linux timerfd,  Next: linux inotify,  Prev: linux signalfd,  Up: linux

7.7 Timer expiration handling through file descriptors
======================================================

The 'timerfd' API transforms timer expiration events into file
descriptor events, this way we can code event loops using 'select' or
'epoll' and a uniform interface for timer and input/output events.  For
the full documentation see the following manual pages:
'timerfd_create(2)', 'timerfd_settime(2)', 'timerfd_gettime(2)'.

* Menu:

* linux timerfd intro::         Introduction to the 'timerfd' API.
* linux timerfd api::           The 'timerfd' API.
* linux timerfd examples::      Usage examples of the 'timerfd' API.


File: vicare-libs.info,  Node: linux timerfd intro,  Next: linux timerfd api,  Up: linux timerfd

7.7.1 Introduction to the 'timerfd' API
---------------------------------------

The 'timerfd' API allows the definition of time-periodic events by
specification of two time intervals:

  1. Initial expiration: how much time before the first event.

  2. Period: how much time between two time-adjacent events.

         time before the
         first event       period      period      period
        |               |           |           |           |
     ---+---------------+-----------+-----------+-----------+----
        ^               ^           ^           ^           ^
       now          1st event   2nd event   3rd event   4th event

   Each timer can be started, stopped, reconfigured and queried for how
much time until the next event.


File: vicare-libs.info,  Node: linux timerfd api,  Next: linux timerfd examples,  Prev: linux timerfd intro,  Up: linux timerfd

7.7.2 The 'timerfd' API
-----------------------

The following bindings are exported by '(vicare posix)' and reexported
by '(vicare linux)':

     make-struct-timespec           struct-timespec?
     struct-timespec-tv_sec         struct-timespec-tv_nsec
     set-struct-timespec-tv_sec!    set-struct-timespec-tv_nsec!

     make-struct-itimerspec         struct-itimerspec?
     struct-itimerspec-it_interval  struct-itimerspec-it_value
     set-struct-itimerspec-it_interval!
     set-struct-itimerspec-it_value!

   The following bindings are exported by the '(vicare linux)' library.

 -- Function: timerfd-create CLOCKID
 -- Function: timerfd-create CLOCKID FLAGS
     Interface to the C function 'timerfd_create()'.  Create a new timer
     object and a file descriptor that refers to that timer; if
     successful return a fixnum representing the file descriptor, else
     raise an exception.

     CLOCKID must be one among: 'CLOCK_REALTIME', 'CLOCK_MONOTONIC'.
     FLAGS can be either the fixnum zero or a bitwise OR combination of:
     'TFD_CLOEXEC', 'TFD_NONBLOCK'; when not given: it defaults to the
     fixnum zero.

 -- Function: timerfd-settime FD FLAGS NEW
 -- Function: timerfd-settime FD FLAGS NEW OLD
     Interface to the C function 'timerfd_settime()'.  Start or stop the
     timer referred to by the file descriptor FD.  If successful return
     OLD or '#f' when OLD is not given; if an error occurs raise an
     exception.

     FLAGS can be either the fixnum zero or 'TFD_TIMER_ABSTIME'.  NEW
     must be a valid instance of 'struct-itimerspec', which is used to
     set the timer.  The optional OLD can be '#f' or a valid instance of
     'struct-itimerspec'; when given: it is filled with the old timer
     specification.

 -- Function: timerfd-gettime FD
 -- Function: timerfd-gettime FD CURR
     Interface to the C function 'timerfd_gettime()'.  Retrieve the
     current timer specification associated to the file descriptor FD.
     If successful return CURR or a newly built instance of
     'struct-itimerspec'; if an error occurs: raise an exception.

     The optional CURR must be a valid instance of 'struct-itimerspec',
     when not given a new instance of this structure type is internally
     built: it is filled with the current timer specification.

 -- Function: timerfd-read FD
     Perform a 'read()' operation on FD, which must be a file descriptor
     associated to a timer.  The function behaves as follows:

        * If the operation is successful: return the number of timer
          expirations occurred since the timer was set or the last
          successful 'read()'.

        * if the operation fails with code 'EWOULDBLOCK': the return
          value is zero.

        * Else an exception is raised.


File: vicare-libs.info,  Node: linux timerfd examples,  Prev: linux timerfd api,  Up: linux timerfd

7.7.3 Usage examples of the 'timerfd' API
-----------------------------------------

The following program watches a timer as time goes by:

     #!r6rs
     (import (vicare)
       (vicare platform constants)
       (only (vicare language-extensions syntaxes)
             unwind-protect)
       (prefix (vicare posix) px.)
       (prefix (vicare linux) lx.))

     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define (%print-remaining-time fd)
       (pretty-print (lx.struct-itimerspec-it_value
                      (lx.timerfd-gettime fd))))

     (define (%sleep-one-second)
       (px.nanosleep 1 0))

     (let ((fd (lx.timerfd-create CLOCK_REALTIME)))
       (unwind-protect
           (let ( ;; one event every 3 seconds
                 (period (lx.make-struct-timespec 3 0))
                 ;; the first event after 1 nanosecond
                 (offset (lx.make-struct-timespec 0 1)))
             (lx.timerfd-settime fd 0
                (lx.make-struct-itimerspec period offset))
             (do ((i 0 (fx+ 1 i)))
                 ((fx= i 6))
               (%print-remaining-time fd)
               (%sleep-one-second))
             #f)
         (px.close fd)))

the output is:

     #["struct-timespec" tv_sec=2 tv_nsec=999911022]
     #["struct-timespec" tv_sec=1 tv_nsec=999307638]
     #["struct-timespec" tv_sec=0 tv_nsec=998303788]
     #["struct-timespec" tv_sec=2 tv_nsec=997338092]
     #["struct-timespec" tv_sec=1 tv_nsec=996393490]
     #["struct-timespec" tv_sec=0 tv_nsec=995418649]

   The following example prints the number of timer expirations:

     #!r6rs
     (import (vicare)
       (vicare platform constants)
       (only (vicare language-extensions syntaxes)
             unwind-protect)
       (prefix (vicare posix) px.)
       (prefix (vicare linux) lx.))

     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))
     (define fd
       (lx.timerfd-create CLOCK_REALTIME TFD_NONBLOCK))
     (unwind-protect
         (begin
           ;; 0.3 seconds = 300 ms = 300,000 us = 300,000,000 ns
           (define nsecs  300000000)
     ;;;                 9876543210
           (lx.timerfd-settime fd 0
             (lx.make-struct-itimerspec
              ;; one event every 0.3 seconds
              (lx.make-struct-timespec 0 nsecs)
              ;; the first event after 1 nanosecond
              (lx.make-struct-timespec 0 1)))
           (printf "right after starting timer: ~a\n"
             (lx.timerfd-read fd))
           (px.nanosleep 1 0)
           (printf "after 1 second: ~a\n"
             (lx.timerfd-read fd))
           (px.nanosleep 0 nsecs)
           (printf "after 0.3 seconds: ~a\n"
             (lx.timerfd-read fd)))
       (px.close fd))

the output is:

     right after starting timer: 1
     after 1 second: 3
     after 0.3 seconds: 1

we notice that right after starting the timer: the number of expirations
is 1 because the timer starts 1 nanosecond after the call to
'timerfd-settime', which is almost immediately.


File: vicare-libs.info,  Node: linux inotify,  Next: linux daemonisation,  Prev: linux timerfd,  Up: linux

7.8 Monitoring file system events
=================================

The 'inotify' API allows us to monitor file system events; for an
overview of the API we must refer to the 'inotify(7)' manual page.

 -- Struct Type: struct-inotify-event
     Scheme level representation of the C language type 'struct
     inotify-event', see the 'inotify(7)' manual page.  It has the
     following fields:

     'wd'
          An exact integer in the range of the C language type 'int'.

     'mask'
          An exact integer in the range of the C language type
          'uint32_t'.

     'cookie'
          An exact integer in the range of the C language type
          'uint32_t'.

     'len'
          An exact integer in the range of the C language type
          'uint32_t'.  Zero or the number of bytes in the pathname
          represented by the 'name' field.

     'name'
          A bytevector representing a file system pathname or '#f'.

 -- Function: make-struct-inotify-event
 -- Function: make-struct-inotify-event WD MASK COOKIE LEN NAME
     Build and return a new instance of 'struct-inotify-event'.  When no
     arguments are given: all the fields are set to the fixnum zero, but
     the field NAME which is set to '#f'.

 -- Function: struct-inotify-event? OBJ
     Return '#t' if OBJ is an instance of 'struct-inotify-event'.

 -- Function: struct-inotify-event-wd IEV
 -- Function: struct-inotify-event-mask IEV
 -- Function: struct-inotify-event-cookie IEV
 -- Function: struct-inotify-event-len IEV
 -- Function: struct-inotify-event-name IEV
     Accessors for the fields of 'struct-inotify-event'.

 -- Function: set-struct-inotify-event-wd! IEV VALUE
 -- Function: set-struct-inotify-event-mask! IEV VALUE
 -- Function: set-struct-inotify-event-cookie! IEV VALUE
 -- Function: set-struct-inotify-event-len! IEV VALUE
 -- Function: set-struct-inotify-event-name! IEV VALUE
     Mutators for the fields of 'struct-inotify-event'.

 -- Function: inotify-init
     Interface to the C function 'inotify_init()', see the manual page
     'inotify_init(2)'.  Initialise a new 'inotify' instance; if
     successful return a file descriptor associated to a new event
     queue, else raise an exception.

 -- Function: inotify-init1 FLAGS
     Interface to the C function 'inotify_init1()', see the manual page
     'inotify_init1(2)'.  Initialise a new 'inotify' instance; if
     successful return a file descriptor associated to a new event
     queue, else raise an exception.

     FLAGS must be a fixnum representing the bitwise inclusive OR
     combination of 'IN_NONBLOCK' and 'IN_CLOEXEC'.

 -- Function: inotify-add-watch FD PATHNAME MASK
     Interface to the C function 'inotify_add_watch()', see the manual
     page 'inotify_add_watch(2)'.  Add a watch to an initialised
     'inotify' instance; if successful return an exact integer
     representing watch descriptor, else raise an exception.

     FD must be a finxum representing the file descriptor associated to
     the 'inotify' instance.  PATHNAME must be a Scheme string or
     bytevector representing the pathname to watch.  MASK must be an
     exact integer in the range of the C language type 'uint32_t'
     representing the watch mask.

 -- Function: inotify-rm-watch FD WD
     Interface to the C function 'inotify_rm_watch()', see the manual
     page 'inotify_rm_watch(2)'.  Remove an existing watch from an
     'inotify' instance; if successful return unspecified values, else
     raise an exception.

     FD must be a fixnum representing the file descriptor associated to
     the 'inotify' instance.  WD must be an exact integer in the range
     of the C language type 'int' representing the watch descriptor.

   The following meaningless example shows how to watch for a
modification event on a file:

     #!r6rs
     (import (vicare)
       (prefix (vicare linux) lx.)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (let* ((infd     (lx.inotify-init))
            (pathname "inotify.test")
            (fd       (px.open pathname
                               (fxior O_CREAT O_EXCL O_RDWR)
                               (fxior S_IRUSR S_IWUSR))))
       (unwind-protect
            (let ((wd (lx.inotify-add-watch infd pathname
                                            IN_MODIFY)))
              (unwind-protect
                   (begin
                     (px.write fd #vu8(1 2 3))
                     ;; let the event happen
                     (px.select-fd infd 1 0)
                     (let ((ev (lx.inotify-read infd)))
                       (lx.struct-inotify-event? ev)
                       => #t
                       (= wd (lx.struct-inotify-event-wd ev))
                       => #t
                       (lx.struct-inotify-event-len ev)
                       => 0
                       (lx.struct-inotify-event-name ev)
                       => #f
                       ))
                   (lx.inotify-rm-watch infd wd)))
          (px.close fd)
          (delete-file pathname)))


File: vicare-libs.info,  Node: linux daemonisation,  Next: linux ether,  Prev: linux inotify,  Up: linux

7.9 Turning a process into a daemon
===================================

The following bindings are exported by the library '(vicare linux)'.

 -- Function: daemon NOCHDIR NOCLOSE
     Interface to the C language function 'daemon()', *note daemon:
     (*manpages*)daemon.  Turn the current process into a daemon.  If an
     error occurs raise an exception.

     If NOCHDIR is '#f': change the current working directory to the
     root directory.

     If NOCLOSE is '#f': redirect 'stdin', 'stdout' and 'stderr' to
     '/dev/null'.


File: vicare-libs.info,  Node: linux ether,  Prev: linux daemonisation,  Up: linux

7.10 Ethernet address manipulation routines
===========================================

Some of the following functions act upon the system file '/etc/ethers';
such file may not be present in all the GNU+Linux installations, but it
is quite easy to create one; *note Ethernet address to IP number
database: (*manpages*)ethers(5).  Notice that the address of an Ethernet
interface can be found in the output of the command:

     $ /usr/sbin/ip address

   The following bindings are exported by the library '(vicare linux)'.

 -- Function: ether-ntoa ETHER-ADDR-BV
 -- Function: ether-ntoa-r ETHER-ADDR-BV
     Interfaces to the C functions 'ether_ntoa()' and 'ether_ntoa_r()',
     *note ether_ntoa: (*manpages*)ether_aton.  Convert a bytevector
     holding a 'struct ether_addr' into the string representation of the
     address.  If successful return a bytevector holding the ASCIIZ
     string representing the address; else raise an exception.

 -- Function: ether-ntoa/string ETHER-ADDR-BV
 -- Function: ether-ntoa-r/string ETHER-ADDR-BV
     Like 'ether-ntoa' and 'ether-ntoa-r', but return a Scheme string.

          (import (vicare)
            (prefix (vicare linux) lx.))

          (define-constant eth0.str "20:6a:8a:f6:b5:ed")

          (lx.ether-ntoa/string (lx.ether-aton eth0.str #f))
          => "20:6a:8a:f6:b5:ed"

 -- Function: ether-aton ADDR.STR ADDR.LEN
 -- Function: ether-aton-r ADDR.STR ADDR.LEN
     Interfaces to the C functions 'ether_aton()' and 'ether_aton_r()',
     *note ether_ntoa: (*manpages*)ether_aton.  Convert a string
     representing an Ethernet address into a 'struct ether_addr'.  If
     successful return a bytevector holding the C structure, otherwise
     raise an exception.

     The arguments ADDR.STR and ADDR.LEN must represent a generalised C
     ASCIIZ string, *note Introduction to generalised C strings:
     (vicare-libs)cbuffers strings.

 -- Function: ether-ntohost ETHER-ADDR-BV
     Interface to the C function 'ether_ntohost()', *note ether_ntohost:
     (*manpages*)ether_aton.  Convert a bytevector holding a 'struct
     ether_addr' into the corresponding hostname string found in the
     file '/etc/ethers'.  If successful return a bytevector holding the
     ASCIIZ string representing the address; else raise an exception.

 -- Function: ether-ntohost/string ETHER-ADDR-BV
     Like 'ether-ntohost', but return a Scheme string.

          (import (vicare)
            (prefix (vicare linux) lx.))

          (define-constant eth0.str "20:6a:8a:f6:b5:ed")

          ;;Assuming "/etc/ethers" contains:
          ;;
          ;; 20:6a:8a:f6:b5:ed	localhost
          ;;
          (lx.ether-ntohost/string (lx.ether-aton eth0.str #f))
          => "localhost"

 -- Function: ether-hostton HOSTNAME.STR HOSTNAME.LEN
     Interface to the C function 'ether_hostton()', *note ether_hostton:
     (*manpages*)ether_aton.  Convert a string representing a hostname
     address into the corresponding address in found in the file
     '/etc/ethers', represented as 'struct ether_addr'.  If successful
     return a bytevector holding the C structure, otherwise raise an
     exception.

     The arguments HOSTNAME.STR and HOSTNAME.LEN must represent a
     generalised C ASCIIZ string, *note Introduction to generalised C
     strings: (vicare-libs)cbuffers strings.

          (import (vicare)
            (prefix (vicare linux) lx.))

          ;;Assuming "/etc/ethers" contains:
          ;;
          ;; 20:6a:8a:f6:b5:ed	localhost
          ;;
          (lx.ether-ntoa/string (lx.ether-hostton "localhost" #f))
          => "20:6a:8a:f6:b5:ed"

 -- Function: ether-line LINE.STR LINE.LEN
     Interface to the C function 'ether_line()', *note ether_line:
     (*manpages*)ether_aton.  Parse a string representing a line in the
     format of the file '/etc/ethers'.  If successful return 2 values: a
     bytevector representing a 'struct ether_addr' and a bytevector
     representing the hostname as ASCIIZ string; else raise an
     exception.

     The arguments LINE.STR and LINE.LEN must represent a generalised C
     ASCIIZ string, *note Introduction to generalised C strings:
     (vicare-libs)cbuffers strings.

 -- Function: ether-line/string LINE.STR LINE.LEN
     Like 'ether-line', but, when successful, return a Scheme string as
     second value.

          (import (vicare)
            (prefix (vicare linux) lx.))

          (receive (addr hostname)
              (lx.ether-line/string "20:6a:8a:f6:b5:ed localhost" #f)
            (list (lx.ether-ntoa/string addr) hostname))
          => ("20:6a:8a:f6:b5:ed" "localhost")


File: vicare-libs.info,  Node: args,  Next: cbuffers,  Prev: linux,  Up: Top

8 Optional function arguments validation
****************************************

The library '(vicare arguments validation)' provides bindings to macros
that extend the Scheme language implemented by '(vicare)' and '(rnrs)'.

* Menu:

* args config::                 Enabling or disabling arguments
                                validation.
* args definitions::            Defining arguments validation clauses.
* args using::                  Performing arguments validation.
* args forms::                  Optional validation forms.

* args predefined::             Predefined validation clauses.


File: vicare-libs.info,  Node: args config,  Next: args definitions,  Up: args

8.1 Enabling or disabling arguments validation
==============================================

Global arguments validation is enabled or disabled by setting to '#t' or
'#f' the 'arguments-validation' identifier syntax exported by '(vicare
platform configuration)', the default is '#t'; such value can be
configured as follows:

  1. Argument validation is *enabled* by setting to the string 'yes', or
     the string '1', the environment variable
     'VICARE_ARGUMENTS_VALIDATION'.

  2. Argument validation is *disabled* by setting to the string 'no', or
     the string '0', the environment variable
     'VICARE_ARGUMENTS_VALIDATION'.

  3. If the environment variable 'VICARE_ARGUMENTS_VALIDATION' is unset
     or set to some string different from 'yes', 'no', '1', '0':

        * Arguments validation is *enabled* if the
          '--enable-arguments-validation' option of the 'configure'
          script was used.

        * Arguments validation is *disabled* if the
          '--disable-arguments-validation' option of the 'configure'
          script was used.


File: vicare-libs.info,  Node: args definitions,  Next: args using,  Prev: args config,  Up: args

8.2 Defining argument validation clauses
========================================

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Macro: define-argument-validation (?NAME ?WHO ?ARG ...) ?PREDICATE
          ?ERROR-HANDLER
     Define a validation clause to be used along with the syntax
     'WITH-ARGUMENTS-VALIDATION'.  Example:

          (define-argument-validation (bytevector who bv)
            (bytevector? bv)
            (procedure-argument-violation who
              "expected a bytevector as argument"
              bv))

     We have to assume that the values ?ARG are evaluated multiple
     times.


File: vicare-libs.info,  Node: args using,  Next: args forms,  Prev: args definitions,  Up: args

8.3 Performing arguments validation
===================================

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Macro: with-arguments-validation (?WHO) ((?VALIDATOR ?ARG ...) ...)
          ?BODY0 . ?BODY
     If arguments validation is enabled: expand to code that validates
     the ?ARG expressions using to the ?VALIDATOR clause, then evaluate
     the ?BODY forms; if arguments validation is disabled: just evaluate
     the ?BODY forms.

     ?WHO must be an identifier used as argument when building a '&who'
     condition object.

     ?VALIDATOR must be one among:

        * An identifier previously used as name of validation clause by
          the 'define-argument-validation' macro.

        * The form '(or false ?VALIDATOR-ID)', where: 'or' is the
          identifier exported by '(vicare)'; 'false' is an identifier
          whose expression is the symbol 'false'; ?VALIDATOR-ID must be
          an identifier previously used as name of validation clause by
          the 'define-argument-validation' macro.

          When this form is used, the first clause argument is first
          tested alone: the clause succeeds if the first argument is
          '#f'; otherwise all the clause arguments are handed to the
          validation claused selected by ?VALIDATOR-ID.

        * The identifier 'void', exported by '(vicare)'; this is a
          special case for which no validation is generated: the ARG
          values are considered always valid; this is sometimes useful
          when using this macro in the expansion of another macro.

          *NOTE* In future a full logic expression may be possible as
          ?VALIDATOR argument.  At present only the special 'or' case is
          supported, with 'false' as first operand.

     Simple example:

          (define-argument-validation (fixnum who obj)
            (fixnum? obj)
            (procedure-argument-violation who
              "expected fixnum as argument"
              obj))

          (define-argument-validation (integer who obj)
            (integer? obj)
            (procedure-argument-violation who
              "expected integer as argument"
              obj))

          (with-arguments-validation (who)
               ((fixnum  X)
                (integer Y))
            (do-this)
            (do-that))

     multiple clauses are evaluated from first to last, so the above
     example is equivalent to:

          (with-arguments-validation (who)
               ((fixnum  X))
            (with-arguments-validation (who)
                 ((integer Y))
              (do-this)
              (do-that)))

     which is equivalent to something like:

          (if (fixnum? X)
              (if (integer? X)
                  (begin
                    (do-this)
                    (do-that))
                (procedure-argument-violation who
                  "expected integer as argument"
                  obj))
            (procedure-argument-violation who
              "expected fixnum as argument"
              obj))

 -- Macro: with-dangerous-arguments-validation (?WHO) ((?VALIDATOR ?ARG
          ...) ...) ?BODY0 . ?BODY
     Like 'with-arguments-validation', but the validation is always
     performed even when global arguments validation is disabled.


File: vicare-libs.info,  Node: args forms,  Next: args predefined,  Prev: args using,  Up: args

8.4 Optional validation forms
=============================

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Macro: arguments-validation-forms
 -- Macro: arguments-validation-forms ?BODY0 . ?BODY
     When used without arguments or arguments validation disabled:
     expand to '(values)'; else expand to:

          (begin ?BODY0 . ?BODY)


File: vicare-libs.info,  Node: args predefined,  Prev: args forms,  Up: args

8.5 Predefined validation clauses
=================================

* Menu:

* args predefined pairs::          Validating pairs and lists.
* args predefined booleans::       Validating booleans.
* args predefined numbers::        Validating numbers.
* args predefined fixnums::        Validating fixnums.
* args predefined exact integers:: Validating exact integers.
* args predefined keywords::       Validating keywords.
* args predefined promises::       Validating promises.
* args predefined bits::           Validating bit-sized integers.
* args predefined signed int::     Validating C language 'int' values.
* args predefined clang::          Validating C language values.
* args predefined chars::          Validating characters.
* args predefined strings::        Validating string and
                                   related arguments.
* args predefined vectors::        Validating vector and
                                   related arguments.
* args predefined bytevectors::    Validating bytevector and related
                                   arguments.
* args predefined pathnames::      String and bytevector pathnames.
* args predefined symbols::        Validating symbols.
* args predefined enum-sets::      Validating enum-sets.
* args predefined pointers::       Validating pointers.
* args predefined memory-blocks::  Validating 'memory-block' values.
* args predefined flonums::        Validating flonums.
* args predefined bignums::        Validating bignums.
* args predefined ratnums::        Validating ratnums.
* args predefined reals::          Validating reals.
* args predefined compnums::       Validating compnums.
* args predefined cflonums::       Validating cflonums.
* args predefined complexes::      Validating complexes.
* args predefined ports::          Validating input/output ports.
* args predefined transcoders::    Validating port transcoders.
* args predefined procedures::     Validating procedures.
* args predefined genstrings::     Validating generalised C string
                                   arguments.
* args predefined genbuffers::     Validating generalised C buffer
                                   arguments.
* args predefined time::           Time objects.
* args predefined identifier::     Identifier objects.


File: vicare-libs.info,  Node: args predefined pairs,  Next: args predefined booleans,  Up: args predefined

8.5.1 Validating pairs and lists
--------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: pair OBJ
     Succeed if OBJ satisfies the predicate 'pair?'.

 -- Validation Clause: list OBJ
     Succeed if OBJ satisfies the predicate 'list?'.


File: vicare-libs.info,  Node: args predefined booleans,  Next: args predefined numbers,  Prev: args predefined pairs,  Up: args predefined

8.5.2 Validating booleans
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: boolean OBJ
     Succeed if OBJ satisfies the predicate 'boolean?'.


File: vicare-libs.info,  Node: args predefined numbers,  Next: args predefined fixnums,  Prev: args predefined booleans,  Up: args predefined

8.5.3 Validating numbers
------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: number OBJ
     Succeed if OBJ satisfies the predicate 'number?'.


File: vicare-libs.info,  Node: args predefined fixnums,  Next: args predefined exact integers,  Prev: args predefined numbers,  Up: args predefined

8.5.4 Validating fixnums
------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: fixnum OBJ
     Succeed if OBJ satisfies the predicate 'fixnum?'.

 -- Validation Clause: fixnum/false OBJ
     Succeed if OBJ is '#f' or it satisfies the predicate 'fixnum?'.

 -- Validation Clause: positive-fixnum OBJ
 -- Validation Clause: negative-fixnum OBJ
     Succeed if OBJ satisfies the predicate 'fixnum?' and it is strictly
     positive or strictly negative.

 -- Validation Clause: non-positive-fixnum OBJ
 -- Validation Clause: non-positive-fixnum/false OBJ
     Succeed if OBJ satisfies the predicate 'fixnum?' and it is zero or
     positive.  The second clause accepts also '#f'.

 -- Validation Clause: non-negative-fixnum OBJ
 -- Validation Clause: non-negative-fixnum/false OBJ
     Succeed if OBJ satisfies the predicate 'fixnum?' and it is zero or
     negative.  The second clause accepts also '#f'.

 -- Validation Clause: fixnum-index OBJ
     Succeed if OBJ satisfies the predicate 'fixnum?' and it is zero or
     positive.

 -- Validation Clause: non-zero-fixnum OBJ
 -- Validation Clause: non-zero-fixnum/false OBJ
     Fails if OBJ satisfies the predicate 'fxzero?'.  The second clause
     accepts also '#f'.

 -- Validation Clause: fixnum-in-inclusive-range OBJ MIN MAX
 -- Validation Clause: fixnum-in-exclusive-range OBJ MIN MAX
     Succeed if OBJ satisfies the predicate 'fixnum?' and it is in the
     specified range.  MIN and MAX must be fixnums.

 -- Validation Clause: even-fixnum OBJ
 -- Validation Clause: odd-fixnum OBJ
     Succeed if OBJ satisfies the predicate 'fixnum?' and the predicate
     'fxeven?' or 'fxodd?'.


File: vicare-libs.info,  Node: args predefined exact integers,  Next: args predefined keywords,  Prev: args predefined fixnums,  Up: args predefined

8.5.5 Validating exact integers
-------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: exact-integer OBJ
     Succeed if OBJ satisfies the predicates 'integer?' and 'exact?'.

 -- Validation Clause: exact-integer/false OBJ
     Succeed if OBJ is '#f' or it satisfies the predicates 'integer?'
     and 'exact?'.

 -- Validation Clause: positive-exact-integer OBJ
 -- Validation Clause: negative-exact-integer OBJ
     Succeed if OBJ satisfies the predicates 'integer?' and 'exact?' and
     it is strictly positive or strictly negative.

 -- Validation Clause: non-positive-exact-integer OBJ
 -- Validation Clause: non-negative-exact-integer OBJ
     Succeed if OBJ satisfies the predicates 'integer?' and 'exact?' and
     it is strictly positive or strictly negative.

 -- Validation Clause: exact-integer-in-inclusive-range OBJ MIN MAX
 -- Validation Clause: exact-integer-in-exclusive-range OBJ MIN MAX
     Succeed if OBJ satisfies the predicates 'integer?' and 'exact?' and
     it is in the specified range.  MIN and MAX must be exact integers.

 -- Validation Clause: even-exact-integer OBJ
 -- Validation Clause: odd-exact-integer OBJ
     Succeed if OBJ satisfies the predicates 'integer?' and 'exact?' and
     the predicate 'even?' or 'odd?'.


File: vicare-libs.info,  Node: args predefined keywords,  Next: args predefined promises,  Prev: args predefined exact integers,  Up: args predefined

8.5.6 Validating keywords
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: keyword OBJ
     Succeed if OBJ is a keyword object: it satisfies the predicate
     'keyword?' exported by '(vicare)'.


File: vicare-libs.info,  Node: args predefined promises,  Next: args predefined bits,  Prev: args predefined keywords,  Up: args predefined

8.5.7 Validating promises
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: promise OBJ
     Succeed if OBJ is a promise object: it satisfies the predicate
     'promise?' exported by '(vicare)'.

 -- Validation Clause: false-or-promise OBJ
     Succeed if OBJ is '#f' or a promise object: it satisfies the
     predicate 'promise?' exported by '(vicare)'.


File: vicare-libs.info,  Node: args predefined bits,  Next: args predefined signed int,  Prev: args predefined promises,  Up: args predefined

8.5.8 Validating bit-sized integers
-----------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: octet OBJ
 -- Validation Clause: false-or-octet OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an octet [0, 255].

 -- Validation Clause: byte OBJ
 -- Validation Clause: false-or-byte OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an byte [-128, 127].

 -- Validation Clause: byte/octet OBJ
 -- Validation Clause: byte/octet/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an byte [-128, 127] or octet [0, 255].

 -- Validation Clause: word-u8 OBJ
 -- Validation Clause: word-u8/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an octet.

 -- Validation Clause: word-s8 OBJ
 -- Validation Clause: word-s8/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of a byte.

 -- Validation Clause: word-u16 OBJ
 -- Validation Clause: word-u16/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an unsigned 16-bit integer.

 -- Validation Clause: word-s16 OBJ
 -- Validation Clause: word-s16/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of a signed 16-bit integer.

 -- Validation Clause: word-u32 OBJ
 -- Validation Clause: word-u32/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an unsigned 32-bit integer.

 -- Validation Clause: word-s32 OBJ
 -- Validation Clause: word-s32/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of a signed 32-bit integer.

 -- Validation Clause: word-u64 OBJ
 -- Validation Clause: word-u64/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an unsigned 64-bit integer.

 -- Validation Clause: word-s64 OBJ
 -- Validation Clause: word-s64/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of a signed 64-bit integer.

 -- Validation Clause: word-u128 OBJ
 -- Validation Clause: word-u128/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an unsigned 128-bit integer.

 -- Validation Clause: word-s128 OBJ
 -- Validation Clause: word-s128/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of a signed 128-bit integer.

 -- Validation Clause: word-u256 OBJ
 -- Validation Clause: word-u256/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an unsigned 256-bit integer.

 -- Validation Clause: word-s256 OBJ
 -- Validation Clause: word-s256/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of a signed 256-bit integer.

 -- Validation Clause: machine-word OBJ
 -- Validation Clause: machine-word/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     fitting in the range of an unsigned machine word integer; a machine
     word is 32-bit or 64-bit integer.


File: vicare-libs.info,  Node: args predefined signed int,  Next: args predefined clang,  Prev: args predefined bits,  Up: args predefined

8.5.9 Validating C language 'int' values
----------------------------------------

Exact integers in the range of the C language type 'int' are used often
when interfacing with a foreign C language library; the library '(vicare
platform words)' provides the predicate 'signed-int?' to validated such
values; *note words predicates:: for details.

   The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: signed-int OBJ
     Succeed if OBJ satisfies the predicate 'signed-int?'.

 -- Validation Clause: signed-int/false OBJ
     Succeed if OBJ is '#f' or it satisfies the predicate 'signed-int?'.

 -- Validation Clause: positive-signed-int OBJ
 -- Validation Clause: negative-signed-int OBJ
     Succeed if OBJ satisfies the predicate 'signed-int?' and it is
     strictly positive or strictly negative.

 -- Validation Clause: non-positive-signed-int OBJ
 -- Validation Clause: non-negative-signed-int OBJ
     Succeed if OBJ satisfies the predicate 'signed-int?' and it is
     strictly positive or strictly negative.

 -- Validation Clause: signed-int-in-inclusive-range OBJ MIN MAX
 -- Validation Clause: signed-int-in-exclusive-range OBJ MIN MAX
     Succeed if OBJ satisfies the predicate 'signed-int?' and it is in
     the specified range.  MIN and MAX must be exact integers.

 -- Validation Clause: even-signed-int OBJ
 -- Validation Clause: odd-signed-int OBJ
     Succeed if OBJ satisfies the predicate 'signed-int?' and the
     predicate 'even?' or 'odd?'.


File: vicare-libs.info,  Node: args predefined clang,  Next: args predefined chars,  Prev: args predefined signed int,  Up: args predefined

8.5.10 Validating C language values
-----------------------------------

The library '(vicare platform words)' provides the predicates to
validate typical values used when interfacing with foreign C language
libraries; *note words predicates:: for details.

   The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: unsigned-char OBJ
 -- Validation Clause: unsigned-char/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'unsigned char'.

 -- Validation Clause: signed-char OBJ
 -- Validation Clause: signed-char/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'signed char'.

 -- Validation Clause: unsigned-short OBJ
 -- Validation Clause: unsigned-short/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'unsigned short int'.

 -- Validation Clause: signed-short OBJ
 -- Validation Clause: signed-short/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'signed short int'.

 -- Validation Clause: unsigned-int OBJ
 -- Validation Clause: unsigned-int/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'unsigned int'.

 -- Validation Clause: unsigned-long OBJ
 -- Validation Clause: unsigned-long/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'unsigned long'.

 -- Validation Clause: signed-long OBJ
 -- Validation Clause: signed-long/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'signed long'.

 -- Validation Clause: unsigned-long-long OBJ
 -- Validation Clause: unsigned-long-long/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'unsigned long long'.

 -- Validation Clause: signed-long-long OBJ
 -- Validation Clause: signed-long-long/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'signed long long'.

 -- Validation Clause: pointer-integer OBJ
 -- Validation Clause: pointer-integer/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'void *'.

 -- Validation Clause: size_t OBJ
 -- Validation Clause: size_t/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'size_t'.

 -- Validation Clause: ssize_t OBJ
 -- Validation Clause: ssize_t/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'ssize_t'.

 -- Validation Clause: off_t OBJ
 -- Validation Clause: off_t/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'off_t'.

 -- Validation Clause: ptrdiff_t OBJ
 -- Validation Clause: ptrdiff_t/false OBJ
     Succeed if OBJ is an exact integer, or '#f' for the second variant,
     in the range of a C language type 'ptrdiff_t'.


File: vicare-libs.info,  Node: args predefined chars,  Next: args predefined strings,  Prev: args predefined clang,  Up: args predefined

8.5.11 Validating characters
----------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: char OBJ
 -- Validation Clause: char/false OBJ
     Succeed if OBJ is a character.  The second clause also accepts
     '#f'.

 -- Validation Clause: char-in-ascii-range OBJ
 -- Validation Clause: char-in-ascii-range/false OBJ
     Succeed if OBJ is a character and its Unicode code point is in the
     range [0, 127].  The second form accepts also '#f' as value.


File: vicare-libs.info,  Node: args predefined strings,  Next: args predefined vectors,  Prev: args predefined chars,  Up: args predefined

8.5.12 Validating string and related arguments
----------------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: string OBJ
     Succeed if OBJ is a string.

 -- Validation Clause: string/false OBJ
     Succeed if OBJ is '#f' or a string.

 -- Validation Clause: non-empty-string OBJ
     Succeed if OBJ is a string and its length is greater than zero.

 -- Validation Clause: non-empty-string/false OBJ
     Succeed if OBJ is '#f' or a string and its length is greater than
     zero.

 -- Validation Clause: list-of-strings OBJ
     Succeed if OBJ is null or a list of strings.

 -- Validation Clause: string-or-symbol OBJ
 -- Validation Clause: string-or-symbol-or-false OBJ
     Succeed if OBJ is a string or symbol; the second clause accepts
     also '#f'.

 -- Validation Clause: index-for-string STR IDX
     Succeed if IDX is a fixnum usable as index (not out of range) for
     STR, which is expected to be an already validated string.  IDX must
     satisfy the constraints:

          0 <= IDX < (string-length STR)

 -- Validation Clause: one-off-index-for-string STR IDX
     Succeed if IDX is a fixnum usable as index for STR, which is
     expected to be an already validated string, or it is equal to the
     string length.  IDX must satisfy the constraints:

          0 <= IDX <= (string-length STR)

 -- Validation Clause: index-and-count-for-string STR IDX COUNT
     Assuming that STR is an already validated string: succeed if IDX is
     a fixnum usable as index (not out of range) for STR, and COUNT is a
     fixnum which can be used as characters count in STR starting and
     IDX without going out of range.

     In other words: IDX and COUNT select a substring of STR.

 -- Validation Clause: start-and-end-for-string STR START END
     Assuming that STR is an already validated string: succeed if both
     START and END are fixnums usable as indexes (not out of range) for
     STR, and START is less than or equal to END.

     In other words: START and END select a substring of STR by
     specifying inclusive limits.

 -- Validation Clause: start-and-past-for-string STR START PAST
     Assuming that STR is an already validated string: succeed if both
     START and PAST are fixnums satisfying the constraints:

          0 <= START <= (string-length STR)
          START <= PAST <= (string-length STR)

     In other words: START and PAST select a substring of STR by
     specifying left-inclusive and right-exclusive limits.


File: vicare-libs.info,  Node: args predefined vectors,  Next: args predefined bytevectors,  Prev: args predefined strings,  Up: args predefined

8.5.13 Validating vector and related arguments
----------------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: vector OBJ
     Succeed if OBJ is a vector.

 -- Validation Clause: vector/false OBJ
     Succeed if OBJ is '#f' or a vector.

 -- Validation Clause: non-empty-vector OBJ
     Succeed if OBJ is a vector and its length is greater than zero.

 -- Validation Clause: non-empty-vector/false OBJ
     Succeed if OBJ is '#f' or a vector and its length is greater than
     zero.

 -- Validation Clause: index-for-vector VEC IDX
     Succeed if IDX is a fixnum usable as index (not out of range) for
     VEC, which is expected to be an already validated vector.

 -- Validation Clause: index-and-count-for-vector VEC IDX COUNT
     Assuming that VEC is an already validated vector: succeed if IDX is
     a fixnum usable as index (not out of range) for VEC, and COUNT is a
     fixnum which can be used as characters count in VEC starting and
     IDX without going out of range.

     In other words: IDX and COUNT select a subvector of VEC.

 -- Validation Clause: start-and-end-for-vector VEC START END
     Assuming that VEC is an already validated vector: succeed if both
     START and END are fixnums usable as indexes (not out of range) for
     VEC, and START is less than or equal to END.

     In other words: START and END select a subvector of VEC by
     specifying inclusive limits.

 -- Validation Clause: start-and-past-for-vector VEC START PAST
     Assuming that VEC is an already validated vector: succeed if both
     START and PAST are fixnums satisfying the constraints:

          0 <= START <= (vector-length VEC)
          START <= PAST <= (vector-length VEC)

     In other words: START and PAST select a subvector of VEC by
     specifying left-inclusive and right-exclusive limits.


File: vicare-libs.info,  Node: args predefined bytevectors,  Next: args predefined pathnames,  Prev: args predefined vectors,  Up: args predefined

8.5.14 Validating bytevector and related arguments
--------------------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: bytevector OBJ
     Succeed if OBJ is a bytevector.

 -- Validation Clause: bytevector/false OBJ
     Succeed if OBJ is '#f' or a bytevector.

 -- Validation Clause: non-empty-bytevector OBJ
     Succeed if OBJ is a bytevector and its length is greater than zero.

 -- Validation Clause: non-empty-bytevector/false OBJ
     Succeed if OBJ is '#f' or a bytevector and its length is greater
     than zero.

 -- Validation Clause: list-of-bytevectors OBJ
     Succeed if OBJ is null or a list of bytevectors.

 -- Validation Clause: index-for-bytevector BV IDX
     Succeed if IDX is a fixnum usable as index (not out of range) for
     BV, which is expected to be an already validated bytevector.

 -- Validation Clause: bytevector-length LEN
     Succeed if LEN is a non-negative fixnum usable as bytevector
     length.

 -- Validation Clause: index-and-count-for-bytevector BV IDX COUNT
     Assuming that BV is an already validated bytevector: succeed if IDX
     is a fixnum usable as index (not out of range) for BV, and COUNT is
     a fixnum which can be used as characters count in BV starting and
     IDX without going out of range.

     In other words: IDX and COUNT select a subbytevector of BV.

 -- Validation Clause: start-and-end-for-bytevector BV START END
     Assuming that BV is an already validated bytevector: succeed if
     both START and END are fixnums usable as indexes (not out of range)
     for BV, and START is less than or equal to END.

     In other words: START and END select a subbytevector of BV by
     specifying inclusive limits.

 -- Validation Clause: start-and-past-for-bytevector BV START PAST
     Assuming that BV is an already validated bytevector: succeed if
     both START and PAST are fixnums satisfying the constraints:

          0 <= START <= (bytevector-length BV)
          START <= PAST <= (bytevector-length BV)

     In other words: START and PAST select a subbytevector of BV by
     specifying left-inclusive and right-exclusive limits.


File: vicare-libs.info,  Node: args predefined pathnames,  Next: args predefined symbols,  Prev: args predefined bytevectors,  Up: args predefined

8.5.15 String and bytevector pathnames
--------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: file-pathname OBJ
     Succeed if OBJ satisfies the predicate 'file-pathname?' from
     '(vicare language-extensions posix)'.

 -- Validation Clause: file-string-pathname OBJ
     Succeed if OBJ satisfies the predicate 'file-string-pathname?' from
     '(vicare language-extensions posix)'.

 -- Validation Clause: file-bytevector-pathname OBJ
     Succeed if OBJ satisfies the predicate 'file-bytevector-pathname?'
     from '(vicare language-extensions posix)'.

 -- Validation Clause: file-colon-search-path OBJ
     Succeed if OBJ satisfies the predicate 'file-colon-search-path?'
     from '(vicare language-extensions posix)'.

 -- Validation Clause: file-string-colon-search-path OBJ
     Succeed if OBJ satisfies the predicate
     'file-string-colon-search-path?' from '(vicare language-extensions
     posix)'.

 -- Validation Clause: file-bytevector-colon-search-path OBJ
     Succeed if OBJ satisfies the predicate
     'file-bytevector-colon-search-path?' from '(vicare
     language-extensions posix)'.


File: vicare-libs.info,  Node: args predefined symbols,  Next: args predefined enum-sets,  Prev: args predefined pathnames,  Up: args predefined

8.5.16 Validating symbols
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: symbol OBJ
     Succeed if OBJ is a symbol.

 -- Validation Clause: symbol/false OBJ
     Succeed if OBJ is '#f' or a symbol.

 -- Validation Clause: list-of-symbols OBJ
     Succeed if OBJ is a proper list whose items are symbols.


File: vicare-libs.info,  Node: args predefined enum-sets,  Next: args predefined pointers,  Prev: args predefined symbols,  Up: args predefined

8.5.17 Validating enum-sets
---------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: enum-set OBJ
     Succeed if OBJ is a enum-set.

 -- Validation Clause: enum-set/false OBJ
     Succeed if OBJ is '#f' or a enum-set.


File: vicare-libs.info,  Node: args predefined pointers,  Next: args predefined memory-blocks,  Prev: args predefined enum-sets,  Up: args predefined

8.5.18 Validating pointers
--------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: pointer OBJ
     Succeed if OBJ is a pointer.

 -- Validation Clause: pointer/false OBJ
     Succeed if OBJ is '#f' or a pointer.

 -- Validation Clause: non-null-pointer OBJ
     Succeed if OBJ is a pointer and it does *not* represent 'NULL'.

 -- Validation Clause: c-callback OBJ
     Succeed if OBJ is a pointer object.

 -- Validation Clause: c-callback/false OBJ
     Succeed if OBJ is '#f' or a pointer object.


File: vicare-libs.info,  Node: args predefined memory-blocks,  Next: args predefined flonums,  Prev: args predefined pointers,  Up: args predefined

8.5.19 Validating 'memory-block' values
---------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: memory-block OBJ
     Succeed if OBJ is a memory-block.

 -- Validation Clause: memory-block/false OBJ
     Succeed if OBJ is '#f' or a memory-block.


File: vicare-libs.info,  Node: args predefined flonums,  Next: args predefined bignums,  Prev: args predefined memory-blocks,  Up: args predefined

8.5.20 Validating flonums
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: flonum OBJ
     Succeed if OBJ satisfies the predicate 'flonum?'.


File: vicare-libs.info,  Node: args predefined bignums,  Next: args predefined ratnums,  Prev: args predefined flonums,  Up: args predefined

8.5.21 Validating bignums
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: bignum OBJ
     Succeed if OBJ satisfies the predicate 'bignum?'.


File: vicare-libs.info,  Node: args predefined ratnums,  Next: args predefined reals,  Prev: args predefined bignums,  Up: args predefined

8.5.22 Validating ratnums
-------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: ratnum OBJ
     Succeed if OBJ satisfies the predicate 'ratnum?'.


File: vicare-libs.info,  Node: args predefined reals,  Next: args predefined compnums,  Prev: args predefined ratnums,  Up: args predefined

8.5.23 Validating reals
-----------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: real OBJ
     Succeed if OBJ satisfies the predicate 'real?'.

 -- Validation Clause: real-exact OBJ
     Succeed if OBJ satisfies one of the predicates 'fixnum?',
     'bignum?', 'ratnum?'.


File: vicare-libs.info,  Node: args predefined compnums,  Next: args predefined cflonums,  Prev: args predefined reals,  Up: args predefined

8.5.24 Validating compnums
--------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: compnum OBJ
     Succeed if OBJ satisfies the predicate 'compnum?'.


File: vicare-libs.info,  Node: args predefined cflonums,  Next: args predefined complexes,  Prev: args predefined compnums,  Up: args predefined

8.5.25 Validating cflonums
--------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: cflonum OBJ
     Succeed if OBJ satisfies the predicate 'cflonum?'.


File: vicare-libs.info,  Node: args predefined complexes,  Next: args predefined ports,  Prev: args predefined cflonums,  Up: args predefined

8.5.26 Validating complexes
---------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: complex OBJ
     Succeed if OBJ satisfies the predicate 'complex?'.


File: vicare-libs.info,  Node: args predefined ports,  Next: args predefined transcoders,  Prev: args predefined complexes,  Up: args predefined

8.5.27 Validating input/output ports
------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: port OBJ
     Succeed if OBJ is a port.

 -- Validation Clause: port/false OBJ
     Succeed if OBJ is '#f' or a port.

 -- Validation Clause: input-port OBJ
 -- Validation Clause: output-port OBJ
 -- Validation Clause: input/output-port OBJ
     Succeed if OBJ is an input, output or input/output port.

 -- Validation Clause: input-port/false OBJ
 -- Validation Clause: output-port/false OBJ
 -- Validation Clause: input/output-port/false OBJ
     Succeed if OBJ is '#f' or an input, output or input/output port.

 -- Validation Clause: textual-port OBJ
 -- Validation Clause: binary-port OBJ
     Succeed if OBJ is an textual or binary port.

 -- Validation Clause: textual-port/false OBJ
 -- Validation Clause: binary-port/false OBJ
     Succeed if OBJ is '#f' or an textual or binary port.

 -- Validation Clause: open-port OBJ
     Succeed if OBJ is an open port.


File: vicare-libs.info,  Node: args predefined transcoders,  Next: args predefined procedures,  Prev: args predefined ports,  Up: args predefined

8.5.28 Validating port transcoders
----------------------------------

The following bindings are extranscodered by the library '(vicare
arguments validation)'.

 -- Validation Clause: transcoder OBJ
     Succeed if OBJ is a transcoder.

 -- Validation Clause: transcoder/false OBJ
     Succeed if OBJ is '#f' or a transcoder.


File: vicare-libs.info,  Node: args predefined procedures,  Next: args predefined genstrings,  Prev: args predefined transcoders,  Up: args predefined

8.5.29 Validating procedures
----------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: procedure OBJ
     Succeed if OBJ is a procedure.

 -- Validation Clause: procedure/false OBJ
     Succeed if OBJ is '#f' or a procedure.


File: vicare-libs.info,  Node: args predefined genstrings,  Next: args predefined genbuffers,  Prev: args predefined procedures,  Up: args predefined

8.5.30 Validating generalised C string arguments
------------------------------------------------

*note Introduction to generalised C strings: cbuffers strings, for
details on generalised C strings.

   The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: general-c-string OBJ
     Succeed if OBJ is a generalised C string.

 -- Validation Clause: general-c-string/false OBJ
     Succeed if OBJ is '#f' or a generalised C string.

 -- Validation Clause: general-c-string.len STR STR.LEN
     If STR is a pointer object: succeed if STR.LEN an exact integer in
     the range of the C language type 'size_t'.  Otherwise succeed if
     STR.LEN is '#f'.

 -- Validation Clause: general-c-string* OBJ OBJ.LEN
     Succeed if OBJ is a generalised C string and OBJ.LEN its optional
     length.

 -- Validation Clause: general-c-string*/false OBJ OBJ.LEN
     Succeed if OBJ is a '#f' or a generalised C string and OBJ.LEN its
     optional length.  If OBJ is '#f': OBJ.LEN must be false too.


File: vicare-libs.info,  Node: args predefined genbuffers,  Next: args predefined time,  Prev: args predefined genstrings,  Up: args predefined

8.5.31 Validating generalised C buffer arguments
------------------------------------------------

*note Introduction to generalised C buffers: cbuffers buffers, for
details on generalised C buffers.

   The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: general-c-buffer OBJ
     Succeed if OBJ is a generalised C buffer.

 -- Validation Clause: general-c-buffer/false OBJ
     Succeed if OBJ is '#f' or a generalised C buffer.

 -- Validation Clause: general-c-sticky-buffer OBJ
     Succeed if OBJ is a generalised C sticky buffer.

 -- Validation Clause: general-c-sticky-buffer/false OBJ
     Succeed if OBJ is '#f' or a generalised C sticky buffer.

 -- Validation Clause: general-c-buffer.len BUF BUF.LEN
     If BUF is a pointer object: succeed if BUF.LEN an exact integer in
     the range of the C language type 'size_t'.  Otherwise succeed if
     BUF.LEN is '#f'.

 -- Validation Clause: general-c-buffer* OBJ OBJ.LEN
     Succeed if OBJ is a generalised C buffer and OBJ.LEN its optional
     length.

 -- Validation Clause: general-c-sticky-buffer* OBJ OBJ.LEN
     Succeed if OBJ is a generalised C sticky buffer and OBJ.LEN its
     optional length.

 -- Validation Clause: general-c-buffer*/false OBJ OBJ.LEN
     Succeed if OBJ is a '#f' or a generalised C buffer and OBJ.LEN its
     optional length.  If OBJ is '#f': OBJ.LEN must be false too.

 -- Validation Clause: general-c-sticky-buffer*/false OBJ OBJ.LEN
     Succeed if OBJ is a '#f' or a generalised C sticky buffer and
     OBJ.LEN its optional length.  If OBJ is '#f': OBJ.LEN must be false
     too.


File: vicare-libs.info,  Node: args predefined time,  Next: args predefined identifier,  Prev: args predefined genbuffers,  Up: args predefined

8.5.32 Validating time objects
------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: time OBJ
     Succeed if OBJ is a time object: it satisfies the predicate 'time?'
     exported by '(vicare)'.

 -- Validation Clause: time/false OBJ
     Succeed if OBJ is '#f' or a time object: it satisfies the predicate
     'time?' exported by '(vicare)'.


File: vicare-libs.info,  Node: args predefined identifier,  Prev: args predefined time,  Up: args predefined

8.5.33 Validating identifier objects
------------------------------------

The following bindings are exported by the library '(vicare arguments
validation)'.

 -- Validation Clause: identifier OBJ
     Succeed if OBJ is a identifier object: it satisfies the predicate
     'identifier?' exported by '(vicare)'.

 -- Validation Clause: identifier/false OBJ
     Succeed if OBJ is '#f' or a identifier object: it satisfies the
     predicate 'identifier?' exported by '(vicare)'.


File: vicare-libs.info,  Node: cbuffers,  Next: readline,  Prev: args,  Up: Top

9 Generalised C buffers and strings
***********************************

When interfacing a C language foreign library with Vicare, it is often
needed to convert Scheme objects to raw memory blocks, possibly
containing ASCIIZ strings.

   To access generalised C buffers at the C language level see *note
Generalised C buffers: (vicare-scheme)objects misc cbuffers.

* Menu:

* cbuffers buffers::            Introduction to generalised C buffers.
* cbuffers strings::            Introduction to generalised C strings.
* cbuffers api::                Programming interface to generalised
                                C buffers and strings.


File: vicare-libs.info,  Node: cbuffers buffers,  Next: cbuffers strings,  Up: cbuffers

9.1 Introduction to generalised C buffers
=========================================

Generalised C buffers are meant to be used in interfaces to foreign C
language libraries, when a pointer to raw data is required as argument.

   A "generalised C buffer" is an object capable of holding an array of
mutable bytes referenced by a pointer; such Scheme objects are:
bytevectors, pointer objects, instances of 'memory-block'.

   A "generalised C sticky buffer" is an object capable of holding an
array of mutable bytes referenced by a pointer, whose data area is never
moved around by the garbage collector; such Scheme objects are: pointer
objects, instances of 'memory-block'.  Sticky buffers are meant to be
used when calling out to C functions that call back to Scheme.

   *note Memory blocks: (vicare-scheme)iklib memory blocks. for details
on memory blocks.

   Two arguments to function are usually needed to represent a
generalised C buffer: the buffer value itself and an optional length.

  1. The buffer argument is meant to be either bytevector, or
     'memory-block' instance, or pointer object.

  2. The length argument is meant to be '#f' or an exact integer in the
     range of the C language type 'size_t'.  When the buffer argument is
     a pointer object: the length argument must represent the number of
     bytes available in the referenced memory block; otherwise the
     length argument is ignored.

   Here is an example function accepting a generalised C buffer argument
BUF and its optional length argument BUF.LEN:

     (define fun
       (case-lambda
         ((buf)
          (fun buf #f))
         ((buf buf.len)
          (define who 'fun)
          (with-arguments-validation (who)
              ((general-c-buffer     buf)
               (general-c-buffer.len buf buf.len))
            (do-something-with buf buf.len)))))


File: vicare-libs.info,  Node: cbuffers strings,  Next: cbuffers api,  Prev: cbuffers buffers,  Up: cbuffers

9.2 Introduction to generalised C strings
=========================================

Generalised C strings are meant to be used in interfaces to foreign C
language libraries, when a pointer to C string or input buffer is
required as argument.

   A "generalised C string" is an object capable of holding the
representation of a C language string; such Scheme objects are: strings,
bytevectors, pointer objects, instances of 'memory-block'.  *note Memory
blocks: (vicare-scheme)iklib memory blocks. for details on memory
blocks.

   When a Scheme string is used as generalised C string: the application
must take care of converting the Scheme string into a C string
representation, for example using 'string->ascii'.

   When using generalised C strings we have to remember that:

   * A run of the garbage collector may move the data area of Scheme
     bytevectors; for this reason Scheme bytevectors and Scheme strings
     converted to bytevectors are not suitable as arguments to Scheme
     functions interfacing to C functions that call back to Scheme.

   * If a Scheme string is used as argument: the C function cannot
     modify it by using it as output buffer.

in these cases we should use generalised C buffers, *note Introduction
to generalised C buffers: cbuffers buffers.

   Two arguments to function are usually needed to represent a
generalised C string: the string value itself and an optional length.

  1. The string argument is meant to be either a string, or bytevector,
     or 'memory-block' instance, or pointer object.

  2. The length argument is meant to be '#f' or an exact integer in the
     range of the C language type 'size_t'.  When the string argument is
     a pointer object: the length argument must represent the number of
     bytes available in the referenced memory block; otherwise the
     length argument is ignored.

   Here is an example function accepting a generalised C string argument
STR and its optional length argument STR.LEN, the string is converted to
bytevector with 'string->ascii':

     (define fun
       (case-lambda
         ((str)
          (fun str #f))
         ((str str.len)
          (define who 'fun)
          (with-arguments-validation (who)
              ((general-c-string     str)
               (general-c-string.len str str.len))
            (with-general-c-strings
                ((str^         str))
              (do-something-with str^ str.len))))))


File: vicare-libs.info,  Node: cbuffers api,  Prev: cbuffers strings,  Up: cbuffers

9.3 Programming interface to generalised C buffers and strings
==============================================================

The API dealing with generalised C buffers and strings, is composed of
syntaxes used to validate and normalise the arguments before handing
them to the foreign function.

   *note Validating generalised C buffer arguments: args predefined
genbuffers. for details on how to validation generalised C buffer
arguments.

   *note Validating generalised C string arguments: args predefined
genstrings. for details on how to validation generalised C string
arguments.

   The following bindings are exported by the library '(vicare arguments
general-c-buffers)'.

 -- Function: general-c-string? ?OBJ
     Expand to an expression which evaluates ?OBJ once and returns '#t'
     if the result is a generalised C string.

 -- Function: general-c-buffer? ?OBJ
     Expand to an expression which evaluates ?OBJ once and returns '#t'
     if the result is a generalised C buffer.

 -- Function: general-c-sticky-buffer? ?OBJ
     Expand to an expression which evaluates ?OBJ once and returns '#t'
     if the result is a generalised C sticky buffer.

 -- Function: assert-general-c-buffer-and-length WHO BUF LEN
 -- Function: assert-general-c-string-and-length WHO STR LEN
     Assume that BUF and STR have already been validated as general C
     buffer and general C string; validate LEN as valid length of buffer
     or string.

     When successful: nothing happens.  If the validation fails: raise
     an exception using 'procedure-arguments-consistency-violation'.
     The argument WHO is used for the condition of type '&who'.

 -- Function: general-c-buffer-len BUF BUF.LEN
     Return the number of bytes in a generalised C buffer object.

     BUF must be a bytevector, pointer object or 'memory-block' struct
     instance.

     When BUF is a pointer object: BUF.LEN must be an exact integer (in
     the range of the C language type 'size_t') representing the number
     of bytes available in the referenced memory block.  Otherwise
     BUF.LEN is ignored.

 -- Syntax: with-general-c-strings ((?STR ?EXPR) ...)
          (string-to-bytevector ?STRING->BYTEVECTOR) ?BODY0 . ?BODY
 -- Syntax: with-general-c-strings ((?STR ?EXPR) ...) ?BODY0 . ?BODY
 -- Auxiliary Syntax: string-to-bytevector
     Prepare some generalised C strings to be used by a chunk of code
     expecting access to raw memory holding a C language string or input
     buffer.

     The values ?STR must be identifiers, unique according to
     'bound-identifier=?'.

     The values ?EXPR must be expressions which will always be evaluated
     only once.

     The value ?STRING->BYTEVECTOR must be an expression evaluating to a
     procedure which converts a string to a bytevector, for example
     'string->ascii'.  In the second form of the syntax use:
     ?STRING->BYTEVECTOR defaults to 'string->ascii'.

     For each couple ?STR and ?EXPR do the following:

        * If the result of evaluating ?EXPR is a bytevector, pointer
          object or 'memory-block' instance bind it to ?STR.

        * If the result of evaluating ?EXPR is a string: convert it to a
          bytevector using the procedure result of evaluating
          ?STRING->BYTEVECTOR, then bind it to ?STR.

     Evaluate the ?BODY forms in the region in which such bindings are
     effective.  Return the return value of the last ?BODY form.

 -- Syntax: with-general-c-strings/false ((?STR ?EXPR) ...)
          (string-to-bytevector ?STRING->BYTEVECTOR) ?BODY0 . ?BODY
 -- Syntax: with-general-c-strings/false ((?STR ?EXPR) ...) ?BODY0 .
          ?BODY
 -- Auxiliary Syntax: string-to-bytevector
     Like 'with-general-c-strings' but if a ?EXPR evaluates to '#f'
     accept the value.

 -- Syntax: with-general-c-pathnames ((?PTN ?EXPR) ...) ?BODY0 . ?BODY
     Prepare some generalised C strings to be used by a chunk of code
     expecting access to raw memory holding a C language string
     representing a file system pathname.

     The values ?PTN must be identifiers, unique according to
     'bound-identifier=?'.

     The values ?EXPR must be expressions which will always be evaluated
     only once.

     For each couple ?PTN and ?EXPR do the following:

        * If the result of evaluating ?EXPR is a bytevector, pointer
          object or 'memory-block' instance bind it to ?PTN.

        * If the result of evaluating ?EXPR is a string: convert it to a
          bytevector using the function referenced by the parameter
          'string->pathname-func', then bind it to ?PTN.

     Evaluate the ?BODY forms in the region in which such bindings are
     effective.  Return the return value of the last ?BODY form.

 -- Syntax: with-general-c-pathnames/false ((?PTN ?EXPR) ...) ?BODY0 .
          ?BODY
     Like 'with-general-c-pathnames' but if a ?EXPR evaluates to '#f'
     accept the value.

   As example, let's say we have loaded C language code exposing a
function 'ikptr_posix_file_size()', which given a file pathname returns
its size; we can interface it as follows:

     #!r6rs
     (import (vicare)
       (vicare arguments validation))

     (define (file-size pathname)
       (define who 'file-size)
       (with-arguments-validation (who)
           ((general-c-string pathname))
         (with-general-c-pathnames ((pathname^ pathname))
           (foreign-call "ikptr_posix_file_size" pathname^))))


File: vicare-libs.info,  Node: readline,  Next: parser logic,  Prev: cbuffers,  Up: Top

10 Extended interface to GNU Readline
*************************************

The library '(vicare readline)' extends the basic readline API exported
by '(vicare)' (*note Readline interface: (vicare-scheme)iklib readline.)
with features specific to the GNU Readline library.  The following
bindings:

     readline-enabled?
     readline
     make-readline-input-port

exported by '(vicare)' are reexported by '(vicare readline)'.

 -- Function: rl-version
     If support for readline is enabled and the linked library is GNU
     Readline: return an exact integer representing the GNU Readline
     version number as encoded in the C symbol 'RL_READLINE_VERSION';
     else return '#f'.  When this function returns '#f': no other GNU
     Readline functions must be called, lest the process be aborted.


File: vicare-libs.info,  Node: parser logic,  Next: gcc,  Prev: readline,  Up: Top

11 Defining parsers logic
*************************

The library '(vicare parser-logic)' defines an infrastructure to declare
the logic of a parser for sequences of characters; such logic can be
specialised for different underlying devices.  The library heavily
relies on macros.

* Menu:

* parser logic intro::          Introductory examples.
* parser logic operators::      The logic of parser operators.
* parser logic api::            Programming interface to
                                parser definition.


File: vicare-libs.info,  Node: parser logic intro,  Next: parser logic operators,  Up: parser logic

11.1 Introductory examples
==========================

Parsing a string of selected characters
.......................................

As first usage example, let's see a simple parser using a full Scheme
string as argument and accepting lexemes being the empty string or
strings of characters '#\a' and '\#b'; the result of a call to the
parser is the list of characters or '#f' if the input is invalid:

     #!r6rs
     (import (vicare)
       (vicare parser-logic))

     (module (parse-abba)

       (define (parse-abba input-string)
         (assert (string? input-string))
         (%parse-string input-string
                        (string-length input-string)
                        0    ;start index
                        '()  ;start value for ACCUMULATOR
                        ))

       (define-parser-logic define-string->abba-parser ch next fail
         (%parse-string (accumulator)
            ((:end-of-input)
             (reverse accumulator))
            ((#\a #\b)
             (next %parse-string (cons ch accumulator)))))

       (define-string->abba-parser string->token-or-false
         (%parse-string))

       #| end of module |# )

     (parse-abba "")         => ()
     (parse-abba "a")        => (#\a)
     (parse-abba "b")        => (#\b)
     (parse-abba "1")        => #f)
     (parse-abba "ciao")     => #f)
     (parse-abba "abb")      => (#\a #\b #\b)

notice the use of 'next' to recursively tail-call 'parse-string'.

   The macro 'string->token-or-false' is exported by '(vicare
parser-logic)'; it implements the device logic for a full input Scheme
string representing a lexeme; it is to be used in a parser returning
'#f' when the input is invalid.

   The macros in the module combine their output and expand to the
definition of a function '%parse-string' equivalent to the following:

     (define (%parse-string input.string input.length input.index
                            accumulator)
       (if (fx=? input.index input.length)
           (reverse accumulator)
         (let ((ch (string-ref input.string input.index)))
           (cond ((or (char=? #\a ch)
                      (char=? #\b ch))
                  (%parse-string input.string input.length
                                 (fx+ 1 input.index)
                                 (cons ch accumulator)))
                 (else #f)))))

Parsing a string of intermixed selected characters
..................................................

Let's see a parser using a full Scheme string as argument and accepting
lexemes being the empty string or strings of characters '#\a' and '\#b':

   * '#\a' can be followed only by '#\b' or end-of-input.

   * '#\b' can be followed only by '#\a' or end-of-input.

the result of a call to the parser is the list of characters or '#f' if
the input is invalid:

     #!r6rs
     (import (vicare)
       (vicare parser-logic))

     (module (parse-abab)

       (define (parse-abab input-string)
         (assert (string? input-string))
         (%parse-string input-string
                        (string-length input-string)
                        0    ;start index
                        '()  ;start value for ACCUMULATOR
                        ))

       ;;Parser logic to convert a string of intermixed
       ;;#\a and #\b into a list of characters.
       (define-parser-logic define-string->abab-parser ch next fail
         (%parse-string (accumulator)
            ((:end-of-input)
             (reverse accumulator))
            ((#\a #\b)
             (if (or (null? accumulator)
                     (case ch
                       ((#\a) (char=? #\b (car accumulator)))
                       ((#\b) (char=? #\a (car accumulator)))))
                 (next %parse-string (cons ch accumulator))
               (fail)))))

       ;;Actual parser drawing characters from an input string.
       (define-string->abab-parser string->token-or-false
         (%parse-string))

       #| end of module |# )

     (parse-abab "")         => ()
     (parse-abab "a")        => (#\a)
     (parse-abab "b")        => (#\b)
     (parse-abab "1")        => #f
     (parse-abab "ciao")     => #f
     (parse-abab "abb")      => #f
     (parse-abab "baa")      => #f
     (parse-abab "abab")     => (#\a #\b #\a #\b)
     (parse-abab "baba")     => (#\b #\a #\b #\a)

notice the use of 'fail' to signal an input error from inside an
operator clause.

   The macros in the module combine their output and expand to the
definition of a function '%parse-string' equivalent to the following:

     (define (%parse-string input.string input.length input.index
                            accumulator)
       (if (fx=? input.index input.length)
           (reverse accumulator)
         (let ((ch (string-ref input.string input.index)))
           (cond ((or (char=? #\a ch)
                      (char=? #\b ch))
                  (if (or (null? accumulator)
                          (case ch
                            ((#\a) (char=? #\b (car accumulator)))
                            ((#\b) (char=? #\a (car accumulator)))))
                      (%parse-string input.string input.length
                                     (fx+ 1 input.index)
                                     (cons ch accumulator))
                    #f))
                 (else #f)))))

Parsing exact integers in base 10
.................................

Let's see a parser using a full Scheme string as argument and accepting
lexemes representing exact integers in base 10; the result of a call to
the parser is the exact integer object or '#f' if the input is invalid:

     #!r6rs
     (import (vicare)
       (vicare parser-logic))

     (define (parse-integer input-string)

       (define (%digit ch)
         ;;Given a character argument: return the corresponding
         ;;fixnum if the character is between #\0 and #\9, else
         ;;return false.
         ;;
         (let ((N (fx- (char->integer ch) (char->integer #\0))))
           (and (fx>= N 0)
                (fx<  N 10)
                N)))

       ;;Parser logic to convert a string into an exact integer
       ;;in base 10.
       (define-parser-logic define-string->integer-parser ch next fail
         (%parse-integer ()
            ((%digit) => D
             (next %parse-digit+ D)))
         (%parse-digit+ (accumulator)
            ((:end-of-input)
             accumulator)
            ((%digit) => D
             (next %parse-digit+ (+ D (* 10 accumulator))))))

       ;;Actual parser drawing characters from an input string.
       (define-string->integer-parser string->token-or-false
         (%parse-integer))

       (assert (string? input-string))
       (%parse-integer input-string (string-length input-string) 0))

     (parse-integer "")              => #f
     (parse-integer "1")             => 1
     (parse-integer "123")           => 123
     (parse-integer "ciao")          => #f
     (parse-integer "123ciao")       => #f

   The macros in the body of 'parse-integer' combine their output and
expand to the definition of two functions '%parse-integer' and
'%parse-digit+' equivalent to the following:

     (define (%parse-integer input.string input.length input.index)
       (if (fx=? input.index input.length)
           #f
         (let ((ch (string-ref input.string input.index)))
           (cond ((%digit ch)
                  => (lambda (D)
                       (%parse-digit+ input.string input.length
                                      (fx+ 1 input.index) D)))
                 (else #f)))))

     (define (%parse-digit+ input.string input.length input.index
                            accumulator)
       (if (fx=? input.index input.length)
           accumulator
         (let ((ch (string-ref input.string input.index)))
           (cond ((%digit ch)
                  => (lambda (D)
                       (%parse-digit+ input.string input.length
                                      (fx+ 1 input.index)
                                      (+ D (* 10 accumulator)))))
                 (else #f)))))


File: vicare-libs.info,  Node: parser logic operators,  Next: parser logic api,  Prev: parser logic intro,  Up: parser logic

11.2 The logic of parser operators
==================================

After all the macros have been expanded, the parser is a set of
"operator functions" extracting characters from an input device with the
purpose of producing a token.  Some operators are "entry points" to the
parser: public functions we can call to start parsing; other operators
are for internal use only.  Each operator is meant to either: tail-call
another operator, terminate parsing by raising an exception, terminate
parsing by returning an error value, terminate parsing successfully by
returning a token value.

     *NOTE* Operator functions are just ordinary Scheme functions
     playing a special role in a parser; they are given a name with the
     only purpose of letting us talk about them, and it happens that
     such name is "operator".

   Operators are generated by macros from a symbolic expression
specifying an abstract parser:

     (define-parser-logic define-parser ch next fail . ?OPERATORS)

and containing a subexpression for each operator.  Access to the input
device is specified by another macro which must implement a set of
'syntax-rules':

     (define-syntax device-logic
       (syntax-rules (:introduce-device-arguments
                      :generate-end-of-input-or-char-tests
                      :unexpected-end-of-input
                      :generate-delimiter-test
                      :invalid-input-char)
         ((_ :introduce-device-arguments          ---) ---)
         ((_ :generate-end-of-input-or-char-tests ---) ---)
         ((_ :unexpected-end-of-input             ---) ---)
         ((_ :generate-delimiter-test             ---) ---)
         ((_ :invalid-input-char                  ---) ---)))

   Concrete parsers are defined by combining the parser logic with the
device logic:

     (define-parser device-logic (?OPERATOR-NAME ...))

we can define any number of concrete parsers using the same parser logic
and different device logics; at the end of the expansion, the input
device forms are hard coded into the operator.  The list of
?OPERATOR-NAME is a list of identifiers bound to the operators being
entry points to the parser.

   To understand the semantics of operators, let's consider one
accepting only the characters '#\X' or '#\Y' and rejecting the
end-of-input:

     (define (operator-1 input-device parser-state)
       (let ((ch (get-next-char)))
         (cond ((end-of-input? ch)
                (error-form))
               ((char=? X ch)
                (a-clause-form))
               ((char=? Y ch)
                (another-clause-form))
               (else ;invalid input char
                (error-form)))))

such operator would be specified by the following ?OPERATOR symbolic
subexpression:

     (operator-1 (parser-state)
       ((#\X)
        (a-clause-form))
       ((#\Y)
        (another-clause-form)))

notice how the end-of-input test is automatically generated.  The
operator has some arguments representing the input device state and
other arguments representing the parser state; the list of input device
arguments comes first and is specified by the device logic, discussed
later; the list of parser state arguments comes last and is specified in
the ?OPERATOR symbolic expression.

   An operator function accepting characters '#\X', '#\Y' or '#\Z', with
'#\Y' and '#\Z' to be processed in the same way, and rejecting the
end-of-input looks like this:

     (define (operator-2 input-device parser-state)
       (let ((ch (get-next-char)))
         (cond ((end-of-input? ch)
                (error-form))
               ((char=? #\X ch)
                (a-clause-form))
               ((or (char=? #\Y ch)
                    (char=? #\Z ch))
                (another-clause-form))
               (else ;invalid input char
                (error-form)))))

such operator would be specified by the following ?OPERATOR symbolic
subexpression:

     (operator-2 (parser-state)
       ((#\X)
        (a-clause-form))
       ((#\Y #\Z)
        (another-clause-form)))

   An operator function accepting characters '#\X' or '#\Y', but also
the end-of-input from the device, looks like this:

     (define (operator-3 input-device parser-state)
       (let ((ch (get-next-char)))
         (cond ((end-of-input? ch)
                (end-of-input-form))
               ((char=? #\X ch)
                (a-clause-form))
               ((char=? #\Y ch)
                (another-clause-form))
               (else ;invalid input char
                (error-form)))))

and is specified in the parser logic as the following ?OPERATOR symbolic
subexpression:

     (operator-3 (parser-state)
       ((:end-of-input)
        (end-of-input-form))
       ((#\X)
        (a-clause-form))
       ((#\Y)
        (another-clause-form)))

   An operator function accepting characters '#\X' or '#\Y', the
end-of-input from the device, and also a set of end-of-lexeme delimiter
characters, looks like this:

     (define (operator-4 input-device parser-state)
       (let ((ch (get-next-char)))
         (cond ((end-of-input? ch)
                (end-of-input-form))
               ((char=? #\X ch)
                (a-clause-form))
               ((char=? #\Y ch)
                (another-clause-form))
               ((end-of-lexeme-delimiter? ch)
                (end-of-input-form))
               (else ;invalid input char
                (error-form)))))

notice how the 'end-of-input-form' is used for both the proper
end-of-input state and the end-of-lexeme state; such operator is
specified in the parser logic as the following ?OPERATOR symbolic
subexpression:

     (operator-4 (parser-state)
       ((:end-of-input)
        (end-of-input-form))
       ((X)
        (a-clause-form))
       ((Y)
        (another-clause-form)))

notice that processing of the end-of-lexeme state is not specified in
the parser logic: its generation is completely delegated to the device
logic.

   Sometimes it is useful to apply a test function or macro to an input
character and collect the result for further processing; this can be
done as follows:

     (define (the-test ch arg1 arg2 arg3)
       ---)

     (define (operator-5 input-device parser-state)
       (let ((ch (get-next-char)))
         (cond ((end-of-input? ch)
                (error-form))
               ((the-test ch 1 2 3)
                => (lambda (result)
                     (a-clause-form)))
               ((char=? #\Y ch)
                (another-clause-form))
               (else ;invalid input char
                (error-form)))))

and is specified in the parser logic as the symbolic subexpression:

     (operator-5 (parser-state)
       ((the-test 1 2 3) => result
        (a-clause-form))
       ((#\Y)
        (another-clause-form)))

where '=>' is the auxiliary syntax exported by '(rnrs base (6))'.


File: vicare-libs.info,  Node: parser logic api,  Prev: parser logic operators,  Up: parser logic

11.3 Programming interface to parser definition
===============================================

The following bindings are exported by the library '(vicare
parser-logic)'.

 -- Syntax: define-parser-logic ?DEFINER ?CH ?NEXT ?FAIL . ?OPERATORS
 -- Auxiliary Syntax: :end-of-input
     Define an abstract parser specifying the rules for parsing the
     input characters through calls to a set of operator functions; the
     result of the expansion is a syntax definition which can be used to
     instantiate a concrete parser by combining the parser logic with
     the input device logic.

     The input arguments are:

     ?DEFINER
          It must be an identifier.  It is bound to the generated syntax
          definition; such syntax is used as follows:

               (?DEFINER ?DEVICE-LOGIC (?OPERATOR-NAME ...))

          where: ?DEVICE-LOGIC is the identifier bound to the device
          logic syntax; the ?OPERATOR-NAME are identifiers among the
          public operator function names.

     ?CH
          It must be an identifier.  When a character is successfully
          extracted from the input device, it is bound to this
          identifier and made available to the operator clauses.

     ?NEXT
          It must be an identifier.  The device logic rule
          ':generate-end-of-input-or-char-tests' must bind it to a
          syntax; such syntax must expand to a tail-call to an operator
          processing the next input character.  ?NEXT is used as follows
          in the operator clauses:

               (next ?OPERATOR-NAME ?OPERATOR-ARG ...)

          and it should expand to something like:

               (?OPERATOR-NAME ?DEVICE-ARG ... ?OPERATOR-ARG ...)

          where: ?DEVICE-ARG are the arguments representing the input
          device state; ?OPERATOR-ARG are the arguments representing the
          parser state as specified in the ?OPERATOR-SPEC.

     ?FAIL
          It must be an identifier.  The device logic rule
          ':generate-end-of-input-or-char-tests' must bind it to a
          syntax; such syntax is used to handle parsing errors detected
          by the operator clauses.  ?FAIL is simply used as '(?FAIL)'.

     Each ?OPERATOR-SPEC must have the form:

          (?OPERATOR-NAME (?OPERATOR-ARG ...) ?OPERATOR-CLAUSE ...)

     where:

     ?OPERATOR-NAME
          Must be an identifier.  It is bound to a generated operator
          function.

          There is no difference in the way public operators and private
          ones are specified; the public operators names are listed in
          the concrete parser definition.  An operator can be public in
          a concrete parser and private in another concrete parser.

     ?OPERATOR-ARG
          Must be identifiers bound to the formal arguments associated
          to the parser state.

     ?OPERATOR-CLAUSE
          Are symbolic expressions specifying the input accepted by the
          operator.

     Each ?OPERATOR-CLAUSE must have one of the formats:

     '((?CHAR0 ?CHAR ...) ?BODY0 ?BODY ...)'
          Each ?CHAR must be an expression evaluating to a Scheme
          character object.  The ?BODY forms are evaluated if the input
          character bound to ?CH is equal, according to 'char=?', to one
          among the ?CHAR characters.

     '((?FUNC ?EXPR ...) => ?RET ?BODY0 ?BODY ...)'
          ?FUNC must be an expression evaluating to a function; the
          ?EXPR must be expressions; ?RET must be an identifier.  The
          ?BODY forms are evaluated if the form:

               (?FUNC ?CH ?EXPR ...)

          evaluates to a true value; such true value is bound to ?RET
          prior to evaluating the ?BODY.

     '((:end-of-input) ?BODY0 ?BODY ...)'
          The ?BODY forms are evaluated if no more characters are
          available from the input device.  This clause is to be used by
          operators accepting the end-of-input state as valid; if such
          rule is not present: the end-of-input will cause an error and
          the device logic is used to handle it.

 -- Auxiliary Syntax: :introduce-device-arguments
 -- Auxiliary Syntax: :generate-end-of-input-or-char-tests
 -- Auxiliary Syntax: :unexpected-end-of-input
 -- Auxiliary Syntax: :generate-delimiter-test
 -- Auxiliary Syntax: :invalid-input-char
     Identifiers used to specify device logic syntax rules; they must be
     used in a syntax definition like:

          (define-syntax device-logic
            (syntax-rules (:introduce-device-arguments
                           :generate-end-of-input-or-char-tests
                           :unexpected-end-of-input
                           :generate-delimiter-test
                           :invalid-input-char)
              ((_ :introduce-device-arguments          ---) ---)
              ((_ :generate-end-of-input-or-char-tests ---) ---)
              ((_ :unexpected-end-of-input             ---) ---)
              ((_ :generate-delimiter-test             ---) ---)
              ((_ :invalid-input-char                  ---) ---)))

     the rules have the following syntax:

     ':introduce-device-arguments'
          The input form is:

               (_ :introduce-device-arguments ?KONT . ?REST)

          this rule introduces a list of identifiers used as
          device-specific arguments; they will be the first arguments
          for each parser operator function.  The output form must be:

               (?KONT (?DEVICE-ARG ...) . ?REST)

          where the ?DEVICE-ARG are identifiers.

     ':generate-end-of-input-or-char-tests'
          The input form is:

               (_ :generate-end-of-input-or-char-tests
                  ?CH ?NEXT ?FAIL
                  (?DEVICE-ARG ...)
                  ?END-OF-INPUT-KONT ?PARSE-INPUT-CHAR-KONT)

          this rule is used to generate the input device tests for an
          operator function.  The expanded code must first test for the
          end-of-input state and then proceed to evaluate code for the
          input character; in pseudocode the output form should be:

               (if (end-of-input? ?DEVICE-ARG ...)
                   ?END-OF-INPUT-KONT
                 (let ((?CH (get-next-char ?DEVICE-ARG ...)))
                   ?PARSE-INPUT-CHAR-KONT))

          ?CH is an identifier.  The input character must be bound to it
          before evaluating ?PARSE-INPUT-CHAR-KONT.

          ?NEXT is an identifier.  This rule must bind it to a syntax
          used to tail-call another operator using ?DEVICE-ARG as first
          arguments; for example:

               (define-syntax ?NEXT
                 (syntax-rules ()
                   ((_ ?operator-name ?operator-arg ...)
                    (?operator-name ?DEVICE-ARG ... ?operator-arg))))

          ?FAIL is an identifier.  This rule must bind it to a syntax
          used to signal an error detected by an operator clause; for
          example:

               (define-syntax ?FAIL
                 (syntax-rules ()
                   ((_)
                    (error #f "invalid input character"
                      ?DEVICE-ARG ...))))

          The ?DEVICE-ARG are the identifiers introduced by
          ':introduce-device-arguments'.

          ?END-OF-INPUT-KONT is a form to be evaluated whenever the
          end-of-input is detected.

          ?PARSE-INPUT-CHAR-KONT is a form to be evaluated whenever a
          character is extracted from the input device.

     ':unexpected-end-of-input'
          The input form is:

               (_ :unexpected-end-of-input (?DEVICE-ARG ...))

          whenever the end-of-input is found by an operator that does
          not accept it as valid, this rule is used to decide what to
          do.

          The ?DEVICE-ARG are the identifiers introduced by
          ':introduce-device-arguments'.

          The output form can return a value or raise an exception; the
          returned value becomes the return value of the call to the
          parser.

     ':generate-delimiter-test'
          The input form is:

               (_ :generate-delimiter-test
                  ?CH
                  ?CH-IS-DELIMITER-KONT
                  ?CH-IS-NOT-DELIMITER-KONT)

          this rule is used for input devices for which the lexeme
          string is embedded into a sequence of other characters, so
          there exists a set of characters that delimit the
          end-of-lexeme.  The parser delegates to the device the
          responsibility of knowing which characters are delimiters, if
          any.

          ?CH is an identifier bound to the input character.
          ?CH-IS-DELIMITER-KONT is a form to be evaluated whenever ?CH
          is a delimiter character.  ?CH-IS-NOT-DELIMITER-KONT is a form
          to be evaluated whenever ?CH is not a delimiter character.

          For parsers accepting a full Scheme string as lexeme: there
          are no delimiters,3 the end-of-lexeme is the end-of-input;
          such parsers should just use ?CH-IS-NOT-DELIMITER-KONT as
          output form.

          For parsers having delimiter characters, for example,
          recognised by a function like:

               (define (delimiter? ch)
                 (or (char=? ch #\space)
                     (char=? ch #\linefeed)))

          the output form should be something like:

               (if (delimiter? ?CH)
                   ?CH-IS-DELIMITER-KONT
                 ?CH-IS-NOT-DELIMITER-KONT)

     ':invalid-input-char'
          The input form is:

               (_ :invalid-input-char (?DEVICE-ARG ...) ?CH)

          whenever an input character is not accepted by an operator
          function this rule is used to decide what to do.

          The ?DEVICE-ARG are the identifiers introduced by
          ':introduce-device-arguments'; ?CH is an identifier bound to
          the invalid input character.

          The output form can return a value or raise an exception; the
          returned value becomes the return value of the call to the
          parser.

 -- Syntax: string->token-or-false ?KEYWORD ?ARG ...
     Define the device logic to parse a lexeme from a full Scheme string
     object as in 'string->number'.  It is implemented as follows:

          (define-syntax string->token-or-false
            (syntax-rules (:introduce-device-arguments
                           :generate-end-of-input-or-char-tests
                           :unexpected-end-of-input
                           :generate-delimiter-test
                           :invalid-input-char)
              ((_ :introduce-device-arguments
                  ?kont . ?rest)
               (?kont (input.string input.length input.index) . ?rest))

              ((_ :invalid-input-char
                  (?input.string ?input.length ?input.index)
                  ?ch)
               #f)

              ((_ :unexpected-end-of-input
                  (?input.string ?input.length ?input.index))
               #f)

              ((_ :generate-delimiter-test
                  ?ch ?ch-is-delimiter-kont ?ch-is-not-delimiter-kont)
               ?ch-is-not-delimiter-kont)

              ((_ :generate-end-of-input-or-char-tests
                  ?ch ?next ?fail
                  (?input.string ?input.length ?input.index)
                  ?end-of-input-kont ?parse-input-char-kont)
               (let-syntax
                   ((?fail (syntax-rules ()
                             ((_) #f)))
                    (?next (syntax-rules ()
                             ((_ ?operator-name ?operator-arg (... ...))
                              (?operator-name ?input.string ?input.length
                                              (fx+ 1 ?input.index)
                                              ?operator-arg (... ...))))))
                 (if (fx=? ?input.index ?input.length)
                     ?end-of-input-kont
                   (let ((?ch (string-ref ?input.string ?input.index)))
                     ?parse-input-char-kont))))
              ))

