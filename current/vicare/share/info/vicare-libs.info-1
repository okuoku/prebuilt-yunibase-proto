This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: Top,  Next: lang,  Up: (dir)

Libraries for Vicare Scheme
***************************

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.

* Menu:

* lang::                        Language extension libraries.
* srfi::                        Scheme Requests For Implementation.
* platform::                    Hosting platform libraries.
* posix::                       The POSIX interface.
* glibc::                       The GNU C Library interface.
* iconv::                       The Libiconv interface.
* linux::                       The GNU+Linux interface.
* args::                        Optional function arguments validation.
* cbuffers::                    Generalised C buffers and strings.
* readline::                    Extended interface to GNU Readline.
* parser logic::                Defining parsers logic.
* gcc::                         A toy library interface to GCC.
* flonum format::               Formatting flonums.
* flonum parser::               Parsing flonums.
* debugging::                   Debugging facilities.
* getopts::                     Parsing command line arguments.
* checks::                      Lightweight testing.
* tracing::                     Tracing syntaxes.
* multimethods::                Multimethods dispatching.

Networking libraries

* net channels::                Interprocess connection channels.

Container libraries

* comparators::                 Comparators.
* iteration thunks::            Iteration thunks.
* lists::                       List library.
* vectors::                     Vector library.
* strings::                     String library.
* char-sets::                   Character sets.
* bytevectors::                 Bytevectors.
* bytevector compounds::        Bytevector compounds.
* kmp::                         Knuth-Morris-Pratt searching.
* levenshtein::                 Levenshtein distance metric.
* wtables::                     Weak hashtables.
* object-properties::           Object properties.
* one-dimension::               One dimensional extended ranges.
* arrays::                      Multidimensional arrays.
* chains::                      Chains of objects.
* stacks::                      Stacks of objects.
* queues::                      Queues of objects.
* deques::                      Double-ended queues of objects.
* binary heaps::                Binary heaps.
* dynamic arrays::              Dynamic arrays.
* bst::                         Binary search trees.
* sets bags::                   Sets and bags.
* bitvectors::                  Bitvectors.
* ilists::                      Immutable lists.
* ralists::                     Random-access lists.
* istacks::                     Common interface to stack-like
                                containers.
* iqueues::                     Common interface to queue-like
                                containers.
* ideques::                     Common interface to deque-like
                                containers.

Adapted libraries

* random::                      Sources of random bits.
* irregex::                     IrRegular expressions.
* pregexp::                     Portable regular expressions for Scheme.
* formations::                  Formatting strings.
* silex::                       A lexical analyser generator.

Library groups

* parser-tools::                Lexers and parsers.

Appendices

* Package License::             GNU General Public License.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* core: (vicare-scheme).        Documentation for Vicare Scheme.
* libffi: (libffi).             Libffi documentation.


File: vicare-libs.info,  Node: lang,  Next: srfi,  Prev: Top,  Up: Top

1 Language extension libraries
******************************

* Menu:

* keywords::                    More facilities for keyword objects.
* cond-expand::                 Feature based conditional expansion.
* include::                     Including source files at expand time.
* amb::                         McCarthy's 'amb' operator.
* simple-match::                Simple destructuring match syntax.
* variables::                   Defining storage locations.
* syntaxes::                    Language syntactic extensions.
* makers::                      Maker syntaxes.
* custom-ports::                Custom ports.
* asciis::                      Utilities for ASCII characters.
* hooks::                       Running lists of functions.
* callables::                   Callable objects.
* c-enums::                     C language flags and flags combinations.
* pipelines::                   Pipelining expressions.
* streams::                     Streams.
* loops::                       Loop constructs.
* comparisons::                 Comparison functions.
* restarts::                    Signaling conditions and restarts.
* ibodies::                     Instantiable bodies.
* tuples::                      Tuples on top of lists and vectors.


File: vicare-libs.info,  Node: keywords,  Next: cond-expand,  Up: lang

1.1 More facilities for keyword objects
=======================================

Keywords are disjoint objects which can be read by Vicare's reader in
'#!vicare' mode, *note (vicare-scheme)iklib reader stx::.  The core
bindings and keyword objects handling is embedded in Vicare's boot
image, but additional facilities are required to make use of keywords.

   The following bindings are exported by the library '(vicare
language-extensions keywords)'.  Additionally the following bindings are
reexported from '(vicare)':

     symbol->keyword         keyword->symbol
     keyword?                keyword=?
     keyword-hash

 -- Syntax: let-keywords ?INPUT ?ARGS ?ALLOW ?OPTIONS-SPEC ?FORM0 ?FORM
          ...
 -- Syntax: let*-keywords ?INPUT ?ARGS ?ALLOW ?OPTIONS-SPEC ?FORM0 ?FORM
          ...
 -- Syntax: letrec-keywords ?INPUT ?ARGS ?ALLOW ?OPTIONS-SPEC ?FORM0
          ?FORM ...
 -- Syntax: letrec*-keywords ?INPUT ?ARGS ?ALLOW ?OPTIONS-SPEC ?FORM0
          ?FORM ...
 -- Auxiliary Syntax: with-argument ?NAME ?DEFAULT ?KEYWORD
 -- Auxiliary Syntax: without-argument ?NAME ?DEFAULT ?KEYWORD
          ?WHEN-GIVEN
     Expand into a 'let' like form whose bindings are configured from a
     list of arguments and options.

     'let-keywords' expands into a 'let' syntax, 'let*-keywords' expands
     into a 'let*' syntax, 'letrec-keywords' expands into a 'letrec'
     syntax, 'letrec*-keywords' expands into a 'letrec*' syntax.

     ?INPUT must be an expression evaluating to a list of values and
     keywords; keywords must be compliant to the specification in
     ?OPTIONS-SPEC.  The same keyword can be present multiple times in
     ?INPUT.

     ?ARGS must be an identifier which will be bound to a list of values
     from ?INPUT not matching any of the options specified in
     ?OPTIONS-SPEC.

     ?ALLOW must be an expression meant to evaluate to '#f' or true;
     when '#f': keyword values in ?INPUT not matched by specifications
     in ?OPTIONS-SPEC will cause an assertion violation; when true:
     keyword values in ?INPUT not matched by specifications in
     ?OPTIONS-SPEC will be collected in ?ARGS.

     ?OPTIONS-SPEC must be null or a list of lists, each with the
     following formats:

          (with-argument ?NAME ?DEFAULT ?KEYWORD)
          (without-argument ?NAME ?DEFAULT ?KEYWORD ?WHEN-GIVEN)

     such specifications are interpreted as follows:

        * The 'with-argument' specification describes an optional
          keyword argument with mandatory value, which must *not* be a
          keyword itself.

        * The 'without-argument' specification describes an optional
          keyword argument without value.

        * ?NAME must be an identifier which will become the name of a
          binding in the output 'let' like syntax.

        * ?DEFAULT must be an expression which will become a the value
          of binding in the output 'let' like syntax.

        * ?KEYWORD must be a keyword object which can be present in
          ?INPUT to mutate the associated ?NAME binding.

        * For keywords with argument: when the ?KEYWORD is present in
          ?INPUT, it must be followed by a value which will become the
          new value of the corresponding ?NAME binding.

        * For keywords without argument: when the ?KEYWORD is present in
          ?INPUT, the value resulting from the evaluation of ?WHEN-GIVEN
          will become the new value of the corresponding ?NAME binding.

     We can imagine the following macro use:

          (let-keywords ?INPUT args #f
              ((with-argument a 1 #:a)
               (with-argument b 2 #:b))
            (alpha)
            (beta))

     to expand to something like:

          (let ((a 1)
                (b 2))
            (let ((args ?OPTIONS-PARSER))
              (alpha)
              (beta)))

     where ?OPTIONS-PARSER is a form which takes care of parsing the
     ?INPUT.

   Examples:

     #!vicare
     (import (vicare)
       (vicare language-extensions keywords))

     ;; options with arguments
     (let-keywords '(#:a 1 #:b 2 #:d 4) args #f
         ((with-argument a #\a #:a)
          (with-argument b #\b #:b)
          (with-argument c #\c #:c)
          (with-argument d #\d #:d))
       (list a b c d args))
     => (1 2 #\c 4 ())

     ;; options without arguments
     (let-keywords '(#:a #:b #:d 4) args #f
         ((without-argument a #\a #:a #\A)
          (without-argument b #\b #:b #\B)
          (without-argument c #\c #:c #\C)
          (with-argument d #\d #:d))
       (list a b c d args))
     => (#\A #\B #\c 4 ())

     ;; options with arguments, leftover arguments
     (let-keywords '(#:a 1 ciao #:b 2 hello #:d 4) args #f
         ((with-argument a #\a #:a)
          (with-argument b #\b #:b)
          (with-argument c #\c #:c)
          (with-argument d #\d #:d))
       (list a b c d args))
     => (1 2 #\c 4 (ciao hello))

     ;; no options, allow unknown
     (let-keywords '(#:a 1 #:b 2 #:d 4) args #t
         ()
       args)
     => (#:a 1 #:b 2 #:d 4)

     (let-keywords '(#:a) args #f
         ()
       args)
     error-> unknown option #:a

     (let-keywords '(#:a #:b 123) args #t
         ((with-argument a 1 #:a)
          (with-argument b 2 #:b))
       args)
     error-> option value for #:a cannot be a keyword

     (let-keywords '(#:a) args #t
         ((with-argument a 1 #:a)
          (with-argument b 2 #:b))
       args)
     error-> option #:a requires argument

     ;; keywords used multiple times
     (let-keywords '(#:verbose #:verbose #:verbose) args #f
       ((without-argument verbosity 0 #:verbose (+ 1 verbosity)))
       verbosity)
     => 3


File: vicare-libs.info,  Node: cond-expand,  Next: include,  Prev: keywords,  Up: lang

1.2 Feature based conditional expansion
=======================================

The following bindings are exported by the library '(vicare
language-extensions cond-expand)'.

 -- Syntax: define-cond-expand ?COND-EXPAND ?FEATURE-FUNC ...
     Expand to the definition of a syntax like 'cond-expand' supporting
     all the features of the 'cond-expand' from SRFI-0 and in addition
     supporting the features specified by a set of functions.  *note
     Features supported by Vicare: srfi cond-expand vicare.

     ?COND-EXPAND must be an identifier representing the name of the new
     syntax.

     The optional ?FEATURE-FUNC arguments must be expressions which,
     evaluated only once at expand time, must return functions; each of
     such functions must accept as single argument an identifier
     representing a feature and must return as single argument: '#t' if
     the feature is supported, '#f' otherwise.

   In the following example we define a 'cond-expand' syntax just like
the one exported by SRFI-0:

     #!r6rs
     (import (rnrs)
       (vicare language-extensions cond-expand))

     (define-cond-expand cond-expand)

     (cond-expand
       ((and srfi-0 srfi-1)  #t)
       (else                 #f))
     ==> #t

in the following example we define a 'cond-expand' that additionally
recognises the features 'write' and 'display':

     #!r6rs
     (import (rnrs)
       (vicare language-extensions cond-expand))

     (define-cond-expand cond-expand
       (lambda (id)
         (free-identifier=? id #'display))
       (lambda (id)
         (free-identifier=? id #'write)))

     (cond-expand
       ((or display write)   #t)
       (else                 #f))
     ==> #t

   The following bindings are exported by the library '(vicare
language-extensions cond-expand helpers)'.

 -- Syntax: define-cond-expand-identifiers-helper ?WHO ?FEATURE-CLAUSE
          ...
     Expand to the definition of a function bound to ?WHO which can be
     used as feature function in uses of the macro 'define-cond-expand'.

     Each of the optional ?FEATURE-CLAUSE must have the following
     format:

          (?FEATURE-ID ?EXPR)

     where ?FEATURE-ID must be the feature identifier and ?EXPR must be
     an expression.  The generated function compares the given
     identifier with each of ?FEATURE-ID, using 'free-identifier=?':

        * If the result is '#t': evaluate ?EXPR and return the result.

        * If the result is '#f': move on to the next ?FEATURE-ID.

        * If no more ?FEATURE-ID are left: return '#f'.

   In the following example we define a 'cond-expand' that additionally
recognises the features 'write' and 'display':

     #!r6rs
     (import (rnrs)
       (vicare language-extensions cond-expand)
       (for (vicare language-extensions cond-expand)
            expand))

     (define-cond-expand cond-expand
       (let ()
         (define-cond-expand-identifiers-helper help
           (display        #t)
           (write          #t))
         help))

     (cond-expand
       ((or display write)   #t)
       (else                 #f))
     ==> #t


File: vicare-libs.info,  Node: include,  Next: amb,  Prev: cond-expand,  Up: lang

1.3 Including source files at expand time
=========================================

The following bindings are exported by the library '(vicare
language-extensions include)'.

 -- Syntax: include FILENAME
     Include in the current source file the contents of the file
     selected by the pathname FILENAME, which must be a string.
     Everything happens as if the code was present in place of the
     'include' form.

 -- Syntax: include/lexical-context FILENAME IDENTIFIER
     Include in the current source file the contents of the file
     selected by the pathname FILENAME, which must be a string.
     IDENTIFIER must be a Scheme identifier and it is used to assign a
     lexical context to the sourced code.


File: vicare-libs.info,  Node: amb,  Next: simple-match,  Prev: include,  Up: lang

1.4 McCarthy's 'amb' operator
=============================

The library '(vicare language-extensions amb)' defines McCarthy's 'amb'
operator and a set of related utilities.  The "ambiguous operator"
allows the execution of depth-first search in a tree of choices
integrated in the normal control flow of a Scheme program; it is built
upon continuations.

   The 'amb' operator was briefly defined in:

     John McCarthy.  "A Basis for a Mathematical Theory of Computation".
     In Computer Programming And Formal Systems by P. Braffort and D.
     Hirschberg (Ed.), 1963.

and further discussed in:

     Ramin Zabih, David McAllester, and David Chapman.
     "Non-deterministic Lisp with dependency-directed backtracking".  In
     Proc.  Proceedings of the Sixth National Conference on Artificial
     Intelligence, pp.  59-64, 1987.

* Menu:

* amb api::                     Programming interface for 'amb'.
* amb examples::                Usage examples for 'amb'.


File: vicare-libs.info,  Node: amb api,  Next: amb examples,  Up: amb

1.4.1 Programming interface for 'amb'
-------------------------------------

* Menu:

* amb api core::                Core 'amb' syntaxes.
* amb api random::              Random selection of choices.
* amb api generator::           Generating choices.
* amb api utilities::           Utility functions and syntaxes.
* amb api condition::           Condition object types.


File: vicare-libs.info,  Node: amb api core,  Next: amb api random,  Up: amb api

1.4.1.1 Core 'amb' syntaxes
...........................

The following bindings are exported by the library '(vicare
language-extensions amb)'.

 -- Syntax: with-ambiguous-choices ?BODY0 ?BODY ...
     Initialise the dynamic environment for a new 'amb' search and in
     such environment evaluates the ?BODY forms.  Return the result of
     the last form.

 -- Syntax: with-amb-exhaustion-handler ?HANDLER ?THUNK
     Install in the dynamic environment a custom handler for search tree
     exhaustion.  This syntax should be used in the body of
     'with-ambiguous-choices', but before the first use of 'amb'.

     ?HANDLER must be an expression evaluating to a thunk: such thunk is
     called by 'amb' whenever no more choices are available.  ?THUNK
     must be an expression evaluating to a thunk: it is evaluated while
     the custom handler is installed.

 -- Syntax: amb ?EXPR ...
     Evaluate one of the ?EXPR expressions and return its result; save
     in the dynamic environment a continuation that can be reinstated to
     reject the result of this ?EXPR and try with the next ?EXPR.  The
     ?EXPR arguments are tried in the given order: left to right.

     If the result of evaluating an ?EXPR is a promise (produced by
     'delay'): the promise is forced to produce the result.

     When used with no arguments: reject the result of the most recent
     EXPR and reinstate the previous continuation to try the next EXPR.

     When all the choices have been tried: raise a non-continuable
     exception with condition object components '&who', '&message',
     '&amb-exhaustion'.

     It is an error if 'amb' is used outside the dynamic environment
     prepared by 'with-ambiguous-choices'.


File: vicare-libs.info,  Node: amb api random,  Next: amb api generator,  Prev: amb api core,  Up: amb api

1.4.1.2 Random selection of choices
...................................

The following bindings are exported by the library '(vicare
language-extensions amb)'.

 -- Syntax: amb-permute ?EXPR ...
     Like 'amb' but permute the order of the given expressions.  The
     permutation determining the selection order is generated at every
     first execution of the expanded code, using the random fixnum
     generator referenced by 'amb-random-fixnum-maker'.

     If we define the following function:

          (define (choose)
            (amb 1 2 3))

     a new permutation is generated at every function invocation.

 -- Syntax: amb-permute ?EXPR ...
     Like 'amb' but randomly select an expression to evaluate; the same
     expression can be selected multiple times.  This syntax never
     finishes choices.  The next expression to evaluate is selected
     using the random fixnum generator referenced by
     'amb-random-fixnum-maker'.

 -- Parameter: amb-random-fixnum-maker
     Hold a procedure accepting a fixnum as single argument: when
     applied to the fixnum N it must return a fixnum in the range [0,
     N). It is initialised with 'random' from the library '(vicare)',
     *note random: (vicare-scheme)iklib misc.


File: vicare-libs.info,  Node: amb api generator,  Next: amb api utilities,  Prev: amb api random,  Up: amb api

1.4.1.3 Generating choices
..........................

The following bindings are exported by the library '(vicare
language-extensions amb)'.

 -- Function: amb-thunk GENERATOR-THUNK
     Like 'amb' but generate the next choice by evaluating a thunk.
     GENERATOR-THUNK must be a thunk, which, when evaluated, returns the
     next choice; when no more choices are available GENERATOR-THUNK
     must evaluate '(amb)'.

          #!r6rs
          (import (vicare)
            (vicare language-extensions amb))

          (define-values (empty? enqueue! dequeue!)
            (make-queue '(1 2 3 4)))

          (define (generator)
            (if (empty?)
                (amb)
              (dequeue!)))

          (with-ambiguous-choices
           (let ((R (amb-thunk generator)))
             (amb-assert (<= 3 R))
             R))
          => 3


File: vicare-libs.info,  Node: amb api utilities,  Next: amb api condition,  Prev: amb api generator,  Up: amb api

1.4.1.4 Utility functions and syntaxes
......................................

The following bindings are exported by the library '(vicare
language-extensions amb)'.

 -- Syntax: amb-assert ?EXPR
     Evaluate ?EXPR and if the result is true return it; if the result
     is false reject the latest 'amb' choice.

          (amb-assert ?EXPR) ==> (or ?EXPR (amb))

 -- Parameter: amb-backtrack-log
     Hold a thunk to be called every time 'amb', or any of its
     derivatives, backtracks to reject a previous choice.  It is
     initialised to 'void'.


File: vicare-libs.info,  Node: amb api condition,  Prev: amb api utilities,  Up: amb api

1.4.1.5 Condition object types
..............................

Search tree exhaustion
......................

 -- Condition Type: &amb-exhaustion
     Condition type used to signal the exhaustion of a search tree
     visited by 'amb'; it is derived from '&condition'.

 -- Function: make-amb-exhaustion
     Build and return a new instance of '&amb-exhaustion'.

 -- Function: amb-exhaustion? OBJ
     Return '#t' if OBJ is an instance of '&amb-exhaustion', else return
     '#f'.

Search not initialised
......................

 -- Condition Type: &amb-not-initialised
     Condition type used to tag the compound condition object raised
     whenever 'amb' is used outside the dynamic environment prepared by
     'with-ambiguous-choices'; it is derived from '&assertion'.

 -- Function: make-amb-not-initialised
     Build and return a new instance of '&amb-not-initialised'.

 -- Function: amb-not-initialised? OBJ
     Return '#t' if OBJ is an instance of '&amb-not-initialised', else
     return '#f'.


File: vicare-libs.info,  Node: amb examples,  Prev: amb api,  Up: amb

1.4.2 Usage example for 'amb'
-----------------------------

* Menu:

* amb examples simple::         Introductory examples.
* amb examples ssc::            Seed, square, cube.
* amb examples coloring::       Graph coloring.


File: vicare-libs.info,  Node: amb examples simple,  Next: amb examples ssc,  Up: amb examples

1.4.2.1 Introductory examples
.............................

In all the examples of this section we will assume that the following
prelude opens the program:

     #!r6rs
     (import (vicare)
       (vicare language-extensions amb))

   The 'amb' operator requires appropriate initialisation of the dynamic
environment, so if we just evaluate the following form we will get an
error:

     (amb)
     error-> &amb-not-initialised

   If we initialise the environment and then just call 'amb', we get an
"exhausted search tree" error:

     (with-ambiguous-choices
      (amb))
     error-> &amb-exhaustion

because there are no choices, so the search terminates immediately.

   If we apply 'amb' to some choices, it will return the first one:

     (with-ambiguous-choices
      (amb 1 2 3))
     => 1

   If we want to see an actual use of 'amb', we have to reject some
choices.  Let's look at this program:

     (with-ambiguous-choices
      (let ((X (amb 1 2 3)))
        (amb-assert (even? X))
        X))
     => 2

this is what happens:

  1. 'amb' returns the result of the first expression: '1'.

  2. 'amb-assert' rejects '1' because it is odd; the execution flow
     jumps back to the form '(amb 1 2 3)'.

  3. 'amb' returns the result of the next expression: '2'.

  4. 'amb-assert' accepts '2' because it is even.

  5. The result is '2'.

The custom failure handler
..........................

The syntax 'with-amb-exhaustion-handler' allows us to install a custom
handler for the event "exhausted search tree"; the installed handler is
called by 'amb' whenever no more choices are available.  As example, if
we want a non-local exit at the end of a failed search, we can do:

     (call/cc
         (lambda (escape)
           (with-ambiguous-choices
            (with-amb-exhaustion-handler
                (lambda ()
                  (escape #t))
              (lambda ()
                (amb)
                #f)))))
     => #t


File: vicare-libs.info,  Node: amb examples ssc,  Next: amb examples coloring,  Prev: amb examples simple,  Up: amb examples

1.4.2.2 Seed, square, cube
..........................

Given the seed numbers:

     1 3

let's say we want to select the one having the square among:

     5 9 11

and the cube among:

     13 27 31

we can imagine a search tree, *note amb examples ssc: fig:amb_ssc_tree.

          | A |    | B |    | C |

     o----- 1 -----  5 ----- 13
        |       |        |-- 27
        |       |         -- 31
        |       |
        |       |--  9 ----- 13
        |       |        |-- 27
        |       |         -- 31
        |       |
        |        -- 11 ----- 13
        |                |-- 27
        |                 -- 31
        |
         -- 3 -----  5 ----- 13
                |        |-- 27
                |         -- 31
                |
                |--  9 ----- 13
                |        |-- 27
                |         -- 31
                |
                 -- 11 ----- 13
                         |-- 27
                          -- 31

Figure 1.1: Search tree for the seed, square, cube problem.

   If we assign a selected seed to the variable A, a selected possible
square to the variable B and a selected possible cube to the variable C,
we want search for a tuple (A, B, C) satisfying the constraints: A^2 =
B, A^3 = C.

   To select among the seeds we use the syntax:

     (amb 1 3)

to select among the possible squares we use the syntax:

     (amb 5 9 11)

to select among the possible cubes we use the syntax:

     (amb 13 27 31)

and the constraints can be expressed by the predicates:

     (= (square A) B)
     (= (cube   A) C)

the resulting program follows:

     #!r6rs
     (import (vicare)
       (vicare language-extensions amb))

     (with-ambiguous-choices
       (let* ((A (amb 1 3))
              (B (amb 5 9 11)))
         (amb-assert (= (square A) B))
         (let ((C (amb 13 27 31)))
           (amb-assert (= (cube A) C))
           (list A B C))))
     => (3 9 27)

   We can modify the program to show the search path:

     #!r6rs
     (import (vicare)
       (vicare language-extensions amb))

     (define (print . args)
       (apply fprintf (current-error-port) args))

     (with-ambiguous-choices
      (let ((A (amb 1 3)))
        (print "A=~a\n" A)
        (let ((B (amb 5 9 11)))
          (print "\tB=~a\n" B)
          (amb-assert (= (square A) B))
          (let ((C (amb 13 27 31)))
            (print "\t\tC=~a\n" C)
            (amb-assert (= (cube A) C))
            (list A B C)))))
     => (3 9 27)
     -| A=1
     -|         B=5
     -|         B=9
     -|         B=11
     -| A=3
     -|         B=5
     -|         B=9
     -|                 C=13
     -|                 C=27


File: vicare-libs.info,  Node: amb examples coloring,  Prev: amb examples ssc,  Up: amb examples

1.4.2.3 Graph coloring
......................

The following program shows how to select colors to paint European
nations on map: given a map of nations we want to paint each nation with
a color different from the one of its neighbors; it is known that 4
colors are always enough (even though more than 4 colors are
aesthetically better).  The code is derived from an example in "Teach
Yourself Scheme in Fixnum Days" by Dorai Sitaram.

   We start with the prelude:

     #!r6rs
     (import (vicare)
       (vicare language-extensions amb)
       (only (vicare language-extensions syntaxes)
             define-values))

   We represent the map with a graph: one node for each nation; nations
that face each other are connected by a link.  We select the adjacency
list representation.  We want to make sure that we have correctly
defined the graph: two nodes connected by a link must be present in the
adjacency list of each other.  A better graph definition syntax would
have integrated this check.

     (define-record-type node
       (fields (immutable name)
               ;;List of NODE  records representing the adjacency
               ;;list of this node.
               (mutable neighbors)
               ;;Symbol representing this node's color.
               (mutable color))
       (protocol (lambda (maker)
                   (lambda (name)
                     (maker name '() #f)))))

     (define-syntax define-nodes
       (syntax-rules ()
         ((_ ?nodes-var (?node (?neighbor ...)) ...)
          (begin
            (define ?node (make-node (quote ?node)))
            ...
            (module ()
              (node-neighbors-set! ?node (list ?neighbor ...))
              ...)
            (define ?nodes-var
              (list ?node ...))
            (module ()
              (assert-graph-consistency ?nodes-var))))
         ))

     (define (assert-graph-consistency nodes)
       ;;Verify that every node is  present in the adjacency list
       ;;of all its neighbors.
       ;;
       (define who 'assert-graph-consistency)
       (for-each
           (lambda (node)
             (for-each
                 (lambda (neighbor)
                   (unless (memq node (node-neighbors neighbor))
                     (assertion-violation who
                       "incorrect node links"
                       (node-name node)
                       (node-name neighbor))))
               (node-neighbors node)))
         nodes))

   We are interested in nations that face each other, even when there is
a sea between them; for example: it is aesthetically more pleasant if
France and the United Kingdom are painted in different colors.

     (define-nodes europe-facing-nations
       (portugal        (spain))
       (spain           (portugal andorra france))
       (andorra         (spain france))
       (france          (spain andorra monaco italy
                         switzerland germany luxembourg
                         belgium united-kingdom))
       (united-kingdom  (france belgium netherlands denmark
                         norway iceland ireland))
       (ireland         (united-kingdom iceland))
       (monaco          (france))
       (italy           (france greece albania montenegro
                         croatia slovenia austria switzerland
                         san-marino))
       (san-marino      (italy))
       (switzerland     (france italy austria germany
                         liechtenstein))
       (liechtenstein   (switzerland austria))
       (germany         (france switzerland austria czech-republic
                         poland sweden denmark netherlands
                         belgium luxembourg))
       (belgium         (france luxembourg germany netherlands
                         united-kingdom))
       (netherlands     (belgium germany united-kingdom))
       (luxembourg      (france germany belgium))
       (austria         (italy slovenia hungary slovakia
                         czech-republic germany switzerland
                         liechtenstein))
       (slovenia        (italy croatia hungary austria))
       (croatia         (italy montenegro bosnia serbia hungary
                         slovenia))
       (bosnia          (croatia montenegro serbia))
       (montenegro      (croatia italy albania serbia bosnia))
       (albania         (italy greece macedonia serbia
                         montenegro))
       (greece          (italy cyprus bulgaria macedonia albania))
       (cyprus          (greece))
       (macedonia       (albania greece bulgaria serbia))
       (bulgaria        (macedonia greece romania serbia))
       (serbia          (montenegro albania macedonia bulgaria
                         romania hungary croatia bosnia))
       (romania         (serbia bulgaria hungary))
       (hungary         (slovenia croatia serbia romania slovakia
                         austria))
       (slovakia        (austria hungary poland czech-republic))
       (czech-republic  (germany austria slovakia poland))
       (poland          (germany czech-republic slovakia sweden))
       (denmark         (united-kingdom germany sweden norway))
       (sweden          (norway denmark germany poland finland))
       (norway          (united-kingdom denmark sweden finland
                         iceland))
       (finland         (sweden norway))
       (iceland         (ireland united-kingdom norway)))

   The only use of 'amb' is in the function that selects a color for a
nation.  We use 'amb-permute', rather than the plain 'amb', to try
assigning a different first color to the nations (statistically
speaking).

     (define (choose-color)
       ;;Every time we call this function: we start a new choice.
       ;;
       (amb-permute 'red 'yellow 'blue 'green))

   We validate a possible solution with 'amb-assert', checking that a
node/nation has color different from the one of its neighbors:

     (define (validate-all-nodes-color all-nodes)
       (for-all validate-single-node-color all-nodes))

   To build a "better" starting point, we also want to test the color of
a single node against the colors of its neighbors while we are building
the initial choice.  When calling this function: the neighbors may not
have a color yet: their 'color' field can be set to '#f'.

     (define (validate-single-node-color node)
       (amb-assert (not (memq (node-color node)
                              (map node-color
                                (node-neighbors node))))))

   The actual coloring function that selects a color for each nation and
validates the solution until all the constraints are satisfied:

     (define (color-nations nations)
       (with-ambiguous-choices
        ;;Build an initial choice.
        (for-each
            (lambda (nation)
              (node-color-set! nation (choose-color))
              (validate-single-node-color nation))
          nations)
        ;;Validate the choice and backtrack if needed.
        (validate-all-nodes-color nations)))

   We also need to display the result:

     (define (print-colors nations)
       (for-each
           (lambda (nation)
             (print "~a: ~a\n"
                    (node-name nation)
                    (node-color nation))
             (for-each
                 (lambda (neighbor)
                   (print "\t~a: ~a\n"
                          (node-name neighbor)
                          (node-color neighbor)))
               (node-neighbors nation)))
         europe-facing-nations))

     (define (print . args)
       (apply fprintf (current-error-port) args))

   Run it:

     (color-nations europe-facing-nations)
     (print-colors  europe-facing-nations)


File: vicare-libs.info,  Node: simple-match,  Next: variables,  Prev: amb,  Up: lang

1.5 Simple destructuring match syntax
=====================================

The library '(vicare language-extensions simple-match)' provides a
simple implementation of the destructuring-bind 'match' syntax; it is
*not* a fully featured 'match' syntax.

   It has two purposes: being a single macro transformer, without
dependencies on external libraries, it can be used in the code of
Vicare's boot image; being simple, its code can be used as starting
point to implement more complex destructuring syntaxes.

   The supported syntax is *different* from the one of the popular
matching libraries by Alex Shinn and Andrew Wright.

* Menu:

* simple-match syntax::         Pattern matcher generator.


File: vicare-libs.info,  Node: simple-match syntax,  Up: simple-match

1.5.1 Pattern matcher generator
-------------------------------

The following bindings are exported by the library '(vicare
languae-extensions simple-match)'.  The auxiliary syntaxes are the
bindings exported by the library '(vicare)', which are reexported by
this library.

 -- Syntax: match ?EXPR ?CLAUSE ...
 -- Auxiliary Syntax: =>
 -- Auxiliary Syntax: else
 -- Auxiliary Syntax: let
 -- Auxiliary Syntax: quote
 -- Auxiliary Syntax: quasiquote
 -- Auxiliary Syntax: syntax
 -- Auxiliary Syntax: and
 -- Auxiliary Syntax: or
 -- Auxiliary Syntax: not
 -- Auxiliary Syntax: apply
 -- Auxiliary Syntax: eval
 -- Auxiliary Syntax: ...
 -- Auxiliary Syntax: _
     Match the symbolic expression ?EXPR against the ?CLAUSE arguments.
     Each clause must have one of the formats:

          (?PATTERN ?BODY ...)
          (?PATTERN (=> ?NEXT) ?BODY ...)
          (else ?BODY0 ?BODY ...)

     ?EXPR is evaluated once and the result is matched against each
     ?PATTERN in turn; the first to succeed causes the corresponding
     ?BODY forms to be evaluated as in 'begin', and the remaining
     patterns are ignored.  However, if the ?NEXT identifier is labeled,
     it may be used as a continuation to continue matching, allowing for
     additional runtime tests on the pattern.

     A clause with no body '(?PATTERN)', when matching the input
     expression, causes the evaluation of '(values)' (which returns zero
     values).

   The syntax for the patterns is:

'_'
     The literal underscore is the wildcard: it matches anything, it
     does not reference any variable.

          (match "ciao"
            (_            #t)
            (else         #f))
          => #t

          (match '(1 2 3)
            (_            #t)
            (else         #f))
          => #t

          (match '(1 2 3)
            ((_ _ _)      #t)
            (else         #f))
          => #t

          (match '(1 2 3)
            ((_ 2 _)      #t)
            (else         #f))
          => #t

          (match '(1 2 3)
            ((_ 0 _)      #t)
            (else         #f))
          => #f

'?DATUM'
     Matches if the input expression equals ?DATUM.  The pattern ?DATUM
     can be a boolean, character, fixnum, bignum, ratnum, flonum,
     cflonum, compnum, string or bytevector; such data is compared to
     the input expression using type-specific predicates and unsafe
     accessors.

          (match 1
            (1            #t)
            (else         #f))
          => #t

'?VARIABLE'
     Variable reference: it matches the value bound to ?VARIABLE using
     'equal?'.

          (let ((X 1))
            (match 1
              (X          #t)
              (else       #f)))
          => #t

          (let ((X 1))
            (match 1
              (X          X)
              (else       #f)))
          => 1

'(let ?VARIABLE)'
     Bind the value of the input expression to ?VARIABLE, which must be
     an identifier; the variable is immediately available to be
     referenced in the following subpatterns.  The empty 'let' pattern
     is a syntax error; the 'let' pattern with multiple subpatterns is a
     syntax error, with the exception of the variable with ellipsis.

          (match 1
            ((let X)      X)
            (else         #f))
          => 1

          (match 1
            ((let X)      #\A)
            (else         #f))
          => #\A

          (match '(1)
            ((let X)      X)
            (else         #f))
          => (1)

          (match '(1)
            (((let X))    X)
            (else         #f))
          => 1

          (match '(1 2 3)
            (((let X) (let Y) (let Z))
             (vector X Y Z))
            (else #f))
          => #(1 2 3)

          (match '(1 2)
            (((let X) (let Y) (let Z))
             (vector X Y Z))
            (else #f))
          => #f

          (match '(1 (2 3))
            (((let X) (let X) (let X))
             X)
            (else #f))
          => 3

          (match 123
            ((and (let X) (eval (positive? X)))
             X)
            (else #f))
          => 123

          (match '(1 2 3)
            (((and (apply number?)
                   (let N1))
              . (and (apply (lambda (obj)
                              (for-all number? obj)))
                     (let N)))
             (vector N1 N))
            (else #f))
          => #(1 (2 3))

'(let ?VARIABLE ...)'
     This pattern can appear only as last subpattern of a list or vector
     pattern.  Bind the rest of the input expression to ?VARIABLE, which
     must be an identifier, as a list; the variable is immediately
     available to be referenced in the following subpatterns.

          (match '(1 2 3 4 5)
            (((let X) (let Y) (let Z ...))
             (vector X Y Z))
            (else #f))
          => #(1 2 (3 4 5))

          (match '(1 2)
            (((let X) (let Y) (let Z ...))
             (vector X Y Z))
            (else #f))
          => #(1 2 ())

          (match '(1 2 . 3)
            (((let X) (let Y) (let Z ...))
             (vector X Y Z))
            (else #f))
          => #f

          (match '(1 2 3 4 . 5)
            (((let X) (let Y) (let Z ...))
             (vector X Y Z))
            (else #f))
          => #f

          (match '(1 2 3)
            ((let id ...)         #\A)
             (else                #\B))
          error-> &syntax

          (match '(1 2 3 4)
            (((and (apply number?) (let N1))
              (and (apply number?) (let N))
              ...)
             (vector N1 N))
            (else #f))
          => (#(1 2) #(1 3) #(1 4))

'(quote ?DATUM)'
     A quoted datum; it matches if it is equal to the input expression
     according to 'equal?'.  As special case: if ?DATUM is a symbol, it
     is compared to the input expression with 'eq?'.

          (match '(1 2 3)
            ('(1 2 3)     #t)
            (else         #f))
          => #t

          (match '(1 X 3)
            ('(1 X 3)     #t)
            (else         #f))
          => #t

          (match '(1 X 3)
            ((1 'X 3)     #t)
            (else         #f))
          => #t

'(quasiquote ?DATUM)'
     A quasiquoted datum; it matches if it the result of the
     quasiquotation is equal to the input expression according to
     'equal?'.

          (let ((X 2))
            (match '(2 2)
              (`(1 ,X)    #\A)
              (`(2 ,X)    #\B)
              (`(3 ,X)    #\C)
              (else       #f)))
          => #\B

'(syntax ?PATTERN)'
'(syntax ?PATTERN (?LITERAL ...))'
     A 'syntax-case' pattern with optional literal identifiers; the
     matching code is built as follows:

          (syntax-case input-expr (?LITERAL ...)
            (?PATTERN
             #;success)
            (_
             #;failure))

     the body of the clause can access pattern variables in the same way
     they are accessed from the output expression of a 'syntax-case'
     use.

          (match '(1 2 3)
            ((syntax (1 2 3))
             #t)
            (else #f))
          => #t

          ;;match an identifier
          (let ((ciao #f))
            (match #'ciao
              ((syntax ciao (ciao))
               #t)
              (else #f)))
          => #t

          ;;match pattern variables
          (let ((ciao #f))
            (match '(1 2 3)
              ((syntax (a b c))
               (syntax->datum #'b))
              (else #f)))
          => 2

'()'
'(?PATTERN1 --- ?PATTERNN)'
     Null or proper list of N elements.

          (match '()
            (()
             #t)
            (else #f))
          => #t

          (match '(1 2 3)
            ((1 2 3)
             #t)
            (else #f))
          => #t

'(?PATTERN1 --- ?PATTERNN . ?PATTERNN+1)'
     Improper list of N or more elements.

          (match '(1 . 2)
            ((1 . 2)
             #t)
            (else #f))
          => #t

          (match '(1 2 3 . 4)
            ((1 2 3 . 4)
             #t)
            (else #f))
          => #t

'(?PATTERN1 --- ?PATTERNN ?PATTERNN+1 ...)'
     List of N or more elements with terminating ellipsis; each element
     of remainder must match ?PATTERNN+1.  The body is evaluated once
     for every element matched by the pattern before the ellipsis and
     the results are returned in a list.

          (match '(1)
            ((1 ...)      #t)
            (else         #f))
          => (#t)

          (match '(1 1)
            ((1 ...)      #t)
            (else         #f))
          => (#t #t)

          (match '(1 1 1)
            ((1 ...)      #t)
            (else         #f))
          => (#t #t #t)

          (match '(1 2)
            ((0 1 ...)    #t)
            (else         #f))
          => #f

          (match '(1 2 3)
            (((let X) ...)
             (+ 10 X))
            (else #f))
          => (11 12 13)

          (match '(1 2 3)
            (((let X) (let Y) ...)
             (vector X Y))
            (else #f))
          => (#(1 2) #(1 3))

          (match '((1 2 3) (4 5 6) (7 8 9))
            ((((let X) (let Y) (let Z)) ...)
             (vector X Y Z))
            (else #f))
          => (#(1 2 3) #(4 5 6) #(7 8 9))

          (match '((1 2 3)
                   (4 5 6)
                   (7 8 9))
            ((((let X) (let Y) ...) ...)
             (vector X Y))
            (else #f))
          => ((#(1 2) #(1 3))
              (#(4 5) #(4 6))
              (#(7 8) #(7 9)))

'#(?PATTERN1 --- ?PATTERNN)'
     Vector of N elements.

          (match '#(1 2 3)
            (#(1 2 3)
             #t)
            (else #f))
          => #t

'#(?PATTERN1 --- ?PATTERNN ?PATTERNN+1 ...)'
     Vector of N or more elements with terminating ellipsis; each
     element of remainder must match ?PATTERNN+1.  The body is evaluated
     once for every element matched by the pattern before the ellipsis
     and the results are returned in a list.

          (match '#(1 1 1)
            (#(1 ...)       #t)
            (else           #f))
          => (#t #t #t)

'(and ?PATTERN ---)'
     Matches if each ?PATTERN matches the input expression.  The empty
     'and' succeeds.

          (match 123
            ((and (apply fixnum?) (apply positive?))
             #t)
            (else #f))
          => #t

          (match 123
            ((and (apply fixnum?) (let X))
             X)
            (else #f))
          => 123

          (match 123
            ((and (let X) X)
             X)
            (else #f))
          => 123

'(or ?PATTERN ---)'
     Matches if at least one ?PATTERN matches the input expression.  The
     empty 'or' fails.

          (match 1
            ((or 1 2)
             #t)
            (else #f))
          => #t

          (match 1
            ((or (apply fixnum?) (apply bignum?))
             #t)
            (else #f))
          => #t

'(not ?PATTERN)'
     Matches if the subpattern ?PATTERN does *not* match the input
     expression.  The empty not fails.  The empty 'not' pattern is a
     syntax error; the 'not' pattern with multiple subpatterns is a
     syntax error.

          (match 9
            ((not 1)
             #t)
            (else #f))
          => #t

          (match "ciao"
            ((not (apply fixnum?))
             #t)
            (else #f))
          => #t

'(apply ?PRED ---)'
     Each ?PRED subpattern must be an expression; every time this
     pattern is matched against an input expression: ?PRED is evaluated;
     the value returned by ?PRED must be a predicate function.  This
     pattern matches if all the predicate functions return true when
     applied to the input expression; the empty 'apply' pattern is a
     syntax error.

          (match 1
            ((apply fixnum? positive?)
             #t)
            (else #f))
          => #t

          (match 1
            ((apply (lambda (x)
                      (and (fixnum?   x)
                           (positive? x))))
             #t)
            (else #f))
          => #t

'(eval ?EXPR)'
     The subpattern ?EXPR must be expression; every time this pattern is
     matched against an input expression: ?EXPR is evaluated.  This
     pattern matches if the result of ?EXPR is true.  The empty 'eval'
     pattern is a syntax error; the 'eval' pattern with multiple
     subpatterns is a syntax error.

          (match 1
            ((eval #t)
             #t)
            (else #f))
          => #t

          (match 1
            ((eval #f)    #\A)
            (else         #f))
          => #t

          (match #t
            ((and (let X) (eval X))
             #t)
            (else #f))
          => #t

          (match #f
            ((and (let X) (eval X))
             #t)
            (else #f))
          => #f

          (match '(1 2)
            (((let X) (eval X)) ;ignores 2, but consumes it
             X)
            (else #f))
          => 1

          (match '(1 2 3)
            (((let X) (eval X) (let Y)) ;ignores 2, but consumes it
             (vector X Y))
            (else #f))
          => #(1 3)

   When the escape identifier is present, it is bound to a thunk to be
evaluated to jump to matching the next pattern or to the "no match"
error.

     (match '(1 2 3)
       ((1 2 3)
        (=> escape)
        #t)
       (else #f))
     => #t

     (match '(1 2 0)
       ((1 2 3)
        (=> escape)
        #t)
       (else #f))
     => #f

     (match '(1 2 3)
       ((1 2 3)
        (=> escape)
        (escape))
       (else #f))
     => #f

     (match '(1 2 3)
       ((1 2 3)
        (=> escape)
        (escape))
       ((1 2 3)
        #t)
       (else #f))
     => #t

     (match '(1 2 3)
       ((1 2 3)
        (=> escape)
        (escape)))
     error-> &error


File: vicare-libs.info,  Node: variables,  Next: syntaxes,  Prev: simple-match,  Up: lang

1.6 Defining storage locations
==============================

The library '(vicare language-extensions variables)' provides a way to
define simple storage locations similar to the variables used in many
languages.  The 'variable' type is disjoint from the other types.

   The following bindings are exported by the library '(vicare
language-extensions variables)'; the bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: make-variable
 -- Function: make-variable OBJ
     Build and return a new 'variable' object.  The 'variable' is
     initialised to OBJ, which defaults to the return value of '(void)'.

 -- Function: variable? OBJ
     Return '#t' if OBJ is a 'variable' object, else return '#f'.

 -- Function: variable-set! VARIABLE OBJ
 -- Function: variable-ref VARIABLE
 -- Function: $variable-set! VARIABLE OBJ
 -- Function: $variable-ref VARIABLE
     Setter and getter for the value of 'variable' objects.

 -- Syntax: define-variable ?NAME
 -- Syntax: define-variable ?NAME OBJ
 -- Syntax: define-variable (?NAME . ?FORMALS) ?BODY
     Like 'define', but store the value in a newly built 'variable'
     object, which is then bound to ?NAME.  Example:

          (import (vicare)
            (vicare language-extensions variables))

          (define-variable v 123)
          v => 123
          (set! v 456)
          v => 456

     While 'define' defines a binding which, when exported by a library,
     cannot be modified, 'define-variable' allocates a storage location,
     so the value bound to ?NAME can be modified at will.

 -- Syntax: define-variable-alias ?NAME ?VARIABLE-EXPR
 -- Syntax: $define-variable-alias ?NAME ?VARIABLE-EXPR
     Like the second form of 'define-variable', but accept as second
     argument an expression which, when evaluated, returns a 'variable'
     object.


File: vicare-libs.info,  Node: syntaxes,  Next: makers,  Prev: variables,  Up: lang

1.7 Language syntactic extensions
=================================

The library '(vicare language-extensions syntaxes)' provides bindings to
macros that extend the Scheme language implemented by '(vicare)' and
'(rnrs)'.

* Menu:

* syntaxes defines::            Special definitions.
* syntaxes bindings::           Special local bindings.
* syntaxes sequencing::         Sequencing execution.
* syntaxes conversion::         Converting common arguments.
* syntaxes args::               Arguments validation.
* syntaxes misc::               Miscellaneous syntaxes.


File: vicare-libs.info,  Node: syntaxes defines,  Next: syntaxes bindings,  Up: syntaxes

1.7.1 Special definitions
-------------------------

The following bindings are exported by the library '(vicare
language-extensions syntaxes)'.

 -- Macro: define-exact-integer->symbol-function ?WHO (?CODE ...)
     Define a function used to convert exact intgers to the
     corresponding symbolic name.  Expand to:

          (define (?WHO code)
            (define who '?WHO)
            (with-arguments-validation (who)
                ((exact-integer      code))
              (case code
                ((?CODE)     '?CODE)
                ...
                (else #f))))


File: vicare-libs.info,  Node: syntaxes bindings,  Next: syntaxes sequencing,  Prev: syntaxes defines,  Up: syntaxes

1.7.2 Special local bindings
----------------------------

The following bindings are exported by the library '(vicare
language-extensions syntaxes)'.

 -- Macro: let-inline ((?VAR ?EXPR) ...) ?BODY0 . ?BODY
     Wrapper for 'let-syntax', expand to:

          (let-syntax ((?VAR (identifier-syntax ?EXPR))
                       ...)
            ?BODY0 . ?BODY)

 -- Macro: let*-inline () ?BODY0 . ?BODY
 -- Macro: let*-inline ((?VAR0 ?EXPR0) (?VAR ?EXPR) ...) ?BODY0 . ?BODY
     Wrapper for 'let-syntax', expand to:

          (let-syntax ((?VAR0 (identifier-syntax ?EXPR)))
            (let*-inline ((?VAR ?EXPR)
                          ...)
              ?BODY0 . ?BODY))


File: vicare-libs.info,  Node: syntaxes sequencing,  Next: syntaxes conversion,  Prev: syntaxes bindings,  Up: syntaxes

1.7.3 Sequencing execution
--------------------------

The following bindings are exported by the library '(vicare
language-extensions syntaxes)'.

 -- Macro: begin0-let ((?VAR0 ?INIT0) (?VAR ?INIT) ...) ?FORM0 ?FORM ...
     Expand to:

          (let ((?VAR0 ?INIT0)
                (?VAR  ?INIT)
                ...)
            ?FORM0 ?FORM ...
            ?VAR0)


File: vicare-libs.info,  Node: syntaxes conversion,  Next: syntaxes args,  Prev: syntaxes sequencing,  Up: syntaxes

1.7.4 Converting common arguments
---------------------------------

The following bindings are exported by the library '(vicare
language-extensions syntaxes)'.

 -- Macro: with-pathnames ((?PATHNAME.BV ?PATHNAME) ...) . ?BODY
     Used to preprocess function arguments which must be bytevectors or
     strings representing pathnames; the strings are converted to
     bytevectors.  This macro assumes that the arguments have already
     been validated.  Expand to:

          (let ((?PATHNAME.BV (let ((pathname ?PATHNAME))
                                (if (bytevector? pathname)
                                    pathname
                                  ((string->filename-func) pathname))))
                ...)
            . ?BODY)

 -- Macro: with-bytevectors ((?VALUE.BV ?VALUE) ...) . ?BODY
     Used to preprocess function arguments which must be bytevectors or
     strings; the strings are converted to bytevectors.  This macro
     assumes that the arguments have already been validated.  Expand to:

          (let ((?VALUE.BV (let ((V ?VALUE))
                             (if (bytevector? V)
                                 V
                               (string->latin1 V))))
                ...)
            . ?BODY)

 -- Macro: with-bytevectors/or-false ((?VALUE.BV ?VALUE) ...) . ?BODY
     Used to preprocess function arguments which must be bytevectors,
     strings or false; the strings are converted to bytevectors.  This
     macro assumes that the arguments have already been validated.
     Expand to:

          (let ((?value.bv (let ((V ?value))
                             (cond ((bytevector? V)
                                    V)
                                   ((string? V)
                                    (string->latin1 V))
                                   (else V))))
                ...)
            . ?body)


File: vicare-libs.info,  Node: syntaxes args,  Next: syntaxes misc,  Prev: syntaxes conversion,  Up: syntaxes

1.7.5 Arguments validation
--------------------------

The following bindings are imported and reexported by '(vicare
language-extension syntaxes)' from the library '(vicare arguments
validation)':

     define-argument-validation
     with-arguments-validation
     with-dangerous-arguments-validation
     arguments-validation-forms


File: vicare-libs.info,  Node: syntaxes misc,  Prev: syntaxes args,  Up: syntaxes

1.7.6 Miscellaneous syntaxes
----------------------------

The following bindings are exported by the library '(vicare
language-extensions syntaxes)'.

 -- Macro: callet ?FUNC ?ARG ...
     Expand to a call to ?FUNC, which must evaluate to a function,
     applied to the arguments resulting from processing the ARG
     syntaxes; ARG can be one among:

          ?EXPR
          (?NAME ?EXPR)

     where ?EXPR is an expression that will become the actual argument
     and ?NAME must be an identifier used to comment the meaning of the
     arguments.  Examples:

          (callet printf
                  (string "ciao ~a")
                  (arg    123))
          ==> (printf "ciao ~a" 123)

 -- Macro: callet* ?FUNC ?ARG ...
     Like 'callet', but define local 'let*' bindings for the ARG with
     name.  Example:

          (callet printf
                  (string "ciao ~a")
                  (arg    123))
          ==> (let* ((string "ciao ~a")
                     (arg    123))
                (printf string arg))


File: vicare-libs.info,  Node: makers,  Next: custom-ports,  Prev: syntaxes,  Up: lang

1.8 Maker syntaxes
==================

The library '(vicare language-extensions makers)' provides a constructor
for macro definitions; its nominal purpose is to define macros which
wrap constructors for records and similar entities, allowing the use of
"keywords" to specify non-positional arguments.

   To avoid identifiers collision, it is suggested to import this
library with prefix 'mk.', as in:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

* Menu:

* makers intro::                Introduction to maker macros.
* makers api::                  Defining makers.


File: vicare-libs.info,  Node: makers intro,  Next: makers api,  Up: makers

1.8.1 Introduction to maker macros
----------------------------------

It happens to define a function or macro accepting a number of arguments
greater than 3:

     (define (the-func a b c d e f g h i)
       ...)

in these cases it can be difficult to remember the order of the
arguments; it can also be desirable to define default values for some or
all of the arguments, so that at the call site some arguments can be
omitted in the source code.  The syntax 'define-maker' implements a
solution to this problem.

   The following examples show the expansion of a simple maker with
neither fixed nor variable arguments, only optional clauses arguments:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define-maker doit
       list ((alpha:     1)
             (beta:      2)
             (gamma:     3)))

     (doit)                  ==> (list 1 2 3)

     (doit (alpha:   10))    ==> (list 10 2 3)
     (doit (beta:    20))    ==> (list 1 20 3)
     (doit (gamma:   30))    ==> (list 1 2 30)

     (doit (alpha:   10)
           (beta:    20))    ==> (list 10 20 3)

     (doit (alpha:   10)
           (gamma:   30))    ==> (list 10 2 30)

     (doit (gamma:   30)
           (beta:    20))    ==> (list 1 20 30)

     (doit (alpha:   10)
           (beta:    20)
           (gamma:   30))    ==> (list 10 20 30)

     (let ((b 7))
       (doit (beta:  (+ 6 (* 2 b)))
             (alpha: (+ 2 8)))
       ==> (list (+ 2 8)
                 (+ 6 (* 2 b))
                 3)
       #f)

     (doit (alpha: 10 20 30))
     ==> (list 1 (list 10 20 30) 3)

notice the last example: when multiple values are used in an argument's
clause, they are enclosed in a 'list' form; the following examples show
the expansion of a maker with both fixed and variable arguments, plus
optional clauses arguments:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define-maker (doit a b)
         (list #\a #\b)
       ((alpha:  1)
        (beta:   2)
        (gamma:  3)))


     (doit #\p #\q)          ==> (list #\a #\b #\p #\q 1 2 3)

     (doit #\p #\q
           (alpha: 10))      ==> (list #\a #\b #\p #\q 10 2 3)

     (doit #\p #\q
           (beta: 20))       ==> (list #\a #\b #\p #\q 1 20 3)

     (doit #\p #\q
           (gamma: 30))      ==> (list #\a #\b #\p #\q 1 2 30)

     (doit #\p #\q
           (alpha: 10)
           (beta:  20))      ==> (list #\a #\b #\p #\q 10 20 3)

     (doit #\p #\q
           (alpha: 10)
           (gamma: 30))      ==> (list #\a #\b #\p #\q 10 2 30)

     (doit #\p #\q
           (gamma: 30)
           (beta:  20))      ==> (list #\a #\b #\p #\q 1 20 30)

   Each default value can be any expression and it is evaluated every
time the maker is used:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define g
       (let ((counter 0))
         (lambda ()
           (set! counter (+ 1 counter))
           counter)))

     (define default2 (- (/ 9 3) 1))

     (define-maker doit
       list ((alpha:     1)
             (beta:      default2)
             (gamma:     (g))))

     (doit)                  => ( 1  2  1)
     (doit (alpha: 10))      => (10  2  2)
     (doit (beta:  20))      => ( 1 20  3)
     (doit (gamma: 30))      => ( 1  2 30)

   A maker invocation can expand itself into another macro use; this
allows us to detect whether an optional argument was used or not:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define-maker doit
         subdoit
       ((alpha:  1)
        (beta:   2)
        (gamma:  sentinel)))

     (define-syntax subdoit
       (lambda (stx)
         (syntax-case stx ()
           ((_ ?alpha ?beta ?gamma)
            (and (identifier? #'?gamma)
                 (free-identifier=? #'?gamma #'sentinel))
            #'(list ?alpha ?beta 3))
           ((_ ?alpha ?beta ?gamma)
            #'(list ?alpha ?beta ?gamma))
           )))

     (doit)                  => ( 1  2  3)
     (doit (alpha: 10))      => (10  2  3)
     (doit (beta:  20))      => ( 1 20  3)
     (doit (gamma: 30))      => ( 1  2 30)

and also to "unpack" multiple values used in the same argument clause:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define-maker doit
       subdoit ((alpha:  1)
                (beta:   2)
                (gamma:  3)))

     (define-syntax subdoit
       (lambda (stx)
         (syntax-case stx (list)
           ((_ ?alpha (list ?beta0 ...) ?gamma)
            #'(list ?alpha ?beta0 ... ?gamma))
           ((_ ?alpha ?beta ?gamma)
            #'(list ?alpha ?beta ?gamma))
           )))

     (doit (alpha: 10)
            (beta: #\a #\b #\c)
            (gamma: 30))
     => (10 #\a #\b #\c 30)

   We can define a maker in the body of a library and export it; we just
have to remember to export the auxiliary syntaxes, too:

     (library (the-lib)
       (export doit alpha beta gamma)
       (import (vicare)
         (prefix (vicare language-extensions makers) mk.))
       (define-auxiliary-syntaxes alpha beta gamma)
       (define-maker doit
         list ((alpha     1)
               (beta      2)
               (gamma     3))))

     (library (exec)
       (export)
       (import (rnrs)
         (prefix (the-lib) lib.))
       (lib.doit)                  ==> (list 1 2 3)
       (lib.doit (lib.alpha   10)) ==> (list 10 2 3)
       (lib.doit (lib.beta    20)) ==> (list 1 20 3)
       (lib.doit (lib.gamma   30)) ==> (list 1 2 30)
       )

   A number of options can be specified to customise the parsing of
clauses.  We can specify if a clause is mandatory or optional:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define-maker doit
       list ((alpha:     1 (mk.mandatory))
             (beta:      2 (mk.optional))
             (gamma:     3)))

     (doit (alpha: 10))              ==> (list 10 2 3)
     (doit (beta:  20))              error-> missing clause "alpha:"

the default is for all the clauses to be optional.  We can specify that
a clause must be used along one or more other clauses:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntaxes alpha: beta: gamma:)

     (define-maker doit
       list ((alpha:     1 (mk.with beta: gamma:))
             (beta:      2)
             (gamma:     3)))

     (doit (alpha: 10)
           (beta:  20)
           (gamma: 30))              ==> (list 10 20 30)

     (doit (beta: 20))               ==> (list 1 20 3)

     (doit (alpha: 10)
           (gamma: 30))              error-> missing clause "beta:"

or we can specify that a clause must not be used along one or more other
clauses:

     (import (vicare)
       (prefix (vicare language-extensions makers) mk.))

     (define-auxiliary-syntax alpha: beta: gamma:)

     (define-maker doit
       list ((alpha:     1 (mk.without beta: gamma:))
             (beta:      2)
             (gamma:     3)))

     (doit (alpha: 10)
           (beta:  20)
           (gamma: 30))              error-> invalid clauses mix

     (doit (beta: 20))               ==> (list 1 20 3)


File: vicare-libs.info,  Node: makers api,  Prev: makers intro,  Up: makers

1.8.2 Defining makers
---------------------

The following bindings are exported by the '(vicare language-extensions
makers)' library.

 -- Macro: define-maker NAME-SPEC MAKER-SEXP KEYWORDS-DEFAULTS-OPTIONS
 -- Auxiliary Syntax: mandatory
 -- Auxiliary Syntax: optional
 -- Auxiliary Syntax: with IDENTIFIER ...
 -- Auxiliary Syntax: without IDENTIFIER ...
     Define a new maker macro.  NAME-SPEC has one of the forms:

          NAME-IDENTIFIER
          (NAME-IDENTIFIER POSITIONAL-ARG ...)

     where NAME-IDENTIFIER is the name of the defined macro and each
     POSITIONAL-ARG is an identifier, name of a mandatory positional
     argument for the macro.

     MAKER-SEXP has one of the forms:

          MAKER-EXPR0
          (MAKER-EXPR0 MAKER-EXPR ...)

     where each MAKER-EXPR is a macro keyword or an expression evaluated
     in the lexical context of the 'define-maker' macro use; the
     expressions are evaluated every time the maker is used.

     KEYWORDS-DEFAULTS-OPTIONS defines optional arguments selected with
     an auxiliary syntax and a value; it has the form:

          (CLAUSE-SPEC ...)

     where each CLAUSE-SPEC has the form:

          (AUXILIARY-SYNTAX DEFAULT-EXPR)
          (AUXILIARY-SYNTAX DEFAULT-EXPR OPTION ...)

     where each AUXILIARY-SYNTAX is an identifier and DEFAULT-EXPR is an
     expression representing the default value for the argument; the
     expressions are all evaluated in the lexical context of the
     'define-maker' macro use, the expressions are evaluated every time
     the maker is used.

     Notice that the AUXILIARY-SYNTAX identifiers are matched against
     the values in the macro use by comparing the syntax objects with
     'free-identifier=?'.

     Each of the OPTION forms can be one among:

          (mandatory)
          (optional)
          (with IDENTIFIER ...)
          (without IDENTIFIER ...)

     where the first two specify if the current clause is mandatory or
     optional; the 'with' option selects a list of clauses that must be
     present when the current clause is used; the 'without' option
     selects a list of clauses that must not be present when the current
     clause is used.  Each clause can be used at most once; 'mandatory'
     cannot appear along with 'optional'.

     When the new macro is used without optional auxiliary syntaxes, it
     is expanded to:

          ;; single maker expression, no positional arguments
          (MAKER-EXPR-RESULT)

          ;; single maker expression, positional arguments
          (MAKER-EXPR-RESULT
           POSITIONAL-ARG0 POSITIONAL-ARG ...)

          ;; multiple maker expressions, no positional arguments
          (MAKER-EXPR-RESULT0 MAKER-EXPR-RESULT ...)

          ;; multiple maker expressions, positional arguments
          (MAKER-EXPR-RESULT0 MAKER-EXPR-RESULT ...
           POSITIONAL-ARG0 POSITIONAL-ARG ...)

     When the new macro is defined with optional auxiliary syntaxes, the
     expressions in the given syntax clauses, or the default
     expressions, are appended to the output form in the same order as
     the corresponding syntaxes in KEYWORDS-DEFAULTS-OPTIONS.

     It is an error if the generated maker is invoked with a clause used
     multiple times.

     When the clause of a generated maker is used with multiple values:
     the values are enclosed in a 'list' form and the result is used as
     argument for the maker expression; for example:

          (import (vicare)
            (prefix (vicare language-extensions makers) mk.))

          (define-syntax alpha:)

          (mk.define-maker doit
              vector
            ((alpha: (list 1 2 3))))

          (doit)                   ==> (vector (list 1 2 3))
          (doit (alpha: 10 20 30)) ==> (vector (list 10 20 30))


File: vicare-libs.info,  Node: custom-ports,  Next: asciis,  Prev: makers,  Up: lang

1.9 Custom ports
================

The library '(vicare language-extensions custom-ports)' implements
special custom Scheme input and output ports.

* Menu:

* custom-ports pairs::          Port pairs.


File: vicare-libs.info,  Node: custom-ports pairs,  Up: custom-ports

1.9.1 Port pairs
----------------

Port pairs are Scheme ports connected together so that data written to
one port is read from the other port.

   Forking a Vicare process does *not* allow the use of port pairs to
communicate between processes; it is rather possible to use port pairs
to communicate among coroutines, *note Running coroutines:
(vicare-scheme)iklib coroutines.  To communicate between processes we
have to use the POSIX library and create pipes (*note pipe: posix fd
pipe.) or socket pairs (*note socketpair: posix socket socket.).

   The following bindings are exported by the library '(vicare
language-extensions custom-ports)'.

 -- Function: open-binary-input-port-pair
     Return two values being binary ports: input the first, output the
     second.  Such ports are connected together so that data written to
     the output port is read from the input port.

 -- Function: open-binary-output-port-pair
     Return two values being binary ports: output the first, input the
     second.  Such ports are connected together so that data written to
     the output port is read from the input port.

 -- Function: open-binary-input/output-port-pair
     Return two values being binary ports: input/output the first,
     input/output the second.  Such ports are connected together so that
     data written to one port is read from the other port.

 -- Function: open-textual-input-port-pair
     Return two values being textual ports: input the first, output the
     second.  Such ports are connected together so that data written to
     the output port is read from the input port.

 -- Function: open-textual-output-port-pair
     Return two values being textual ports: output the first, input the
     second.  Such ports are connected together so that data written to
     the output port is read from the input port.

 -- Function: open-textual-input/output-port-pair
     Return two values being textual ports: input/output the first,
     input/output the second.  Such ports are connected together so that
     data written to one port is read from the other port.


File: vicare-libs.info,  Node: asciis,  Next: hooks,  Prev: custom-ports,  Up: lang

1.10 Utilities for ASCII characters
===================================

The library '(vicare language-extensions ascii-chars)' provides
functions and macros dealing with fixnums representing characters in
ASCII encoding range.

* Menu:

* asciis generic::              Generic utilities.
* asciis conversion::           Conversion utilities.
* asciis predicates::           Character predicates.
* asciis uri::                  Character predicates related to RFC
                                3986, Uniform Resource Identifiers.


File: vicare-libs.info,  Node: asciis generic,  Next: asciis conversion,  Up: asciis

1.10.1 Generic utilities
------------------------

The following bindings are exported by the library '(vicare
language-extensions ascii-chars)'.  The identifiers whose name is
prefixed with '$' are bound to unsafe operations: they do *not* validate
the arguments and applying them to invalid arguments leads to undefined
behaviour.

 -- Function: fixnum-in-ascii-range? OBJ
 -- Syntax: $fixnum-in-ascii-range? OBJ
     Return '#t' if OBJ is a fixnum representing a character in ASCII
     encoding.

 -- Function: fixnum-in-base10-range? OBJ
 -- Syntax: $fixnum-in-base10-range? OBJ
     Return '#t' if OBJ is a fixnum in the range [0, 9].

 -- Function: fixnum-in-base16-range? OBJ
 -- Syntax: $fixnum-in-base16-range? OBJ
     Return '#t' if OBJ is a fixnum in the range [0, 15].

 -- Function: ascii-upper-case? FX
 -- Function: ascii-lower-case? FX
 -- Function: ascii-title-case? FX
 -- Syntax: $ascii-upper-case? FX
 -- Syntax: $ascii-lower-case? FX
 -- Syntax: $ascii-title-case? FX
     Return '#t' if FX represents an upper case or lower case letter
     character, otherwise return '#f'.

 -- Function: ascii-cased? FX
 -- Syntax: $ascii-cased? FX
     Return '#t' if FX represents a letter character, which can be
     converted to upper or lower case, otherwise return '#f'.

 -- Function: ascii-alphabetic? FX
 -- Syntax: $ascii-alphabetic? FX
     Return '#t' if FX represents a letter character, otherwise return
     '#f'.

 -- Function: ascii-dec-digit? FX
 -- Syntax: $ascii-dec-digit? FX
     Return '#t' if FX represents a decimal digit character, otherwise
     return '#f'.

 -- Function: ascii-hex-digit? FX
 -- Syntax: $ascii-hex-digit? FX
     Return '#t' if FX represents a hexadecimal digit character,
     otherwise return '#f'.

 -- Function: ascii-alpha-digit? FX
 -- Syntax: $ascii-alpha-digit? FX
     Return '#t' if FX represents a letter or a decimal digit character,
     otherwise return '#f'.

 -- Function: ascii-upcase FX
 -- Function: ascii-downcase FX
 -- Function: ascii-titlecase FX
 -- Syntax: $ascii-upcase FX
 -- Syntax: $ascii-downcase FX
 -- Syntax: $ascii-titlecase FX
     Return a fixnum representing the upper case or lower case version
     of FX; return FX itself if it represents an uncased character.


File: vicare-libs.info,  Node: asciis conversion,  Next: asciis predicates,  Prev: asciis generic,  Up: asciis

1.10.2 Conversion utilities
---------------------------

The following bindings are exported by the library '(vicare
language-extensions ascii-chars)'.  The identifiers whose name is
prefixed with '$' are bound to unsafe operations: they do *not* validate
the arguments and applying them to invalid arguments leads to undefined
behaviour.

 -- Function: ascii-dec->fixnum FX
 -- Syntax: $ascii-dec->fixnum FX
     Given a fixnum representing a decimal digit in ASCII encoding:
     return the corresponding fixnum in the range [0, 9].

          (ascii-dec->fixnum (char->integer #\5))
          => 5

 -- Function: fixnum->ascii-dec FX
 -- Syntax: $fixnum->ascii-dec FX
     Given a fixnum in the range [0, 9]: return the corresponding fixnum
     representing the decimal digit in ASCII encoding.

          (fixnum->ascii-dec 5)
          => (char->integer #\5)

 -- Function: ascii-hex->fixnum FX
 -- Syntax: $ascii-hex->fixnum FX
     Given a fixnum representing a hexadecimal digit in ASCII encoding:
     return the corresponding fixnum in the range [0, 15].

          (ascii-hex->fixnum (char->integer #\5))
          => 5

          (ascii-hex->fixnum (char->integer #\A))
          => 10

 -- Function: fixnum->ascii-hex FX
 -- Syntax: $fixnum->ascii-hex FX
     Given a fixnum in the range [0, 15]: return the corresponding
     fixnum representing the hexadecimal digit in ASCII encoding.

          (fixnum->ascii-hex 5)
          => (char->integer #\5)

          (fixnum->ascii-hex 10)
          => (char->integer #\A)


File: vicare-libs.info,  Node: asciis predicates,  Next: asciis uri,  Prev: asciis conversion,  Up: asciis

1.10.3 Character predicates
---------------------------

The following bindings are exported by the library '(vicare
language-extensions ascii-chars)'.  The identifiers whose name is
prefixed with '$' are bound to unsafe operations: they do *not* validate
the arguments and applying them to invalid arguments leads to undefined
behaviour.

 -- Syntax: $ascii-chi-V? FX
     Evaluate to true if FX is a fixnum representing the character 'V'
     in ASCII encoding.

 -- Syntax: $ascii-chi-v? FX
     Evaluate to true if FX is a fixnum representing the character 'v'
     in ASCII encoding.

 -- Syntax: $ascii-chi-ampersand? FX
     Evaluate to true if FX is a fixnum representing the character '&'
     in ASCII encoding.

 -- Syntax: $ascii-chi-at-sign? FX
     Evaluate to true if FX is a fixnum representing the character '@'
     in ASCII encoding.

 -- Syntax: $ascii-chi-open-bracket? FX
     Evaluate to true if FX is a fixnum representing the character '['
     in ASCII encoding.

 -- Syntax: $ascii-chi-close-bracket? FX
     Evaluate to true if FX is a fixnum representing the character ']'
     in ASCII encoding.

 -- Syntax: $ascii-chi-open-paren? FX
     Evaluate to true if FX is a fixnum representing the character '('
     in ASCII encoding.

 -- Syntax: $ascii-chi-close-paren? FX
     Evaluate to true if FX is a fixnum representing the character ')'
     in ASCII encoding.

 -- Syntax: $ascii-chi-dot? FX
     Evaluate to true if FX is a fixnum representing the character '.'
     in ASCII encoding.

 -- Syntax: $ascii-chi-comma? FX
     Evaluate to true if FX is a fixnum representing the character ','
     in ASCII encoding.

 -- Syntax: $ascii-chi-colon? FX
     Evaluate to true if FX is a fixnum representing the character ':'
     in ASCII encoding.

 -- Syntax: $ascii-chi-semicolon? FX
     Evaluate to true if FX is a fixnum representing the character ';'
     in ASCII encoding.

 -- Syntax: $ascii-chi-bang? FX
     Evaluate to true if FX is a fixnum representing the character '!'
     in ASCII encoding.

 -- Syntax: $ascii-chi-dollar? FX
     Evaluate to true if FX is a fixnum representing the character '$'
     in ASCII encoding.

 -- Syntax: $ascii-chi-question-mark? FX
     Evaluate to true if FX is a fixnum representing the character '?'
     in ASCII encoding.

 -- Syntax: $ascii-chi-number-sign? FX
     Evaluate to true if FX is a fixnum representing the character '#'
     in ASCII encoding.

 -- Syntax: $ascii-chi-percent? FX
     Evaluate to true if FX is a fixnum representing the character '%'
     in ASCII encoding.

 -- Syntax: $ascii-chi-equal? FX
     Evaluate to true if FX is a fixnum representing the character '='
     in ASCII encoding.

 -- Syntax: $ascii-chi-plus? FX
     Evaluate to true if FX is a fixnum representing the character '+'
     in ASCII encoding.

 -- Syntax: $ascii-chi-minus? FX
 -- Syntax: $ascii-chi-dash? FX
     Evaluate to true if FX is a fixnum representing the character '-'
     in ASCII encoding.

 -- Syntax: $ascii-chi-underscore? FX
     Evaluate to true if FX is a fixnum representing the character '_'
     in ASCII encoding.

 -- Syntax: $ascii-chi-tilde? FX
     Evaluate to true if FX is a fixnum representing the character '~'
     in ASCII encoding.

 -- Syntax: $ascii-chi-quote? FX
     Evaluate to true if FX is a fixnum representing the character '''
     in ASCII encoding.

 -- Syntax: $ascii-chi-slash? FX
     Evaluate to true if FX is a fixnum representing the character '/'
     in ASCII encoding.

 -- Syntax: $ascii-chi-star? FX
     Evaluate to true if FX is a fixnum representing the character '*'
     in ASCII encoding.


File: vicare-libs.info,  Node: asciis uri,  Prev: asciis predicates,  Up: asciis

1.10.4 Character predicates related to RFC 3986, Uniform Resource Identifiers
-----------------------------------------------------------------------------

The following bindings are exported by the library '(vicare
language-extensions ascii-chars)'.  The identifiers whose name is
prefixed with '$' are bound to unsafe operations: they do *not* validate
the arguments and applying them to invalid arguments leads to undefined
behaviour.

 -- Syntax: $ascii-uri-reserved? FX
     Evaluate to true if FX is a fixnum representing a reserved
     character in ASCII encoding according to RFC 3986.

 -- Syntax: $ascii-uri-unreserved? FX
     Evaluate to true if FX is a fixnum representing an unreserved
     character in ASCII encoding according to RFC 3986.

 -- Syntax: $ascii-uri-gen-delim? FX
     Evaluate to true if FX is a fixnum representing a 'gen-delim'
     character in ASCII encoding according to RFC 3986.

 -- Syntax: $ascii-uri-sub-delim? FX
     Evaluate to true if FX is a fixnum representing a 'sub-delim'
     character in ASCII encoding according to RFC 3986.

 -- Syntax: $ascii-uri-pct-encoded? ?CHI ?BV ?I
     The argument ?CHI must be a fixnum representing the octet at index
     ?I in the bytevector ?BV; ?BV and ?I must be identifiers.  Return
     '#t' if the 3 bytes at offset ?I represent a percent-encoded
     sequence and increment ?I to reference the third octet; otherwise
     return '#f' and set ?I to the offset of the offending octet; if
     there are not enough octets: return '#f' and leave ?I unchanged.

          #!vicare
          (import (vicare)
            (vicare language-extensions ascii-chars))

          (let* ((bv  '#ve(ascii "ciao"))
                 (i   0)
                 (chi (bytevector-u8-ref bv i))
                 (R   ($ascii-uri-pct-encoded? chi bv i)))
            (values R i))
          => #f 0

          (let* ((bv  '#ve(ascii "c%ABo"))
                 (i   1)
                 (chi (bytevector-u8-ref bv i))
                 (R   ($ascii-uri-pct-encoded? chi bv i)))
            (values R i))
          => #t 3

          (let* ((bv  '#ve(ascii "c%AB"))
                 (i   1)
                 (chi (bytevector-u8-ref bv i))
                 (R    ($ascii-uri-pct-encoded? chi bv i)))
            (values R i))
          => #t 3

          (let* ((bv  '#ve(ascii "c%AZ"))
                 (i   1)
                 (chi (bytevector-u8-ref bv i))
                 (R   ($ascii-uri-pct-encoded? chi bv i)))
            (values R i))
          => #f 3

          (let* ((bv  '#ve(ascii "c%ZA"))
                 (i   1)
                 (chi (bytevector-u8-ref bv i))
                 (R   ($ascii-uri-pct-encoded? chi bv i)))
            (values R i))
          => #f 2

          (let* ((bv  '#ve(ascii "c%A"))
                 (i   1)
                 (chi (bytevector-u8-ref bv i))
                 (R   ($ascii-uri-pct-encoded? chi bv i)))
            (values R i))
          => #f 1

 -- Syntax: $ascii-uri-pchar-not-percent-encoded? FX
     Evaluate to true if FX is a fixnum matching the 'pchar' component
     in ASCII encoding, with the exception of the percent-encoded
     sequence as defined by RFC 3986.

 -- Syntax: $ascii-uri-pchar? ?CHI ?BV ?I
     The argument ?CHI must be a fixnum representing the octet at index
     ?I in the bytevector ?BV; ?BV and ?I must be identifiers.  Return
     '#t' if the octet ?CHI or the 3 bytes at offset ?I represent
     'pchar' component in ASCII encoding; if successful increment ?I to
     reference the last matching octet; otherwise return '#f' and set ?I
     to the offset of the offending octet; if there are not enough
     octets: return '#f' and leave ?I unchanged.


File: vicare-libs.info,  Node: hooks,  Next: callables,  Prev: asciis,  Up: lang

1.11 Running lists of functions
===============================

The library '(vicare language-extensions hooks)' exports an API defining
"hooks": opaque Scheme objects, disjoint from other types, referencing a
list of functions which can be applied to arguments at a specified point
in a program.  Vicare Scheme hooks are somewhat similar to GNU Guile
hooks.

 -- Function: make-hook
     Build and return a new hook object.

 -- Function: hook? OBJ
     Return '#t' if OBJ is a hook object, otherwise '#f'.

 -- Function: hook-empty? HOOK
     Return '#t' if HOOK is a hook object and it is empty, otherwise
     '#f'.

 -- Function: add-hook! HOOK PROC
 -- Function: add-hook! HOOK PROC LAST?
     Register PROC as hook function; return unspecified values.  If
     LAST? is '#f' or not used: the new function is registered as first,
     else it is registered as last.

 -- Function: remove-hook! HOOK PROC
     Remove a previously registered hook function.  Return unspecified
     values.

 -- Function: reset-hook! HOOK
     Remove all the previously registered hooks.

 -- Function: hook->list HOOK
     Return the list of registered functions.

 -- Function: run-hook HOOK ARG ...
     Run all the hook functions applying them to the given arguments.
     Return unspecified values.


File: vicare-libs.info,  Node: callables,  Next: c-enums,  Prev: hooks,  Up: lang

1.12 Callable objects
=====================

The library '(vicare language-extensions callables)' allows the
definition of "callable objects": closure objects associated to an
object used as first argument in every call.  Here is an example of
callable object:

     (import (vicare)
       (vicare language-extensions callables))

     (define C
       (callable 123 (lambda (self delta)
                       (+ delta self))))

     (callable? C)           => #t
     (callable-object C)     => 123
     (C 9000)                => 9123

 -- Syntax: callable ?OBJECT ?FUNCTION
     Build and return a new callable object associated to ?OBJECT and
     having ?FUNCTION as callable procedure.

 -- Function: callable? OBJ
     Return '#t' if OBJ is a callable object, otherwise return '#f'.
     Notice that a callable object satisfies 'procedure?'.

 -- Function: callable-object CALLABLE
 -- Function: $callable-object CALLABLE
     Return the object associated to the callable object CALLABLE.
     '$callable-object' is the unsafe version which does not validate
     its argument prior to accessing its internal fields.


File: vicare-libs.info,  Node: c-enums,  Next: pipelines,  Prev: callables,  Up: lang

1.13 C language flags and flags combinations
============================================

The following bindings are exported by the library '(vicare
language-extensions c-enumerations)'.

 -- Syntax: define-c-flags ?NAME (?FLAG0 ?FLAG ...) (?SYMBOL0 ?SYMBOL
          ...)
     Define a new enumeration type and a couple of functions to convert
     between enumeration sets of this type and other objects.  Usage
     example:

          (define A 1)
          (define B 2)
          (define C 3)

          (define-c-flags things
            (A B C)
            (a b c))

          (things->value (things a)) => 1
          (things->value (things b)) => 2
          (things->value (things c)) => 3

          (value->things 1) => (things a)
          (value->things 2) => (things b)
          (value->things 3) => (things c)

     when used in a library, we can do the following to export the
     interface:

          (library (things)
            (export things things->value value->things)
            (import (rnrs))
            (define A 1)
            (define B 2)
            (define C 3)
            (define-c-flags things
              (A B C)
              (a b c)))

     The typical use of this syntax is to define an interface for C
     language foreign constants.

     ?NAME must be an identifier to which an enumeration set constructor
     syntax is bound; the syntax accepts only a single symbol as
     argument and it expands to an enumeration set with that symbol as
     element.

     The enumeration type is 'enum-?NAME' and the original constructor
     syntax accepting any number of arguments is '%?NAME'.

     The ?FLAG arguments are meant to be identifiers bound to any Scheme
     value, but they can be any value.  The ?SYMBOL arguments must be
     Scheme symbols which are used to define (in the given order) the
     universe of the enumeration.

     The function which converts from an enumeration set (holding a
     single argument) to the corresponding value is bound to
     '?NAME->value'.  The function which converts from a value to the
     enumeration set (holding a single argument) is bound to
     'value->?NAME'.

 -- Syntax: define-c-ior-flags ?NAME (?FLAG0 ?FLAG ...) (?SYMBOL0
          ?SYMBOL ...)
     Define a new enumeration type and a couple of functions to convert
     between enumeration sets of this type and a bitwise, inclusive, OR
     combination of exact integers.  Usage example:

          (define A (bitwise-arithmetic-shift-left 1 0))
          (define B (bitwise-arithmetic-shift-left 1 1))
          (define C (bitwise-arithmetic-shift-left 1 2))

          (define-c-ior-flags things
            (A B C)
            (a b c))

          (things->value (things a))      => 1
          (things->value (things b))      => 2
          (things->value (things a b))    => 3
          (things->value (things c))      => 4
          (things->value (things a c))    => 5
          (things->value (things b c))    => 6
          (things->value (things a b c))  => 7

          (value->things 1) => (things a)
          (value->things 2) => (things b)
          (value->things 5) => (things a c)

     when used in a library, we can do the following to export the
     interface:

          (library (things)
            (export things things->value value->things)
            (import (rnrs))
            (define A (bitwise-arithmetic-shift-left 1 0))
            (define B (bitwise-arithmetic-shift-left 1 1))
            (define C (bitwise-arithmetic-shift-left 1 2))
            (define-c-ior-flags things
              (A B C)
              (a b c)))

     The typical use of this syntax is to define an interface for C
     language foreign constants used as flags in inclusive OR
     combinations.

     ?NAME must be an identifier to which an enumeration set constructor
     syntax is bound; the syntax accepts any number of symbols as
     arguments and it expands to an enumeration set with that symbols as
     elements.  The enumeration type is 'enum-?NAME'.

     The ?FLAG arguments must be identifiers bound to exact integers.
     The ?SYMBOL arguments must be Scheme symbols which are used to
     define (in the given order) the universe of the enumeration.

     The function which converts from an enumeration set to the
     corresponding bitwise, inclusive OR combination is bound to
     '?NAME->value'.  An assertion violation is raised if this function
     is applied to an enumeration set of the wrong type.

     The function which converts from a bitwise, inclusive OR
     combination to the enumeration set is bound to 'value->?NAME'.  If
     this function is applied to an integer holding bits outside the
     ones coded in the definition of the enumeration, no error is
     raised.


File: vicare-libs.info,  Node: pipelines,  Next: streams,  Prev: c-enums,  Up: lang

1.14 Pipelining expressions
===========================

The following bindings are exported by the library '(vicare
language-extensions pipelines)'.

 -- Syntax: pipeline ?PRODUCER => ?FORMALS ?CONSUMER ...
 -- Auxiliary Syntax: =>
     Allow a sequence of producer/consumer expressions to be written
     with simpler and less indented syntax.  The following expansions
     are implemented:

          (pipeline ?PRODUCER => ?FORMALS ?CONSUMER)
          ==> (call-with-values
                  (lambda () ?PRODUCER)
                (lambda ?FORMALS ?CONSUMER))

          (pipeline ?PRODUCER
            => ?FORMALS0
            ?CONSUMER0
            => ?FORMALS1
            ?CONSUMER1)
          ==> (call-with-values
                  (lambda () ?PRODUCER)
                (lambda ?FORMALS0
                  (call-with-values
                      (lambda () ?CONSUMER0)
                    (lambda ?FORMALS1
                      ?CONSUMER1))))

     The auxiliary syntax '=>' is the one exported by '(rnrs base (6))'.

   Examples:

     (pipeline 1)
     => 1

     (pipeline
       1.2
       => (x0)
       (sin x0)
       => (x1)
       (cos x1)
       => (x2)
       (tan x2)
       => (x3)
       x3)
     == (tan (cos (sin 1.2)))

     (pipeline
       (values 1 2)
       => (a0 b0)
       (values (times10 a0) (times10 b0))
       => (a1 b1)
       (values (times10 a1) (times10 b1))
       => (a2 b2)
       (values (times10 a2) (times10 b2))
       => (a3 b3)
       (list a3 b3))
     => (1000 2000)

     (pipeline
       (values 1 2 3 4)
       => (a0 b0 . rest0)
       (apply values (times10 a0) (times10 b0) (map times10 rest0))
       => (a1 b1 . rest1)
       (apply values (times10 a1) (times10 b1) (map times10 rest1))
       => (a2 b2 . rest2)
       (apply values (times10 a2) (times10 b2) (map times10 rest2))
       => (a3 b3 . rest3)
       (cons* a3 b3 rest3))
     => (1000 2000 3000 4000)


File: vicare-libs.info,  Node: streams,  Next: loops,  Prev: pipelines,  Up: lang

1.15 Streams
============

The '(vicare language-extensions streams)' library implements "streams";
sometimes called "lazy lists", streams are a sequential data structure
containing elements computed only on demand.  A stream is either null or
is a pair with a stream in its cdr.  Since elements of a stream are
computed only when accessed, streams can be infinite.  Once computed,
the value of a stream element is cached in case it is needed again.

* Menu:

* streams basic::               Basic interface.
* streams cons::                Definitions and constructors.
* streams from::                Converting objects into streams.
* streams to::                  Converting streams to objects.
* streams ops::                 Operations.
* streams select::              Selecting.
* streams range::               Range streams.
* streams of::                  Comprehensions.
* streams fold::                Folding.
* streams unfold::              Unfolding.
* streams map::                 Mapping and side effects.
* streams match::               Matching.
* streams utilities::           Utilities.
* streams examples::            Examples.


File: vicare-libs.info,  Node: streams basic,  Next: streams cons,  Up: streams

1.15.1 Basic interface
----------------------

The basic API provides two mutually-recursive abstract data types: An
object of the 'stream' abstract data type is a promise that, when
forced, is either 'stream-null' or is an object of type 'stream-pair'.
An object of the 'stream-pair' abstract data type contains a "kar" and a
"kdr", which must be a 'stream'.  The essential feature of streams is
the systematic suspensions of the recursive promises between the two
data types.

     alpha stream
       :: (promise stream-null)
       |  (promise (alpha stream-pair))

     alpha stream-pair
       :: (promise alpha) x (promise (alpha stream))

   The object stored in the kar of a 'stream-pair' is a promise that is
forced the first time the kar is accessed; its value is cached in case
it is needed again.  The object may have any type, and different stream
elements may have different types.  If the kar is never accessed, the
object stored there is never evaluated.  Likewise, the kdr is a promise
to return a stream, and is only forced on demand.

   This API provides eight operators: constructors for 'stream-null' and
'stream-pair', type recognisers for streams and the two kinds of
streams, accessors for both fields of a 'stream-pair', a lambda that
creates procedures that return streams.

 -- Constant: stream-null
     Return a promise that, when forced, is a single object,
     distinguishable from all other objects, that represents the null
     stream.  'stream-null' is immutable and unique.

 -- Syntax: stream-cons OBJ STREAM
     Accept an object and a stream and create a newly-allocated stream
     containing a promise that, when forced, is a 'stream-pair' with the
     object in its kar and the stream in its 'stream-cdr'.

     Once created, a 'stream-pair' is immutable; there is *no*
     'stream-set-kar!' or 'stream-set-kdr!' that modifies an existing
     'stream-pair'.  There is no dotted-pair or improper stream as with
     lists.

 -- Function: stream? OBJ
     Return '#t' if OBJ is a 'stream' and '#f' otherwise.  If OBJ is a
     'stream', 'stream?' does not force its promise.

     If '(stream? obj)' is '#t', then one of '(stream-null? obj)' and
     '(stream-pair? obj)' will be '#t' and the other will be '#f'; if
     '(stream? obj)' is '#f', both '(stream-null? obj)' and
     '(stream-pair? obj)' will be '#f'.

 -- Function: stream-null? OBJ
     Return '#t' if the OBJ is the distinguished null stream and '#f'
     otherwise.  If OBJ is a 'stream', 'stream-null?' must force its
     promise in order to distinguish 'stream-null' from 'stream-pair'.

 -- Function: stream-pair? OBJ
     Take an OBJ and return '#t' if it is a 'stream-pair' constructed by
     'stream-cons' and '#f' otherwise.  If OBJ is a 'stream',
     'stream-pair?' must force its promise in order to distinguish
     'stream-null' from 'stream-pair'.

 -- Function: stream-car STREAM
     Return the object stored in the kar of STREAM.  'stream-car'
     signals an error if the object passed to it is not a 'stream-pair'.
     Calling 'stream-car' causes the object stored there to be evaluated
     if it has not yet been; the object's value is cached in case it is
     needed again.

 -- Function: stream-cdr STREAM
     Return the stream stored in the kdr of STREAM.  'stream-cdr'
     signals an error if the object passed to it is not a 'stream-pair'.
     Calling 'stream-cdr' does not force the promise containing the
     stream stored in the kdr of the stream.

 -- Syntax: stream-lambda FORMALS . BODY
     Create a procedure that returns a promise to evaluate the body of
     the procedure.  The last body expression to be evaluated must yield
     a stream.

     As with normal 'lambda', FORMALS may be a single variable name, in
     which case all the formal arguments are collected into a single
     list, or a list of variable names, which may be null if there are
     no arguments, proper if there are an exact number of arguments, or
     dotted if a fixed number of arguments is to be followed by zero or
     more arguments collected into a list.

     BODY must contain at least one expression, and may contain internal
     definitions preceding any expressions to be evaluated.

   Examples:

     (define strm123
       (stream-cons 1
         (stream-cons 2
           (stream-cons 3
             stream-null))))

     (stream-car strm123)
     => 1

     (stream-car (stream-cdr strm123))
     => 2

     (stream-pair?
       (stream-cdr
         (stream-cons (/ 1 0) stream-null)))
     => #f

     (stream? (list 1 2 3))
     => #f

     (define iter
       (stream-lambda (f x)
         (stream-cons x (iter f (f x)))))

     (define nats
       (iter (lambda (x)
               (+ x 1))
             0))

     (stream-car (stream-cdr nats))
     => 1

     (define stream-add
       (stream-lambda (s1 s2)
         (stream-cons
           (+ (stream-car s1) (stream-car s2))
           (stream-add (stream-cdr s1)
                       (stream-cdr s2)))))

     (define evens
       (stream-add nats nats))

     (stream-car evens)
     => 0

     (stream-car (stream-cdr evens))
     => 2

     (stream-car (stream-cdr (stream-cdr evens)))
     => 4


File: vicare-libs.info,  Node: streams cons,  Next: streams from,  Prev: streams basic,  Up: streams

1.15.2 Definitions and constructors
-----------------------------------

 -- Syntax: stream OBJECT ...
     Take zero or more objects and create a newly-allocated 'stream'
     containing in its elements the objects, in order.  Since 'stream'
     is syntactic, the objects are evaluated when they are accessed, not
     when the 'stream' is created.  If no objects are given, as in
     '(stream)', the null stream is returned.  See also 'list->stream'.

     Example:

          (define strm123 (stream 1 2 3))

          ; (/ 1 0) not evaluated when stream is created
          (define s (stream 1 (/ 1 0) -1))

 -- Function: stream-constant OBJECT ...
     Take one or more objects and return a newly-allocated 'stream'
     containing in its elements the objects, repeating the objects in
     succession forever.

     Example:

          (stream-constant 1)
          => 1 1 1 ...

          (stream-constant #t #f)
          => #t #f #t #f #t #f ...

 -- Syntax: define-stream (NAME FORMALS) . BODY
     Create a procedure that returns a 'stream', and may appear anywhere
     a normal 'define' may appear, including an internal definition, and
     may have internal definitions of its own, including other
     'define-streams'.  The defined procedure takes arguments in the
     same way as 'stream-lambda'.

     'define-stream' is syntactic sugar on 'stream-lambda'; see also
     'stream-let'.

     The following example is a simple version of 'stream-map' that
     takes only a single input stream and calls itself recursively:

          (define-stream (stream-map proc strm)
            (if (stream-null? strm)
                stream-null
              (stream-cons
                (proc (stream-car strm))
                (stream-map proc (stream-cdr strm)))))

 -- Syntax: stream-let NAME ((VAR EXPR) ...) BODY
     Create a local scope that binds each variable to the value of its
     corresponding expression.  Additionally bind NAME to a procedure
     which takes the bound variables as arguments and BODY as its
     defining expressions, binding the tag with 'stream-lambda'.  NAME
     is in scope within BODY, and may be called recursively.

     When the expanded expression defined by 'stream-let' is evaluated,
     'stream-let' evaluates the expressions in its body in an
     environment containing the newly-bound variables, returning the
     value of the last expression evaluated, which must yield a stream.

     'stream-let' provides syntactic sugar on 'stream-lambda', in the
     same manner as normal 'let' provides syntactic sugar on normal
     'lambda'.  However, unlike normal 'let', the NAME is required, not
     optional, because unnamed 'stream-let' is meaningless.

     Example: 'stream-member' returns the first 'stream-pair' of the
     input STRM with a kar X that satisfies '(eqv? obj x)', or the null
     stream if X is not present in STRM.

          (define-stream (stream-member eql? obj strm)
            (stream-let loop ((strm strm))
              (cond ((stream-null? strm)
                     strm)
                    ((eqv? obj (stream-car strm))
                     strm)
                    (else
                     (loop (stream-cdr strm))))))


File: vicare-libs.info,  Node: streams from,  Next: streams to,  Prev: streams cons,  Up: streams

1.15.3 Converting objects into streams
--------------------------------------

 -- Function: list->stream LIST-OF-OBJECTS
     Return a newly-allocated 'stream' containing in its elements the
     objects in the list.  Since the objects are given in a list, they
     are evaluated when 'list->stream' is called, before the 'stream' is
     created.  If the list of objects is null, as in '(list->stream
     '())', the null 'stream' is returned.  See also 'stream'.

     Example:

          (define strm123
            (list->stream '(1 2 3)))

          ;; fails with divide-by-zero error
          (define s
            (list->stream (list 1 (/ 1 0) -1)))

 -- Function: port->stream
 -- Function: port->stream PORT
     Return a newly-allocated 'stream' containing in its elements the
     characters on the PORT.  If PORT is not given it defaults to the
     current input port.  The returned 'stream' has finite length and is
     terminated by 'stream-null'.

     It looks like one use of 'port->stream' would be this:

          (define s               ;wrong!
            (with-input-from-file filename
              (lambda ()
                (port->stream))))

     but that fails, because 'with-input-from-file' is eager, and closes
     the input port prematurely, before the first character is read.  To
     read a file into a stream, use:

          (define-stream (file->stream filename)
            (let ((p (open-input-file filename)))
              (stream-let loop ((c (read-char p)))
                (if (eof-object? c)
                    (begin (close-input-port p)
                           stream-null)
                    (stream-cons c
                      (loop (read-char p)))))))


File: vicare-libs.info,  Node: streams to,  Next: streams ops,  Prev: streams from,  Up: streams

1.15.4 Converting streams to objects
------------------------------------

 -- Function: stream->list STREAM
 -- Function: stream->list STREAM N
     Take a natural number N and a STREAM and return a newly-allocated
     list containing in its elements the first N items in the STREAM.
     If the STREAM has less than N items all the items in the STREAM
     will be included in the returned list.  If N is not given it
     defaults to infinity, which means that unless STREAM is finite
     'stream->list' will never return.

     Example:

          (stream->list 10
            (stream-map (lambda (x) (* x x))
              (stream-from 0)))
            => (0 1 4 9 16 25 36 49 64 81)


File: vicare-libs.info,  Node: streams ops,  Next: streams select,  Prev: streams to,  Up: streams

1.15.5 Operations
-----------------

 -- Function: stream-length STREAM
     Take an input stream and return the number of elements in the
     stream; it does not evaluate its elements.  'stream-length' may
     only be used on finite streams; it enters an infinite loop with
     infinite streams.

     Example:

          (define strm123
            (stream 1 2 3))

          (stream-length strm123)
          => 3

 -- Function: stream-ref STREAM N
     Return the N-th element of STREAM, counting from zero.  An error is
     signaled if N is greater than or equal to the length of STREAM.

     Example:

          (define (fact n)
            (stream-ref
              (stream-scan * 1 (stream-from 1))
              n))

 -- Function: stream-reverse STREAM
     Return a newly-allocated stream containing the elements of the
     input STREAM but in reverse order.  'stream-reverse' may only be
     used with finite streams; it enters an infinite loop with infinite
     streams.  'stream-reverse' does not force evaluation of the
     elements of the stream.

          (define s (stream 1 (/ 1 0) -1))
          (define r (stream-reverse s))

          (stream-ref r 0)
          (stream-ref r 2)        => 1
          (stream-ref r 1)        error-> division by zero

 -- Function: stream-append STREAM ...
     Return a newly-allocated 'stream' containing in its elements those
     elements contained in its input streams, in order of input.  If any
     of the input streams is infinite, no elements of any of the
     succeeding input streams will appear in the output stream; thus, if
     X is infinite, '(stream-append x y)' is identical to X.  See also
     'stream-concat'.

     Example: quicksort can be used to sort a 'stream', using
     'stream-append' to build the output; the sort is lazy; so if only
     the beginning of the output stream is needed, the end of the stream
     is never sorted.

          (define-stream (qsort lt? strm)
            (if (stream-null? strm)
                stream-null
                (let ((x (stream-car strm))
                      (xs (stream-cdr strm)))
                  (stream-append
                    (qsort lt?
                      (stream-filter
                        (lambda (u) (lt? u x))
                        xs))
                    (stream x)
                    (qsort lt?
                      (stream-filter
                        (lambda (u) (not (lt? u x)))
                        xs))))))

     Note also that, when used in tail position as in 'qsort',
     'stream-append' does not suffer the poor performance of 'append' on
     lists.  The list version of 'append' requires re-traversal of all
     its list arguments except the last each time it is called.  But
     'stream-append' is different.  Each recursive call to
     'stream-append' is suspended; when it is later forced, the
     preceding elements of the result have already been traversed, so
     tail-recursive loops that produce streams are efficient even when
     each element is appended to the end of the result stream.  This
     also implies that during traversal of the result only one promise
     needs to be kept in memory at a time.

 -- Function: stream-concat STREAM
     Take a STREAM consisting of one or more streams and return a
     newly-allocated stream containing all the elements of the input
     streams.  If any of the streams in the input stream is infinite,
     any remaining streams in the input stream will never appear in the
     output stream.  See also 'stream-append'.

     Example:

          (stream->list
            (stream-concat
              (stream
                (stream 1 2) (stream) (stream 3 2 1))))
          => (1 2 3 2 1)

     Example: the permutations of a finite stream can be determined by
     interleaving each element of the stream in all possible positions
     within each permutation of the other elements of the stream;
     'interleave' returns a stream of streams with X inserted in each
     possible position of YY:

          (define-stream (interleave x yy)
            (stream-match yy
              (() (stream (stream x)))
              ((y .  ys)
                (stream-append
                  (stream (stream-cons x yy))
                  (stream-map
                    (lambda (z) (stream-cons y z))
                    (interleave x ys))))))

          (define-stream (perms xs)
            (if (stream-null? xs)
                (stream (stream))
              (stream-concat
                (stream-map
                  (lambda (ys)
                    (interleave (stream-car xs) ys))
                  (perms (stream-cdr xs))))))

 -- Function: stream-zip STREAM ...
     Take one or more input streams and return a newly-allocated stream
     in which each element is a list (not a stream) of the corresponding
     elements of the input streams.  The output stream is as long as the
     shortest input stream, if any of the input streams is finite, or is
     infinite if all the input streams are infinite.

     A common use of 'stream-zip' is to add an index to a stream, as in:

          (stream-finds eqv? obj strm)

     which returns all the zero-based indices in STRM at which OBJ
     appears; '(stream-find eqv? obj strm)' returns the first such
     index, or '#f' if OBJ is not in STRM.

          (define-stream (stream-finds item= obj strm)
            (stream-of (car x)
              (x in (stream-zip (stream-from 0) strm))
              (item= obj (cadr x))))

          (define (stream-find item= obj strm)
            (stream-car
              (stream-append
                (stream-finds item= obj strm)
                (stream #f))))

          (stream-find char=? #\l
            (list->stream
              (string->list "hello")))
          => 2

          (stream-find char=? #\l
            (list->stream
              (string->list "goodbye")))
          => #f

     'stream-find' is not as inefficient as it looks; although it calls
     'stream-finds', which finds all matching indices, the matches are
     computed lazily, and only the first match is needed for
     'stream-find'.


File: vicare-libs.info,  Node: streams select,  Next: streams range,  Prev: streams ops,  Up: streams

1.15.6 Selecting
----------------

 -- Function: stream-drop N STREAM
     Return the suffix of the input stream that starts at the next
     element after the first N elements.  The output stream shares
     structure with the input stream; thus, promises forced in one
     instance of the stream are also forced in the other instance of the
     stream.  If the input stream has less than N elements,
     'stream-drop' returns the null stream.  See also 'stream-take'.

     Example:

          (define (stream-split n strm)
            (values (stream-take n strm)
                    (stream-drop n strm)))

 -- Function: stream-drop-while PRED STREAM
     Return the suffix of the input stream that starts at the first
     element X for which '(pred x)' is '#f'.  The output stream shares
     structure with the input stream.  See also 'stream-take-while'.

     Example: 'stream-unique' creates a new stream that retains only the
     first of any sub-sequences of repeated elements.

          (define-stream (stream-unique item= strm)
            (if (stream-null? strm)
                stream-null
              (stream-cons (stream-car strm)
                (stream-unique item=
                  (stream-drop-while
                    (lambda (x)
                      (item= (stream-car strm) x))
                    strm)))))

 -- Function: stream-take N STREAM
     Take a non-negative exact integer N and a STREAM and return a
     newly-allocated stream containing the first N elements of the input
     stream.  If the input stream has less than N elements, so does the
     output stream.  See also 'stream-drop'.

     Example: 'merge-sort' splits a stream into two equal-length pieces,
     sorts them recursively and merges the results:

          (define-stream (merge-sort lt? strm)
            (let* ((n     (div (stream-length strm) 2))
                   (ts    (stream-take n strm))
                   (ds    (stream-drop n strm)))
              (if (zero? n)
                  strm
                (stream-merge lt? (merge-sort < ts) (merge-sort < ds)))))

 -- Function: stream-take-while PRED STREAM
     Take a predicate and a stream and return a newly-allocated stream
     containing those elements X that form the maximal prefix of the
     input stream for which '(pred x)' is non-'#f'.  See also
     'stream-drop-while'.

          (stream-car
            (stream-reverse
              (stream-take-while
                (lambda (x) (< x 1000))
                primes)))
          => 997

 -- Function: stream-filter PRED STREAM
     Return a newly-allocated stream that contains only those elements X
     of the input stream for which '(pred x)' is true.

     Example:

          (stream-filter odd? (stream-from 0))
          => 1 3 5 7 9 ...


File: vicare-libs.info,  Node: streams range,  Next: streams of,  Prev: streams select,  Up: streams

1.15.7 Range streams
--------------------

 -- Function: stream-from FIRST
 -- Function: stream-from FIRST STEP
     Create a newly-allocated stream that contains FIRST as its first
     element and increments each succeeding element by STEP, which
     defaults to '1'.  FIRST and STEP may be of any numeric type.

     'stream-from' is frequently useful as a generator in 'stream-of'
     expressions.  See also 'stream-range' for a similar procedure that
     creates finite streams.

     'stream-from' could be implemented as:

          (stream-iterate
              (lambda (x)
                (+ x step))
            first)

     Example:

          (define nats (stream-from 0))
          => 0 1 2 ...

          (define odds (stream-from 1 2))
          => 1 3 5 ...

 -- Function: stream-range FIRST PAST
 -- Function: stream-range FIRST PAST STEP
     Create a newly-allocated stream that contains FIRST as its first
     element and increments each succeeding element by STEP.  The stream
     is finite and ends before PAST, which is not an element of the
     stream.  If STEP is not given it defaults to '1' if FIRST is less
     than PAST and '-1' otherwise.

     FIRST, PAST and STEP may be of any numeric type.

     'stream-range' is frequently useful as a generator in 'stream-of'
     expressions.  See also 'stream-from' for a similar procedure that
     creates infinite streams.

     Examples:

          (stream-range 0 10)
          => 0 1 2 3 4 5 6 7 8 9

          (stream-range 0 10 2)
          => 0 2 4 6 8

     Successive elements of the stream are calculated by adding STEP to
     FIRST, so if any of FIRST, PAST or STEP are inexact, the length of
     the output stream may differ from:

          (ceiling (- (/ (- past first) step) 1)


File: vicare-libs.info,  Node: streams of,  Next: streams fold,  Prev: streams range,  Up: streams

1.15.8 Comprehensions
---------------------

 -- Syntax: stream-of EXPR CLAUSE ...
     Provide the syntax of stream comprehensions, which generate streams
     by means of looping expressions.  The result is a stream of objects
     of the type returned by EXPR.  There are four types of CLAUSE
     arguments:

     '(var in stream-expr)'
          Loop over the elements of STREAM-EXPR, in order from the start
          of the stream, binding each element of the stream in turn to
          VAR.  'stream-from' and 'stream-range' are frequently useful
          as generators for STREAM-EXPR.

     '(var is expr)'
          Bind VAR to the value obtained by evaluating EXPR.

     '(pred expr)'
          Include in the output stream only those elements X for which
          '(pred x)' is true.

     The scope of variables bound in the stream comprehension is the
     clauses to the right of the binding clause (but not the binding
     clause itself) plus the result expression.

     When two or more generators are present, the loops are processed as
     if they are nested from left to right; that is, the rightmost
     generator varies fastest.  A consequence of this is that only the
     first generator may be infinite and all subsequent generators must
     be finite.  If no generators are present, the result of a stream
     comprehension is a stream containing the result expression; thus,
     '(stream-of 1)' produces a finite stream containing only the
     element '1'.

          (stream-of (* x x)
            (x in (stream-range 0 10))
            (even? x))
          => 0 4 16 36 64

          (stream-of (list a b)
            (a in (stream-range 1 4))
            (b in (stream-range 1 3)))
          => (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)

          (stream-of (list i j)
            (i in (stream-range 1 5))
            (j in (stream-range (+ i 1) 5)))
          => (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)


File: vicare-libs.info,  Node: streams fold,  Next: streams unfold,  Prev: streams of,  Up: streams

1.15.9 Folding
--------------

 -- Function: stream-iterate PROC BASE
     Create a newly-allocated stream containing BASE in its first
     element and apply PROC to each element in turn to determine the
     succeeding element.  See also 'stream-unfold' and 'stream-unfolds'.

     Examples:

          (stream-iterate (lambda (x) (+ x 1)) 0)
            => 0 1 2 3 4 ...

          (stream-iterate (lambda (x) (* x 2)) 1)
            => 1 2 4 8 16 ...

     Given a seed between 0 and 232, exclusive, the following expression
     creates a stream of pseudo-random integers between 0 and 232,
     exclusive, beginning with seed, using the method described by
     Stephen Park and Keith Miller:

          (stream-iterate
            (lambda (x) (modulo (* x 16807) 2147483647))
            seed)

     Example: successive of the following stream approach the value of
     the "golden ratio" 1.618...:

          (stream-iterate (lambda (x) (+ 1 (/ x))) 1)

 -- Function: stream-fold PROC BASE STREAM
     Apply a binary procedure to BASE and the first element of STREAM to
     compute a new base, then apply the procedure to the new base and
     the next element of STREAM to compute a succeeding base, and so on,
     accumulating a value that is finally returned as the value of
     'stream-fold' when the end of the STREAM is reached.

     STREAM must be finite, or 'stream-fold' will enter an infinite
     loop.  See also 'stream-scan', which is similar to 'stream-fold',
     but useful for infinite streams.

     For readers familiar with other functional languages, this is a
     left-fold; there is no corresponding right-fold, since right-fold
     relies on finite streams that are fully-evaluated, at which time
     they may as well be converted to a list.

     'stream-fold' is often used to summarize a stream in a single
     value, for instance, to compute the maximum element of a stream.

          (define (stream-maximum item< strm)
            (stream-fold
              (lambda (x y)
                (if (item< x y) y x))
              (stream-car strm)
              (stream-cdr strm)))

     Sometimes, it is useful to have 'stream-fold' defined only on
     non-null streams:

          (define (stream-fold-one proc strm)
            (stream-fold proc
              (stream-car strm)
              (stream-cdr strm)))

     'stream-minimum' can then be defined as:

          (define (stream-minimum item< strm)
            (stream-fold-one
              (lambda (x y)
                (if (item< x y) x y))
              strm))

     'stream-fold' can also be used to build a stream:

          (define-stream (isort item< strm)
            (define-stream (insert strm x)
              (stream-match strm
                (() (stream x))
                ((y .  ys)
                  (if (item< y x)
                      (stream-cons y (insert ys x))
                    (stream-cons x strm)))))
            (stream-fold insert stream-null strm))

 -- Function: stream-scan PROC BASE STREAM
     Accumulate the partial folds of an input STREAM into a
     newly-allocated output stream.  The output stream is the BASE
     followed by:

          (stream-fold proc base (stream-take i stream))

     for each of the first i elements of STREAM.

     Examples:

          (stream-scan + 0 (stream-from 1))
          => (stream 0 1 3 6 10 15 ...)

          (stream-scan * 1 (stream-from 1))
          => (stream 1 1 2 6 24 120 ...)


File: vicare-libs.info,  Node: streams unfold,  Next: streams map,  Prev: streams fold,  Up: streams

1.15.10 Unfolding
-----------------

 -- Function: stream-unfold MAP PRED GEN BASE
     'stream-unfold' is the fundamental recursive stream constructor.
     It constructs a stream by repeatedly applying GEN to successive
     values of BASE, in the manner of 'stream-iterate', then applying
     MAP to each of the values so generated, appending each of the
     mapped values to the output stream as long as '(pred base)' is
     non-'#f'.  See also 'stream-iterate' and 'stream-unfolds'.

     For example, the expression below creates the finite stream:

          0 1 4 9 16 25 36 49 64 81

     initially the base is '0', which is less than '10', so MAP squares
     the base and the mapped value becomes the first element of the
     output stream; then GEN increments the base by '1', so it becomes
     '1'; this is less than '10', so MAP squares the new base and '1'
     becomes the second element of the output stream; and so on, until
     the base becomes '10', when PRED? stops the recursion and
     'stream-null' ends the output stream.

          (stream-unfold
            (lambda (x) (expt x 2)) ; map
            (lambda (x) (< x 10))   ; pred
            (lambda (x) (+ x 1))    ; gen
            0)                      ; base

 -- Function: stream-unfolds PROC SEED
     Return N newly-allocated streams containing those elements produced
     by successive calls to the generator PROC, which takes the current
     SEED as its argument and returns 'n+1' values:

          (proc seed) -> seed R0 ...  R(n-1)

     where the returned SEED is the input SEED to the next call to the
     generator and R(i) indicates how to produce the next element of the
     i-th result stream:

     '(value)'
          VALUE is the next car of the result stream;

     '#f'
          no value produced by this iteration of the generator PROC for
          the result stream;

     '()'
          the end of the result stream.

     It may require multiple calls of PROC to produce the next element
     of any particular result stream.  See also 'stream-iterate' and
     'stream-unfold'.

     'stream-unfolds' is especially useful when writing expressions that
     return multiple streams.  For instance, with reference to the
     definitions below:

          (stream-partition pred strm)

     is equivalent to:

          (values
            (stream-filter pred strm)
            (stream-filter
                (lambda (x)
                  (not (pred x)))
               strm))

     but only tests 'pred' once for each element of STRM.

          (define (stream-partition pred strm)
            (stream-unfolds
              (lambda (s)
                (if (stream-null? s)
                    (values s '() '())
                  (let ((a (stream-car s))
                        (d (stream-cdr s)))
                    (if (pred a)
                        (values d (list a) #f)
                      (values d #f (list a))))))
              strm))

          (call-with-values
            (lambda ()
              (stream-partition odd?
                (stream-range 1 6)))
            (lambda (odds evens)
              (list (stream->list odds)
                    (stream->list evens))))
          => ((1 3 5) (2 4))


File: vicare-libs.info,  Node: streams map,  Next: streams match,  Prev: streams unfold,  Up: streams

1.15.11 Mapping and side effects
--------------------------------

 -- Function: stream-map PROC STREAM ...
     Apply a procedure element-wise to corresponding elements of the
     input streams, returning a newly-allocated stream containing
     elements that are the results of those procedure applications.  The
     output stream has as many elements as the minimum-length input
     stream, and may be infinite.

     Example:

          (define (square x)
            (* x x))

          (stream-map square (stream 9 3))
          => 81 9

          (define (sigma f m n)
            (stream-fold + 0
              (stream-map f (stream-range m (+ n 1)))))

          (sigma square 1 100)
          => 338350

 -- Function: stream-for-each PROC STREAM ...
     Apply a procedure element-wise to corresponding elements of the
     input streams for its side-effects; return nothing.
     'stream-for-each' stops as soon as any of its input streams is
     exhausted.

     Example, the following procedure displays the contents of a file:

          (define (display-file filename)
            (stream-for-each display
              (file->stream filename)))


File: vicare-libs.info,  Node: streams match,  Next: streams utilities,  Prev: streams map,  Up: streams

1.15.12 Matching
----------------

 -- Syntax: stream-match STREAM CLAUSE ...
     Provide the syntax of pattern-matching for streams.  The input
     STREAM is an expression that evaluates to a stream.  CLAUSE
     arguments are of the form:

          (?PATTERN ?EXPR)
          (?PATTERN ?FENDER ?EXPR)

     consisting of a ?PATTERN that matches a stream of a particular
     shape, an optional ?FENDER that must succeed if the ?PATTERN is to
     match, and an ?EXPR that is evaluated if the ?PATTERN matches.
     There are four types of patterns:

     '()'
          Matches the null stream.

     '(pat0 pat1 ...)'
          Matches a finite stream with length exactly equal to the
          number of pattern elements.

     '(pat0 pat1 ... . patrest)'
          Matches an infinite stream, or a finite stream with length at
          least as great as the number of pattern elements before the
          literal dot.

     'pat'
          Matches an entire stream; should always appear last in the
          list of clauses; it's not an error to appear elsewhere, but
          subsequent clauses could never match.

     Each ?PATTERN element may be either:

     _An identifier_
          Matches any stream element; additionally, the value of the
          stream element is bound to the variable named by the
          identifier, which is in scope in the fender and expression of
          the corresponding clause; each identifier in a single pattern
          must be unique.

     _A literal underscore_
          Matches any stream element, but creates no bindings.

     The patterns are tested in order, left-to-right, until a matching
     pattern is found; if ?FENDER is present, it must evaluate as true
     for the match to be successful.  Pattern variables are bound in the
     corresponding fender and expression.  Once the matching pattern is
     found, the corresponding expression is evaluated and returned as
     the result of the match.  An error is signaled if no pattern
     matches the input stream.

     'stream-match' is often used to distinguish null streams from
     non-null streams, binding head and tail:

          (define (len strm)
            (stream-match strm
              (()                 0)
              ((head . tail)      (+ 1 (len tail)))))

     Fenders can test the common case where two stream elements must be
     identical; the else pattern is an identifier bound to the entire
     stream, not a keyword as in 'cond'.

          (stream-match strm
            ((x y . _) (equal? x y)
             'ok)
            (else
             'error))

     A more complex example uses two nested matchers to match two
     different stream arguments; '(stream-merge lt? . strms)' stably
     merges two or more streams ordered by the LT? predicate:

          (define-stream (stream-merge lt? . strms)

            (define-stream (merge xx yy)
              (stream-match xx
                (() yy)
                ((x . xs)
                 (stream-match yy
                   (() xx)
                   ((y . ys)
                    (if (lt? y x)
                        (stream-cons y (merge xx ys))
                      (stream-cons x (merge xs yy))))))))

            (stream-let loop ((strms strms))
              (cond ((null? strms)
                     stream-null)
                    ((null? (cdr strms))
                     (car strms))
                    (else
                     (merge (car strms)
                            (apply stream-merge lt?
                            (cdr strms)))))))


File: vicare-libs.info,  Node: streams utilities,  Next: streams examples,  Prev: streams match,  Up: streams

1.15.13 Utilities
-----------------

Streams, being the signature structured data type of functional
programming languages, find useful expression in conjunction with
higher-order functions.  Some of these higher-order functions, and their
relationship to streams, are described below.

   The identity and constant procedures are frequently useful as the
recursive base for maps and folds; '(identity obj)' always returns OBJ,
and '(const obj)' creates a procedure that takes any number of arguments
and always returns the same OBJ, no matter its arguments:

     (define (identity obj)
       obj)

     (define (const obj)
       (lambda x obj))

   Many of the stream procedures take a unary predicate that accepts an
element of a stream and returns a boolean.  Procedure '(negate pred)'
takes a unary predicate and returns a new unary predicate that, when
called, returns the opposite boolean value as the original predicate.

     (define (negate pred)
       (lambda (x) (not (pred x))))

   'negate' is useful for procedures like 'stream-take-while' that take
a predicate, allowing them to be used in the opposite direction from
which they were written; for instance, with the predicate reversed,
'stream-take-while' becomes 'stream-take-until'.  'stream-remove' is the
opposite of 'stream-filter':

     (define-stream (stream-remove pred strm)
       (stream-filter (negate pred) strm))

   A section is a procedure which has been partially applied to some of
its arguments; for instance, '(double x)', which returns twice its
argument, is a partial application of the multiply operator to the
number 2.  Sections come in two kinds:

   * Left sections partially apply arguments starting from the left.

   * Right sections partially apply arguments starting from the right.

   The procedure 'lsec' takes a procedure and some prefix of its
arguments and returns a new procedure in which those arguments are
partially applied; the procedure 'rsec' takes a procedure and some
reversed suffix of its arguments and returns a new procedure in which
those arguments are partially applied:

     (define (lsec proc . args)
       (lambda x
         (apply proc (append args x))))

     (define (rsec proc . args)
       (lambda x
         (apply proc (reverse (append (reverse args)
                                      (reverse x))))))

   Since most of the stream procedures take a stream as their last
(rightmost) argument, left sections are particularly useful in
conjunction with streams.

     (define stream-sum (lsec stream-fold + 0))

   Function composition creates a new function by partially applying
multiple functions, one after the other.  In the simplest case there are
only two functions, F and G, composed as '(compose f g)'; the
composition can be bound to create a new function, as in:

     (define fg (compose f g))

the procedure 'compose' takes one or more procedures and returns a new
procedure that performs the same action as the individual procedures
would if called in succession:

     (define (compose . fns)
       (let comp ((fns fns))
         (cond
           ((null? fns) 'error)
           ((null? (cdr fns)) (car fns))
           (else
             (lambda args
               (call-with-values
                 (lambda ()
                   (apply
                     (comp (cdr fns))
                     args))
                 (car fns)))))))

   'compose' works with sections to create succinct but highly
expressive procedure definitions.  The expression to compute the squares
of the integers from 1 to 10 given above at 'stream-unfold' could be
written by composing 'stream-map', 'stream-take-while', and
'stream-iterate':

     ((compose
       (lsec stream-map (rsec expt 2))
       (lsec stream-take-while (negate (rsec > 10)))
       (lsec stream-iterate (rsec + 1)))
      1)


File: vicare-libs.info,  Node: streams examples,  Prev: streams utilities,  Up: streams

1.15.14 Examples
----------------

The examples below show a few of the myriad ways streams can be
exploited, as well as a few ways they can trip the unwary user.  All the
examples are drawn from published sources; it is instructive to compare
the Scheme versions to the originals in other languages.

* Menu:

* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co-routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.


File: vicare-libs.info,  Node: streams examples infinite,  Next: streams examples generators,  Up: streams examples

1.15.14.1 Infinite streams
..........................

As a simple illustration of infinite streams, consider this definition
of the natural numbers:

     (define nats
       (stream-cons 0
         (stream-map add1 nats)))

the recursion works because it is offset by one from the initial
'stream-cons'.  Another sequence that uses the offset trick is this
definition of the Fibonacci numbers:

     (define fibs
       (stream-cons 1
         (stream-cons 1
           (stream-map +
             fibs
             (stream-cdr fibs)))))

   Yet another sequence that uses the same offset trick is the Hamming
numbers, named for the mathematician and computer scientist Richard
Hamming, defined as all numbers that have no prime factors greater than
5; in other words, Hamming numbers are all numbers expressible as

     2i x 3j x 5k

where I, J and K are non-negative integers.  The Hamming sequence starts
with 1 2 3 4 5 6 8 9 10 12 and is computed starting with 1, taking 2, 3
and 5 times all the previous elements with 'stream-map', then merging
'sub-streams' and eliminating duplicates:

     (define hamming
       (stream-cons 1
         (stream-unique =
           (stream-merge <
             (stream-map (lsec * 2) hamming)
             (stream-map (lsec * 3) hamming)
             (stream-map (lsec * 5) hamming)))))

   It is possible to have an infinite stream of infinite streams.
Consider the definition of 'power-table':

     (define power-table
       (stream-of
         (stream-of (expt m n)
           (m in (stream-from 1)))
           (n in (stream-from 2))))

which evaluates to an infinite stream of infinite streams:

     (stream
       (stream 1 4 9 16 25 ...)
       (stream 1 8 27 64 125 ...)
       (stream 1 16 81 256 625 ...)
       ...)

   But even though it is impossible to display 'power-table' in its
entirety, it is possible to select just part of it:

     (stream->list 10 (stream-ref power-table 1))
       => (1 8 27 64 125 216 343 512 729 1000)

   This example clearly shows that the elements of a stream are computed
lazily, as they are needed; '(stream-ref power-table 0)' is not
computed, even when its successor is displayed, since computing it would
enter an infinite loop.

   Chris Reade shows how to calculate the stream of prime numbers
according to the sieve of Eratosthenes, using a method that eliminates
multiples of the sifting base with addition rather than division:

     (define primes (let ()
       (define-stream (next base mult strm)
         (let ((first (stream-car strm))
               (rest (stream-cdr strm)))
           (cond ((< first mult)
                   (stream-cons first
                     (next base mult rest)))
                 ((< mult first)
                   (next base (+ base mult) strm))
                 (else (next base
                         (+ base mult) rest)))))
       (define-stream (sift base strm)
         (next base (+ base base) strm))
       (define-stream (sieve strm)
         (let ((first (stream-car strm))>
               (rest (stream-cdr strm)))
           (stream-cons first
             (sieve (sift first rest)))))
       (sieve (stream-from 2))))

   A final example of infinite streams is a functional pearl from Jeremy
Gibbons, David Lester and Richard Bird that enumerates the positive
rational numbers without duplicates:

     (define rats
       (stream-iterate
         (lambda (x)
           (let* ((n (floor x)) (y (- x n)))
             (/ (- n -1 y))))
         1))


File: vicare-libs.info,  Node: streams examples generators,  Next: streams examples pipeline,  Prev: streams examples infinite,  Up: streams examples

1.15.14.2 Generators and co-routines
....................................

It is possible to model generators and co-routines using streams.
Consider the task, due to Carl Hewitt, of determining if two trees have
the same sequence of leaves:

     (same-fringe? = '(1 (2 3)) '((1 2) 3))  => #t

     (same-fringe? = '(1 2 3) '(1 (3 2)))    => #f

   The simplest solution is to flatten both trees into lists and compare
them element-by-element:

     (define (flatten tree)
       (cond [(null? tree) '()]
             [(pair? (car tree))
              (append (flatten (car tree))
                      (flatten (cdr tree)))]
             [else (cons (car tree)
                         (flatten (cdr tree)))]))

     (define (same-fringe? eql? tree1 tree2)
       (let loop ([t1 (flatten tree1)]
                  [t2 (flatten tree2)])
         (cond [(and (null? t1) (null? t2)) #t]
               [(or (null? t1) (null? t2)) #f]
               [(not (eql? (car t1) (car t2))) #f]
               [else (loop (cdr t1) (cdr t2))])))

   That works, but requires time to flatten both trees and space to
store the flattened versions; if the trees are large, that can be a lot
of time and space, and if the fringes differ, much of that time and
space is wasted.

   Hewitt used a generator to flatten the trees one element at a time,
storing only the current elements of the trees and the machines needed
to continue flattening them, so 'same-fringe?' could stop early if the
trees differ.  Dorai Sitaram presents both the generator solution and a
co-routine solution, which both involve tricky calls to
'call-with-current-continuation' and careful coding to keep them
synchronized.

   An alternate solution flattens the two trees to streams instead of
lists, which accomplishes the same savings of time and space, and
involves code that looks little different than the list solution
presented above:

     (define-stream (flatten tree)
       (cond [(null? tree) stream-null]
             [(pair? (car tree))
              (stream-append
                (flatten (car tree))
                (flatten (cdr tree)))]
             [else (stream-cons
                     (car tree)
                     (flatten (cdr tree)))]))

     (define (same-fringe? eql? tree1 tree2)
       (let loop ([t1 (flatten tree1)]
                  [t2 (flatten tree2)])
         (cond [(and (stream-null? t1)
                     (stream-null? t2)) #t]
               [(or  (stream-null? t1)
                     (stream-null? t2)) #f]
               [(not (eql? (stream-car t1)
                           (stream-car t2))) #f]
               [else (loop (stream-cdr t1)
                           (stream-cdr t2))])))

   Note that streams, a data structure, replace generators or
co-routines, which are control structures, providing a fine example of
how lazy streams enhance modularity.


File: vicare-libs.info,  Node: streams examples pipeline,  Next: streams examples persistent,  Prev: streams examples generators,  Up: streams examples

1.15.14.3 A pipeline of procedures
..................................

Another way in which streams promote modularity is enabling the use of
many small procedures that are easily composed into larger programs, in
the style of Unix pipelines, where streams are important because they
allow a large dataset to be processed one item at a time.  Bird and
Wadler provide the example of a text formatter.  Their example uses
right-folds:

     (define (stream-fold-right f base strm)
       (if (stream-null? strm)
           base
         (f (stream-car strm)
            (stream-fold-right f base
              (stream-cdr strm)))))

     (define (stream-fold-right-one f strm)
       (stream-match strm
         [(x) x]
         [(x . xs)
          (f x (stream-fold-right-one f xs))]))

   Bird and Wadler define text as a stream of characters, and develop a
standard package for operating on text, which they derive mathematically
(this assumes the line-separator character is a single '#\newline'):

     (define (breakon a)
       (stream-lambda (x xss)
         (if (equal? a x)
             (stream-append (stream (stream)) xss)
           (stream-append
             (stream (stream-append
                 (stream x) (stream-car xss)))
             (stream-cdr xss)))))

     (define-stream (lines strm)
       (stream-fold-right
         (breakon #\newline)
         (stream (stream))
         strm))

     (define-stream (words strm)
       (stream-filter stream-pair?
         (stream-fold-right
           (breakon #\space)
           (stream (stream))
           strm)))

     (define-stream (paras strm)
       (stream-filter stream-pair?
         (stream-fold-right
           (breakon stream-null)
           (stream (stream))
           strm)))

     (define (insert a)
       (stream-lambda (xs ys)
         (stream-append xs (stream a) ys)))

     (define unlines
       (lsec stream-fold-right-one
         (insert #\newline)))

     (define unwords
       (lsec stream-fold-right-one
         (insert #\space)))

     (define unparas
       (lsec stream-fold-right-one
         (insert stream-null)))

   These versatile procedures can be composed to count words, lines and
paragraphs; the 'normalize' procedure squeezes out multiple spaces and
blank lines:

     (define countlines
       (compose stream-length lines))

     (define countwords
       (compose stream-length
                stream-concat
                (lsec stream-map words)
                lines))

     (define countparas
       (compose stream-length paras lines))

     (define parse
       (compose (lsec stream-map
                  (lsec stream-map words))
                paras
                lines))

     (define unparse
       (compose unlines
                unparas
                (lsec stream-map
                  (lsec stream-map unwords))))

     (define normalize (compose unparse parse))

   More useful than normalization is text-filling, which packs as many
words onto each line as will fit.

     (define (greedy m ws)
       (- (stream-length
            (stream-take-while (rsec <= m)
              (stream-scan
                (lambda (n word)
                  (+ n (stream-length word) 1))
                -1
                ws))) 1))

     (define-stream (fill m ws)
       (if (stream-null? ws)
           stream-null
         (let* ([n (greedy m ws)]
                [fstline (stream-take n ws)]
                [rstwrds (stream-drop n ws)])
           (stream-append
             (stream fstline)
             (fill m rstwrds)))))

     (define linewords
       (compose stream-concat
                (lsec stream-map words)))

     (define textparas
       (compose (lsec stream-map linewords)
                paras
                lines))

     (define (filltext m strm)
       (unparse (stream-map (lsec fill m) (textparas strm))))

   To display filename in lines of N characters, say:

     (stream-for-each display
       (filltext n (file->stream filename)))

   Though each operator performs only a single task, they can be
composed powerfully and expressively.  The alternative is to build a
single monolithic procedure for each task, which would be harder and
involve repetitive code.  Streams ensure procedures are called as
needed.


File: vicare-libs.info,  Node: streams examples persistent,  Next: streams examples passes,  Prev: streams examples pipeline,  Up: streams examples

1.15.14.4 Persistent data
.........................

Queues are one of the fundamental data structures of computer science.
In functional languages, queues are commonly implemented using two
lists, with the front half of the queue in one list, where the head of
the queue can be accessed easily, and the rear half of the queue in
reverse order in another list, where new items can easily be added to
the end of a queue.  The standard form of such a queue holds that the
front list can only be null if the rear list is also null:

     (define queue-null (cons '() '())

     (define (queue-null? obj)
       (and (pair? obj) (null? (car obj))))

     (define (queue-check f r)
       (if (null? f)
           (cons (reverse r) '())
         (cons f r)))

     (define (queue-snoc q x)
       (queue-check (car q) (cons x (cdr q))))

     (define (queue-head q)
       (if (null? (car q))
           (error "empty queue: head")
         (car (car q))))

     (define (queue-tail q)
       (if (null? (car q))
           (error "empty-head: tail")
         (queue-check (cdr (car q)) (cdr q))))

   This queue operates in amortized constant time per operation, with
two conses per element, one when it is added to the rear list, and
another when the rear list is reversed to become the front list.
'queue-snoc' and 'queue-head' operate in constant time; 'queue-tail'
operates in worst-case linear time when the front list is empty.

   Chris Okasaki points out that, if the queue is used persistently, its
time-complexity rises from linear to quadratic since each persistent
copy of the queue requires its own linear-time access.  The problem can
be fixed by implementing the front and rear parts of the queue as
streams, rather than lists, and rotating one element from rear to front
whenever the rear list is larger than the front list:

     (define queue-null
       (cons stream-null stream-null))

     (define (queue-null? x)
       (and (pair? x) (stream-null (car x))))

     (define (queue-check f r)
       (if (< (stream-length r) (stream-length f))
           (cons f r)
         (cons (stream-append f (stream-reverse r))
               stream-null)))

     (define (queue-snoc q x)
       (queue-check (car q) (stream-cons x (cdr q))))

     (define (queue-head q)
       (if (stream-null? (car q))
           (error "empty queue: head")
         (stream-car (car q))))

     (define (queue-tail q)
       (if (stream-null? (car q))
           (error "empty queue: tail")
         (queue-check (stream-cdr (car q)) (cdr q))))

   Memoization solves the persistence problem; once a queue element has
moved from rear to front, it needs never be moved again in subsequent
traversals of the queue.  Thus, the linear time-complexity to access all
elements in the queue, persistently, is restored.


File: vicare-libs.info,  Node: streams examples passes,  Next: streams examples pitfalls,  Prev: streams examples persistent,  Up: streams examples

1.15.14.5 Reducing two passes to one
....................................

The final example is a lazy dictionary, where definitions and uses may
occur in any order; in particular, uses may precede their corresponding
definitions.  This is a common problem.

   Many programming languages allow procedures to be used before they
are defined.  Macro processors must collect definitions and emit uses of
text in order.  An assembler needs to know the address that a linker
will subsequently give to variables.  The usual method is to make two
passes over the data, collecting the definitions on the first pass and
emitting the uses on the second pass.  But Chris Reade shows how streams
allow the dictionary to be built lazily, so that only a single pass is
needed.  Consider a stream of requests:

     (define requests
       (stream
         '(get 3)
         '(put 1 "a")    ; use follows definition
         '(put 3 "c")    ; use precedes definition
         '(get 1)
         '(get 2)
         '(put 2 "b")    ; use precedes definition
         '(put 4 "d")))  ; unused definition

   We want a procedure that will display cab, which is the result of
'(get 3)', '(get 1)', and '(get 2)', in order.  We first separate the
request stream into gets and puts:

     (define (get? obj) (eq? (car obj) 'get))

     (define-stream (gets strm)
       (stream-map cadr (stream-filter get? strm)))

     (define-stream (puts strm)
       (stream-map cdr  (stream-remove get? strm)))

   Now, 'run-dict' inserts each element of the puts stream into a lazy
dictionary, represented as a stream of key/value pairs (an association
stream), then looks up each element of the gets stream with
'stream-assoc':

     (define-stream (run-dict requests)
       (let ([dict (build-dict (puts requests))])
         (stream-map (rsec stream-assoc dict)
           (gets requests))))

     (define (stream-assoc key dict)
         (cond [(stream-null? dict) #f]
               [(equal? key (car (stream-car dict)))
                (stream-car dict)]
               [else (stream-assoc key
                       (stream-cdr dict))]))

   DICT is created in the 'let', but nothing is initially added to it.
Each time 'stream-assoc' performs a lookup, enough of DICT is built to
satisfy the lookup, but no more.  We are assuming that each item is
defined once and only once.  All that is left is to define the procedure
that inserts new items into the dictionary, lazily:

     (define-stream (build-dict puts)
       (if (stream-null? puts)
           stream-null
         (stream-cons
           (stream-car puts)
           (build-dict (stream-cdr puts)))))


   Now we can run the requests and print the result:

     (stream-for-each display
       (stream-map cadr (run-dict requests)))

   The '(put 4 "d")' definition is never added to the dictionary because
it is never needed.


File: vicare-libs.info,  Node: streams examples pitfalls,  Prev: streams examples passes,  Up: streams examples

1.15.14.6 Pitfalls
..................

Programming with streams, or any lazy evaluator, can be tricky, even for
programmers experienced in the genre.  Programming with streams is even
worse in Scheme than in a purely functional language, because, though
the streams are lazy, the surrounding Scheme expressions in which they
are embedded are eager.  The impedance between lazy and eager can
occasionally lead to astonishing results.  Thirty-two years ago, William
Burge warned:

     Some care must be taken when a stream is produced to make sure that
     its elements are not really a list in disguise, in other words, to
     make sure that the stream elements are not materialized too soon.

   For example, a simple version of 'stream-map' that returns a stream
built by applying a unary procedure to the elements of an input stream
could be defined like this:

     (define-stream (stream-map proc strm) ;wrong!
       (let loop ([strm strm])
         (if (stream-null? strm)
             stream-null
           (stream-cons
             (proc (stream-car strm))
             (loop (stream-cdr strm))))))

   That looks right.  It properly wraps the procedure in
'stream-lambda', and the two legs of the 'if' both return streams, so it
type-checks.  But it fails because the named 'let' binds LOOP to a
procedure using normal 'lambda' rather than 'stream-lambda', so even
though the first element of the result stream is lazy, subsequent
elements are eager.  'stream-map' can be written using 'stream-let':

     (define-stream (stream-map proc strm)
       (stream-let loop ([strm strm])
         (if (stream-null? strm)
             stream-null
           (stream-cons
             (proc (stream-car strm))
             (loop (stream-cdr strm))))))

   Here, 'stream-let' assures that each element of the result stream is
properly delayed, because each is subject to the 'stream-lambda' that is
implicit in 'stream-let', so the result is truly a stream, not a "list
in disguise".  Another version of this procedure was given previously at
the description of 'define-stream'.

   Another common problem occurs when a stream-valued procedure requires
the next stream element in its definition.  Consider this definition of
'stream-unique':

     (define-stream (stream-unique eql? strm) ;wrong!
       (stream-match strm
         [() strm]
         [(_) strm]
         [(a b . _)
          (if (eql? a b)
              (stream-unique eql?
                (stream-cdr strm))
            (stream-cons a
              (stream-unique eql?
                (stream-cdr strm))))]))

the '(a b . _)' pattern requires the value of the next stream element
after the one being considered.  Thus, to compute the nth element of the
stream, one must know the n+1st element, and to compute the n+1st
element, one must know the n+2nd element, and to compute...  The correct
version, given above in the description of 'stream-drop-while', only
needs the current stream element.

   A similar problem occurs when the stream expression uses the previous
element to compute the current element:

     (define (nat n)
       (stream-ref
         (stream-let loop ([s (stream 0)])
           (stream-cons (stream-car s)
             (loop (stream (add1 (stream-car s))))))
         n))

this program traverses the stream of natural numbers, building the
stream as it goes.  The definition is correct: '(nat 15)' evaluates to
15; but it needlessly uses unbounded space because each stream element
holds the value of the prior stream element in the binding to S.

   When traversing a stream, it is easy to write the expression in such
a way that evaluation requires unbounded space, even when that is not
strictly necessary.  During the discussion of SRFI-40, Joe Marshall
created this infamous procedure:

     (define (times3 n)
       (stream-ref
         (stream-filter
           (lambda (x)
             (zero? (modulo x n)))
           (stream-from 0))
         3))

'(times3 5)' evaluates to 15 and '(times3 #e1e9)' evaluates to three
billion, though it takes a while.  In either case, 'times3' should
operate in bounded space, since each iteration mutates the promise that
holds the next value.  But it is easy to write 'times3' so that it does
not operate in bounded space, as the follies of SRFI-40 showed.

   The common problem is that some element of the stream (often the
first element) is bound outside the expression that is computing the
stream, so it holds the head of the stream, which holds the second
element, and so on.  In addition to testing the programmer, this
procedure tests the stream primitives (it caught several errors during
development) and also tests the underlying Scheme system (it found a bug
in one implementation).

   Laziness is no defense against an infinite loop; for instance, the
expression below never returns, because the 'odd?' predicate never finds
an odd stream element.

     (stream-null?
       (stream-filter odd?
         (stream-from 0 2)))

   Ultimately, streams are defined as promises, which are implemented as
thunks (lambda with no arguments).  Since a stream is a procedure,
comparisons such as 'eq?', 'eqv?' and 'equal?' are not meaningful when
applied to streams.  For instance, the expression

     (define s ((stream-lambda () stream-null)))

defines S as the null stream, and '(stream-null? s)' is '#t', but '(eq?
s stream-null)' is '#f'.

   To determine if two streams are equal, it is necessary to evaluate
the elements in their common prefixes, reporting '#f' if two elements
ever differ and '#t' if both streams are exhausted at the same time.

     (define (stream-equal? eql? xs ys)
       (cond [(and (stream-null? xs)
                   (stream-null? ys)) #t]
             [(or (stream-null? xs)
                  (stream-null? ys)) #f]
             [(not (eql? (stream-car xs)
                         (stream-car ys))) #f]
             [else (stream-equal? eql?
                     (stream-cdr xs)
                     (stream-cdr ys))]))

   It is generally not a good idea to mix lazy streams with eager
side-effects, because the order in which stream elements are evaluated
determines the order in which the side-effects occur.  For a simple
example, consider this side-effecting version of 'strm123':

     (define strm123-with-side-effects
       (stream-cons (begin (display "one") 1)
         (stream-cons (begin (display "two") 2)
           (stream-cons (begin (display "three") 3)
             stream-null))))

   The stream has elements '1 2 3'.  But depending on the order in which
stream elements are accessed, '"one"', '"two"' and '"three"' could be
printed in any order.

   Since the performance of streams can be very poor, normal (eager)
lists should be preferred to streams unless there is some compelling
reason to the contrary.  For instance, computing pythagorean triples
with streams:

     (stream-ref
       (stream-of (list a b c)
         (n in (stream-from 1))
         (a in (stream-range 1 n))
         (b in (stream-range a n))
         (c is (- n a b))
         (= (+ (* a a) (* b b)) (* c c)))
       50)

is about two orders of magnitude slower than the equivalent expression
using loops:

     (do ([n 1 (+ n 1)]) ([> n 228])
       (do ([a 1 (+ a 1)]) ([> a n])
         (do ([b a (+ b 1)]) ([> b n])
           (let ([c (- n a b)])
             (if (= (+ (* a a) (* b b)) (* c c))
                 (display (list a b c)))))))


File: vicare-libs.info,  Node: loops,  Next: comparisons,  Prev: streams,  Up: lang

1.16 Loop constructs
====================

The '(vicare language-extensions loops)' library provides extensions to
the Scheme language to loop over general sequences of values.

     *NOTE* The library is derived from the reference implementation of
     SRFI-42 by Sebastian Egner.

* Menu:

* loops intro::                 Introduction.
* loops comprehensions::        Comprehensions.
* loops qualifiers::            Qualifiers.
* loops generators::            Generators.


File: vicare-libs.info,  Node: loops intro,  Next: loops comprehensions,  Up: loops

1.16.1 Introduction
-------------------

An "eager comprehension" is a convenient notation for one or more nested
or parallel loops generating a sequence of values, and accumulating this
sequence into a result.  In its most simple form, a comprehension looks
like this:

     (list-ec (: i 5)
       (* i i))
     => (0 1 4 9 16)

where I is a local variable that is sequentially bound to the values 0,
1, ..., 4, and the squares of these numbers are collected in a list.
The following example illustrates most conventions with respect to
nesting and syntax:

     (list-ec (: n 1 4)
              (: i n)
       (list n i))
     => ((1 0) (2 0) (2 1)
         (3 0) (3 1) (3 2))

the variable N is first bound to 1 then to 2 and finally to 3, and for
each binding of N the variable I is bound to the values 0, 1, ..., N-1
in turn.  The expression '(list n i)' constructs a two-elements list for
each binding, and the comprehension 'list-ec' collects all these results
in a list.


File: vicare-libs.info,  Node: loops comprehensions,  Next: loops qualifiers,  Prev: loops intro,  Up: loops

1.16.2 Comprehensions
---------------------

* Menu:

* loops comprehensions do::     Simple loops.
* loops comprehensions list::   List accumulator loops.
* loops comprehensions string:: String accumulator loops.
* loops comprehensions vector:: Vector accumulator loops.
* loops comprehensions arith::  Arithmetic accumulator loops.
* loops comprehensions search:: Searching loops.
* loops comprehensions fold::   Folding loops.
* loops comprehensions define:: Defining new comprehensions.


File: vicare-libs.info,  Node: loops comprehensions do,  Next: loops comprehensions list,  Up: loops comprehensions

1.16.2.1 Simple loops
.....................

 -- Syntax: do-ec ?QUALIFIER ... COMMAND
     Evaluate the COMMAND exactly once for each binding in the sequence
     defined by the qualifiers.  If there are no qualifiers COMMAND is
     evaluated exactly once.  The expression is evaluated for its
     side-effects only.  The result of the comprehension is unspecified.

          (let ((x 0))
            (do-ec                ;no qualifiers
              (set! x (+ x 1)))
            x)
          => 1

          (let ((x 0))
            (do-ec (:range i 10)  ;i from 0 to 9
              (set! x (+ x 1)))
            x)
          => 10

          (let ((x 0))
            (do-ec (:range i 0)   ;loops zero times
              (set! x (+ x 1)))
            x)
          => 0

          (let ((x 0))
            (do-ec (:range n 10)  ;n from 0 to 9
                   (:range k n)   ;k from 0 to n
              (set! x (+ x 1)))
            x)
          => 45


File: vicare-libs.info,  Node: loops comprehensions list,  Next: loops comprehensions string,  Prev: loops comprehensions do,  Up: loops comprehensions

1.16.2.2 List accumulator loops
...............................

 -- Syntax: list-ec ?QUALIFIER ... EXPRESSION
     The list of values obtained by evaluating EXPRESSION once for each
     binding in the sequence defined by the qualifiers.  If there are no
     qualifiers the result is the list with the value of EXPRESSION.

          (list-ec                ;no qualifiers
            1)
          => (1)

          (list-ec (:range i 4)   ;i from 0 to 3
            i)
          => (0 1 2 3)

          (list-ec (:range n 3)
                   (:range k (+ n 1))
            (list n k))
          => ((0 0)
              (1 0) (1 1)
              (2 0) (2 1) (2 2))

 -- Syntax: append-ec ?QUALIFIER ... EXPRESSION
     The list obtained by appending all values of EXPRESSION, which must
     all be lists.  Think of it as:

          (apply append (list-ec ?QUALIFIER ... EXPRESSION))

     Examples:

          (append-ec              ;no qualifiers
            '(a b))
          => (a b)

          (append-ec (:range i 0) ;loops zero times
            '(a b))
          => '()

          (append-ec (:range i 1)
            '(a b))
          => (a b)

          (append-ec (:range i 2)
            '(a b))
          => '(a b a b)


File: vicare-libs.info,  Node: loops comprehensions string,  Next: loops comprehensions vector,  Prev: loops comprehensions list,  Up: loops comprehensions

1.16.2.3 String accumulator loops
.................................

 -- Syntax: string-ec ?QUALIFIER ... EXPRESSION
     The string of all values of EXPRESSION.  Think of it as:

          (list->string (list-ec ?QUALIFIER ... EXPRESSION))

     Examples:

          (string-ec              ;no qualifiers
            #\a)
          => (string #\a)

          (string-ec (:range i 0)
            #\a)
          => ""

          (string-ec (:range i 1)
            #\a)
          => "a"

          (string-ec (:range i 2)
            #\a)
          => "aa"

 -- Syntax: string-append-ec ?QUALIFIER ... EXPRESSION
     The string obtained by appending all values of EXPRESSION, which
     must all be strings.  Think of it as:

          (apply string-append (list-ec ?QUALIFIER ... EXPRESSION))

     Examples:

          (string-append-ec
            "ab")
          => "ab"

          (string-append-ec (:range i 0)
            "ab")
          => ""

          (string-append-ec (:range i 1)
            "ab")
          => "ab"

          (string-append-ec (:range i 2)
            "ab")
          => "abab"


File: vicare-libs.info,  Node: loops comprehensions vector,  Next: loops comprehensions arith,  Prev: loops comprehensions string,  Up: loops comprehensions

1.16.2.4 Vector accumulator loops
.................................

 -- Syntax: vector-ec ?QUALIFIER ... EXPRESSION
     The vector of all values of EXPRESSION.  Think of it as:

          (list->vector (list-ec ?QUALIFIER ... EXPRESSION))

     Examples:

          (vector-ec              ;no qualifiers
            1)
          => (vector 1)

          (vector-ec (:range i 0)
            i)
          => (vector)

          (vector-ec (:range i 1)
            i)
          => (vector 0)

          (vector-ec (:range i 2)
            i)
          => (vector 0 1)

 -- Syntax: vector-of-length-ec K ?QUALIFIER ... EXPRESSION
     The vector of all values of EXPRESSION, of which there must be
     exactly K.  This comprehension behaves like 'vector-ec' but can be
     implemented more efficiently.

          (vector-of-length-ec 1
            1)
          => (vector 1)

          (vector-of-length-ec 0 (:range i 0)
            i)
          => (vector)

          (vector-of-length-ec 1 (:range i 1)
            i)
          => (vector 0)

          (vector-of-length-ec 2 (:range i 2)
            i)
          => (vector 0 1)


File: vicare-libs.info,  Node: loops comprehensions arith,  Next: loops comprehensions search,  Prev: loops comprehensions vector,  Up: loops comprehensions

1.16.2.5 Arithmetic accumulator loops
.....................................

 -- Syntax: sum-ec ?QUALIFIER ... EXPRESSION
     The sum of all values of EXPRESSION.  Think of it as:

          (apply + (list-ec ?QUALIFIER ... EXPRESSION))

     Examples:

          (sum-ec                 ;no qualifiers
            1)
          => 1

          (sum-ec (:range i 0)
            i)
          => 0

          (sum-ec (:range i 1)
            i)
          => 0

          (sum-ec (:range i 2)
            i)
          => 1

          (sum-ec (:range i 3)
            i)
          => 3

 -- Syntax: product-ec ?QUALIFIER ... EXPRESSION
     The product of all values of EXPRESSION.  Think of it as:

          (apply * (list-ec ?QUALIFIER ... EXPRESSION))

     Examples:

          (product-ec             ;no qualifiers
            1)
          => 1

          (product-ec (:range i 1 0)      ;i from 1 to 1
            i)
          => 1

          (product-ec (:range i 1 1)      ;loop zero times
            i)
          => 1

          (product-ec (:range i 9 9)      ;loop zero times
            i)
          => 1

          (product-ec (:range i 1 2)      ;i from 1 to 1
            i)
          => 1

          (product-ec (:range i 1 3)      ;i from 1 to 2
            i)
          => 2

          (product-ec (:range i 1 4)      ;i from 1 to 3
            i)
          => 6

 -- Syntax: min-ec ?QUALIFIER ... EXPRESSION
 -- Syntax: max-ec ?QUALIFIER ... EXPRESSION
     The minimum and maximum of all values of EXPRESSION.  The sequence
     of values must be non-empty.  Think of these as

          (apply min (list-ec ?QUALIFIER ... EXPRESSION))
          (apply max (list-ec ?QUALIFIER ... EXPRESSION))

     If we want to return a default value in case the sequence is empty
     we may want to consider:

          (fold3-ec 'infinity ?QUALIFIER ... EXPRESSION min min)


File: vicare-libs.info,  Node: loops comprehensions search,  Next: loops comprehensions fold,  Prev: loops comprehensions arith,  Up: loops comprehensions

1.16.2.6 Searching loops
........................

 -- Syntax: any?-ec ?QUALIFIER ... TEST
     Tests whether any value of TEST in the sequence of bindings
     specified by the qualifiers is true.  If this is the case: '#t' is
     returned, otherwise '#f'.  If there are no bindings at all, in the
     sequence specified by the qualifiers, then the result is '#f'.  The
     enumeration of values stops after the first true value encountered.

 -- Syntax: every?-ec ?QUALIFIER ... TEST
     Tests whether all values of TEST are true.  If this is the case:
     '#t' is returned, otherwise '#f'.  If the sequence is empty the
     result is '#t'.  Enumeration stops after the first '#f'.

 -- Syntax: first-ec DEFAULT ?QUALIFIER ... EXPRESSION
 -- Syntax: last-ec DEFAULT ?QUALIFIER ... EXPRESSION
     The first or last value of EXPRESSION in the sequence of bindings
     specified by the qualifiers.  Before enumeration, the result is
     initialized with the value of DEFAULT; so this will be the result
     if the sequence is empty.  Enumeration is terminated in 'first-ec'
     when the first value has been computed.


File: vicare-libs.info,  Node: loops comprehensions fold,  Next: loops comprehensions define,  Prev: loops comprehensions search,  Up: loops comprehensions

1.16.2.7 Folding loops
......................

 -- Syntax: fold-ec X0 ?QUALIFIER ... EXPRESSION F2
 -- Syntax: fold3-ec X0 ?QUALIFIER ... EXPRESSION F1 F2
     Reduce the sequence x[1], x[2], ..., x[n-1] of values obtained by
     evaluating EXPRESSION once for each binding as specified by the
     ?QUALIFIER syntaxes.  The arguments X0, F2 and F1, all
     syntactically equivalent to EXPRESSION, specify the reduction
     process.

          (define (f2 expr knil)
            (+ knil (* expr expr)))

          (fold-ec 0              ;knil
                   (:range k 1 5) ;qualifier, k from 1 to 4
            k                     ;expression
            f2)
          => 30 ;(+ 0 (* 1 1) (* 2 2) (* 3 3) (* 4 4))

     The reduction process for 'fold-ec' is defined as follows.  A
     reduction variable X is initialized to the value of X0, and for
     each k \in {1, ..., n-1} the command:

          (set! x[k+1] (f2 x[k] x[k-1]))

     is evaluated.  Finally, x[n] is returned as the value of the
     comprehension.

     The reduction process for 'fold3-ec' is different:

       1. If and only if the sequence is empty: X0 is evaluated and
          returned as the value of the comprehension.

       2. If the sequence in non-empty: A reduction variable X is
          initialized to the value of '(f1 x[1])', and for each k \in
          {2, ..., n-1} the command:

               (set! x[k+1] (f2 x[k] x[k-1]))

          is evaluated; finally, x[n] is returned as the value of the
          comprehension.

     Example:

          (define (f2 expr knil)
            (+ knil (* expr expr)))

          (define (f1 x)
            x)

          (fold3-ec 1234                  ;never used
                    (:range k 2 5)        ;k from 2 to 4
            k                             ;expression
            f1
            f2)
          => 27 ;(+ (f1 2) (* 3 3) (* 4 4))

          (fold3-ec 1234
                    (:range k 2 2)        ;loop zero times
            k
            f1
            f2)
          => 1234

     As the order of the arguments suggests, X0 is evaluated outside the
     scope of the qualifiers, whereas the reduction expressions
     involving F1 and F2 are inside the scope of the qualifiers (so they
     may depend on any variable introduced by the qualifiers).  Note
     that F2 is evaluated repeatedly, with any side-effect or overhead
     this might have.

     The main purpose of these comprehensions is implementing other
     comprehensions as special cases.  They are generalizations of the
     procedures 'fold-left' and 'reduce'.  Note that 'fold3-ec' is
     defined such that X0 is only evaluated in case the sequence is
     empty.  This allows raising an error for the empty sequence.


File: vicare-libs.info,  Node: loops comprehensions define,  Prev: loops comprehensions fold,  Up: loops comprehensions

1.16.2.8 Defining new comprehensions
....................................

To create a new comprehension a hygienic macro with that name is
defined.  The macro transforms the new comprehension patterns into
instances of 'do-ec', which is the most fundamental eager comprehension,
or any other comprehension already defined.

   For example, the following code defines 'list-ec' and 'min-ec' in
terms of 'fold-ec' and 'fold3-ec':

     (define-syntax list-ec
       (syntax-rules ()
         ((_ ?etc1 ?etc ...)
          (reverse (fold-ec '() ?etc1 ?etc ... cons)))))

     (define-syntax min-ec
       (syntax-rules ()
         ((_ ?etc1 ?etc ...)
          (fold3-ec (min) ?etc1 ?etc ... min min))))

   Note that the pattern '?etc1 ...' matches QUALIFIER* and EXPRESSION
without separate access to QUALIFIER* and EXPRESSION.  In order to
define a comprehension that does need explicit access to the EXPRESSION
part, the following method is used.

   First, all qualifiers are collected into a nested-qualifier, and then
the "exactly one qualifier" case is implemented.  For illustration, the
following code defines 'fold3-ec' in terms of 'do-ec':

     (define-syntax fold3-ec
       (syntax-rules (nested)

         ((fold3-ec x0 (nested q1 ...) q etc1 etc2 etc3 etc ...)
          (fold3-ec x0 (nested q1 ... q) etc1 etc2 etc3 etc ...))

         ((fold3-ec x0 q1 q2 etc1 etc2 etc3 etc ...)
          (fold3-ec x0 (nested q1 q2) etc1 etc2 etc3 etc ...))

         ((fold3-ec x0 expression f1 f2)
          (fold3-ec x0 (nested) expression f1 f2))

         ((fold3-ec x0 qualifier expression f1 f2)
          (let ((result #f)
                (empty  #t))
            (do-ec qualifier
              (let ((value expression)) ; don't duplicate code
                (if empty
                    (begin
                      (set! result (f1 value))
                      (set! empty #f))
                  (set! result (f2 value result)))))
            (if empty x0 result)))))

   Finally, observe that the newly defined 'fold3-ec' comprehension
inherits all types of qualifiers supported by 'do-ec', including all
application-specific generators; no further definitions are necessary.


File: vicare-libs.info,  Node: loops qualifiers,  Next: loops generators,  Prev: loops comprehensions,  Up: loops

1.16.3 Qualifiers
-----------------

This section defines the syntax ?QUALIFIER.  The nesting of qualifiers
is from left (outer) to right (inner).  In other words, the rightmost
generator "spins faster".  The nesting also defines the region of the
variables introduced by the generators.  This implies that inner
generators may depend on the variables of outer generators.  The
sequence of enumeration of values is strictly depth first.  These
conventions are illustrated by the first example.

   The syntax ?QUALIFIER consists of the following alternatives.

 -- Qualifier Syntax: ?GENERATOR
     Enumerate a sequence of bindings of one or more variables.  The
     region of the variables starts at the generator and extends over
     all subsequent qualifiers and expressions in the comprehension
     (*note loops generators::).

 -- Qualifier Syntax: if TEST
     Filter the sequence of bindings by testing if TEST evaluates to
     true.  Only for those bindings for which this is the case, the
     subsequent qualifiers of the comprehension are evaluated.

          (list-ec (:range i 10)
                   (if (even? i))
            i)
          => (0 2 4 6 8)

          (list-ec (:range i 5)
                   (if (even? i))
                   (:let j (+ 1 i))
            j)
          => (1 3 5)

 -- Qualifier Syntax: not TEST
 -- Qualifier Syntax: and TEST ...
 -- Qualifier Syntax: or TEST ...
     Abbreviated notations for filters of the form:

          (if (not TEST))
          (if (and TEST ...))
          (if (or  TEST ...))

 -- Qualifier Syntax: begin SEQUENCE
     Evaluate SEQUENCE, consisting of 'COMMAND ... EXPRESSION', once for
     each binding of the variables defined by the previous qualifiers in
     the comprehension.  Using this qualifier, side effects can be
     inserted into the body of a comprehension.

          (let* ((ans '())
                 (ell (list-ec (:range i 5)
                               (begin
                                 (set! ans (cons i ans)))
                               i)))
            (list ans ell))
          => ((4 3 2 1 0)
              (0 1 2 3 4))

 -- Qualifier Syntax: nested ?QUALIFIER ...
     A syntactic construct to group qualifiers.  The meaning of a
     qualifier according to the 'nested' syntax is the same as inserting
     the ?QUALIFIER syntaxes into the enclosing comprehension.

     This construct can be used to reduce comprehensions with several
     qualifiers into a form with exactly one qualifier.

          (list-ec (nested (:range i 5)
                           (if (even? i))
                           (:let j (+ 1 i)))
            j)
          => (1 3 5)

          (list-ec (:range i 5)
                   (nested (if (even? i))
                           (:let j (+ 1 i)))
            j)
          => (1 3 5)

          (list-ec (:range i 5)
                   (if (even? i))
                   (nested (:let j (+ 1 i)))
            j)
          => (1 3 5)

          (list-ec (:range i 5)
                   (if (even? i))
                   (:let j (+ 1 i))
                   (nested)
            j)
          => (1 3 5)


File: vicare-libs.info,  Node: loops generators,  Prev: loops qualifiers,  Up: loops

1.16.4 Generators
-----------------

* Menu:

* loops generators intro::      Introduction to generators.
* loops generators do::         Loop generators.
* loops generators typed::      Typed generators.
* loops generators ranges::     Range generators.
* loops generators port::       Port generators.
* loops generators dispatch::   Dispatched generators.
* loops generators let::        Let generators.
* loops generators parallel::   Parallel generators.
* loops generators cond::       Conditional generators.


File: vicare-libs.info,  Node: loops generators intro,  Next: loops generators do,  Up: loops generators

1.16.4.1 Introduction to generators
...................................

This section defines the syntax ?GENERATOR.  Each generator defines a
sequence of bindings through which one or more variables are run.  The
scope of the variables begins after the closing parenthesis of the
generator expression and extends to the end of the comprehension it is
part of.

   The variables defined by the generators are specified using the
syntax:

     ?VARS -> ?VARIABLE1
            |  ?VARIABLE1 (index ?VARIABLE2)

where ?VARIABLE1 runs through the values in the sequence defined by the
generator, and the optional ?VARIABLE2 is an exact integer-valued index
variable counting the values (starting from 0).  The names of the
variables must be distinct.  The following example illustrates the index
variable:

     (list-ec (: x (index i) "abc")
        (list x i))
     => ((#\a 0) (#\b 1) (#\c 2))

   Unless defined otherwise, all generators make sure that the
expressions provided for their syntactic arguments are evaluated exactly
once, before enumeration begins.  Moreover, it may be assumed that the
generators do not copy the code provided for their arguments, because
that could lead to exponential growth in code size.

   Finally, it is possible to assign a value to the variables defined by
a generator, but the effect of this assignment is unspecified; example:

     (list-ec (:range i 5)
       (set! i #\a)          ;undefined behaviour because of this
       ---)


File: vicare-libs.info,  Node: loops generators do,  Next: loops generators typed,  Prev: loops generators intro,  Up: loops generators

1.16.4.2 Loop generators
........................

 -- Generator Syntax: :do (?LB ...) ?NE1? (?LS ...)
 -- Generator Syntax: :do (let (?OB ...) ?OC ...) (?LB ...) ?NE1? (let
          (?IB ...) ?IC ...) ?NE2? (?LS ...)
     Defines a generator in terms of a named 'let', optionally decorated
     with inner and outer 'let'.  This generator is for defining other
     generators.  (In fact, the reference implementation transforms any
     other generator into an instance of fully decorated ':do'.)

     The generator is a compromise between expressive power (more
     flexible loops) and fixed structure (necessary for merging and
     modifying generators).

     In the fully decorated form, the following syntactic variables are
     present:

     ?OB
          Outer binding.

     ?OC
          Outer command.

     ?LB
          Loop binding.

     ?NE1?
          Not end predicate.

     ?IB
          Inner binding.

     ?IC
          Inner command.

     ?NE2?
          Not end predicate.

     ?LS
          Loop step.

     They define the following loop skeleton:

          (let (?OB ...)
            ?OC ...
            (let loop (?LB ...)
              (when ?NE1?
                (let (?IB ...)
                  ?IC ...
                  payload
                  (when ?NE2?
                    (loop ?LS ...))))))

     where ?OC and ?IC are syntactically equivalent to forms in the body
     of a 'begin', i.e.  they do not begin with a ?DEFINITION.  The
     latter requirement allows the code generator to produce more
     efficient code for special cases by removing empty 'let'
     expressions altogether.


File: vicare-libs.info,  Node: loops generators typed,  Next: loops generators ranges,  Prev: loops generators do,  Up: loops generators

1.16.4.3 Typed generators
.........................

 -- Generator Syntax: :list VARS ARG0 ARG ...
 -- Generator Syntax: :string VARS ARG0 ARG ...
 -- Generator Syntax: :vector VARS ARG0 ARG ...
     Run through one or more lists, strings, or vectors.  First all the
     ARG expressions are evaluated and then all elements of the
     resulting values are enumerated from left to right.  One can think
     of it as first appending all arguments and then enumerating the
     combined object.

          (list-ec (:string c (index i) "a" "b")
            (cons c i))
          => ((#\a . 0) (#\b . 1))

          (list-ec (:string c (index i) "ciao" "mamma")
            (cons c i))
          => ((#\c . 0) (#\i . 1) (#\a . 2) (#\o . 3)
              (#\m . 4) (#\a . 5) (#\m . 6) (#\m . 7) (#\a . 8))

 -- Generator Syntax: :integers VARS
     Runs through the sequence 0, 1, 2, ... of non-negative integers.
     This is most useful in combination with ':parallel', ':while', and
     ':until' or with a non-local exit in the body of the comprehension.

Application specific typed generator
....................................

To define a new typed generator a hygienic referentially transparent
macro of the same name is defined to transform the generator pattern
into an instance of the ':do' generator.  The extension is fully
modular, meaning that no other macro has to be modified to add the new
generator.  This is achieved by defining the new macro in Continuation
Passing Style.

   Technically, this works as follows.  Assume the generator syntax:

     (:mygen VAR ARG)

is to be implemented, for example running the variable VAR through the
list '(reverse ARG)'.  The following definition implements ':mygen' in
terms of ':list' using the additional syntactic variable CC (read
current continuation):

     (define-syntax :mygen
       (syntax-rules ()
         ((:mygen cc var arg)
          (:list cc var (reverse arg)))))

   After this definition, any comprehension will accept the ':mygen'
generator and produce the proper code for it.  This works as follows.
When a comprehension sees something of the form '(G ARG ...)' in the
position of a ?QUALIFIER then it will transform the entire comprehension
into:

     (G (continue ...) ARG ...)

   This effectively "transfers control" to the macro G, for example
':mygen'.  The macro G has full control of the transformation, but
eventually it should transform the expression into:

     (:do (continue ...)  etc ...)

   In the ':mygen' example this is done by the ':list' macro.  The macro
':do' finally transforms into:

     (continue ... (:do etc ...))

   As 'continue' has been chosen by the macro implementing the
comprehension, it can regain control and proceed with other qualifiers.

   In order to ensure consistency of new generators with the ones
defined in '(vicare language-extensions loops)', a few conventions are
in order.

   * The generator patterns begin with one or more variables followed by
     arguments defining the sequence.

   * Each generator except ':do' can handle an optional index variable.
     This is most easily implemented using ':parallel' together with
     ':integers'.  In case the payload generator needs an index anyhow
     (e.g.  ':vector') it is more efficient to add an index variable if
     none is given and to implement the indexed case.

   * Make sure that no syntactic variable of the generator pattern ever
     gets duplicated in the code (to avoid exponential code size in
     nested application), and introduce sufficient intermediate
     variables to make sure expressions are evaluated at the correct
     time.


File: vicare-libs.info,  Node: loops generators ranges,  Next: loops generators port,  Prev: loops generators typed,  Up: loops generators

1.16.4.4 Range generators
.........................

 -- Generator Syntax: :range VARS STOP
 -- Generator Syntax: :range VARS START STOP
 -- Generator Syntax: :range VARS START STOP STEP
     Runs through a range of exact rational numbers.

     '(:range VARS STOP)'
          Evaluate the expression STOP, which must result in an exact
          integer N, and runs through the finite sequence 0, 1, 2, ...,
          N-1.  If N is zero or negative the sequence is empty.

     '(:range VARS START STOP)'
          Evaluate the expressions START and STOP, which must result in
          exact integers A and B, and runs through the finite sequence
          A, A+1, A+2, ..., B-1.  If B is less or equal A then the
          sequence is empty.

     '(:range VARS START STOP STEP)'
          First evaluates the expressions START, STOP and STEP, which
          must result in exact integers A, B and S such that S is
          non-zero.  Then the sequence A, A+S, A+2*S, ..., A+(N-1)*S is
          enumerated where: N = ceil((B-A)/S).

          In other words, the sequence starts at A, increments by S, and
          stops when the next value would reach or cross B. If N is zero
          or negative the sequence is empty.

 -- Generator Syntax: :real-range VARS STOP
 -- Generator Syntax: :real-range VARS START STOP
 -- Generator Syntax: :real-range VARS START STOP STEP
     Runs through a range of real numbers using an explicit index
     variable.  This form of range enumeration avoids accumulation of
     rounding errors and is the one to use if any of the numbers
     defining the range is inexact, not an integer, or a bignum of large
     magnitude.

     Providing default values 0 for START and 1 for STEP, the generator
     first evaluates START, STOP and STEP, which must result in reals A,
     B and S such that N = (B-A)/S is also representable as a real.
     Then the sequence 0, 1, 2, ..., N-1 is enumerated while the current
     value I is less than N, and the variable in VARS is bound to the
     value A+I*S. If any of the values A, B or S is non-exact then all
     values in the sequence are non-exact.

 -- Generator Syntax: :char-range VARS MIN MAX
     Run through a range of characters.  First MIN and MAX are
     evaluated, which must result in two characters A and B. Then the
     sequence of characters A, A+1, A+2, ..., B is enumerated in the
     order defined by 'char<=?'.  If B is smaller than A then the
     sequence is empty.  Note that B is included in the sequence.


File: vicare-libs.info,  Node: loops generators port,  Next: loops generators dispatch,  Prev: loops generators ranges,  Up: loops generators

1.16.4.5 Port generators
........................

 -- Generator Syntax: :port VARS PORT
 -- Generator Syntax: :port VARS PORT READ-PROC
     Read from the port until the eof-object is read.  If a port reader
     procedure READ-PROC is supplied: The generator first evaluates PORT
     and READ-PROC, which must result in an input port P and a procedure
     R.  Then the variable is run through the sequence obtained by '(R
     P)' while the result does not satisfy 'eof-object?'.


File: vicare-libs.info,  Node: loops generators dispatch,  Next: loops generators let,  Prev: loops generators port,  Up: loops generators

1.16.4.6 Dispatched generators
..............................

 -- Generator Syntax: : VARS ARG0 ARG ...
     First the ARG expressions are evaluated into a[1], a[2], ..., a[n]
     and then a global dispatch procedure is used to dispatch on the
     number and types of the arguments and run the resulting generator.
     Initially the following cases are recognized, with i \in {1, ...,
     n}:

     ':list'
          If for all i:

               (list? a[i]) => #t

     ':string'
          If for all i:

               (string? a[i]) => #t

     ':vector'
          If for all i:

               (vector? a[i]) => #t

     ':range'
          If n \in {1, ..., 3} and for all i \in {1, ..., n}:

               (and (integer? a[i])
                    (exact?   a[i]))
               => #t

     ':real-range'
          If n \in {1, ..., 3} and for all i \in {1, ..., n}:

               (real? a[i]) => #t

     ':char-range'
          If n = 2 and for all i \in {1, 2}:

               (char? a[i]) => #t

     ':port'
          If n \in {1, 2} and:

               (and (input-port? a[1])
                    (procedure?  a[2]))
               => #t

     The current dispatcher can be retrieved as '(:-dispatch-ref)', a
     new dispatcher 'd' can be installed by '(:-dispatch-set! d)'
     yielding an unspecified result, and a copy of the initial
     dispatcher can be obtained as '(make-initial-:-dispatch)'.  Please
     refer to the section below for recommendation how to add cases to
     the dispatcher.

 -- Generator Syntax: :dispatched VARS DISPATCH ARG0 ARG ...
     Runs the variables through a sequence defined by DISPATCH and the
     ARG expressions.  The purpose of ':dispatched' is implementing
     dispatched generators, in particular the predefined dispatching
     generator ':'.

     The working of ':dispatched' is as follows: First DISPATCH and the
     ARG expressions are evaluated, resulting in a procedure D (the
     "dispatcher") and the values a[1], a[2], ..., a[n].  Then:

          (d (list a[1] a[2] ... a[n]))

     is evaluated, resulting in a value G.  If G is not a procedure then
     the dispatcher did not recognize the argument list and an error is
     raised.  Otherwise the "generator procedure" G is used to run VARS
     through a sequence of values.

     The sequence defined by G is obtained by repeated evaluation of '(G
     EMPTY)' until the result is EMPTY.  In other words, G indicates the
     end of the sequence by returning its only argument, for which the
     caller has provided an object distinct from anything G can produce.

     The definition of dispatchers is greatly simplified by the macro
     ':generator-proc' that constructs a generator procedure from a
     typed generator.  Let '(G VAR ARG0 ARG ...)' be an instance of the
     ?GENERATOR syntax, for example an application-specific typed
     generator, with a single variable VAR and no index variable.  Then:

          (:generator-proc (g arg0 arg ...))
          => g

     where the generator procedure G runs through the list:

          (list-ec (g var arg0 arg ...) var)

     In order to define a new dispatching generator (say ':my') first a
     dispatching procedure (say ':my-dispatch') is defined.  The
     dispatcher will be called with a single (!)  argument containing
     the list of all values to dispatch on.  To enable informative error
     messages, the dispatcher should return a descriptive object (e.g.
     a symbol for the module name) when it is called with the empty
     list.  Otherwise (if there is at least one value to dispatch on),
     the dispatcher must either return a generator procedure or '#f'
     (which means: no interest).  As an example, the following skeleton
     code defines a dispatcher similar to the initial dispatcher of ':':

          (define (:my-dispatch args)
            (case (length args)
              ((1) (let ((a1 (car args)))
                     (cond
                      ((list? a1)
                       (:generator-proc (:list a1)))
                      ((string? a1)
                       (:generator-proc (:string a1)))
                      ...more unary cases...
                      (else
                       #f))))
              ((2) (let ((a1 (car args))
                         (a2 (cadr args)))
                     (cond
                      ((and (list? a1) (list? a2))
                       (:generator-proc (:list a1 a2)))
                      ...more binary cases...
                      (else
                       #f))))
              ...more arity cases...
              (else
               (cond
                ((every?-ec (:list a args) (list? a))
                 (:generator-proc (:list (apply append args))))
                ...more large variable arity cases...
                (else
                 #f)))))

     Once the dispatcher has been defined, the following macro
     implements the new dispatching generator:

          (define-syntax :my
            (syntax-rules (index)
              ((:my cc var (index i) arg0 arg ...)
               (:dispatched cc var (index i) :my-dispatch arg0 arg ...))
              ((:my cc var arg0 arg ...)
               (:dispatched cc var :my-dispatch arg0 arg ...))))

     This method of extension yields complete control of the dispatching
     process.  Other modules can only add cases to ':my' if they have
     access to ':my-dispatch'.

Extending the predefined dispatched generator
.............................................

An alternative to adding a new dispatched generator is to extend the
predefined generator ':'.  Technically, extending ':' means installing a
new global dispatching procedure using ':-dispatch-set!' as described
above.  In most cases, however, the already installed dispatcher should
be extended by new cases.  The following procedure is a utility for
doing so:

     (dispatch-union d1 d2)
     => d

where the new dispatcher D recognizes the union of the cases recognized
by the dispatchers D1 and D2.  The new dispatcher always tries both
component dispatchers and raises an error in case of conflict.  The
identification returned by '(d)' is the concatenation of the component
identifications '(d1)' and '(d2)', enclosed in lists if necessary.  For
illustration, consider the following code:

     (define (example-dispatch args)
       (cond
        ((null? args)
         'example)
        ((and (= (length args) 1) (symbol? (car args)) )
         (:generator-proc (:string (symbol->string (car args)))))
        (else
         #f)))

     (:-dispatch-set! (dispatch-union (:-dispatch-ref) example-dispatch))

   After evaluation of this code, the following example will work:

     (list-ec (: c 'abc)
       c)
     => (#\a #\b #\c)

   Adding cases to ':' is particularly useful for frequent cases of
interactive input.  Be warned, however, that the advantage of global
extension also carries the danger of conflicts, unexpected side-effects,
and slow dispatching.


File: vicare-libs.info,  Node: loops generators let,  Next: loops generators parallel,  Prev: loops generators dispatch,  Up: loops generators

1.16.4.7 Let generators
.......................

 -- Generator Syntax: :let VARS EXPRESSION
     Run through the sequence consisting of the value of EXPRESSION,
     only.  This is the same as:

          (:list VARS (list EXPRESSION))

     If an index variable is specified, its value is 0.  The ':let'
     generator can be used to introduce an intermediate variable
     depending on outer generators.


File: vicare-libs.info,  Node: loops generators parallel,  Next: loops generators cond,  Prev: loops generators let,  Up: loops generators

1.16.4.8 Parallel generators
............................

 -- Generator Syntax: :parallel ?GENERATOR ...
     Run several generators in parallel.  This means that the next
     binding in the sequence is obtained by advancing each generator by
     one step.  The parallel generator terminates when any of its
     component generators terminate.  The generators share a common
     scope for the variables they introduce.  This implies that the
     names of the variables introduced by the various generators must be
     distinct.


File: vicare-libs.info,  Node: loops generators cond,  Prev: loops generators parallel,  Up: loops generators

1.16.4.9 Conditional generators
...............................

 -- Generator Syntax: :while ?GENERATOR EXPRESSION
     Run ?GENERATOR while EXPRESSION evaluates to true.  The guarding
     expression is included in the region of the variables introduced by
     the generator.

     Note the distinction between the filter 'if' and the modified
     generator expressed by ':while'.

 -- Generator Syntax: :until ?GENERATOR EXPRESSION
     Run ?GENERATOR until after EXPRESSION has evaluated to true.  The
     guarding expression is included in the region of the variables
     introduced by the generator.

   Note the distinction between ':while', stopping at a certain
condition, and ':until', stopping after a certain condition has
occurred.  The latter implies that the binding that has triggered
termination has been processed by the comprehension.


File: vicare-libs.info,  Node: comparisons,  Next: restarts,  Prev: loops,  Up: lang

1.17 Comparison functions
=========================

The library '(vicare language-extensions comparisons)' implements an
infrastructure for comparison functions; it can be seen as an extension
of the standard procedures '=', '<', 'char<?' etc.  The primary design
aspect is the separation of representing a total order and using it.

   Since the compare procedures are often optional, comparing built in
types is as convenient as using built in function, sometimes more
convenient: For example, testing if the integer index 'i' lies in the
integer range [0, n) can be written as '(<=/<? 0 i n)'.

* Menu:

* comparisons intro::           Introduction.
* comparisons examples::        Examples.
* comparisons conventions::     Terminology and conventions.
* comparisons atoms::           Comparing atoms.
* comparisons sequence::        Comparing lists and vectors.
* comparisons pair::            Comparing pairs and improper lists.
* comparisons default::         The default compare procedure.
* comparisons cons::            Constructing compare procedures.
* comparisons branch::          Branching.
* comparisons pred::            Predicates.
* comparisons minmax::          Minimum and maximum values.
* comparisons debug::           Debugging procedure.


File: vicare-libs.info,  Node: comparisons intro,  Next: comparisons examples,  Up: comparisons

1.17.1 Introduction
-------------------

The '(vicare language-extensions comparisons)' library defines a
mechanism for comparing Scheme values with respect to a total order (aka
linear order).  The mechanism provides operations for:

  1. Comparing objects of the built-in types.

  2. Using a total order in situations that arise in programs.

  3. Facilitating the definition of a new total order.

   Traditionally, a total order is represented in Scheme by an order
predicate, like '<' or 'char<?'.  In the context of '(vicare
language-extensions comparisons)', however, a total order is represented
by a Scheme procedure comparing its two arguments and returning either
-1, 0, or 1 depending on whether the first argument is considered
smaller, equal, or greater than the second argument respectively.
Examples of such compare procedures include:

     (lambda (x y)
       (sign (- x y)))

for comparing real numbers, but also:

     (lambda (x y) 0)

comparing anything.

   The primary reason for using 3-valued compare procedures (instead of
2-valued order predicates) is efficiency: When comparison is
computationally expensive, it is wasteful if two predicates are
evaluated where a single 3-valued comparison would suffice.

   But dealing directly with 3-valued comparisons in the application
program is inconvenient and obscures intention: For testing x < y one
would have to write:

     (= (compare x y) -1)

for this reason, an operation '<?' is supplied which allows to phrase
the same test as:

     (<? compare x y)

   This is an example of mapping the three possible outcomes of a
comparison into the two boolean values '#t' and '#f'.  Since '<?' takes
the total order as an explicit parameter, a comfortably large arsenal of
tests can be made available for each and every total order.  This
deviates from the approach of R6RS, in which there are only five
operations ('=', '<', '>', '<=', '>=') and for each total order
(real/number, char, char-ci, string, string-ci) a complete set of these
five operations is provided.

   But still, using '<?' would be inconvenient if the compare procedure
would have to be supplied explicitly every time.  For this reason, the
argument COMPARE is often made optional and the procedure
'default-compare' is used whenever no COMPARE procedure is passed
explicitly.  'default-compare' defines some resonable total order on the
builtin types of R6RS.

   For the definition of comparison procedures, special control
structures (macros) are provided.  These control structures can be used
in the definition of a (potentially recursive) comparison procedure.


File: vicare-libs.info,  Node: comparisons examples,  Next: comparisons conventions,  Prev: comparisons intro,  Up: comparisons

1.17.2 Examples
---------------

Assume there is a type 'length' representing physical length; the type
has an accessor procedure 'meters' returning the length in meters (a
real number):

     (define-record-type length
       (fields (immutable meters     meters)))

   A compare procedure for lengths can then be defined in terms of
'real-compare' as:

     (define (length-compare length1 length2)
       (real-compare (meters length1) (meters length2)))

now:

     (<? length-compare x y)

tests if length X is shorter than length Y.  Also,

     (<=/<? length-compare a x b)

tests if length X lies between length A (included) and length B
(excluded).  The expression:

     (min-compare length-compare x y z)

is the shortest of the lengths X, Y, and Z.  Likewise,

     (chain<? length-compare x1 x2 x3 x4)

tests if the lengths X1, X2, X3, X3 are strictly increasing, and so on.

   Furthermore, assume there is another type 'box' representing a
physical box; the type has procedures 'width', 'height', and 'depth'
accessing the dimension (each giving a length):

     (define-record-type box
       (fields (immutable width      width)
               (immutable height     height)
               (immutable depth      depth)))

   A comparison procedure for boxes, comparing first by width then by
height and then by depth, can be defined using the control structure
'refine-compare' as:

     (define (box-compare box1 box2)
       (refine-compare
         (length-compare (width  box1) (width  box2))
         (length-compare (height box1) (height box2))
         (length-compare (depth  box1) (depth  box2))))

so:

     (<? box-compare b1 b2)

tests if box B1 is smaller than box B2, in the sense of the order
defined.  Of course, all the other tests, minimum, maximum etc.  are
available, too.

   As a final complication, assume that there is also a type 'bowl' with
accessors 'radius' (a 'length') and 'open?' (a boolean):

     (define-record-type bowl
       (fields (immutable radius   radius)
               (immutable open?    open?)))

   Bowls are to be compared first by whether they are open or closed,
and then by radius.  However, bowls and boxes also need to be compared
to each other, ordered such that a bowl is considered "smaller" than a
box.  (There are type-test predicates 'box?' and 'bowl?').  Using the
control structure 'select-compare' this can be expressed as:

     (define (container-compare c1 c2)
       (select-compare c1 c2
         (bowl? (boolean-compare (open?  c1) (open?  c2))
                (length-compare  (radius c1) (radius c2)))
         (box?  (box-compare c1 c2))
         (else "neither bowls nor boxes" c1 c2)))

   This is an example of "hierarchical extension" of compare procedures.
Also note the implicit use of 'refine-compare' in the 'bowl?' case.


File: vicare-libs.info,  Node: comparisons conventions,  Next: comparisons atoms,  Prev: comparisons examples,  Up: comparisons

1.17.3 Terminology and conventions
----------------------------------

A "comparison procedure" is a Scheme procedure of two arguments
returning an exact integer in {-1, 0, 1} such that the valid input
values are ordered according to some total order.  A comparison
procedure, together with a set of Scheme values to which it is
applicable, represents a comparison function.

   A "comparison" is either an expression applying a comparison
procedure to two values, or the result of such an expression.

   Each operation (macro or procedure) processing the value of a
comparison checks if the value is indeed an exact integer in the set
{-1, 0, 1}.  If this is not the case, an error is signalled.

   Comparison procedures expecting certain types of arguments should
raise an error in case the arguments are not of this type.


File: vicare-libs.info,  Node: comparisons atoms,  Next: comparisons sequence,  Prev: comparisons conventions,  Up: comparisons

1.17.4 Comparing atoms
----------------------

This section describes comparison procedures for most of the atomic
types of R6RS: booleans, characters, strings, symbols, and numbers.  As
a general naming convention, a procedure named:

     TYPE-compare-ORDER

compares two objects of the type TYPE with respect to a total order for
which ORDER is a mnemonic hint (e.g.  '-ci' for case-insensitive).  Of
course, '-ORDER' may be absent if there is just one order or the order
is obvious.  It is an error if a comparison procedure accepting objects
of a certain type is called with one or two arguments not of that type.

 -- Function: boolean-compare BOOL1 BOOL2
     Compare two booleans, ordered by '#f' < '#t'.  A non-false value is
     not interpreted as a "true value," but rather an error will be
     signalled.

 -- Function: char-compare CHAR1 CHAR2
 -- Function: char-compare-ci CHAR1 CHAR2
     Compare characters as 'char<=?' and 'char-ci<=?' respectively.  The
     suffix '-ci' means "case insensitive."

 -- Function: string-compare STRING1 STRING2
 -- Function: string-compare-ci STRING1 STRING2
     Compare strings as 'string<=' and 'string-ci<=?'.  The suffix '-ci'
     means "case insensitive."

 -- Function: symbol-compare SYMBOL1 SYMBOL2
     Compares symbols as 'string<=' on the names returned by
     'symbol->string'.

 -- Function: integer-compare X Y
 -- Function: rational-compare X Y
 -- Function: real-compare X Y
 -- Function: complex-compare X Y
 -- Function: number-compare X Y
     Compare two numbers using the R6RS functions '=' and '<'.  It is an
     error if an argument is not of the type specified by the name of
     the procedure.

     Complex numbers are ordered based on their magnitude:

          (real-compare (magnitude x) (magnitude y))

     If at least one among X and Y is a complex number: 'number-compare'
     defaults to 'complex-compare', else it defaults to 'real-compare'.

     If one or both the arguments is '+nan.0':

     'integer-compare'
     'rational-compare'
          Raise an error because '+nan.0' is neither integer nor
          rational.

     'real-compare'
     'complex-compare'
     'number-compare'
          Return '+nan.0'.


File: vicare-libs.info,  Node: comparisons sequence,  Next: comparisons pair,  Prev: comparisons atoms,  Up: comparisons

1.17.5 Comparing lists and vectors
----------------------------------

This section describes comparison procedures for Scheme lists, vectors
and objects that can be accessed like lists or like vectors.

   An object X can be accessed like a vector if there are procedures
'size' and 'ref' such that '(size x)' is a non-negative integer n
indicating the number of elements, and '(ref x i)' is the i-th element
of X for i in {0, ..., n-1}.

   The default vector access procedures are 'vector-length' and
'vector-ref'.

   An object X can be accessed like a (proper) list if there are
procedures 'empty?', 'head' and 'tail' such that '(empty? x)' is a
boolean indicating that there are no elements in X, '(head x)' is the
first element of X, and '(tail x)' is an object representing the
residual elements of X.

   The default list access procedures are 'null?', 'car' and 'cdr'.

   Independently of the way the elements are accessed, the natural
ordering of vectors and lists differs.  The following comparison
policies are defined:

_As vectors_
     The shorter sequence is always smaller than the longer one, no
     matter the elements in it.  Sequences of the same size are compared
     lexicographically (element by element, stopping at the first
     different one).

_As lists_
     The empty sequence is smallest.  Two non-empty sequences are
     compared by their first elements, and only if the first elements
     are equal the residual sequences are compared, recursively.

 -- Function: vector-compare X Y
 -- Function: vector-compare COMPARE X Y
 -- Function: vector-compare COMPARE X Y SIZE REF
 -- Function: vector-compare-as-list X Y
 -- Function: vector-compare-as-list COMPARE X Y
 -- Function: vector-compare-as-list COMPARE X Y SIZE REF
 -- Function: list-compare X Y
 -- Function: list-compare COMPARE X Y
 -- Function: list-compare COMPARE X Y EMPTY? HEAD TAIL
 -- Function: list-compare-as-vector X Y
 -- Function: list-compare-as-vector COMPARE X Y
 -- Function: list-compare-as-vector COMPARE X Y EMPTY? HEAD TAIL
     Compare two sequences X and Y, using COMPARE for comparing
     elements.  The result is an exact integer in {-1, 0, 1}.  If
     COMPARE is not supplied, 'default-compare' is used.

     The procedure named 'ACCESS-compare-as-ORDER' accesses the objects
     like ACCESS and compares them with respect to the order given by
     ORDER.  The names 'TYPE-compare' are abbreviations for
     'TYPE-compare-as-TYPE'.

     In the following examples the difference between comparison as list
     and comparison as vector does not show:

          (list-compare '()  '())                    => 0
          (list-compare '(1) '())                    => +1
          (list-compare '()  '(1))                   => -1

          (list-compare '(1) '(1))                   => 0
          (list-compare '(1) '(2))                   => -1
          (list-compare '(2) '(1))                   => +1

          (list-compare '(1 1) '(1 1))               => 0
          (list-compare '(1 1) '(1 2))               => -1
          (list-compare '(1 2) '(1 1))               => +1

          (list-compare '(1 1 1) '(1 1))             => +1
          (list-compare '(1 1)   '(1 1 1))           => -1

          (list-compare-as-vector '()  '())          => 0
          (list-compare-as-vector '(1) '())          => +1
          (list-compare-as-vector '()  '(1))         => -1

          (list-compare-as-vector '(1) '(1))         => 0
          (list-compare-as-vector '(1) '(2))         => -1
          (list-compare-as-vector '(2) '(1))         => +1

          (list-compare-as-vector '(1 1) '(1 1))     => 0
          (list-compare-as-vector '(1 1) '(1 2))     => -1
          (list-compare-as-vector '(1 2) '(1 1))     => +1

          (list-compare-as-vector '(1 1 1) '(1 1))   => +1
          (list-compare-as-vector '(1 1)   '(1 1 1)) => -1

     In the following examples the difference shows:

          (vector-compare         '#(1 1 1) '#(2 1)) => +1
          (vector-compare-as-list '#(1 1 1) '#(2 1)) => -1


File: vicare-libs.info,  Node: comparisons pair,  Next: comparisons default,  Prev: comparisons sequence,  Up: comparisons

1.17.6 Comparing pairs and improper lists
-----------------------------------------

This section describes comparison procedures for Scheme pairs and
(possibly) improper lists.

 -- Function: pair-compare-car COMPARE
 -- Function: pair-compare-cdr COMPARE
     Construct a compare procedure on pairs which only uses the car (or,
     respectively, the cdr), and ignores the other.  One could define:

          (define (pair-compare-car compare)
            (lambda (x y)
              (compare (car x) (car y))))

     'pair-compare-car' can be used to turn a search data structure
     (e.g.  a heap) into a dictionary: Store '(key . value)' pairs and
     compare them using the compare procedure '(pair-compare-car
     compare-key)'.

 -- Function: pair-compare COMPARE-CAR COMPARE-CDR PAIR1 PAIR2
 -- Function: pair-compare COMPARE OBJ1 OBJ2
 -- Function: pair-compare OBJ1 OBJ2
     Compare two pairs, or (possibly improper) lists.

     The quaternary form compares PAIR1 and PAIR2 by comparing their
     cars using 'compare-car', and if the cars are equal the cdrs are
     compared using 'compare-cdr'.

     The ternary form compares two objects by type using the ordering of
     types:

          null < pair < neither-null-nor-pair

     Two objects of type neither-null-nor-pair are compared using
     COMPARE.  Two pairs are compared by using COMPARE on the cars, and
     if the cars are equal by recursing on the cdrs.

     The binary form uses 'default-compare' as COMPARE.

          (pair-compare '() 'foo)
          => -1

          (pair-compare '() '(1 . 2)))
          => -1

          (pair-compare '(1 . 2) 'foo)
          => -1

          (pair-compare 3 4)
          => -1


File: vicare-libs.info,  Node: comparisons default,  Next: comparisons cons,  Prev: comparisons pair,  Up: comparisons

1.17.7 The default compare procedure
------------------------------------

It is convenient to have a compare procedure readily available for
comparing most builtin types.

 -- Function: default-compare OBJ1 OBJ2
     Compare the arguments by type using the ordering:

          null < pair   < boolean < char   < string
               < symbol < number  < vector < other

     Two objects of the same type TYPE are compared as 'TYPE-compare'
     would, if there is such a procedure.  The type NULL consists of the
     empty list.  The effect of comparing two other objects or of
     comparing cyclic structures (made from lists or vectors) is
     unspecified.


File: vicare-libs.info,  Node: comparisons cons,  Next: comparisons branch,  Prev: comparisons default,  Up: comparisons

1.17.8 Constructing compare procedures
--------------------------------------

The syntactic extensions defined in this section are the primary
utilities for defining new compare procedures as conveniently as
possible.

 -- Syntax: refine-compare EXPR ...
     The arguments, if any, must be expressions; they are evaluated from
     left to right until a non-zero value is found (which then is the
     value) or until there are no more arguments to evaluate (in which
     case the value is '0').  If no arguments are supplied, the return
     value is '0'.

 -- Syntax: select-compare EXPR1 EXPR2 CLAUSE ...
     Each CLAUSE, with the possible exception of the last, is of the
     form:

          (?TYPE? ?C1 ...)

     where ?TYPE? is an expression evaluating to a predicate procedure,
     and ?CI are expressions evaluating to an exact integer in {-1, 0,
     1}.  The last CLAUSE may be an "else clause", which has the form:

          (else ?C1 ...)

     'select-compare' is a conditional for defining hierarchical
     extensions and refinements of compare procedures.  It compares the
     values of EXPR1 and EXPR2 by trying the type tests in order, and
     applies an implict 'refine-compare' on the consequences upon a
     match.

     In more detail, evaluation proceeds as follows: First EXPR1 and
     EXPR2 are evaluated in unspecified order, resulting in values X1
     and X2, respectively.  Then the clauses are evaluated one by one,
     from left to right.

     For clause:

          (?TYPE? ?C1 ...)

     first ?TYPE? is evaluated resulting in a predicate procedure TYPE?
     and then the expressions '(TYPE? X1)' and '(TYPE? X2)' are
     evaluated and interpreted as booleans:

       1. If both booleans are true then the overall value is:

               (refine-compare ?C1 ...)

       2. If only the first is true the result is '-1'.

       3. If only the second is true the result is '+1'.

       4. If neither is true the next clause is considered.

     An else clause is treated as if both tests where true.  If there
     are no clauses left, the result is '0'.

     'select-compare' evaluates EXPR1 and EXPR2 exactly once, even in
     the absence of any clauses.  Moreover, each ?TYPE? is evaluated at
     most once and the resulting procedure TYPE? is called at most
     twice.

 -- Syntax: cond-compare ?CLAUSE ...
     Each ?CLAUSE, with the possible exception of the last, is of the
     form:

          ((?T1 ?T2) ?C1 ...)

     where ?T1 and ?T2 are expressions evaluating to booleans, and ?CI
     are expressions evaluating to an exact integer in {-1, 0, 1}.

     The last CLAUSE may be an "else clause", which has the form:

          (else ?C1 ...)

     'cond-compare' is another conditional for defining hierarchical
     extensions and refinements of compare procedures.

     Evaluation proceeds as follows: The clauses are evaluated one by
     one, from left to right.  For clause:

          ((?T1 ?T2) ?C1 ...)

     first ?T1 and ?T2 are evaluated and the results are interpreted as
     boolean values:

       1. If both booleans are true then the overall value is:

               (refine-compare ?C1 ...)

       2. If only the first is true the result is '-1'.

       3. If only the second is true the result is '+1'.

       4. If neither is true the next clause is considered.

     An else clause is treated as if both booleans where true.  If there
     are no clauses left (or there are no clauses to begin with), the
     result is '0'.

     'cond-compare' evaluates each expression at most once.


File: vicare-libs.info,  Node: comparisons branch,  Next: comparisons pred,  Prev: comparisons cons,  Up: comparisons

1.17.9 Branching
----------------

The facilities described in this section provide a mechanism for using a
compare procedure (passed as a parameter) in the different situations
arising in applications.

 -- Syntax: if3 ?C ?LESS ?EQUAL ?GREATER
     ?C, ?LESS, ?EQUAL, and ?GREATER are expressions.

     'if3' is the 3-way conditional for comparisons.  First ?C is
     evaluated, resulting in value C.  The value C must be an exact
     integer in '{-1, 0, 1}', otherwise an error is signalled.

     C = -1
          The value of the 'if3' expression is obtained by evaluating
          ?LESS.

     C = 0
          ?EQUAL is evaluated.

     C = 1
          ?GREATER is evaluated.

 -- Syntax: if=? ?C ?CONSEQUENT
 -- Syntax: if=? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if<? ?C ?CONSEQUENT
 -- Syntax: if<? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if>? ?C ?CONSEQUENT
 -- Syntax: if>? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if<=? ?C ?CONSEQUENT
 -- Syntax: if<=? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if>=? ?C ?CONSEQUENT
 -- Syntax: if>=? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if-not=? ?C ?CONSEQUENT
 -- Syntax: if-not=? ?C ?CONSEQUENT ?ALTERNATE
     ?C, ?CONSEQUENT, and ?ALTERNATE are expressions.  If ?ALTERNATE is
     not provided, '(if #f #f)' is used.

     These six macros are 2-way conditionals for comparisons.  First ?C
     is evaluated, resulting in value C.  The value C must be an exact
     integer in {-1, 0, 1}, otherwise an error is signalled.  Then,
     depending on the value of C and the name of the macro, either
     ?CONSEQUENCE or ?ALTERNATE is evaluated, and the resulting value is
     the value of the conditional expression.

     The branch is chosen according to the following table:

                  ?CONSEQUENT      ?ALTERNATE
     -----------------------------------------------
     'if=?'       'c = 0'          'c in {-1, 1}'
     'if<?'       'c = -1'         'c in {0, 1}'
     'if>?'       'c = 1'          'c in {-1, 0}'
     'if<=?'      'c in {-1, 0}'   'c = 1'
     'if>=?'      'c in {0, 1}'    'c = -1'
     'if-not=?'   'c in {-1, 1}'   'c = 0'


File: vicare-libs.info,  Node: comparisons pred,  Next: comparisons minmax,  Prev: comparisons branch,  Up: comparisons

1.17.10 Predicates
------------------

 -- Function: =? [COMPARE] [X Y]
 -- Function: <? [COMPARE] [X Y]
 -- Function: >? [COMPARE] [X Y]
 -- Function: <=? [COMPARE] [X Y]
 -- Function: >=? [COMPARE] [X Y]
 -- Function: not=? [COMPARE] [X Y]
     If the values X and Y are given, test if X and Y are in the
     relation specified by the name of the procedure 'rel?', with
     respect to compare procedure COMPARE; otherwise construct a
     predicate procedure.

     In the forms:

          (rel? [COMPARE] X Y)

     the result is a boolean depending on '(COMPARE X Y)' and the test
     'rel?' as specified for 'if<?' etc.  If COMPARE is not supplied,
     'default-compare' is used.

     In the form:

          (rel? [COMPARE])

     the predicate procedure:

          (lambda (x y)
            (rel? COMPARE X Y))

     is constructed.  Again, if COMPARE is not supplied,
     'default-compare' is used.

     A few examples for illustration:

          (>? "laugh" "LOUD")
          => #t

          (<? string-compare-ci "laugh" "LOUD")
          => #t

          (define char<=?
            (<=? char-compare))

          (sort-by-less '(1 a "b") (<?))
          => '("b" a 1)

          (sort-by-less '(1 a "b") (>?))
          => '(1 a "b")

          _Warning:_ A common mistake is writing '(<=? x y z)' where
          '(<=/<=? x y z)' is meant; this will most likely manifest
          itself at the time the expression '(x y z)' is evaluated.

 -- Function: </<? [COMPARE] [X Y Z]
 -- Function: </<=? [COMPARE] [X Y Z]
 -- Function: <=/<? [COMPARE] [X Y Z]
 -- Function: <=/<=? [COMPARE] [X Y Z]
 -- Function: >/>? [COMPARE] [X Y Z]
 -- Function: >/>=? [COMPARE] [X Y Z]
 -- Function: >=/>? [COMPARE] [X Y Z]
 -- Function: >=/>=? [COMPARE] [X Y Z]
     Test if X, Y, and Z form a chain with the two relations specified
     by the name of the procedure 'rel1/rel2?', with respect to the
     compare procedure COMPARE.

     If COMPARE is not provided, 'default-compare' is used.

     If X, Y and Z are not provided, a predicate procedure of three
     arguments is constructed.  The order in which the values are
     compared is unspecified, but each value is compared at least once.

          *NOTE*

               (<=/<? real-compare 0 x 1)

          tests if X is a real number in the half open interval '[0,
          1)'.

 -- Function: chain=? COMPARE X1 ...
 -- Function: chain<? COMPARE X1 ...
 -- Function: chain>? COMPARE X1 ...
 -- Function: chain<=? COMPARE X1 ...
 -- Function: chain>=? COMPARE X1 ...
     Test if the values X1 ... (zero or more values) form a chain with
     respect to the relation specified by the name of the procedure, and
     with respect to the compare procedure COMPARE.  The result is a
     boolean.

     The order in which the values are compared is unspecified, but each
     value is compared at least once (even if there is just one).

     A sequence of values X1, ..., XN forms a chain with respect to the
     relation 'rel?' if:

          (rel? COMPARE XI XJ)

     for all 1 < i < j < n.  In particular, this is the case for n \in
     {0, 1}.

     Since the relations '=', '<', '>', '<', and '>' are transitive, it
     is sufficient to test:

          (rel? COMPARE XI XI+1)

     for 1 < i < n.

          *NOTE* The reason every XI participates in at least one
          comparison is type-checking: After testing if the values form
          a chain, these value may be assumed to be of the type
          comparable by compare-- and this holds irrespectively of the
          number of values, or whether they form a chain.

 -- Function: pairwise-not=? COMPARE X1 ...
     Tests if the values X1 ...  (zero or more values) are pairwise
     unequal with respect to the compare procedure COMPARE.  The result
     is a boolean.

     The order in which the values are compared is unspecified, but each
     value is compared at least once (even if there is just one).

     The values X1, ..., XN are pairwise unequal if:

          (not=? COMPARE XI XJ)

     for all i different from j.  In particular, this is the case for n
     \in {0, 1}.

     Since compare defines a total ordering on the values, the property
     can be checked in time O(n log n).

 -- Function: compare-by< LT-PRED [X Y]
 -- Function: compare-by> GT-PRED [X Y]
 -- Function: compare-by<= LE-PRED [X Y]
 -- Function: compare-by>= GE-PRED [X Y]
 -- Function: compare-by=/< EQ-PRED LT-PRED [X Y]
 -- Function: compare-by=/> EQ-PRED GT-PRED [X Y]
     If optional arguments X and Y are present then these are compared
     with respect to the total order defined by the predicate(s) given;
     the result is in {-1, 0, 1}.  If X and Y are not present then a
     procedure comparing its two arguments using the predicate(s) given
     is constructed and returned.

     The predicate procedures mean the following:

     LT-PRED
          Test if x < y.

     LE-PRED
          Test for <=.

     GT-PRED
          Test for >.

     GE-PRED
          Test for >=.

     EQ-PRED
          Test if X and Y are equivalent.

     The result returned by a predicate procedure is interpreted as a
     Scheme truth value (i.e.  '#f' is false and non-'#f' is true).

     The purpose of the procedures compare-by-predicate(s) is to define
     a compare procedure from an order predicate, and possibly an
     additional equivalence predicate.  If an equivalence predicate
     eq-pred is given, it is called before the order predicate because
     the equivalence may be coarser than the total ordering, and it may
     also be cheaper.

          *NOTE* 'char-compare' could be defined in terms of 'char<=?'
          as:

               (define char-compare
                 (compare-by<= char<=?))


File: vicare-libs.info,  Node: comparisons minmax,  Next: comparisons debug,  Prev: comparisons pred,  Up: comparisons

1.17.11 Minimum and maximum values
----------------------------------

 -- Function: min-compare COMPARE X1 ...
 -- Function: max-compare COMPARE X1 ...
     A minimum or maximum of the values X1 ...  (one or more values)
     with respect to the compare procedure compare.

     The result is the first value that is minimal (maximal,
     respectively).  The order in which the values are compared is
     unspecified, but each value is compared at least once (even if
     there is just one value).

 -- Function: kth-largest COMPARE K X0 ...
     The K-th largest element of values X0 ...  (one or more values)
     with respect to the compare procedure COMPARE.

     More precisely:

          (kth-largest COMPARE K X0 ... XN-1)

     returns the '(modulo k n)'-th element of the unique sequence
     obtained by stably sorting X0, ..., XN-1.  (Recall that a sorting
     algorithm is stable if it does not permute items with equal key,
     i.e.  equivalent w.r.t.  COMPARE).

     The argument K is an exact integer, and n > 1.  The order in which
     the values XI are compared is unspecified, but each value is
     compared at least once (even if there is just one value).

          *NOTE* The 0-th largest element is the minimum, the (n-1)-th
          largest element is the maximum.  The median is the ((n -
          1)/2)-th largest element if n is odd, and the average of the
          (n/2 - 1)-th and n/2-th largest elements if n is even.


File: vicare-libs.info,  Node: comparisons debug,  Prev: comparisons minmax,  Up: comparisons

1.17.12 Debugging procedure
---------------------------

 -- Function: debug-compare COMPARE
     Constructs a compare procedure equivalent to COMPARE but with
     debugging code wrapped around the calls to compare.  The debugging
     code signals an error if it detects a violation of the axioms of a
     compare function.  For this it is assumed that COMPARE has no
     side-effects.

     More specifically, '(debug-compare COMPARE)' evaluates to a compare
     procedure COMPARE1 which checks reflexivity, antisymmetry, and
     transitivity of compare based on the arguments on which COMPARE1 is
     called:

     The procedure COMPARE1 checks reflexivity on any value passed to
     compare, antisymmetry on any pair of values on which compare is
     called, and transitivity on triples where two of the arguments are
     from the current call to COMPARE1 and the third is a pseudo-random
     selection from the two arguments of the previous call to COMPARE1.


File: vicare-libs.info,  Node: restarts,  Next: ibodies,  Prev: comparisons,  Up: lang

1.18 Signalling conditions and restarts
=======================================

The library '(vicare language-extensions conditions-and-restarts)'
implements Scheme-flavoured Common Lisp's condition handlers and restart
handlers.

   Not everything defined by Common Lisp is implemented:

   * There is no integration with the debugger.

   * Some facilities are not implemented.  Among the missing ones:
     'restart-bind', 'with-simple-restart', 'muffle-warning'.

   To understand what is going on here, we should read Common Lisp's
Hyper Spec, Chapter 9.1 "Condition System Concepts"(1).

* Menu:

* restarts signal::             Signalling conditions.
* restarts handler-case::       Catching signalled conditions.
* restarts ignore-errors::      Ignoring signalled conditions of
                                type '&error'.
* restarts handler-bind::       Handling signalled conditions.
* restarts restart-case::       Installing restart handlers.
* restarts assoc::              Associating restarts to conditions.
* restarts invoke::             Finding and invoking restarts.
* restarts func::               Standardised restart functions.
* restarts errors::             Detecting errors in the conditions
                                and restarts mechanism.

   ---------- Footnotes ----------

   (1) 
<http://www.cs.cmu.edu/Groups/AI/html/hyperspec/HyperSpec/Body/sec_9-1.htm>


File: vicare-libs.info,  Node: restarts signal,  Next: restarts handler-case,  Up: restarts

1.18.1 Signalling conditions
----------------------------

 -- Function: signal CND
     Signal a condition by raising it with 'raise-continuable'.  Perform
     what is needed to handle the restarts protocol.  CND must be a
     condition object (simple or compound).

     As defined by Common Lisp: 'signal' should return if no handler
     accepting the condition is found; in this implementation this
     normal return will *not* happen by default.  To implement such
     behaviour we have to wrap the whole code in a form like this:

          (with-return-to-signal-on-unhandled-exception
            ?BODY0 ?BODY ...)

 -- Syntax: with-return-to-signal-on-unhandled-exception ?BODY0 ?BODY
          ...
     Do what is needed to allow 'signal' to just return if all the
     installed condition handlers decline to handle the signalled
     condition.


File: vicare-libs.info,  Node: restarts handler-case,  Next: restarts ignore-errors,  Prev: restarts signal,  Up: restarts

1.18.2 Catching signalled conditions
------------------------------------

 -- Syntax: handler-case (?CLAUSE ...) ?BODY0 ?BODY ...
     Evaluate body forms in a dynamic environment in which new exception
     handlers are installed; it is capable of handling exceptions raised
     with 'raise', 'raise-continuable' and 'signal'.  Basically behave
     like R6RS's 'guard' syntax.

     The arguments ?CLAUSE must have one of the following syntaxes:

          (?TYPESPEC ?CONDITION-HANDLER)
          (:no-error ?NO-ERROR-HANDLER)

     Every ?TYPESPEC is meant to be a logic predicate with the format:

          ?TYPESPEC = (?TAG)
                    | (and ?INNER-PRED0 ?INNER-PRED ...)
                    | (or  ?INNER-PRED0 ?INNER-PRED ...)
                    | (xor ?INNER-PRED0 ?INNER-PRED ...)
                    | (not ?INNER-PRED)

          ?INNER-PRED = ?tag
                      | (and ?INNER-PRED0 ?INNER-PRED ...)
                      | (or  ?INNER-PRED0 ?INNER-PRED ...)
                      | (xor ?INNER-PRED0 ?INNER-PRED ...)
                      | (not ?INNER-PRED)

     where: each ?TAG is an identifier usable as second argument to
     'is-a?'; 'and', 'or', 'xor', 'not' are the identifiers exported by
     '(vicare)'.

     Every ?CONDITION-HANDLER must be an expression evaluating to a
     procedure accepting a condition object as single argument; the
     condition object can be simple or compound.

     In the no-error clause: ':no-error' must be the actual symbol;
     ?NO-ERROR-HANDLER must be an expression evaluating to a procedure.
     The optional ':no-error' clause can be present only if it is the
     last one.

     If the body performs a normal return:

        * If the ':no-error' clause is missing: the values returned by
          the body become the values returned by 'handler-case'.

        * If the ':no-error' clause is present: the procedure
          ?NO-ERROR-HANDLER is applied to the returned values; the
          return values of such application become the return values of
          'handler-case'.

     If an exception is raised (in Common Lisp jargon: a condition is
     signalled): a condition handler matching the raised object is
     searched in the sequence of clauses, left-to-right:

        * If a clause matches: the dynamic extent of the body is
          terminated, the ?CONDITION-HANDLER is applied to the raised
          object and the return values of such application become the
          return values of 'handler-case'.

        * If no clause matches: the raised object is re-raised with
          'raise-continuable'.

   Usage examples:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;no condition
     (with-result
       (handler-case
           ((&error   (lambda (E)
                        (add-result 'error-handler)
                        1))
            (&warning (lambda (E)
                        (add-result 'warning-handler)
                        2)))
         (add-result 'body)
         1))
     => (1 (body))

     ;;no condition, :no-error clause
     (with-result
       (handler-case
           ((&error    (lambda (E)
                         (add-result 'error-handler)
                         1))
            (&warning  (lambda (E)
                         (add-result 'warning-handler)
                         2))
            (:no-error (lambda (X)
                         (add-result 'no-error)
                         (* 10 X))))
         (add-result 'body)
         1))
     => (10 (body no-error))

     ;;;

     (internal-body        ;signalled condition

       (define (doit C)
         (with-result
           (handler-case
               ((&error   (lambda (E)
                            (add-result 'error-handler)
                            1))
                (&warning (lambda (E)
                            (add-result 'warning-handler)
                            2)))
             (add-result 'body-begin)
             (signal C)
             (add-result 'body-normal-return))))

       (doit (make-error))
       => (1 (body-begin error-handler))

       (doit (make-warning))
       => (2 (body-begin warning-handler))

       #| end of body |# )

     ;;Signalled condition, multiple types in single clause.
     ;;
     (internal-body

       (define (doit C)
         (with-result
           (handler-case
               (((&error &warning) (lambda (E)
                                     (add-result 'handler)
                                     1)))
             (add-result 'body-begin)
             (signal C)
             (add-result 'body-normal-return))))

       (doit (make-error))
       => (1 (body-begin handler))

       (doit (make-warning))
       => (1 (body-begin handler))

       #| end of body |# )

     ;;Signalled condition, nested HANDLER-CASE uses.
     ;;
     (internal-body

       (define (doit C)
         (with-result
           (handler-case
               ((&error   (lambda (E)
                            (add-result 'error-handler)
                            1)))
             (handler-case
                 ((&warning (lambda (E)
                              (add-result 'warning-handler)
                              2)))
               (add-result 'body-begin)
               (signal C)
               (add-result 'body-normal-return)))))

       (doit (make-error))
       => (1 (body-begin error-handler))

       (doit (make-warning))
       => (2 (body-begin warning-handler))

       #| end of body |# )

     (internal-body        ; unwind-protect

       (define (doit C)
         (with-result
           (handler-case
               ((&error   (lambda (E)
                            (add-result 'error-handler)
                            1)))
             (with-unwind-handler
                 (lambda (why)
                   (add-result 'outer-unwind-handler))
               (lambda ()
                 (handler-case
                     ((&warning (lambda (E)
                                  (add-result 'warning-handler)
                                  2)))
                   (with-unwind-handler
                       (lambda (why)
                         (add-result 'inner-unwind-handler))
                     (lambda ()
                       (add-result 'body-begin)
                       (signal C)
                       (add-result 'body-normal-return)))))))))

       (doit (make-error))
       => (1
             (body-begin
              inner-unwind-handler
              outer-unwind-handler
              error-handler))

       (doit (make-warning))
       => (2
             (body-begin
              inner-unwind-handler
              warning-handler
              outer-unwind-handler))

       #| end of body |# )


File: vicare-libs.info,  Node: restarts ignore-errors,  Next: restarts handler-bind,  Prev: restarts handler-case,  Up: restarts

1.18.3 Ignoring signalled conditions of type '&error'
-----------------------------------------------------

 -- Syntax: ignore-errors ?BODY0 ?BODY ...
     Install a handler for conditions of type '&error', then evaluate
     the body forms; the handler is installed using 'handler-case'.  If
     the body performs a normal return: its return values become the
     return values of 'ignore-errors'.  If the body signals a condition
     of type '&error': two values are returned, '#f' and the signalled
     condition object.

   Usage examples:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;no condition
     (with-result
       (ignore-errors
         (add-result 'body)
         1))
     => (1 (body))

     (internal-body ;;signalled condition

     (define (doit C)
       (with-result
         (handler-case
             ((&error   (lambda (E)
                          (add-result 'error-handler)
                          1))
              (&warning (lambda (E)
                          (add-result 'warning-handler)
                          2)))
           (receive (A B)
               (ignore-errors
                 (add-result 'body-begin)
                 (signal C)
                 (add-result 'body-normal-return))
             (values A (and (error? B) 99))))))

       (doit (make-error))
       => (#f 99 (body-begin))

       (doit (make-warning))
       => (2 (body-begin warning-handler))

       #| end of body |# )


File: vicare-libs.info,  Node: restarts handler-bind,  Next: restarts restart-case,  Prev: restarts ignore-errors,  Up: restarts

1.18.4 Handling signalled conditions
------------------------------------

 -- Syntax: handler-bind (?CLAUSE ...) ?BODY0 ?BODY ...
     Evaluate body forms in a dynamic environment in which new exception
     handlers are installed; it is capable of handling exceptions raised
     with 'raise', 'raise-continuable' and 'signal'.  Not quite like
     R6RS's 'with-exception-handler' syntax, but similar.

     The arguments ?CLAUSE must have the following syntax:

          (?TYPESPEC ?CONDITION-HANDLER)

     Every ?TYPESPEC is meant to be a logic predicate with the format:

          ?TYPESPEC = (?TAG)
                    | (and ?INNER-PRED0 ?INNER-PRED ...)
                    | (or  ?INNER-PRED0 ?INNER-PRED ...)
                    | (xor ?INNER-PRED0 ?INNER-PRED ...)
                    | (not ?INNER-PRED)

          ?INNER-PRED = ?tag
                      | (and ?INNER-PRED0 ?INNER-PRED ...)
                      | (or  ?INNER-PRED0 ?INNER-PRED ...)
                      | (xor ?INNER-PRED0 ?INNER-PRED ...)
                      | (not ?INNER-PRED)

     where: each ?TAG is an identifier usable as second argument to
     'is-a?'; 'and', 'or', 'xor', 'not' are the identifiers exported by
     '(vicare)'.

     Every ?CONDITION-HANDLER must be an expression evaluating to a
     procedure accepting a condition object as single argument; the
     condition object can be simple or compound.

     If the body performs a normal return: the values returned by the
     body become the values returned by 'handler-bind'.

     If an exception is raised (in Common Lisp jargon: a condition is
     signalled): a condition handler matching the raised object is
     searched in the sequence of clauses, left-to-right:

        * If a clause matches: its ?CONDITION-HANDLER is applied to the
          raised object.

        * If no clause matches: the raised object is re-raised with
          'raise-continuable'.

     The handlers are called with a continuation whose dynamic
     environment is that of the call to 'raise', 'raise-continuable' or
     'signal' that raised the exception; except that the current
     exception handler is the one that was in place when 'handler-bind'
     was evaluated.

     When a condition handler is applied to the raised condition object:

        * If it accepts to handle the condition: it must perform a
          non-local exit, for example by invoking a restart.

        * If it declines to handle the condition: it must perform a
          normal return; in this case the returned values are discarded
          and the originally raised object is re-raised using
          'raise-continuable'.

   Usage examples on handling raised conditions:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;no condition
     (with-result
       (handler-bind
           ((&error   (lambda (E)
                        (add-result 'error-handler)
                        1))
            (&warning (lambda (E)
                        (add-result 'warning-handler)
                        2)))
         (add-result 'body)
         1))
     => (1 (body))

     ;;;

     ;;Escaping from handler, which is the normal way of accepting
     ;;to handle a condition.
     ;;
     (with-result
       (call/cc
           (lambda (escape)
             (handler-bind
                 ((&error (lambda (E)
                            (add-result 'error-handler)
                            (escape 2))))
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return)
               1))))
     => (2 (body-begin error-handler))

     ;;The first handler declines to handle a raised exception,
     ;;the second one accepts.
     ;;
     (with-result
       (call/cc
           (lambda (escape)
             (handler-bind
                 ((&warning (lambda (E)
                              ;;By returning this handler declines.
                              (add-result 'warning-handler)))
                  (&error   (lambda (E)
                              (add-result 'error-handler)
                              (escape 2))))
               (add-result 'body-begin)
               (raise (condition (make-error)
                                 (make-warning)))
               (add-result 'body-return)
               1))))
     => (2 (body-begin warning-handler error-handler))

     ;;Multiple condition identifiers in the same clause.
     ;;
     (with-result
       (call/cc
           (lambda (escape)
             (handler-bind
                 (((&warning &error) (lambda (E)
                                       (add-result 'handler)
                                       (escape 2))))
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return)
               1))))
     => (2 (body-begin handler))

     ;;Nested HANDLER-BIND uses, returning from handler.
     ;;
     (with-result
       (call/cc
           (lambda (escape)
             (handler-bind
                 ((&error (lambda (E)
                            (add-result 'outer-error-handler)
                            (escape 2))))
               (handler-bind
                   ((&error (lambda (E)
                              (add-result 'inner-error-handler))))
                 (add-result 'body-begin)
                 (raise (make-error))
                 (add-result 'body-return)
                 1)))))
     => (2 (body-begin inner-error-handler outer-error-handler))

     ;;; unwind-protect

     (internal-body

       (define (doit C)
         (with-result
           (returnable
             (handler-bind
                 ((&error   (lambda (E)
                              (add-result 'error-handler)
                              (return 1))))
               (with-unwind-handler
                   (lambda (why)
                     (add-result 'outer-unwind-handler))
                 (lambda ()
                   (handler-bind
                       ((&warning (lambda (E)
                                    (add-result 'warning-handler)
                                    (return 2))))
                     (with-unwind-handler
                         (lambda (why)
                           (add-result 'inner-unwind-handler))
                       (lambda ()
                         (add-result 'body-begin)
                         (signal C)
                         (add-result 'body-normal-return))))))))))

       (doit (make-error))
       => (1
             (body-begin
              error-handler
              inner-unwind-handler
              outer-unwind-handler))

       (doit (make-warning))
       => (2
             (body-begin
              warning-handler
              inner-unwind-handler
              outer-unwind-handler))

       #| end of body |# )

   Usage examples on invoking restarts:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;Nested RESTART-CASE and HANDLER-BIND.  Signal a condition,
     ;;call a handler, invoke a restart.
     ;;
     (internal-body

       (define (restarts-outside/handlers-inside C)
         (with-result
           (restart-case
               (handler-bind
                   ((&error   (lambda (E)
                                (add-result 'error-handler-begin)
                                (invoke-restart 'alpha)
                                (add-result 'error-handler-return)))
                    (&warning (lambda (E)
                                (add-result 'warning-handler-begin)
                                (invoke-restart 'beta)
                                (add-result 'warning-handler-return))))
                 (begin
                   (add-result 'body-begin)
                   (signal C)
                   (add-result 'body-return)))
             (alpha (lambda ()
                      (add-result 'restart-alpha)
                      1))
             (beta  (lambda ()
                      (add-result 'restart-beta)
                      2)))))

       (restarts-outside/handlers-inside (make-error))
       => (1 (body-begin error-handler-begin restart-alpha))

       (restarts-outside/handlers-inside (make-warning))
       => (2 (body-begin warning-handler-begin restart-beta))

       #| end of body |# )

     ;;Nested RESTART-CASE and HANDLER-BIND.  Signal a condition,
     ;;call a handler, invoke a restart.
     ;;
     (internal-body

       (define (restarts-inside/handlers-outside C)
         (with-result
           (handler-bind
               ((&error   (lambda (E)
                            (add-result 'error-handler-begin)
                            (invoke-restart 'alpha)
                            (add-result 'error-handler-return)))
                (&warning (lambda (E)
                            (add-result 'warning-handler-begin)
                            (invoke-restart 'beta)
                            (add-result 'warning-handler-return))))
             (restart-case
                 (begin
                   (add-result 'body-begin)
                   (signal C)
                   (add-result 'body-return))
               (alpha (lambda ()
                        (add-result 'restart-alpha)
                        1))
               (beta  (lambda ()
                        (add-result 'restart-beta)
                        2))))))

       (restarts-inside/handlers-outside (make-error))
       => (1 (body-begin error-handler-begin restart-alpha))

       (restarts-inside/handlers-outside (make-warning))
       => (2 (body-begin warning-handler-begin restart-beta))

       #| end of body |# )

     ;;Nested RESTART-CASE and HANDLER-BIND.  Signal a condition,
     ;;call a handler, invoke a restart.
     ;;
     (internal-body

       (define (restarts-inside/nested-handlers C)
         (with-result
           (handler-bind
               ((&error   (lambda (E)
                            (add-result 'error-handler-begin)
                            (invoke-restart 'alpha)
                            (add-result 'error-handler-return))))
             (handler-bind
                 ((&warning (lambda (E)
                              (add-result 'warning-handler-begin)
                              (invoke-restart 'beta)
                              (add-result 'warning-handler-return))))
               (restart-case
                   (begin
                     (add-result 'body-begin)
                     (signal C)
                     (add-result 'body-return))
                 (alpha (lambda ()
                          (add-result 'restart-alpha)
                          1))
                 (beta  (lambda ()
                          (add-result 'restart-beta)
                          2)))))))

       (restarts-inside/nested-handlers (make-error))
       => (1 (body-begin error-handler-begin restart-alpha))

       (restarts-inside/nested-handlers (make-warning))
       => (2 (body-begin warning-handler-begin restart-beta))

       #| end of LET |# )

     ;;Nested RESTART-CASE and HANDLER-BIND.  Signal a condition,
     ;;call a handler, invoke a restart.
     ;;
     (internal-body

       (define (nested-restarts/handlers-outside C)
         (with-result
           (handler-bind
               ((&error   (lambda (E)
                            (add-result 'error-handler)
                            (invoke-restart 'alpha)))
                (&warning (lambda (E)
                            (add-result 'warning-handler)
                            (cond ((find-restart 'beta)
                                   => (lambda (handler)
                                        (invoke-restart handler)))))))
             (restart-case
                 (restart-case
                     (begin
                       (add-result 'body-begin)
                       (signal C)
                       (add-result 'body-return))
                   (alpha (lambda ()
                            (add-result 'restart-alpha)
                            1)))
               (beta  (lambda ()
                        (add-result 'restart-beta)
                        2))))))

       (nested-restarts/handlers-outside (make-error))
       => (1 (body-begin error-handler restart-alpha))

       (nested-restarts/handlers-outside (make-warning))
       => (2 (body-begin warning-handler restart-beta))

       #| end of body |# )

     ;;Nested RESTART-CASE and HANDLER-BIND.  Signal a condition,
     ;;call the first handler, the first handler declines, call
     ;;the second handler, invoke a restart.
     ;;
     (with-result
       (handler-bind
           ((&message (lambda (E)
                        (add-result 'outer-message-handler-begin)
                        (invoke-restart 'alpha E)
                        (add-result 'outer-message-handler-return))))
         (handler-bind
             ((&message (lambda (E)
                          (add-result 'inner-message-handler))))
           (restart-case
               (begin
                 (add-result 'body-begin)
                 (signal (make-message-condition "ciao"))
                 (add-result 'body-return))
             (alpha (lambda (E)
                      (add-result 'alpha-restart)
                      (condition-message E)))))))
     => ("ciao"
           (body-begin
            inner-message-handler
            outer-message-handler-begin
            alpha-restart))


File: vicare-libs.info,  Node: restarts restart-case,  Next: restarts assoc,  Prev: restarts handler-bind,  Up: restarts

1.18.5 Installing restart handlers
----------------------------------

 -- Syntax: restart-case ?BODY (?CLAUSE ...)
     Install restart handlers in the current dynamic environment, then
     evaluate the body form.

     The arguments ?CLAUSE must have the following syntax:

          (?RESTART-NAME ?RESTART-HANDLER)

     Every ?RESTART-NAME must be a symbol representing the name of a
     restart; the same ?RESTART-NAME can be used in nested uses of
     'restart-case'.

     Every ?RESTART-HANDLER must be an expression evaluating to a
     procedure accepting a non-constrained number of arguments.  The
     return values of ?RESTART-HANDLER become the return values of
     'restart-case'.  The ?RESTART-HANDLER is evaluated in the dynamic
     environment of the call to 'invoke-restart' that invoked the
     restart.

     As special case, if ?BODY is:

          (signal ?EXPR)

     the installed restarts are associated to the condition object
     returned by the evaluation of ?EXPR.

   Usage examples on restarts and declining handlers:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;No handlers installed.  Signal a condition and
     ;;cause SIGNAL to return.
     ;;
     (with-result
       (with-return-to-signal-on-unhandled-exception
         (add-result 'body-in)
         (signal (make-error))
         (add-result 'body-out)
         1))
     => (1 (body-in body-out))

     ;;No handlers installed.  Raise an exception with the
     ;;standard RAISE and show that it goes through the
     ;;"return to signal" syntax.
     ;;
     (with-result
       (try
           (with-return-to-signal-on-unhandled-exception
             (add-result 'body-in)
             (raise (make-error))
             (add-result 'body-out)
             1)
         (catch E
           ((&error)
            (add-result 'catch-error)
            2))))
     => (2 (body-in catch-error))

     ;;No handlers installed.  Raise an exception with the
     ;;standard RAISE-CONTINUABLE and show that it goes
     ;;through the "return to signal" syntax.
     ;;
     (with-result
       (try
           (with-return-to-signal-on-unhandled-exception
             (add-result 'body-in)
             (raise-continuable (make-error))
             (add-result 'body-out)
             1)
         (catch E
           ((&error)
            (add-result 'catch-error)
            2))))
     => (2 (body-in catch-error))

     ;;No handlers installed.  Raise an exception with the
     ;;standard RAISE-CONTINUABLE and show that it goes
     ;;through the "return to signal" syntax.
     ;;
     (with-result
       (with-exception-handler
           (lambda (E)
             (add-result 'exception-handler))
         (lambda ()
           (with-return-to-signal-on-unhandled-exception
             (add-result 'body-in)
             (raise-continuable (make-error))
             (add-result 'body-out)
             1))))
     => (1 (body-in exception-handler body-out))

     ;;;

     ;;Nested RESTART-CASE and HANDLER-BIND.  Signal a condition,
     ;;call the first handler, the first handler declines, call
     ;;the second handler, the second handler declines, SIGNAL
     ;;returns.
     ;;
     (with-result
       (with-return-to-signal-on-unhandled-exception
         (handler-bind
             ((&error (lambda (E)
                        (add-result 'outer-error-handler))))
           (handler-bind
               ((&error (lambda (E)
                          (add-result 'inner-error-handler))))
             (add-result 'body-in)
             (signal (make-error))
             (add-result 'body-out)
             1))))
     => (1
           (body-in
            inner-error-handler
            outer-error-handler
            body-out))

   Usage examples on the unwind-protection mechanism:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (with-result
       (restart-case
           (with-unwind-handler
               (lambda (why)
                 (add-result 'unwind-handler))
             (lambda ()
               (add-result 'body-enter)
               (invoke-restart 'alpha)
               (add-result 'body-return)))
         (alpha (lambda ()
                  (add-result 'restart-alpha)
                  1))))
     => (1 (body-enter restart-alpha unwind-handler))

     (internal-body

       (define (doit C)
         (with-result
           (returnable
             (handler-bind
                 ((&error   (lambda (E)
                              (add-result 'error-handler)
                              (return 1))))
               (with-unwind-handler
                   (lambda (why)
                     (add-result 'outer-unwind-handler))
                 (lambda ()
                   (handler-bind
                       ((&warning (lambda (E)
                                    (add-result 'warning-handler)
                                    (return 2))))
                     (with-unwind-handler
                         (lambda (why)
                           (add-result 'inner-unwind-handler))
                       (lambda ()
                         (add-result 'body-begin)
                         (signal C)
                         (add-result 'body-normal-return))))))))))

       (doit (make-error))
       => (1
             (body-begin
              error-handler
              inner-unwind-handler
              outer-unwind-handler))

       (doit (make-warning))
       => (2
             (body-begin
              warning-handler
              inner-unwind-handler
              outer-unwind-handler))

       #| end of body |# )


File: vicare-libs.info,  Node: restarts assoc,  Next: restarts invoke,  Prev: restarts restart-case,  Up: restarts

1.18.6 Associating restarts to conditions
-----------------------------------------

 -- Syntax: with-condition-restarts ?CONDITION-FORM ?RESTARTS-FORM
          ?BODY0 ?BODY ...
     Evaluate body forms in a dynamic environment in which some restart
     objects are associated to a condition object; in some special case
     it is implicitly used by 'restart-case'.  If the body performs a
     normal return: the body return values become the return values of
     'with-condition-restarts'.

     This is the sequence of operations:

       1. The expression ?CONDITION-FORM is evaluated: its single return
          value must be a condition object, simple or compound.

       2. The expression ?RESTARTS-FORM is evaluated: its single return
          value must be a list of restart objects, for example returned
          by 'find-restart'.

       3. In the dynamic environment: every simple condition object
          returned by ?CONDITION-FORM is associated to every restart
          object returned by ?RESTARTS-FORM.

       4. The body is evaluated.

   Usage examples on associate conditions and restarts:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;Install a restart handler, establish an association between a
     ;;condition object and the restart object, call FIND-RESTART
     ;;with the condition argument, no restart objects without
     ;;association found, FIND-RESTART returns false.
     ;;
     (let ((C (make-error)))
       (restart-case
           (with-condition-restarts C
             (list (find-restart 'alpha))
             (find-restart 'alpha C))
         ;;This is associated: it is skipped.
         (alpha (lambda () 1))))
     => #f

     ;;Install nested restart handlers with the same name, establish
     ;;an association between a condition object and the innermost
     ;;restart object, call FIND-RESTART with the condition argument,
     ;;invoke restart.
     ;;
     (let ((C (make-error)))
       (restart-case
           (restart-case
               (with-condition-restarts C
                 (list (find-restart 'alpha))
                 (invoke-restart (find-restart 'alpha C)))
             ;;This is associated: it is skipped.
             (alpha (lambda () 1)))
         ;;This is not associated: it is selected.
         (alpha (lambda () 2))))
     => 2

     ;;Install a condition handler, install restart a handler and
     ;;establish an association between the raised condition object
     ;;and the restart object, search the restart, no matching
     ;;restart without association, SIGNAL returns.
     ;;
     (with-return-to-signal-on-unhandled-exception
       (handler-bind
           ((&error (lambda (E)
                      (cond ((find-restart 'alpha E)
                             => invoke-restart)
                            (else #f)))))
         (restart-case
             (signal (make-error))
           ;;This is associated: it is skipped.
           (alpha (lambda ()
                    (add-result 'restart-alpha)
                    1)))
         123))
     => 123

     ;;Install a condition handler, install nested restart handlers
     ;;with the same name, establish an association between a raised
     ;;condition object and innermost restart object, invoke the
     ;;restart, the outermost restart is selected.
     ;;
     (handler-bind
         ((&error (lambda (E)
                    (invoke-restart (find-restart 'alpha E)))))
       (restart-case
           (restart-case
               (signal (make-error))
             ;;This is associated: it is skipped.
             (alpha (lambda () 1)))
         ;;This is not associated: it is selected.
         (alpha (lambda () 2))))
     => 2


File: vicare-libs.info,  Node: restarts invoke,  Next: restarts func,  Prev: restarts assoc,  Up: restarts

1.18.7 Finding and invoking restarts
------------------------------------

 -- Function: find-restart NAME
 -- Function: find-restart NAME CND
     Search the current dynamic environment for the innermost restart
     handler associated to NAME, which must be a symbol.  If a handler
     is found: return its restart object; otherwise return '#f'.

     When the optional argument CND is used and CND is a condition
     object (simple or compound): among the installed restarts, return
     only the innermost that is *not* associated to the condition object
     CND.  When the optional argument CND is used and CND is '#f':
     behave as if CND was not used.

 -- Function: invoke-restart RESTART-DESIGNATOR . REST
     Given a restart designator: search the associated handler in the
     current dynamic environment and apply it to the given REST
     arguments.  Return the return values of such application, if the
     called function returns.

     RESTART-DESIGNATOR can be either a symbol representing the name of
     the restart or the restart object itself (as returned by
     'find-restart').

     If RESTART-DESIGNATOR is a symbol and no matching restart is found:
     an exception is raised with condition object of type
     '&undefined-restart-error'.

 -- Function: compute-restarts
     Return a list of symbols representing the names of the restarts
     currently installed in the dynamic environment.  The list is
     ordered: the innermost restarts come first, the outermost restarts
     come last.

 -- Function: restart-name RST
     Given a restart object: return a symbol representing its name.

   Examples about finding and invoking restarts:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;Search an UNdefined restart.
     ;;
     (find-restart 'alpha)
     => #f

     ;;Search an UNdefined restart.
     ;;
     (restart-case
         (find-restart 'beta)
       (alpha (lambda ()
                (add-result 'restart-alpha))))
     => #f

     ;;Search an UNdefined restart.
     ;;
     (restart-case
         (find-restart 'gamma)
       (alpha (lambda ()
                (add-result 'restart-alpha)))
       (beta  (lambda ()
                (add-result 'restart-beta)))
       (delta (lambda ()
                (add-result 'restart-delta))))
     => #f

     ;;Invoke an UNdefined restart.
     ;;
     (try
         (invoke-restart 'alpha)
       (catch E
         ((&undefined-restart-error)
          1)
         (else E)))
     => 1

     ;;Find then invoke a restart in two steps.
     ;;Invoking a restart is a non-local exit.
     ;;
     (with-result
       (restart-case
           (begin
             (add-result 'body-in)
             (let ((restart (find-restart 'alpha)))
               (add-result 'body-invoking)
               (begin0
                   (invoke-restart restart)
                 (add-result 'body-out)
                 1)))
         (alpha (lambda ()
                  (add-result 'restart-alpha)
                  2))))
     => (2 (body-in body-invoking restart-alpha))

     ;;Find and invoke a restart in a single step.
     ;;Invoking a restart is a non-local exit.
     ;;
     (with-result
       (restart-case
           (begin
             (add-result 'body-in)
             (begin0
                 (invoke-restart 'alpha)
               (add-result 'body-out)
               1))
         (alpha (lambda ()
                  (add-result 'restart-alpha)
                  2))))
     => (2 (body-in restart-alpha))

   Usage examples on 'compute-restarts':

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (compute-restarts)
     => ()

     (map restart-name
       (restart-case
           (compute-restarts)
         (alpha void)
         (beta  void)))
     => (alpha beta)

     (map restart-name
       (restart-case
           (restart-case
               (compute-restarts)
             (alpha void)
             (beta  void))
         (delta void)
         (gamma void)))
     => (alpha beta delta gamma)

     (map restart-name
       (restart-case
           (restart-case
               (restart-case
                   (compute-restarts)
                 (alpha void)
                 (beta  void))
             (delta void)
             (gamma void))
         (chi void)
         (xi  void)))
     => (alpha beta delta gamma chi xi)


File: vicare-libs.info,  Node: restarts func,  Next: restarts errors,  Prev: restarts invoke,  Up: restarts

1.18.8 Standardised restart functions
-------------------------------------

 -- Function: use-value OBJ
 -- Function: use-value OBJ CND
     If a restart named 'use-value' is installed in the dynamic
     environment: apply its handler to OBJ; otherwise return '#f'
     (without performing a non-local exit).

     If the optional argument CND is a condition object: select the
     innermost matching restart that is *not* associated with such
     condition object.  If CND is missing or '#f': just select the
     innermost installed restart.

 -- Function: store-value OBJ
 -- Function: store-value OBJ CND
     If a restart named 'store-value' is installed in the dynamic
     environment: apply its handler to OBJ; otherwise return '#f'
     (without performing a non-local exit).

     If the optional argument CND is a condition object: select the
     innermost matching restart that is *not* associated with such
     condition object.  If CND is missing or '#f': just select the
     innermost installed restart.

 -- Function: continue-restart
 -- Function: continue-restart CND
     If a restart named 'continue' is installed in the dynamic
     environment: call its handler with no arguments; otherwise return
     '#f' (without performing a non-local exit).

     If the optional argument CND is a condition object: select the
     innermost matching restart that is *not* associated with such
     condition object.  If CND is missing or '#f': just select the
     innermost installed restart.

          *NOTE* Under Common Lisp: this is simply called 'continue';
          under Vicare 'continue' is already bound.

 -- Function: abort-restart
 -- Function: abort-restart CND
     If a restart named 'abort' is installed in the dynamic environment:
     call its handler with no arguments; otherwise return '#f' (without
     performing a non-local exit).

     If the optional argument CND is a condition object: select the
     innermost matching restart that is *not* associated with such
     condition object.  If CND is missing or '#f': just select the
     innermost installed restart.

          *NOTE* Under Common Lisp: this is simply called 'abort'; this
          is quite a common action, so it is left unbound.

   Usage examples on restart functions:

     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     ;;; use-value

     ;;Signal condition, call a handler, call a USE-VALUE restart.
     ;;
     (with-result
       (handler-bind
           ((&error (lambda (E)
                      (add-result 'error-handler-begin)
                      (use-value "ciao")
                      (add-result 'error-handler-return))))
         (restart-case
             (begin
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return))
           (use-value (lambda (value)
                        (add-result 'restart-use-value)
                        value)))))
     => ("ciao"
           (body-begin error-handler-begin restart-use-value))

     ;;Call a USE-VALUE restart, no USE-VALUE handler is defined.
     ;;
     (with-result
       (add-result 'body-begin)
       (begin0
           (use-value 1)
         (add-result 'body-return)))
     => (#f (body-begin body-return))

     ;;; store-value

     ;;Signal condition, call a handler, call a STORE-VALUE restart.
     ;;
     (with-result
       (handler-bind
           ((&error (lambda (E)
                      (add-result 'error-handler-begin)
                      (store-value "ciao")
                      (add-result 'error-handler-return))))
         (restart-case
             (begin
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return))
           (store-value (lambda (value)
                          (add-result 'restart-store-value)
                          value)))))
     => ("ciao"
           (body-begin error-handler-begin restart-store-value))

     ;;Call a STORE-VALUE restart, no STORE-VALUE handler is defined.
     ;;
     (with-result
       (add-result 'body-begin)
       (begin0
           (store-value 1)
         (add-result 'body-return)))
     => (#f (body-begin body-return))

     ;;; store-value/use-value

     ;;Adapted example from Common Lisp's Hyper Spec.
     ;;
     (internal-body

       (define-condition-type &unbound-symbol-error
           &error
         make-unbound-symbol-error
         unbound-symbol-error?)

       (define* (careful-symbol-value sym)
         (restart-case
             (if (symbol-bound? sym)
                 (symbol-value sym)
               (signal (make-unbound-symbol-error)))
           (use-value   (lambda (obj) obj))
           (store-value (lambda (obj)
                          (set-symbol-value! sym obj)
                          obj))))

       (let ((sym (gensym)))
         (set-symbol-value! sym 1)
         (careful-symbol-value sym))
       => 1

       (let ((sym (gensym)))
         (handler-bind
             ((&unbound-symbol-error (lambda (E)
                                       (use-value 1))))
           (careful-symbol-value sym)))
       => 1

       (let ((sym (gensym)))
         (handler-bind
             ((&unbound-symbol-error (lambda (E)
                                       (store-value 1))))
           (values (careful-symbol-value sym)
                   (careful-symbol-value sym))))
       => 1 1

       #| end of INTERNAL-BODY |# )

     ;;; continue

     ;;Signal condition, call a handler, call a CONTINUE restart.
     ;;
     (with-result
       (handler-bind
           ((&error (lambda (E)
                      (add-result 'error-handler-begin)
                      (continue-restart)
                      (add-result 'error-handler-return))))
         (restart-case
             (begin
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return))
           (continue (lambda ()
                       (add-result 'restart-continue)
                       2)))))
     => (2 (body-begin error-handler-begin restart-continue))

     ;;CONTINUE example derived from Common Lisp's Hyper Spec.
     ;;
     (internal-body

       (define (real-sqrt n)
         (when (negative? n)
           (set! n (- n))
           (restart-case
               (signal (make-error))
             (continue (lambda ()
                         (add-result 'continue-restart)))))
         (sqrt n))

       (with-result
         (handler-bind
             ((&error (lambda (E)
                        (add-result 'error-handler)
                        (continue-restart))))
           (add-result 'body-enter)
           (begin0
               (real-sqrt -9)
             (add-result 'body-return)))))
     => (3
           (body-enter error-handler continue-restart body-return))

     ;;Call a CONTINUE restart, no CONTINUE handler is defined.
     ;;
     (with-result
         (try
             (restart-case
                 (begin
                   (add-result 'body-begin)
                   (begin0
                       (continue-restart)
                     (add-result 'body-return))))
           (catch E
             ((&restarts-control-error)
              (add-result 'catch-control-error)
              2)
             (else
              (print-condition E)
              3))))
     => (#f (body-begin body-return))

     ;;Signal condition, call  the inner handler, call an CONTINUE  restart, no CONTINUE
     ;;handler is defined, call the outer handler, return.
     ;;
     (with-result
       (with-return-to-signal-on-unhandled-exception
         (handler-bind
             ((&error (lambda (E)
                          (add-result 'outer-error-handler))))
             (handler-bind
                 ((&error (lambda (E)
                            (add-result 'inner-error-handler-begin)
                            (continue-restart)
                            (add-result 'inner-error-handler-return))))
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return)
               1))))
     => (1
           (body-begin
            inner-error-handler-begin
            inner-error-handler-return
            outer-error-handler
            body-return))

     ;;; abort

     ;;Signal condition, call a handler, call an ABORT restart.
     ;;
     (with-result
       (handler-bind
           ((&error (lambda (E)
                      (add-result 'error-handler-begin)
                      (abort-restart)
                      (add-result 'error-handler-return))))
         (restart-case
             (begin
               (add-result 'body-begin)
               (signal (make-error))
               (add-result 'body-return))
           (abort (lambda ()
                    (add-result 'restart-abort)
                    2)))))
     => (2 (body-begin error-handler-begin restart-abort))

     ;;Call an ABORT restart, no ABORT handler is defined.
     ;;
     (with-result
       (try
           (begin
             (add-result 'body-begin)
             (abort-restart)
             (add-result 'body-return))
         (catch E
           ((&restarts-control-error)
            (add-result 'catch-control-error)
            2)
           (else E))))
     => (2 (body-begin catch-control-error))

     ;;Signal condition, call a handler, call an ABORT restart,
     ;;no ABORT handler is defined.
     ;;
     (with-result
       (try
           (handler-bind
               ((&error (lambda (E)
                          (add-result 'error-handler-begin)
                          (abort-restart)
                          (add-result 'error-handler-return))))
             (add-result 'body-begin)
             (signal (make-error))
             (add-result 'body-return))
         (catch E
           ((&restarts-control-error)
            (add-result 'catch-control-error)
            2)
           (else E))))
     => (2 (body-begin error-handler-begin catch-control-error))


File: vicare-libs.info,  Node: restarts errors,  Prev: restarts func,  Up: restarts

1.18.9 Detecting errors in the conditions and restarts mechanism
----------------------------------------------------------------

Base condition type
-------------------

 -- Condition Type: &restarts-error
     Base type of all the error conditions associated to the restarts
     mechanism.

 -- Function: make-restarts-error
     Build and return a condition object of type '&restarts-error'.

 -- Function: restarts-error-condition? OBJ
     Return '#t' if OBJ is a condition object of type '&restarts-error';
     otherwise return '#f'.

Control error condition type
----------------------------

 -- Condition Type: &restarts-control-error
     Type of error conditions associated to the restarts mechanism.  It
     is derived from '&restarts-error'.

 -- Function: make-restarts-control-error
     Build and return a condition object of type
     '&restarts-control-error'.

 -- Function: restarts-control-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&restarts-control-error'; otherwise return '#f'.

 -- Function: signal-restarts-control-error WHO MESSAGE IRRITANT ...
     Build a compound condition object with components:
     '&restarts-control-error', '&who' '&message' '&irritants' and raise
     it using 'signal'.

Undefined restart error condition type
--------------------------------------

 -- Condition Type: &undefined-restart-error
     Type of the error conditions raise when attempting to invoke an
     undefined restart.  It is derived from '&restarts-control-error'.

 -- Function: make-undefined-restart-error
     Build and return a condition object of type
     '&undefined-restart-error'.

 -- Function: undefined-restart-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&undefined-restart-error'; otherwise return '#f'.

 -- Function: signal-undefined-restart-error WHO MESSAGE IRRITANT ...
     Build a compound condition object with components:
     '&undefined-restart-error', '&who' '&message' '&irritants' and
     raise it using 'signal'.


File: vicare-libs.info,  Node: ibodies,  Next: tuples,  Prev: restarts,  Up: lang

1.19 Instantiable bodies
========================

Instantiable bodies are sequences of forms defined in a lexical context
and usable in another lexical context with some preliminary processing.
The following syntactic bindings are exported by the library '(vicare
language-extensions instantiable-bodies)'.

 -- Syntax: define-instantiable-body ?DEFINER . ?BODY
     Define a new syntax bound to the syntactic identifier ?DEFINER
     which, when used, expands to the ?BODY forms.  The defined syntax
     must be used as follows:

          (?DEFINER
            ((?FROM ?TO) ...))

     where ?FROM must be a syntactic identifier and ?TO can be any form.
     Before the expansion: all the occurrences of the syntactic
     identifiers ?FROM are replaced by the associated syntactic
     identifiers ?TO.

   Here is a simple example:

     (define-instantiable-body definer
       (define (fun)
         const))

     (definer ((fun doit) (const 123)))

     (doit)  => 123

the use of the syntax 'definer' expands into:

     (define (doit)
       123)


File: vicare-libs.info,  Node: tuples,  Prev: ibodies,  Up: lang

1.20 Tuples on top of lists and vectors
=======================================

The library '(vicare language-extensions tuples)' implements tuples on
top of ordinary Scheme lists and vectors; the library makes use of the
typed language.  Tuple-types are label-types used to provide convenient
read-only access to lists and vectors (*note Sub-typing with labels:
(vicare-scheme)types labels.).

   The following syntactic bindings are exported by the library '(vicare
language-extensions tuples)'.

 -- Syntax: define-list-tuple-type ?NAME ?CLAUSE ...
 -- Syntax: define-vector-tuple-type ?NAME ?CLAUSE ...
 -- Auxiliary Syntax: fields
 -- Auxiliary Syntax: brace
     Define a new tuple type on top of lists or vectors.

     At present only the 'fields' clause is supported; the syntactic
     bindings 'fields' and 'brace' are the ones exported by the library
     '(vicare)'.

     The clause 'fields' must have the following format:

          (fields ?FIELD-SPEC0 ?FIELD-SPEC ...)

     where each ?FIELD-SPEC must have one of the following formats:

          ?FIELD-NAME
          (brace ?FIELD-NAME ?FIELD-TYPE)

     where ?FIELD-NAME is a syntactic identifier representing the field
     name and ?FIELD-TYPE is a syntax object representing the field's
     type annotation.  When no type annotation is specified: it defaults
     to '<top>'.

   Usage examples with lists and untyped fields:

     (define-list-tuple-type <stuff>
       (fields a b c))

     (define T
       (new <stuff> 1 2 3))

     (.a T)  => 1
     (.b T)  => 2
     (.c T)  => 3

usage examples with vectors and typed fields:

     (define-vector-tuple-type <stuff>
       (fields {a <fixnum>}
               {b <flonum>}
               {c <string>}))

     (define T
       (new <stuff> 1 2.3 "ciao"))

     T                       => #(1 2.3 "ciao")
     (.a T)                  => 1
     (.b T)                  => 2.3
     (.c T)                  => "ciao"
     (.length (.c T))        => 4


File: vicare-libs.info,  Node: srfi,  Next: platform,  Prev: lang,  Up: Top

2 Scheme Requests For Implementation
************************************

A port to R6RS of the SRFI libraries is included in the distribution of
Vicare.  The libraries' names conform to SRFI 97: SRFI Libraries.  There
is a registry of available SRFIs and other platform features which works
alongside SRFI 0: Feature-Based Conditional Expansion.

   The SRFI libraries are optionally installed by the package; the
availability of the SRFI libraries can be tested at run-time with the
function 'vicare-built-with-srfi-enabled' from '(vicare)' (*note
vicare-built-with-srfi-enabled: (vicare-scheme)iklib config.), and at
expand-time with the clause 'srfi-enabled' of 'cond-expand' from SRFI-0
(*note linux-enabled: srfi cond-expand vicare.).

     This SRFI documentation is an unofficial Texinfo reformatting and
     minor modification of the original documents by Marco Maggi.

* Menu:

* srfi cond-expand::            SRFI-0 feature based conditional
                                expansion construct.
* srfi list::                   SRFI-1 list library.
* srfi and-let-star::           SRFI-2 'and-let*'.
* srfi string-ports::           SRFI-6 basic string ports.
* srfi receive::                SRFI-8 'receive': Binding to
                                multiple values.
* srfi records::                SRFI-9 defining record types.
* srfi let-values::             SRFI-11 syntax for receiving
                                multiple values.
* srfi strings::                SRFI-13 string library.
* srfi char-sets::              SRFI-14 character sets.
* srfi case-lambda::            SRFI-16 syntax for procedures of
                                variable arity.
* srfi time::                   SRFI-19 time data types and procedures.
* srfi error-reporting::        SRFI-23 error reporting mechanism.
* srfi marray::                 SRFI-25 multidimensional array.
* srfi shared structures::      SRFI-38 representation for data with
                                shared structure.
* srfi specialize-procedures::  SRFI-26 notation for specializing
                                parameters without currying.
* srfi random::                 SRFI-27 sources of random bits.
* srfi basic-format::           SRFI-28 basic format strings.
* srfi rec::                    SRFI-31 a special form 'rec'
                                for recursive evaluation.
* srfi parameters::             SRFI-39 parameter objects.
* srfi args-fold::              SRFI-37 a program argument processor.
* srfi streams::                SRFI-41 streams.
* srfi eager-comp::             SRFI-42 eager comprehensions.
* srfi vectors::                SRFI-43 vector library.
* srfi lazy::                   SRFI-45 lazy iterative algorithms.
* srfi intermediate-format::    SRFI-48 intermediate format strings.
* srfi general-cond::           SRFI-61 a more general 'cond' clause.
* srfi testing::                SRFI-64 testing.
* srfi compare-procedures::     SRFI-67 compare procedures.
* srfi hash-tables::            SRFI-69 basic hash tables.
* srfi lightweight-testing::    SRFI-78 lightweight testing.
* srfi environment-variables::  SRFI-98 environment variables.
* srfi err5rs records::         SRFI-99 ERR5RS records.
* srfi ralists::                SRFI-101 random-access lists.
* srfi basic-socket::           SRFI-106 basic socket interface.
* srfi boxes::                  SRFI-111 boxes.
* srfi env-inquiry::            SRFI-112 environment inquiry.
* srfi sets-and-bags::          SRFI-113 sets and bags.
* srfi comparators::            SRFI-114 comparators.
* srfi regexps::                SRFI-115 regular expressions.
* srfi ilists::                 SRFI-116 immutable lists.


File: vicare-libs.info,  Node: srfi cond-expand,  Next: srfi list,  Up: srfi

2.1 SRFI-0 feature based conditional expansion construct
========================================================

The library '(srfi :0)' is by Marc Feeley as reference implementation
for SRFI-0; see:

             <http://srfi.schemers.org/srfi-0/srfi-0.html>

for more details.

* Menu:

* srfi cond-expand license::    Original document license.
* srfi cond-expand abstract::   Abstract.
* srfi cond-expand rationale::  Rationale.
* srfi cond-expand spec::       Specifications.
* srfi cond-expand vicare::     Features supported by Vicare.


File: vicare-libs.info,  Node: srfi cond-expand license,  Next: srfi cond-expand abstract,  Up: srfi cond-expand

2.1.1 Original document license
-------------------------------

Copyright (C) Marc Feeley 1999.  All Rights Reserved.

   This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Scheme Request For Implementation process or
editors, except as needed for the purpose of developing SRFIs in which
case the procedures for copyrights defined in the SRFI process must be
followed, or as required to translate it into languages other than
English.

   The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

   This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


File: vicare-libs.info,  Node: srfi cond-expand abstract,  Next: srfi cond-expand rationale,  Prev: srfi cond-expand license,  Up: srfi cond-expand

2.1.2 Abstract
--------------

It is desirable that programs which depend on additions to standard
Scheme name those additions.  SRFIs provide the specifications of these
additions ("features"), and SRFI-0 provides the means to actually check
that these features are present in the Scheme system by means of the
'cond-expand' construct.  It is anticipated that there will be two main
classes of features:

   * sets of value and syntax bindings;

   * reader syntax extensions;

"reader syntax" refers to aspects of the syntax described by the
grammars in the Scheme reports.

   The former class of features will probably include most SRFIs,
exemplified by the list library specified in SRFI-1.  The latter class
includes Unicode source code support and different kinds of parentheses.

   Control over the presence of individual features will vary over
different Scheme systems.  A given feature may be absent or provided by
default in some Scheme systems and in others some mechanism (such as an
'import' clause in the code or a program configuration file, a command
line option, a dependency declaration in a module definition, etc.)
will be required for the feature to be present in the system.

   Moreover, in some systems a given feature may be in effect throughout
the entire program if it is in effect anywhere at all.  Other systems
may have more precise mechanisms to control the scope of a feature (this
might be the case for example when a module system is supported).  In
general it is thus possible that a feature is in effect in some parts of
the program and not in others.  This allows conflicting SRFIs to be
present in a given program as long as their scope do not intersect.

   SRFI-0 does not prescribe a particular mechanism for controlling the
presence of a feature as it is our opinion that this should be the role
of a module system.  We expect that future module system SRFIs will need
to extend the semantics of SRFI-0 for their purposes, for example by
defining feature scoping rules or by generalizing the feature testing
construct.


File: vicare-libs.info,  Node: srfi cond-expand rationale,  Next: srfi cond-expand spec,  Prev: srfi cond-expand abstract,  Up: srfi cond-expand

2.1.3 Rationale
---------------

Most Scheme systems extend the language with some additional features
(such as the ability to manipulate Unicode characters and strings, to do
binary I/O, or to handle asynchronous interrupts).  Such features may be
provided in a variety of ways including new procedures, new program
syntax, and extended behavior of standard procedures and special-forms.

   A particular functionality may exist in several or even most Scheme
systems but its API may be different (use of a procedure or
special-form, name, number of parameters, etc).  To write code that will
run on several Scheme systems, it is useful to have a common construct
to enable or disable sections of code based on the existence or absence
of a feature in the Scheme system being used.  For example, the
construct could be used to check if a particular binary I/O procedure is
present, and if not, load a portable library which implements that
procedure.

   Features are identified by feature identifiers.  In order for the
semantics of this construct to be well-defined, the feature identifier
must of course refer to a feature which has a well-defined meaning.
There is thus a need for a registry, independent of this SRFI, to keep
track of the formal specification associated with each valid
feature-identifier.  The SRFI registry is used for this purpose.  It is
expected that features will eventually be assigned meaningful names
(aliases) by the SRFI editors to make reading and writing code less
tedious than when using 'srfi-N' feature identifiers.

   Another issue is the binding time of this construct (i.e.  the moment
when it operates).  It is important that the binding time be early so
that a compiler can discard the sections of code that are not needed,
and perform better static analyses.  Expressing this construct through a
procedure returning a boolean, such as:

     (feature-implemented? 'srfi-5)

would not achieve this goal, as its binding time is too late (i.e.
program run-time).  A read-time construct, such as Common Lisp's '#+'
read-macro, is very early but would require non-trivial changes to the
reader of existing Scheme systems and the syntax is not particularly
human friendly.  Instead, a macro-expansion-time construct is used.

   The construct is restricted to the top level of a program in order to
simplify its implementation and to force a more disciplined use of the
construct (to facilitate reading and understanding programs) and to
avoid (some) misunderstandings related to the scope of features.  These
restrictions can of course be lifted by some Scheme systems or by other
SRFIs (in particular module system SRFIs).

