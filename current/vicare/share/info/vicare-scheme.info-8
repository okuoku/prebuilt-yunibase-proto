This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: machinery call frames,  Next: machinery continuations,  Prev: machinery scheme stack,  Up: machinery

16.4 Basics of function call frames
===================================

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.

   Let's consider the program:

     (import (rnrs))
     (define (one A)
       (+ A 1))
     (one 2)

in which the call to Scheme function generates a stack frame; the form
'(one 2)' is the "call site" and we can think of it as generating
Assembly code containing the chunk:

     (call address_of_one)
     (label return_address)

   Let's start with an empty Scheme stack represented by CPU registers
and PCB fields, *note machinery call frames: fig:MCF_empty_stack_Scheme.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler | <- Frame Pointer Register (FPR)
     |----------------------|
                 .
                 .
                 .
     |----------------------|
     |                      | <- pcb->stack_base
     |----------------------|
     |                      |
            low memory

Figure 16.4: Empty Scheme stack as represented in the CPU registers and
the PCB structure while running Scheme code.

   Running the program means executing the following operations:

  1. Prepare to call 'one': put the single argument on the stack 2
     machine words below the underflow handler, *note machinery call
     frames: fig:MCF_one_before.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler | <- FPR
          |----------------------|
          |                      | <- FPR - 1*wordsize
          |----------------------|
          |    argument A == 2   | <- FPR - 2*wordsize
          |----------------------|
          |                      |
                 low memory

     Figure 16.5: Preparing the function call to 'one' by putting the
     argument on the stack.

  2. Call 'one': execute the Assembly instruction 'call'; this puts the
     return address on the stack and decrements the FPR by a machine
     word, *note machinery call frames: fig:MCF_one_after.  Notice that
     the stack now contains a single stack frame representing the status
     of the code before the call.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler |
          |----------------------|         --
          |    return address    | <- FPR  . frame of caller
          |----------------------|         --
          |    argument A == 2   |
          |----------------------|
          |                      |
                 low memory

     Figure 16.6: Stack right after the function call to 'one'.

  3. Prepare to call '+': put the two arguments on the stack 2 machine
     words below the return address, *note compiler machinery call
     frames: fig:MCF_plus_before.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler |
          |----------------------|         --
          |    return address    | <- FPR  . frame of caller
          |----------------------|         --
          |    argument A == 2   |         .
          |----------------------|         . frame of ONE
          |                      |         .
          |----------------------|         --
          |   1st argument == 2  |
          |----------------------|
          |   2nd argument == 1  |
          |----------------------|
          |                      |
                 low memory

     Figure 16.7: Preparing the call to '+'.

  4. Adjust the FPR to reference the machine word right above the one
     that will hold the return address, *note compiler machinery call
     frames: fig:MCF_plus_adjust.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler |
          |----------------------|         --
          |    return address    |         . frame of caller
          |----------------------|         --
          |    argument A == 2   | <- FPR
          |----------------------|
          |                      |
          |----------------------|
          |   1st argument == 2  |
          |----------------------|
          |   2nd argument == 1  |
          |----------------------|
          |                      |
                 low memory

     Figure 16.8: Adjusting the FPR for the call to '+'.

  5. Call '+': execute the Assembly instruction 'call'; this puts the
     return address on the stack and decrements the FPR by a machine
     word, *note machinery call frames: fig:MCF_plus_after.  Notice that
     the stack now contains two stack frames representing the status of
     the code before the call.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler |
          |----------------------|         --
          |    return address    |         . frame of caller
          |----------------------|         --
          |    argument A == 2   |         .
          |----------------------|         . frame of ONE
          |    return address    | <- FPR  .
          |----------------------|         --
          |   1st argument == 2  |
          |----------------------|
          |   2nd argument == 1  |
          |----------------------|
          |                      |
                 low memory

     Figure 16.9: Stack right after the call to '+'.

  6. Let's skip how '+' performs the addition and just assume that the
     result is stored in the AAR register.

  7. Return from '+': execute the Assembly instruction 'ret' which:
     loads the machine word from the stack location referenced by FPR
     into the CPU's Instruction Pointer Register, increments the FPR by
     a machine word, jumps to the code address in the Instruction
     Pointer Register, *note machinery call frames: fig:MCF_plus_ret.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler |
          |----------------------|         --
          |    return address    |         . frame of caller
          |----------------------|         --
          |    argument A == 2   | <- FPR  .
          |----------------------|         . frame of ONE
          |    return address    |         .
          |----------------------|         --
          |                      |
                 low memory

     Figure 16.10: Stack right after the 'ret' instruction that returns
     from '+'.

  8. Adjust back the FPR to reference the return address of the caller
     *note machinery call frames: fig:MCF_caller_adjust.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler |
          |----------------------|         --
          |    return address    | <- FPR  . frame of caller
          |----------------------|         --
          |    argument A == 2   |
          |----------------------|
          |                      |
                 low memory

     Figure 16.11: Adjusting the FPR back after returning from '+'.

  9. Return from 'one': execute the Assembly instruction 'ret' which:
     loads the machine word from the stack location referenced by FPR
     into the CPU's Instruction Pointer Register, increments the FPR by
     a machine word, jumps to the code address in the Instruction
     Pointer Register, *note machinery call frames: fig:MCF_one_ret.
     The return value is still in the AAR register.

                high memory
          |                      |
          |----------------------|
          |                      | <- pcb->frame_base
          |----------------------|
          | ik_underflow_handler | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.12: Stack right after the 'ret' instruction that returns
     from 'one'.

  10. The form '(one 2)' is the only top-level expression in the
     program, so, after executing it, the execution flow must go back to
     the C code that started the program; we can imagine the Assembly
     code:

          (call address_of_one)
          (label return_address)
          ;; move the return value from AAR to the stack
          (movl AAR (disp (- wordsize) FPR))
          (ret)

     where '(ret)' jumps to the underflow handler.

   After the program execution: the stack is left empty as it was at the
beginning; this is because no continuation objects have been created.


File: vicare-scheme.info,  Node: machinery continuations,  Next: machinery stack overflow,  Prev: machinery call frames,  Up: machinery

16.5 The current continuation
=============================

For the original paper presenting an implementation of continuations
quite similar (but not equal) to the one used by Vicare see *note
references: bib:HDBControl.

* Menu:

* machinery continuations general::  General concept of process
                                     continuation.
* machinery continuations without::  Subordinate function calls without
                                     continuations.
* machinery continuations immut::    Immutability of the Scheme stack.
* machinery continuations non::      Subordinate function calls with
                                     non-invoked continuation.
* machinery continuations escape::   Subordinate function calls with
                                     invoked continuation.


File: vicare-scheme.info,  Node: machinery continuations general,  Next: machinery continuations without,  Up: machinery continuations

16.5.1 General concept of process continuation
----------------------------------------------

Let's think of a process in execution as having: a table of descriptors,
a code memory segment, a heap memory segment and a stack memory segment,
*note machinery continuations general: fig:MCG_process_segments.  The
Instruction Pointer CPU register (IP) keeps track of the next
instruction to execute in the code segment; the Stack Pointer CPU
register (SP) keeps track of the current location on the stack;
dynamically allocated data goes in the heap segment.

     |---|---|---| descriptors table
       |   |   |
       |   |   |      IP
       |   |   v      v
       |   |   |------+---------------| code segment
       |   v
       |   |----------------------| heap segment
       v
       |----------+-----------| stack segment
                  ^
                  SP

Figure 16.13: Memory segments of a process in execution.

   One way to implement continuations is to push the current IP on the
stack segment, duplicate the stack segment itself, finally save
somewhere the SP; later we can reinstall the saved stack segment, reset
the SP and perform a 'ret' assembly instruction that will pop the saved
IP and resume the execution; *note machinery continuations general:
fig:MCG_duplicated_stack_segment.  Of course we must make sure that the
resources referenced by the saved stack segment are not released while
the continuation still exists.

     |---|---|---| descriptors table
       |   |   |
       |   |   |     IP IP1
       |   |   v      v v
       |   |   |------+-+--------------| code segment
       |   v
       |   |----------------------| heap segment
       |
       v           IP1
       |----------+--+---------| stack segment
                  ^
                  SP

                   IP1
       |----------+--+---------| duplicated stack segment
                  ^
                  SP

Figure 16.14: Duplicated stack segment as continuation implementation
mechanism.

   Stack segment duplication is *not* the way Vicare implements
continuations; but the actual implementation is not conceptually
different.


File: vicare-scheme.info,  Node: machinery continuations without,  Next: machinery continuations immut,  Prev: machinery continuations general,  Up: machinery continuations

16.5.2 Subordinate function calls without continuations
-------------------------------------------------------

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.  Let's look at this simple program that does
not create explicit continuations:

     (import (rnrs))
     (define (alpha) (beta))
     (define (beta)  (delta))
     (define (delta) 123)
     (alpha)

   Vicare allocates a memory segment to be used as stack, then executes
the call to 'alpha' pushing its stack frame on the stack; as subordinate
function calls are performed: new stack frames are pushed on the stack,
*note machinery continuations without: fig:MCW_continuation_stack_grow.

             -- growing direction -->

     |----------|---------------------------------------|
       locals of
       toplevel

     |----------|----------|----------------------------|
       frame of  locals of
       toplevel    alpha

     |----------|----------|----------|-----------------|
       frame of   frame of  locals of
       toplevel    alpha     beta

     |----------|----------|----------|-----------|-----|
       frame of   frame of   frame of   locals of
       toplevel    alpha      beta       delta

Figure 16.15: Scheme stack segment after calling 'alpha', 'beta',
'delta'.

   When the functions return the stack rewinds; when there are no more
stack frames: there is nowhere to return to, so the program terminates,
*note machinery continuations without:
fig:MCW_continuation_stack_rewind.

             <-- rewind direction --

     |----------|----------|----------|-----------------|
       frame of   frame of   frame of
       toplevel    alpha      beta

     |----------|----------|----------------------------|
       frame of   frame of
       toplevel    alpha

     |----------|---------------------------------------|
       frame of
       toplevel

Figure 16.16: Scheme stack segment after returning from 'delta', 'beta',
'alpha'.


File: vicare-scheme.info,  Node: machinery continuations immut,  Next: machinery continuations non,  Prev: machinery continuations without,  Up: machinery continuations

16.5.3 Immutability of the Scheme stack
---------------------------------------

Under Vicare machine words on the stack are immutable by definition;
let's see why.  Scheme has two kinds of values: immediate and compound.

   * Each instance of an immediate value (boolean, fixnum, character,
     ...) is fully contained in a single machine word; immediate values
     are moved around in CPU registers and memory locations and they are
     immutable; immediate values are put on the stack if it is needed
     for the execution of a program.

   * Each instance of a compound value (pair, vector, record, ...) is
     composed of a memory block, allocated on the heap and actually
     holding the data, and a reference to it: a machine word being the
     tagged address of the first word in the memory block.

     If we mutate a vector with 'vector-set!': we mutate the memory
     block, the reference to such vector is untouched.  References to
     compound values are immutable.

     Vicare always allocates compound values' memory blocks on the heap,
     while references are moved around in CPU registers and memory
     locations; references are put on the stack if it is needed for the
     execution of a program.

   Local variables can be mutated, special care is taken to implement
them; *note Local variables: machinery locals.


File: vicare-scheme.info,  Node: machinery continuations non,  Next: machinery continuations escape,  Prev: machinery continuations immut,  Up: machinery continuations

16.5.4 Subordinate function calls with non-invoked continuation
---------------------------------------------------------------

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.  Let's consider the following program that
creates a continuation but does *not* call its escape function:

     (import (rnrs))
     (define (alpha A)
       (beta A))
     (define (beta B)
       (call/cc
          (lambda (escape)
            (+ B 2))))
     (alpha 1)

we can understand how the stack grows until right after the call to
'call/cc' but before 'call/cc' actually does something, *note machinery
continuations non: fig:MCN_callcc_begin.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler |
     |----------------------|         --
     |  return addr to top  |         . frame of toplevel
     |----------------------|         --
     |    argument A == 1   |         .
     |----------------------|         . frame of alpha
     | return addr to alpha |         .
     |----------------------|         --
     |    argument B == 1   |         .
     |----------------------|         . frame of beta
     | return addr to beta  | <- FPR  .
     |----------------------|         --
     |   closure reference  |         . locals of call/cc
     |----------------------|         .
     |                      |
            low memory

Figure 16.17: Stack right after the call to 'call/cc' but before
'call/cc' does something.

   For convenience we give a name to the closure '(lambda (escape) (+ B
2))', let's call it "receiver"(1).  'call/cc' creates a continuation
object by freezing the call frames currently on the stack between FPR
and 2 words below 'pcb->frame_base', *note machinery continuations non:
fig:MCN_callcc_freezing.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler |
     |----------------------|         --
     |  return addr to top  |         .
     |----------------------|         .
     |    argument A == 1   |         .
     |----------------------|         . freezed
     | return addr to alpha |         . frames
     |----------------------|         .
     |    argument B == 1   |         .
     |----------------------|         .
     | return addr to beta  | <- FPR  .
     |----------------------|         --
     |       receiver       |         . locals of
     |----------------------|         . call/cc
     |                      |
            low memory

Figure 16.18: Region of stack freezed by 'call/cc'.

   The continuation object references the array of freezed words on the
stack, keeping a reference to the value of FPR at the time of creation.
The continuation object is also a node in a simply linked list of
continuation objects, whose head is stored in a field of the PCB:
'pcb->next_k'.  In more detail 'call/cc' does the following:

  1. Create the continuation object and prepend it to the list in
     'pcb->next_k'; let's call this continuation object K_1; *note
     machinery continuations non: fig:MCN_callcc_next_k_K1.

          |--------|---| PCB
                     |
               next_k --------> |-----|-| K_1
                                       |
                                   next -----> NULL

     Figure 16.19: Continuation object K_1 inserted as new "next PCB
     continuation".

  2. Create a closure object implementing the escape function associated
     to the continuation object, the one that will be bound to ESCAPE in
     the example; *note machinery continuations non:
     fig:MCN_callcc_K1_escape.  In the closure object: the address of
     the code entry point references the special subroutine
     'SL_continuation_code', the single slot for free variables
     references the continuation object.

          |-----|-----| closure object
             |     |
             |      --------> |------| K_1
             |
              --------------> |------| code object

     Figure 16.20: Closure object implementing the escape function for
     K_1.

  3. Prepare the application of the receiver closure to the escape
     function: move the reference to the receiver closure in the CPR;
     move the address of the underflow handler on the stack and set the
     FPR to reference it; set the value of 'pcb->frame_base' to exclude
     the freezed frames from the stack segment; *note machinery
     continuations non: fig:MCN_callcc_before_receiver.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     --
          |  return addr to top  |                     .
          |----------------------|                     .
          |    argument A == 1   |                     .
          |----------------------|                     . freezed
          | return addr to alpha |                     . frames
          |----------------------|                     . in K_1
          |    argument B == 1   |                     .
          |----------------------|                     .
          | return addr to beta  | <- pcb->frame_base  .
          |----------------------|                     --
          | ik_underflow_handler | <- FPR              .
          |----------------------|                     . locals of
          |    escape closure    |                     . receiver
          |----------------------|                     . closure
          |                      |
                 low memory


     Figure 16.21: Stack right before the call to the receiver closure.

  4. Perform a direct jump to the entry point of the receiver closure
     without pushing a return address on the stack.  The FPR is left
     referencing the entry point of the stack underflow handler.

   In this example, the receiver closure executes '(+ B 2)' and returns;
there is only a single return value: it is put in AAR and the return
from the closure is performed with a 'ret' Assembly instruction.  We
skip the details of performing the addition and consider the stack right
before the 'ret' Assembly instruction is executed by the CPU, *note
machinery continuations non: fig:MCN_callcc_after_receiver.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     --
     |  return addr to top  |                     .
     |----------------------|                     .
     |    argument A == 1   |                     .
     |----------------------|                     . freezed
     | return addr to alpha |                     . frames
     |----------------------|                     . in K_1
     |    argument B == 1   |                     .
     |----------------------|                     .
     | return addr to beta  | <- pcb->frame_base  .
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.22: Stack right before the receiver closure executes the 'ret'
Assembly instruction; the single return value is in AAR.

   The FPR references the underflow handler, so the 'ret' instruction
will cause the execution flow to jump there; the stack underflow handler
does the following:

  1. Detect the presence of a multiframe continuation object as "next
     PCB continuation", so split K_1 in two continuation objects: the
     mutated K_1 referencing only the frame of 'beta' and a new
     continuation object K_2 referencing all the other frames, *note
     machinery continuations non: fig:MCN_callcc_K2_frames.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     --
          |  return addr to top  |                     .
          |----------------------|                     . freezed
          |    argument A == 1   |                     . frames
          |----------------------|                     . in K_2
          | return addr to alpha |                     .
          |----------------------|                     --
          |    argument B == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to beta  | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.23: Continuation object K_1 mutated to reference a single
     frame.

  2. Insert K_2 in the linked list of continuation objects after K_1 and
     register it as the new "next PCB continuation", *note machinery
     continuations non: fig:MCN_callcc_next_k_K2.

          |--------|---| PCB
                     |
               next_k|     |-----|-| K_1
                     |            |
                     |        next -->|
                      --------------->|-----|-| K_2
                                             |
                                         next -----> NULL

     Figure 16.24: Continuation object K_2 inserted as new "next
     continuation".

  3. Duplicate the stack frame referenced by K_1 below the address of
     the underflow handler, adjust the FPR to reference the return
     address of the frame, *note machinery continuations non:
     fig:MCN_callcc_K1_copy.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     --
          |  return addr to top  |                     .
          |----------------------|                     . freezed
          |    argument A == 1   |                     . frames
          |----------------------|                     . in K_2
          | return addr to alpha |                     .
          |----------------------|                     --
          |    argument B == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to beta  | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler |
          |----------------------|
          |    argument B == 1   |
          |----------------------|
          | return addr to beta  | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.25: Stack frame in K_1 duplicated below the underflow
     handler address.

  4. There is a single return value, so: perform a 'ret' Assembly
     instruction to go back to the body of 'beta'.

   The code of 'beta' is reentered right after the call to 'call/cc' and
the FPR is adjusted to reference the address of the stack underflow
handler, *note compiler machinery continuations non:
fig:MCN_callcc_beta_ret.  'beta' must return the same return value,
which is already in the AAR: it executes a 'ret' Assembly instruction.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     --
     |  return addr to top  |                     .
     |----------------------|                     . freezed
     |    argument A == 1   |                     . frames
     |----------------------|                     . in K_2
     | return addr to alpha |                     .
     |----------------------|                     --
     |    argument B == 1   |                     . freezed
     |----------------------|                     . frame
     | return addr to beta  | <- pcb->frame_base  . in K_1
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.26: Stack right before 'beta' executes the 'ret' Assembly
instruction; the return value is in the AAR.

   The stack underflow handler is reentered and does the following:

  1. Detect the presence of a multiframe continuation object as "next
     PCB continuation", so split K_2 in two continuation objects: the
     mutated K_2 referencing only the frame of 'alpha' and a new
     continuation object K_3 referencing all the other frames, *note
     machinery continuations non: fig:MCN_callcc_K3_frames.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |                        freezed
          |----------------------|                     -- frame
          |  return addr to top  |                     .  in K_3
          |----------------------|                     --
          |    argument A == 1   |                     . freezed
          |----------------------|                     . frames
          | return addr to alpha |                     . in K_2
          |----------------------|                     --
          |    argument B == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to beta  | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.27: Continuation object K_2 mutated to reference a single
     frame.

  2. Insert K_3 in the linked list of continuation objects after K_2 and
     register it as the new "next PCB continuation", *note machinery
     continuations non: fig:MCN_callcc_next_k_K3.

          |-----|---| PCB
                  |
            next_k|   |-----|-| K_1
                  |          |
                  |      next -->|-----|-| K_2
                  |                     |
                  |                 next ----->|
                   --------------------------->|-----|-| K_3
                                                      |
                                                  next -----> NULL

     Figure 16.28: Continuation object K_2 inserted as new "next
     continuation".

  3. Duplicate the stack frame referenced by K_2 below the address of
     the underflow handler, adjust the FPR to reference the return
     address of the frame, *note machinery continuations non:
     fig:MCN_callcc_K2_copy.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |                        freezed
          |----------------------|                     -- frames
          |  return addr to top  |                     .  in K_3
          |----------------------|                     --
          |    argument A == 1   |                     .
          |----------------------|                     . frames
          | return addr to alpha |                     . in K_2
          |----------------------|                     --
          |    argument B == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to beta  | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler |
          |----------------------|
          |    argument A == 1   |
          |----------------------|
          | return addr to alpha | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.29: Stack frame in K_2 duplicated below the underflow
     handler address.

  4. There is a single return value, so: perform a 'ret' Assembly
     instruction to go back to the body of 'alpha'.

   The code of 'alpha' is reentered right after the call to 'beta' and
the FPR is adjusted to reference the address of the stack underflow
handler, *note compiler machinery continuations non:
fig:MCN_callcc_alpha_ret.  'alpha' must return the same return value,
which is already in the AAR: it executes a 'ret' Assembly instruction.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |                        freezed
     |----------------------|                     -- frames
     |  return addr to top  |                     .  in K_3
     |----------------------|                     --
     |    argument A == 1   |                     .
     |----------------------|                     . frames
     | return addr to alpha |                     . in K_2
     |----------------------|                     --
     |    argument B == 1   |                     . freezed
     |----------------------|                     . frame
     | return addr to beta  | <- pcb->frame_base  . in K_1
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.30: Stack right before 'alpha' executes the 'ret' Assembly
instruction; the return value is in the AAR.

   The stack underflow handler is reentered and does the following:

  1. Detect the presence of a single-frame continuation object as "next
     PCB continuation", so set 'pcb->next_k' to the next field in K_3,
     *note machinery continuations non: fig:MCN_callcc_next_k_K3.

          |-----|---| PCB
                  |
            next_k|   |-----|-| K_1
                  |          |
                  |      next -->|-----|-| K_2
                  |                     |
                  |                 next ----->|
                   --> NULL                    |-----|-| K_3
                                                      |
                                                  next -----> NULL

     Figure 16.31: Continuation object K_3 removed from the PCB.

  2. Duplicate the stack frame referenced by K_3 below the address of
     the underflow handler, adjust the FPR to reference the return
     address of the frame, *note machinery continuations non:
     fig:MCN_callcc_K3_copy.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |                        freezed
          |----------------------|                     -- frames
          |  return addr to top  |                     .  in K_3
          |----------------------|                     --
          |    argument A == 1   |                     .
          |----------------------|                     . frames
          | return addr to alpha |                     . in K_2
          |----------------------|                     --
          |    argument B == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to beta  | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler |
          |----------------------|
          |  return addr to top  | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.32: Stack frame in K_3 duplicated below the underflow
     handler address.

  3. There is a single return value, so: perform a 'ret' Assembly
     instruction to go back to the top level expression.

   The code of the top level expression is reentered right after the
call to 'alpha' and the FPR is adjusted to reference the address of the
stack underflow handler, *note compiler machinery continuations escape:
fig:MCN_callcc_top_ret.  The top level expression is the last one in the
program, so it returns the return value it receives, which is already in
the AAR: it executes a 'ret' Assembly instruction.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |                        freezed
     |----------------------|                     -- frames
     |  return addr to top  |                     .  in K_3
     |----------------------|                     --
     |    argument A == 1   |                     .
     |----------------------|                     . frames
     | return addr to alpha |                     . in K_2
     |----------------------|                     --
     |    argument B == 1   |                     . freezed
     |----------------------|                     . frame
     | return addr to beta  | <- pcb->frame_base  . in K_1
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.33: Stack right before the top level expression executes the
'ret' Assembly instruction; the return value is in the AAR.

   The underflow handler is reentered again with 'NULL' as "next PCB
continuation": this means the program is terminated, so the underflow
handler does what is needed.

   ---------- Footnotes ----------

   (1) Springer and Friedman call it "receiver" in their "Scheme and the
Art of Programming", The MIT Press, 1989.


File: vicare-scheme.info,  Node: machinery continuations escape,  Prev: machinery continuations non,  Up: machinery continuations

16.5.5 Subordinate function calls with invoked continuation
-----------------------------------------------------------

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.  Let's consider the following program that
creates a continuation and invokes its escape function:

     (import (rnrs))
     (define (alpha A)
       (call/cc
          (lambda (escape)
            (beta escape A))))
     (define (beta escape B)
       (escape (+ B 2)))
     (alpha 1)

we can understand how the stack grows until right after the call to
'call/cc' but before 'call/cc' actually does something, *note machinery
continuations escape: fig:MCE_callcc_begin.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler |
     |----------------------|         --
     |  return addr to top  |         . frame of toplevel
     |----------------------|         --
     |    argument A == 1   |         .
     |----------------------|         . frame of alpha
     | return addr to alpha |         .
     |----------------------|         --
     |      receiver        |         . locals of call/cc
     |----------------------|         .
     |                      |
            low memory

Figure 16.34: Stack right after the call to 'call/cc' but before
'call/cc' does something.

   'call/cc' creates a continuation object by freezing the call frames
currently on the stack between FPR and 2 words below 'pcb->frame_base',
*note machinery continuations escape: fig:MCE_callcc_freezing.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler |
     |----------------------|         --
     |  return addr to top  |         .
     |----------------------|         . freezed
     |    argument A == 1   |         . frames
     |----------------------|         .
     | return addr to alpha | <- FPR  .
     |----------------------|         --
     |       receiver       |         . locals of
     |----------------------|         . call/cc
     |                      |
            low memory

Figure 16.35: Region of stack freezed by 'call/cc'.

   The continuation object references the array of freezed words on the
stack, keeping a reference to the value of FPR at creation time.  The
continuation object is also a node in a simply linked list of
continuation objects, whose head is stored in a field of the PCB:
'pcb->next_k'.  In more detail 'call/cc' does the following:

  1. Create the continuation object and prepend it to the list in
     'pcb->next_k'; let's call this continuation object K_1; *note
     machinery continuations escape: fig:MCE_callcc_next_k_K1.

          |--------|---| PCB
                     |
               next_k --------> |-----|-| K_1
                                       |
                                   next -----> NULL

     Figure 16.36: Continuation object K_1 inserted as new "next PCB
     continuation".

  2. Create a closure object implementing the escape function associated
     to the continuation object, the one that will be bound to ESCAPE in
     the example; *note machinery continuations escape:
     fig:MCE_callcc_K1_escape.  In the closure object: the address of
     the code entry point references the special subroutine
     'SL_continuation_code', the single slot for free variables
     references the continuation object.

          |-----|-----| closure object
             |     |
             |      --------> |------| K_1
             |
              --------------> |------| code object

     Figure 16.37: Closure object implementing the escape function for
     K_1.

  3. Prepare the application of the receiver closure to the escape
     function: the reference to the receiver closure is moved in the
     CPR; the address of the underflow handler is moved on the stack and
     the FPR is set to reference it; the value of 'pcb->frame_base' is
     set to exclude the freezed frames from the stack segment; *note
     machinery continuations escape: fig:MCE_callcc_before_receiver.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     --
          |  return addr to top  |                     .
          |----------------------|                     . freezed
          |    argument A == 1   |                     . frames
          |----------------------|                     . in K_1
          | return addr to alpha | <- pcb->frame_base  .
          |----------------------|                     --
          | ik_underflow_handler | <- FPR
          |----------------------|                     -- locals of
          |    escape closure    |                     .  receiver
          |----------------------|                     .  closure
          |                      |
                 low memory


     Figure 16.38: Stack right before the call to the receiver closure.

  4. Perform a direct jump to the entry point of the receiver closure
     without pushing a return address on the stack.  The FPR is left
     referencing the entry point of the stack underflow handler.

   In this example, the receiver closure calls 'beta' with 2 arguments,
*note machinery continuations escape: fig:MCE_callcc_enter_beta.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     --
     |  return addr to top  |                     .
     |----------------------|                     . freezed
     |    argument A == 1   |                     . frames
     |----------------------|                     . in K_1
     | return addr to alpha | <- pcb->frame_base  .
     |----------------------|                     --
     | ik_underflow_handler |
     |----------------------|                     -- frame of
     | return addr to receiv| <- FPR              .  receiver
     |----------------------|                     --
     |    escape closure    |                     . locals
     |----------------------|                     . in beta
     |    argument B == 1   |                     .
     |----------------------|                     .
     |                      |
            low memory

Figure 16.39: Stack right after the call to 'beta'.

   'beta' applies the escape closure to the result of '(+ B 2)', let's
skip the details of performing the addition.  To apply the escape
closure to the single argument representing the addition: the reference
to escape function is copied in the CPR, the single argument is placed
after an empty machine word, the FPR is moved right above the empty
word, finally a 'call' Assembly instruction is executed, *note machinery
continuations escape: fig:MCE_callcc_enter_escape.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     --
     |  return addr to top  |                     .
     |----------------------|                     . freezed
     |    argument A == 1   |                     . frames
     |----------------------|                     . in K_1
     | return addr to alpha | <- pcb->frame_base  .
     |----------------------|                     --
     | ik_underflow_handler |
     |----------------------|                     -- frame of
     | return addr to receiv| <- FPR              .  receiver
     |----------------------|                     --
     |    escape closure    |                     .
     |----------------------|                     .  frame
     |    argument B == 1   |                     .  of beta
     |----------------------|                     .
     | return addr to beta  | <- FPR              .
     |----------------------|                     --
     |   argument fixnum 3  |                     . locals of
     |----------------------|                     . escape
     |                      |
            low memory

Figure 16.40: Stack right after the call to 'escape'.

   A continuation's escape function is a special subroutine that throws
away all the stack frames up to, and excluding, the undeflow handler
address below the 'pcb->frame_base', *note machinery continuations
escape: fig:MCE_callcc_throw_away.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     --
     |  return addr to top  |                     .
     |----------------------|                     . freezed
     |    argument A == 1   |                     . frames
     |----------------------|                     . in K_1
     | return addr to alpha | <- pcb->frame_base  .
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.41: Stack right after 'escape' has thrown away the useless
stack frames.

   The argument of the escape function becomes its return value; in this
example there is a single return value, so it is moved in the AAR.  The
continuation object K_1 in the escape closure is stored in
'pcb->next_k', becoming the "next PCB continuation"; the old value of
'pcb->next_k' is simply overwritten: a new list of continuations is
installed in the PCB.  Finally a 'ret' Assembly instruction is executed.

   The FPR references the underflow handler, so the 'ret' instruction
will cause the execution flow to jump there; the stack underflow handler
does the following:

  1. Detect the presence of a multiframe continuation object as "next
     PCB continuation", so split K_1 in two continuation objects: the
     mutated K_1 referencing only the frame of 'alpha' and a new
     continuation object K_2 referencing all the other frames, *note
     machinery continuations escape: fig:MCE_callcc_K2_frames.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     -- freezed
          |  return addr to top  |                     .  frame K_2
          |----------------------|                     --
          |    argument A == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to alpha | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.42: Continuation object K_1 mutated to reference a single
     frame.

  2. Insert K_2 in the linked list of continuation objects after K_1 and
     register it as the new "next PCB continuation", *note machinery
     continuations escape: fig:MCE_callcc_next_k_K2.

          |--------|---| PCB
                     |
               next_k|     |-----|-| K_1
                     |            |
                     |        next -->|
                      --------------->|-----|-| K_2
                                             |
                                         next -----> NULL

     Figure 16.43: Continuation object K_2 inserted as new "next
     continuation".

  3. Duplicate the stack frame referenced by K_1 below the address of
     the underflow handler, adjust the FPR to reference the return
     address of the frame, *note machinery continuations escape:
     fig:MCE_callcc_K1_copy.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     -- freezed
          |  return addr to top  |                     .  frame K_2
          |----------------------|                     --
          |    argument A == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to alpha | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler |
          |----------------------|
          |    argument A == 1   |
          |----------------------|
          | return addr to alpha | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.44: Stack frame in K_1 duplicated below the underflow
     handler address.

  4. There is a single return value, so: perform a 'ret' Assembly
     instruction to go back to the body of 'alpha'.

   The code of 'alpha' is reentered right after the call to 'call/cc'
and the FPR is adjusted to reference the address of the stack underflow
handler, *note compiler machinery continuations escape:
fig:MCE_callcc_alpha_ret.  'alpha' must return the same return value,
which is already in the AAR: it executes a 'ret' Assembly instruction.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     -- freezed
     |  return addr to top  |                     .  frame K_2
     |----------------------|                     --
     |    argument A == 1   |                     . freezed
     |----------------------|                     . frame
     | return addr to alpha | <- pcb->frame_base  . in K_1
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.45: Stack right before 'alpha' executes the 'ret' Assembly
instruction; the return value is in the AAR.

   The stack underflow handler is reentered and does the following:

  1. Detect the presence of a single-frame continuation object K_2 as
     "next PCB continuation", so store its next continuation reference
     in 'pcb->next_k', *note machinery continuations escape:
     fig:MCE_callcc_next_k_K2.

          |-----|---| PCB
                  |
            next_k|   |-----|-| K_1
                  |          |
                  |      next -->|-----|-| K_2
                  |                     |
                  |                 next -----> NULL
                   --> NULL

     Figure 16.46: Continuation object K_2 removed from the PCB.

  2. Duplicate the stack frame referenced by K_2 below the address of
     the underflow handler, adjust the FPR to reference the return
     address of the frame, *note machinery continuations escape:
     fig:MCE_callcc_K2_copy.

                high memory
          |                      |
          |----------------------|
          | ik_underflow_handler |
          |----------------------|                     -- freezed
          |  return addr to top  |                     .  frame K_2
          |----------------------|                     --
          |    argument A == 1   |                     . freezed
          |----------------------|                     . frame
          | return addr to alpha | <- pcb->frame_base  . in K_1
          |----------------------|                     --
          | ik_underflow_handler |
          |----------------------|
          |  return addr to top  | <- FPR
          |----------------------|
          |                      |
                 low memory

     Figure 16.47: Stack frame in K_2 duplicated below the underflow
     handler address.

  3. There is a single return value, so: perform a 'ret' Assembly
     instruction to go back to the top level expression.

   The code of the top level expression is reentered right after the
call to 'alpha' and the FPR is adjusted to reference the address of the
stack underflow handler, *note compiler machinery continuations escape:
fig:MCE_callcc_top_ret.  The top level expression is the last one in the
program, so it returns the return value it receives, which is already in
the AAR: it executes a 'ret' Assembly instruction.

           high memory
     |                      |
     |----------------------|
     | ik_underflow_handler |
     |----------------------|                     -- freezed
     |  return addr to top  |                     .  frame K_2
     |----------------------|                     --
     |    argument A == 1   |                     . freezed
     |----------------------|                     . frame
     | return addr to alpha | <- pcb->frame_base  . in K_1
     |----------------------|                     --
     | ik_underflow_handler | <- FPR
     |----------------------|
     |                      |
            low memory

Figure 16.48: Stack right before the top level expression executes the
'ret' Assembly instruction; the return value is in the AAR.

   The underflow handler is reentered again with 'NULL' as "next PCB
continuation": this means the program is terminated, so the underflow
handler does what is needed.

   We can understand that this mechanism of duplicating the freezed
frames can be repeated any number of times, allowing the execution flow
to go back to a saved continuation any number of times.


File: vicare-scheme.info,  Node: machinery stack overflow,  Next: machinery call arguments,  Prev: machinery continuations,  Up: machinery

16.6 Scheme stack overflow
==========================

Let's recall how the Scheme stack segment looks, *note machinery stack
overflow: fig:MSO_stack_boundary.  Function call frames are put on the
stack starting from high memory addresses, stack usage grows towards low
memory addresses; at some point the stack runs out of space.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|                        --
     | ik_underflow_handler |                        .
     |----------------------|                        .
                .                                    .
                .                                    .
                .                                    .
     |----------------------|                        .
     |                      | <- pcb->frame_redline  . stack
     |----------------------|                        . segment
                .                                    . size
                .                                    .
                .                                    .
     |----------------------|                        .
     |                      | <- pcb->stack_base     .
     |----------------------|                        --
     |                      |
            low memory

Figure 16.49: Stack boundaries as represented by the PCB.

   To detect stack usage approaching the end of available stack space:
the PCB contains a field referencing a machine word 2 memory chunks
(4096 bytes each) above the lower boundary; whenever stack usage crosses
this "red line": a new stack segment needs to be allocated and call
frames must be put on the new stack; *note machinery stack overflow:
fig:MSO_redline_crossed.

           high memory
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler |
     |----------------------|
                .
                .
                .
     |----------------------|                        --
     |     local value      |                        .
     |----------------------|                        .
     |     local value      | <- pcb->frame_redline  .
     |----------------------|                        . framesize
     |     local value      |                        .
     |----------------------|                        .
     |    return address    | <- FPR                 .
     |----------------------|                        --
     |   function argument  |
     |----------------------|
     |   function argument  |
     |----------------------|
                .
                .
                .
     |----------------------|
     |                      | <- pcb->stack_base
     |----------------------|
     |                      |
           low memory

Figure 16.50: Scenario on the Scheme stack that triggers the stack
overflow; we see that: FPR < 'pcb->frame_redline'.

   Scheme functions can be partitioned in: those that may use more stack
space, those that do not; Vicare recognises this partition and inserts a
stack overflow check at the beginning of each of the former.  The
pseudo-Assembly performing the check is as follows:

     (label function_entry_point)
       (cmpl FPR pcb->frame_redline)
       (jb L0)

     (label L1)
       ... the function body ...
       (ret)

     (label L0)
       (forcall "ik_stack_overflow")
       (jmp L1)

   When stack overflow happens the C function 'ik_stack_overflow()' is
called through the 'forcall' primitive instruction and the Assembly
subroutine 'ik_foreign_call'; 'forcall' creates a new stack frame and
then calls 'ik_foreign_call' which in turn calls the C function, *note
machinery stack overflow: fig:MSO_forcall_frame.

           high memory
     |                      |
     |----------------------|                        --
     |     local value      |                        .
     |----------------------|                        .
     |     local value      | <- pcb->frame_redline  .
     |----------------------|                        . framesize
     |     local value      |                        .
     |----------------------|                        .
     |    return address    |                        .
     |----------------------|                        --
     |   function argument  |                        .
     |----------------------|                        . frame of
     |   function argument  |                        . forcall
     |----------------------|                        .
     |    return address    | <- FPR                 .
     |----------------------|                        --
     |                      |
           low memory

Figure 16.51: Call frame of 'forcall' on top of the call frame that
caused the stack underflow.

   'ik_stack_overflow()' does the following:

  1. Freeze all the call frames on the stack in a continuation object;
     prepend such object to the list of continuations in the PCB, so
     that it becomes the "next PCB continuation".

  2. Allocate and initialise a new stack segment and register it in the
     PCB.  The frame pointer is set to reference the first machine word
     on the stack, which contains the address of the underflow handler.

  3. For garbage collection purposes: reconfigure old stack segment's
     memory block as data segment.

   Upon returning to the caller 'ik_foreign_call' performs a 'ret'
Assembly instruction with the FPR referencing the underflow handler; so
returning from a stack reallocation is exactly like returning to the
next PCB continuation.


File: vicare-scheme.info,  Node: machinery call arguments,  Next: machinery call retvals,  Prev: machinery stack overflow,  Up: machinery

16.7 Function call arguments
============================

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.


File: vicare-scheme.info,  Node: machinery call retvals,  Next: machinery tail calls,  Prev: machinery call arguments,  Up: machinery

16.8 Function call return values
================================

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.


File: vicare-scheme.info,  Node: machinery tail calls,  Next: machinery locals,  Prev: machinery call retvals,  Up: machinery

16.9 Tail calls implementation
==============================

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, with the exception that we allow the
compiler to perform tail calls optimisation (TCO), *note Simplification
assumptions: machinery simplifications.


File: vicare-scheme.info,  Node: machinery locals,  Prev: machinery tail calls,  Up: machinery

16.10 Local variables
=====================

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.

   Local variables are put on the Scheme stack in such a way that the
stack frame can be left immutable if it is freezed in a Scheme
continuation object.  Immutable local variables and mutable local
variables, before the first mutation, are just put in machine words on
the stack frame; mutable local variables after the first mutation are
put in the single slot of a Scheme vector whose reference is put on the
stack.

Immutable local variables only
..............................

Let's consider the following program in which the function 'one' has
only immutable local variables:

     (import (rnrs))
     (define (one A B)
       (let ((C 3)
             (D 4))
         (list A B C D)))
     (one 1 2)

right after the call to 'one' the arguments are on the stack below the
return address, *note machinery locals: fig:ML_arguments_on_stack.

           high memory
     |                      |
     |----------------------|         --
                 .                    .
                 .                    . caller
                 .                    . stack frame
     |----------------------|         .
     |    return address    | <- FPR  .
     |----------------------|         --
     |    argument A == 1   |         .
     |----------------------|         . stack frame
     |    argument B == 2   |         . of ONE
     |----------------------|         .
     |                      |
            low memory

Figure 16.52: Stack frame with arguments.

   Then the local values are put on the stack, right below the
arguments, *note machinery locals: fig:ML_locals_on_stack.

           high memory
     |                      |
     |----------------------|                      --
                 .                                 .
                 .                                 . caller
                 .                                 . stack frame
     |----------------------|                      .
     |    return address    | <- FPR               .
     |----------------------|                      --
     |    argument A == 1   | <- FPR - 1*wordsize  .
     |----------------------|                      .
     |    argument B == 2   | <- FPR - 2*wordsize  .
     |----------------------|                      . stack frame
     |       local C == 3   | <- FPR - 3*wordsize  . of ONE
     |----------------------|                      .
     |       local D == 4   | <- FPR - 4*wordsize  .
     |----------------------|                      .
     |                      |
            low memory

Figure 16.53: Stack frame with arguments and local variables.

   We can imagine the function 'one' compiled to pseudo-code as follows:

     (define (one stack-slot-1 stack-slot-2)
       (let-on-stack ((stack-slot-3 3)
                      (stack-slot-4 4))
         (list stack-slot-1
               stack-slot-2
               stack-slot-3
               stack-slot-4)))

if the Assembly code needs to copy the value of the local variable
'stack-slot-3' into the CPU register AAR, it just does it as stack
memory access:

     (movl (disp (* -3 wordsize) FPR) AAR)

   If a continuation object is created with this scenario on the stack:
everything is ready, because the stack frame never needs to be mutated.

Mutable local variables
.......................

Let's consider the following program in which the function 'one' has
both an immutable local variable and a mutable one:

     (import (rnrs))
     (define (one A B)
       (let ((C 3)
             (D 4))
         (display (list A B C D))
         (set! D 41)
         (display (list A B C D))
         (set! D 42)
         (display (list A B C D))))
     (one 1 2)

after the call to 'one' the arguments and the local variables are put on
the stack below the return address, *note compiler machinery locals:
fig:ML_before_mutation.

           high memory
     |                      |
     |----------------------|                      --
                 .                                 .
                 .                                 . caller
                 .                                 . stack frame
     |----------------------|                      .
     |    return address    | <- FPR               .
     |----------------------|                      --
     |    argument A == 1   | <- FPR - 1*wordsize  .
     |----------------------|                      .
     |    argument B == 2   | <- FPR - 2*wordsize  .
     |----------------------|                      . stack frame
     |       local C == 3   | <- FPR - 3*wordsize  . of ONE
     |----------------------|                      .
     |       local D == 4   | <- FPR - 4*wordsize  .
     |----------------------|                      .
     |                      |
            low memory

Figure 16.54: Stack frame with arguments and local variables before the
first local variable mutation.

   Before the first local variable mutation (the 'set!' form): if the
Assembly code needs to copy the value of the local variable
'stack-slot-4' into the CPU register AAR, it just does it as stack
memory access:

     (movl (disp (* -3 wordsize) FPR) AAR)

because the value is just there.  If a continuation object is created
with this scenario on the stack: everything is ready, because the stack
frame never needs to be mutated.

   When the mutable local variable is assigned: something has to change.
We can imagine the function 'one' compiled to pseudo-code as follows:

     (define (one stack-slot-1 stack-slot-2)
       (let-on-stack ((stack-slot-3 3)
                      (stack-slot-4 4))
         (display (list stack-slot-1
                        stack-slot-2
                        stack-slot-3
                        stack-slot-4))
         (set! stack-slot-4 (vector 41))
         (display (list stack-slot-1
                        stack-slot-2
                        stack-slot-3
                        ($vector-ref stack-slot-4 0)))
         ($vector-set! stack-slot-4 0 42)
         (display (list stack-slot-1
                        stack-slot-2
                        stack-slot-3
                        ($vector-ref stack-slot-4 0)))))

whenever the local variable assignment happens: a Scheme vector is
allocated on the heap and filled with the new variable's value; then a
reference to such object is stored in the stack slot reserved to the
local variable.  From this point onwards: access to the local variable
happens through the primitive operations '$vector-ref' and
'$vector-set!'.

   If a continuation object is created after the local variable first
mutation: everything is ready, the stack frame does not need to be
mutated because the mutable location is in the Scheme vector.

Mutable arguments
.................

Mutable argument bindings are handled in the same way of mutable local
variables.  Let's consider the following program in which the function
'one' has a mutable argument:

     (import (rnrs))
     (define (one A)
       (display A)
       (set! A 2)
       (display A)
       (set! A 3)
       (display A))
     (one 1)

We can imagine the function 'one' compiled to pseudo-code as follows:

     (define (one stack-slot-1)
       (display stack-slot-1)
       (set! stack-slot-1 (vector 2))
       (display ($vector-ref stack-slot-1 0))
       ($vector-set! stack-slot-1 0 3)
       (display ($vector-ref stack-slot-1 0))


File: vicare-scheme.info,  Node: compiler,  Next: boot image,  Prev: machinery,  Up: Top

17 Low level interface to the compiler
**************************************

Vicare is a compiler for the Scheme language; internally it implements a
multitude of passes, each of which performing a transformation step from
Scheme code to executable binary code.  The library '(vicare compiler)'
exports one binding for each compiler pass, allowing inspection of the
performed transformations.

   This section contains some documentation for each pass; however, it
is almost impossible to truly understand what a pass does without
reading the source code, where additional documentation is present in
the form of comments.

* Menu:

* compiler intro::              Introduction to the compilation process.
* compiler conv::               Compiler coding conventions.
* compiler topics::             Inspection by topics.
* compiler options::            Initialisation and general configuration
                                options.
* compiler sysval::             System values bound to core primitive names.
* compiler unparse::            Unparsing intermediate representations.

Compiler passes

* compiler full::               The full transformation.
* compiler recordize::          Scheme code to nested structs.
* compiler dircalls::           Optimisation for direct calls.
* compiler letrec::             Optimisation of 'letrec' and 'letrec*'
                                forms.
* compiler optimisation::       Source optimisation.
* compiler refassig::           Rewriting references and assignments.
* compiler type inference::     Core type inference.
* compiler unsafe primrefs::    Safe to unsafe core primitive applications.
* compiler sanitise bindings::  Sanitising bindings.
* compiler direct jumps::       Optimisation for direct jumps.
* compiler global assign::      Inserting global assignments.
* compiler vars::               Introducing storage locations.
* compiler closure makers::     Introducing closure makers.
* compiler lifting::            Closures optimization and 'clambda'
                                lifting.
* compiler primopcalls::        Introducing primitive operation calls.
* compiler freevar refs::       Rewriting references to free variables.
* compiler engine::             Inserting engine checks.
* compiler stack::              Inserting stack overflow checks.
* compiler cogen::              Full assembly code generation.
* compiler assember::           Binary code generation.


File: vicare-scheme.info,  Node: compiler intro,  Next: compiler conv,  Up: compiler

17.1 Introduction to the compilation process
============================================

An expression in the core language is Scheme code fully expanded in
which: no syntactic bindings are present; all the lexical bindings have
a unique name represented by a lex gensym; all the top level lexical
bindings are associated to a loc gensym used to hold the binding's
current value.  The compiler is used to process:

   * Full 'library' forms and full R6RS programs the expander has
     transformed into 'library-letrec*' core language forms.

   * Standalone expressions from invocations of R6RS's 'eval', for
     example read by the REPL, either in the context of a stateless
     environment or in the context of a stateful interactive
     environment.

these symbolic expressions must be compiled after correct initialisation
of location gensyms for:

   * All the lexical bindings defined by the boot image.

   * All the lexical bindings defined by the imported libraries.

   * All the bindings previously defined in the stateful interactive
     environment, if such was used for the expansion process.

   The compiler recognises the following core language forms, whose
semantics is similar to the corresponding standard language syntax:

     (library-letrec* ((?LHS ?LOC ?RHS) ...) ?BODY)
     (quote ?DATUM)
     (if ?TEST ?CONSEQUENT ?ALTERNATE)
     (set! ?LHS ?RHS)
     (begin ?BODY0 ?BODY ...)
     (let     ((?LHS ?RHS) ...) ?BODY)
     (letrec  ((?LHS ?RHS) ...) ?BODY)
     (letrec* ((?LHS ?RHS) ...) ?BODY)
     (case-lambda (?FORMALS ?BODY) ...)
     (annotated-case-lambda ?ANNOTATION (?FORMALS ?BODY) ...)
     (lambda ?FORMALS ?BODY)
     (foreign-call "?FUNCTION-NAME" ?ARG ...)
     (primitive ?PRIM)
     (annotated-call ?ANNOTATION ?FUN ?ARG ...)
     ?LEX
     (?FUNC ?ARG ...)
     (typed-expr ?EXPR ?CORE-TYPE-NAME)

where: a standalone ?LEX atom is a lex gensym, interpreted as reference
to binding; ?LHS stands for "left-hand side" and it is a lex gensym;
?RHS stands for "right-hand side"; ?LOC is a loc gensym; ?PRIM is a
symbol representing the public name of a core lexical primitive.


File: vicare-scheme.info,  Node: compiler conv,  Next: compiler topics,  Prev: compiler intro,  Up: compiler

17.2 Compiler coding conventions
================================

Throughout the compiler code variables with the following names appear:

OP
     Scheme symbol representing an *operation* to be directly translated
     into assembly.  Examples: 'alloc', 'mref', 'mref32', 'bref',
     'logand', 'logxor', 'logor', 'int+', 'int-', 'int*',
     'int-quotient', 'int-remainder', 'sll', 'sra'.

RATOR
     Represents a reference to an *operator*: a function coded in
     assembly or C language.

RANDS
     Scheme list holding the *operands* to which an operation must be
     applied.  These operands are in such a format that can be directly
     used in the assembly S-expression like:

          (make-set eax (car rands))

     which generates an assignment operation to store the first element
     of RANDS into the 'eax' processor register.


File: vicare-scheme.info,  Node: compiler topics,  Next: compiler options,  Prev: compiler conv,  Up: compiler

17.3 By topic inspection of behaviour
=====================================

It is useful to inspect how the compiler handles specific code elements
throughout different passes.

* Menu:

* compiler topics topbind::     Handling of lexical top level bindings.
* compiler topics locbind::     Handling of lexical local bindings.
* compiler topics clambda::     Handling of lambda expressions.


File: vicare-scheme.info,  Node: compiler topics topbind,  Next: compiler topics locbind,  Up: compiler topics

17.3.1 Handling of lexical top level bindings
---------------------------------------------

Core language representation
............................

Bindings defined by the core language form 'library-letrec*' are named
"top level bindings"; they are akin to the C language "global
variables".  The form 'library-letrec*' has the format:

     (library-letrec* ((?LEX ?LOC ?INIT) ...) ?BODY)

in which: ?LEX is a lexical gensym that uniquely identifies the binding
in the core language form; ?LOC is a location gensym which will be used
at run-time to hold the current value of the binding in its 'value'
slot; ?INIT is the initialisation expression.

   References to top level bindings are represented by standalone ?LEX
gensyms; assignments to top level bindings are represented by 'set!'
forms:

     (set! ?LEX ?RHS)

where the right-hand side expression ?RHS will, at run-time, evaluate to
the new binding's value.

Recordised language representation
..................................

The 'library-letrec*' form is recordised into a 'rec*bind' form:

     (rec*bind ((?PREL ?INIT) ...) ?BODY)

in which ?PREL is a 'prelex' struct holding both the ?LEX and ?LOC
gensyms.  References to top level bindings are represented by standalone
'prelex' structs; assignments to top level bindings are represented by
'assign' structs:

     (assign ?PREL ?RHS)

Implementation of references and assignments
............................................

Since the actual value of a top level binding is stored in the 'value'
field of a loc gensym:

   * References to top level bindings must be transformed into:

          (funcall (primref $symbol-value) (constant ?LOC))

     which extracts the value from slot 'value' of ?LOC.

   * Common assignments to top level bindings must be transformed into:

          (funcall (primref $set-symbol-value!)
                   (constant ?LOC)
                   ?RHS)

     which stores a new value in the slot 'value' of ?LOC.

   * Single assignments to top level bindings which also serve as
     binding initialisations must be transformed into:

          (funcall (primref $init-symbol-value!)
                   (constant ?LOC)
                   ?RHS)

     which stores a new value in the slot 'value' of ?LOC and, only if
     the value is recognised at run-time as being closure object, also
     stores value in the slot 'proc'.

Results of optimising 'rec*bind' forms
......................................

A compiler pass takes care of performing "'letrec' optimisation":
structs of type 'rec*bind' are transformed into a nested hierarchy of
'bind', 'fix' and 'assign' forms.  Different cases must be handled in
different ways.

   * Some non-recursive "simple" and unassigned bindings end up defined
     as follows:

          (bind ((?PREL ?INIT))
            ?BODY)

     the transformation of references is straightforward.  As example,
     let's consider:

          (library-letrec*
              ((a.lex a.loc '1)
               (b.lex b.loc '2))
            ((primitive display) a.lex b.lex))

     which is recordised and transformed into:

          (bind ((a.lex_0 (constant 1)))
            (bind ((b.lex_0 (constant 2)))
              (funcall (primref display) (constant 1) (constant 2))))

     in which the references to bindings are integrated by the source
     optimiser.

   * Some non-recursive "simple" and assigned bindings end up defined as
     follows:

          (bind ((?PREL ?INIT))
            ?BODY)

     the transformation of references and assignments is
     straightforward.  As example, let's consider:

          (library-letrec*
              ((a.lex a.loc '1)
               (b.lex b.loc '2))
            (begin
              (set! a.lex '11)
              (set! b.lex '22)
              ((primitive display) a.lex b.lex)))

     which is recordised and transformed into:

          (bind ((a.lex_0 (constant 1)))
            (bind ((b.lex_0 (constant 2)))
              (seq
                (funcall (primref $set-symbol-value!)
                         (constant a.loc)
                         (constant 11))
                (funcall (primref $set-symbol-value!)
                         (constant b.loc)
                         (constant 22))
                (funcall (primref display)
                         (funcall (primref $symbol-value)
                                  (constant a.loc))
                         (funcall (primref $symbol-value)
                                  (constant b.loc))))))

   * Some *unassigned* top level bindings end up defined (roughly) as
     follows:

          (bind ((?PREL (constant #<void>)))
            (assign ?PREL ?INIT)
            ?BODY)

     this might happen when the initialisation expressions in the
     original 'rec*bind' need to access the machine words in which the
     bindings' values are stored; so, at run-time, first we need to
     allocate the loc gensyms and then we can evaluate the
     initialisation expressions and store the resulting value in the
     gensym itself.

     In this special case, since the binding is unassigned in the
     original code, the 'assign' struct is introduced by the compiler
     and it is the only assignment for the binding.  The compiler
     recognises this case and transforms:

          (assign ?PREL ?INIT)

     into:

          (funcall (primref $init-symbol-value!)
                   (constant ?LOC)
                   ?INIT)

     in which ?LOC is the loc gensym of the binding.

   * When top level bindings are unassigned and have initialisation
     expression being a 'clambda' form: they end up being defined by a
     'fix' struct; the 'letrec' optimiser takes care of recognising and
     handling such case.  As example:

          (library-letrec*
              ((a.lex a.loc (lambda () '1))
               (b.lex a.loc (lambda () '2)))
            ((primitive display) (a.lex)))

     is transformed into:

          (fix ((a.lex_0 (lambda () (constant 1)))
                (b.lex_0 (lambda () (constant 2))))
            (funcall (primref display) (constant 1)))

     in which the call to 'a.lex' is integrated by the source optimiser.


File: vicare-scheme.info,  Node: compiler topics locbind,  Next: compiler topics clambda,  Prev: compiler topics topbind,  Up: compiler topics

17.3.2 Handling of lexical local bindings
-----------------------------------------

Lexical local bindings are defined in the core language by the forms:
'let', 'letrec', 'letrec*', 'lambda', 'case-lambda',
'annotated-case-lambda'.  These forms have syntax:

     (let     ((?LEX ?RHS) ...) ?BODY)
     (letrec  ((?LEX ?RHS) ...) ?BODY)
     (letrec* ((?LEX ?RHS) ...) ?BODY)
     (case-lambda (?FORMALS ?BODY) ...)
     (annotated-case-lambda ?ANNOTATION (?FORMALS ?BODY) ...)
     (lambda ?FORMALS ?BODY)

in which: ?LEX is a lexical gensym that uniquely identifies the binding
in the core language form; ?RHS is the initialisation expression;
?FORMALS is a proper or improper list of lex gensyms uniquely
identifying arguments to function.

   References to local bindings are represented by standalone ?LEX
gensyms; assignments to local bindings are represented by 'set!' forms:

     (set! ?LEX ?RHS)

where the right-hand side expression ?RHS will, at run-time, evaluate to
the new binding's value.

Recordised language representation
..................................

The 'let', 'letrec' and 'letrec*' forms are recordised into nested
hierarchies of 'bind', 'recbind' and 'rec*bind' structs:

     (bind     ((?PREL ?RHS) ...) ?BODY)
     (recbind  ((?PREL ?RHS) ...) ?BODY)
     (rec*bind ((?PREL ?RHS) ...) ?BODY)

in which ?PREL is a 'prelex' struct holding the ?LEX gensym.

   The 'lambda', 'case-lambda' and 'annotated-case-lambda' forms are
recordised as 'clambda' structs:

     (clambda (?PREL-FORMALS ?BODY) ...)

in which ?PREL-FORMALS is a a proper or improper list of 'prel' structs
representing arguments to each 'clambda' clause.

   References to local bindings are represented by standalone 'prelex'
structs; assignments to local bindings are represented by 'assign'
structs:

     (assign ?PREL ?RHS)

Implementation of references and assignments
............................................

We distinguish between bindings that are only referenced (unassigned,
read-only) and bindings that are also assigned (assigned, read-write).
Example of code in which the binding 'X' is only referenced:

     (let ((X 123)) (display X))

example of code in which the binding 'X' is assigned and referenced:

     (let ((X 123)) (set! X 456) (display X))

   The implementation technique for continuations used by Vicare
mandates that: once an immediate Scheme object or reference to
non-immediate Scheme object is stored in a machine word on the Scheme
stack, such machine word *must not be mutated*; this allows the run-time
system to copy stack frames at will.  As a consequence the following
implementation techniques for local bindings are adopted:

   * The value of unassigned lexical local bindings is stored in words
     allocated on the Scheme stack, with no further troubles.

   * The value of assigned lexical local bindings is stored in
     single-slot vectors providing mutable memory locations: a vector of
     one slot for each binding; a word allocated on the Scheme stack
     contains a reference to the single-slot vector.

   References to unassigned bindings must be implemented as Scheme stack
operations; references and assignments to assigned bindings must be
substituted with appropriate vector operations.

Recordisation and transformation of unassigned bindings
.......................................................

After the 'letrec' optimiser has processed 'recbind' and 'rec*bind'
forms, unassigned local bindings always end up defined as:

     (bind ((?PREL ?RHS)) ?BODY)

and references are represented by standalone 'prelex' structs.  Whenever
a ?RHS expression is recognised to be of type 'clambda', the
corresponding 'bind' is transformed into:

     (fix ((?PREL ?RHS)) ?BODY)

No further transformations are needed for recordised code.

Recordisation and transformation of assigned bindings
.....................................................

After the 'letrec' optimiser has processed 'recbind' and 'rec*bind'
forms, assigned local bindings always end up defined as:

     (bind ((?PREL ?RHS)) ?BODY)

references are represented by standalone 'prelex' structs and
assignments are represented by 'assign' structs.

     *NOTE* No matter if a ?RHS expression is of type 'clambda': its
     associated 'bind' struct is *not* transformed into a 'fix' struct;
     only unassigned 'clambda' bindings can be defined by a 'fix'
     struct.

   Definitions, references and assignments are transformed by
introducing the appropriate vector operations; such operation are
equivalent to the following:

     (let ((x 123))
       (set! x 456)
       x)

is transformed into:

     (let ((t 123))
       (let ((x (vector t)))
         ($vector-set! x 0 456)
         ($vector-ref  x 0)))

where the temporary binding 't' is generated by the compiler; the code
always only access the first and single slot of the vector.  Using
recordised code:

     (bind ((x_0 123))
       (seq
         (assign x_0 456)
         x))

is transformed into:

     (bind ((x_0 123))
       (bind ((x_1 (funcall (primref vector) x_0)))
         (seq
           (funcall (primref $vector-set!)
                    x_1
                    (constant 0)
                    (constant 456))
           (funcall (primref $vector-ref)
                    x_1
                    (constant 0)))))

   Formal bindings in 'clambda' structs are also processed this way; for
example:

     (lambda (a)
       (display a)
       (set! a 1)
       a)

is transformed into:

     (lambda (a_0)
       (bind ((a_1 (funcall (primref vector) a_0)))
         (seq
           (funcall (primref display)
                    (funcall (primref $vector-ref)
                             a_1 (constant 0)))
           (funcall (primref $vector-set!)
                    a_1 (constant 0) (constant 1))
           (funcall (primref $vector-ref)
                    a_1 (constant 0)))))

     *NOTE* Assigned local bindings whose RHS expression is a 'clambda'
     struct are also transformed by introducing a vector.  After this
     transformation: there are no more 'bind' struct whose RHS is a
     'clambda' struct.


File: vicare-scheme.info,  Node: compiler topics clambda,  Prev: compiler topics locbind,  Up: compiler topics

17.3.3 Handling of lambda expressions
-------------------------------------

Handling of assigned 'clambda' bindigns
.......................................

If a binding is assigned, it is defined by a 'bind' struct:

     (bind ((?LHS ?INIT))
       (seq
         (assign ?LHS ?RHS)
         ?REST))

and so it is transformed by introducing a vector to hold the read-write
machine word:

     (bind ((?TMP ?INIT))
       (bind ((?LHS (funcall (primref vector) ?TMP)))
         (seq
           (funcall (primref $vector-set!)
                    ?LHS (constant 0) ?RHS)
           ?REST)))

if its ?INIT expression is a 'clambda' struct, it is further transformed
as follows:

     (fix ((?TMP ?CLAMBDA))
       (bind ((?LHS (funcall (primref vector) ?TMP)))
         (seq
           (funcall (primref $vector-set!)
                    ?LHS (constant 0) ?RHS)
           ?REST)))

so, in the end, 'clambda' expressions originally bound to assigned
bindings end up defined by 'fix' forms.


File: vicare-scheme.info,  Node: compiler options,  Next: compiler sysval,  Prev: compiler topics,  Up: compiler

17.4 Initialisation and general configuration options
=====================================================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: initialise-compiler
     Initialise compiler's internal tables.  It is automatically called
     the first time the compiler is invoked to generate code.

 -- Parameter: generate-descriptive-labels
     When set to true: attempt to generate descriptive pretty names for
     gensyms used by the compiler as lexical gensyms, loc gensyms and
     code labels; this is useful for debugging purposes and code
     generation inspection.  When set to false: attempt to generate
     gensyms in the fastest way.


File: vicare-scheme.info,  Node: compiler sysval,  Next: compiler unparse,  Prev: compiler options,  Up: compiler

17.5 System values bound to core primitive names
================================================

Every core primitive value has a name that is considered part of
Vicare's core language; such primitive name is the actual public name of
the binding exported by the boot image.  The name of the function
'display' is the symbol 'display'; the name of the record-type
descriptor '&condition-rtd' is the symbol '&condition-rtd'.

   The name's property list contains a special entry whose value is the
"storage location gensym" ("loc" for short) of the core primitive value;
we can easily inspect such situation as follows:

     (import (vicare)
       (prefix (vicare compiler) compiler.))

     (compiler.initialise-compiler)

     (getprop 'display (compiler.system-value-gensym))
     => loc.display

     ;; extract the procedure from the loc
     (symbol-value (getprop 'display (compiler.system-value-gensym)))
     => #<procedure display>

     (compiler.system-value 'display)
     => #<procedure display>

     (compiler.system-value '&condition-rtd)
     => #[rtd name=&condition ...]

   We see that the property list contains an entry with key set to the
symbol returned by 'system-value-gensym'; notice that this key is
different every time we rebuild the boot image.

 -- Function: system-value SYMBOL
     Attempt to extract from SYMBOL the core primitive value of which
     SYMBOL is the name; if successful return the Scheme object, else
     raise an assertion violation.

 -- Function: system-value-gensym
     Return special gensym used internally to map core primitive names
     to their value.


File: vicare-scheme.info,  Node: compiler unparse,  Next: compiler full,  Prev: compiler sysval,  Up: compiler

17.6 Unparsing intermediate representations
===========================================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: unparse-recordized-code INPUT
     Given as argument a struct instance representing recordised code:
     build and return a symbolic expression that can be printed in human
     readable form.  INPUT can be any structure that is produced by the
     compiler passes.

 -- Function: unparse-recordized-code/pretty INPUT
     Given as argument a struct instance representing recordised code:
     build and return a symbolic expression that can be printed in human
     readable form.  INPUT can be any structure that is produced by the
     compiler passes.

     This function attempts to unparse recordised code and reconstruct a
     Scheme-like symbolic expression; the returned sexp does *not*
     exactly represent the input.

 -- Function: unparse-recordized-code/sexp INPUT
     Given as argument a struct instance representing recordised code:
     build and return a symbolic expression that can be printed in human
     readable form.  INPUT can be any structure that is produced by the
     compiler passes.  The output of this function is similar to
     'unparse-recordized-code' but more human readable.


File: vicare-scheme.info,  Node: compiler full,  Next: compiler recordize,  Prev: compiler unparse,  Up: compiler

17.7 The full transformation
============================

The sequence of compiler passes is:

     pass-recordize
     pass-optimize-direct-calls
     pass-optimize-letrec
     pass-source-optimize
     pass-rewrite-references-and-assignments
     pass-core-type-inference (optional)
     pass-introduce-unsafe-primrefs (optional)
     pass-sanitize-bindings
     pass-optimize-for-direct-jumps
     pass-insert-global-assignments
     pass-introduce-vars
     pass-introduce-closure-makers
     pass-optimize-combinator-calls/lift-clambdas

the sequence in which the passes are performed *cannot* be changed; they
must be performed in the specified order.  The passes functions are to
be considered unsafe: if the input is invalid, the behaviour is
undefined.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: compile-core-expr->code CORE-LANGUAGE-SEXP


File: vicare-scheme.info,  Node: compiler recordize,  Next: compiler dircalls,  Prev: compiler full,  Up: compiler

17.8 Scheme code to nested structs
==================================

The core language forms produced by the expander are converted to
"recordised code" by the compiler before actually generating machine
code; recordised code is a nested hierarchy of struct instances.  The
struct types used for this recordisation are used to represent code in
the core language in a way which is better inspectable and optimisable.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-recordize CORE-LANGUAGE-FORM
     Given a symbolic expression representing a form in the core
     language, convert it into a nested hierarchy of struct instances;
     return the outer struct instance.

     This function expects a symbolic expression with perfect syntax: no
     syntax errors are checked.  We expect this function to be executed
     without errors, no exceptions should be raised unless an internal
     error makes it happen.

     In addition the following operations are performed:

        * Determine some properties of the code and store relative
          informations in the struct instances.  For example: is a
          lexical binding ever referenced or assigned?

        * The application of some special lexical primitives is
          transformed into a core language expression integrated in the
          original source code, then recordised.  See below for details.

* Menu:

* compiler recordize bindings:: Recordisation of bindings.
* compiler recordize specials:: Special lexical primitives.
* compiler recordize examples:: Recordisation examples.
* compiler recordize debug::    Introduction of debug calls.


File: vicare-scheme.info,  Node: compiler recordize bindings,  Next: compiler recordize specials,  Up: compiler recordize

17.8.1 Recordisation of bindings
--------------------------------

The core language forms that define bindings are:

     (library-letrec* ((?LHS ?LOC ?RHS) ...) ?BODY)
     (let     ((?LHS ?RHS) ...) ?BODY)
     (letrec  ((?LHS ?RHS) ...) ?BODY)
     (letrec* ((?LHS ?RHS) ...) ?BODY)
     (lambda ?FORMALS ?BODY)
     (case-lambda (?FORMALS ?BODY) ...)
     (annotated-case-lambda ?ANNOTATION (?FORMALS ?BODY) ...)

and as special case:

     (set! ?LHS ?RHS)

when present at the top level.  In all these expressions ?LHS is a
lexical gensym uniquely identifying the binding.

   The recordisation process transforms:

   * 'library-letrec*' and 'letrec*' forms into 'rec*bind' structs, in
     which defined lex gensyms are substituted with 'prelex' structs.

   * 'letrec' forms into 'recbind' structs, in which defined lex gensyms
     are substituted with 'prelex' structs.

   * 'let' forms into 'bind' structs, in which defined lex gensyms are
     substituted with 'prelex' structs.

   * 'lambda', 'case-lambda' and 'annotated-case-lambda' forms into
     'clambda' structs, in which lex gensyms representing bindings
     defined by function arguments are substituted with 'prelex'
     structs.

Undefined bindings and previously defined bindings
..................................................

In the core language input expression: if a binding is defined by the
expression itself, its lex gensym is present as left-hand side in a
'let', 'letrec', 'letrec*', 'library-letrec*' form or as formal argument
in a 'lambda', 'case-lambda', 'annotated-case-lambda' form.  Otherwise
the lex gensym represents an undefined binding or a binding defined
outside the input form.

   Every symbol in the input form not present as left-hand side in a
'bind', 'recbind', 'rec*bind' struct or formal argument in a 'clambda'
struct is interpreted as a reference to undefined or previously defined
binding.  This interpretation includes:

   * Bindings defined by imported libraries.

   * Bindings defined by expressions previously evaluated and added to
     an interaction environment.

   * Bindings that appear for the first time in top level assignment
     forms:

          (set! ?LHS ?RHS)

     like the definitions of syntax transformers in the visit code
     generated by the expander or standalone expressions evaluated at
     the REPL; such assignments to undefined bindings cause a new
     binding to be generated.

for all these cases: the lex gensym acts also as loc gensym.

   After the recordisation process:

   * All the lex gensyms in reference position representing bindings not
     defined by the input expression have been converted to:

          (funcall (primref top-level-value) (constant ?LOC))

     where ?LOC is the loc gensym of the binding.  If this binding is
     truly undefined: the call to 'top-level-value' will raise an
     exception at run-time.

   * All the lex gensyms in assignment position representing bindings
     not defined by the input expression have been converted to:

          (funcall (primref $init-symbol-value!) (constant ?LOC) ?RHS)

     where ?LOC is the loc gensym of the binding; this is the run-time
     definition of a new binding.

so all the 'prelex' structs introduced by 'recordize' represent bindings
defined by the input expression.

     *NOTE* As specified by R6RS, bindings defined by imported libraries
     must not be mutated; this means core language forms like:

          (set! ?LOC ?RHS)

     in which ?LOC is the loc gensym of an imported binding are
     forbidden.  It is the responsibility of the expander not to
     generate such assignment forms for bindings defined by imported
     libraries.

     *NOTE* The special handling of core language assignment forms:

          (set! ?LEX ?RHS)

     in which ?LEX is both the lex and loc gensym of a binding not
     defined by the input expression allows:

        * The correct handling of visit code generated by the expander.

        * The definition of bindings by 'eval' (for example at the REPL)
          using just 'set!' rather than a proper binding form.  This
          case allows bindings to be added to interaction environment
          using weird syntaxes; here is an example session at the REPL:

               vicare> (let () (set! a 1) (set! b 2) #f)
               $1 = #f

               vicare> a
               $1 = 1

               vicare> b
               $1 = 2

          It is the responsibility of the expander to forbid such
          definitions when processing libraries and programs.


File: vicare-scheme.info,  Node: compiler recordize specials,  Next: compiler recordize examples,  Prev: compiler recordize bindings,  Up: compiler recordize

17.8.2 Special lexical primitives
---------------------------------

Whenever, in the recordisation process, the compiler recognises the
application of some special lexical core primitives: it transforms such
application into an equivalent core language expression integrated in
the original source code.  This transformation is equivalent to the
source integration performed by the compiler's source optimiser when
compiling user defined code, but it acts upon primitives defined by the
boot image.

 -- Integrated Primitive: make-parameter INIT
 -- Integrated Primitive: make-parameter INIT GUARD
     Integration of the primitive function 'make-parameter', *note
     make-parameter: iklib parameters.


File: vicare-scheme.info,  Node: compiler recordize examples,  Next: compiler recordize debug,  Prev: compiler recordize specials,  Up: compiler recordize

17.8.3 Recordisation examples
-----------------------------

Handling of imported bindings
.............................

Let's imagine the following library:

     (library (libtest compiler-internals)
       (export a-func a-thunk a-const)
       (import (rnrs (6)))
       (define (a-func a b)
         (+ a b))
       (define (a-thunk)
         "ciao")
       (define a-const 123))

it is recordised as follows:

     (rec*bind ((a-func_0  (lambda (a_0 b_0)
                             (funcall (primref +) a_0 b_0)))
                (a-thunk_0 (lambda ()
                             (constant "ciao")))
                (a-const_0 (constant 123)))
       (constant #<void>))

if this library is imported as in:

     (library (recordize-demo-1)
       (export)
       (import (rnrs) (libtest compiler-internals))
       (list a-const (a-thunk) (a-func 1 2)))

the resulting recordised code is:

     (rec*bind ()
       (funcall (primref list)
                (funcall (primref top-level-value)
                         (constant a-const))
                (funcall (funcall (primref top-level-value)
                                  (constant a-thunk)))
                (funcall (funcall (primref top-level-value)
                                  (constant a-func))
                                  (constant 1)
                                  (constant 2))))

where the symbols 'a-const', 'a-thunk', 'a-func' are the location
gensyms of the imported bindings.


File: vicare-scheme.info,  Node: compiler recordize debug,  Prev: compiler recordize examples,  Up: compiler recordize

17.8.4 Introduction of debug calls
----------------------------------

Whenever debugging mode is enabled, application forms like:

     (?FUNC ?ARG ...)

are expanded and recordised into:

     (funcall (primref debug-call)
              ?ANNOTATION
              ?RATOR ?RAND ...)

where: ?RATOR is the recordised version of ?FUNC; ?RAND is the
recordised version of ?ARG; ?ANNOTATION is a debugging annotation:

     (constant (?ANNOTATION-SOURCE . (?FUNC ?ARG ...)))

in which ?ANNOTATION-SOURCE has one of the formats:

     #f
     (?PORT-IDENTIFIER . ?FIRST-CHARACTER-OFFSET)

the introducion of 'debug-call' is performed no matter what expression
?FUNC is.

Example: 'lambda' application
.............................

The standard language form:

     ((lambda (x) x) 1)

is expanded into the core language form:

     (annotated-call ?ANNOTATION-STRUCT
                     (annotated-case-lambda #'(lambda (x) x)
                                            ((x x)))
                     (quote 1))

which is recordised as:

     (funcall (primref debug-call)
              (constant (?ANNOTATION-SOURCE . ((lambda (x) x) '1)))
              (lambda (x_0) x_0)
              (constant 1))

Example: 'let' application
..........................

The standard language form:

     ((let ((f (lambda (y) y)))
        f)
       1)

is expanded and recordised into:

     (funcall (primref debug-call)
              (constant (?ANNOTATION-SOURCE
                         . ((let ((f (lambda (x) x))) f) 1)))
              (bind ((f_0 (lambda (x_0) x_0))) f_0)
              (constant 1))


File: vicare-scheme.info,  Node: compiler dircalls,  Next: compiler letrec,  Prev: compiler recordize,  Up: compiler

17.9 Optimisation for direct calls
==================================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-optimize-direct-calls INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

     Inspect application forms:

          (funcall ?OPERATOR ?OPERAND ...)

     and attempt to integrate the ?OPERATOR when possible.

* Menu:

* compiler dircalls lambda::    Examples of 'clambda' integration.
* compiler dircalls let::       Examples of bindings integration.
* compiler dircalls cond::      Example: 'cond' syntaxes.
* compiler dircalls debug::     Examples of 'debug-call' integration.


File: vicare-scheme.info,  Node: compiler dircalls lambda,  Next: compiler dircalls let,  Up: compiler dircalls

17.9.1 Examples of 'clambda' integration
----------------------------------------

By definition, a "direct closure application" like:

     ((lambda (x) x) 123)

can be transformed to:

        (let ((x 123)) x)

in which the operator 'lambda' form is integrated; so it can be
converted to low level operations that more efficiently implement the
binding; direct calls optimisation attempts to perform such integration.
Notice that in the case:

     ((case-lambda
        ((x) x)
        ((x y) y))
      123)

the integration yields:

     (let ((x 123)) x)

and the clause with two arguments is just discarded and never compiled.


File: vicare-scheme.info,  Node: compiler dircalls let,  Next: compiler dircalls cond,  Prev: compiler dircalls lambda,  Up: compiler dircalls

17.9.2 Examples of bindings integration
---------------------------------------

There are other integration possibilities when the operator of an
application form is a complex expression:

     ((let ((?lhs ?rhs) ...) ?body) ?rand ...)
     ===> (let ((?lhs ?rhs) ...)
            (?body ?rand ...))

     ((letrec ((?lhs ?rhs) ...) ?body) ?rand ...)
     ===> (letrec ((?lhs ?rhs) ...)
            (?body ?rand ...))

     ((letrec ((?lhs ?rhs) ...) ?body) ?rand ...)
     ===> (letrec* ((?lhs ?rhs) ...)
            (?body ?rand ...))


File: vicare-scheme.info,  Node: compiler dircalls cond,  Next: compiler dircalls debug,  Prev: compiler dircalls let,  Up: compiler dircalls

17.9.3 Example: 'cond' syntaxes
-------------------------------

'cond' syntaxes are expanded as follows:

     (cond ((this X)
            => (lambda (Y)
                 (that Y)))
           (else
            (those)))

becomes:

     (let ((t (this X)))
       (if t
           ((lambda (Y) (that Y)) t)
         (those)))

which contains a direct call, which will be optimised to:

     (let ((t (this X)))
       (if t
           (let ((Y t)) (that Y))
         (those)))


File: vicare-scheme.info,  Node: compiler dircalls debug,  Prev: compiler dircalls cond,  Up: compiler dircalls

17.9.4 Examples of 'debug-call' integration
-------------------------------------------

As example of integration, the standard language form:

     ((lambda (x) x) 1)

is expanded into the core language form:

     (annotated-call ?annotation-struct
                     (annotated-case-lambda #'(lambda (x) x)
                                            ((x x)))
                     (quote 1))

which is recordised as:

     (funcall (primref debug-call)
              (constant (?ANNOTATION-SOURCE . ((lambda (x) x) '1)))
              (lambda (x_0) x_0)
              (constant 1))

and integrated as:

     (bind ((x_0 (constant 1)))
       x_0)

where we can see there is no more a function application.

   Another example, the standard language form:

     ((let ((f (lambda (y) y)))
        f)
      '1)

is expanded and recordised into:

     (funcall (primref debug-call)
              (constant (?ANNOTATION-SOURCE
                         . ((let ((f (lambda (x) x))) f) 1)))
              (bind ((f_0 (lambda (x_0) x_0))) f_0)
              (constant 1))

and integrated as:

     (bind ((f_0 (lambda (y_0) y_0)))
       (funcall (primref debug-call)
                (constant (?ANNOTATION-SOURCE
                           . ((let ((f (lambda (y) y))) f) 1)))
                f_0
                (constant 1)))

where we can see the 'debug-call' moved into the body.


File: vicare-scheme.info,  Node: compiler letrec,  Next: compiler optimisation,  Prev: compiler dircalls,  Up: compiler

17.10 Optimisation of 'letrec' and 'letrec*' forms
==================================================

Vicare's compiler offers multiple algorithms to implement and optimise
the core language forms 'letrec', 'letrec*' and 'library-letrec*', whose
syntax is:

     (letrec ((?LHS ?RHS) ...) ?BODY)

     (letrec* ((?LHS ?RHS) ...) ?BODY)

     (library-letrec* ((?LHS ?LOC ?RHS) ...) ?BODY)

notice that the ?BODY is a single form.  The transformations for
'letrec*' and 'library-letrec*' are equal; the difference between the
two lies in the implementation of allocations, references and
assignments to the ?LHS.

   When this compiler pass is applied to the recordised code, the forms
have already been transformed into:

     (recbind  ((?LHS ?RHS) ...) ?BODY)

     (rec*bind ((?LHS ?RHS) ...) ?BODY)

where instances of the structure 'recbind' represent 'letrec' forms and
instances of the structure 'rec*bind' represent 'letrec*' and
'library-letrec*' forms.

   After this compiler pass has been applied: 'recbind' and 'rec*bind'
structs are no more present in the returned code, having been
substituted with 'bind' and 'fix' structs.  So in the returned code:
every 'prelex' struct represents a binding defined either by 'bind' or
'fix'.

* Menu:

* compiler letrec algo::        Introduction to the algorithms.
* compiler letrec api::         Transformations programming interface.
* compiler letrec notes::       General notes on the context of
                                'letrec' optimisations.
* compiler letrec basic::       The basic transformation algorithm.
* compiler letrec wsd::         The WSD transformation algorithm.
* compiler letrec scc::         The SCC transformation algorithm.


File: vicare-scheme.info,  Node: compiler letrec algo,  Next: compiler letrec api,  Up: compiler letrec

17.10.1 Introduction to the algorithms
--------------------------------------

The compiler implements three algorithms: 'basic', 'waddell', 'scc'.
The default and more advanced is 'scc'; there is little reason to use
the other algorithms when processing real code.

   The 'basic' transformation is the one that defines the 'letrec'
syntax from the R5RS standard document.

   The 'waddell' transformation focuses on generating 'fix' structures
representing recursive binding forms for unassigned 'lambda'
expressions.  To understand this algorithm, and the code, we *must* read
the following paper:

     [WSD] Oscar Waddell, Dipanwita Sarkar, R. Kent Dybvig.  "Fixing
     Letrec: A Faithful Yet Efficient Implementation of Scheme's
     Recursive Binding Construct".

   The 'scc' algorithm is an evolution of the 'waddell' transformation
that better processes bindings, taking into account their actual
dependency graph.  To understand this algorithm, and the code, we *must*
read the following paper:

     [SCC] Abdulaziz Ghuloum, R. Kent Dybvig.  "Fixing Letrec
     (reloaded)".  Workshop on Scheme and Functional Programming '09.

the described algorithm makes use of Tarjan's algorithms to partition
the nodes of a graph into Strongly Connected Components (SCC):

     Tarjan, Robert Endre.  "Depth-first search and linear graph
     algorithms".  SIAM Journal on Computing 1 (2): 146-160, 1972.

for details on the SCC algorithm, we can also refer to the Wikipedia
article "Tarjan's strongly connected components algorithm"(1).

   ---------- Footnotes ----------

   (1) 
<https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm>


File: vicare-scheme.info,  Node: compiler letrec api,  Next: compiler letrec notes,  Prev: compiler letrec algo,  Up: compiler letrec

17.10.2 Transformations programming interface
---------------------------------------------

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-optimize-letrec RECORDISED-CODE
     Perform transformations and optimisations to convert the recordised
     representation of 'letrec', 'letrec*' and 'libary-letrec*' core
     language forms into a composition of low level binding constructs
     and assignments.

 -- Parameter: check-for-illegal-letrec
     If set to true: 'optimize-letrec' will perform an additional
     recordized code pass to check for illegal binding references in the
     right-hand sides of 'letrec', 'letrec*' and 'library-letrec*'
     syntaxes, raising a syntax violation error if one is found.  This
     is the default.

     If set to false: the validating pass is not performed, faithfully
     hoping for no problems in code.

 -- Parameter: current-letrec-pass
     Select the transformations performed by 'optimize-letrec'; possible
     values are the symbols:

     'basic'
          Perform the basic transformation.

     'waddell'
          Perform a transformation similar (but no equal) to the one
          described in the [WSD] paper.

     'scc'
          Perform a transformation similar (but no equal) to the one
          described in the [SCC] paper.  This is the default.


File: vicare-scheme.info,  Node: compiler letrec notes,  Next: compiler letrec basic,  Prev: compiler letrec api,  Up: compiler letrec

17.10.3 General notes on the context of 'letrec' optimisations
--------------------------------------------------------------

On 'let' and 'let*' bindings
............................

Let's consider the following program:

     (import (rnrs))
     (let ((A B))
       #t)

it will fail with "unbound identifier B"; we are *not* concerned with
unbound identifiers in this compiler pass.  So let's move on to the
following program:

     (import (rnrs))
     (let ((A 123))
       (let ((A A))
         #t))

no errors here: the identifier 'A' in reference position is captured by
the outer 'let' binding for 'A'.  Now this program:

     (import (rnrs))
     (let* ((A 123)
            (B A))
       #t)

everything is all right; now this program:

     (import (rnrs))
     (let* ((A 123)
            (A A))
       #t)

again no error: the identifier 'A' in reference position is captured by
the first 'let*' binding for 'A'; 'let*' allows us to create bindings
with the same name.

'letrec' bindings
.................

Let's move to the 'letrec' syntax.  This program is legal:

     (import (rnrs))
     (letrec ((A (lambda () A)))
       #t)

because 'letrec' defines recursive bindings, so we are allowed to
reference 'A' in the right-hand side of the binding for 'A' itself, as
long as we put such reference in the body of a 'lambda'.

   This program is also legal:

     (import (rnrs))
     (letrec ((A (lambda () B))
              (B (lambda () A)))
       #t)

because the cross references to 'A' and 'B' are in the body of 'lambda'
syntaxes.

   This program is illegal:

     (import (rnrs))
     (letrec ((A (list A)))
       #t)

because the identifier 'A' in reference position is not in the body of a
'lambda' syntax: to evaluate the right-hand side of the binding we need
the value of the binding itself.  Notice that 'A' in reference position
is *not* an unbound identifier: it is captured by the 'A' in binding
position; it is just "illegal" and we must detect this situation,
according to R6RS.

   This program is illegal:

     (import (rnrs))
     (letrec ((A 123)
              (B (list A)))
       #t)

because the identifier 'A' in reference position is not in the body of a
'lambda' syntax: 'letrec' does not impose an order to the evaluation of
the init expressions, so to evaluate the right-hand side of the binding
we need the value of the binding itself.

On 'letrec*' bindings
.....................

Let's move to the 'letrec*' syntax; it is similar, but not equal, to
'letrec'.  This program is legal:

     (import (rnrs))
     (letrec* ((A (lambda () A)))
       #t)

because 'letrec*' defines recursive bindings, so we are allowed to
reference 'A' in the right-hand side of the binding for 'A' itself, as
long as we put such reference in the body of a 'lambda'.

   This program is also legal:

     (import (rnrs))
     (letrec* ((A (lambda () B))
               (B (lambda () A)))
       #t)

because the cross references to 'A' and 'B' are in the body of 'lambda'
syntaxes.

   This program is illegal:

     (import (rnrs))
     (letrec* ((A (list A)))
       #t)

because the identifier 'A' in reference position is not in the body of a
'lambda' syntax: to evaluate the right-hand side of the binding we need
the value of the binding itself.  Again, notice that 'A' in reference
position is *not* an unbound identifier: it is captured by the 'A' in
binding position; it is just "illegal" and we must detect this
situation, according to R6RS.

   This program is legal:

     (import (rnrs))
     (letrec* ((A 123)
               (B (list A)))
       #t)

because 'letrec*' imposes a left-to-right order to the evaluation of the
init expressions.

On illegal bindings
...................

R6RS mandates that illegal references to bindings established by
'letrec' and 'letrec*' are detected at run-time and cause an assertion
violation to be raised.  Vicare detects them at compile-time, so some
fully R6RS-compliant code will not work under Vicare.

   The following code is illegal under both R6RS and Vicare:

     (import (rnrs))
     (letrec ((x y)
              (y x))
       'should-not-get-here)

   The following program will run under a R6RS-compliant implementation:

     (import (rnrs))
     (letrec ((x (if (eq? (cons 1 2)
                          (cons 1 2))
                     x
                   1)))
       x)

because the form 'x' in reference position in the right-hand side of the
binding is never evaluated; under Vicare this code will rather raise a
syntax violation at compile-time.

Bindings on the Scheme stack
............................

In the 'recbind' forms the right-hand side expressions ?RHS have no
imposed order of evaluation; the following two forms, in which the order
of the bindings is reversed, must be completely equivalent:

     (recbind ((?LHS1 ?RHS1)
               (?LHS2 ?RHS2))
       ?BODY)

     (recbind ((?LHS2 ?RHS2)
               (?LHS1 ?RHS1))
       ?BODY)

   In the 'rec*bind' forms the right-hand side expressions ?RHS must be
evaluated in the same order in which they appear.

   In a lower-level compiler pass: instances of struct 'bind' will be
converted to code that evaluates the ?RHS expressions and store their
return value into appropriately allocated Scheme stack machine words; a
machine word for every ?LHS will be allocated, each ?LHS will represent
an actual "local variable".

   If we think about the Scheme stack, it is clear why 'bind' structures
cannot represent recursive bindings; given the core language expression:

     (letrec ((f (lambda () f)))
       ?BODY)

the internal representation must be:

     (bind ((f_0 '#!void))
       (seq
         (assign f_0 (lambda () f_0))
         ?BODY))

so that: first 'bind' reserves a Scheme stack machine word for the local
variable, initialised to '#<void>'; then a closure object is created,
referencing the local variable 'f_0'; finally a reference to the closure
object is stored in 'f_0'.  To create the closure object, we must first
know the address of the allocated machine word.

   When processing 'recbind' and 'rec*bind' structures: we must make
sure that a machine word is allocated on the Scheme stack before the
address of such word is needed by the ?RHS expressions.  We do this by
transforming 'recbind' and 'rec*bind' instances into a composition of
'bind' and 'assign' instances.


File: vicare-scheme.info,  Node: compiler letrec basic,  Next: compiler letrec wsd,  Prev: compiler letrec notes,  Up: compiler letrec

17.10.4 The basic transformation algorithm
------------------------------------------

The basic transformations are equivalent to:

     (letrec ((?LHS ?RHS) ...) ?BODY)
     ==> (let ((?LHS #!void) ...)
           (let ((?TMP ?RHS) ...)
             (set! ?LHS ?TMP) ...
             ?BODY))

     (letrec* ((?LHS ?RHS) ...) ?BODY)
     ==> (let ((?LHS #!void) ...)
           (set! ?LHS ?RHS) ...
           ?BODY)

and in recordised code are represented as:

     (recbind ((?LHS ?RHS) ...) ?BODY)
     ==> (bind ((?LHS #!void) ...)
           (bind ((?TMP ?RHS) ...)
             (assign ?LHS ?TMP) ...
             ?BODY))

     (rec*bind ((?LHS ?RHS) ...) ?BODY)
     ==> (bind ((?LHS #!void) ...)
           (assign ?LHS ?RHS) ...
           ?BODY)

as example, with these transformations the library:

     (library (optimize-letrec-basic-demo)
       (export a b c)
       (import (rnrs))
       (define (a) 1)
       (define (b) (a) 2)
       (define (c) (b) 3))

is transformed into:

     (bind ((a_0 '#!void)
            (b_0 '#!void)
            (c_0 '#!void))
      (seq
        (set! a_0 (lambda () '1))
        (set! b_0 (lambda () (seq (funcall a_0) '2)))
        (set! c_0 (lambda () (seq (funcall b_0) '3)))
        (funcall void)))


File: vicare-scheme.info,  Node: compiler letrec wsd,  Next: compiler letrec scc,  Prev: compiler letrec basic,  Up: compiler letrec

17.10.5 The WSD transformation algorithm
----------------------------------------

The WSD algorithm recognises some properties of the bindings to allow:
less assignment operations, more efficient generation of unassigned
function bindings in the same lexical contour.

   When processing a 'letrec' or 'letrec*' core language form WSD
classifies each binding into: 'unreferenced', 'simple', 'complex' or
'fixable'.  Vicare's implementation of WSD leaves unreferenced bindings
alone, in this compiler pass, to be processed later by the source
optimiser; an unreferenced binding is classified as 'simple'.  It also
renames the category 'lambda' into 'fixable'.

The 'letrec' transformation
...........................

If the form is a 'letrec': we do *not* care about the order of
evaluation of the right-hand sides, so given the core language form:

     (letrec ((?LHS ?RHS) ...) ?BODY)

we transform it into:

     (let ((?SIMPLE.LHS ?SIMPLE.RHS) ...)
       (let ((?COMPLEX.LHS '#!void) ...)
         (let ((?FIXABLE.LHS ?FIXABLE.RHS) ...)
           (let ((?TMP ?COMPLEX.RHS) ...)
             (set! ?COMPLEX.LHS ?TMP) ...
             ?BODY))))

in which the ?COMPLEX.RHS expressions are evaluated in unspecified
order.  In recordised code, the input expression:

     (recbind ((?LHS ?RHS) ...) ?body)

is transformed into:

     (bind ((?SIMPLE.LHS ?SIMPLE.RHS) ...)
       (bind ((?COMPLEX.LHS '#!void) ...)
         (fix ((?FIXABLE.LHS ?FIXABLE.RHS) ...)
           (bind ((?TMP ?COMPLEX.RHS) ...)
             (assign ?COMPLEX.LHS ?TMP) ...
             ?BODY))))

The 'letrec*' transformation
............................

If the form is a 'letrec*': we *do care* about the order of evaluation
of the right-hand sides, so given the core language form:

     (letrec* ((?LHS ?RHS) ...) ?BODY)

we transform it into:

     (let ((?SIMPLE.LHS ?SIMPLE.RHS) ...)
       (let ((?COMPLEX.LHS '#!void) ...)
         (let ((?FIXABLE.LHS ?FIXABLE.RHS) ...)
           (set! ?COMPLEX.LHS ?COMPLEX.RHS) ...
           ?BODY)))

in which the ?COMPLEX.RHS expressions are evaluated in the same order in
which they appear in the core language form.  In recordised code, the
input expression:

     (rec*bind ((?LHS ?RHS) ...) ?BODY)

is transformed into:

     (bind ((?SIMPLE.LHS ?SIMPLE.RHS) ...)
       (bind ((?COMPLEX.LHS '#!void) ...)
         (fix ((?FIXABLE.LHS ?FIXABLE.RHS) ...)
           (assign ?COMPLEX.LHS ?COMPLEX.RHS) ...
           ?BODY)))

Notes
.....

The really important thing about the WSD transformations is to generate
reliable 'fix' bindings definitions: the classification of "fixable"
bindings must be reliable.  This covers the very common case of
'library' forms whose top level function definitions are unassigned; for
example, the library:

     (library (optimize-letrec-waddell-demo)
       (export a b c)
       (import (rnrs))
       (define (a) 1)
       (define (b) (a) 2)
       (define (c) (b) 3))

is transformed into:

     (bind ()        ;simple
       (bind ()      ;complex
         (fix ((a_0 (lambda () '1))
               (b_0 (lambda () (seq (funcall a_0) '2)))
               (c_0 (lambda () (seq (funcall b_0) '3))))
           (funcall void))))

   The algorithm's implementation can be conservative and suboptimal in
classifying bindings as 'complex', even though they could be 'simple' or
'fixable', whenever the classification as 'simple' or 'fixable' requires
too much work or is unreliable; in other words: when in doubt, just call
it 'complex'.  One of the purposes of the SCC algorithm is exactly to
improve such classification.


File: vicare-scheme.info,  Node: compiler letrec scc,  Prev: compiler letrec wsd,  Up: compiler letrec

17.10.6 The SCC transformation algorithm
----------------------------------------

The SCC algorithm builds a directed graph representation of the bindings
in a single 'recbind' or 'rec*bind' structure, outlining the
dependencies among right-hand side expressions; in the graph each
binding is a vertex (also called node).  It then applies Tarjan's
algorithm to the graph and partitions the bindings into clusters of
Strongly Connected Components (SCC).

   Here is the gist of the algorithm:

  1. Given the core language 'letrec' form:

          (letrec ((D (lambda () B))
                   (C D)
                   (B C)
                   (A B))
            ?BODY)

     we build a directed graph of dependencies between the bindings; the
     graph of dependencies for the given form is:

          A --> B --> C
                ^     |
                |     |
                D <---

  2. We perform a depth-first visit of the directed graph; during the
     visit we step from the current vertex to a successor one, following
     an outgoing edge, if it has not already been visited; a depth-first
     visit is like entering a maze and always turn right at cross roads.
     While visiting the vertexes: we push each visited vertex on a
     stack; we rank each vertex with a zero-based serial index.

     The following picture shows an ongoing visit with path 'A', 'B',
     'C', 'D'; the serial index of each vertex is in square brackets:

          A[0] --> B[1] --> C[2]     STK == A, B, C, D
                     ^       |
                     .       |
                     .       |
                   D[3] <----

     let's say we are visiting 'D' and considering the successor vertex
     'B' as next step.

       a. 'B' has already been visited, so we do not enter it; the index
          of 'B' is '1', less than the index of 'D' which is '3', so we
          mutate the index of 'D' to be '1':

               A[0] --> B[1] --> C[2]     STK == A, B, C, D
                          ^        |
                          .        |
                          .        |
                        D[1] <-----

          there are no more successor vertexes from 'D' so we step back
          to 'C'; notice that we leave the stack unchanged.

       b. Upon stepping back to 'C': we recognise that the index of 'C'
          is '2', less than the index of 'D' which is '1'; so we mutate
          the index of 'C' to be '1':

               A[0] --> B[1] --> C[1]     STK == A, B, C, D
                          ^        .
                          .        .
                          .        .
                        D[1] <.....

          there are no more successor vertexes from 'C' so we step back
          to 'B'; notice that we leave the stack unchanged.

       c. Upon stepping back to 'B': we recognise that the index of 'B'
          is '1', greater than or equal to the index of 'C' which is
          '1'; we leave the index of 'B' unchanged.  Now we recognise
          that: after visiting all the vertexes successors to 'B', the
          index of 'B' is unchanged; we conclude that all the nodes on
          the stack up to and including 'B' are part of a Strongly
          Connected Component:

               STK == A, B, C, D
                        |-------| SCC

          so we pop them from the stack and form a cluster with them.
          The vertexes in a cluster are marked as "done" and will be
          skipped in further steps of the visit, as if they are not
          there.

  3. Clusters of SCCs are formed and accumulated while stepping back
     from the depth-first visit, the accumulated clusters are in reverse
     order.  This implementation of Tarjan's algorithm guarantees that
     the returned list of clusters is in the correct order for RHS
     evaluation in 'recbind' or 'rec*bind' structs:

        * The RHS of bindings in the first cluster from the list, must
          be evaluated before the RHS of bindings in the second cluster.

        * The RHS of bindings in the second cluster from the list, must
          be evaluated before the RHS of bindings in the third cluster.

        * And so on.

     So we can arrange the evaluation as if each cluster comes from a
     nested binding form; if the returned list is:

          ((?CLUSTER-BINDING-1 ...)
           (?CLUSTER-BINDING-2 ...)
           (?CLUSTER-BINDING-3 ...))

     the equivalent nested binding forms are:

          (recbind (?CLUSTER-BINDING-3 ...)
            (recbind (?CLUSTER-BINDING-2 ...)
              (recbind (?CLUSTER-BINDING-1 ...)
                ?BODY)))

  4. Each cluster of SCCs generates a nested hierarchy of bindings;
     first the bindings are partitioned into fixable and non-fixable,
     the a form like the following is generated:

          (bind ((?COMPLEX.LHS '#!void) ...)
            (fix ((?FIXABLE.LHS ?FIXABLE.RHS) ...)
              (assign ?COMPLEX.LHS ?COMPLEX.RHS) ...
              ?BODY))


File: vicare-scheme.info,  Node: compiler optimisation,  Next: compiler refassig,  Prev: compiler letrec,  Up: compiler

17.11 Source optimisation
=========================

For an introduction to the source code see the thesis:

     Oscar Waddell.  "Extending the Scope of Syntactic Abstraction".
     PhD. Thesis.  Indiana University Computer Science Department.
     August 1999.

and the paper:

     Oscar Waddell, R. Kent Dybvig.  "Fast and Effective Procedure
     Inlining".  Indiana University.  Computer Science Department.
     Technical Report No.  484.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-source-optimize INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

 -- Parameter: source-optimizer-passes-count
     Specify how many passes to perform with the source optimizer; it
     must be a positive fixnum.  Defaults to '1'; it is set to 2 when
     the optimisation level is '3'.

     It makes sense to perform zero, one or two passes; it is unlikely
     that more passes can do significant improvement.

   The following bindings are exported by the library '(vicare)'.

 -- Parameter: optimize-level
     The optimization level; accepted values are the fixnums '0', '1',
     '2', '3'.  Defaults to '2'.

 -- Parameter: cp0-effort-limit
     The initial value of an "effort counter" that is decremented every
     time an optimisation is performed by the source optimiser; when the
     counter reaches zero: the current optimisation effort is abandoned
     and the original input expression kept as is.  It is set every time
     the optimiser enters specific subexpressions of the input.

 -- Parameter: cp0-size-limit
     The initial value of a (estimated) code size counter that is
     decremented every time an optimisation is performed by the source
     optimiser; when the counter reaches zero: the current optimisation
     effort is abandoned and the original input expression kept as is.
     It is set every time the optimiser enters specific subexpressions
     of the input.


File: vicare-scheme.info,  Node: compiler refassig,  Next: compiler type inference,  Prev: compiler optimisation,  Up: compiler

17.12 Rewriting references and assignments
==========================================

References to bindings in recordised code are represented as standalone
'prelex' structures; assignments to bindings in recordised code are
represented as 'assign' structs:

     (assign ?PREL ?RHS)

in which ?PREL is a 'prelex' structure and the right-hand side ?RHS is
recordised code which, evaluated at run-time, will return the new
binding's value.

   With respect to how references and assignments are actually
implemented, there are three kinds of lexical bindings:

   * Top level bindings, defined by 'library-letrec*' core language
     forms; *note Handling of lexical top level bindings: compiler
     topics topbind.

   * Unassigned (read-only) local bindings, defined by 'let', 'letrec'
     and 'letrec*' core language forms and never subjected to a 'set!'
     core language form; *note Handling of lexical local bindings:
     compiler topics locbind.

   * Assigned (read-write) local bindings, defined by 'let', 'letrec'
     and 'letrec*' core language forms and subjected to one or more
     'set!' core language forms; *note Handling of lexical local
     bindings: compiler topics locbind.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-rewrite-references-and-assignments INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

     Transform references and assignments for top level lexical bindings
     and unassigned local lexical bindings according to the
     implementation of such operations.  Remembering that the actual
     value of a top level binding is stored in the 'value' field of a
     loc gensym, this function performs the following transformations:

        * References to top level bindings are transformed into:

               (funcall (primref $symbol-value) (constant ?LOC))

          which extracts the value from slot 'value' of the loc gensym
          ?LOC.

        * Common assignments to top level bindings are transformed into:

               (funcall (primref $set-symbol-value!)
                        (constant ?LOC)
                        ?RHS)

          which stores a new value in the slot 'value' of the log gensym
          ?LOC.

        * Single assignments to top level bindings which also serve as
          binding initialisations are transformed into:

               (funcall (primref $init-symbol-value!)
                        (constant ?LOC)
                        ?RHS)

          which stores a new value in the slot 'value' of ?LOC and, only
          if the value is recognised at run-time as being closure
          object, also stores value in the slot 'proc'.

        * Definitions of assigned local bindings are transformed as
          follows:

               (bind ((?PREL ?INIT)) ?BODY)
               ==> (bind ((?TMP-PREL ?INIT))
                     (bind ((?PREL (funcall (primref vector)
                                            ?TMP-PREL)))
                       ?BODY))

        * References to assigned local bindings are transformed from
          standalone 'prelex' structs to:

               (funcall (primref $vector-ref) ?PREL (constant 0))

        * Assignments to assigned local bindings are transformed as
          follows:

               (assign ?PREL ?RHS)
               ==> (funcall (primref $vector-set!)
                           ?PREL
                           (constant 0)
                           ?RHS)

     After this compiler pass: there are no more 'assign' structs in the
     returned recordised code.


File: vicare-scheme.info,  Node: compiler type inference,  Next: compiler unsafe primrefs,  Prev: compiler refassig,  Up: compiler

17.13 Core type inference
=========================

This optional compiler pass analyses the type of values returned by
expressions with the purpose of transforming 'funcall' recordised forms:

     (funcall (primref ?PRIM-NAME) ?RAND ...)
     (funcall ?RATOR               ?RAND ...)

into:

     (funcall (primref ?PRIM-NAME)       (known ?RAND ?RAND-TYPE) ...)
     (funcall (known ?RATOR ?RATOR-TYPE) (known ?RAND ?RAND-TYPE) ...)

where: ?RATOR-TYPE is the type description of the value returned by
?RATOR; each ?RAND-TYPE is the type description of the value returned by
the corresponding ?RAND; a 'primref' operator is left untouched.  The
type descriptions are records of type 'core-type-tag' whose represented
types are inferred by this compiler pass.

   The structs of type 'known' are annotation "tags" consumed by the
functions generating the implementation of the core primitive
operations; for example, given the recordised code:

     (funcall (primref vector-length) ?RAND)

which makes use of the primitive operation 'vector-length':

   * If no type tag is assigned to ?RAND: the implementation of
     'vector-length' integrated at the call site must include a
     validation of ?RAND as vector object.

   * If the tag 'T:vector' is introduced for the operand:

          (funcall (primref vector-length) (known ?RAND T:vector))

     the implementation of 'vector-length' integrated at the call site
     does *not* include a validation of ?RAND as vector object.

     *NOTE* At present (Jul 23, 2016), this compiler pass is performed
     only if the configured compiler's optimisation level is '1' or
     above.  When Vicare is run with the option '-O0': this compiler
     pass is skipped.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-core-type-inference INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

 -- Parameter: perform-core-type-inference?
     When true the pass 'core-type-inference' is performed, else it is
     skipped.  Defaults to '#t'.

Properties propagation through function arguments
.................................................

Let's examine what happens when a variable reference is used as operand
for the primitive operation 'cdr'; the primitive 'cdr' accepts a pair as
operand.  In the following standard code example the variable 'x' is of
unknown type, when its binding is created 'x' is left untagged:

     (let ((f (lambda (y) y))
           (x (read)))
       (f (cdr x))
       (f x))

but, after being used as argument for 'cdr' without raising an
exception: it is known that its type is 'T:pair', so the second
reference to 'x' is tagged with 'T:pair'; the result of the
transformation is:

     (bind ((f_0 (lambda (y_0) y_0))
            (x_0 (funcall (primref read))))
       (seq
         (funcall (known f_0 (T:procedure T:non-false
                              T:nonimmediate T:object))
           (funcall (primref cdr) x_0))
         (funcall (known f_0 (T:procedure T:non-false
                              T:nonimmediate T:object))
           (known x_0 (T:pair T:non-false
                       T:nonimmediate T:object)))))

   We know that a "wrong operand type" exception is non-continuable; so
if 'cdr' raises an exception because 'x' is not a pair: the control flow
cannot come back.  This allows us to determine type informations and
propagate them after the arguments have been validated.


File: vicare-scheme.info,  Node: compiler unsafe primrefs,  Next: compiler sanitise bindings,  Prev: compiler type inference,  Up: compiler

17.14 Safe to unsafe core primitive applications
================================================

This optional compiler pass recognises the application of *safe* core
primitive functions having operands of the correct type and replaces
them with the corresponding application of *unsafe* core primitive
functions or operations; the result is faster code.

     *NOTE* A "safe" core primitive validates its arguments and raises
     an exception it they have the wrong type; an "unsafe" core
     primitive assumes its operands are correct and just attempts to
     perform the algorithm.

     *NOTE* At present (Jul 23, 2016), this compiler pass is performed
     only if the configured compiler's optimisation level is '1' or
     above.  When Vicare is run with the option '-O0': this compiler
     pass is skipped.

   It makes sense to perform this compiler pass only if
'core-type-inference' has been performed first: it is the "type
inference" pass that introduces the type descriptions consumed by the
"unsafe primitives introduction" pass.  Performing this pass could be
useless because:

   * The same transformation may have been already performed by the
     expander when the tagged language is enabled.

   * The same transformation is performed by the primitive operation
     implementation handlers.

nevertheless, it is technologically possible to compose core language
expressions by means different from applying the expander to source
code; in such scenario this compiler pass makes sense, because there are
core primitives implemented only as functions (not operations) that
still have an unsafe variant.

 -- Function: pass-introduce-unsafe-primrefs INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

 -- Parameter: perform-unsafe-primrefs-introduction?
     When true the pass 'introduce-unsafe-primrefs' is performed, else
     it is skipped.  Defaults to '#t'.


File: vicare-scheme.info,  Node: compiler sanitise bindings,  Next: compiler direct jumps,  Prev: compiler unsafe primrefs,  Up: compiler

17.15 Sanitizing bindings
=========================

This compiler pass makes sure that every 'clamba' struct appears as
direct right-hand side expression in a 'fix' struct:

     (fix ((?LHS ?CLAMBDA)) ?BODY)

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-sanitize-bindings INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

     Perform the following transformations:

        * 'clambda' structs that already appear as RHS of 'fix' structs
          are left alone.

        * 'clambda' structs appearing as RHS in single-binding 'bind'
          structs cause the 'bind' struct to be replaced by a 'fix'
          struct:

               (bind ((?LHS ?CLAMBDA)) ?BODY)
               ==> (fix ((?LHS ?CLAMBDA)) ?BODY)

        * 'clambda' structs appearing as RHS in multiple-binding 'bind'
          structs cause the 'bind' struct to be split into a 'bind'
          struct and a 'fix' struct in which the bindings are
          partitioned:

               (bind ((?LHS0 ?CLAMBDA)
                      (?LHS1 ?RHS))
                 ?BODY)
               ==> (bind ((?LHS1 ?RHS))
                     (fix ((?LHS0 ?CLAMBDA))
                       ?BODY))

        * 'clambda' structs appearing as standalone expressions (that
          is: not directly as RHS of a 'bind' or 'fix' struct) are
          "lifted" as follows:

               (clambda (?FORMALS ?BODY) ...)
               ==> (fix ((tmp (clambda (?FORMALS ?BODY) ...)))
                     tmp)

     In the returned struct of recordised code: all the 'clambda'
     structs appear in the code as right-hand side initialisation
     expressions of 'fix' structs; all the 'bind' structs have a
     non-'clambda' struct as right-hand side initialisation expression.


File: vicare-scheme.info,  Node: compiler direct jumps,  Next: compiler global assign,  Prev: compiler sanitise bindings,  Up: compiler

17.16 Optimisation for direct jumps
===================================

Let's consider the following code in which the 'lambda' sexp has not
been integrated at the call site:

     (let ((f (lambda (x) x)))
       (f 123))

by inspecting this code we can verify at compile-time that that 'f'
references a 'clambda' and the application form has the correct number
of operands; Vicare offers a technique to implement a "full closure
object application" '(f 123)' as a faster "direct jump call" to the
'clambda' clause with the correct number of operands.  Another example,
when the 'clambda' has multiple clauses:

     (let ((f (case-lambda
                ((x)   x)
                ((x y) (list x y)))))
       (f 1 2))

by inspecting this code we can verify at compile-time that 'f'
references a 'clambda' and that it is called with 2 arguments: there is
technique that allows to implement the application '(f 1 2)' as a direct
jump to the clause with 2 arguments.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-optimize-for-direct-jumps INPUT
     Perform code optimisation traversing the whole hierarchy in INPUT,
     which must be a struct instance representing recordised code, and
     building a new hierarchy of optimised, recordised code; return the
     new hierarchy.

     Transform 'funcall' structs into 'jmpcall' structs whenever in the
     application form:

          (funcall ?OPERATOR ?OPERAND ...)

     the operator is a binding reference known to reference a 'clambda'
     struct.

     Upon entering this transformation: all the 'clambda' structs must
     appear in the input as right-hand side initialisation expressions
     of 'fix' structs; all the 'bind' structs must have a non-'clambda'
     struct as right-hand side initialisation expression.

Examples
........

Let's see some example in which we have disable function integration in
application forms.  The standard code:

     (let ((f (case-lambda
                ((a)   1)
                ((a b) 2))))
       (list (f 1) (f 1 2)))

is transformed into:

     (fix ((f_0 (case-lambda
                  ((a_0)     (constant 1))
                  ((a_1 b_0) (constant 2)))))
       (funcall (primref list)
         (jmpcall asmlabel:f:clambda:case-1
                  f_0 (constant 1))
         (jmpcall asmlabel:f:clambda:case-2
                  f_0 (constant 1) (constant 2))))

where 'asmlabel:f:clambda:case-1' is a placeholder for the address of
the machine code entry point of the first case of the 'clambda' bound to
'f_0' (the one with 1 argument); 'asmlabel:f:clambda:case-2' represents
the machine code entry point of the second case.

   The following core language code defines a recursive function:

     (letrec ((f (case-lambda
                   (()  (f '1))
                   ((a) a))))
       ((primitive list) (f) (f '2)))

and it is transformed into:

     (fix ((f_0 (case-lambda
                  (()
                   (jmpcall asmlabel:f:clambda:case-1
                            f_0 (constant 1)))
                  ((a_0)
                   a_0))))
       (funcall (primref list)
         (jmpcall asmlabel:f:clambda:case-0
                  f_0)
         (jmpcall asmlabel:f:clambda:case-1
                  f_0 (constant 2))))

where we see the recursive function call is also optimised as direct
jump.


File: vicare-scheme.info,  Node: compiler global assign,  Next: compiler vars,  Prev: compiler direct jumps,  Up: compiler

17.17 Inserting global assignments
==================================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-insert-global-assignments INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of transformed, recordized code;
     return the new hierarchy.

     This module inserts global assignments forms that put the value of
     lexical top level bindings in the slot 'value' of the corresponding
     loc gensym; for bindings whose value is a closure object: the value
     is also stored in the 'proc' slot of the loc gensym.

   As example, the library:

     (library (insert-global-assignments-demo-1)
       (export a b c d)
       (import (rnrs))
       (define (a) '1)
       (define (b) '2)
       (define (c) '3)
       (define d '4))

is expanded into the core language form:

     (library-letrec*
         ((a.lex a.loc (lambda () '1))
          (b.lex b.loc (lambda () '2))
          (c.lex c.loc (lambda () '3))
          (d.lex d.loc '4))
       (quote #!void))

then recordised and transformed into:

     (fix ((a.lex_0 (lambda () (constant 1)))
           (b.lex_0 (lambda () (constant 2)))
           (c.lex_0 (lambda () (constant 3))))
       (seq
         (funcall (primref $set-symbol-value/proc!)
                  (constant a.loc) a.lex_0)
         (funcall (primref $init-symbol-value!)
                  (constant b.loc) b.lex_0)
         (funcall (primref $init-symbol-value!)
                  (constant c.loc) c.lex_0)
         (bind ((d.lex_0 (constant 4)))
           (seq
             (funcall (primref $init-symbol-value!)
                      (constant d.loc) d.lex_0)
             (constant #!void)))))


File: vicare-scheme.info,  Node: compiler vars,  Next: compiler closure makers,  Prev: compiler global assign,  Up: compiler

17.18 Introducing storage locations
===================================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-introduce-vars INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

     Replace all the 'prelex' structs in recordised code with 'var'
     structs; this is because after this compiler pass we need a
     different set of properties to handle variable bindings.


File: vicare-scheme.info,  Node: compiler closure makers,  Next: compiler lifting,  Prev: compiler vars,  Up: compiler

17.19 Introducing closure makers
================================

We can think of 'clambda' structs as representing code that, once
compiled, becomes the machine code stored in code objects implementing
Scheme functions.  This compiler pass wraps each 'clambda' struct into a
'closure-maker' struct, which represents code that, executed at
run-time, builds and returns a closure object using the 'clambda''s code
object as implementation.  While wrapping 'clambda', a list of variable
references that are free in the body of the 'clambda' is gathered for
future use.

     *NOTE* The *true* purpose of this compiler pass is to gather lists
     of free variables referenced by 'clambda' bodies.  We might
     introduce the closure makers at a later pass and store the lists of
     free variables in the 'clambda' structs; we introduce the closure
     makers here because it helps a bit in reasoning about the
     transformations.

   Upon entering this compiler pass:

   * For bindings defined by 'bind' structs:

          (bind ((?LHS ?RHS) ...) ?BODY)

     the ?LHS are 'var' structs; the ?RHS are non-'clambda' structs; the
     'var' in ?LHS do *not* appear in the ?RHS expressions.

   * For bindings defined by 'fix' structs:

          (fix ((?LHS ?RHS) ...) ?BODY)

     the ?LHS are 'var' structs; the ?RHS are 'clambda' structs; the
     'var' in ?LHS might appear in the ?RHS expressions.

   * Structs of type 'clambda' appear only as right-hand side
     expressions of 'fix' structs.

   This compiler pass transforms:

     (fix ((?LHS ?CLAMBDA-RHS) ...) ?BODY)

into:

     (fix ((?LHS (closure-maker ?CLAMBDA-RHS)) ...) ?BODY)

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-introduce-closure-makers INPUT
     Perform code transformations traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised
     code, and building a new hierarchy of recordised code; return the
     new hierarchy.

     This function wraps each 'clambda' struct in the input recordised
     code into 'closure-maker' structures, compiling a list of free
     variables referenced by each 'clambda'.

Examples
........

This example generates a function with no free variables:

     (lambda () '1)
     ==> (fix ((tmp_0 (closure-maker (lambda () (constant 1))
                                     no-freevars)))
           tmp_0)

   This example generates a multi-clause function with no free
variables:

     (case-lambda
      (() '1)
      ((a) a))
     ==> (fix ((tmp_0 (closure-maker (case-lambda
                                      (()    (constant 1))
                                      ((a_0) a_0))
                                     no-freevars)))
           tmp_0)

   This example generates a function with a free variable:

     (let ((a ((primitive read))))
       (lambda () a))
     ==> (bind ((a_0 (funcall (primref read))))
           (fix ((tmp_0 (closure-maker (lambda () a_0)
                                       (freevars: a_0))))
             tmp_0))

   This example generates a recursive function with no free variables
other than the reference to itself:

     (letrec ((f (lambda () (f))))
       f)
     ==> (fix ((f_0 (closure-maker
                       (lambda ()
                         (jmpcall asmlabel:f:clambda:case-0 f_0))
                       (freevars: f_0))))
           f_0)

   The core language form:

     (library-letrec*
         ((a a.loc (lambda () '1))
          (b b.loc (lambda () '2))
          (c c.loc (lambda () '3))
          (d d.loc '4))
       (quote #!void))

is transformed into:

     (fix ((a_0 (closure-maker (lambda () (constant 1)) no-freevars))
           (b_0 (closure-maker (lambda () (constant 2)) no-freevars))
           (c_0 (closure-maker (lambda () (constant 3)) no-freevars)))
       (seq
         (funcall (primref $set-symbol-value/proc!)
                  (constant a.loc) a_0)
         (funcall (primref $init-symbol-value!)
                  (constant b.loc) b_0)
         (funcall (primref $init-symbol-value!)
                  (constant c.loc) c_0)
         (bind ((d_0 (constant 4)))
           (seq
             (funcall (primref $init-symbol-value!)
                      (constant d.loc) d_0)
             (constant #!void)))))


File: vicare-scheme.info,  Node: compiler lifting,  Next: compiler primopcalls,  Prev: compiler closure makers,  Up: compiler

17.20 Closures optimization and 'clambda' lifting
=================================================

This compiler pass performs 'clambda' lifting and optimisation of calls
to functions without free variables.

* Menu:

* compiler lifting intro::         Introduction to 'clambda' lifting.
* compiler lifting prerequisites:: Prerequisites for codes lifting.
* compiler lifting combinators::   Combinators and non-combinators.
* compiler lifting optimisation::  Optimisation of combinator calls.
* compiler lifting examples::      Examples of combinators and
                                   non-combinators.
* compiler lifting substitutions:: Substitution optimisations.
* compiler lifting api::           'clambda' lifting API.


File: vicare-scheme.info,  Node: compiler lifting intro,  Next: compiler lifting prerequisites,  Up: compiler lifting

17.20.1 Introduction to 'clambda' lifting
-----------------------------------------

The purpose of this compiler pass is to partition the input expression
into: the code that will be compiled to code objects implementing
closure objects; code that will be compiled to a code object
implementing the main body of the expression.  As example, the library:

     (library (clambda-lifting-demo-0)
       (export a b c d)
       (import (rnrs))
       (define (a) '1)
       (define (b) '2)
       (define (c) '3)
       (define d 4))

is expanded into:

     (library-letrec*
         ((a a.loc (lambda () '1))
          (b b.loc (lambda () '2))
          (c c.loc (lambda () '3))
          (d d.loc '4))
       (quote #!void))

before this compiler pass it is transformed into:

     (fix ((a_0 (closure-maker (lambda () (constant 1)) no-freevars))
           (b_0 (closure-maker (lambda () (constant 2)) no-freevars))
           (c_0 (closure-maker (lambda () (constant 3)) no-freevars)))
       (seq
         (funcall (primref $set-symbol-value/proc!)
                  (constant a.loc) a_0)
         (funcall (primref $init-symbol-value!)
                  (constant b.loc) b_0)
         (funcall (primref $init-symbol-value!)
                  (constant c.loc) c_0)
         (bind ((d_0 (constant 4)))
           (seq
             (funcall (primref $init-symbol-value!)
                      (constant d.loc) d_0)
             (constant #!void)))))

and after this compiler pass it will become:

     (codes
       ((lambda (label: asmlabel:c:clambda) () (constant 3))
        (lambda (label: asmlabel:b:clambda) () (constant 2))
        (lambda (label: asmlabel:a:clambda) () (constant 1)))
       (seq
         (funcall (primref $set-symbol-value/proc!)
           (constant a.loc)
           (closure-maker (code-loc asmlabel:a:clambda) no-freevars))
         (funcall (primref $init-symbol-value!)
           (constant b.loc)
           (closure-maker (code-loc asmlabel:b:clambda) no-freevars))
         (funcall (primref $init-symbol-value!)
           (constant c.loc)
           (closure-maker (code-loc asmlabel:c:clambda) no-freevars))
         (bind ((d_0 (constant 4)))
           (seq
             (funcall (primref $init-symbol-value!)
               (constant d.loc) d_0)
             (constant #!void)))))

   We see the result of the transformation is a struct of type 'codes'
in which the 'clambda' forms have been extracted and separated; in
addition, the top level 'fix' struct has been removed and references to
the 'fix' bindings have been replaced by 'closure-maker' forms, this
happens because all the functions are combinators.

   The 'closure-maker' form:

     (closure-maker (code-loc asmlabel:a:clambda) no-freevars)

will be compiled to code that returns a closure object implementing the
function 'a', with assembly entry point label 'asmlabel:a:clambda'.


File: vicare-scheme.info,  Node: compiler lifting prerequisites,  Next: compiler lifting combinators,  Prev: compiler lifting intro,  Up: compiler lifting

17.20.2 Prerequisites for codes lifting
---------------------------------------

When arriving at this compiler pass the input recordised code is such
that:

   * All the 'clambda' structs are wrapped into 'closure-maker' structs.

   * All the 'closure-maker' structs appear as right-hand side
     expressions of bindings defined by 'fix' structs.

   * Bindings defined by 'fix' structs are immutable and their
     right-hand side expressions are all 'closure-maker' structs.

   * Bindings defined by 'bind' structs are immutable and their
     right-hand side expressions are of type different from
     'closure-maker' and 'clambda'.  These bindings are immutable
     because the assigned ones have been previously transformed into
     immutable references to mutable vector objects.

   * If the right-hand side expression of a binding defined by 'bind' is
     a 'var' struct: such binding defines a synonym.  For example:

          (bind ((a ?RHS))
            (bind ((b a))
              ?BODY))

     the binding 'b' is immutable, so 'b' is a synonym of 'a'; it is
     perfectly all right to substitute all the occurrences of the 'var'
     'b' in ?BODY with occurrences of the 'var' 'a'.


File: vicare-scheme.info,  Node: compiler lifting combinators,  Next: compiler lifting optimisation,  Prev: compiler lifting prerequisites,  Up: compiler lifting

17.20.3 Combinators and non-combinators
---------------------------------------

To discuss the transformations we define:

_combinator_
     A Scheme function without free variables; a combinator does not
     capture any binding.  The closure object implementing a combinator
     can be created once and for all at compile-time; for example:

          (define (compute x y z)
            (define (lincomb a b c)
              (+ (* a b) (* a c)))
            (lincomb x y z))

     assuming function integration is disabled: the closure object
     implementing the function 'lincomb' can be created once at
     compile-time and reused at every call to 'compute'.

_non-combinator_
     A Scheme function with free variables, whose current value must be
     captured at run-time.  To implement a non-combinator: a new closure
     object must be created at run-time every time the control flow
     reaches the 'lambda' form, to capture the current values of the
     free variables; for example:

          (define (adder x)
            (lambda (x)
              (+ x y)))

     at every call to the function 'adder' a new closure object must be
     created and returned, capturing the value of the argument 'x'.

   We want to discuss how to recognise combinators and non-combinators
among the bindings defined by a 'fix' struct.  Let's consider the
recordised code:

     (bind ((?LHS1 ?RHS1) ...)
       (fix ((?LHS0 ?RHS0) ...)
         (bind ((?LHS2 ?RHS2) ...)
           ?BODY)))

at this point in the sequence of compiler passes, we know that all the
?RHS0 are 'closure-maker' structs.  The 'var' structs ?LHS0 and ?LHS1
may appear in the body of each ?RHS0, while the internally defined 'var'
structs ?LHS2 cannot; so the ?LHS2 do not influence the nature of the
?RHS0 expressions: we can ignore all the internally defined bindings.
So let's switch to inspect the recordised code:

     (bind ((?LHS1 ?RHS1) ...)
       (fix ((?LHS0 ?RHS0) ...)
         ?BODY))

the 'var' structs ?LHS0 and ?LHS1 may appear in the body of each ?RHS0;
this includes the case of recursive ?RHS0, in which a ?LHS0 'var'
appears in the list of free variables of the associated ?RHS0.

   * If a list of free variables is empty: the corresponding ?RHS0 is a
     combinator.  For example, in the recordised code:

          (bind ((a ?RHS-A) (b ?RHS-B))
            (fix ((f (closure-maker (lambda () '3) no-freevars))
                  (g (closure-maker (lambda () '4) no-freevars)))
              ?BODY))

     both the 'fix'-bound functions have empty list of free variables,
     so both functions are combinators.

   * If a list of free variables contains only externally defined ?LHS1
     structs: the corresponding ?RHS0 is a non-combinator.  For example,
     in the recordised code:

          (bind ((a ?RHS-A) (b ?RHS-B))
            (fix ((f (closure-maker (lambda () a)
                                    (freevars: a)))
                  (g (closure-maker (lambda () (constant 3))
                                    no-freevars)))
              ?BODY))

     the function bound to 'f' has the 'var' 'a' in its free variables
     list; the value of the free variable 'a' is known only at run-time,
     so the closure maker must capture a run-time value, so the function
     'f' is a non-combinator.

   * If a list of free variables contains only ?LHS0 structs defined at
     by the same 'fix' and bound to combinators: the corresponding ?RHS0
     is a combinator.  For example, in the recordised code:

          (bind ((a ?RHS-A) (b ?RHS-B))
            (fix ((f (closure-maker (lambda () (constant 3))
                                    no-freevars))
                  (g (closure-maker (lambda () (funcall f))
                                    (freevars: f))))
              ?BODY))

     the function bound to 'f' has no free variables, so it is a
     combinator; the function bound to 'g' has 'f' in its list of free
     variables; the value of 'f' is known at compile-time, so the
     closure maker of 'g' does not need to capture a free variable's
     run-time value, so the function 'g' is a combinator too.

   * If every list of free variables contains only ?LHS0 structs defined
     by the same 'fix': all the corresponding ?RHS0 are combinators.
     For example, in the recordised code:

          (bind ((a ?RHS-A) (b ?RHS-B))
            (fix ((f (closure-maker (lambda () (funcall g))
                                    (freevars: g)))
                  (g (closure-maker (lambda () (funcall f))
                                    (freevars: f))))
              ?BODY))

     both the functions have lists of free variables including only
     'var' structs defined by the same 'fix'; the values of the free
     variables is known at compile-time, so the closure makers do not
     need to capture the free variables' run-time values, so both the
     functions are combinators.

   * If a list of free variables contains a ?LHS0 struct bound to a
     non-combinator, the corresponding ?RHS0 is a non-combinator too.
     For example, in the recordised code:

          (bind ((a ?RHS-A) (b ?RHS-B))
            (fix ((f (closure-maker (lambda () a)
                                    (freevars: a)))
                  (g (closure-maker (lambda () (funcall f))
                                    (freevars: f))))
              ?BODY))

     the function bound to 'f' is a non-combinator; the function bound
     to 'g' has 'f' in its free variables list; the value of 'f'
     includes the run-time value of 'a', so the value of the free
     variable 'f' is known only at run-time, so the closure maker of 'g'
     must capture the run-time value, so the function 'g' is a
     non-combinator too.


File: vicare-scheme.info,  Node: compiler lifting optimisation,  Next: compiler lifting examples,  Prev: compiler lifting combinators,  Up: compiler lifting

17.20.4 Optimisation of combinator calls
----------------------------------------

If a Scheme function is a combinator it does not need to capture the
current value of any binding; this means we can adopt two opposite
strategies of implementation:

   * For every combinator function definition: we might create a single
     closure object at compile-time and use it everywhere the function
     is referenced.  We create a combinator closure object and keep it
     in memory even when the running Scheme process never uses the
     function.

   * For every reference to combinator function: we might create a
     different closure object at compile-time.  We delay the creation of
     a closure object until the combinator function is actually
     referenced by the running Scheme process.

this compiler pass, as implemented by Vicare, assumes that delaying the
creation of combinator closure objects is advantageous.  As example, the
core language expression:

     (let ((f (lambda () '1)))
        ((primitive list) (f) (f)))

is transformed into:

     (codes
      ((lambda (label: asmlabel:f:clambda) () (constant 1)))
      (funcall (primref list)
        (jmpcall asmlabel:f:clambda:case-0
                 (closure-maker (code-loc asmlabel:f:clambda)
                                no-freevars))
        (jmpcall asmlabel:f:clambda:case-0
                 (closure-maker (code-loc asmlabel:f:clambda)
                                no-freevars))))

where multiple 'closure-maker' structs are introduced for the same
function.

   The fact that we introduce multiple 'closure-maker' structs to create
closure objects with the same 'clambda' implementation, takes advantage
of the R6RS statement that we cannot assume Scheme functions are 'eq?'
to themselves:

     (define (func) ?BODY)
     (eq? func func) => unspecified

for example, the following core language form:

     (let ((a (lambda () '1)))
       ((primitive eq?) a a))

is transformed into:

     (codes
       ((lambda (label: asmlabel:a:clambda) () (constant 1)))
       (funcall (primref eq?)
         (closure-maker (code-loc asmlabel:a:clambda) no-freevars)
         (closure-maker (code-loc asmlabel:a:clambda) no-freevars)))

further transformations of the code might recognise the operands of
'eq?' as being references to the same function, but in more complex
cases this may not happen.


File: vicare-scheme.info,  Node: compiler lifting examples,  Next: compiler lifting substitutions,  Prev: compiler lifting optimisation,  Up: compiler lifting

17.20.5 Examples of combinators and non-combinators
---------------------------------------------------

Let's consider some examples of code creating a function and reason
about the function being a combinator or a non-combinator; in these
examples function integration has been disabled.

Standalone combinator
.....................

This core language expression:

     (lambda () ((primitive read)))

is transformed into:

     (codes
       ((lambda (label: asmlabel:anonymous:clambda)
          () (funcall (primref read))))
       (closure-maker (code-loc asmlabel:anonymous:clambda)
                      no-freevars))

the returned function looks like it is closed upon the binding 'read',
but in truth 'read' is a primitive function whose value is known at
compile-time; so the returned function is a combinator.

Simple combinators definition
.............................

This core language expression:

     (let ((f (lambda () '1))
           (g (lambda () '2)))
       ((primitive list) (f) (g)))

defines two combinator functions; the 'closure-maker' struct is
introduced at the functions' call site:

     (codes
       ((lambda (label: asmlabel:g:clambda) () (constant 2))
        (lambda (label: asmlabel:f:clambda) () (constant 1)))
       (funcall (primref list)
         (jmpcall asmlabel:f:clambda:case-0
                  (closure-maker (code-loc asmlabel:f:clambda)
                                 no-freevars))
         (jmpcall asmlabel:g:clambda:case-0
                  (closure-maker (code-loc asmlabel:g:clambda)
                                 no-freevars))))

Multiple calls to single combinator
...................................

This core language form:

     (let ((f (lambda () '1)))
        ((primitive list) (f) (f)))

defines a combinator function; multiple 'closure-maker' structs are
introduced at the call site for the same function:

     (codes
       ((lambda (label: asmlabel:f:clambda) () (constant 1)))
       (funcall (primref list)
         (jmpcall asmlabel:f:clambda:case-0
                  (closure-maker (code-loc asmlabel:f:clambda)
                                 no-freevars))
         (jmpcall asmlabel:f:clambda:case-0
                  (closure-maker (code-loc asmlabel:f:clambda)
                                 no-freevars))))

Non-combinator definition
.........................

In the core language expression:

     (let ((a ((primitive read))))
       (lambda () a))

the returned function is a non-combinator because its return value
depends upon the value of the binding 'a' at the time the closure object
is created; 'a' is a free variable in the body of the function and the
function is closed upon it.  Indeed such form is transformed into:

     (codes
       ((lambda (label: asmlabel:anonymous:clambda) () a_0))
       (bind ((a_0 (funcall (primref read))))
         (fix ((tmp_0 (closure-maker
                        (code-loc asmlabel:anonymous:clambda)
                        (freevars: a_0))))
           tmp_0)))

Multiple calls to non-combinator
................................

In this example a single non-combinator is called twice:

     (let ((a ((primitive read))))
       (let ((f (lambda () a)))
         ((primitive list) (f) (f))))

the result of the transformation is:

     (codes
       ((lambda (label: asmlabel:f:clambda) () a_0))
       (bind ((a_0 (funcall (primref read))))
         (fix ((f_0 (closure-maker (code-loc asmlabel:f:clambda)
                                   (freevars: a_0))))
           (funcall (primref list)
                    (jmpcall asmlabel:f:clambda:case-0 f_0)
                    (jmpcall asmlabel:f:clambda:case-0 f_0)))))

we see that a single 'closure-maker' is introduced.

Recursive combinator and non-combinator
.......................................

A self reference in a recursive function does not necessarily make it a
non-combinator.  For example:

     (letrec ((f (lambda () (f))))
       ?BODY)

is transformed into:

     (codes
       ((lambda (label: asmlabel:f:clambda) ()
          (jmpcall asmlabel:f:clambda:case-0
                   (closure-maker (code-loc asmlabel:f:clambda)
                                  no-freevars))))
       (closure-maker (code-loc asmlabel:f:clambda) no-freevars))

there are no free variables other than the recursive reference, so the
function is a combinator.  Conversely, in the expression:

     (let ((a ((primitive read))))
       (letrec ((f (lambda (x) (f a))))
         (f '1)))

in addition to the self reference there is a non-removable free
variable, so the result of the transformation is:

     (codes
       ((lambda (label: asmlabel:f:clambda) (x_0)
           (jmpcall asmlabel:f:clambda:case-1 f_0 a_0)))
       (bind ((a_0 (funcall (primref read))))
         (fix ((f_0 (closure-maker (code-loc asmlabel:f:clambda)
                                   (freevars: a_0))))
           (jmpcall asmlabel:f:clambda:case-1 f_0 (constant 1)))))

Cycle of combinator calls
.........................

In this expression functions defined at the same lexical contour call
each other in a cycle:

     (letrec* ((a (lambda () (d)))
               (b (lambda () (a)))
               (c (lambda () (b)))
               (d (lambda () (c))))
       ((primitive list) (a) (b) (c) (d)))

there are no true free variables, so all the functions are implemented
as combinators:

     (codes
      ((lambda (label: asmlabel:a:clambda) ()
          (jmpcall asmlabel:d:clambda:case-0
                   (closure-maker (code-loc asmlabel:d:clambda)
                                  no-freevars)))
       (lambda (label: asmlabel:d:clambda) ()
          (jmpcall asmlabel:c:clambda:case-0
                   (closure-maker (code-loc asmlabel:c:clambda)
                                  no-freevars)))
       (lambda (label: asmlabel:c:clambda) ()
          (jmpcall asmlabel:b:clambda:case-0
                   (closure-maker (code-loc asmlabel:b:clambda)
                   no-freevars)))
       (lambda (label: asmlabel:b:clambda) ()
          (jmpcall asmlabel:a:clambda:case-0
                   (closure-maker (code-loc asmlabel:a:clambda)
                   no-freevars))))
      (funcall (primref list)
        (jmpcall asmlabel:a:clambda:case-0
                 (closure-maker (code-loc asmlabel:a:clambda)
                                no-freevars))
        (jmpcall asmlabel:b:clambda:case-0
                 (closure-maker (code-loc asmlabel:b:clambda)
                                no-freevars))
        (jmpcall asmlabel:c:clambda:case-0
                 (closure-maker (code-loc asmlabel:c:clambda)
                                no-freevars))
        (jmpcall asmlabel:d:clambda:case-0
                 (closure-maker (code-loc asmlabel:d:clambda)
                 no-freevars))))

Cycle of non-combinator calls
.............................

In this expression functions defined at the same lexical contour call
each other in a cycle; one of them has a true free variable, causing all
of them to be non-combinators:

     (let ((v ((primitive read))))
       (letrec* ((a (lambda (x) (d x)))
                 (b (lambda (x) (a x)))
                 (c (lambda (x) (b x)))
                 (d (lambda (x) (c v))))
         ((primitive list) (a '1) (b '2) (c '3) (d '4))))

the result of the transformation is:

     (codes
      ((lambda (label: asmlabel:a:clambda) (x_0)
          (jmpcall asmlabel:d:clambda:case-1 d_0 x_0))
       (lambda (label: asmlabel:d:clambda) (x_1)
          (jmpcall asmlabel:c:clambda:case-1 c_0 v_0))
       (lambda (label: asmlabel:c:clambda) (x_2)
          (jmpcall asmlabel:b:clambda:case-1 b_0 x_2))
       (lambda (label: asmlabel:b:clambda) (x_3)
          (jmpcall asmlabel:a:clambda:case-1 a_0 x_3)))
      (bind ((v_0 (funcall (primref read))))
        (fix ((a_0 (closure-maker (code-loc asmlabel:a:clambda)
                                  (freevars: d_0)))
              (d_0 (closure-maker (code-loc asmlabel:d:clambda)
                                  (freevars: c_0 v_0)))
              (c_0 (closure-maker (code-loc asmlabel:c:clambda)
                                  (freevars: b_0)))
              (b_0 (closure-maker (code-loc asmlabel:b:clambda)
                                  (freevars: a_0))))
          (funcall (primref list)
            (jmpcall asmlabel:a:clambda:case-1 a_0 (constant 1))
            (jmpcall asmlabel:b:clambda:case-1 b_0 (constant 2))
            (jmpcall asmlabel:c:clambda:case-1 c_0 (constant 3))
            (jmpcall asmlabel:d:clambda:case-1 d_0 (constant 4))))))


File: vicare-scheme.info,  Node: compiler lifting substitutions,  Next: compiler lifting api,  Prev: compiler lifting examples,  Up: compiler lifting

17.20.6 Substitution optimisations
----------------------------------

This compiler pass performs substitutions of binding references with the
purpose of optimising their implementation.  One of the possible results
is to reduce the number of free variables non-combinator functions are
closed upon; if all the free variables are removed: some non-combinator
functions can be implemented as combinators.

Substituting references to combinators
......................................

This has already been discussed.  Whenever a function is recognised to
be a combinator: every reference to it is substituted with a form
building and returning a new closure object; as example, the core
language form:

     (let ((f (lambda () '1)))
       (f))

is transformed into:

     (codes
       ((lambda (label: asmlabel:f:clambda) () (constant 1)))
       (jmpcall asmlabel:f:clambda:case-0
                (closure-maker (code-loc asmlabel:f:clambda)
                               no-freevars)))

Synonym variables substitution
..............................

In the following core language expression:

     (let ((a ((primitive read))))
       (let ((b a))
         b))

the binding 'b' is a synonym for 'a', so it is transformed into:

     (codes
       ()
       (bind ((a_0 (funcall (primref read))))
         a_0))

   In the following recordised code:

     (fix ((a_0 (lambda () ?BODY)))
       (bind ((b_0 a_0))
         (fix ((c_0 (lambda () (funcall b_0))))
           c_0)))

the returned value looks like a closure upon the binding 'b_0', but in
truth it is known at compile-time that 'b_0' is an immutable binding
referencing a 'clambda' struct and also which 'clambda' is referenced;
so the function bound to 'c_0' is just a combinator; more: everywhere a
reference to 'b_0' appears we can substitute it with a reference to
'a_0', and so we can transform the code to:

     (fix ((a_0 (lambda () ?BODY)))
       (bind ((b_0 a_0))
         (fix ((c_0 (lambda () (funcall a_0))))
           c_0)))

     *NOTE* While synonym binding elimination is performed by this
     compiler pass: it should have already been performed by the source
     optimiser.


File: vicare-scheme.info,  Node: compiler lifting api,  Prev: compiler lifting substitutions,  Up: compiler lifting

17.20.7 'clambda' lifting API
-----------------------------

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-optimize-combinator-calls/lift-clambdas INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a struct instance representing recordised code
     in the core language, and building a new hierarchy of transformed,
     recordised code; return a 'codes' struct.

     Perform 'clambda' lifting and optimisation of calls to functions
     without free variables.


File: vicare-scheme.info,  Node: compiler primopcalls,  Next: compiler freevar refs,  Prev: compiler lifting,  Up: compiler

17.21 Introducing primitive operation calls
===========================================

The purpose of this compiler pass is to examine all the function calls:

     (?OPERATOR ?OPERAND ...)

which, in recordized code, are represented by struct instances of type
'funcall'; everything else is left untouched.  If the ?OPERATOR is a
struct instance of type 'primref' representing a primitive operation:
such struct is replaced by an appropriate struct instance of type
'primopcall'.  So recordised code like:

     (funcall (primref ?NAME) (?OPERAND ...))

is transformed into:

     (primopcall ?NAME (?OPERAND ...))

   If the 'funcall' struct represents a call to a proper lexical core
primitive function (not operation): it is left untouched as 'funcall'
struct.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-introduce-primitive-operation-calls INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a 'codes' struct representing recordised code;
     build and return a new 'codes' struct.

     Transform 'funcall' structs representing core primitive operation
     applications into 'primopcall' structs.

   As example, 'list' is both a lexical core function and a core
primitive operation which must return a new list at each invocation; so
the core language expression:

     ((primitive list) '1 '2)

is transformed into:

     (codes
       ()
       (primopcall list (constant 1) (constant 2)))


File: vicare-scheme.info,  Node: compiler freevar refs,  Next: compiler engine,  Prev: compiler primopcalls,  Up: compiler

17.22 Rewriting references to free variables
============================================

This compiler pass rewrites references to free variables in closure
objects to forms actually accessing the values from the run-time closure
object.

   We know that a Scheme closure object (satisfiying the predicate
'procedure?') has memory layout:

                     0   1   2   3   4   5
      |------------|---|---|---|---|---|---| closure object
            ^
            |      |.......................|
       pointer to     one slot for every
       binary code    free variable

the purpose of this compiler pass is to replace references to free
variables with 'primopcall' structs representing the use of the
primitive operation '$cpref'.

   In addition, it transforms every 'closure-maker' not appearing as
right-hand side expression of a 'fix' into:

     (fix ((tmp ?closure-maker))
       tmp)

this is an independent task that must be performed somewhere, and we do
it here.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-rewrite-freevar-references INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a 'codes' struct representing recordised code;
     build and return a new 'codes' struct.

     Introduce primitive calls to the primitive operation '$cpref' to
     access free variables in closure objects.

   As example, the core language expression:

     (let ((a ((primitive read))))
       (lambda () a))

is transformed into:

     (codes
       ((lambda (label: asmlabel:anonymous:clambda) (cp_0)
          (primopcall $cpref cp_0 (constant 0))))
       (bind ((a_0 (funcall (primref read))))
         (fix ((tmp_0 (closure-maker
                         (code-loc asmlabel:anonymous:clambda)
                         (freevars: a_0))))
           tmp_0)))

and the following core language expression, defining an assigned free
variable:

     (let ((a ((primitive read))))
       (lambda ()
         (begin
           (set! a '1)
           a)))

is transformed into:

     (codes
      ((lambda (label: asmlabel:anonymous:clambda) (cp_0)
          (seq
            (primopcall $vector-set!
                       (primopcall $cpref cp_0 (constant 0))
                       (constant 0)
                       (constant 1))
            (primopcall $vector-ref
                       (primopcall $cpref cp_0 (constant 0))
                       (constant 0)))))
      (bind ((a_0 (funcall (primref read))))
        (bind ((a_1 (primopcall vector a_0)))
          (fix ((tmp_0 (closure-maker
                          (code-loc asmlabel:anonymous:clambda)
                          (freevars: a_1))))
            tmp_0))))


File: vicare-scheme.info,  Node: compiler engine,  Next: compiler stack,  Prev: compiler freevar refs,  Up: compiler

17.23 Inserting engine checks
=============================

This compiler pass traverses all the function bodies and, if the body
contains at least one 'jmpcall' struct or one 'funcall' struct (in which
the operator is *not* a 'primref'), it transforms the ?BODY into:

     (seq
       (primopcall $do-event ())
       ?BODY)

the call to the primitive operation '$do-event' suspends the execution
of Scheme code for the current internal process and enters an internal
subprocess which can take actions asynchronously.

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-insert-engine-checks INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a 'codes' struct representing recordised code;
     build and return a new 'codes' struct.

     Insert calls to the primitive operation '$do-event' when
     appropriate.


File: vicare-scheme.info,  Node: compiler stack,  Next: compiler cogen,  Prev: compiler engine,  Up: compiler

17.24 Inserting stack overflow checks
=====================================

This compiler pass traverses all the function bodies and: if a ?BODY
contains code that will cause further use of the Scheme stack, it
transforms it as follows:

     (seq
       (primopcall $stack-overflow-check ())
       ?BODY)

so that, right after entering the execution of a function, the call to
the primitive operation '$stack-overflow-check' checks if the current
Scheme stack is about to be exhausted.  If a ?BODY does not make further
use of the stack: its function execution is a "stack tail".

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-insert-stack-overflow-check INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a 'codes' struct representing recordised code;
     build and return a new 'codes' struct.

     Insert calls to the primitive operation '$stack-overflow-check'
     when appropriate.


File: vicare-scheme.info,  Node: compiler cogen,  Next: compiler assember,  Prev: compiler stack,  Up: compiler

17.25 Full assembly code generation
===================================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-code-generation INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a 'codes' struct representing recordised code;
     build and return a new 'codes' struct.

* Menu:

* compiler cogen primop::       Expanding primitive operations.
* compiler cogen order::        Imposing calling convention and
                                evaluation order.
* compiler cogen frame::        Assigning frame sizes.
* compiler cogen color::        Colorising by Chaitin.
* compiler cogen flatten::      Flattening codes.


File: vicare-scheme.info,  Node: compiler cogen primop,  Next: compiler cogen order,  Up: compiler cogen

17.25.1 Expanding primitive operations
--------------------------------------

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-specify-representation INPUT
     Perform code transformation traversing the whole hierarchy in
     INPUT, which must be a 'codes' struct representing recordised code;
     build and return a new 'codes' struct.


File: vicare-scheme.info,  Node: compiler cogen order,  Next: compiler cogen frame,  Prev: compiler cogen primop,  Up: compiler cogen

17.25.2 Imposing calling convention and evaluation order
--------------------------------------------------------

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-impose-calling-convention/evaluation-order INPUT


File: vicare-scheme.info,  Node: compiler cogen frame,  Next: compiler cogen color,  Prev: compiler cogen order,  Up: compiler cogen

17.25.3 Assigning frame sizes
-----------------------------

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-assign-frame-sizes INPUT


File: vicare-scheme.info,  Node: compiler cogen color,  Next: compiler cogen flatten,  Prev: compiler cogen frame,  Up: compiler cogen

17.25.4 Colorising by Chaitin
-----------------------------

For an introduction to register allocation see:

          <http://en.wikipedia.org/wiki/Register_allocation>

   The following bindings are exported by the library '(vicare
compiler)'.

 -- Function: pass-color-by-chaitin INPUT


File: vicare-scheme.info,  Node: compiler cogen flatten,  Prev: compiler cogen color,  Up: compiler cogen

17.25.5 Flattening codes
------------------------

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: pass-flatten-codes INPUT


File: vicare-scheme.info,  Node: compiler assember,  Prev: compiler cogen,  Up: compiler

17.26 Binary code generation
============================

The following bindings are exported by the library '(vicare compiler)'.

 -- Function: assemble-sources INPUT


File: vicare-scheme.info,  Node: boot image,  Next: missing,  Prev: compiler,  Up: Top

18 Anatomy of the boot image
****************************

The boot image is for Vicare what the basic run-time system, the dynamic
library linker and the C Standard library are for the C language.

   The boot image is a binary file in which the Scheme objects are
serialised with the same format of FASL files representing compiled
libraries (*note fasl::).  The source code of the boot image is a set of
Scheme libraries as defined by R6RS, with Vicare extensions; its
compiled and serialised representation has the layout:

      header library header library header library header library ...
     |------|-------|------|-------|------|-------|------|-------|---

where:

   * The 'header' is the ASCII string '#@IK0', followed by the ASCII
     character '1' on 32-bit platforms or the ASCII character '2' on
     64-bit platforms; the end of fasl marker is '@'.

   * The 'library' is a contiguous sequence of serialised Scheme objects
     representing a compiled library.


File: vicare-scheme.info,  Node: missing,  Next: building,  Prev: boot image,  Up: Top

Appendix A Missing Features
***************************

Vicare does not fully conform to R6RS yet.  Although it implements most
of R6RS's macros and procedures, some are still missing.  This appendix
summarizes the set of missing features and procedures.

   * 'number->string' does not accept the third argument (precision).
     Similarly, 'string->number' and the reader do not recognize the
     '|p' notation.


File: vicare-scheme.info,  Node: building,  Next: credits,  Prev: missing,  Up: Top

Appendix B Building infrastructure
**********************************

This appendix contains instructions on how to use and modify the
building infrastructure of Vicare Scheme.  The source of the package is
manage by a Git repository, so some bits of the infrastructure depend on
Git.

* Menu:

* building revision::           Package revision in the banner.


File: vicare-scheme.info,  Node: building revision,  Up: building

B.1 Package revision in the banner
==================================

When running 'vicare' in a terminal, it prints a banner showing the
revision number:

     $ vicare
     Vicare Scheme version 0.1d0+ \
       (revision master/21da24720f161708372756e1324c230bd5ff6ac9, \
        build 2010-05-01)
     Copyright (c) 2006-2010 Abdulaziz Ghuloum

   The revision specification shows the branch name and the commit hash;
they are read from the file './scheme/last-revision', which is generated
by the following chunk of code in the '.git/hooks/post-commit' script:

     LAST_REVISION_FILE=./scheme/last-revision
     BRANCH_NAME=$(git branch 2>/dev/null | \
                     sed -e '/^[^*]/d' -e 's/^* //')
     COMMIT_HASH=$(git show | head -1 | cut -d' ' -f2)
     echo "$BRANCH_NAME/$COMMIT_HASH" >$LAST_REVISION_FILE


File: vicare-scheme.info,  Node: credits,  Next: dynamic environment,  Prev: building,  Up: Top

Appendix C Credits for this document
************************************

The skeleton of this document is the original "Ikarus User's Guide" in
XeLaTeX format, by Abdulaziz Ghulom.  That document is available in the
Ikarus distribution and is covered by the GNU General Public License
version 3 as published by the Free Software Foundation.  It is available
at the following URLs:

             <http://www.cs.indiana.edu/~aghuloum/ikarus/>
                    <https://launchpad.net/ikarus>

Documentation: language definition, base and standard library
.............................................................

The chapters *note The Scheme language: scheme, *note Base library:
baselib. and *note Standard library: stdlib. are derived from the
original "Revised^6 Report on the Algorithmic Language Scheme" document
and the original "Revised^6 Report on the Algorithmic Language Scheme
--- Standard Libraries", authored by the following people:

     MICHAEL SPERBER
     R. KENT DYBVIG, MATTHEW FLATT, ANTON VAN STRAATEN
     (Editors)

     RICHARD KELSEY, WILLIAM CLINGER, JONATHAN REES
     (Editors, Revised^5 Report on the Algorithmic Language Scheme)

     ROBERT BRUCE FINDLER, JACOB MATTHEWS
     (Authors, formal semantics)

with various contributions by the following people:

     Hal Abelson, Norman Adams, David Bartley, Gary Brooks, William
     Clinger, Daniel Friedman, Robert Halstead, Chris Hanson,
     Christopher Haynes, Eugene Kohlbecker, Don Oxley, Kent Pitman,
     Jonathan Rees, Guillermo Rozas, Guy L. Steele Jr., Gerald Jay
     Sussman, and Mitchell Wand.

and a lot of discussions and debates by the Scheme community.  According
to the following quotation from the original document:

     We intend this report to belong to the entire Scheme community, and
     so we grant permission to copy it in whole or in part without fee.
     In particular, we encourage implementors of Scheme to use this
     report as a starting point for manuals and other documentation,
     modifying it as necessary.

the documents are meant to be in the public domain.  They are available
at:

                        <http://www.r6rs.org/>
                <http://www.r6rs.org/r6rs-errata.html>


File: vicare-scheme.info,  Node: dynamic environment,  Next: resources,  Prev: credits,  Up: Top

Appendix D Notes on the dynamic environment
*******************************************

In this section we inspect, by examples, the concepts of "dynamic
environment" and "dynamic extent of a function call".  *note Dynamic
extent and the dynamic environment: scheme basic dynamic extent, for the
meaning as defined by R6RS.

* Menu:

* dynamic environment intro::   Introduction to the concept of dynamic
                                environment.
* dynamic environment parms::   Parameters: the archetype of state in
                                the dynamic environment.
* dynamic environment extent::  The dynamic extent of a function call.
* dynamic environment guard::   On the implementation of 'guard'.
* dynamic environment except::  More cases of exception handling.


File: vicare-scheme.info,  Node: dynamic environment intro,  Next: dynamic environment parms,  Up: dynamic environment

D.1 Introduction to the concept of dynamic environment
======================================================

The dynamic environment is a subset of the state of a 'vicare' process
that is maintained with the in-guard and out-guard thunks of
'dynamic-wind'.

   Let's consider the following program prelude:

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define var)

     (define (step id)
       (add-result (list id var))
       (++ var))

     (define-syntax dotimes
       (syntax-rules ()
         ((_ ?count . ?body)
          (do ((i 0 (+ 1 i)))
              ((= i ?count))
            . ?body))
         ))

we can call the function 'step' to access and mutate the current value
of the variable 'var'; 'dotimes' is a simple macro that evaluates a body
a number of times.  For example we can do:

     (define (doit id init)
       (set! var init)
       (dotimes 5
         (step id)))

     (with-result
       (doit 'single 0)
       1)
     => (1 ((single 0)
            (single 1)
            (single 2)
            (single 3)
            (single 4)))

this program does not define a dynamic environment.

   Now, with the same prelude, let's consider the following code making
use of coroutines:

     (define (doit id init)
       (define local-var)
       (coroutine
           (lambda ()
             (dynamic-wind
                 (lambda ()
                   (set! var local-var))
                 (lambda ()
                   (set! var init)
                   (dotimes 5
                     (step id)
                     (yield)))
                 (lambda ()
                   (set! local-var var))))))

     (with-result
       (doit 'one  0)
       (doit 'two 10)
       (finish-coroutines)
       1)
     => (1 ((one 0) (two 10)
            (one 1) (two 11)
            (one 2) (two 12)
            (one 3) (two 13)
            (one 4) (two 14)))

this program defines a dynamic environment:

   * The in-guard thunk stores in 'var' the local value 'local-var':

          (lambda ()
            (set! var local-var))

   * The out-guard thunk saves in 'local-var' the global value 'var':

          (lambda ()
            (set! local-var var))

this way the function 'step' called by the body thunk of 'dynamic-wind'
accesses and mutates a variable 'var' that holds a value "private" to
the coroutine.

The current exception handler
-----------------------------

The standard 'with-exception-handler' uses the same mechanism to install
in the dynamic environment the current exception handler.  The following
program shows how 'with-exception-handler' transparently installs as
handler a closure for each coroutine:

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define-syntax dotimes
       (syntax-rules ()
         ((_ ?count . ?body)
          (do ((i 0 (+ 1 i)))
              ((= i ?count))
            . ?body))
         ))

     (define (doit name init)
       (define X init)
       (coroutine
           (lambda ()
             (with-exception-handler
                 (lambda (E)
                   (++ X))
               (lambda ()
                 (dotimes 5
                   (add-result (list name
                                     (raise-continuable (void))))
                   (yield)))))))

     (with-result
       (doit 'one 0)
       (doit 'two 10)
       (finish-coroutines)
       1)
     => (1 ((one 1) (two 11)
            (one 2) (two 12)
            (one 3) (two 13)
            (one 4) (two 14)
            (one 5) (two 15)))


File: vicare-scheme.info,  Node: dynamic environment parms,  Next: dynamic environment extent,  Prev: dynamic environment intro,  Up: dynamic environment

D.2 Parameters: the archetype of state in the dynamic environment
=================================================================

Parameters are the perfect example of using the dynamic environment to
define a state that is "local" to the dynamic extent of a function call;
*note iklib parameters::, for details.

   The following example shows how in a call:

     (with-exception-handler ?HANDLER ?THUNK)

the ?HANDLER is called in the dynamic environment of the call to ?THUNK,
so that it can access the dynamic environment that contributed to cause
the exception:

     (import (vicare))

     (define parm
       (make-parameter #f))

     (parametrise ((parm 'outer-parm))
       (with-exception-handler
           (lambda (E)
             (parm))
         (lambda ()
           (parametrise ((parm 'inner-parm))
             (raise-continuable 2)))))
     => inner-parm

   The following example shows how 'parametrise' causes the value of the
parameter to be "local" to a coroutine:

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

     (define-syntax dotimes
       (syntax-rules ()
         ((_ ?count . ?body)
          (do ((i 0 (+ 1 i)))
              ((= i ?count))
            . ?body))
         ))

     (define parm
       (make-parameter #f))

     (define (doit name init)
       (parametrise ((parm init))
         (coroutine
             (lambda ()
               (dotimes 5
                 (add-result (list name (parm)))
                 (parm (++ (parm)))
                 (yield))))))

     (with-result
        (doit 'one  0)
        (doit 'two 10)
        (finish-coroutines)
        1)
     => (1 ((one 0) (two 10)
            (one 1) (two 11)
            (one 2) (two 12)
            (one 3) (two 13)
            (one 4) (two 14)))


File: vicare-scheme.info,  Node: dynamic environment extent,  Next: dynamic environment guard,  Prev: dynamic environment parms,  Up: dynamic environment

D.3 The dynamic extent of a function call
=========================================

The dynamic environment is maintained by the standard function
'dynamic-wind', which has the arguments:

     (dynamic-wind IN-GUARD THUNK OUT-GUARD)

the thunk IN-GUARD is called every time the execution flow enters the
dynamic extent of the call to THUNK; the thunk OUT-GUARD is called every
time the execution flow exits the dynamic extent of the call to THUNK.

   When we call 'dynamic-wind': the IN-GUARD and OUT-GUARD thunks are
pushed on a stack referenced by an internal Vicare global variable.
Whenever we save the current continuation by calling 'call/cc': such
internal stack is stored in the state of the created continuation.

   We always create the dynamic extent of a function call by calling the
function; then, by saving continuations, we can enter and exit the
dynamic extent any number of times.  Let's try to understand what this
means.

   * The simple way to enter and exit the dynamic extent of a call to
     THUNK is the call and return:

          (import (vicare))

          (with-result
            (dynamic-wind
                (lambda ()
                  (add-result 'in-guard))
                (lambda ()
                  (add-result 'thunk)
                  1)
                (lambda ()
                  (add-result 'out-guard))))
          => (1 (in-guard thunk out-guard))

   * A more sophisticated way to exit the dynamic extent is to call an
     escape procedure that reinstates a previously saved continuation:

          (import (vicare))

          (with-result
            (call/cc
                (lambda (escape)
                  (dynamic-wind
                      (lambda ()
                        (add-result 'in-guard))
                      (lambda ()
                        (add-result 'thunk-in)
                        (escape 2)
                        (add-result 'thunk-out)
                        1)
                      (lambda ()
                        (add-result 'out-guard))))))
          => (2 (in-guard thunk-in out-guard))

     in this example THUNK is called but it never performs a normal
     function return.

   * If we want to abort a dynamic extent by raising an exception: from
     the installed exception handler we must call an escape procedure
     that reinstates a previously saved continuation.

          (import (vicare))

          (with-result
            (call/cc
                (lambda (escape)
                  (with-exception-handler
                      (lambda (E)
                        (add-result 'handler)
                        (escape E))
                    (lambda ()
                      (dynamic-wind
                          (lambda ()
                            (add-result 'in-guard))
                          (lambda ()
                            (add-result 'thunk-in)
                            (raise 2)
                            (add-result 'thunk-out)
                            1)
                          (lambda ()
                            (add-result 'out-guard))))))))
          => (2 (in-guard thunk-in handler out-guard))

   * The coroutines infrastructure saves continuations to enter and exit
     dynamic extents any number of times, hiding the complexities.

          (import (vicare))

          (with-result
            (coroutine
                (lambda ()
                  (dynamic-wind
                      (lambda ()
                        (add-result '(1 in-guard)))
                      (lambda ()
                        (add-result '(1.1 thunk))
                        (yield)
                        (add-result '(1.2 thunk))
                        (yield)
                        (add-result '(1.3 thunk)))
                      (lambda ()
                        (add-result '(1 out-guard))))))

            (coroutine
                (lambda ()
                  (dynamic-wind
                      (lambda ()
                        (add-result '(2 in-guard)))
                      (lambda ()
                        (add-result '(2.1 thunk))
                        (yield)
                        (add-result '(2.2 thunk))
                        (yield)
                        (add-result '(2.3 thunk)))
                      (lambda ()
                        (add-result '(2 out-guard))))))

            (finish-coroutines)
            1)
          => (1 ((1 in-guard) (1.1 thunk) (1 out-guard)
                 (2 in-guard) (2.1 thunk) (2 out-guard)
                 (1 in-guard) (1.2 thunk) (1 out-guard)
                 (2 in-guard) (2.2 thunk) (2 out-guard)
                 (1 in-guard) (1.3 thunk) (1 out-guard)
                 (2 in-guard) (2.3 thunk) (2 out-guard)))

   * When we invoke an escape procedure to reinstate a previously saved
     continuation: the out guards added internally are called up to the
     point where 'call/cc' was called.

          (import (vicare))

          (with-result
            (dynamic-wind
                (lambda ()
                  (add-result 'outer-in-guard))
                (lambda ()
                  (add-result 'outer-thunk-in)
                  (call/cc
                      (lambda (escape)
                        (dynamic-wind
                            (lambda ()
                              (add-result 'inner-in-guard))
                            (lambda ()
                              (add-result 'inner-thunk-in)
                              (escape)
                              (add-result 'inner-thunk-out))
                            (lambda ()
                              (add-result 'inner-out-guard)))))
                  (add-result 'outer-thunk-out)
                  1)
                (lambda ()
                  (add-result 'outer-out-guard))))
          => (1 (outer-in-guard outer-thunk-in inner-in-guard
                 inner-thunk-in
                 inner-out-guard outer-thunk-out outer-out-guard))

   About exiting from the dynamic extent of a function call, we must
acknowledge that:

   * The normal return from a function call exits its dynamic extent.

   * Calling an escape procedure from within a function call to
     reinstate a continuation outside the function, exits the dynamic
     extent of the call.

          (define (fun escape)
            (do-something)
            (escape 123)
            (do-something))

          (call/cc fun)

   * Raising a continuable or non-continuable exception from within a
     function call, by itself, does *not* exit the dynamic extent of the
     call.

          (define (fun)
            (do-something)
            ;;Does not exit the dynamic extent of the call to FUN.
            (raise 123))

   * Both the tests and expressions in the clauses of the standard
     syntax 'guard' are executed outside the extent of the 'guard' body.

   * There is *no* guarantee that: after exiting the dynamic extent of a
     function call without a normal return: such extent will be
     reentered later and continue to a normal return.


File: vicare-scheme.info,  Node: dynamic environment guard,  Next: dynamic environment except,  Prev: dynamic environment extent,  Up: dynamic environment

D.4 On the implementation of 'guard'
====================================

Vicare's implementation of the 'guard' syntax is really sophisticated
because it has to deal with both the dynamic environment requirements of
R6RS and the unwind protection mechanism defined by Vicare itself.

About the dynamic environment
-----------------------------

In a syntax use like:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1)
               (else   ?EXPR2))
       ?BODY0 ?BODY ...)

if the ?BODY raises an exception: one of the clauses will certainly be
executed because there is an 'else' clause.  The ?BODY might mutate the
dynamic environment; all the ?TEST and ?EXPR expressions must be
evaluated in the dynamic environment of the use of 'guard'.

   In a syntax use like:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1))
       ?BODY0 ?BODY ...)

if all the ?TEST expressions evaluate to false: we must re-raise the
exception using 'raise-continuable'; so the syntax is "almost"
equivalent to:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1)
               (else   (raise-continuable E)))
       ?BODY0 ?BODY ...)

but: ?BODY might mutate the dynamic environment; all the ?TEST and ?EXPR
expressions must be evaluated in the dynamic environment of the use of
'guard'; the 'raise-continuable' in the 'else' clause must be evaluated
the dynamic environment of the ?BODY.

   We must remember that, when using:

     (with-exception-handler ?HANDLER ?THUNK)

the ?HANDLER procedure is evaluated in the dynamic environment of the
?THUNK, minus the exception handler itself.  So, in pseudo-code, a
syntax use with 'else' clause must be expanded as follows:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1)
               (else   ?EXPR2))
       ?BODY0 ?BODY ...)
     ==> (save-guard-continuation
          (with-exception-handler
              (lambda (E)
                (reinstate-guard-continuation
                 (cond (?TEST0 ?EXPR0)
                       (?TEST1 ?EXPR1)
                       (else   ?EXPR2))))
            (lambda () ?BODY0 ?BODY ...)))

and, also in pseudo-code, a syntax use without 'else' clause must be
expanded as follows:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1))
       ?BODY0 ?BODY ...)
     ==> (save-guard-continuation
          (with-exception-handler
              (lambda (E)
                (save-exception-handler-continuation
                 (reinstate-guard-continuation
                  (cond (?TEST0 ?EXPR0)
                        (?TEST1 ?EXPR1)
                        (else
                         (reinstate-exception-handler-continuation
                           (raise-continuable E)))))))
            (lambda () ?BODY0 ?BODY ...)))

notice how, in the exception handler, we have to jump out and in the
dynamic environment of the exception handler itself.

About the unwind-protection mechanism
-------------------------------------

Let's focus on unwind proteciton in the case of raised exception.  When
using:

     (with-unwind-protection ?CLEANUP ?THUNK)

the ?CLEANUP is associated to the dynamic extent of the call to ?THUNK:
when the dynamic extent is terminated (as defined by Vicare) the
?CLEANUP is called.

   Vicare defines as termination event of a 'guard''s ?BODY the
execution of a 'guard''s clause that does not re-raise the exception.
For a 'guard' use like:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1)
               (else   ?EXPR2))
       ?BODY0 ?BODY ...)

we can imagine the pseudo-code:

     (guard (E (?TEST0 (run-unwind-protection-cleanups) ?EXPR0)
               (?TEST1 (run-unwind-protection-cleanups) ?EXPR1)
               (else   (run-unwind-protection-cleanups) ?EXPR2))
       ?BODY0 ?BODY ...)

and for a 'guard' use like:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1))
       ?BODY0 ?BODY ...)

we can imagine the pseudo-code:

     (guard (E (?TEST0 (run-unwind-protection-cleanups) ?EXPR0)
               (?TEST1 (run-unwind-protection-cleanups) ?EXPR1)
               (else   (raise-continuable E)))
       ?BODY0 ?BODY ...)

   By doing things this way: an exception raised by an ?EXPR does not
impede the execution of the cleanups.  If a ?TEST raises an exception
the cleanups will not be run, and there is nothing we can do about it;
?TEST expressions are usually calls to predicates that recognise the
condition type of 'E', so the risk of error is reduced.

   So, in pseudo-code, a syntax use with 'else' clause must be expanded
as follows:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1)
               (else   ?EXPR2))
       ?BODY0 ?BODY ...)
     ==> (save-guard-continuation
          (with-exception-handler
              (lambda (E)
                (reinstate-guard-continuation
                 (cond (?TEST0 (run-unwind-protection-cleanups) ?EXPR0)
                       (?TEST1 (run-unwind-protection-cleanups) ?EXPR1)
                       (else   (run-unwind-protection-cleanups) ?EXPR2))))
            (lambda () ?BODY0 ?BODY ...)))

and, also in pseudo-code, a syntax use without 'else' clause must be
expanded as follows:

     (guard (E (?TEST0 ?EXPR0)
               (?TEST1 ?EXPR1))
       ?BODY0 ?BODY ...)
     ==> (save-guard-continuation
          (with-exception-handler
              (lambda (E)
                (save-exception-handler-continuation
                 (reinstate-guard-continuation
                  (cond (?TEST0 (run-unwind-protection-cleanups) ?EXPR0)
                        (?TEST1 (run-unwind-protection-cleanups) ?EXPR1)
                        (else   (reinstate-exception-handler-continuation
                                 (raise-continuable E)))))))
            (lambda () ?BODY0 ?BODY ...)))

   But how is 'run-unwind-protection-cleanups' implemented?  To cause
the cleanups to be called we must cause an exit from the dynamic extent
of the ?THUNKs.  This is a sophisticated operation implemented as
follows:

     (define (run-unwind-protection-cleanups)
       (run-unwind-protection-cleanup-upon-exit? #t)
       (save-clause-expression-continuation
        (reinstate-exception-handler-continuation
         (reinstate-clause-expression-continuation))))

we jump in 'guard''s exception handler dynamic environment then
immediately jump out in the 'guard''s clause expression dynamic
environment.


File: vicare-scheme.info,  Node: dynamic environment except,  Prev: dynamic environment guard,  Up: dynamic environment

D.5 More cases of exception handling
====================================

Let's imagine the following prelude for all the examples in this
section:

     #!vicare
     (import (vicare)
       (only (vicare checks)
             with-result
             add-result))

   This is what happens when we raise an exception from the in-guard
thunk of a 'dynamic-wind':

     (with-result
       (call/cc
           (lambda (escape)
             (with-exception-handler
                 (lambda (E)
                   (escape E))
               (lambda ()
                 (dynamic-wind
                     (lambda ()
                       (add-result 'in-guard)
                       (raise 1))
                     (lambda ()
                       (add-result 'thunk))
                     (lambda ()
                       (add-result 'out-guard))))))))
     => (1 (in-guard))

   This is what happens when we raise an exception from the out-guard
thunk of a 'dynamic-wind':

     (with-result
       (call/cc
           (lambda (escape)
             (with-exception-handler
                 (lambda (E)
                   (escape E))
               (lambda ()
                 (dynamic-wind
                     (lambda ()
                       (add-result 'in-guard))
                     (lambda ()
                       (add-result 'thunk))
                     (lambda ()
                       (add-result 'out-guard)
                       (raise 1))))))))
     => (1 (in-guard thunk out-guard))

   This is what happens when we raise an exception from the thunk of a
'dynamic-wind' and the from the out-guard of the same:

     (with-result
       (define count 0)
       (call/cc
           (lambda (escape)
             (with-exception-handler
                 (lambda (E)
                   (add-result (list 'handler E))
                   (escape E))
               (lambda ()
                 (dynamic-wind
                     (lambda ()
                       (add-result 'in-guard))
                     (lambda ()
                       (add-result 'thunk)
                       (raise 1))
                     (lambda ()
                       (add-result 'out-guard)
                       (raise 2))))))))
     => (2 (in-guard
            thunk     (handler 1)
            out-guard (handler 2)))

the first exception is forgotten when 'escape' attempts to exit the
dynamic extent of the thunk.


File: vicare-scheme.info,  Node: resources,  Next: unicode,  Prev: dynamic environment,  Up: Top

Appendix E Allocating and releasing resources
*********************************************

In this section we do an overview of the facilities Vicare provides to
handle resource allocation and release.

   Vicare has ways to deal with releasing resources by relying on the
garbage collector; if we use such mechanisms the resource is
"asynchronous" with respect to code execution.  These are the methods
asynchronous resource handling:

   * Directly use guardians, *note Guardians and garbage collection:
     iklib guardians.

   * Wrap the reference to the resource in a Vicare data structure and
     register a finalisation function in the structure type descriptor,
     *note Finalisation of structures: syslib structs safe final.

   * Wrap the reference to the resource in a R6RS record and register a
     finalisation function in the record type descriptor, *note
     Automatic finalisation of records: iklib records final.

   Asynchronous resource management is often not good, because there is
no guarantee that a resource is released before the Vicare process
termination.  Sometimes it is better to associate the life of an
allocated resource to the dynamic extent of a call to function; if we
use such mechanism the resource is "synchronous" with respect to code
execution.  These are the methods synchronous resource handling:

   * The unwind protection mechanism; *note iklib unwind-protect::, for
     details.

   * The compensation stacks; *note iklib compensations::, for details.


File: vicare-scheme.info,  Node: unicode,  Next: fasl,  Prev: resources,  Up: Top

Appendix F On Unicode and UTF encodings
***************************************

As required by R6RS, the Scheme implementations must support Unicode
characters and input/output libraries must implement transcoders for
textual ports supporting encoding and decoding between Scheme characters
and UTF-8 and UTF-16.

   The mandatory starting points to learn about this stuff are the
following (URLs last verified on Sep 9, 2011):

               <http://www.unicode.org/faq/utf_bom.html>
        <http://en.wikipedia.org/wiki/Universal_Character_Set>
                <http://en.wikipedia.org/wiki/Unicode>
            <http://en.wikipedia.org/wiki/Byte_order_mark>
                 <http://en.wikipedia.org/wiki/UTF-8>
                 <http://en.wikipedia.org/wiki/UTF-16>
                 <http://en.wikipedia.org/wiki/UTF-32>

here we give only a brief overview of the main definitions, drawing text
from those pages.

   The "Universal Character Set" (UCS) is a standard set of characters
upon which many character encodings are based; it contains abstract
characters, each identified by an unambiguous name and an integer number
called its "code point".

   "Unicode" is a computing industry standard for the consistent
encoding, representation and handling of text expressed in most of the
world's writing systems.

   UCS and Unicode have an identical repertoire and numbers: the same
characters with the same numbers exist in both standards.  UCS is a
simple character map, Unicode adds rules for collation, normalization of
forms, and the bidirectional algorithm for scripts.

   The Unicode Consortium, the nonprofit organization that coordinates
Unicode's development, has the goal of eventually replacing existing
character encoding schemes with Unicode and its standard "Unicode
Transformation Format" alias "UCS Transformation Format" (UTF) schemes.

   By convention a Unicode code point is referred to by writing 'U+'
followed by its hexadecimal number with at least 4 digits ('U+0044' is
fine, 'U+12' is not).

   In practice, Unicode code points are exact integers in the range [0,
#x10FFFF], but outside the range [#xD800, #xDFFF] which has special
meaning in UTF schemes.  A code point can be stored in 21 bits:

     (string-length (number->string #x10FFFF 2)) => 21

R6RS defines fixnums to have at least 24 bits, so a fixnum is wide
enough to hold a code point:

     (fixnum? #x10FFFF) => #t

and indeed Scheme characters are a disjoint type of value holding such
fixnums:

     (integer->char #x10FFFF) => #\x10FFFF

UTF-8 scheme
............

UTF-8 is a multioctet character encoding for Unicode which can represent
every character in the Unicode set, that is it can represent every code
point in the ranges '[0, #xD800)' and '(#xDFFF, #x10FFFF]'.

   A stream of UTF-8 encoded characters is meant to be stored octet by
octet in fixed order (and so without the need to specify the endianness
of words).

   The encoding scheme uses sequences of 1, 2, 3 or 4 octets to encode a
each code point as shown in the following table; the first octet in a
sequence has a unique bit pattern in the most significant bits and so it
allows the determination of the sequence length; every octet contains a
number of payload bits which must be concatenated (bitwise inclusive OR)
to reconstruct the integer representation of a code point:

     | # of octets | 1st octet | 2nd octet | 3rd octet | 4th octet |
     |-------------+-----------+-----------+-----------+-----------|
     |     1        #b0xxxxxxx
     |     2        #b110xxxxx  #b10xxxxxx
     |     3        #b1110xxxx  #b10xxxxxx  #b10xxxxxx
     |     4        #b11110xxx  #b10xxxxxx  #b10xxxxxx  #b10xxxxxx

     | # of octets | # of payload bits |       hex range     |
     |-------------+-------------------+---------------------|
     |     1                         7    [#x0000,   #x007F]
     |     2                5 + 6 = 11    [#x0080,   #x07FF]
     |     3            4 + 6 + 6 = 16    [#x0800,   #xFFFF]
     |     4        3 + 6 + 6 + 6 = 21  [#x010000, #x10FFFF]

   Note that octets '#xFE' and '#xFF' cannot appear in a valid stream of
UTF-8 encoded characters.  The sequence of 3 octets is the one that
could encode (but must not) the forbidden range '[#xD800, #xDFFF]'.

   The first 128 characters of the Unicode character set correspond
one-to-one with ASCII and are encoded using a single octet with the same
binary value as the corresponding ASCII character, making valid ASCII
text valid UTF-8 encoded Unicode text as well.  Such encoded octets have
the Most Significant Bit (MSB) set to zero.

   Although the standard does not define it, many programs start a UTF-8
stream with a Byte Order Mark (BOM) composed of the 3 octets: '#xEF',
'#xBB', '#xBF'.

UTF-16 decoding
...............

Given a 16-bit word in a UTF-16 stream, represented in Scheme as a
fixnum in the range '[#x0000, #xFFFF]', we can classify it on the
following axis:

     0000        D7FF D800    DBFF DC00      DFFF E000       FFFF
      |-------------||-----------||-------------||------------|
       single word    first in     second in      single word
       character      pair         pair           character

or the following logic:

     word in [#x0000, #xD7FF] => single word character
     word in [#xD800, #xDBFF] => first in surrogate pair
     word in [#xDC00, #xDFFF] => second in surrogate pair
     word in [#xE000, #xFFFF] => single word character

   ISO/IEC 8859-1 also known as Latin-1

   Latin-1 uses 1 octet per character.  The first 256 Unicode code
points are identical to the content of Latin-1, the first 127 Latin-1
code points are identical to ASCII.  For an itroduction see:

             <http://en.wikipedia.org/wiki/ISO/IEC_8859-1>

   Latin-1 code points are identical to their octet encoding.

   Latin-1 code points in the range [0, 127] are identical to the same
code points encoded in both ASCII and in UTF-8.

   Latin-1 code points in the range [128, 255] are *different* from the
same code points encoded in UTF-8.

   Every octet (that is: every fixnum in the range [0, 255]) can be
interpreted as a character in Latin-1 encoding.


File: vicare-scheme.info,  Node: fasl,  Next: shmem,  Prev: unicode,  Up: Top

Appendix G Handling FASL files
******************************

FASL files are binary files in which compiled Scheme code and data is
stored; we can easily create a FASL file as follows:

     vicare> (define filename "/tmp/marco/p.fasl")
     vicare> (define p (open-file-output-port filename))
     vicare> (fasl-write '(1 ciao "hello") p)
     vicare> (close-port p)
     vicare> (define p (open-file-input-port filename))
     vicare> (fasl-read p)
     (1 ciao "hello")
     vicare> (close-port p)
     vicare>

* Menu:

* fasl format::                 Binary format of a FASL file.
* fasl api::                    FASL files API.
* fasl foreign::                Associating foreign libraries to
                                FASL files.


File: vicare-scheme.info,  Node: fasl format,  Next: fasl api,  Up: fasl

G.1 Binary format of a FASL file
================================

A FASL object is a header followed by one or more object fields followed
by an end-of-FASL marker.  After the end-of-FASL marker the file must be
at its EOF.

   The header is the string '#@IK0', followed by '1' if fixnum width is
30 bits, else followed by '2'; the end of fasl marker is '@'.

   If the same object is referenced multiple times in the FASL file: it
can be included only once and "marked" with a fixnum; such mark is later
dereferenced to insert a reference to the object in the loaded code.

   A data word is an exact signed integer of 32-bit or 64-bit depending
on the word size of the underlying platform.

   An object field is a character in ASCII encoding, optionally followed
by data representing the serialisation of a Scheme value:

"N"
     Denotes the empty list.

"T"
     Denotes '#t'.

"F"
     Denotes '#f'.

"E"
     Denotes the end of file object.

"U"
     Denotes the unspecified value (void).

"I" + word
     A fixnum stored as a big endian word.

"s" + word(N) + octet ...
     An ASCII string of N characters followed by N octets representing
     the characters in ASCII encoding.  The data word N must represent
     an exact integer in the range of fixnums.

"S" + word(N) + int32 ...
     A Unicode string of N characters followed by N 32-bit integers in
     native order representing the characters as Unicode code points.
     The data word N must represent an exact integer in the range of
     fixnums.

"M" + symbol-name
     A symbol.  'symbol-name' is a string field.

"G" + pretty-name + unique-name
     A gensym.  Both 'pretty-name' and 'unique-name' are strings.

"c" + octet
     A character in the ASCII range (<= 255).

"C" + int32
     A character stored as 32-bit integer representing a Unicode code
     point.

"P" + object1 + object2
     A pair.

"V" + word(N) + object ...
     A vector of length N followed by N object fields.  The data word N
     must represent an exact integer in the range of fixnums.

"v" + word(N) + octet ...
     A bytevector of length N followed by N octets.  The data word N
     must represent an exact integer in the range of fixnums.

"R" + rtd-name + rtd-symbol + field-count + name ...
     A struct type descriptor.  'rtd-name' must be a symbol.
     'rtd-symbol' must be a symbol.  'field-count' must be a word in the
     fixnum range.  The 'name' object fields must be symbols
     representing the field name and there must be 'field-count' of
     them.

"{" + field-count + rtd + field ...
     A structure instance.  'field-count' must be a word in the fixnum
     range.  'rtd' must be a struct type descriptor.  The 'field' object
     fields must be the fields of the structure instance and there must
     be 'field-count' of them.

"r" + denominator + numerator
     Ratnum.

"f" + 8-byte
     IEEE double precision flonum.  The bytes are stored: most
     significant first, least significant last.

"b" + word(N) + octet ...
     Denotes a bignum.  N is a signed integer word whose sign is the
     sign of the bignum and whose modulo is the number of octets
     representing the bignum.

"i" + real-part + imag-part
     Complex numbers, both cflonum and compnum.

"l" + octet(N) + object ...
     A short chain of pairs followed by its elements, including the cdr
     of the last pair; the number N <= 255 is 2 less than the number of
     elements.  As example, the list:

          (#\A . (#\B . (#\C . #\D)))

     has N = 2, so it is serialised as:

          "l" octet(2) #\A #\B #\C #\D

     As other example, the standalone pair '(#\A . #\B)' has N = 0, so
     it is serialised as:

          "l" octet(0) #\A #\B

"L" + word(N) + object ...
     A long chain of pairs followed by its elements, including the cdr
     of the last pair; the number N > 255 is 2 less than the number of
     elements.  See the format of 'l' for details.

"h" + vector + vector
     'eq?' hashtable, first vector keys, second vector values.

"H" + vector + vector
     'eqv?' hashtable, first vector keys, second vector values.

"W" + name + parent + uid + sealed? + opaque? + count + (bool + field) ...
     An R6RS record type descriptor.

     'name'
          Must be the return value of 'record-type-name'.

     'parent'
          Must be the return value of 'record-type-parent'.

     'uid'
          Must be the return value of 'record-type-uid'.

     'sealed?'
          Must be the return value of 'record-type-sealed?'.

     'opaque?'
          Must be the return value of 'record-type-opaque?'.

     'count'
          Must be a fixnum representing the number of fields.

     Each 'bool + field' sequence must be a boolean representing the
     mutability of the record field, followed by symbol representing the
     name of the record field.

"x" + int + int + annotation + bytes + relocation vector
     Denotes code.  A serialised code object is represented as follows,
     after the 'x' header:

       1. An exact integer representing the number of bytes actually
          used in the data area of the code object; this is the number
          of bytes used by the executable machine code.

             * On 32-bit platforms: a big endian 32-bit raw integer.

             * On 64-bit platforms: a sequence of two big endian 32-bit
               raw integers; the first integer represents the least
               significant 32 bits, the second integer represents the
               most significant 32 bits.

       2. An exact integer representing the number of free variables in
          the code.

             * On 32-bit platforms: a big endian 32-bit integer
               representing the fixnum.

             * On 64-bit platforms: a sequence of two big endian 32-bit
               integers representing the fixnum; the first integer
               represents the least significant 32 bits, the second
               integer represents the most significant 32 bits.

       3. A Scheme object representing the code annotation.

       4. An array of bytes being the binary code.

       5. The code relocation vector as an ordinary Scheme vector.

"Q" + "x" + code object
     Procedure.  A procedure is represented by the header 'Q' followed
     by the serialisation of a code object, header 'x' included.

">" + int32(I)
     Mark the next object with index I.

"<" + int32(I)
     Dereference the object marked with index I.

"O" + libid
     Foreign library identifier.  'libid' must be a string representing
     the foreign shared library identifier: on Unix-like systems it is
     prefixed with 'lib' and suffixed with '.so' to compose a library
     file name.


File: vicare-scheme.info,  Node: fasl api,  Next: fasl foreign,  Prev: fasl format,  Up: fasl

G.2 FASL files API
==================

The following bindings are exported by the library '(vicare)'.

 -- Function: fasl-write OBJ PORT
 -- Function: fasl-write OBJ PORT LIBRARIES
     Serialise OBJ to the binary output port PORT prefixing it with the
     FASL file header.  If LIBRARIES is present: it must be a list of
     strings representing foreign shared libraries to be loaded whenever
     the FASL file is loaded, *note fasl foreign:: for details.

 -- Function: fasl-read PORT
     Read and return a serialised object from the binary input PORT.


File: vicare-scheme.info,  Node: fasl foreign,  Prev: fasl api,  Up: fasl

G.3 Associating foreign libraries to FASL files
===============================================

It is possible to register in a FASL a list of host's shared objects to
be loaded upon loading the FASL file itself, *note foreign:: for
details.


File: vicare-scheme.info,  Node: shmem,  Next: binfmt,  Prev: fasl,  Up: Top

Appendix H Interprocess shared memory
*************************************

* Menu:

* shmem mmap::                  Shared memory through 'mmap'.


File: vicare-scheme.info,  Node: shmem mmap,  Up: shmem

H.1 Shared memory through 'mmap'
================================

This appendix shows some sample code describing how to exchange binary
and Scheme data among multiple Vicare processes through shared memory.
It is assumed that Vicare is installed with the POSIX interface enabled.

   The first example just exchanges a signed integer:

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (let* ((shmem.len (px.sysconf _SC_PAGESIZE))
            (shmem.ptr (px.mmap #f shmem.len
                          (fxior PROT_READ PROT_WRITE)
                          (fxior MAP_SHARED MAP_ANONYMOUS)
                          0 0)))
       (unwind-protect
           (px.fork

             ;; Parent: write a signed int, wait for the
             ;; child to exit, read the incremented int.
             (lambda (child-pid)
               (pointer-set-c-signed-int! shmem.ptr 0 234)
               (px.waitpid child-pid 0)
               (pointer-ref-c-signed-int shmem.ptr 0))

             ;; Child: wait for a while, then read a signed
             ;; int and write it back incremented by 1000;
             ;; finally exit.
             (lambda ()
               (px.nanosleep 1 0)
               (pointer-set-c-signed-int! shmem.ptr 0
                 (+ 1000 (pointer-ref-c-signed-int shmem.ptr 0)))
                 (exit)))

         (px.munmap shmem.ptr shmem.len)))
     => 1234

   The second example exchanges a bytevector of known length:

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (let* ((shmem.len (px.sysconf _SC_PAGESIZE))
            (shmem.ptr (px.mmap #f shmem.len
                                (fxior PROT_READ PROT_WRITE)
                                (fxior MAP_SHARED MAP_ANONYMOUS)
                                0 0)))
       (unwind-protect
           (px.fork

             ;; Parent: write the bytevector, wait for the
             ;; child to exit, read back the bytevector.
             (lambda (child-pid)
               (memory-copy shmem.ptr 0
                 '#vu8(0 1 2 3 4 5 6 7 8 9) 0 10)
               (px.waitpid child-pid 0)
               (let ((bv (make-bytevector 10)))
                 (memory-copy bv 0 shmem.ptr 0 10)
                 bv))

             ;; Child: wait for a while, read the bytevector,
             ;; increment the bytes, write the bytevector,
             ;; finally exit.
             (lambda ()
               (px.nanosleep 1 0)
               (let ((bv (make-bytevector 10)))
                 (memory-copy bv 0 shmem.ptr 0 10)
                 (do ((i 0 (+ 1 i)))
                     ((= i 10)
                      (memory-copy shmem.ptr 0 bv 0 10)
                      (exit))
                   (bytevector-u8-set! bv i
                     (+ 100 (bytevector-u8-ref bv i)))))))

         (px.munmap shmem.ptr shmem.len)))
     => #vu8(100 101 102 103 104 105 106 107 108 109)

   The third example shares a Scheme datum of length unknown by using
'fasl-write' and 'fasl-read'; the number of bytes is exchanged in the
first location of shared memory, we assume that 16 pages of memory are
enough:

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (vicare language-extensions syntaxes))

     (define data
       '(1 2 #(3 4) ciao "hello" #vu8(99 98 97)))

     (let* ((shmem.len (* 16 (px.sysconf _SC_PAGESIZE)))
            (shmem.ptr (px.mmap #f shmem.len
                          (fxior PROT_READ PROT_WRITE)
                          (fxior MAP_SHARED MAP_ANONYMOUS)
                          0 0)))
       (unwind-protect
           (px.fork

              ;; Parent: wait for the child process, read the data
              ;; length, allocate a bytevector, read data.
              (lambda (child-pid)
                (px.waitpid child-pid 0)
                (let* ((bv.len (pointer-ref-c-signed-int shmem.ptr 0))
                       (bv     (make-bytevector bv.len)))
                  (memory-copy bv 0 shmem.ptr SIZEOF_INT bv.len)
                  (fasl-read (open-bytevector-input-port bv))))

              ;; Child: convert Scheme data into a fasl bytevector,
              ;; write data length, write data, finally exit.
              (lambda ()
                (let-values (((port getter)
                             (open-bytevector-output-port)))
                  (fasl-write data port)
                  (let* ((bv     (getter))
                         (bv.len (bytevector-length bv)))
                    (pointer-set-c-signed-int! shmem.ptr 0 bv.len)
                    (memory-copy shmem.ptr SIZEOF_INT bv 0 bv.len)
                    (exit))))

         (px.munmap shmem.ptr shmem.len))))
     => (1 2 #(3 4) ciao "hello" #vu8(99 98 97))


File: vicare-scheme.info,  Node: binfmt,  Next: file-magic,  Prev: shmem,  Up: Top

Appendix I Launching programs directly on GNU+Linux
***************************************************

This appendix describes an optional feature of Vicare: source and binary
Scheme programs execution through the mechanism of the 'binfmt_misc'
Linux kernel module; it is available only on Unix-like platforms running
the Linux kernel.

     This appendix is derived from the original 'binfmt_misc'
     documentation text file by Richard Guenther.

   By default the installation of the required files is disabled; to
enable it: at configuration time we must pass the '--enable-binfmt'
option to the 'configure' script.

* Menu:

* binfmt overview::             Overview of the mechanism.
* binfmt loading::              Loading the module.
* binfmt registry::             The registry.
* binfmt using::                Using the mechanism.
* binfmt control::              Controlling the mechanism.
* binfmt hints::                Hints.
* binfmt scheme::               Running Scheme programs.


File: vicare-scheme.info,  Node: binfmt overview,  Next: binfmt loading,  Up: binfmt

I.1 Overview of the mechanism
=============================

The common way of running a Scheme script, is to invoke the executable
'vicare' using the option '--r6rs-script' to select the pathname of the
file:

     vicare --r6rs-script path/to/script.sps

to run a compiled Scheme program, we invoke the executable 'vicare'
using the option '--binary-program' to select the pathname of the file:

     vicare --binary-program path/to/program

   The features implemented in the 'binfmt_misc' kernel module allow us
to invoke almost every program by simply typing its name in the shell,
without explicitly invoking the executable program implementing the
interpreter; this includes for example compiled Java, Python or Emacs
programs, and of course Scheme programs; this mechanism is a
generalisation of the mechanism that runs shell scripts whose file
begins with '#!/bin/sh'.

   With proper configuration: the kernel recognises the binary file type
by matching some bytes at the beginning of the file with a magic byte
sequence (masking out specified bits) we have supplied; it can also
recognise a filename extension.

   If we enable Vicare support for 'binfmt_misc', we can run Scheme
programs as follows:

   * For source scripts, we make the file executable and put as very
     first bytes the string ';;;!vicare', then we just do:

          path/to/script.sps

   * For compiled programs, we make the file executable and just do:

          path/to/program


File: vicare-scheme.info,  Node: binfmt loading,  Next: binfmt registry,  Prev: binfmt overview,  Up: binfmt

I.2 Loading the module
======================

If the module is installed on the system, we will find it in:

     /lib/modules/<version>/kernel/fs/binfmt_misc.ko

and to load it we do (as root):

     /sbin/modprobe binfmt_misc

for example on a Slackware Linux installation, loading can be done by
uncommenting the relevant line in '/etc/rc.d/rc.modules'.

   Then we add the following line to '/etc/fstab':

     none /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0

so that the 'binfmt_misc' directory can be mounted and will be mounted
when booting the system.  We can freely mount and unmount this virtual
file system with (as root):

     # mount  /proc/sys/fs/binfmt_misc
     # umount /proc/sys/fs/binfmt_misc

but this is rarely useful.  There are other means of enabling and
disabling the feature.


File: vicare-scheme.info,  Node: binfmt registry,  Next: binfmt using,  Prev: binfmt loading,  Up: binfmt

I.3 The registry
================

To actually register a new binary type, we have to compose a string
like:

     :name:type:offset:magic:mask:interpreter:

and echo it to '/proc/sys/fs/binfmt_misc/register'.  We can choose the
separator character ':' depending on our needs and we can omit a field
by simply using an empty string; for example if we omit the offset and
the mask fields:

     :name:type::magic::interpreter:

   Fields description follows.

'name'
     It is an identifier string.  A new '/proc' file will be created
     with this name under '/proc/sys/fs/binfmt_misc', and we can use it
     to query and reset the configuration status.

'type'
     It is the type of file recognition.  If set to 'M' activates first
     bytes recognition (also known as "magic" recognition); if set to
     'E' activates file name extension recognition.

'offset'
     It is the zero-based offset of the magic/mask in the file, counted
     in bytes.  It is used only with magic recognition.  It defaults to
     zero.

'magic'
     It is the byte sequence 'binfmt_misc' will look for file
     recognition.

     The magic string may contain hex-encoded characters like '\x0a' or
     '\xA4'.  When echoing the record from a shell environment, we will
     have to quote the backslash: '\\x0a'.

     If we chose filename extension matching, this is the extension to
     be recognised (without the '.', the '\x0a' specials are not
     allowed).  Extension matching is case sensitive.

'mask'
     It is a bitmask.  We can mask out some bits from matching by
     supplying a string with the same length of 'magic'.  The mask is
     ANDed with the byte sequence from the file.  It defaults to '0xff'.

'interpreter'
     It is the program that should be invoked with the binary as first
     argument.  *We have to specify the full path.*

   There are some restrictions:

   * The whole 'register' string must not exceed 255 characters.

   * The magic must reside in the first 128 bytes of the file, i.e.
     'offset+size(magic)' has to be less than 128.

   * The interpreter string must not exceed 127 characters.


File: vicare-scheme.info,  Node: binfmt using,  Next: binfmt control,  Prev: binfmt registry,  Up: binfmt

I.4 Using the mechanism
=======================

When 'binfmt_misc' support is enabled, the Vicare package installs a set
of files automating almost everything:

'$sysconfdir/rc.d/rc.vicare-scheme'
     A shell script ('/bin/sh') to be executed to enable or disable the
     feature.  Just running it enables 'binfmt_misc' support.

'$libexecdir/vicare-scheme/binfmt-script-launcher.sh'
     A shell script ('/bin/sh') used as 'interpreter' when running
     source scripts.

'$libexecdir/vicare-scheme/binfmt-program-launcher.sh'
     A shell script ('/bin/sh') used as 'interpreter' when running
     compiled programs.

   We might want to add the invocation of 'rc.vicare-scheme' in one of
the shell scripts that are executed at system boot time; for example, on
a Slackware Linux system we can use '/etc/rc.d/rc.local' by inserting
this code:

     if [ -x "$sysconfdir/rc.d/rc.vicare-scheme" ]; then
        "$sysconfdir/rc.d/rc.vicare-scheme"
     fi

   The script 'rc.vicare-scheme' implements 'binfmt_misc' support by
adding two records to the register: one for source scripts with name
'VICARE_SCRIPTS' and one for compiled programs with name
'VICARE_PROGRAMS'.  'rc.vicare-scheme' does the following:

  1. Verify if the 'binfmt_misc' kernel module has been loaded by
     testing the existence of the 'register' file; if the module is not
     there, nothing happens.

  2. Remove the configuration from the registry if it is already there;
     this is done by testing the existence of the special files:

          /proc/sys/fs/binfmt_misc/VICARE_SCRIPTS
          /proc/sys/fs/binfmt_misc/VICARE_PROGRAMS

     echoing '-1' in them removes the records.

  3. Echo the records into the registry with the following fields for
     source scripts:

     'VICARE_SCRIPTS'
          It is the name of the special file representing the record in
          the registry.

     'M'
          Activates first bytes recognition.

     '0'
          The offset of the magic string into the file.

     ';;;!vicare'
          The magic string itself.

     '$libexecdir/vicare-scheme/binfmt-script-launcher.sh'
          The full pathname to the source scripts launcher.

     and the following fields for compiled programs:

     'VICARE_PROGRAMS'
          It is the name of the special file representing the record in
          the registry.

     'M'
          Activates first bytes recognition.

     '0'
          The offset of the magic string into the file.

     '#@IK01'
     '#@IK02'
          The magic string itself.  One for 32-bit platforms the other
          for 64-bit platforms.

     '$libexecdir/vicare-scheme/binfmt-script-launcher.sh'
          The full pathname to the compiled programs launcher.

   The 'mask' field is set to the empty string, that is: no mask is
applied and the 'magic' is matched literally.

   We have to care about the order of added entries: entries added later
are matched first.


File: vicare-scheme.info,  Node: binfmt control,  Next: binfmt hints,  Prev: binfmt using,  Up: binfmt

I.5 Controlling the mechanism
=============================

Overall control
...............

We can enable/disable the mechanism by echoing '0' (to disable) or '1'
(to enable) to the special file:

     /proc/sys/fs/binfmt_misc/status

that is, at the shell prompt and with superuser privileges, to enable:

     # echo 1 >/proc/sys/fs/binfmt_misc/status

and to disable:

     # echo 0 >/proc/sys/fs/binfmt_misc/status

   Applying the command 'cat' to the 'status' special file tells us the
current status of 'binfmt_misc':

     $ cat /proc/sys/fs/binfmt_misc/status
     enabled

   We can remove all the entries from the registry echoing '-1' to
'status'; at the shell prompt and with superuser privileges:

     # echo -1 >/proc/sys/fs/binfmt_misc/status

removing the entries and disabling the mechanism are two distinct
operations.

Specific format control
.......................

We can enable/disable recognition of a single binary format by echoing
'0' or '1' to the format specific special file under
'/proc/sys/fs/binfmt_misc'.  For example for 'VICARE_SCRIPTS', at the
shell prompt and with superuser privileges, to enable:

     $ echo 1 >/proc/sys/fs/binfmt_misc/VICARE_SCRIPTS

and to disable:

     $ echo 0 >/proc/sys/fs/binfmt_misc/VICARE_SCRIPTS

disabled formats are *not* removed from the internal table.

   Applying the command 'cat' to the format's special file tells us the
current status of that format and its configuration; for example for
'VICARE_SCRIPTS', at the shell prompt:

     $ cat /proc/sys/fs/binfmt_misc/VICARE_SCRIPTS

   We can remove a specific format entry from the registry echoing '-1'
to its special file; for 'VICARE_SCRIPTS' at the shell prompt and with
superuser privileges:

     $ echo -1 >/proc/sys/fs/binfmt_misc/VICARE_SCRIPTS

removing the entry and disabling the mechanism for a format are two
distinct operations.


File: vicare-scheme.info,  Node: binfmt hints,  Next: binfmt scheme,  Prev: binfmt control,  Up: binfmt

I.6 Hints
=========

If we want to pass command line arguments to the executable program
implementing the interpreter, we must write a wrapper script for it;
there is no way to embed the arguments in the registry record.

   The wrapper must *not* look in the 'PATH' environment variable for
the actual interpreter filename; the kernel passes it the full filename
to use.  Using 'PATH' can cause unexpected behaviour and be a security
hazard.


File: vicare-scheme.info,  Node: binfmt scheme,  Prev: binfmt hints,  Up: binfmt

I.7 Running Scheme programs
===========================

The 'binfmt_misc' mechanism can be used to run both source and compiled
programs.  Vicare adheres to the following rules, which we can change by
customising the files in the distribution:

  1. Vicare source programs are recognised if the file starts with the
     string ';;;!vicare'.  Notice that we *cannot* use the sequence
     '#!vicare' because when 'binfmt_misc' reads the prefix '#!' it
     activates the traditional shebang processing.

  2. The 'binfmt_misc' configuration is stored in a Bourne shell script
     ('/bin/sh' interpreter) named 'rc.vicare-scheme' installed in the
     '$(sysconfdir)/rc.d' directory.  If the default configuration is
     not changed, this ends up being:

          /usr/local/etc/rc.d/rc.vicare-scheme

     The script can be executed at system boot time and again later any
     number of times: at each run it resets and reinitialises the
     configuration for Scheme programs.

  3. The 'vicare' executable must be in '$(bindir)', else we must
     customise the 'rc.vicare-scheme' script.


File: vicare-scheme.info,  Node: file-magic,  Next: notes,  Prev: binfmt,  Up: Top

Appendix J Installing 'file' magic file
***************************************

Under Unix platforms it is usually available a command 'file' that can
be used to identify common file formats.  Vicare Scheme installs a
configuration file that 'file' can use to identify FASL files.  The file
is:

     /etc/file/magic/vicare-scheme

and its installation is enabled by configuring the package with the
'--enable-file-magic' command line option of 'configure'.


File: vicare-scheme.info,  Node: notes,  Next: Package License,  Prev: file-magic,  Up: Top

Appendix K Miscellaneous notes on everything
********************************************

* Menu:

* notes nan::                   How to deal with not-a-number.


File: vicare-scheme.info,  Node: notes nan,  Up: notes

K.1 How to deal with not-a-number
=================================

The not-a-number value, "NaN" for short, represents the result of a
_wrong_ computation.  NaN can appear as literal in Scheme source code as
'+nan.0' or '-nan.0', and it can be the result of an expression
composing Scheme arithmetic functions.  NaN has *no sign*, '+nan.0' and
'-nan.0' have the same semantic meaning.

   What follows is just a set of notes with no commitment to rigour in
Mathematics.  For more informations on NaN, start from:

     Wikipedia contributors.  "Not a number".  Wikipedia, The Free
     Encyclopedia.
     <http://en.wikipedia.org/w/index.php?title=NaN&oldid=303402207>
     (accessed July 21, 2009).

see also:

     Wikipedia contributors.  "Division by zero".  Wikipedia, The Free
     Encyclopedia.
     <http://en.wikipedia.org/w/index.php?title=Division_by_zero&oldid=303258289>
     (accessed July 21, 2009).

   Being that NaN is a little weird, let's start by understanding how to
deal with infinities first.

* Menu:

* notes nan inf::               How to deal with infinities.
* notes nan nan::               Understanding not-a-number.


File: vicare-scheme.info,  Node: notes nan inf,  Next: notes nan nan,  Up: notes nan

K.1.1 How to deal with infinities
---------------------------------

Infinities can appear as literals in Scheme source code as '+inf.0' or
'-inf.0', and they can be the result of an expression composing Scheme
arithmetic functions.

   We have to distinguish between "number objects" as defined in R6RS
Scheme, and "numbers" as defined by Mathematics.

Infinities in the mathematical realm
....................................

We can take that Algebra defines "groups" as couples (S, o) where: S is
a set of mathematical entities, o is an operation that composes two
entities in S and evaluates to some mathematical entity.  We can define
the group (R, +), where R is the set of real numbers and + is the common
addition, because they are compliant with the following axioms:

_Closure_
     For every couple of reals, their sum is a real.

_Associativity_
     For every triplet of reals:

          a + (b + c) = (a + b) + c

_Identity element_
     There exists a unique real 0 for which, for every real a:

          0 + a = a + 0 = a

_Inverse element_
     For every real a there is a unique other real b for which:

          a + b = 0  =>  a = -b

the existence of the inverse element for addition allows the definition
of subtraction.  The couple (R, *), the reals with the ordinary product,
is also a group:

_Closure_
          \forall a, b \in R     a * b = c   c \in R

_Associativity_
          a * (b * c) = (a * b) * c

_Identity element_
          1 * a = a * 1 = a

_Inverse element_
          a * b = 1  =>  a = 1/b

the existence of the inverse element for multiplication allows the
definition of division.

   The triplet (S, +, *) in which S is a set of mathematical entities,
and + and * are composition operations with the properties for a group,
is called "field" if the following additional axioms hold:

_Commutativity_
          a + b = b + a    a * b = b * a

_Distributivity_
          a * (b + c) = a * b + a * c

   Human experience shows that it is convenient to state (simplified):
Every mathematical entity which is not compliant with the axioms of a
field is not a number.

   Infinities are abstract mathematical entities which we can define
through the following disequations:

     \forall r \in R        -\infty < r < +\infty

which means:

   * Positive infinity is comparable to numbers and it is greater than
     all the positive numbers.

   * Negative infinity is comparable to numbers and it is lesser than
     all the negative number.

we notice that the comparison operator < does not define a group,
because the result of 1 < 2 (as defined in Mathematics) is a boolean
value not a number.(1)

   Despite the fact that we can compare them to numbers, *infinities are
not numbers in the Mathematics sense.*  We can show this with the
following simple mathematical computation; let's consider the following
equation:

     4 + +\infty = x

what should we take as value for x?  x cannot be a number like, say, 8,
because:

     4 + +\infty = 8
     => +\infty = 8 - 4 = 4
     => +\infty = 4  Wrong!

the only answer that tries to make some sense is x = +\infty, but then:

     4 + +\infty = +\infty
     =>  4 = +\infty - +\infty = 0
     =>  4 = 0  Wrong!

if we assume that infinities are numbers, some perfectly legal algebraic
manipulation yields a wrong result.  Human beings define mathematical
entities based on their usefulness; human experience shows that it is
more useful to avoid absurd equations like 4 = 0, than to define
infinities as numbers.

   So, infinities are *not* numbers and the equation 4 + \infty = x is
wrong in the sense that, in Mathematics, it is an error to write it.

   Mathematics is not "perfect", in the sense that it allows us to write
wrong equations; unfortunately we can recognise an equation as wrong
only by trying to solve it.

   Let's look at this equation:

        4 - 3       1
     ------------ = - = x
     12 - (4 + 8)   0

what should we take as value for x?

   If we had the limit:

              1
     \lim    --- = x      t > 0
     t -> 0   t

we would know that x -> +\infty (x approaches +\infty, it is not equal
to it).  Computing 1 / t for t smaller and smaller, yields a result that
is a bigger and bigger positive number, which approaches the
mathematical entity greater than all the positive numbers; that is
+\infty.

   But what about the straight 1 / 0 = x?  The only mathematical entity
that makes sense as answer is x = +\infty, so 1 / 0 is not a number.  We
can demonstrate this with the following simple computation:

     3 * (1 / 0) = y
     =>  3 / 0 = y
     =>  3 = y * 0 = 0
     =>  3 = 0   Wrong!

so, it is impossible for 1 / 0 and y to comply with the axioms.

Infinities in the computer realm
................................

Number objects are all the Scheme values for which the predicate
'number?' returns '#t'.  Both the infinities '+inf.0' and '-inf.0' are
number objects.  This way Scheme defines a class of values which can be
used as arguments to arithmetic procedures, and which can potentially be
the return value of an arithmetic procedure.

   We acknowledged that, when a mathematical expression is non-compliant
with the axioms of definition of numbers, we can verify it by doing the
computation and checking the final or partial results.  A computer can
do the same by detecting, for example, if a division has 1 and 0 as
operands.

   It turns out that making a computer processor interrupt a computation
when an expression is wrong, is inefficient.  So two special values were
defined to allow a computation to signal that special error: '+inf.0'
and '-inf.0'.

   When a computation returns '+inf.0' and '-inf.0' we know that the
expression was wrong.  R6RS Scheme defines the following conventional
results:

     (div 1 0) => error
     (/   1 0) => error

     (/   1.0 0)   => +inf.0
     (/   1   0.0) => +inf.0
     (/   1.0 0.0) => +inf.0

when both the operands are exact, the expression raises an error; when
one of the operands is inexact, the expression yields infinity.

   Special rules were defined to avoid to mistake a wrong computation
for a correct one; for example:

     (+ 44 (* 23 +inf.0)) => +inf.0
     (+ 44 (* 23 -inf.0)) => -inf.0

we know that both of these are wrong, but we also know that they are
wrong in that special way for which returning an infinity makes some
sense.  It is our responsibility to decide what to do.

   The special rules makes it impossible for an expression to return a
finite number if one of the partial results was an infinity.  Sometimes
the composition of two infinities can yield an infinity with no
confusion; examples:

     (+ +inf.0 +inf.0) => +inf.0
     (+ -inf.0 -inf.0) => -inf.0

     (- +inf.0 -inf.0) => +inf.0  ;like (+ +inf.0 +inf.0)
     (- -inf.0 +inf.0) => -inf.0  ;like (+ -inf.0 -inf.0)
     (- +inf.0 -inf.0) => +inf.0  ;like (+ +inf.0 +inf.0)

     (* +inf.0 +inf.0) => -inf.0
     (* +inf.0 -inf.0) => -inf.0
     (* -inf.0 -inf.0) => +inf.0

but some expressions are difficult to deal with:

     (+ +inf.0 -inf.0) => ?
     (+ -inf.0 +inf.0) => ?

     (- -inf.0 -inf.0) => ?
     (- -inf.0 +inf.0) => ?

     (/ +inf.0 +inf.0) => ?
     (/ +inf.0 -inf.0) => ?
     (/ -inf.0 +inf.0) => ?
     (/ -inf.0 -inf.0) => ?

neither a number nor an infinity makes sense as result here; we need
NaN.

   ---------- Footnotes ----------

   (1) This holds despite the fact that many programming languages allow
a disequation to yield a number.


File: vicare-scheme.info,  Node: notes nan nan,  Prev: notes nan inf,  Up: notes nan

K.1.2 Understanding not-a-number
--------------------------------

NaN is a special value used as result of a wrong expression.  We have
seen that the composition of infinities is not always defined; in those
cases the result is NaN:

     (+ +inf.0 -inf.0) => +nan.0
     (+ -inf.0 +inf.0) => +nan.0

     (- -inf.0 -inf.0) => +nan.0
     (- -inf.0 +inf.0) => +nan.0

     (/ +inf.0 +inf.0) => +nan.0
     (/ +inf.0 -inf.0) => +nan.0
     (/ -inf.0 +inf.0) => +nan.0
     (/ -inf.0 -inf.0) => +nan.0

also it is:

     (div 0   0)   => <error>
     (/   0   0)   => <error>
     (/   0.0 0)   => +nan.0
     (/   0   0.0) => +nan.0
     (/   0.0 0.0) => +nan.0

because, in Mathematics, 0 / 0 is not compliant to the axioms:

     (0 / 0) = y
     =>  0 * y = 0    y is not unique

   Special rules were defined so that an arithmetic composition between
NaN and another number always returns NaN. This allows us not to mistake
a wrong computation for a correct one:

     (+ 1 +nan.0) => +nan.0
     (- 1 +nan.0) => +nan.0
     (* 1 +nan.0) => +nan.0
     (/ 1 +nan.0) => +nan.0

we have to beware, though, that some non-arithmetic function may hide
the NaN, and give rise to some surprise:

     (max 1 +nan.0) => 1.0       ; ! the inexact 1!!
     (min 1 +nan.0) => +nan.0    ; !?!

   Scheme defines a predicate to test if a value is NaN, 'nan?'.  R6RS
Scheme mandates that:

     (= +nan.0 +nan.0) => #f
     (= +nan.0 z)      => #f

for every number Z.  The first is correct because a wrong computation is
not equal, in numerical sense, to another wrong computation.

   R6RS Scheme also states that:

     (eqv? +nan.0 +nan.0) => <undefined>

but currently many Scheme implementations do:

     (eqv?   +nan.0 +nan.0) => #t
     (equal? +nan.0 +nan.0) => #t

notice that, by definition, 'equal?' relies on 'eqv?'.  This allows us
to do tests for wrong computations using not only 'nan?'; this is
especially useful when writing test suites (with more complicated stuff
than this):

     (check
         (list (+ 1 2) (/ 0.0 0.0))
       => '(3 +nan.0))

   The behaviour of 'eqv?' and 'equal?' does not reduce our ability to
detect wrong expressions; we can always do:

     (let ((v (expression)))
       (cond
         ((= v 1)   (some-thing))
         ((nan? v)  (some-other-thing))
         (else      (yet-another-thing))))

'eqv?' and 'equal?' just allow us to do (by definition 'case' relies on
'eqv?'):

     (case (expression)
       ((1 2)     (some-thing))
       ((+nan.0)  (some-other-thing))
       (else      (yet-another-thing)))

     (let ((v (expression)))
       (cond
         ((= v 1)          (some-thing))
         ((eqv? v +nan.0)  (some-other-thing))
         (else             (yet-another-thing))))

which, in some situations, is one more possibility to code the logic of
a function:

     (= (expression1) (expression2))
     => <bool> ; true if the results are equal numbers

     (eqv? (expression1) (expression2))
     => <bool> ; true if the results are equal numbers
               ; or are both wrong expressions


File: vicare-scheme.info,  Node: Package License,  Next: history,  Prev: notes,  Up: Top

Appendix L GNU General Public License
*************************************

                        Version 3, 29 June 2007

     Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     "This License" refers to version 3 of the GNU General Public
     License.

     "Copyright" also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     "The Program" refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as "you".  "Licensees" and
     "recipients" may be individuals or organizations.

     To "modify" a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a "modified
     version" of the earlier work or a work "based on" the earlier work.

     A "covered work" means either the unmodified Program or a work
     based on the Program.

     To "propagate" a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it on
     a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To "convey" a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays "Appropriate Legal Notices"
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may convey
     the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The "source code" for a work means the preferred form of the work
     for making modifications to it.  "Object code" means any non-source
     form of a work.

     A "Standard Interface" means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The "System Libraries" of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work with
     that Major Component, or to implement a Standard Interface for
     which an implementation is available to the public in source code
     form.  A "Major Component", in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The "Corresponding Source" for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including scripts
     to control those activities.  However, it does not include the
     work's System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files associated
     with source files for the work, and the source code for shared
     libraries and dynamically linked subprograms that the work is
     specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output, given
     its content, constitutes a covered work.  This License acknowledges
     your rights of fair use or other equivalent, as provided by
     copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for you,
     or provide you with facilities for running those works, provided
     that you comply with the terms of this License in conveying all
     material for which you do not control copyright.  Those thus making
     or running the covered works for you must do so exclusively on your
     behalf, under your direction and control, on terms that prohibit
     them from making any copies of your copyrighted material outside
     their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention to
     limit operation or modification of the work as a means of
     enforcing, against the work's users, your or third parties' legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program's source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to "keep intact all notices".

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an "aggregate" if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation's users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for as
          long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of the
          written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access to
          the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated by
          you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to the
          object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long as
          needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.

     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A "User Product" is either (1) a "consumer product", which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product is
     a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     "normally used" refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     "Installation Information" for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or installed
     by the recipient, or for the User Product in which it has been
     modified or installed.  Access to a network may be denied when the
     modification itself materially and adversely affects the operation
     of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     "Additional permissions" are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License with
     terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be marked
          in reasonable ways as different from the original version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered "further
     restrictions" within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or conveying
     under this License, you may add to a covered work material governed
     by the terms of that license document, provided that the further
     restriction does not survive such relicensing or conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under the
     third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, you do not qualify to receive new licenses
     for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An "entity transaction" is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party's predecessor in interest had or
     could give under the previous paragraph, plus a right to possession
     of the Corresponding Source of the work from the predecessor in
     interest, if the predecessor has it or can get it with reasonable
     efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for exercise
     of rights granted under this License, and you may not initiate
     litigation (including a cross-claim or counterclaim in a lawsuit)
     alleging that any patent claim is infringed by making, using,
     selling, offering for sale, or importing the Program or any portion
     of it.

  11. Patents.

     A "contributor" is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor's "contributor
     version".

     A contributor's "essential patent claims" are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, "control"
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor's essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its contributor
     version.

     In the following three paragraphs, a "patent license" is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To "grant"
     such a patent license to a party means to make such an agreement or
     commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  "Knowingly relying" means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient's use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is "discriminatory" if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under which
     you make payment to the third party based on the extent of your
     activity of conveying the work, and under which the third party
     grants, to any of the parties who would receive the covered work
     from you, a discriminatory patent license (a) in connection with
     copies of the covered work conveyed by you (or copies made from
     those copies), or (b) primarily for and in connection with specific
     products or compilations that contain the covered work, unless you
     entered into that arrangement, or that patent license was granted,
     prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

     If conditions are imposed on you (whether by court order, agreement
     or otherwise) that contradict the conditions of this License, they
     do not excuse you from the conditions of this License.  If you
     cannot convey a covered work so as to satisfy simultaneously your
     obligations under this License and any other pertinent obligations,
     then as a consequence you may not convey it at all.  For example,
     if you agree to terms that obligate you to collect a royalty for
     further conveying from those to whom you convey the Program, the
     only way you could satisfy both those terms and this License would
     be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

  14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the Free
     Software Foundation.  If the Program does not specify a version
     number of the GNU General Public License, you may choose any
     version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

  15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
     DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type 'show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.
