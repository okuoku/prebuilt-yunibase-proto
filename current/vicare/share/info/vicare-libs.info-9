This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: dynamic arrays conversion,  Next: dynamic arrays misc,  Prev: dynamic arrays filtering,  Up: dynamic arrays

40.8 Converting dynamic-arrays to other objects
===============================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array->list ARRY
 -- Function: $dynamic-array->list ARRY
 -- Function: list->dynamic-array LIST
 -- Function: $list->dynamic-array LIST
     Convert to and from a dynamic array and a proper list.  Objects
     from the list are pushed on the dynamic array left-to-right from
     the rear side.

          (define D
            (list->dynamic-array '(0 1 2)))

          (dynamic-array-front D)         => 0
          (dynamic-array-rear  D)         => 2
          (dynamic-array->list D)         => (0 1 2)

 -- Function: dynamic-array->vector ARRY
 -- Function: $dynamic-array->vector ARRY
 -- Function: vector->dynamic-array VECTOR
 -- Function: $vector->dynamic-array VECTOR
     Convert to and from a dynamic array and a vector.  Objects from the
     vector are pushed on the dynamic array left-to-right from the rear
     side.

          (define D
            (vector->dynamic-array '#(0 1 2)))

          (dynamic-array-front   D)       => 0
          (dynamic-array-rear    D)       => 2
          (dynamic-array->vector D)       => #(0 1 2)


File: vicare-libs.info,  Node: dynamic arrays misc,  Next: dynamic arrays sort,  Prev: dynamic arrays conversion,  Up: dynamic arrays

40.9 Miscellaneous operations on dynamic-arrays
===============================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-copy! DST-ARRY SRC-ARRY
 -- Function: $dynamic-array-copy! DST-ARRY SRC-ARRY
     Iterate over all the objects in SRC-ARRY, starting from the front
     side, and push them in the rear side of DST-ARRY.  This is a
     shallow copy: the very objects from the source dynamic array are
     added to the destination dynamic array; if we need to duplicate the
     objects, we can use the map operation.

     The DST-ARRY argument allows us to build the destination dynamic
     array with the desired configuration parameters.

 -- Function: dynamic-array-reverse! DST-ARRY SRC-ARRY
 -- Function: $dynamic-array-reverse! DST-ARRY SRC-ARRY
     Iterate over the objects in SRC-QUEUE, starting from the front
     side, and push them in the front side of DST-QUEUE.  Return
     DST-QUEUE.

     The DST-ARRY argument allows us to build the destination dynamic
     array with the desired configuration parameters.


File: vicare-libs.info,  Node: dynamic arrays sort,  Next: dynamic arrays iterthunks,  Prev: dynamic arrays misc,  Up: dynamic arrays

40.10 Sorting dynamic arrays
============================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays sort)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-sort ITEM< ARRY
 -- Function: $dynamic-array-sort ITEM< ARRY
     Build and return a new dynamic array holding all the objects from
     ARRY sorted from the lesser to the greater according to the
     comparison procedure ITEM<.

     ITEM< must be a procedure accepting two objects from ARRY and
     returning true if the first argument is less than the second
     argument.

          (let* ((C1 (dynamic-array 0 4 3 1 2 5))
                 (C2 (dynamic-array-sort < C1)))
            (dynamic-array->list C2))
          => (0 1 2 3 4 5)

 -- Function: dynamic-array-sort! ITEM< ARRY
 -- Function: $dynamic-array-sort! ITEM< ARRY
     Sort all the objects from ARRY from the lesser to the greater
     according to the comparison procedure ITEM<; ARRY itself is mutated
     and returned.

     ITEM< must be a procedure accepting two objects from ARRY and
     returning true if the first argument is less than the second
     argument.

          (let ((C (dynamic-array 0 4 3 1 2 5)))
            (dynamic-array->list (dynamic-array-sort! < C)))
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: dynamic arrays iterthunks,  Prev: dynamic arrays sort,  Up: dynamic arrays

40.11 Iteration thunks
======================

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers dynamic-arrays)'.

 -- Function: make-dynamic-array-front-iteration-thunk ARRY
     Build and return a new iteration thunk visiting the objects from
     the front of ARRY.

          (import (vicare)
            (vicare containers dynamic-arrays)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-dynamic-array-front-iteration-thunks
               (dynamic-array)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-dynamic-array-front-iteration-thunks
               (dynamic-array 0 1 2 3 4 5)))
          => (5 4 3 2 1 0)

 -- Function: make-dynamic-array-rear-iteration-thunk ARRY
     Build and return a new iteration thunk popping the objects from the
     rear of ARRY.

          (import (vicare)
            (vicare containers dynamic-arrays)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-dynamic-array-rear-iteration-thunks
               (dynamic-array)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-dynamic-array-rear-iteration-thunks
               (dynamic-array 0 1 2 3 4 5)))
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: bst,  Next: sets bags,  Prev: dynamic arrays,  Up: Top

41 Binary search trees
**********************

The library '(vicare containers binary-search-trees)' implements the
skeleton functions needed by binary search trees.

* Menu:

* bst intro::                   Introduction to binary search trees.
* bst bnodes::                  Binary node objects.
* bst unodes::                  Unbalanced binary node objects.


File: vicare-libs.info,  Node: bst intro,  Next: bst bnodes,  Up: bst

41.1 Introduction to binary search trees
========================================

The "binary search trees" are tree structures in which every node has at
most two children.  Every node is associated to a "sort key": a value
that can be used to establish an ordering among the nodes.  The node
insertion and node removal operations are implemented in such a way
that:

   * The left child of a node has key less than the one the node.

   * The right child of a node has key greater than, or equal to, the
     one of the node.

   Here is an example of binary search tree, with nodes in the correct
order:

     5-------10----12
     |        |     |
     1--3--4  7--9 11
        |     |  |
        2     6  8

the root node has sort key '5'; the left child of the root has sort key
'1'; the right child of the root has sort key '10'.  Let's take '10' as
example: every node in its left subtree has key less than '10'; every
node in its right subtree has key greater than, or equal to, '10'.  This
is a general property of binary search trees.

   The library '(vicare containers binary-search-trees)' is the core
library for binary search tree implementation; it implements trees in
such a way that:

   * The empty tree is represented by '#f'.

   * A node is represented by an instance of type '<binary-node>' or a
     subtype of this type.

   * The type '<binary-node>' has 3 fields: 'parent', 'left', 'right'.
     The value of these fields can be '#f' or an instance of
     '<binary-node>'.

   * If the 'parent' field of a node is set to '#f': it means that node
     is the root of a tree.

   All the functions acting on instances of '<binary-node>' are meant to
be usable on trees implementing any node balancing strategy; they only
expect the binary tree to be a binary search tree as defined above.  The
core library only implements unbalanced binary search trees, in which
nodes have the type '<unbalanced-binary-node>'.  The type hierarchy is:

     (define-record-type <binary-node>
       ---)

     (define-record-type <unbalanced-binary-node>
       (parent <binary-node>)
       ---)

   By themselves, these types have no sort key; to associate a sort key
with a node instance we need to subtype them.  The following is an
example of binary search tree of fixnums:

     (import (vicare)
       (vicare containers binary-search-trees))

     (define-record-type <fixnum-node>
       (parent <unbalanced-binary-node>)

       (fields (immutable sort-key))

       (protocol
        (lambda (make-unbalanced-binary-node)
          (case-lambda*
            (()
             ((make-unbalanced-binary-node #f #f) (void)))

            ((key)
             ((make-unbalanced-binary-node #f #f) key))

            (({key   fixnum?}
              {left  false-or-unbalanced-binary-node?}
              {right false-or-unbalanced-binary-node?})
             ((make-unbalanced-binary-node left right) key)))))

       #| end of DEFINE-RECORD-TYPE |# )

     (define (key< new old)
       (fx<? (<fixnum-node>-sort-key new)
             (<fixnum-node>-sort-key old)))

     (define (make-comparison-proc target-key)
       (lambda (node)
         (let ((key (<fixnum-node>-sort-key node)))
           (cond ((fx=? target-key key)       0)
                 ((fx<? target-key key)      -1)
                 (else                       +1)))))

we can build a tree from a list and then search for a node as follows:

     (define (tree . key*)
       (fold-left (lambda (root key)
                    (unbalanced-tree-insert! root key<
                       (make-<fixnum-node> key)))
         #f key*))

     ;; 5-------10----12
     ;; |        |     |
     ;; 1--3--4  7--9 11
     ;;    |     |  |
     ;;    2     6  8
     (define root
       (tree 5 1 3 2 4 10 7 12 6 9 8 11))

     (define node
       (binary-tree-find root (make-comparison-proc 8)))

we can perform a forwards in-order iteration as follows:

     (binary-tree-fold-in-order-forwards
         (lambda (knil node)
           (cons (<fixnum-node>-sort-key node) knil))
       '() root))
     => (12 11 10 9 8 7 6 5 4 3 2 1)

in the result of this operation: the sort key in the first node from the
search is the last item in the list.


File: vicare-libs.info,  Node: bst bnodes,  Next: bst unodes,  Prev: bst intro,  Up: bst

41.2 Binary node objects
========================

Binary search trees are composed of "binary node objects" linked
together in a tree hierarchy.  The object type '<binary-node>' is the
base type of all the node types.

* Menu:

* bst bnodes objects::          Binary node data type.
* bst bnodes access::           Accessors and mutators for binary nodes.
* bst bnodes pred::             Structure predicates for binary nodes.
* bst bnodes inspect::          Inspecting binary trees.
* bst bnodes searching::        Searching in binary trees.
* bst bnodes iterating::        Iterating over binary trees.
* bst bnodes validating::       Validating binary trees.


File: vicare-libs.info,  Node: bst bnodes objects,  Next: bst bnodes access,  Up: bst bnodes

41.2.1 Binary node data type
----------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.

 -- R6RS Record Type: <binary-node>
     Record type representing a node in a binary tree.  The
     '<binary-node>' type is non-generative and available for subtyping.
     In this documentation '<binary-node>' object arguments to functions
     are indicated as BNODE.

     This type has the following fields:

     'parent'
          An instance of '<binary-node>' representing the parent node;
          '#f' if this node has no parent.

     'left'
          An instance of '<binary-node>' representing the left child,
          the root of the left subtree; '#f' if this node has no left
          subtree.

     'right'
          An instance of '<binary-node>' representing the right child,
          the root of the right subtree; '#f' if this node has no right
          subtree.

 -- Function: make-binary-node
 -- Function: make-binary-node LEFT RIGHT
     Build and return a new instance of '<binary-node>'.  The optional
     LEFT and RIGHT arguments must be '#f' or instances of
     '<binary-node>' representing the left and right subtrees.  The
     'parent' field of the new instance is set to '#f'.

 -- Function: binary-node? OBJ
     Return '#t' if OBJ is an instance of '<binary-node>'; otherwise
     return '#f'.


File: vicare-libs.info,  Node: bst bnodes access,  Next: bst bnodes pred,  Prev: bst bnodes objects,  Up: bst bnodes

41.2.2 Accessors and mutators for binary nodes
----------------------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: binary-node-parent BNODE
 -- Function: $binary-node-parent BNODE
     Accessor for the parent node of BNODE.  Return '#f' or an instance
     of '<binary-node>'.

 -- Function: binary-node-left BNODE
 -- Function: $binary-node-left BNODE
     Accessor for the left subtree of BNODE.  Return '#f' or an instance
     of '<binary-node>'.

 -- Function: binary-node-left-set! BNODE LEFT
 -- Function: $binary-node-left-set! BNODE LEFT
     Mutator for the left subtree of a '<binary-node>' instance.  The
     argument LEFT must be '#f' or an instance of '<binary-node>'
     representing the root of the left subtree.  When LEFT is a node: it
     is mutated to reference BNODE as parent.

 -- Function: binary-node-right BNODE
 -- Function: $binary-node-right BNODE
     Accessor for the right subtree of BNODE.  Return '#f' or an
     instance of '<binary-node>'.

 -- Function: binary-node-right-set! BNODE RIGHT
 -- Function: $binary-node-right-set! BNODE RIGHT
     Mutator for the right subtree of a '<binary-node>' instance.  The
     argument RIGHT must be '#f' or an instance of '<binary-node>'
     representing the root of the right subtree.  When RIGHT is a node:
     it is mutated to reference BNODE as parent.

 -- Function: binary-node-replace-in-parent! OLD-CHILD NEW-CHILD
 -- Function: $binary-node-replace-in-parent! OLD-CHILD NEW-CHILD
     Replace one child node with another child node.

     The argument OLD-CHILD must be an instance of '<binary-node>'; the
     argument NEW-CHILD must be '#f' or an instance of '<binary-node>'.

     Let's name DAD the parent of OLD-CHILD, DAD can be '#f' or an
     instance of '<binary-node>'; this function performs the following
     operations:

        * If DAD is a node and OLD-CHILD is the left child of DAD: set
          NEW-CHILD as left child of DAD.

        * If DAD is a node and OLD-CHILD is the right child of DAD: set
          NEW-CHILD as right child of DAD.

        * The parent of OLD-CHILD is set to '#f'.

        * If NEW-CHILD is a node: the parent of NEW-CHILD is set to DAD.

     As example, let's consider this simple tree:

          2--3  0
          |
          1

     applying this function to OLD-CHILD having key '1' and NEW-CHILD
     having key '0', results in the following tree:

          2--3  1
          |
          0


File: vicare-libs.info,  Node: bst bnodes pred,  Next: bst bnodes inspect,  Prev: bst bnodes access,  Up: bst bnodes

41.2.3 Structure predicates for binary nodes
--------------------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: binary-node-parent-and-left-child? BNODE1 BNODE2
 -- Function: $binary-node-parent-and-left-child? BNODE1 BNODE2
     Return '#t' if BNODE2 is the left child of BNODE1; otherwise return
     '#f'.

 -- Function: binary-node-parent-and-right-child? BNODE1 BNODE2
 -- Function: $binary-node-parent-and-right-child? BNODE1 BNODE2
     Return '#t' if BNODE2 is the right child of BNODE1; otherwise
     return '#f'.

 -- Function: binary-node-parent-and-child? BNODE1 BNODE2
 -- Function: $binary-node-parent-and-child? BNODE1 BNODE2
     Return '#t' if BNODE2 is the left or right child of BNODE1;
     otherwise return '#f'.

 -- Function: binary-node-root? BNODE
 -- Function: $binary-node-root? BNODE
     Return '#t' if BNODE is the root of a tree (it has no parent);
     otherwise return '#f'.

 -- Function: binary-node-leaf? BNODE
 -- Function: $binary-node-leaf? BNODE
     Return '#t' if BNODE is a leaf in the a tree (it has no children);
     otherwise return '#f'.


File: vicare-libs.info,  Node: bst bnodes inspect,  Next: bst bnodes searching,  Prev: bst bnodes pred,  Up: bst bnodes

41.2.4 Inspecting binary trees
------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: binary-tree-depth NODE
 -- Function: $binary-node-depth NODE
     Return an exact integer representing the depth of NODE in the
     binary tree.  NODE must be '#f' to represent and empty tree or an
     instance of '<binary-node>'.

        * If NODE is '#f': the return value is '0'.

        * If NODE is the root of a tree: the return value is '1'.

        * If NODE is a child of the root of a tree: the return value is
          '2'.

        * And so on.


File: vicare-libs.info,  Node: bst bnodes searching,  Next: bst bnodes iterating,  Prev: bst bnodes inspect,  Up: bst bnodes

41.2.5 Searching in binary trees
--------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: binary-tree-root NODE
 -- Function: $binary-tree-root NODE
     Find the root of a binary tree.  The argument NODE must be:

        * '#f' to represent an empty tree; in this case the return value
          is '#f'.

        * An instance of '<binary-node>'; in this case the return value
          is an instance of '<binary-node>'.

 -- Function: binary-tree-minimum ROOT
 -- Function: binary-tree-minimum ROOT EMPTY-TREE-HANDLER
 -- Function: $binary-tree-minimum ROOT EMPTY-TREE-HANDLER
     Search and return the minimum node in the tree starting from ROOT;
     the minimum node is the leftmost from ROOT.

     The argument ROOT must be '#f', to represent an empty tree, or an
     instance of '<binary-node>'.

     The optional argument EMPTY-TREE-HANDLER must be a thunk.  If ROOT
     is '#f' and EMPTY-TREE-HANDLER is not used: the return value is
     '#f'.  If ROOT is '#f' and EMPTY-TREE-HANDLER is used: the return
     value is the return value of EMPTY-TREE-HANDLER.

 -- Function: binary-tree-maximum ROOT
 -- Function: binary-tree-maximum ROOT EMPTY-TREE-HANDLER
 -- Function: $binary-tree-maximum ROOT EMPTY-TREE-HANDLER
     Search and return the maximum node in the tree starting from ROOT;
     the maximum node is the rightmost from ROOT.

     The argument ROOT must be '#f', to represent an empty tree, or an
     instance of '<binary-node>'.

     The optional argument EMPTY-TREE-HANDLER must be a thunk.  If ROOT
     is '#f' and EMPTY-TREE-HANDLER is not used: the return value is
     '#f'.  If ROOT is '#f' and EMPTY-TREE-HANDLER is used: the return
     value is the return value of EMPTY-TREE-HANDLER.

 -- Function: binary-tree-find ROOT COMPARE
 -- Function: binary-tree-find ROOT COMPARE EMPTY-TREE-HANDLER
 -- Function: $binary-tree-find ROOT COMPARE EMPTY-TREE-HANDLER
     Search and return a node in the tree starting from ROOT based on
     its sort key.

     The argument ROOT must be '#f', to represent an empty tree, or an
     instance of '<binary-node>'.

     The argument COMPARE must be a procedure accepting an instance of
     '<binary-node>' as single argument; it must return a single value:

     '0'
          If the argument node satisfies the search criterion.

     '-1'
          If the argument node has sort key less than the sort key of
          the target node.

     '+1'
          If the argument node has sort key greater than, or equal to,
          the sort key of the target node.

     The optional argument EMPTY-TREE-HANDLER must be a thunk.  If the
     target node is not found and EMPTY-TREE-HANDLER is not used: the
     return value is '#f'.  If the target node it not found and
     EMPTY-TREE-HANDLER is used: the return value is the return value of
     EMPTY-TREE-HANDLER.

 -- Function: binary-tree-deepest-left-leaf ROOT
 -- Function: $binary-tree-deepest-left-leaf ROOT
     Find the deepest leaf in the left subtrees starting from ROOT.  The
     argument root must be '#f' to represent an empty tree or an
     instance of '<binary-node>'.

     As example, given the tree:

          5-------10----12
          |        |     |
          1--3--4  7--9 11
             |     |  |
             2     6  8

     starting from '5' the selected node is '2', starting from '10' the
     selected node is '6'.

 -- Function: binary-tree-deepest-right-leaf ROOT
 -- Function: $binary-tree-deepest-right-leaf ROOT
     Find the deepest leaf in the right subtrees starting from ROOT.
     The argument root must be '#f' to represent an empty tree or an
     instance of '<binary-node>'.

     As example, given the tree:

          5-------10----12
          |        |     |
          1--3--4  7--9 11
             |     |  |
             2     6  8

     starting from '5' the selected node is '11', starting from '1' the
     selected node is '4'.


File: vicare-libs.info,  Node: bst bnodes iterating,  Next: bst bnodes validating,  Prev: bst bnodes searching,  Up: bst bnodes

41.2.6 Iterating over binary trees
----------------------------------

* Menu:

* bst bnodes iterating in-order::       In-order iterations.
* bst bnodes iterating pre-order::      Pre-order iterations.
* bst bnodes iterating post-order::     Post-order iterations.
* bst bnodes iterating level-order::    Level-order iterations.
* bst bnodes iterating breadth-first::  Breadth-first iterations.
* bst bnodes iterating thunks::         Iteration thunks.


File: vicare-libs.info,  Node: bst bnodes iterating in-order,  Next: bst bnodes iterating pre-order,  Up: bst bnodes iterating

41.2.6.1 In-order iterations
............................

Forwards in-order iteration: visit all the nodes from the leftmost to
the rightmost.  Backwards in-order iteration: visit all the nodes from
the rightmost to the leftmost.  As example, given the tree:

     5-------10----12
     |        |     |
     1--3--4  7--9 11
        |     |  |
        2     6  8

the inorder iteration is:

     forward:   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12
     backward: 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1

   Here is an example of forwards and backwards in-order iteration using
trees of fixnums as defined in the introduction (*note bst intro::):

     (define root
       ;; 5-------10----12
       ;; |        |     |
       ;; 1--3--4  7--9 11
       ;;    |     |  |
       ;;    2     6  8
       (tree 5 1 3 2 4 10 7 12 6 9 8 11))

     ;;By reversing we return a list in which: the first item
     ;;is the sort key of the first node visited in the iteration.
     (reverse
       (binary-tree-fold-in-order-forwards
           (lambda (knil node)
             (cons (<fixnum-node>-sort-key node) knil))
         '() root))
     => (1 2 3 4 5 6 7 8 9 10 11 12)

     ;;By reversing we return a list in which: the first item
     ;;is the sort key of the first node visited in the iteration.
     (reverse
       (binary-tree-fold-in-order-backwards
           (lambda (node knil)
             (cons (<fixnum-node>-sort-key node) knil))
         '() root))
     => (12 11 10 9 8 7 6 5 4 3 2 1)

   The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

Forwards iteration
..................

 -- Function: binary-tree-fold-in-order-forwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-in-order-forwards KONS KNIL ROOT
     Like 'fold-left' for lists, visit the nodes of a binary tree with a
     in-order forwards iteration.  The argument ROOT must be '#f' to
     represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-in-order-forwards ROOT
 -- Function: $binary-tree-begin-in-order-forwards ROOT
     Perform the first step in a in-order forwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-in-order-forwards BNODE
 -- Function: $binary-tree-step-in-order-forwards BNODE
     Advance an in-order forwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.

Backwards iteration
...................

 -- Function: binary-tree-fold-in-order-backwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-in-order-backwards KONS KNIL ROOT
     Like 'fold-right' for lists, visit the nodes of a binary tree with
     a in-order backwards iteration.  The argument ROOT must be '#f' to
     represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-in-order-backwards ROOT
 -- Function: $binary-tree-begin-in-order-backwards ROOT
     Perform the first step in a in-order backwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-in-order-backwards BNODE
 -- Function: $binary-tree-step-in-order-backwards BNODE
     Advance an in-order backwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.


File: vicare-libs.info,  Node: bst bnodes iterating pre-order,  Next: bst bnodes iterating post-order,  Prev: bst bnodes iterating in-order,  Up: bst bnodes iterating

41.2.6.2 Pre-order iterations
.............................

Pre-order iteration: visit the current node then the left child then the
right child.  As example, given the tree:

     5-------10----12
     |        |     |
     1--3--4  7--9 11
        |     |  |
        2     6  8

the pre-order iteration is:

     forward:    5,  1,  3,  2,  4, 10,  7,  6,  9,  8, 12, 11
     backward:   5, 10, 12, 11,  7,  9,  8,  6,  1,  3,  4,  2

the forwards iteration is a "worm that always turns right", while the
backwards iteration is a "worm that always turns left".

   The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

Forwards iteration
..................

 -- Function: binary-tree-fold-pre-order-forwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-pre-order-forwards KONS KNIL ROOT
     Like 'fold-left' for lists, visit the nodes of a binary tree with a
     pre-order forwards iteration.  The argument ROOT must be '#f' to
     represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-pre-order-forwards ROOT
 -- Function: $binary-tree-begin-pre-order-forwards ROOT
     Perform the first step in a pre-order forwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-pre-order-forwards BNODE
 -- Function: $binary-tree-step-pre-order-forwards BNODE
     Advance an pre-order forwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.

Backwards iteration
...................

 -- Function: binary-tree-fold-pre-order-backwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-pre-order-backwards KONS KNIL ROOT
     Like 'fold-right' for lists, visit the nodes of a binary tree with
     a pre-order backwards iteration.  The argument ROOT must be '#f' to
     represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-pre-order-backwards ROOT
 -- Function: $binary-tree-begin-pre-order-backwards ROOT
     Perform the first step in a pre-order backwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-pre-order-backwards BNODE
 -- Function: $binary-tree-step-pre-order-backwards BNODE
     Advance an pre-order backwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.


File: vicare-libs.info,  Node: bst bnodes iterating post-order,  Next: bst bnodes iterating level-order,  Prev: bst bnodes iterating pre-order,  Up: bst bnodes iterating

41.2.6.3 Post-order iterations
..............................

Post-order iteration: visit the left-child, then the right-child, then
the parent node.  As example, given the tree:

     5-------10----12
     |        |     |
     1--3--4  7--9 11
        |     |  |
        2     6  8

the post-order iteration is:

     forward:    2,  4,  3,  1,  6,  8,  9,  7, 11, 12, 10,  5
     backward:  11, 12,  8,  9,  6,  7, 10,  4,  2,  3,  1,  5

   The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

Forwards iteration
..................

 -- Function: binary-tree-fold-post-order-forwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-post-order-forwards KONS KNIL ROOT
     Like 'fold-left' for lists, visit the nodes of a binary tree with a
     post-order forwards iteration.  The argument ROOT must be '#f' to
     represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-post-order-forwards ROOT
 -- Function: $binary-tree-begin-post-order-forwards ROOT
     Perform the first step in a post-order forwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-post-order-forwards BNODE
 -- Function: $binary-tree-step-post-order-forwards BNODE
     Advance an post-order forwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.

Backwards iteration
...................

 -- Function: binary-tree-fold-post-order-backwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-post-order-backwards KONS KNIL ROOT
     Like 'fold-right' for lists, visit the nodes of a binary tree with
     a post-order backwards iteration.  The argument ROOT must be '#f'
     to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-post-order-backwards ROOT
 -- Function: $binary-tree-begin-post-order-backwards ROOT
     Perform the first step in a post-order backwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-post-order-backwards BNODE
 -- Function: $binary-tree-step-post-order-backwards BNODE
     Advance an post-order backwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.


File: vicare-libs.info,  Node: bst bnodes iterating level-order,  Next: bst bnodes iterating breadth-first,  Prev: bst bnodes iterating post-order,  Up: bst bnodes iterating

41.2.6.4 Level-order iterations
...............................

Level-order iteration: visit the tree level by level.  Example:

     5-------10----12
     |        |     |
     1--3--4  7--9 11
        |     |  |
        2     6  8

the order of the forwards iteration is: 5, 1, 10, 3, 7, 12, 2, 4, 6, 9,
11, 8.  To do it we need a moving cursor that always "turns right"
keeping the count of the level.  The order of the backwards iteration
is: 5, 10, 1, 12, 7, 3, 11, 9, 6, 4, 2, 8.

   The implementation of the level-order iteration is particularly slow,
but it has the current node as the only state.  The level-order
iteration is usually called "breadth-first iteration" or "breadth-first
search", that name is reserved for another implementation (*note
Breadth-first iterations: bst bnodes iterating breadth-first.).

   The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

Forwards iteration
..................

 -- Function: binary-tree-fold-level-order-forwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-level-order-forwards KONS KNIL ROOT
     Like 'fold-left' for lists, visit the nodes of a binary tree with a
     level-order forwards iteration.  The argument ROOT must be '#f' to
     represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-level-order-forwards ROOT
 -- Function: $binary-tree-begin-level-order-forwards ROOT
     Perform the first step in a level-order forwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-level-order-forwards BNODE
 -- Function: $binary-tree-step-level-order-forwards BNODE
     Advance a level-order forwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.

Backwards iteration
...................

 -- Function: binary-tree-fold-level-order-backwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-level-order-backwards KONS KNIL ROOT
     Like 'fold-right' for lists,a visit the nodes of a binary tree with
     a level-order backwards iteration.  The argument ROOT must be '#f'
     to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-level-order-backwards ROOT
 -- Function: $binary-tree-begin-level-order-backwards ROOT
     Perform the first step in a level-order backwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.  If
     the tree is empty: return '#f'; otherwise return an instance of
     '<binary-node>' representing the first visited node.

 -- Function: binary-tree-step-level-order-backwards BNODE
 -- Function: $binary-tree-step-level-order-backwards BNODE
     Advance a level-order backwards iteration by one step starting from
     BNODE, which must be an instance of '<binary-node>'.  If BNODE is
     the last in the iteration: return '#f'; otherwise return an
     instance of '<binary-node>' representing the next visited node.


File: vicare-libs.info,  Node: bst bnodes iterating breadth-first,  Next: bst bnodes iterating thunks,  Prev: bst bnodes iterating level-order,  Up: bst bnodes iterating

41.2.6.5 Breadth-first iterations
.................................

Breadth-first iteration: visit the tree level by level.  Example:

     5-------10----12
     |        |     |
     1--3--4  7--9 11
        |     |  |
        2     6  8

the order of the forwards iteration is: 5, 1, 10, 3, 7, 12, 2, 4, 6, 9,
11, 8.  To do it we need a moving cursor that always "turns right"
keeping the count of the level.  The order of the backwards iteration
is: 5, 10, 1, 12, 7, 3, 11, 9, 6, 4, 2, 8.

   The implementation of the breadth-first iteration makes use,
internally of a queue container.  The API of this iteration is
*different* from the one of the other iterations.

   The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

Forwards iteration
..................

 -- Function: binary-tree-fold-breadth-first-forwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-breadth-first-forwards KONS KNIL ROOT
     Like 'fold-left' for lists, visit the nodes of a binary tree with a
     breadth-first forwards iteration.  The argument ROOT must be '#f'
     to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-breadth-first-forwards ROOT
 -- Function: $binary-tree-begin-breadth-first-forwards ROOT
     Perform the first step in a breadth-first forwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.
     Return 2 values:

        * If the tree is empty: return '#f' and '#f'.

        * If the tree is not empty: return an object representing the
          state of the iteration and an instance of '<binary-node>'
          representing the first visited node.

 -- Function: binary-tree-step-breadth-first-forwards STATE
 -- Function: $binary-tree-step-breadth-first-forwards STATE
     Advance a breadth-first forwards iteration by one step; STATE must
     be the object representing the state of the iteration.  Return 2
     values:

        * If the iteration is over: return '#f' and '#f'.

        * If the iteratio is not over: return an object representing the
          state of the iteration and an instance of '<binary-node>'
          representing the next visited node.

Backwards iteration
...................

 -- Function: binary-tree-fold-breadth-first-backwards KONS KNIL ROOT
 -- Function: $binary-tree-fold-breadth-first-backwards KONS KNIL ROOT
     Like 'fold-left' for lists, visit the nodes of a binary tree with a
     breadth-first backwards iteration.  The argument ROOT must be '#f'
     to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: binary-tree-begin-breadth-first-backwards ROOT
 -- Function: $binary-tree-begin-breadth-first-backwards ROOT
     Perform the first step in a breadth-first backwards iteration.  The
     argument ROOT must be '#f' to represent an empty tree or an
     instance of '<binary-node>' representing the root of a tree.
     Return 2 values:

        * If the tree is empty: return '#f' and '#f'.

        * If the tree is not empty: return an object representing the
          state of the iteration and an instance of '<binary-node>'
          representing the first visited node.

 -- Function: binary-tree-step-breadth-first-backwards STATE
 -- Function: $binary-tree-step-breadth-first-backwards STATE
     Advance a breadth-first backwards iteration by one step; STATE must
     be the object representing the state of the iteration.  Return 2
     values:

        * If the iteration is over: return '#f' and '#f'.

        * If the iteratio is not over: return an object representing the
          state of the iteration and an instance of '<binary-node>'
          representing the next visited node.


File: vicare-libs.info,  Node: bst bnodes iterating thunks,  Prev: bst bnodes iterating breadth-first,  Up: bst bnodes iterating

41.2.6.6 Iteration thunks
.........................

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers binary-search-trees)'.

 -- Function: make-binary-tree-forwards-in-order-iteration-thunk ROOT
 -- Function: make-binary-tree-backwards-in-order-iteration-thunk ROOT
     Build and return an iteration thunk visiting the node of a tree
     with a in-order forwards or backwards iteration.  ROOT must be '#f'
     to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

     Here is an example with the fixnum trees defined in the
     introduction (*note bst intro::):

          (import (vicare containers iteration-thunks))

          (define root
            ;; 5-------10----12
            ;; |        |     |
            ;; 1--3--4  7--9 11
            ;;    |     |  |
            ;;    2     6  8
            (tree 5 1 3 2 4 10 7 12 6 9 8 11))

          (iteration-thunk-fold
              (lambda (knil node)
                (cons (<fixnum-node>-sort-key node) knil))
            '()
            (make-binary-tree-forwards-in-order-iteration-thunk root))
          => (12 11 10 9 8 7 6 5 4 3 2 1)

 -- Function: make-binary-tree-forwards-pre-order-iteration-thunk ROOT
 -- Function: make-binary-tree-backwards-pre-order-iteration-thunk ROOT
     Build and return an iteration thunk visiting the node of a tree
     with a pre-order forwards or backwards iteration.  ROOT must be
     '#f' to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: make-binary-tree-forwards-post-order-iteration-thunk ROOT
 -- Function: make-binary-tree-backwards-post-order-iteration-thunk ROOT
     Build and return an iteration thunk visiting the node of a tree
     with a post-order forwards or backwards iteration.  ROOT must be
     '#f' to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: make-binary-tree-forwards-level-order-iteration-thunk ROOT
 -- Function: make-binary-tree-backwards-level-order-iteration-thunk
          ROOT
     Build and return an iteration thunk visiting the node of a tree
     with a level-order forwards or backwards iteration.  ROOT must be
     '#f' to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.

 -- Function: make-binary-tree-forwards-breadth-first-iteration-thunk
          ROOT
 -- Function: make-binary-tree-backwards-breadth-first-iteration-thunk
          ROOT
     Build and return an iteration thunk visiting the node of a tree
     with a breadth-first forwards or backwards iteration.  ROOT must be
     '#f' to represent an empty tree or an instance of '<binary-node>'
     representing the root of a tree.


File: vicare-libs.info,  Node: bst bnodes validating,  Prev: bst bnodes iterating,  Up: bst bnodes

41.2.7 Validating binary trees
------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: binary-tree-valid? ROOT KEY<
 -- Function: $binary-tree-valid? ROOT KEY<
     Traverse a binary search tree from ROOT verifying that: all the
     left subtrees have sort key less than that of their parents; all
     the right subtrees have sort key greater than, or equal to, that of
     their parents.

     The argument ROOT must be '#f', to represent an empty tree, or an
     instance of '<binary-node>' representing the root of the tree.

     The argument KEY< must be a procedure taking 2 arguments being
     instances of '<binary-node>': it must return true if the first
     argument has sort key less than the sort key of the second
     argument; otherwise it must return '#f'.


File: vicare-libs.info,  Node: bst unodes,  Prev: bst bnodes,  Up: bst

41.3 Unbalanced binary node objects
===================================

The "unbalanced binary search trees" support insertion and removal of
nodes without implementing any balancing algorithm.  The performance of
these trees is low, but they are useful for debugging purposes.

* Menu:

* bst unodes objects::          Unbalanced binary node data type.
* bst unodes ops::              Operations on unbalanced trees.


File: vicare-libs.info,  Node: bst unodes objects,  Next: bst unodes ops,  Up: bst unodes

41.3.1 Unbalanced binary node data type
---------------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.

 -- R6RS Record Type: <unbalanced-binary-node>
     Record type representing a node in a binary tree.  The
     '<unbalanced-binary-node>' type is non-generative and available for
     subtyping.  It is derived from '<binary-node>'.  In this
     documentation '<unbalanced-binary-node>' object arguments to
     functions are indicated as UNODE.

 -- Function: make-unbalanced-binary-node
 -- Function: make-unbalanced-binary-node LEFT RIGHT
     Build and return a new instance of '<unbalanced-binary-node>'.  The
     optional arguments LEFT and RIGHT must be '#f' or instances of
     '<unbalanced-binary-node>' representing the left and right
     subtrees.  The 'parent' field of the new instance is set to '#f'.

 -- Function: unbalanced-binary-node? OBJ
     Return '#t' if OBJ is an instance of '<unbalanced-binary-node>';
     otherwise return '#f'.


File: vicare-libs.info,  Node: bst unodes ops,  Prev: bst unodes objects,  Up: bst unodes

41.3.2 Operations on unbalanced binary nodes
--------------------------------------------

The following syntactic bindings are exported by the library '(vicare
containers binary-search-trees)'.  The bindings whose name is prefixed
with '$' are unsafe operations: they do *not* validate their arguments
before accessing them.

 -- Function: unbalanced-tree-insert! ROOT KEY< UNODE
 -- Function: $unbalanced-tree-insert! ROOT KEY< UNODE
     Insert a new node into an unbalanced binary tree.

     The argument ROOT must be '#f' or an instance of
     '<unbalanced-binary-node>' representing the root of the tree.

     The argument KEY< must be a procedure accepting two arguments of
     type '<binary-node>' and returning: true if the first argument has
     sort key less than the second argument; '#f' otherwise.  Example
     for the trees of fixnums defined in the introduction (*note bst
     intro::):

          (define (key< one two)
            (fx<? (<fixnum-node>-sort-key one)
                  (<fixnum-node>-sort-key two)))

     The argument UNODE must be an instance of
     '<unbalanced-binary-node>' representing the new node to insert.
     This node is meant to have left and right fields set to '#f'.

     The return value is the root node after the insertion operation.
     If the argument ROOT is '#f': the return value is UNODE.  If the
     argument ROOT is a node: the return value is ROOT itself.

 -- Function: unbalanced-tree-remove! UNODE ROOT
 -- Function: $unbalanced-tree-remove! UNODE ROOT
     Remove a node from an unbalanced binary tree.  UNODE must be the
     instance of '<unbalanced-binary-node>' to remove.  ROOT must be an
     instance of '<unbalanced-binary-node>' representing the root of the
     binary tree; it can be that UNODE equals ROOT.

     Return an instance of '<unbalanced-binary-node>' representing the
     new tree root after UNODE removal.  If, after the removal, the tree
     is left empty: the return value is '#f'.


File: vicare-libs.info,  Node: sets bags,  Next: bitvectors,  Prev: bst,  Up: Top

42 Sets and bags
****************

The library '(vicare containers sets-and-bags)' implements sets and
bags; sets and bags (also known as multisets) are unordered collections
that can contain any Scheme object.

   This library is actually the reference implementation of SRFI-113
adapted to Vicare.  The library exports the same syntactic bindings of
the library '(srfi :113 sets-and-bags)'.  *note SRFI-113 sets and bags:
srfi sets-and-bags, for the documentation.


File: vicare-libs.info,  Node: bitvectors,  Next: ilists,  Prev: sets bags,  Up: Top

43 Bitvectors
*************

The library '(vicare containers bitvectors)' implements vectors of bits.

* Menu:

* bitvectors type::             Record type of bitvectors.
* bitvectors inspection::       Inspecting bitvectors.
* bitvectors bits::             Bitwise operations on bitvectors.
* bitvectors conv::             Conversion operations on bitvectors.


File: vicare-libs.info,  Node: bitvectors type,  Next: bitvectors inspection,  Up: bitvectors

43.1 Record type of bitvectors
==============================

The following bindings are exported by the library '(vicare containers
bitvectors)'.

 -- Record Type: <bitvector>
     Name of object-type representing bitvectors.  The current
     implementation is as vector of fixnums.  Instances of this type can
     be compared with 'equal?'.

 -- Constructor on <bitvector>: <bitvector> constructor {LENGTH
          <non-negative-exact-integer>}
     Build and return a new '<bitvector>' object capable of holding
     LENGTH bits.  The bits are initialised to '#f'.

 -- Hash function on <bitvector>: <non-negative-fixnum> hash {OBJ
          <bitvector>}
     Return the hash value for the '<bitvector>'.

 -- Method on <bitvector>: <bitvector> clone
     Return a new '<bitvector>' instance equal to this instance.


File: vicare-libs.info,  Node: bitvectors inspection,  Next: bitvectors bits,  Prev: bitvectors type,  Up: bitvectors

43.2 Inspecting bitvectors
==========================

The following bindings are exported by the library '(vicare containers
bitvectors)'.

 -- Method on <bitvector>: <non-negative-exact-integer> length
     Return the number of bits.


File: vicare-libs.info,  Node: bitvectors bits,  Next: bitvectors conv,  Prev: bitvectors inspection,  Up: bitvectors

43.3 Bitwise operations on bitvectors
=====================================

The following bindings are exported by the library '(vicare containers
bitvectors)'.

 -- Method on <bitvector>: () bit-set! {BIT-INDEX
          <non-negative-exact-integer>} BOOL
     Set the bit at BIT-INDEX in the '<bitvector>' to one if BOOL is
     non-false, or to zero if BOOL is '#f'.

 -- Method on <bitvector>: <boolean> bit-ref {BIT-INDEX
          <non-negative-exact-integer>}
     Return a boolean representing the bit at BIT-INDEX in the
     '<bitvector>'.

 -- Method on <bitvector>: () set-all!
 -- Method on <bitvector>: () clear-all!
     Set all the bits to true or to false.

 -- Method on <bitvector>: () toggle! BIT-INDEX
     Invert the bit at BIT-INDEX.

 -- Method on <bitvector>: <bitvector> not
     Apply the bitwise NOT to the instance and return a new
     '<bitvector>' object holding the result.

 -- Method on <bitvector>: <bitvector> not!
     Mutate this instance by applying the bitwise NOT operation and
     storing the result in the instance itself.  The return value is the
     instance object itself.

 -- Method on <bitvector>: <bitvector> and {B <bitvector>}
 -- Method on <bitvector>: <bitvector> ior {B <bitvector>}
 -- Method on <bitvector>: <bitvector> xor {B <bitvector>}
     Apply the bitwise AND, inclusive OR or exclusive OR to the instance
     and B, then return a new '<bitvector>' object representing the
     result.  B must have the same length of the instance.

 -- Method on <bitvector>: <bitvector> and! {B <bitvector>}
 -- Method on <bitvector>: <bitvector> ior! {B <bitvector>}
 -- Method on <bitvector>: <bitvector> xor! {B <bitvector>}
     Mutate this instance by applying the bitwise AND, inclusive OR or
     exclusive OR to the instance and B and storing the result in the
     instance itself.  B must have the same length of the instance.

 -- Method on <bitvector>: <non-negative-exact-integer> bit-count
     Return an exact integer being the number of bits set to true.

 -- Method on <bitvector>: <exact-integer> first-bit-set
     Return an exact integer being the offset of the first bit set to
     true; if all the bits are set to false: return -1.


File: vicare-libs.info,  Node: bitvectors conv,  Prev: bitvectors bits,  Up: bitvectors

43.4 Conversion operations on bitvectors
========================================

The following bindings are exported by the library '(vicare containers
bitvectors)'.

 -- Method on <bitvector>: (list-of <boolean>) list
 -- Method on <bitvector>: (vector-of <boolean>) vector
     Return a list or vector filled with boolean values representing the
     bits of the bitvector.  The boolean at index zero in the returned
     sequence corresponds to the bit at index zero in the bitvector.

 -- Method on <bitvector>: <non-negative-exact-integer>
          non-negative-exact-integer
     Return an exact integer representing the bits in the instance.

 -- Function: <bitvector> list->bitvector {ELL (list-of <boolean>)}
 -- Function: <bitvector> vector->bitvector {VEC (vector-of <boolean>)}
     Build and return a new '<bitvector>' object representing the values
     in the list ELL or vector VEC.

 -- Function: <bitvector> non-negative-exact-integer->bitvector {N
          <non-negative-exact-integer>}
     Build and return a new '<bitvector>' object being the bitwise
     representation given exact integer.


File: vicare-libs.info,  Node: ilists,  Next: ralists,  Prev: bitvectors,  Up: Top

44 Immutable lists
******************

The library '(vicare containers ilists)' implements immutable lists.
This library is actually the reference implementation of SRFI-116
adapted to Vicare.  The library exports the same syntactic bindings of
the library '(srfi :116 ilists)'.  *note SRFI-116 immutable lists: srfi
ilists, for the documentation.

   The library '(vicare containers ilists comparators)' implements
comparators for immutable lists; it exports the same syntactic bindings
of '(srfi :116 comparators)'.

   The library '(vicare containers ilists quotations)' implements
special quotation syntaxes; it exports the same syntactic bindings of
'(srfi :116 quotations)'.


File: vicare-libs.info,  Node: ralists,  Next: istacks,  Prev: ilists,  Up: Top

45 Random-access lists
**********************

The library '(vicare containers ralists)' implements random-access
lists.  This library is actually the reference implementation of
SRFI-101 adapted to Vicare.  The library exports the same syntactic
bindings of the library '(srfi :101)'.  *note SRFI-101 random-access
lists: srfi ralists, for the documentation.

   To avoid name conflicts, it is suggested to prefix the syntactic
bindings when importing this library; for example:

     (import (prefix (vicare containers ralists) ra.))


File: vicare-libs.info,  Node: istacks,  Next: iqueues,  Prev: ralists,  Up: Top

46 Common interface to stack-like containers
********************************************

The library '(vicare containers istacks)' implements a common API for
stack-like containers: data structure capable of last-in/first-out
operations.  A data structure is stack-like if it implements the
operations: 'empty?', 'top', 'push!', 'pop!'.  Several libraries provide
concrete stack implementations.

* Menu:

* istacks common::              The common stacks API.
* istacks lists::               Built-in lists as stacks.
* istacks ilists::              Immutable lists as stacks.
* istacks ralists::             Random-access lists as stacks.
* istacks stacks::              Common stacks API for stacks.
* istacks deques::              Deques as stacks.
* istacks chains::              Chains as stacks.
* istacks dynamic arrays::      Dynamic arrays as stacks.


File: vicare-libs.info,  Node: istacks common,  Next: istacks lists,  Up: istacks

46.1 The common stacks API
==========================

The following syntactic bindings are exported by the library '(vicare
containers istacks)'.

 -- Record Type: <istack>
     Record type representing a stack object.  The '<istack>' type is
     non-generative and available for subtyping.  In this documentation
     '<istack>' instances used as arguments to functions are indicated
     as ISTACK.

     '<istack>' is an "abstract" type: it must not be instantiated
     directly, rather a subtype of '<istack>' must be defined
     implementing the required functions.

 -- Constructor on <istack>: make-istack EMPTY? TOP PUSH! POP!
     When we derive a type from '<istack>' and we specify a protocol:
     this is the closure object used as argument for the protocol
     function.

          (define-record-type <istack-list>
            (parent <istack>)
            (protocol
              (lambda (make-istack)
                ---))
            ---)

     Its arguments must be functions implementing the methods for the
     concrete stack:

     EMPTY?
          A function accepting as single argument the '<istack>'
          instance itself.  It must return '#t' if the stack is empty;
          otherwise it must return '#f'.

     TOP
          A function accepting as single argument the '<istack>'
          instance itself.  It must return the top object in the
          '<istack>'.

     PUSH!
          A function accepting two arguments: the '<istack>' instance
          itself and an object.  It must push the object on the
          '<istack>'; it can return unspecified values.

     POP!
          A function accepting as single argument the '<istack>'
          instance itself.  It must remove and return the top object
          from the '<istack>'.

 -- Function: istack? OBJ
     Return '#t' if OBJ is an instance of '<istack>'; otherwise return
     '#f'.

 -- Function: istack-empty? ISTACK
     Return '#t' if ISTACK is empty; otherwise return '#f'.

 -- Function: istack-top ISTACK
     Return the top object in ISTACK.

 -- Function: istack-push! ISTACK OBJ
     Push OBJ on ISTACK.  Return unspecified values.

 -- Function: istack-pop! ISTACK
     Remove and return the top object from ISTACK.


File: vicare-libs.info,  Node: istacks lists,  Next: istacks ilists,  Prev: istacks common,  Up: istacks

46.2 Built-in lists as stacks
=============================

The library '(vicare containers istacks lists)' provides a concrete
implementation of the '<istack>' type using built-in lists as storage.
Usage example:

     (import (vicare)
       (vicare containers istacks)
       (vicare containers istacks lists))

     (define S
       (make-istack-list))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks lists)'.

 -- Record Type: <istack-list>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-list
 -- Function: make-istack-list ELL
     Build and return a new instance of '<istack-list>'.  The optional
     argument ELL must be a proper list (or null) representing the
     initial contents of the stack, with the car of the list being the
     top object.

 -- Function: istack-list? OBJ
     Return '#t' if OBJ is an instance of '<istack-list>'; otherwise
     return '#f'.

 -- Function: istack-list-first-pair ISTACK
     Return null or the first pair of the list used as storage in the
     '<istack-list>' instance ISTACK.


File: vicare-libs.info,  Node: istacks ilists,  Next: istacks ralists,  Prev: istacks lists,  Up: istacks

46.3 Immutable lists as stacks
==============================

The library '(vicare containers istacks ilists)' provides a concrete
implementation of the '<istack>' type using immutable lists as storage;
immutable lists are defined by the library '(vicare containers ilists)',
*note Immutable lists: ilists.  Usage example:

     (import (vicare)
       (vicare containers istacks)
       (vicare containers istacks ilists))

     (define S
       (make-istack-ilist))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks ilists)'.

 -- Record Type: <istack-ilist>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-ilist
 -- Function: make-istack-ilist ELL
     Build and return a new instance of '<istack-ilist>'.  The optional
     argument ELL must be a proper immutable list (or null) representing
     the initial contents of the stack, with the car of the list being
     the top object.

 -- Function: istack-ilist? OBJ
     Return '#t' if OBJ is an instance of '<istack-ilist>'; otherwise
     return '#f'.

 -- Function: istack-ilist-first-pair ISTACK
     Return null or the first pair of the list used as storage in the
     '<istack-ilist>' instance ISTACK.


File: vicare-libs.info,  Node: istacks ralists,  Next: istacks stacks,  Prev: istacks ilists,  Up: istacks

46.4 Random-access lists as stacks
==================================

The library '(vicare containers istacks ralists)' provides a concrete
implementation of the '<istack>' type using random-access lists as
storage; random-access lists are defined by the library '(vicare
containers ralists)', *note Random-access lists: ralists.  Usage
example:

     (import (vicare)
       (vicare containers istacks)
       (vicare containers istacks ralists))

     (define S
       (make-istack-ralist))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks ralists)'.

 -- Record Type: <istack-ralist>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-ralist
 -- Function: make-istack-ralist ELL
     Build and return a new instance of '<istack-ralist>'.  The optional
     argument ELL must be a proper random-access list (or null)
     representing the initial contents of the stack, with the car of the
     list being the top object.

 -- Function: istack-ralist? OBJ
     Return '#t' if OBJ is an instance of '<istack-ralist>'; otherwise
     return '#f'.

 -- Function: istack-ralist-first-pair ISTACK
     Return null or the first pair of the list used as storage in the
     '<istack-ralist>' instance ISTACK.


File: vicare-libs.info,  Node: istacks stacks,  Next: istacks deques,  Prev: istacks ralists,  Up: istacks

46.5 Common stacks API for stacks
=================================

The library '(vicare containers stacks)' provides an implementation of
the stack container using the '<stack>' type, *note Stacks of objects:
stacks.  The library '(vicare containers istacks stacks)' provides a
concrete implementation of the '<istack>' type using an instance of
'<stack>' as storage.  Usage example:

     (import (vicare)
       (vicare containers stacks)
       (vicare containers istacks)
       (vicare containers istacks stacks))

     (define S
       (make-istack-stack (stack)))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks stacks)'.

 -- Record Type: <istack-stack>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-stack STACK
     Build and return a new instance of '<istack-stack>'.  The argument
     STACK must be an instance of type '<stack>'.

 -- Function: istack-stack? OBJ
     Return '#t' if OBJ is an instance of '<istack-stack>'; otherwise
     return '#f'.


File: vicare-libs.info,  Node: istacks deques,  Next: istacks chains,  Prev: istacks stacks,  Up: istacks

46.6 Deques as stacks
=====================

The library '(vicare containers istacks deques)' provides a concrete
implementation of the '<istack>' type using a deque as storage; deques
are defined by the library '(vicare containers deques)', *note
Double-ended queues of objects: deques.  Usage example:

     (import (vicare)
       (vicare containers deques)
       (vicare containers istacks)
       (vicare containers istacks deques))

     (define S
       (make-istack-deque (deque)))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks deques)'.

 -- Record Type: <istack-deque>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-deque DEQUE
     Build and return a new instance of '<istack-deque>'.  The argument
     DEQUE must be an instance of type '<deque>' as defined by the
     library '(vicare containers deques)'.

 -- Function: istack-deque? OBJ
     Return '#t' if OBJ is an instance of '<istack-deque>'; otherwise
     return '#f'.


File: vicare-libs.info,  Node: istacks chains,  Next: istacks dynamic arrays,  Prev: istacks deques,  Up: istacks

46.7 Chains as stacks
=====================

The library '(vicare containers istacks chains)' provides a concrete
implementation of the '<istack>' type using a chain as storage; chains
are defined by the library '(vicare containers chains)', *note Chains of
objects: chains.  Usage example:

     (import (vicare)
       (vicare containers chains)
       (vicare containers istacks)
       (vicare containers istacks chains))

     (define S
       (make-istack-chain (chain)))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks chains)'.

 -- Record Type: <istack-chain>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-chain CHAIN
     Build and return a new instance of '<istack-chain>'.  The argument
     CHAIN must be null or an instance of type '<chain-link>' as defined
     by the library '(vicare containers chains)'.

 -- Function: istack-chain? OBJ
     Return '#t' if OBJ is an instance of '<istack-chain>'; otherwise
     return '#f'.

 -- Function: istack-chain-first-pair ISTACK
     Return null or the first link of the chain used as storage in the
     '<istack-chain>' instance ISTACK.


File: vicare-libs.info,  Node: istacks dynamic arrays,  Prev: istacks chains,  Up: istacks

46.8 Dynamic arrays as stacks
=============================

The library '(vicare containers istacks dynamic-arrays)' provides a
concrete implementation of the '<istack>' type using a dynamic array as
storage; dynamic arrays are defined by the library '(vicare containers
dynamic-arrays)', *note Dynamic arrays: dynamic arrays.  Usage example:

     (import (vicare)
       (vicare containers dynamic-arrays)
       (vicare containers istacks)
       (vicare containers istacks dynamic-arrays))

     (define S
       (make-istack-dynamic-array (dynamic-array)))

     (istack-push! S 0)
     (istack-push! S 1)
     (istack-push! S 2)

     (istack-top  S)         => 2
     (istack-pop! S)         => 2
     (istack-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers istacks dynamic-arrays)'.

 -- Record Type: <istack-dynamic-array>
     Record type implementing an '<istack>', of which it is a subtype.

 -- Function: make-istack-dynamic-array ARRY
     Build and return a new instance of '<istack-dynamic-array>'.  The
     argument ARRY must be an instance of type '<dynamic-array>' as
     defined by the library '(vicare containers dynamic-arrays)'.

 -- Function: istack-dynamic-array? OBJ
     Return '#t' if OBJ is an instance of '<istack-dynamic-array>';
     otherwise return '#f'.


File: vicare-libs.info,  Node: iqueues,  Next: ideques,  Prev: istacks,  Up: Top

47 Interface to queue-like containers
*************************************

The library '(vicare containers iqueues)' implements a common API for
queue-like containers: data structure capable of first-in/first-out
operations.  A data structure is queue-like if it implements the
operations: 'empty?', 'top', 'push!', 'pop!'; the names are the same of
the operations for a stack, but for a queue: 'push!' enqueues objects on
the rear; 'pop!' dequeues objects from the front.

* Menu:

* iqueues common::              The common queues API.
* iqueues queues::              Common queues API for queues.
* iqueues deques::              Deques as queues.
* iqueues chains::              Chains as queues.
* iqueues dynamic arrays::      Dynamic arrays as queues.


File: vicare-libs.info,  Node: iqueues common,  Next: iqueues queues,  Up: iqueues

47.1 The common queues API
==========================

The following syntactic bindings are exported by the library '(vicare
containers iqueues)'.

 -- Record Type: <iqueue>
     Record type representing a queue object.  The '<iqueue>' type is
     non-generative and available for subtyping.  In this documentation
     '<iqueue>' instances used as arguments to functions are indicated
     as IQUEUE.

     '<iqueue>' is an "abstract" type: it must not be instantiated
     directly, rather a subtype of '<iqueue>' must be defined
     implementing the required functions.

 -- Constructor on <iqueue>: make-iqueue EMPTY? TOP PUSH! POP!
     When we derive a type from '<iqueue>' and we specify a protocol:
     this is the closure object used as argument for the protocol
     function.

          (define-record-type <iqueue-list>
            (parent <iqueue>)
            (protocol
              (lambda (make-iqueue)
                ---))
            ---)

     Its arguments must be functions implementing the methods for the
     concrete queue:

     EMPTY?
          A function accepting as single argument the '<iqueue>'
          instance itself.  It must return '#t' if the queue is empty;
          otherwise it must return '#f'.

     TOP
          A function accepting as single argument the '<iqueue>'
          instance itself.  It must return the top object at the front
          of the '<iqueue>'.

     PUSH!
          A function accepting two arguments: the '<iqueue>' instance
          itself and an object.  It must push the object on the rear of
          the '<iqueue>'; it can return unspecified values.

     POP!
          A function accepting as single argument the '<iqueue>'
          instance itself.  It must remove and return the top object on
          the front of the '<iqueue>'.

 -- Function: iqueue? OBJ
     Return '#t' if OBJ is an instance of '<iqueue>'; otherwise return
     '#f'.

 -- Function: iqueue-empty? IQUEUE
     Return '#t' if IQUEUE is empty; otherwise return '#f'.

 -- Function: iqueue-top IQUEUE
     Return the top object on the front of IQUEUE.

 -- Function: iqueue-push! IQUEUE OBJ
     Push OBJ on the rear of IQUEUE.  Return unspecified values.

 -- Function: iqueue-pop! IQUEUE
     Remove and return the top object on the front of IQUEUE.


File: vicare-libs.info,  Node: iqueues queues,  Next: iqueues deques,  Prev: iqueues common,  Up: iqueues

47.2 Common queues API for queues
=================================

The library '(vicare containers queues)' provides an implementation of
the queue container using the '<queue>' type, *note Simple queues:
queues.  The library '(vicare containers iqueues queues)' provides a
concrete implementation of the '<iqueue>' type using an instance of
'<queue>' as storage.  Usage example:

     (import (vicare)
       (vicare containers queues)
       (vicare containers iqueues)
       (vicare containers iqueues queues))

     (define S
       (make-iqueue-queue (queue)))

     (iqueue-push! S 0)
     (iqueue-push! S 1)
     (iqueue-push! S 2)

     (iqueue-top  S)         => 2
     (iqueue-pop! S)         => 2
     (iqueue-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers iqueues queues)'.

 -- Record Type: <iqueue-queue>
     Record type implementing an '<iqueue>', of which it is a subtype.

 -- Function: make-iqueue-queue QUEUE
     Build and return a new instance of '<iqueue-queue>'.  The argument
     QUEUE must be an instance of type '<queue>'.

 -- Function: iqueue-queue? OBJ
     Return '#t' if OBJ is an instance of '<iqueue-queue>'; otherwise
     return '#f'.


File: vicare-libs.info,  Node: iqueues deques,  Next: iqueues chains,  Prev: iqueues queues,  Up: iqueues

47.3 Deques as queues
=====================

The library '(vicare containers iqueues deques)' provides a concrete
implementation of the '<iqueue>' type using a deque as storage; deques
are defined by the library '(vicare containers deques)', *note
Double-ended queues of objects: deques.  Usage example:

     (import (vicare)
       (vicare containers deques)
       (vicare containers iqueues)
       (vicare containers iqueues deques))

     (define S
       (make-iqueue-deque (deque)))

     (iqueue-push! S 0)
     (iqueue-push! S 1)
     (iqueue-push! S 2)

     (iqueue-top  S)         => 2
     (iqueue-pop! S)         => 2
     (iqueue-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers iqueues deques)'.

 -- Record Type: <iqueue-deque>
     Record type implementing an '<iqueue>', of which it is a subtype.

 -- Function: make-iqueue-deque DEQUE
     Build and return a new instance of '<iqueue-deque>'.  The argument
     DEQUE must be an instance of type '<deque>' as defined by the
     library '(vicare containers deques)'.

 -- Function: iqueue-deque? OBJ
     Return '#t' if OBJ is an instance of '<iqueue-deque>'; otherwise
     return '#f'.


File: vicare-libs.info,  Node: iqueues chains,  Next: iqueues dynamic arrays,  Prev: iqueues deques,  Up: iqueues

47.4 Chains as queues
=====================

The library '(vicare containers iqueues chains)' provides a concrete
implementation of the '<iqueue>' type using a chain as storage; chains
are defined by the library '(vicare containers chains)', *note Chains of
objects: chains.  Usage example:

     (import (vicare)
       (vicare containers chains)
       (vicare containers iqueues)
       (vicare containers iqueues chains))

     (define S
       (make-iqueue-chain (chain)))

     (iqueue-push! S 0)
     (iqueue-push! S 1)
     (iqueue-push! S 2)

     (iqueue-top  S)         => 2
     (iqueue-pop! S)         => 2
     (iqueue-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers iqueues chains)'.

 -- Record Type: <iqueue-chain>
     Record type implementing an '<iqueue>', of which it is a subtype.

 -- Function: make-iqueue-chain CHAIN
     Build and return a new instance of '<iqueue-chain>'.  The argument
     CHAIN must be null or an instance of type '<chain-link>' as defined
     by the library '(vicare containers chains)'; this function
     automatically determines the first and last links in the chain
     starting from CHAIN.

 -- Function: iqueue-chain? OBJ
     Return '#t' if OBJ is an instance of '<iqueue-chain>'; otherwise
     return '#f'.

 -- Function: iqueue-chain-first-link IQUEUE
     Return null or the first link of the chain used as storage in the
     '<iqueue-chain>' instance IQUEUE.

 -- Function: iqueue-chain-last-link IQUEUE
     Return null or the last link of the chain used as storage in the
     '<iqueue-chain>' instance IQUEUE.


File: vicare-libs.info,  Node: iqueues dynamic arrays,  Prev: iqueues chains,  Up: iqueues

47.5 Dynamic arrays as queues
=============================

The library '(vicare containers iqueues dynamic-arrays)' provides a
concrete implementation of the '<iqueue>' type using a dynamic array as
storage; dynamic arrays are defined by the library '(vicare containers
dynamic-arrays)', *note Dynamic arrays: dynamic arrays.  Usage example:

     (import (vicare)
       (vicare containers dynamic-arrays)
       (vicare containers iqueues)
       (vicare containers iqueues dynamic-arrays))

     (define S
       (make-iqueue-dynamic-array (dynamic-array)))

     (iqueue-push! S 0)
     (iqueue-push! S 1)
     (iqueue-push! S 2)

     (iqueue-top  S)         => 2
     (iqueue-pop! S)         => 2
     (iqueue-pop! S)         => 1

   The following syntactic bindings are exported by the library '(vicare
containers iqueues dynamic-arrays)'.

 -- Record Type: <iqueue-dynamic-array>
     Record type implementing an '<iqueue>', of which it is a subtype.

 -- Function: make-iqueue-dynamic-array ARRY
     Build and return a new instance of '<iqueue-dynamic-array>'.  The
     argument ARRY must be an instance of type '<dynamic-array>' as
     defined by the library '(vicare containers dynamic-arrays)'.

 -- Function: iqueue-dynamic-array? OBJ
     Return '#t' if OBJ is an instance of '<iqueue-dynamic-array>';
     otherwise return '#f'.


File: vicare-libs.info,  Node: ideques,  Next: random,  Prev: iqueues,  Up: Top

48 Interface to deque-like containers
*************************************

The library '(vicare containers ideques)' implements a common API for
deque-like containers: data structures representing sequences and
capable of efficient insertion at both the front and rear.  A data
structure is deque-like if it implements the operations: 'empty?',
'front', 'rear', 'push-front!', 'push-rear!', 'pop-front!', 'pop-rear!'.

* Menu:

* ideques common::              The common deques API.
* ideques deques::              Deques as deques.
* ideques chains::              Chains as deques.
* ideques dynamic arrays::      Dynamic arrays as deques.


File: vicare-libs.info,  Node: ideques common,  Next: ideques deques,  Up: ideques

48.1 The common deques API
==========================

The following syntactic bindings are exported by the library '(vicare
containers ideques)'.

 -- Record Type: <ideque>
     Record type representing a deque object.  The '<ideque>' type is
     non-generative and available for subtyping.  In this documentation
     '<ideque>' instances used as arguments to functions are indicated
     as IDEQUE.

     '<ideque>' is an "abstract" type: it must not be instantiated
     directly, rather a subtype of '<ideque>' must be defined
     implementing the required functions.

 -- Constructor on <ideque>: make-ideque EMPTY? FRONT REAR PUSH-FRONT!
          PUSH-REAR! POP-FRONT! POP-REAR!
     When we derive a type from '<ideque>' and we specify a protocol:
     this is the closure object used as argument for the protocol
     function.

          (define-record-type <ideque-chain>
            (parent <ideque>)
            (protocol
              (lambda (make-ideque)
                ---))
            ---)

     Its arguments must be functions implementing the methods for the
     concrete deque:

     EMPTY?
          A function accepting as single argument the '<ideque>'
          instance itself.  It must return '#t' if the deque is empty;
          otherwise it must return '#f'.

     FRONT
          A function accepting as single argument the '<ideque>'
          instance itself.  It must return the first object, at the
          front of the '<ideque>'.

     REAR
          A function accepting as single argument the '<ideque>'
          instance itself.  It must return the last object, at the rear
          of the '<ideque>'.

     PUSH-FRONT!
          A function accepting two arguments: the '<ideque>' instance
          itself and an object.  It must push the object on the front of
          the '<ideque>'; it can return unspecified values.

     PUSH-REAR!
          A function accepting two arguments: the '<ideque>' instance
          itself and an object.  It must push the object on the rear of
          the '<ideque>'; it can return unspecified values.

     POP-FRONT!
          A function accepting as single argument the '<ideque>'
          instance itself.  It must remove and return the first object,
          from the front of the '<ideque>'.

     POP-REAR!
          A function accepting as single argument the '<ideque>'
          instance itself.  It must remove and return the last object,
          from the rear of the '<ideque>'.

 -- Function: ideque? OBJ
     Return '#t' if OBJ is an instance of '<ideque>'; otherwise return
     '#f'.

 -- Function: ideque-empty? IDEQUE
     Return '#t' if IDEQUE is empty; otherwise return '#f'.

 -- Function: ideque-front IDEQUE
     Return the first object, on the front of IDEQUE.

 -- Function: ideque-rear IDEQUE
     Return the last object, on the rear of IDEQUE.

 -- Function: ideque-push-front! IDEQUE OBJ
     Push OBJ on the front of IDEQUE.  Return unspecified values.

 -- Function: ideque-push-rear! IDEQUE OBJ
     Push OBJ on the rear of IDEQUE.  Return unspecified values.

 -- Function: ideque-pop-front! IDEQUE
     Remove and return the first object, from the front of IDEQUE.

 -- Function: ideque-pop-rear! IDEQUE
     Remove and return the last object, from the rear of IDEQUE.


File: vicare-libs.info,  Node: ideques deques,  Next: ideques chains,  Prev: ideques common,  Up: ideques

48.2 Deques as deques
=====================

The library '(vicare containers deques)' provides an implementation of
the deque container using the '<deque>' type, *note Double-ended queues
of objects: deques.  The library '(vicare containers ideques deques)'
provides a concrete implementation of the '<ideque>' type using an
instance of '<deque>' as storage.  Usage example:

     (import (vicare)
       (vicare containers deques)
       (vicare containers ideques)
       (vicare containers ideques deques))

     (define S
       (make-ideque-deque (deque)))

     (ideque-push-front! S 0)
     (ideque-push-rear!  S 1)

     (ideque-front S)        => 0
     (ideque-rear  S)        => 1
     (ideque-pop-front! S)   => 0
     (ideque-pop-rear!  S)   => 1

   The following syntactic bindings are exported by the library '(vicare
containers ideques deques)'.

 -- Record Type: <ideque-deque>
     Record type implementing an '<ideque>', of which it is a subtype.

 -- Function: make-ideque-deque DEQUE
     Build and return a new instance of '<ideque-deque>'.  The argument
     DEQUE must be an instance of type '<deque>' as defined by the
     library '(vicare containers deques)'.

 -- Function: ideque-deque? OBJ
     Return '#t' if OBJ is an instance of '<ideque-deque>'; otherwise
     return '#f'.


File: vicare-libs.info,  Node: ideques chains,  Next: ideques dynamic arrays,  Prev: ideques deques,  Up: ideques

48.3 Chains as deques
=====================

The library '(vicare containers ideques chains)' provides a concrete
implementation of the '<ideque>' type using a chain as storage; chains
are defined by the library '(vicare containers chains)', *note Chains of
objects: chains.  Usage example:

     (import (vicare)
       (vicare containers chains)
       (vicare containers ideques)
       (vicare containers ideques chains))

     (define S
       (make-ideque-chain (chain)))

     (ideque-push-front! S 0)
     (ideque-push-rear!  S 1)

     (ideque-front S)        => 0
     (ideque-rear  S)        => 1
     (ideque-pop-front! S)   => 0
     (ideque-pop-rear!  S)   => 1

   The following syntactic bindings are exported by the library '(vicare
containers ideques chains)'.

 -- Record Type: <ideque-chain>
     Record type implementing an '<ideque>', of which it is a subtype.

 -- Function: make-ideque-chain CHAIN
     Build and return a new instance of '<ideque-chain>'.  The argument
     CHAIN must be null or an instance of type '<chain-link>' as defined
     by the library '(vicare containers chains)'; this function
     automatically determines the first and last links in the chain
     starting from CHAIN.

 -- Function: ideque-chain? OBJ
     Return '#t' if OBJ is an instance of '<ideque-chain>'; otherwise
     return '#f'.

 -- Function: ideque-chain-first-link IDEQUE
     Return null or the first link of the chain used as storage in the
     '<ideque-chain>' instance IDEQUE.

 -- Function: ideque-chain-last-link IDEQUE
     Return null or the last link of the chain used as storage in the
     '<ideque-chain>' instance IDEQUE.


File: vicare-libs.info,  Node: ideques dynamic arrays,  Prev: ideques chains,  Up: ideques

48.4 Dynamic arrays as deques
=============================

The library '(vicare containers ideques dynamic-arrays)' provides a
concrete implementation of the '<ideque>' type using a dynamic array as
storage; dynamic arrays are defined by the library '(vicare containers
dynamic-arrays)', *note Dynamic arrays: dynamic arrays.  Usage example:

     (import (vicare)
       (vicare containers dynamic-arrays)
       (vicare containers ideques)
       (vicare containers ideques dynamic-arrays))

     (define S
       (make-ideque-dynamic-array (dynamic-array)))

     (ideque-push-front! S 0)
     (ideque-push-rear!  S 1)

     (ideque-front S)        => 0
     (ideque-rear  S)        => 1
     (ideque-pop-front! S)   => 0
     (ideque-pop-rear!  S)   => 1

   The following syntactic bindings are exported by the library '(vicare
containers ideques dynamic-arrays)'.

 -- Record Type: <ideque-dynamic-array>
     Record type implementing an '<ideque>', of which it is a subtype.

 -- Function: make-ideque-dynamic-array ARRY
     Build and return a new instance of '<ideque-dynamic-array>'.  The
     argument ARRY must be an instance of type '<dynamic-array>' as
     defined by the library '(vicare containers dynamic-arrays)'.

 -- Function: ideque-dynamic-array? OBJ
     Return '#t' if OBJ is an instance of '<ideque-dynamic-array>';
     otherwise return '#f'.


File: vicare-libs.info,  Node: random,  Next: irregex,  Prev: ideques,  Up: Top

49 Sources of random bits
*************************

The library '(vicare crypto randomisations)' provides an API to access
sources of random and pseudo-random bits, or "randomness sources" for
brevity.  Other, auxiliary libraries provide access to miscellaneous
randomness generators and utilities.

* Menu:

* random intro::                Introduction.
* random prng::                 Notes on the algorithms.
* random numbers::              Simple random numbers.
* random source::               Randomness sources.
* random mrg32k3a::             L'Ecuyer's MRG32k3a generator
* random device::               Device-based generator.
* random utils::                Utilities.
* random generators::           Auxiliary generators.
* random dist::                 Random numbers from known distributions.


File: vicare-libs.info,  Node: random intro,  Next: random prng,  Up: random

49.1 Introduction
=================

There are three different ways to use the interface, with varying
demands on the quality of the source and the amount of control over the
production process:

   * The "no fuss" interface specifies that '(random-integer U)'
     produces the next random integer number X such that 0 <= X < U and
     '(random-real)' produces the next random real number X such that 0
     < X < 1.  Details about how these random values are produced may
     not be very relevant, as long as they appear to be sufficiently
     random.

   * For simulation purposes, on the contrary, it is usually necessary
     to know that the numbers are produced deterministically by a
     pseudo-random number generator of high quality and to have explicit
     access to its state.  In addition, one might want to use several
     independent sources of random numbers at the same time and it can
     be useful to have some simple form of randomization.

   * For security applications a serious form of true randomization is
     essential, in the sense that it is difficult for an adversary to
     exploit or introduce imperfections into the distribution of random
     bits.  Moreover, the linear complexity of the stream of random bits
     is more important than its statistical properties.  In these
     applications, an entropy source (producing truly random bits at a
     low rate) can be used to randomize a pseudo random number generator
     to increase the rate of available bits.

   Once randomness sources provide the infrastructure to obtain random
bits, these can be used to construct other random deviates.  Most
important are floating point numbers of various distributions and random
discrete structures, such as permutations or graphs.


File: vicare-libs.info,  Node: random prng,  Next: random numbers,  Prev: random intro,  Up: random

49.2 Notes on the algorithms
============================

Pseudo-random number generators (PRNGs) are algorithms that can
automatically create long sequences of numbers (for example, millions of
numbers) with good random properties; eventually the sequence repeats
itself or memory usage grows without bound(1).

   We examine some notes on PRNGs with the purpose of gaining basic
understanding of the code, and to reverese engineer the basic steps of
source code available on the Internet.  This section is meant to help
people new to the PRNG algorithms.

* Menu:

* random prng lcg::             Linear congruential generators.
* random prng mwc::             Multiply with carry.
* random prng csprng::          Cryptographically secure PRNG.
* random prng integers::        Generating integers in a specified range.
* random prng reals::           Generating real numbers.

   ---------- Footnotes ----------

   (1) Wikipedia contributors, "Random number generation," Wikipedia,
The Free Encyclopedia,
<http://en.wikipedia.org/wiki/Random_number_generator> (accessed June
28, 2009).


File: vicare-libs.info,  Node: random prng lcg,  Next: random prng mwc,  Up: random prng

49.2.1 Linear congruential generators
-------------------------------------

One of the most common PRNG is the "linear congruential generator"
(LCG), which uses the recurrence:

     N' = (a N + b) mod M      0 <= N', N < M

to generate a new integer number N' from an initial state N, a and b
being known, fixed, recursion coefficients.  The maximum number of
integers the formula can produce is the modulus M.

   To avoid certain non-random properties of a single linear
congruential generator, several such generators with slightly different
values of the multiplier coeffient are typically used in parallel, with
a "master" generator that selects among them.

   The most efficient LCGs have an M equal to a power of 2, most often
2^{32} or 2^{64}, because this allows the modulus operation to be
computed by merely truncating all but the rightmost 32 or 64 bits(1).

   LCGs should not be used for applications where high-quality
randomness is critical.  For example, they are not suitable for a Monte
Carlo simulation or for cryptographic applications.  A further problem
of LCGs is that the lower-order bits of the generated sequence have a
far shorter period than the sequence as a whole if M is set to a power
of 2.

   ---------- Footnotes ----------

   (1) Wikipedia contributors, "Linear congruential generator,"
Wikipedia, The Free Encyclopedia,
http://en.wikipedia.org/wiki/Linear_congruential_generator (accessed May
24, 2009).


File: vicare-libs.info,  Node: random prng mwc,  Next: random prng csprng,  Prev: random prng lcg,  Up: random prng

49.2.2 Multiply with carry
--------------------------

Multiply-with-carry (MWC) is a method invented by George Marsaglia for
generating sequences of pseudo-random integers based on an initial set
of from two to many thousands of randomly chosen seed values(1).

   The main advantage of the MWC method is that it invokes simple
computer integer arithmetic and leads to very fast generation of
sequences of pseudo-random numbers with immense periods, ranging from
around 260 to 22e6.  As with most PRNGs, the resulting sequences are
functions of the randomly chosen seed values, but MWC generators seem to
behave as well as, and often better than, others in tests of randomness.

   A MWC sequence is based on arithmetic modulo M, usually 2^{32},
because arithmetic modulo that M is automatic in most computers, but
sometimes a modulo such as 32^2 - 1 is used, because arithmetic for
modulus 2^{32} - 1 requires only a simple adjustment from that for
2^{32}, and theory for MWC sequences based on modulus 2^{32} has some
nagging difficulties that use of 2^{32} - 1 avoids.

   Complementary-multiply-with-carry generators (CMWC) are a slightly
modified form of MWC giving better results.  A basic formulation of the
algorithm uses the recurrence:

     N' = (M - 1) - (a * N + C) mod M    0 <= N < M

                a * N + C
     C' = floor ---------                     C < a
                    M

to generate a new number N' and a new carry C' from an initial state N
and an initial carry C, a being the recursion coefficient and M being
the modulo.

   Better formulations adopt a "lag" of r values: Chosen a positive
integer r, an initial carry C and a vector [N(1), N(2), ..., N(r)] of
initial seed values, the new number N' and the new carry C' are computed
using the seed N(r) as:

     N' = (M - 1) - (a * N(r) + C) mod M

                a * N(r) + C
     C' = floor ------------
                     M

then the seed vector is right-shifted purging N(r):

     N(r)   = N(r-1)
     N(r-1) = N(r-2)
     ...
     N(2)   = N(1)
     N(1)   = N'

   ---------- Footnotes ----------

   (1) Wikipedia contributors, "Multiply-with-carry," Wikipedia, The
Free Encyclopedia, <http://en.wikipedia.org/wiki/Multiply-with-carry>
(accessed May 8, 2009).


File: vicare-libs.info,  Node: random prng csprng,  Next: random prng integers,  Prev: random prng mwc,  Up: random prng

49.2.3 Cryptographically secure PRNG
------------------------------------

A cryptographically secure pseudo-random number generator (CSPRNG) is a
PRNG with properties that make it suitable for use in cryptography.  The
requirements of an ordinary PRNG are also satisfied by a CSPRNG, but the
reverse is not true.

   CSPRNG requirements fall into two groups: that they pass statistical
randomness tests; that they hold up well under serious attacks, even
when part of their initial or running state becomes available to an
attacker(1).

   ---------- Footnotes ----------

   (1) Wikipedia contributors, "Cryptographically secure pseudorandom
number generator," Wikipedia, The Free Encyclopedia,
<http://en.wikipedia.org/wiki/
Cryptographically_secure_pseudo-random_number_generator> (accessed June
6, 2009).


File: vicare-libs.info,  Node: random prng integers,  Next: random prng reals,  Prev: random prng csprng,  Up: random prng

49.2.4 Generating integers in a specified range
-----------------------------------------------

In applications using a randomness source, it happens to need a
pseudo-random integer X in a given range 0 <= X < U, while the PRNG
generates a pseudo-random integer N in the range 0 <= N < M. In other
words: We need a sample from the range 0 <= X < U having uniform
probability distribution, by means of a sample from the range 0 <= N < M
having a uniform probability distribution.

   We distinguish the two cases U <= M and M < U, because when U <= M
there are more integers in the range 0 <= N < M than in the range 0 <= X
< U, while when M < U it is the other way around.

   * When U <= M, we have to understand that doing a simple N mod U is
     incorrect, because it breaks uniform distribution of the result in
     the range 0 <= X < U. We can use the following formulation which
     gives uniformly distributed results:

          Q  = floor(M / U)
          QU = Q * U

          loop:
            N = <generate the next integer>
            if (N < QU)
            then X = floor(N / Q)
            else goto loop

     notice that QU = Q * U <= M; also notice that it is statistically
     possible that the algorithm loops forever, but we can hope that it
     finds a solution in a reasonable short time.  It works like this:

       1. Conceptually partition the range 0 <= N < QU in U intervals
          each of length Q, indexed by X in the range 0 <= X < U.

       2. Generate an integer N and discard it if QU <= N.

       3. If N is in the range 0 <= N < QU, then it is also in a range X
          * Q < N < (X+1) * Q. X is the result.

   * When M < U, we have to generate pseudo-random integers N' uniformly
     distributed in a range 0 <= N' < M', with M < U <= M'. We can do it
     by computing the following formula, which is a polynomial in M and
     a linear combination with positive coefficients in N(i) with 0 <= i
     < k:

          N' = N0 + M * N1 + M^2 * N2 + ... +
             + ... + M^(k-2) * N(k-2) + M^(k-1) * N(k-1)

     where N0, N1, ..., N(k-1) are all generated integers in the range 0
     <= N(i) < M. The maximum value, that is M' - 1, is realised when
     every N(i) equals M - 1:

          M' - 1 = (M - 1) + M * (M - 1) + M^2 * (M - 1) + ... +
                 + ... + M^(k-2) * (M - 1) + M^(k-1) * (M - 1)
                 = (M - 1) * [1 + M + M^2 + ... + M^(k-2) + M^(k-1)]
                 = (M - 1) * (1 - M^k)/(1 - M)
                 = (M - 1) * (M^k - 1)/(M - 1)
                 = M^k - 1

     which implies M^k = M'. So by selecting k such that U <= M^k we are
     sure that N' will be in a suitable range.

     Computing this polinomial/combination is like expressing the big
     pseudo-random integer N' in base M where N(i) are the digits.  Each
     possible N' is uniquely associated to a k-tuple of integers N(i).
     Being the probability of N(i) uniformly distributed, each possible
     k-tuple has uniform probability in the set of all the possible
     k-tuples.  So also the probability of N' is uniformly distributed
     in the range 0 <= N' < M^k.

     Then we proceed like we did before for U <= M:

          Q  = floor(M' / U)
          QU = Q * U

          loop:
            N' = <compute the next polynomial>
            if (N' < QU)
            then X = floor(N' / Q)
            else goto loop


File: vicare-libs.info,  Node: random prng reals,  Prev: random prng integers,  Up: random prng

49.2.5 Generating real numbers
------------------------------

We want a sample X from the discrete range of representable flonums in 0
<= X < 1 with a distribution that mimics the uniform distribution of
real numbers R in the continuous range 0 < R < 1.

   Knowing that the integers N generated by a PRNG are uniformly
distributed in the range 0 <= N < M, a pseudo-random flonum X in the
range 0 < X < 1 can be computed from a generated N with the following
normalisation formula:

     X = (1 + N) / (1 + M)

notice that:

     N = 0        =>  X = 1 / (1 + M) > 0
     N = (M - 1)  =>  X = M / (1 + M) < 1

sometimes this is enough, but we have to notice that: There may be more
representable flonums in 0 < X < 1 than exact fractions like (1 + N) /
(1 + M).

   The following program prints the generated inexact fractions for the
very simple case M = 5, it prints also the intervals between two
adjacent fractions:

     (import (rnrs)
       (vicare lists))

     (define M 5)
     (fold-left (lambda (prev-X X)
                  (write (list X (- X prev-X)))
                  (newline)
                  X)
                0.0
                (map (lambda (N)
                       (inexact (/ (+ 1 N) (+ 1 M))))
                  (list-tabulate M values)))
     -| (0.16666666666666666 0.16666666666666666)
     -| (0.3333333333333333  0.16666666666666666)
     -| (0.5                 0.16666666666666669)
     -| (0.6666666666666666  0.16666666666666663)
     -| (0.8333333333333334  0.16666666666666674)

so the generated flonums are in "units" of approximately 1/6 =
0.166666666666666; we can compute this unit with 1 / (1 + M).

   It is useful to be able to generate flonums in smaller units: We can
do it by generating a pseudo-random integer N' uniformly distributed in
a range larger than 0 <= N < M. We use the same method previously
outlined for large integers generation.  *note Generating integers in a
specified range: random prng integers.

   So, we select a value for the desired unit, then we find M' such
that:

     1 / (1 + M') <= unit
     =>  1 + M' >= 1 / unit
     =>  M' >= (1 / unit) - 1
     =>  1  >= (1 / unit) - 1 / M'

then we generate a big pseudo-random integer N' in the range 0 <= N' <
M' and normalise it with:

     X = (1 + N') / (1 + M')


File: vicare-libs.info,  Node: random numbers,  Next: random source,  Prev: random prng,  Up: random

49.3 Simple random numbers
==========================

 -- Constant: default-random-source
     A randomness source built by 'make-random-source/mrg32k3a', making
     use of Pierre L'Ecuyer's MRG32k3a generator.  *note L'Ecuyer's
     MRG32k3a generator: random mrg32k3a.

 -- Function: random-integer N
     Use 'default-random-source' to generate the next integer X in the
     range 0 <= X < U, where U is a positive integer.  Subsequent
     results of this procedure are independent, uniformly distributed
     over the range 0 <= X < U.

 -- Function: random-real
     Use 'default-random-source' to generate the next real number X in
     the range 0 < X < 1.  X=0 and X=1 are excluded in order to allow
     \log(X) and \log(1-X) without the danger of a numerical exception.
     Subsequent results of this procedure are independent, uniformly
     distributed in the range 0 < X < 1.


File: vicare-libs.info,  Node: random source,  Next: random mrg32k3a,  Prev: random numbers,  Up: random

49.4 Randomness sources
=======================

 -- Parameter: random-source-maker
     Hold a procedure that can be used to generate a new randomness
     source.  It is initialised to 'make-random-source/mrg32k3a'.  For
     example, it can be used as:

          (define source  ((random-source-maker)))
          (define integer (random-source-integer-maker source))
          (display (integer))
          -| <a random integer>

     and as:

          (parameterise ((random-source-maker
                            make-random-source/device))
            (let* ((source  ((random-source-maker)))
                   (integer (random-source-integer-maker source)))
              (display (integer))))
          -| <a random integer>

 -- Function: random-source? OBJ
     Test if OBJ is a randomness source.  Objects of type randomness
     source are distinct from all other types of objects.

 -- Function: random-source-state-ref SOURCE
 -- Function: random-source-state-set! SOURCE STATE
     Get and set the current state of SOURCE.  The purpose of these
     functions is to allow saving and restoring the state between
     sessions (for example, save the state to a file and reload it
     later).

     The state value is always a vector whose first element is a symbol
     describing the generator.  The other elements of the vector depend
     on the kind of generator: Refer to generator's documentation for
     their format.

 -- Function: random-source-seed! SOURCE INTEGERS-MAKER
     Reseed SOURCE to a new state.  INTEGERS-MAKER must be a a generator
     of random integer numbers, like the ones returned by
     'random-source-integers-maker'.  Notice that many random sources
     require INTEGER-MAKERS to return integers representable with 32
     bits.

 -- Function: random-source-required-seed-values SOURCE
     When 'random-source-seed!' is used to reseed a SOURCE, some
     generator will invoke INTEGERS-MAKER a fixed and known number of
     times, other generators will invoke it a configurable number of
     times, other generators will invoke it until it first returns '#f',
     other generators will invoke it until the returned numbers have
     some desired property.

     This function returns the number of times INTEGERS-MAKER will be
     called; if the return value is '#f': INTEGERS-MAKER will be invoked
     until it first returns '#f'; if the return value is infinity:
     INTEGERS-MAKER will be invoked until it returns numbers with some
     desired property.

 -- Function: random-source-jumpahead! SOURCE NUMBER-OF-STEPS
     Move ahead NUMBER-OF-STEPS randomness SOURCE's state.  What this
     means exactly depends on the type of SOURCE.

   The following procedures return a closure RAND to generate
pseudo-random integers and real numbers using a randomness SOURCE.  If
an application obtains and uses several RAND procedures for the same
randomness SOURCE, a call to any of these procedures advances the state
of SOURCE.  Hence, the procedures do not produce the same sequence of
random integers each, but rather share a state.

 -- Function: random-source-integers-maker SOURCE
     Return a procedure RAND to generate random integers using SOURCE.
     RAND takes a single argument U, which must be a positive integer,
     and returns the next uniformly distributed random integer X in the
     interval 0 <= X < U by advancing the state of SOURCE.

 -- Function: random-source-reals-maker SOURCE
 -- Function: random-source-reals-maker SOURCE UNIT
     Return a procedure RAND which, when invoked with no arguments,
     generates random real numbers X in the range '0 < X < 1' using
     SOURCE.  X=0 and X=1 are excluded in order to allow \log(X) and
     \log(1-X) without the danger of a numerical exception.

     The optional parameter UNIT determines the quantization of the
     output; to have effect, UNIT must be a number such that '0 < unit <
     1', if UNIT is greater than, or equal to, 1 the generated numbers
     will have the default unit.  The numbers created by RAND are spaced
     by at most UNIT.  *note Generating real numbers: random prng reals,
     for details.


File: vicare-libs.info,  Node: random mrg32k3a,  Next: random device,  Prev: random source,  Up: random

49.5 L'Ecuyer's MRG32k3a generator
==================================

The default randomness source of '(vicare crypto randomisations)' is
Pierre L'Ecuyer's MRG32k3a generator:

     P. L'Ecuyer.  "Good Parameter Sets for Combined Multiple Recursive
     Random Number Generators", Shorter version in Operations Research,
     47, 1 (1999), 159-164.

     P. L'Ecuyer, R. Simard, E. J. Chen, W. D. Kelton.  "An
     Object-Oriented Random-Number Package With Many Long Streams and
     Substreams".  2001.  To appear in Operations Research.

 -- Function: make-random-source/mrg32k3a
     Create and return a new randomness source using MRG32k3a,
     representing a deterministic stream of random bits.  Each returned
     randomness source generates the same stream of values, unless the
     state is modified with 'random-source-seed!'.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 7, whose first value is the symbol
     'random-source-state/mrg32k3a'.  All the other values in the vector
     are positive integers.

The algorithm
.............

The MRG32k3a generator produces values N in the range 0 <= N < 2^{32} -
209.  A new pseudo-random number N is generated with the following
computation starting from the state vectors [A1, A2, A3] and [B1, B2,
B3]:

     M1 = 4294967087 = 2^32 - 209
     M2 = 4294944443 = 2^32 - 22853

     c2 =  1403580
     c3 =  -810728
     d1 =   527612
     d3 = -1370589

     A0 = (          c2 * A2 + c3 * A3) mod M1
     B0 = (d1 * B1 +           d3 * B3) mod M2

     ; right-shift A, purging the old A3
     A3 = A2
     A2 = A1
     A1 = A0

     ; right-shift B, purging the old B3
     B3 = B2
     B2 = B1
     B1 = B0

     N = (A0 - B0) mod M1

notice that M1 and M2 are two prime numbers just below 2^{32}; c2, c3,
d1 and d3 are called "recursion coefficients".  The '(vicare crypto
randomisations)' library defines the initial state vectors as:

     A1 = 1062452522
     A2 = 2961816100
     A3 =  342112271

     B1 = 2854655037
     B2 = 3321940838
     B3 = 3542344109


File: vicare-libs.info,  Node: random device,  Next: random utils,  Prev: random mrg32k3a,  Up: random

49.6 Device-based random numbers
================================

In Unix-like operating systems, '/dev/random' is a special file that
serves as a true random number generator or as a pseudorandom number
generator.  It allows access to environmental noise collected from
device drivers and other sources.  Not all operating systems implement
the same semantics for '/dev/random'(1).

 -- Function: make-random-source/device
 -- Function: make-random-source/device DEVICE
     Create and return a new randomness source using the specified
     DEVICE to generate random integers in the range [0, 2^{32}).  When
     DEVICE is not specified, it defaults to '/dev/urandom'.

     We have to remember that reading '/dev/random' will *block* if not
     enough entropy is available, waiting for more randomness to be
     provided by the system.  This is why, by default, this function
     will use '/dev/urandom', which never blocks but provides randomness
     of lesser quality.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 7, whose first value is the symbol
     'random-source-state/device'.  The other values are the device
     pathname, a cache vector of values, the index of the next value to
     be extracted from the cace vector.

 -- Parameter: random-device-cache-length
     Device-based randomness sources cache read bytes into a bytevector
     of fixed size.  This parameter allows us to select the size at
     source construction time.  It is preset to 4096.

Low level API for device randomness sources
...........................................

 -- Function: %random-bytevector DEVICE NUMBER-OF-BYTES
 -- Function: random-bytevector NUMBER-OF-BYTES
 -- Function: urandom-bytevector NUMBER-OF-BYTES
     Read NUMBER-OF-BYTES from the specified DEVICE on the file system
     and return them in a newly allocated bytevector.
     'random-bytevector' is a specialised version reading bytes from
     '/dev/random'.  'urandom-bytevector' is a specialised version
     reading bytes from '/dev/urandom'.

 -- Function: %random-bytevector! DEVICE BV
 -- Function: random-bytevector! BV
 -- Function: urandom-bytevector! BV
     Fill the bytevector BV with bytes read from the specified DEVICE on
     the file system; return BV itself.  'random-bytevector!' is a
     specialised version reading bytes from '/dev/random'.
     'urandom-bytevector!' is a specialised version reading bytes from
     '/dev/urandom'.

   ---------- Footnotes ----------

   (1) See <http://en.wikipedia.org/wiki/Urandom>, last verified Fri Jun
26, 2009.


File: vicare-libs.info,  Node: random utils,  Next: random generators,  Prev: random device,  Up: random

49.7 Utilities
==============

* Menu:

* random utils misc::           Miscellaneous utility functions.
* random utils lists::          Specialised list functions.
* random utils vectors::        Specialised vector functions.
* random utils strings::        Specialised string functions.


File: vicare-libs.info,  Node: random utils misc,  Next: random utils lists,  Up: random utils

49.7.1 Miscellaneous utility functions
--------------------------------------

The following bindings are exported by the '(vicare crypto
randomisations)' library.

 -- Function: random-source-integers-maker-from-range SOURCE START LAST
 -- Function: random-source-integers-maker-from-range SOURCE START LAST
          STEP
     Return a closure that, when evaluated with no arguments, returns a
     random integer in the range selected by START and LAST both
     included, using randomness from SOURCE.  START and LAST must be
     exact integers.  The optional STEP argument, which defaults to one,
     establishes the step of allowed values from the range.

 -- Function: random-source-reals-maker-from-range SOURCE START LAST
 -- Function: random-source-reals-maker-from-range SOURCE START LAST
          STEP
     Return a closure that, when evaluated with no arguments, returns a
     random real in the range selected by START and LAST, using
     randomness from SOURCE.  START and LAST must be real numbers.

        * When STEP is not used: The result R is computed by generating
          a random real X in the range 0 < X < 1, then computing:

               R = start + (last - start) * X

          so R is in the range delimited by START and LAST both
          excluded.  The random real X is computed with no specified
          unit.  *note 'random-source-reals-maker': random source, for
          details.

        * When STEP is used: The result R is computed by generating a
          random integer N in the range 0 <= N < U with upper limit:

               U = floor[(last - start) / step]

          then computing:

               R = start + step * N

          so R is in the range delimited by START included and LAST
          excluded.

 -- Function: random-permutations-maker SOURCE
     Return a closure which, when applied to an integer number N,
     generates random permutations of the set '{0, ..., n-1}' using
     randomness from SOURCE.  Such a permutation is represented by a
     vector of length N for the images of the points.


File: vicare-libs.info,  Node: random utils lists,  Next: random utils vectors,  Prev: random utils misc,  Up: random utils

49.7.2 Specialised list functions
---------------------------------

The auxiliary library '(vicare crypto randomisations lists)' exports
bindings specialised to handle lists and randomness sources; it is based
on '(vicare crypto randomisations)' only.

 -- Function: random-list-unfold-numbers NUMBER-MAKER NUMBER-OF-NUMBERS
     Given the closure NUMBER-MAKER returning a random number, build and
     return a new list of NUMBER-OF-NUMBERS random numbers.

 -- Function: random-list-shuffle ELL SOURCE
     Build and return a new list shuffling the elements of ELL using
     randomness from the given SOURCE.

 -- Function: random-list-sample ELL SOURCE
     Return a closure that, when evaluated with no arguments, returns a
     randomly selected item from ELL, using randomness from SOURCE.

 -- Function: random-list-sample-population ELL LEN SOURCE
     Return a closure that, when evaluated with no arguments, returns a
     list of LEN items randomly selected from ELL, using randomness from
     SOURCE.


File: vicare-libs.info,  Node: random utils vectors,  Next: random utils strings,  Prev: random utils lists,  Up: random utils

49.7.3 Specialised vector functions
-----------------------------------

The auxiliary library '(vicare crypto randomisations vectors)' exports
bindings specialised to handle vectors and randomness sources; it is
based on both '(vicare crypto randomisations)' and '(vicare containers
vectors)'.  Arguments to the following functions follow the same
conventions established for '(vicare containers vectors)' and '(vicare
crypto vectors low)'.  *note Interface conventions: vectors convention.

 -- Function: random-vector-unfold-numbers NUMBER-MAKER
          NUMBER-OF-NUMBERS
     Given the closure NUMBER-MAKER returning a random number, build and
     return a new list of NUMBER-OF-NUMBERS random numbers.

 -- Function: %random-vector-shuffle SOURCE VEC START PAST
 -- Macro: random-vector-shuffle V SOURCE
     Build a new vector copying the selected subvector, then shuffle it
     using randomness from the given SOURCE.  Return the new vector.

 -- Function: %random-vector-shuffle! SOURCE VEC START PAST
 -- Macro: random-vector-shuffle! V SOURCE
     Shuffle the selected subvector using randomness from the given
     SOURCE.  Return the shuffled vector itself.

 -- Function: %random-vector-sample SOURCE VEC START PAST
 -- Macro: random-vector-sample V SOURCE
     Return a closure that, when evaluated with no arguments, returns a
     randomly selected item from the selected subvector, using
     randomness from SOURCE.

 -- Function: %random-vector-sample-population SOURCE LEN VEC START PAST
 -- Macro: random-vector-sample-population V LEN SOURCE
     Return a closure that, when evaluated with no arguments, returns a
     vector of LEN items randomly selected from the selected subvector
     of VEC, using randomness from SOURCE.

 -- Function: random-integers-with-sum REQUESTED-SUM NUMBER-OF-NUMBERS
          INCLUSIVE-MIN INCLUSIVE-MAX SOURCE
     Return a vector of length NUMBER-OF-NUMBERS, holding random
     integers in the range delimited by INCLUSIVE-MIN and INCLUSIVE-MAX,
     generated using randomness from SOURCE.  The integers are such that
     their sum equals REQUESTED-SUM.

 -- Function: random-reals-with-sum REQUESTED-SUM TOLERANCE
          NUMBER-OF-NUMBERS EXCLUSIVE-MIN EXCLUSIVE-MAX SOURCE
     Return a vector of length NUMBER-OF-NUMBERS, holding random reals
     in the range delimited by EXCLUSIVE-MIN and EXCLUSIVE-MAX,
     generated using randomness from SOURCE.  The numbers are such that
     their sum equals approximately REQUESTED-SUM with TOLERANCE:

          (< (- (abs TOLERANCE))
             (abs (- REQUESTED-SUM actual-sum))
             (abs TOLERANCE))
          => #t


File: vicare-libs.info,  Node: random utils strings,  Prev: random utils vectors,  Up: random utils

49.7.4 Specialised string functions
-----------------------------------

The auxiliary library '(vicare crypto randomisations strings)' exports
bindings specialised to handle strings and randomness sources; it is
based on both '(vicare crypto randomisations)' and '(vicare containers
strings)'.  Arguments to the following functions follow the same
conventions established for '(vicare containers strings)' and '(vicare
containers strings low)'.  *note Interface conventions: strings
convention.

 -- Function: random-string-unfold-chars INTEGER-MAKER NUMBER-OF-CHARS
     Given the closure INTEGER-MAKER returning a random integer, build
     and return a new string of NUMBER-OF-CHARS random characters.

     As a usage example, the following program will generate random
     passwords with characters in the range of graphics ASCII codes
     (warning: for real world applications, use a true random source):

          (import (rnrs)
            (vicare randomisations)
            (vicare randomisations strings)
            (vicare char-sets))

          (random-string-unfold-chars
            (lambda ()
              (do ((ch (random-integer 127) (random-integer 127)))
                  ((char-set-contains? char-set:ascii/graphic
                                       (integer->char ch))
                   ch)))
            10)

 -- Function: %random-string-shuffle SOURCE STR START PAST
 -- Macro: random-string-shuffle S SOURCE
     Build a new string copying the selected substring, then shuffle it
     using randomness from the given SOURCE.  Return the new string.

 -- Function: %random-string-shuffle! SOURCE STR START PAST
 -- Macro: random-string-shuffle! S SOURCE
     Shuffle the selected substring using randomness from the given
     SOURCE.  Return the shuffled string itself.

 -- Function: %random-string-sample SOURCE STR START PAST
 -- Macro: random-string-sample S SOURCE
     Return a closure that, when evaluated with no arguments, returns a
     randomly selected item from the selected substring, using
     randomness from SOURCE.

 -- Function: %random-string-sample-population SOURCE LEN STR START PAST
 -- Macro: random-string-sample-population S LEN SOURCE
     Return a closure that, when evaluated with no arguments, returns a
     string of LEN items randomly selected from the selected substring
     of STR, using randomness from SOURCE.


File: vicare-libs.info,  Node: random generators,  Next: random dist,  Prev: random utils,  Up: random

49.8 Auxiliary generators
=========================

* Menu:

* random generators mersenne::  The Mersenne twister.
* random generators marsaglia:: George Marsaglia's generators.
* random generators bbs::       Blum-Blum-Shub generator.
* random generators borosh::    Borosh generator.
* random generators cmrg::      Combined multiple recursive generator.


File: vicare-libs.info,  Node: random generators mersenne,  Next: random generators marsaglia,  Up: random generators

49.8.1 The Mersenne twister
---------------------------

The Mersenne twister is a pseudorandom number generator developed in
1997 by Makoto Matsumoto and Takuji Nishimura:

     Matsumoto Makoto and Nishimura Takuji.  "Mersenne twister: a
     623-dimensionally equidistributed uniform pseudo-random number
     generator".  1998.  ACM Transactions on Modeling and Computer
     Simulation.

it provides for fast generation of very high-quality pseudorandom
numbers, having been designed specifically to rectify many of the flaws
found in older algorithms.  Its name derives from the fact that period
length is chosen to be a Mersenne prime(1).

   The following bindings are exported by the '(vicare crypto
randomisations mersenne)' library.

 -- Function: make-random-source/mersenne
     Build and return a new randomness source using the Mersenne
     generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 626, whose first value is the symbol
     'random-source-state/mersenne'.  The other values are integers
     representable with 32 bits.

     The 'random-source-seed!' function for this generator, must be
     applied tot a numbers maker returning integers representable with
     32 bits.

   '(vicare crypto randomisations mersenne)' initialises the generator
drawing 32 bits integer numbers from a specifically built MRG32k3a
randomness source, which in turn is initialised with the default
'(vicare crypto randomisations)' seeds.  *note L'Ecuyer's MRG32k3a
generator: random mrg32k3a.

   ---------- Footnotes ----------

   (1) Wikipedia contributors, "Mersenne twister", Wikipedia, The Free
Encyclopedia,
<http://en.wikipedia.org/w/index.php?title=Mersenne_twister&oldid=299648661>
(accessed July 1, 2009).


File: vicare-libs.info,  Node: random generators marsaglia,  Next: random generators bbs,  Prev: random generators mersenne,  Up: random generators

49.8.2 George Marsaglia's generators
------------------------------------

The generators described here were posted by George Marsaglia in a
thread on <sci.stat.math> and <sci.crypt> starting on January, 12 1999.
The following bindings are exported by the '(vicare crypto
randomisations marsaglia)' library.

   For all the randomness sources, the 'random-source-seed!' function
must be applied to a number maker returning integers representable with
32 bits.

 -- Function: make-random-source/marsaglia/cong
     Build and return a new randomness source using the CONG generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 2, whose first value is the symbol
     'random-source-state/marsaglia/cong'.  The other value is a single
     integer representable with 32 bits.

 -- Function: make-random-source/marsaglia/fib
     Build and return a new randomness source using the FIB generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 3, whose first value is the symbol
     'random-source-state/marsaglia/fib'.  The other values are integers
     representable with 32 bits.

 -- Function: make-random-source/marsaglia/lfib4
     Build and return a new randomness source using the LFIB4 generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 258, whose first value is the symbol
     'random-source-state/marsaglia/lfib4'.  The other values are
     integers representable with 32 bits.

 -- Function: make-random-source/marsaglia/kiss
     Build and return a new randomness source using the KISS generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 5, whose first value is the symbol
     'random-source-state/marsaglia/kiss'.  The other values are
     integers representable with 32 bits.

 -- Function: make-random-source/marsaglia/mwc
     Build and return a new randomness source using the MWC generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 3, whose first value is the symbol
     'random-source-state/marsaglia/mwc'.  The other values are integers
     representable with 32 bits.

 -- Function: make-random-source/marsaglia/shr3
     Build and return a new randomness source using the SHR3 generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 2, whose first value is the symbol
     'random-source-state/marsaglia/shr3'.  The other value is an
     integer representable with 32 bits.

 -- Function: make-random-source/marsaglia/swb
     Build and return a new randomness source using the SWB generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 261, whose first value is the symbol
     'random-source-state/marsaglia/swb'.  The other values are integers
     representable with 32 bits.

Algorithms
..........

Here is the core C language implementation of the generators, as posted
by Marsaglia (line wrapping added here, and small bits changed):

     #define znew    (z = 36969 * (z & 65535)        \
                        + (z >> 16))

     #define wnew    (w = 18000 * (w & 65535)        \
                        + (w >> 16))

     #define MWC     ((znew << 16) + wnew)

     #define SHR3    (jsr ^= (jsr << 17),  \
                      jsr ^= (jsr >> 13),  \
                      jsr ^= (jsr << 5))

     #define CONG    (jcong = 69069 * jcong + 1234567)

     #define FIB     ((b = a + b),    \
                      (a = b - a))

     #define KISS    ((MWC^CONG) + SHR3)

     #define LFIB4   (c++,                           \
                      t[c] = t[c]                    \
                           + t[(uint8_t)(c +  58)]   \
                           + t[(uint8_t)(c + 119)]   \
                           + t[(uint8_t)(c + 178)])

     #define SWB     (c++,                                   \
                      bro  = (x < y),                        \
                      t[c] = (x = t[(uint8_t)(c + 34)])      \
                                - (y = t[(uint8_t)(c + 19)]  \
                                     + bro))

     #define UNI   (KISS * 2.328306e-10)
     #define VNI   (((int32_t) KISS) * 4.656613e-10)

     #define UC    (uint8_t)   /* a cast operation */

     /* Use random seeds to reset z, w, jsr, jcong, a, b,
        and the table t[256] */
     uint32_t  z, w, jsr, jcong, a, b, t[256];

     uint32_t  x=0, y=0, bro;
     uint8_t   c=0;

   What follows is the comment part of the original post by Marsaglia
himself, with minor editing for formatting purposes and porting to
Scheme (errors in the original text are probably present here, too):

     Any one of KISS, MWC, FIB, LFIB4, SWB, SHR3, or CONG can be used in
     an expression to provide a random 32 bits integer.

     The KISS generator (Keep It Simple Stupid) is designed to combine
     the two multiply-with-carry generators in MWC with the 3-shift
     register SHR3 and the congruential generator CONG, using addition
     and exclusive-or.  Period about 2^{123}.  It is one of my favorite
     generators.

     The MWC generator concatenates two 16 bits multiply-with-carry
     generators:

          x(n) = 36969 * x(n-1) + carry
          y(n) = 18000 * y(n-1) + carry mod 2^16

     has period about 2^{60} and seems to pass all tests of randomness.
     A favorite stand-alone generator--faster than KISS, which contains
     it.

     FIB is the classical Fibonacci sequence:

          x(n) = x(n-1) + x(n-2)

     but taken modulo 2^{32}.  Its period is 3 * 2^{31} if one of its
     two seeds is odd and not 1 mod 8.  It has little worth as a RNG by
     itself, but provides a simple and fast component for use in
     combination generators.

     SHR3 is a 3-shift-register generator with period 2^{32} - 1.  It
     uses:

          y(n) = y(n-1) * (I + L^17) * (I + R^13) * (I+L^5)

     with the y viewed as binary vectors, L the 32 x 32 binary matrix
     that shifts a vector left 1, and R its transpose.  SHR3 seems to
     pass all tests except those related to the binary rank test, since
     32 successive values, as binary vectors, must be linearly
     independent, while 32 successive truly random 32 bits integers,
     viewed as binary vectors, will be linearly independent only about
     29% of the time.

     CONG is a congruential generator with the widely used 69069
     multiplier:

          x(n) = 69069 * x(n-1) + 1234567

     it has period 2^{32}.  The leading half of its 32 bits seem to pass
     tests, but bits in the last half are too regular.

     LFIB4 is an extension of what I have previously defined as a lagged
     Fibonacci generator:

          x(n) = x(n-r) op x(n-s)

     with the x in a finite set over which there is a binary operation
     op, such as +, - on integers modulo 2^{32}, * on odd such integers,
     exclusive-or(xor) on binary vectors.

     Except for those using multiplication, lagged Fibonacci generators
     fail various tests of randomness, unless the lags are very long.
     (See SWB below).  To see if more than two lags would serve to
     overcome the problems of 2-lag generators using +, - or xor, I have
     developed the 4-lag generator LFIB4 using addition:

          x(n) = [x(n-256) + x(n-179) + x(n-119) + x(n-55)] mod 2^32

     its period is 2^{31} * (2^{256} - 1), about 2^{287}, and it seems
     to pass all tests--in particular, those of the kind for which 2-lag
     generators using +, -, xor seem to fail.  For even more confidence
     in its suitability, LFIB4 can be combined with KISS, with a
     resulting period of about 2^{410}, just use:

          (let* ((kiss       (make-random-source/marsaglia/kiss))
                 (cong       (make-random-source/marsaglia/cong))
                 (k-integers (random-source-integers-maker kiss))
                 (c-integers (random-source-integers-maker cong))
                 (integers   (lambda (U M)
                               (mod (+ (k-integers U)
                                       (c-integers U))
                                    M))))
            ---)

     in any Scheme expression.

     SWB is a subtract-with-borrow generator that I developed to give a
     simple method for producing extremely long periods:

          x(n) = [x(n-222) - x(n-237) - borrow] mod 2^32

     the 'borrow' is 0, or set to 1 if computing x(n-1) caused overflow
     in 32 bits integer arithmetic.  This generator has a very long
     period, 2^{7098} * (2^{480} - 1), about 2^{7578}.  It seems to pass
     all tests of randomness, except for the Birthday Spacings test,
     which it fails badly, as do all lagged Fibonacci generators using
     +, - or xor.

     I would suggest combining SWB with KISS, MWC, SHR3, or CONG.
     KISS+SWB has period >2^{7700} and is highly recommended.
     Subtract-with-borrow has the same local behaviour as lagged
     Fibonacci using +, -, xor--the borrow merely provides a much longer
     period.  SWB fails the birthday spacings test, as do all lagged
     Fibonacci and other generators that merely combine two previous
     values by means of +, - or xor.  Those failures are for a
     particular case: m = 512 birthdays in a year of n = 2^{24} days.
     There are choices of m and n for which lags >1000 will also fail
     the test.  A reasonable precaution is to always combine a 2-lag
     Fibonacci or SWB generator with another kind of generator, unless
     the generator uses *, for which a very satisfactory sequence of odd
     32 bits integers results.

     The classical Fibonacci sequence mod 2^{32} from FIB fails several
     tests.  It is not suitable for use by itself, but is quite suitable
     for combining with other generators.

     The last half of the bits of CONG are too regular, and it fails
     tests for which those bits play a significant role.  CONG+FIB will
     also have too much regularity in trailing bits, as each does.  But
     keep in mind that it is a rare application for which the trailing
     bits play a significant role.  CONG is one of the most widely used
     generators of the last 30 years, as it was the system generator for
     VAX and was incorporated in several popular software packages, all
     seemingly without complaint.

   The generators are seeded as follows:

CONG
     The seed values are:

          jcong = 2524969849

     with this seeding it is known that the millionth integer is
     1529210297.

FIB
     The seed values are:

          a =  9983651
          b = 95746118

     with this seeding it is known that the millionth integer is
     3519793928.

KISS
     The seed values are:

          jcong = 1017008441
          jsr   = 3259917390
          w     =   99545079
          z     = 2247183469

     with this seeding it is known that the millionth integer is
     1372460312.

LFIB4
     The seed values are stored in a vector of length 256, holding 32
     bits representable integers; the index into the vector is set to 'c
     = 0'.  The seed values of the vector are precomputed, see the
     source code of the library.

     With this seeding it is known that the millionth integer is
     1064612766.

MWC
     The seed values are:

          w = 1046675282
          z = 2374144069

     with this seeding it is known that the millionth integer is
     904977562.

SHR3
     The seed values are:

          jsr = 4176875757

     with this seeding it is known that the millionth integer is
     2642725982.

SWB
     The seed values are stored in a vector of length 256, holding 32
     bits representable integers; the index into the vector is set to 'c
     = 64'.  The seed values of the vector are precomputed, see the
     source code of the library.

     With this seeding it is known that the millionth integer is
     627749721.


File: vicare-libs.info,  Node: random generators bbs,  Next: random generators borosh,  Prev: random generators marsaglia,  Up: random generators

49.8.3 Blum-Blum-Shub generator
-------------------------------

Blum-Blum-Shub is a PRNG proposed in:

     Lenore Blum, Manuel Blum, Michael Shub.  "A Simple Unpredictable
     Pseudo-Random Number Generator", SIAM Journal on Computing, volume
     15, page 364-383, May 1986.

when seeded with prime numbers satisfying the specified requirements, it
can be considered a cryptographically secure PRNG.  The search of such
prime numbers is a delicate and complex task; we have to turn to
specialised literature to learn how to do it.

   The following bindings are exported by the '(vicare crypto
randomisations blum-blum-shub)' library.  The library makes no attempt
to validate the seed numbers for the cryptographic requirements, it just
implements the PRNG algorithm; attaining cryptographic security is
entirely on our shoulders.

 -- Function: make-random-source/blum-blum-shub
     Build and return a new randomness source using the BBS generator.
     The returned randomness source is *not* seeded; this is because
     seeding a cryptographically secure generator must be done with
     care, and it makes no sense to have a default seed.  The first
     operation after the creation of the source should be to seed it.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 5, whose first value is the symbol
     'random-source-state/blum-blum-shub'.  The other values are integer
     numbers.

     The 'random-source-seed!' function for this generator, must be
     applied to a numbers maker returning:

       1. The value of the prime number P.

       2. The value of the prime number Q.

       3. Integers numbers until one is found whose GCD with P * Q is 1.

     see the algorithm details below.

The algorithm
.............

BBS generates a sequence of bits, not of numbers.  Bits can be
concatenated to yield numbers of any sort in base 2.  Seeding goes like
this:

  1. Select two prime numbers P and Q and compute M = P * Q, which will
     be the modulus of the internally generated integers.  These primes
     are the "secret" of the generated sequence of pseudo-random
     integers; for cryptographic purposes they have to be kept hidden.

  2. Generate (using another PRNG) random integers S until one is found
     such that: The greatest commond divisor (GCD) between S and M is 1.
     Notice that R6RS Scheme implementations already provide a 'gcd'
     function.  *note Arithmetic operations: (vicare-scheme)baselib math
     ops arithmetic.

  3. Compute the seed X:

          X = (S * S) mod M

   The generator in '(vicare crypto randomisations blum-blum-shub)'
computes a new integer N representable with 32 bits, from an initial
state X with the following formulation:

     X0 = (X * X) mod M
     b0 = parity(X0)

     X1 = (X0 * X0) mod M
     b1 = parity(X1)

     X2 = (X1 * X1) mod M
     b2 = parity(X2)

     ...

where b(k) are the bits of N, with 0 <= k < 32, and X32 is the new state
of the generator.  The function parity(X) is the number of bits set to 1
in X, modulo 2.


File: vicare-libs.info,  Node: random generators borosh,  Next: random generators cmrg,  Prev: random generators bbs,  Up: random generators

49.8.4 Borosh generator
-----------------------

This generator is called "Borosh-Niederreiter".  It was taken from:

     Donald E. Knuth.  "The Art of Computer Programming".  Volume 2.
     Third Edition.  Addison-Wesley.  Page 106-108.

the following bindings are exported by the '(vicare crypto
randomisations borosh)' library.

 -- Function: make-random-source/borosh
     Build and return a new randomness source using the
     "Borosh-Niederreiter" generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 2, whose first value is the symbol
     'random-source-state/borosh'.  The other value is a single integer
     representable with 32 bits.

     The 'random-source-seed!' function for this generator, must be
     applied to a numbers maker returning integers representable with 32
     bits.

The algorithm
.............

The generator computes a new integer N' from an initial state N with the
following formulation:

     M = 2^32
     A = 1812433253

     N' = (A * N) mod M

'(vicare crypto randomisations borosh)' sets the initial state to N = 1.


File: vicare-libs.info,  Node: random generators cmrg,  Prev: random generators borosh,  Up: random generators

49.8.5 Combined multiple recursive generator
--------------------------------------------

This is a combined multiple recursive generator.  The algorithm was
derived from:(1)

     P. L'Ecuyer.  "Combined Multiple Recursive Random Number
     Generators".  Operations Research, 44, 5 (1996), 816-822.

the following bindings are exported by the '(vicare crypto
randomisations cmrg)' library.

 -- Function: make-random-source/cmrg
     Build and return a new randomness source using a CMRG generator.

     The state returned by 'random-source-state-ref' is a Scheme vector
     of length 7, whose first value is the symbol
     'random-source-state/cmrg'.  The other values are integers
     representable with 32 bits.

     The 'random-source-seed!' function for this generator, must be
     applied to a numbers maker returning integers representable with 32
     bits.

The algorithm
.............

The sequence is:

     N = (X0 - Y0) mod m1

where the two underlying generators X and Y are:

     X0 = (A1 X1 + A2 X2 + A3 X3) mod M1
     Y0 = (B1 Y1 + B2 X2 + B3 Y3) mod M2

with coefficients:

     A1 = 0       A2 = 63308   A3 = -183326
     B1 = 86098   B2 = 0       B3 = -539608

and moduli:

     M1 = 2^31 - 1       = 2147483647
     M2 = 2^31 - 2000169 = 2145483479

   According to the paper the initial values for X must lie in the range
0 <= X < M1 and the initial values for Y must lie in the range 0 <= Y <
M2, with at least one non-zero value.  '(vicare crypto randomisations
cmrg)' initialises the generator with:

     X1 = 7   X2 = 17   X3 = 47
     Y1 = 3   Y2 = 13   Y3 = 43

and the seeding procedure implemented by the randomness source (through
'random-source-seed!') will extract random numbers from the given
generator until it is 0 < X < M1 and 0 < Y < M2.

   ---------- Footnotes ----------

   (1) It is available from L'Ecuyer's home page (URL last verified Tue
Jul 14, 2009):

    <http://www.iro.umontreal.ca/~lecuyer/myftp/papers/combmrg.ps>
 <ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/combmrg.ps>


File: vicare-libs.info,  Node: random dist,  Prev: random generators,  Up: random

49.9 Random numbers from known distributions
============================================

The following functions are exported by the '(vicare crypto
randomisations distributions)' library.

 -- Function: random-exponentials-maker SOURCE
     Return a closure which, when applied to a real number argument MU,
     generates exponentially exp(mu) distributed random numbers using
     randomness from SOURCE.

 -- Function: random-normals-maker SOURCE
     Return a closure which, when applied to real number arguments MU
     and SIGMA, generates normally distributed N(mu, sigma) random
     numbers using randomness from SOURCE.


File: vicare-libs.info,  Node: irregex,  Next: pregexp,  Prev: random,  Up: Top

50 IrRegular expressions
************************

The library '(vicare irregex)' is an implementation of regular
expressions; it supports both POSIX syntax with various (irregular)
Perl-Compatible Regular Expressions (PCRE) extensions, as well as SCSH's
Scheme Regular Expressions (SRE) syntax, with various aliases for
commonly used patterns.

   Deterministic Finite Automata (DFA) matching is used when possible,
otherwise a closure-compiled Nondeterministic Finite Automata (NFA)
approach is used.(1)

     The library is derived from IrRegex, an implementation of regular
     expressions by Alex Shinn; only small changes were needed for
     integration into Vicare.  The original package is distributed under
     a BSD style license and can be downloaded from:

                        <http://synthcode.com/>

* Menu:

* irregex conventions::         Conventions.
* irregex pred::                Predicates.
* irregex compile::             Compiling regular expressions.
* irregex match::               Match objects.
* irregex replace::             Replacing substrings.
* irregex chunk::               Chunked string matching.
* irregex misc::                Miscellaneous functions.
* irregex pcre::                Supported PCRE syntax.
* irregex sre::                 Extended SRE syntax.

   ---------- Footnotes ----------

   (1) See <http://en.wikipedia.org/wiki/Automata_theory>.


File: vicare-libs.info,  Node: irregex conventions,  Next: irregex pred,  Up: irregex

50.1 Conventions
================

In the documentation of the functions exported by '(vicare irregex)',
the following conventions for argument names are used:

PCRE
     A string representing a regular expression in POSIX syntax, with
     PCRE extensions.

SRE
     A symbolic expression (a list) representing an SRE regular
     expression in SCSH syntax.

IRX
     A regular expression in one of the following forms: string in
     POSIX/PCRE syntax; symbolic expression in SRE syntax; a precompiled
     regular expression value.

STR
     A string.

START
PAST
     Non-negative, exact integers representing indexes usually into a
     string.  START is the index of the first code point in a selected
     substring; PAST is the index of the code point past the last code
     point included in the selected substring.

OBJ
     Can be any value.


File: vicare-libs.info,  Node: irregex pred,  Next: irregex compile,  Prev: irregex conventions,  Up: irregex

50.2 Predicates
===============

 -- Function: irregex? OBJ
     Return '#t' if OBJ is a compiled regular expression.  Compiled
     regular expression values are disjoint from all the other Scheme
     types.

 -- Function: irregex-match-data? OBJ
     Return '#t' if OBJ is a successful match result from
     'irregex-search' or 'irregex-match'.  Match data values are
     disjoint from all the other Scheme types.


File: vicare-libs.info,  Node: irregex compile,  Next: irregex match,  Prev: irregex pred,  Up: irregex

50.3 Compiling regular expressions
==================================

 -- Function: irregex PCRE/SRE OPTIONS ...
 -- Function: string->irregex PCRE OPTIONS ...
 -- Function: sre->irregex SRE OPTIONS ...
     Compile a regular expression from either a POSIX-style regular
     expression string (with most PCRE extensions) or an SCSH-style SRE.
     Return an object representing the compiled regular expression.

     There is no '(rx ...)' syntax to specify the regular expression, we
     just use normal Scheme lists.  Technically a string by itself could
     be considered a valid SRE, so if we want to just match a literal
     string we should use something like:

          (irregex `(: ,str))

     or use the explicit:

          (string->irregex str)

     The optional OPTIONS are a list of any of the following symbols,
     which must be quoted:

     'i'
     'case-insensitive'
          match case-insensitively;

     'm'
     'multi-line'
          treat string as multiple lines (effects '^' and '$');

     's'
     'single-line'
          treat string as a single line ('.' can match newline);

     'utf8'
          UTF-8 mode, assumes strings are byte-strings;

     'fast'
          try to optimize the regular expression;

     'small'
          try to compile a smaller regular expression.

          *NOTE* The 'fast' and 'small' options may not actually make
          the compiled expression any faster or smaller at the moment.


File: vicare-libs.info,  Node: irregex match,  Next: irregex replace,  Prev: irregex compile,  Up: irregex

50.4 Match objects
==================

 -- Function: irregex-search IRX STR
 -- Function: irregex-search IRX STR START
 -- Function: irregex-search IRX STR START PAST
     Search for any instance of the pattern IRX in STR, optionally
     between the given range.  If a match is found, return a match
     object, otherwise '#f'.  Match objects can be used to query the
     selected substring or its submatches using the 'irregex-match-*'
     procedures below.  Examples:

          (irregex-search "[a-z]+" "123abc456")
          => ... ; match object

          (irregex-search "[a-z]+" "123456")
          => #f

          (irregex-search "foobar" "abcFOOBARdef")
          => #f

          (irregex-search (string->irregex "foobar"
                                           'case-insensitive)
                          "abcFOOBARdef")
          => ... ; match object

     Matching follows the POSIX leftmost, longest semantics, when
     searching.  That is, of all possible matches in the string,
     'irregex-search' will return the match at the first position
     (leftmost).  If multiple matches are possible from that same first
     position, the longest match is returned.

 -- Function: irregex-match IRX STR
     Like 'irregex-search', but performs an anchored match against the
     beginning and end of the string, without searching.

     Examples:

          (irregex-match '(w/nocase "foobar") "abcFOOBARdef")
          => #f

          (irregex-match '(w/nocase "foobar") "FOOBAR")
          => ... ; match object

 -- Function: irregex-match-substring MATCH-OBJ
 -- Function: irregex-match-substring MATCH-OBJ INDEX-OR-NAME
 -- Function: irregex-match-start-index MATCH-OBJ INDEX-OR-NAME
 -- Function: irregex-match-end-index MATCH-OBJ INDEX-OR-NAME
     Fetch the matched substring (or its start or end offset) at the
     given submatch index, or named submatch.  The entire match is index
     0, the first 1, etc.  The default is index 0.  Examples:

          (irregex-match-substring
             (irregex-search "ciao" "hello ciao salut")
             0)
          => "ciao"

          (let ((match (irregex-search "c(i(a(o)))"
                                       "hello ciao salut")))
          ;;;                           01234567890123456

            (irregex-match-substring match)       => "ciao"
            (irregex-match-substring match 0)     => "ciao"
            (irregex-match-substring match 1)     => "iao"
            (irregex-match-substring match 2)     => "ao"
            (irregex-match-substring match 3)     => "o"

            (irregex-match-start-index match 0)   => 6
            (irregex-match-past-index match 0))   => 10


File: vicare-libs.info,  Node: irregex replace,  Next: irregex chunk,  Prev: irregex match,  Up: irregex

50.5 Replacing substrings
=========================

 -- Function: irregex-replace IRX STR [REPLACEMENTS ...]
 -- Function: irregex-replace/all IRX STR [REPLACEMENTS ...]
     Match a pattern in a string, and replaces it with a (possibly
     empty) list of substitutions.  Each REPLACEMENT can be either a
     string literal, a numeric index, a symbol (as a named submatch), or
     a procedure which takes one argument (the match object) and returns
     a string.

     'irregex-replace' will replace only the first match, while
     'irregex-replace/all' will replace all of them.

     Examples:

          (irregex-replace "[aeiou]" "hello world" "*")
          => "h*llo world"

          (irregex-replace/all "[aeiou]" "hello world" "*")
          => "h*ll* w*rld"


File: vicare-libs.info,  Node: irregex chunk,  Next: irregex misc,  Prev: irregex replace,  Up: irregex

50.6 Chunked string matching
============================

It's often desirable to perform regular expression matching over
sequences of characters not represented as a single string.  The most
obvious example is a text-buffer data structure, but we may also want to
match over lists or trees of strings (i.e.  ropes), over only certain
ranges within a string, over an input port, etc.

   With existing regular expression libraries, the only way to
accomplish this is by converting the abstract sequence into a freshly
allocated string.  This can be expensive, or even impossible if the
object is a text-buffer opened onto a 500MB file.

   '(vicare irregex)' provides a chunked string API specifically for
this purpose.

 -- Function: make-irregex-chunker GET-NEXT GET-STRING
 -- Function: make-irregex-chunker GET-NEXT GET-STRING GET-START
 -- Function: make-irregex-chunker GET-NEXT GET-STRING GET-START GET-END
 -- Function: make-irregex-chunker GET-NEXT GET-STRING GET-START GET-END
 -- Function: make-irregex-chunker GET-NEXT GET-STRING GET-START GET-END
          GET-SUBSTRING
 -- Function: make-irregex-chunker GET-NEXT GET-STRING GET-START GET-END
          GET-SUBSTRING GET-SUBCHUNK
     Define a chunking API.

     '(GET-NEXT chunk)'
          Return the next chunk, or '#f' if there are no more chunks.

     '(GET-STRING chunk)'
          A string source for the chunk.

     '(GET-START chunk)'
          The start index of the result of GET-STRING (defaults to
          always 0).

     '(GET-END chunk)'
          The end (exclusive) of the string (defaults to 'string-length'
          of the source string).

     '(GET-SUBSTRING CNK1 I CNK2 J)'
          A substring for the range between the chunk CNK1 starting at
          index I and ending at CNK2 at index J.

     '(GET-SUBCHUNK CNK1 I CNK2 J)'
          As above but returns a new chunked data type instead of a
          string (optional).

     There are two important constraints on the GET-NEXT procedure.  It
     must return an 'eq?' identical object when called multiple times on
     the same chunk, and it must not return a chunk with an empty string
     (start == past).  This second constraint is for performance
     reasons, we push the work of possibly filtering empty chunks to the
     chunker since there are many chunk types for which empty strings
     aren't possible, and this work is thus not needed.  Note that the
     initial chunk passed to match on is allowed to be empty.

     GET-SUBSTRING is provided for possible performance improvements,
     without it a default is used.

     GET-SUBCHUNK is optional, but without it we cannot use
     'irregex-match-subchunk'.

 -- Function: irregex-match-subchunk MATCH-OBJ
 -- Function: irregex-match-subchunk MATCH-OBJ INDEX-OR-NAME
     Generate a chunked data-type for the given match item, of the same
     type as the underlying chunk type.  This is only available if the
     chunk type specifies the 'get-subchunk' API, otherwise an error is
     raised.

 -- Function: irregex-search/chunked IRX CHUNKER CHUNK
 -- Function: irregex-search/chunked IRX CHUNKER CHUNK START
 -- Function: irregex-match/chunked IRX CHUNKER CHUNK
 -- Function: irregex-match/chunked IRX CHUNKER CHUNK START
     These return normal match-data objects.

     Example: To match against a simple, flat list of strings use:

          (define (rope->string rope1 start rope2 end)
            (if (eq? rope1 rope2)
                (substring (car rope1) start end)
                (let loop ((rope (cdr rope1))
                           (res (list (substring (car rope1) start))))
                   (if (eq? rope rope2)
                       (string-concatenate-reverse      ; from SRFI-13
                        (cons (substring (car rope) 0 end) res))
                       (loop (cdr rope) (cons (car rope) res))))))

          (define rope-chunker
            (make-irregex-chunker (lambda (x)
                                    (and (pair? (cdr x)) (cdr x)))
                                  car
                                  (lambda (x)
                                    0)
                                  (lambda (x)
                                    (string-length (car x)))
                                  rope->string))

          (irregex-search/chunked <pat> rope-chunker <list-of-strings>)

     Here we are just using the default start, end and substring
     behaviors, so the above chunker could simply be defined as:

          (define rope-chunker
            (make-irregex-chunker (lambda (x)
                                    (and (pair? (cdr x)) (cdr x)))
                                  car))

 -- Function: irregex-fold/chunked IRX KONS KNIL CHUNKER CHUNK
 -- Function: irregex-fold/chunked IRX KONS KNIL CHUNKER CHUNK FINISH
 -- Function: irregex-fold/chunked IRX KONS KNIL CHUNKER CHUNK FINISH
          START-INDEX
     Chunked version of 'irregex-fold'.


File: vicare-libs.info,  Node: irregex misc,  Next: irregex pcre,  Prev: irregex chunk,  Up: irregex

50.7 Miscellaneous functions
============================

 -- Function: irregex-split IRX STR
 -- Function: irregex-split IRX STR START END
 -- Function: irregex-extract IRX STR
 -- Function: irregex-extract IRX STR START END
     'irregex-split' splits the string STR into substrings divided by
     the pattern in IRX.  'irregex-extract' does the opposite, returning
     a list of each instance of the pattern matched disregarding the
     substrings in between.

 -- Function: irregex-fold IRX KONS KNIL STR [FINISH START PAST]
     This follows the API for 'regexp-fold' from SCSH. The KONS
     procedure takes the following signature:

          (KONS <from-index> <match> <seed>)

     where '?FROM-INDEX' is the index from where we started searching
     (initially START and thereafter the past index of the last match);
     '?MATCH' is the resulting match data object; '?SEED' is the
     accumulated fold result starting with KNIL.

     The rationale for providing the '?FROM-INDEX' is because this
     information is useful (e.g.  for extracting the unmatched portion
     of the string before the current match, as needed in
     'irregex-replace'), and not otherwise directly accessible.

     The optional FINISH takes two arguments:

          (FINISH <from-index> <seed>)

     which simiarly allows us to pick up the unmatched tail of the
     string, and defaults to just returning the '?SEED'.

     START and PAST select a substring of STR.

     To extract all instances of a match out of a string, we can use:

          (map irregex-match-substring
            (irregex-fold <irx>
                          (lambda (i m s)
                            (cons m s))
                          '()
                          <str>
                          (lambda (i s)
                            (reverse s))))

 -- Function: irregex-quote STR
     Return a new string with any special regular expression characters
     escaped, to match the original string literally in POSIX regular
     expressions.

 -- Function: irregex-opt LIST-OF-STRINGS
     Return an optimized SRE matching any of the literal strings in the
     list, like Emacs' 'regexp-opt'.  Note this optimization does not
     help when 'irregex' is able to build a DFA.

 -- Function: sre->string SRE
     Convert an SRE to a POSIX-style regular expression string, if
     possible.


File: vicare-libs.info,  Node: irregex pcre,  Next: irregex sre,  Prev: irregex misc,  Up: irregex

50.8 Supported PCRE syntax
==========================

Since the PCRE syntax is so overwhelming complex, it's easier to just
list what '(vicare irregex)' does *not* support for now.  Refer to the
PCRE documentation for details.(1)

   * Unicode character classes ('\P') are not supported, but will be in
     an upcoming release.  '\C' named characters are not supported.

   * Callbacks, subroutine patterns and recursive patterns are not
     supported.  '(*FOO)' patterns are not supported and may never be.

   * '\G' and '\K' are not supported.

   * Octal character escapes are not supported because they are
     ambiguous with back-references; just use hex character escapes.

   Other than that, everything should work, including named submatches,
zero-width assertions, conditional patterns, etc.

   In addition, '\<' and '\>' act as beginning-of-word and end-of-word
marks, respectively, as in Emacs regular expressions.

   Also, two escapes are provided to embed SRE patterns inside PCRE
strings, '"\'<sre>"' and '"(*'<sre>)"'.  For example, to match a
comma-delimited list of integers we could use:

     "\\'integer(,\\'integer)*"

and to match a URL in angle brackets we could use:

     "<('*http-url)>"

note in the second example the enclosing '"('*...)"' syntax is needed
because the Scheme reader would consider the closing '>' as part of the
SRE symbol.

   The following chart gives a quick reference from PCRE form to the SRE
equivalent:

     ;; basic syntax
     "^"                     ;; bos (or eos inside (?m: ...))
     "$"                     ;; eos (or eos inside (?m: ...))
     "."                     ;; nonl
     "a?"                    ;; (? a)
     "a*"                    ;; (* a)
     "a+"                    ;; (+ a)
     "a??"                   ;; (?? a)
     "a*?"                   ;; (*? a)
     "a+?"                   ;; (+? a)
     "a{n,m}"                ;; (** n m a)

     ;; grouping
     "(...)"                 ;; (submatch ...)
     "(?:...)"               ;; (: ...)
     "(?i:...)"              ;; (w/nocase ...)
     "(?-i:...)"             ;; (w/case ...)
     "(?<name>...)"          ;; (=> <name>...)

     ;; character classes
     "[aeiou]"               ;; ("aeiou")
     "[^aeiou]"              ;; (~ "aeiou")
     "[a-z]"                 ;; (/ "az") or (/ "a" "z")
     "[[:alpha:]]"           ;; alpha

     ;; assertions
     "(?=...)"               ;; (look-ahead ...)
     "(?!...)"               ;; (neg-look-ahead ...)
     "(?<=...)"              ;; (look-behind ...)
     "(?<!...)"              ;; (neg-look-behind ...)
     "(?(test)pass|fail)"    ;; (if test pass fail)
     "(*COMMIT)"             ;; commit

   ---------- Footnotes ----------

   (1) See <http://pcre.org/pcre.txt>.  URL last verified Sun Jul 12,
2009.


File: vicare-libs.info,  Node: irregex sre,  Prev: irregex pcre,  Up: irregex

50.9 Extended SRE Syntax
========================

Scheme Regular Expressions were proposed by Olin Shivers.  The original
request for coments is available at:

               <http://www.scsh.net/docu/post/sre.html>

* Menu:

* irregex sre syntax::          Syntax tables.
* irregex sre basic::           Basic patterns.
* irregex sre repetition::      Repetition patterns.
* irregex sre char-sets::       Character sets.
* irregex sre assertion::       Assertion patterns.
* irregex sre utility::         Utility patterns.


File: vicare-libs.info,  Node: irregex sre syntax,  Next: irregex sre basic,  Up: irregex sre

50.9.1 Syntax tables
--------------------

The following tables summarizes the SRE syntax, with detailed
explanations following.

     ;; basic patterns
     <string>                          ; literal string
     (seq <sre> ...)                   ; sequence
     (: <sre> ...)
     (or <sre> ...)                    ; alternation

     ;; optional/multiple patterns
     (? <sre> ...)                     ; 0 or 1 matches
     (* <sre> ...)                     ; 0 or more matches
     (+ <sre> ...)                     ; 1 or more matches
     (= <n> <sre> ...)                 ; exactly <n> matches
     (>= <n> <sre> ...)                ; <n> or more matches
     (** <from> <to> <sre> ...)        ; <n> to <m> matches
     (?? <sre> ...)                    ; non-greedy (non-greedy) pattern: (0 or 1)
     (*? <sre> ...)                    ; non-greedy kleene star
     (**? <from> <to> <sre> ...)       ; non-greedy range

     ;; submatch patterns
     (submatch <sre> ...)              ; numbered submatch
     ($ <sre> ...)
     (submatch-named <name> <sre> ...) ; named submatch
     (=> <name> <sre> ...)
     (backref <n-or-name>)             ; match a previous submatch

     ;; toggling case-sensitivity
     (w/case <sre> ...)                ; enclosed <sre>s are case-sensitive
     (w/nocase <sre> ...)              ; enclosed <sre>s are case-insensitive

     ;; character sets
     <char>                            ; singleton char set
     (<string>)                        ; set of chars
     (or <cset-sre> ...)               ; set union
     (~ <cset-sre> ...)                ; set complement (i.e. [^...])
     (- <cset-sre> ...)                ; set difference
     (& <cset-sre> ...)                ; set intersection
     (/ <range-spec> ...)              ; pairs of chars as ranges

     ;; named character sets
     any
     nonl
     ascii
     lower-case     lower
     upper-case     upper
     alphabetic     alpha
     numeric        num
     alphanumeric   alphanum  alnum
     punctuation    punct
     graphic        graph
     whitespace     white     space
     printing       print
     control        cntrl
     hex-digit      xdigit

     ;; assertions and conditionals
     bos eos                           ; beginning/end of string
     bol eol                           ; beginning/end of line
     bow eow                           ; beginning/end of word
     nwb                               ; non-word-boundary
     (look-ahead <sre> ...)            ; zero-width look-ahead assertion
     (look-behind <sre> ...)           ; zero-width look-behind assertion
     (neg-look-ahead <sre> ...)        ; zero-width negative look-ahead assertion
     (neg-look-behind <sre> ...)       ; zero-width negative look-behind assertion
     (atomic <sre> ...)                ; for (?>...) independent patterns
     (if <test> <pass> [<fail>])       ; conditional patterns
     commit                            ; don't backtrack beyond this (i.e. cut)

     ;; backwards compatibility
     (posix-string <string>)           ; embed a POSIX string literal


File: vicare-libs.info,  Node: irregex sre basic,  Next: irregex sre repetition,  Prev: irregex sre syntax,  Up: irregex sre

50.9.2 Basic patterns
---------------------

The simplest SRE is a literal string, which matches that string exactly.

     (irregex-search "needle" "hayneedlehay")
     => #<match>

   By default the match is case-sensitive, though we can control this
either with the compiler flags or local overrides:

     (irregex-search "needle" "haynEEdlehay")
     => #f

     (irregex-search (irregex "needle" 'i) "haynEEdlehay")
     => #<match>

     (irregex-search '(w/nocase "needle") "haynEEdlehay")
     => #<match>

   We can use 'w/case' to switch back to case-sensitivity inside a
'w/nocase' or when the SRE was compiled with 'case-insensitive':

     (irregex-search '(w/nocase "SMALL" (w/case "BIG")) "smallBIGsmall")
     => #<match>

     (irregex-search '(w/nocase "small" (w/case "big")) "smallBIGsmall")
     => #f

   Of course, literal strings by themselves aren't very interesting
regular expressions, so we want to be able to compose them.  The most
basic way to do this is with the 'seq' operator (or its abbreviation
':'), which matches one or more patterns consecutively:

     (irregex-search '(: "one" space "two" space "three") "one two three")
     => #<match>

   The 'w/case' and 'w/nocase' operators allowed multiple SREs in a
sequence; other operators that take any number of arguments (e.g.  the
repetition operators below) allow such implicit sequences.

   To match any one of a set of patterns we use the 'or' alternation
operator:

     (irregex-search '(or "eeney" "meeney" "miney") "meeney")
     => #<match>

     (irregex-search '(or "eeney" "meeney" "miney") "moe")
     => #f


File: vicare-libs.info,  Node: irregex sre repetition,  Next: irregex sre char-sets,  Prev: irregex sre basic,  Up: irregex sre

50.9.3 Repetition patterns
--------------------------

There are several ways to control the number of times a pattern is
matched.  The simplest of these is '?' which just optionally matches the
pattern:

     (irregex-search '(: "match" (? "es") "!") "matches!")
     => #<match>

     (irregex-search '(: "match" (? "es") "!") "match!")
     => #<match>

     (irregex-search '(: "match" (? "es") "!") "matche!")
     => #f

   To optionally match any number of times we use '*', the Kleene star:

     (irregex-search '(: "<" (* (~ #\>)) ">") "<html>")
     => #<match>

     (irregex-search '(: "<" (* (~ #\>)) ">") "<>")
     => #<match>

     (irregex-search '(: "<" (* (~ #\>)) ">") "<html")
     => #f

   Often we want to match any number of times, but at least one time is
required, and for that we use '+':

     (irregex-search '(: "<" (+ (~ #\>)) ">") "<html>")
     => #<match>

     (irregex-search '(: "<" (+ (~ #\>)) ">") "<a>")
     => #<match>

     (irregex-search '(: "<" (+ (~ #\>)) ">") "<>")
     => #f

   More generally, to match at least a given number of times, we use
'>=':

     (irregex-search '(: "<" (>= 3 (~ #\>)) ">") "<table>")
     => #<match>

     (irregex-search '(: "<" (>= 3 (~ #\>)) ">") "<pre>")
     => #<match>

     (irregex-search '(: "<" (>= 3 (~ #\>)) ">") "<tr>")
     => #f

   To match a specific number of times exactly we use '=':

     (irregex-search '(: "<" (= 4 (~ #\>)) ">") "<html>")
     => #<match>

     (irregex-search '(: "<" (= 4 (~ #\>)) ">") "<table>")
     => #f

   And finally, the most general form is '**' which specifies a range of
times to match.  All of the earlier forms are special cases of this.

     (irregex-search '(: (= 3 (** 1 3 numeric) ".")
                         (** 1 3 numeric))
                     "192.168.1.10")
     => #<match>

     (irregex-search '(: (= 3 (** 1 3 numeric) ".")
                         (** 1 3 numeric))
                     "192.0168.1.10")
     => #f

   There are also so-called "non-greedy" variants of these repetition
operators, by convention suffixed with an additional '?'.  Since the
normal repetition patterns can match any of the allotted repetition
range, these operators will match a string if and only if the normal
versions matched.  However, when the endpoints of which submatch matched
are taken into account (specifically, all matches when using
'irregex-search' since the endpoints of the match itself matter), the
use of a non-greedy repetition can change the result.

   So, whereas '?' can be thought to mean "match or don't match", '??'
means "don't match or match".  '*' typically consumes as much as
possible, but '*?' tries first to match zero times, and only consumes
one at a time if that fails.  If we have a greedy operator followed by a
non-greedy operator in the same pattern, they can produce surprising
results as they compete to make the match longer or shorter.  If this
seems confusing, that's because it is.  Non-greedy repetitions are
defined only in terms of the specific backtracking algorithm used to
implement them, which for compatibility purposes always means the Perl
algorithm.  Thus, when using these patterns we force '(vicare irregex)'
to use a backtracking engine, and can't rely on efficient execution.


File: vicare-libs.info,  Node: irregex sre char-sets,  Next: irregex sre assertion,  Prev: irregex sre repetition,  Up: irregex sre

50.9.4 Character sets
---------------------

Perhaps more common than matching specific strings is matching any of a
set of characters.  We can use the 'or' alternation pattern on a list of
single-character strings to simulate a character set, but this is too
clumsy for everyday use so SRE syntax allows a number of shortcuts.

   A single character matches that character literally, a trivial
character class.  More conveniently, a list holding a single element
which is a string, refers to the character set composed of every
character in the string.

     (irregex-match '(* #\-) "---")
     => #<match>

     (irregex-match '(* #\-) "-_-")
     => #f

     (irregex-match '(* ("aeiou")) "oui")
     => #<match>

     (irregex-match '(* ("aeiou")) "ouais")
     => #f

   Ranges are introduced with the '/' operator.  Strings or characters
in the '/' are flattened and then taken in pairs to represent the start
and end points, inclusive, of character ranges.

     (irregex-match '(* (/ "AZ09")) "R2D2")
     => #<match>

     (irregex-match '(* (/ "AZ09")) "C-3PO")
     => #f

   In addition, a number of set algebra operations is provided.  'or',
of course, has the same meaning, but when all the options are character
sets it can be thought of as the set union operator.  This is further
extended by the '&' set intersection, '-' set difference, and '~' set
complement operators.

     (irregex-match '(* (& (/ "az") (~ ("aeiou")))) "xyzzy")
     => #<match>

     (irregex-match '(* (& (/ "az") (~ ("aeiou")))) "vowels")
     => #f

     (irregex-match '(* (- (/ "az") ("aeiou"))) "xyzzy")
     => #<match>

     (irregex-match '(* (- (/ "az") ("aeiou"))) "vowels")
     => #f


File: vicare-libs.info,  Node: irregex sre assertion,  Next: irregex sre utility,  Prev: irregex sre char-sets,  Up: irregex sre

50.9.5 Assertion patterns
-------------------------

It can be useful to assert something about the area around a pattern,
without explicitly making it part of the pattern.  The most common cases
are specifically anchoring some pattern to the beginning or end of a
word or line or even the whole string.  For example, to match on the end
of a word:

     (irregex-match '(: "foo" eow) "foo")
     => #<match>

     (irregex-match '(: "foo" eow) "foo!")
     => #<match>

     (irregex-match '(: "foo" eow) "foof")
     => #f

   The 'bow', 'bol', 'eol', 'bos' and 'eos' work similarly.  'nwb'
asserts that you are not in a word-boundary; if replaced with 'eow' in
the above examples it would reverse all the results.

   There is no 'wb', since we probably know from context whether it
would be the beginning or end of a word, but if we need it we can always
use '(or bow eow)'.

   Somewhat more generally, Perl introduced positive and negative
'look-ahead' and 'look-behind' patterns.  Perl's 'look-behind' patterns
are limited to a fixed length, however the '(vicare irregex)' versions
have no such limit.

     (irregex-match '(: "regular" (look-ahead " expression"))
                    "regular expression")
     => #<match>

   The most general case, of course, would be an 'and' pattern to
complement the 'or' pattern; all the patterns must match or the whole
pattern fails.  This may be provided in a future release, although it
(and 'look-ahead' and 'look-behind' assertions) are unlikely to be
compiled efficiently.


File: vicare-libs.info,  Node: irregex sre utility,  Prev: irregex sre assertion,  Up: irregex sre

50.9.6 Utility patterns
-----------------------

The following utility regular expressions are also provided for common
patterns that people are eternally reinventing.  They are not
necessarily the official patterns matching the RFC definitions of the
given data, because of the way that such patterns tend to be used.
There are three general usages for regexps:

_Searching_
     Search for a pattern matching a desired object in a larger text.

_Validation_
     Determine whether an entire string matches a pattern.

_Extraction_
     Given a string already known to be valid, extract certain fields
     from it as submatches.

   In some cases, but not always, these will overlap.  When they are
different, 'irregex-search' will naturally always want the searching
version, so '(vicare irregex)' provides that version.

   As an example where these might be different, consider an URL.  If we
want to match all the URLs in some arbitrary text, we probably want to
exclude a period or comma at the tail end of an URL, since it's more
likely being used as punctuation rather than part of the URL, despite
the fact that it would be valid URL syntax.

   Another problem with the RFC definitions is the standard itself may
have become irrelevant.  For example, the pattern '(vicare irregex)'
provides for email addresses doesn't match quoted local parts (e.g.
'"first last"@domain.com') because these are increasingly rare, and
unsupported by enough software that it's better to discourage their use.
Conversely, technically consecutive periods (e.g.
'first..last@domain.com') are not allowed in email addresses, but most
email software does allow this, and in fact such addresses are quite
common in Japan.

   The current patterns provided are:

'newline'
     General newline pattern ('crlf', 'cr', 'lf').

'integer'
     An integer.

'real'
     A real number (including scientific).

'string'
     A "quoted" string.

'symbol'
     An R6RS Scheme symbol.

'ipv4-address'
     A numeric decimal IPv4 address.

'ipv6-address'
     A numeric hexadecimal IPv6 address.

'domain'
     A domain name.

'email'
     An email address.

'http-url'
     A URL beginning with 'https?://'.

   Because of these issues the exact definitions of these patterns are
subject to change, but will be documented clearly when they are
finalized.  More common patterns are also planned, but as what we want
increases in complexity it's probably better to use a real parser.


File: vicare-libs.info,  Node: pregexp,  Next: formations,  Prev: irregex,  Up: Top

51 Portable regular expressions for Scheme
******************************************

The library '(vicare pregexp)' implements regular expressions parsing
modeled on Perl's, and includes such powerful directives as numeric and
non-greedy quantifiers, capturing and non-capturing clustering, POSIX
character classes, selective case- and space-insensitivity,
backreferences, alternation, backtrack pruning, positive and negative
lookahead and lookbehind, in addition to the more basic directives
familiar to all regexp users.

     The library is based upon the Pregexp package by Dorai Sitaram.  It
     was modified to work with R6RS Scheme implementations and to fit
     into the Vicare distribution.

* Menu:

* pregexp intro::               Introduction.
* pregexp api::                 Interface procedures.
* pregexp syntax::              The regexp pattern language.
* pregexp example::             An extended example.


File: vicare-libs.info,  Node: pregexp intro,  Next: pregexp api,  Up: pregexp

51.1 Introduction
=================

A "regexp" is a string that describes a pattern.  A regexp matcher tries
to match this pattern against (a portion of) another string, which we
will call the text string.  The text string is treated as raw text and
not as a pattern.

   Most of the characters in a regexp pattern are meant to match
occurrences of themselves in the text string.  Thus, the pattern 'abc'
matches a string that contains the characters 'a', 'b', 'c' in
succession.

   In the regexp pattern, some characters act as metacharacters, and
some character sequences act as metasequences.  That is, they specify
something other than their literal selves.  For example, in the pattern
'a.c', the characters 'a' and 'c' do stand for themselves but the
metacharacter '.' can match any character (other than newline).
Therefore, the pattern 'a.c' matches an 'a', followed by any character,
followed by a 'c'.

   If we needed to match the character '.' itself, we escape it, ie,
precede it with a backslash ('\').  The character sequence '\.' is thus
a metasequence, since it doesn't match itself but rather just '.'.  So,
to match 'a' followed by a literal '.' followed by 'c', we use the
regexp pattern 'a\\.c'.(1)  Another example of a metasequence is '\t',
which is a readable way to represent the tab character.

   We will call the string representation of a regexp the U-regexp,
where U can be taken to mean Unix-style or universal, because this
notation for regexps is universally familiar.  Our implementation uses
an intermediate tree-like representation called the S-regexp, where S
can stand for Scheme, symbolic, or s-expression.  S-regexps are more
verbose and less readable than U-regexps, but they are much easier for
Scheme's recursive procedures to navigate.

   ---------- Footnotes ----------

   (1) The double backslash is an artifact of Scheme strings, not the
regexp pattern itself.  When we want a literal backslash inside a Scheme
string, we must escape it so that it shows up in the string at all.
Scheme strings use backslash as the escape character, so we end up with
two backslashes; one Scheme-string backslash to escape the regexp
backslash, which then escapes the dot.  Another character that would
need escaping inside a Scheme string is '"'.


File: vicare-libs.info,  Node: pregexp api,  Next: pregexp syntax,  Prev: pregexp intro,  Up: pregexp

51.2 Interface procedures
=========================

 -- Function: pregexp UREX
     Takes a U-regexp, which is a string, and returns an S-regexp, which
     is a tree.

          (pregexp "c.r")
          => (:sub (:or (:seq #\c :any #\r)))

     There is rarely any need to look at the S-regexps returned by
     pregexp.

 -- Function: pregexp-match-positions REX STR
 -- Function: pregexp-match-positions REX STR START
 -- Function: pregexp-match-positions REX STR START PAST
     Take a regexp pattern, either a U- or an S-regexp, and a text
     string, and return a match if the regexp matches (some part of) the
     text string.

     Return '#f' if the regexp did not match the string; and a list of
     index pairs if it did match.

          (pregexp-match-positions "brain" "bird")
          => #f

          (pregexp-match-positions "needle" "hay needle stack")
          => ((4 . 10))

     In the second example, the integers 4 and 10 identify the substring
     that was matched.  4 is the starting (inclusive) index and 10 the
     ending (exclusive) index of the matching substring.

          (substring "hay needle stack" 4 10)
          => "needle"

     Here, 'pregexp-match-positions''s return list contains only one
     index pair, and that pair represents the entire substring matched
     by the regexp.  When we discuss subpatterns later, we will see how
     a single match operation can yield a list of submatches.

     'pregexp-match-positions' takes optional third and fourth arguments
     that specify the indices of the text string within which the
     matching should take place.

          (pregexp-match-positions "needle"
            "his hay needle stack -- my hay needle stack -- her hay needle stack"
            24 43)
          => ((31 . 37))

     Note that the returned indices are still reckoned relative to the
     full text string.

 -- Function: pregexp-match REX STR
 -- Function: pregexp-match REX STR START
 -- Function: pregexp-match REX STR START PAST
     Like 'pregexp-match-positions' but instead of returning index pairs
     it returns the matching substrings:

          (pregexp-match "brain" "bird")
          => #f

          (pregexp-match "needle" "hay needle stack")
          => ("needle")

 -- Function: pregexp-split REX STR
     Takes a regexp pattern and a text string, and return a list of
     substrings of the text string, where the pattern identifies the
     delimiter separating the substrings.

          (pregexp-split ":"
             "/bin:/usr/bin:/usr/bin/X11:/usr/local/bin")
          => ("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")

          (pregexp-split " " "pea soup")
          => ("pea" "soup")

     If the first argument can match an empty string, then the list of
     all the single-character substrings is returned.

          (pregexp-split "" "smithereens")
          => ("s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s")

     To identify one-or-more spaces as the delimiter, take care to use
     the regexp '" +"', not '" *"'.

          (pregexp-split " +" "split pea     soup")
          => ("split" "pea" "soup")

          (pregexp-split " *" "split pea     soup")
          => ("s" "p" "l" "i" "t" "p" "e" "a" "s" "o" "u" "p")

 -- Function: pregexp-replace REX STR REPLACEMENT
     Replace the matched portion of the text string by another string.
     The first argument is the pattern, the second the text string, and
     the third is the insert string (string to be inserted).

          (pregexp-replace "te" "liberte" "ty")
          => "liberty"

     If the pattern doesn't occur in the text string, the returned
     string is identical ('eq?') to the text string.

 -- Function: pregexp-replace* REX STR REPLACEMENT
     Replace all matches in the text string by the insert string:

          (pregexp-replace* "te" "liberte egalite fraternite" "ty")
          => "liberty egality fratyrnity"

     If the pattern doesn't occur in the text string, the returned
     string is identical ('eq?') to the text string.

 -- Function: pregexp-quote
     Take an arbitrary string and returns a U-regexp (string) that
     precisely represents it.  In particular, characters in the input
     string that could serve as regexp metacharacters are escaped with a
     backslash, so that they safely match only themselves.

          (pregexp-quote "cons")
          => "cons"

          (pregexp-quote "list?")
          => "list\\?"

          (pregexp-quote "([a-z]+) +([0-9]+,)? *([0-9]+)")
          => "\\(\\[a-z\\]\\+\\) \\+\\(\\[0-9\\]\\+,\\)\\? \\*\\(\\[0-9\\]\\+\\)"

     'pregexp-quote' is useful when building a composite regexp from a
     mix of regexp strings and verbatim strings.


File: vicare-libs.info,  Node: pregexp syntax,  Next: pregexp example,  Prev: pregexp api,  Up: pregexp

51.3 The regexp pattern language
================================

Here is a complete description of the regexp pattern language recognized
by the pregexp procedures.

* Menu:

* pregexp syntax basic::        Basic assertions.
* pregexp syntax chars::        Characters and character classes.
* pregexp syntax quantifiers::  Quantifiers.
* pregexp syntax clusters::     Clusters.
* pregexp syntax alternation::  Alternation.
* pregexp syntax backtrack::    Backtracking.
* pregexp syntax look::         Looking ahead and behind.


File: vicare-libs.info,  Node: pregexp syntax basic,  Next: pregexp syntax chars,  Up: pregexp syntax

51.3.1 Basic assertions
-----------------------

The assertions '^' and '$' identify the beginning and the end of the
text string respectively.  They ensure that their adjoining regexps
match at one or other end of the text string.  Examples:

     (pregexp-match-positions "^contact" "first contact")
     => #f

   The regexp fails to match because 'contact' does not occur at the
beginning of the text string.

     (pregexp-match-positions "laugh$" "laugh laugh laugh laugh")
     => ((18 . 23))

   The regexp matches the last laugh.

   The metasequence '\b' asserts that a word boundary exists.

     (pregexp-match-positions "yack\\b" "yackety yack")
     => ((8 . 12))

   The 'yack' in 'yackety' doesn't end at a word boundary so it isn't
matched.  The second 'yack' does and is.

   The metasequence '\B' has the opposite effect to '\b': It asserts
that a word boundary does not exist.

     (pregexp-match-positions "an\\B" "an analysis")
     => ((3 . 5))

   The 'an' that doesn't end in a word boundary is matched.


File: vicare-libs.info,  Node: pregexp syntax chars,  Next: pregexp syntax quantifiers,  Prev: pregexp syntax basic,  Up: pregexp syntax

51.3.2 Characters and character classes
---------------------------------------

Typically a character in the regexp matches the same character in the
text string.  Sometimes it is necessary or convenient to use a regexp
metasequence to refer to a single character.  Thus, metasequences '\n',
'\r', '\t', and '\.' match the newline, return, tab and period
characters respectively.

   The metacharacter period ('.') matches any character other than
newline.

     (pregexp-match "p.t" "pet")
     => ("pet")

   It also matches 'pat', 'pit', 'pot', 'put', and 'p8t' but not 'peat'
or 'pfffft'.

   A character class matches any one character from a set of characters.
A typical format for this is the bracketed character class '[...]',
which matches any one character from the non-empty sequence of
characters enclosed within the brackets.(1)  Thus 'p[aeiou]t' matches
pat, pet, pit, pot, put and nothing else.

   Inside the brackets, a hyphen ('-') between two characters specifies
the ASCII range between the characters.  Eg, 'ta[b-dgn-p]' matches tab,
tac, tad, and tag, and tan, tao, tap.

   An initial caret ('^') after the left bracket inverts the set
specified by the rest of the contents, ie, it specifies the set of
characters other than those identified in the brackets.  Eg, 'do[^g]'
matches all three-character sequences starting with do except dog.

   Note that the metacharacter '^' inside brackets means something quite
different from what it means outside.  Most other metacharacters ('.',
'*', '+', '?', etc.)  cease to be metacharacters when inside brackets,
although we may still escape them for peace of mind.  '-' is a
metacharacter only when it's inside brackets, and neither the first nor
the last character.

   Bracketed character classes cannot contain other bracketed character
classes (although they contain certain other types of character classes;
see below).  Thus a left bracket ('[') inside a bracketed character
class doesn't have to be a metacharacter; it can stand for itself.  Eg,
'[a[b]' matches 'a', '[', and 'b'.

   Furthermore, since empty bracketed character classes are disallowed,
a right bracket (']') immediately occurring after the opening left
bracket also doesn't need to be a metacharacter.  Eg, '[]ab]' matches
']', 'a', and 'b'.

Some frequently used character classes
......................................

Some standard character classes can be conveniently represented as
metasequences instead of as explicit bracketed expressions.  '\d'
matches a digit ('[0-9]'); '\s' matches a whitespace character; '\w'
matches a character that could be part of a "word".(2)

   The upper-case versions of these metasequences stand for the
inversions of the corresponding character classes.  Thus '\D' matches a
non-digit, '\S' a non-whitespace character, and '\W' a non-"word"
character.

   Remember to include a double backslash when putting these
metasequences in a Scheme string:

     (pregexp-match "\\d\\d"
                    "0 dear, 1 have 2 read catch 22 before 9")
     => ("22")

   These character classes can be used inside a bracketed expression.
Eg, '[a-z\\d]' matches a lower-case letter or a digit.

POSIX character classes
.......................

A POSIX character class is a special metasequence of the form '[:...:]'
that can be used only inside a bracketed expression.  The POSIX classes
supported are:

'[:alnum:]'
     Letters and digits.

'[:alpha:]'
     Letters.

'[:algor:]'
     The letters c, h, a and d.

'[:ascii:]'
     7-bit ascii characters.

'[:blank:]'
     Widthful whitespace, ie, space and tab.

'[:cntrl:]'
     "Control" characters, viz, those with code < 32.

'[:digit:]'
     Digits, same as '\d'.

'[:graph:]'
     Characters that use ink.

'[:lower:]'
     Lower-case letters.

'[:print:]'
     Ink-users plus widthful whitespace.

'[:space:]'
     Whitespace, same as '\s'.

'[:upper:]'
     Upper-case letters.

'[:word:]'
     Letters, digits, and underscore, same as '\w'.

'[:xdigit:]'
     Hex digits.

   For example, the regexp '[[:alpha:]_]' matches a letter or
underscore.

     (pregexp-match "[[:alpha:]_]" "--x--")
     => ("x")

     (pregexp-match "[[:alpha:]_]" "--_--")
     => ("_")

     (pregexp-match "[[:alpha:]_]" "--:--")
     => #f

   The POSIX class notation is valid only inside a bracketed expression.
For instance, '[:alpha:]', when not inside a bracketed expression, will
not be read as the letter class.  Rather it is (from previous
principles) the character class containing the characters :, a, l, p, h.

     (pregexp-match "[:alpha:]" "--a--")
     => ("a")

     (pregexp-match "[:alpha:]" "--_--")
     => #f

   By placing a caret ('^') immediately after '[:', we get the inversion
of that POSIX character class.  Thus, '[:^alpha]' is the class
containing all characters except the letters.

   ---------- Footnotes ----------

   (1) Requiring a bracketed character class to be non-empty is not a
limitation, since an empty character class can be more easily
represented by an empty string.

   (2) Following regexp custom, we identify "word" characters as
'[A-Za-z0-9_]', although these are too restrictive for what a Schemer
might consider a "word".


File: vicare-libs.info,  Node: pregexp syntax quantifiers,  Next: pregexp syntax clusters,  Prev: pregexp syntax chars,  Up: pregexp syntax

51.3.3 Quantifiers
------------------

The quantifiers '*', '+', and '?' match respectively: zero or more, one
or more, and zero or one instances of the preceding subpattern.

     (pregexp-match-positions "c[ad]*r" "cadaddadddr")
     => ((0 . 11))
     (pregexp-match-positions "c[ad]*r" "cr")
     => ((0 . 2))

     (pregexp-match-positions "c[ad]+r" "cadaddadddr")
     => ((0 . 11))
     (pregexp-match-positions "c[ad]+r" "cr")
     => #f

     (pregexp-match-positions "c[ad]?r" "cadaddadddr")
     => #f
     (pregexp-match-positions "c[ad]?r" "cr")
     => ((0 . 2))
     (pregexp-match-positions "c[ad]?r" "car")
     => ((0 . 3))

Numeric quantifiers
...................

We can use braces to specify much finer-tuned quantification than is
possible with '*', '+', '?'.

   The quantifier '{m}' matches exactly m instances of the preceding
subpattern.  m must be a nonnegative integer.

   The quantifier '{m,n}' matches at least m and at most n instances.  m
and n are nonnegative integers with m <= n.  We may omit either or both
numbers, in which case m defaults to 0 and n to infinity.

   It is evident that '+' and '?' are abbreviations for '{1,}' and
'{0,1}' respectively.  '*' abbreviates '{,}', which is the same as
'{0,}'.

     (pregexp-match "[aeiou]{3}" "vacuous")
     => ("uou")

     (pregexp-match "[aeiou]{3}" "evolve")
     => #f

     (pregexp-match "[aeiou]{2,3}" "evolve")
     => #f

     (pregexp-match "[aeiou]{2,3}" "zeugma")
     => ("eu")

Non-greedy quantifiers
......................

The quantifiers described above are greedy, i.e., they match the maximal
number of instances that would still lead to an overall match for the
full pattern.

     (pregexp-match "<.*>" "<tag1> <tag2> <tag3>")
     => ("<tag1> <tag2> <tag3>")

   To make these quantifiers non-greedy, append a '?' to them.
Non-greedy quantifiers match the minimal number of instances needed to
ensure an overall match.

     (pregexp-match "<.*?>" "<tag1> <tag2> <tag3>")
     => ("<tag1>")

   The non-greedy quantifiers are respectively: '*?', '+?', '??',
'{m}?', '{m,n}?'.  Note the two uses of the metacharacter '?'.


File: vicare-libs.info,  Node: pregexp syntax clusters,  Next: pregexp syntax alternation,  Prev: pregexp syntax quantifiers,  Up: pregexp syntax

51.3.4 Clusters
---------------

Clustering, i.e., enclosure within parens '(...)', identifies the
enclosed subpattern as a single entity.  It causes the matcher to
capture the submatch, or the portion of the string matching the
subpattern, in addition to the overall match.

     (pregexp-match "([a-z]+) ([0-9]+), ([0-9]+)" "jan 1, 1970")
     => ("jan 1, 1970" "jan" "1" "1970")

   Clustering also causes a following quantifier to treat the entire
enclosed subpattern as an entity.

     (pregexp-match "(poo )*" "poo poo platter")
     => ("poo poo " "poo ")

   The number of submatches returned is always equal to the number of
subpatterns specified in the regexp, even if a particular subpattern
happens to match more than one substring or no substring at all.

     (pregexp-match "([a-z ]+;)*" "lather; rinse; repeat;")
     => ("lather; rinse; repeat;" " repeat;")

   Here the '*'-quantified subpattern matches three times, but it is the
last submatch that is returned.

   It is also possible for a quantified subpattern to fail to match,
even if the overall pattern matches.  In such cases, the failing
submatch is represented by '#f'.

     (define date-re
       ;match `month year' or `month day, year'.
       ;subpattern matches day, if present
       (pregexp "([a-z]+) +([0-9]+,)? *([0-9]+)"))

     (pregexp-match date-re "jan 1, 1970")
     => ("jan 1, 1970" "jan" "1," "1970")

     (pregexp-match date-re "jan 1970")
     => ("jan 1970" "jan" #f "1970")

Backreferences
..............

Submatches can be used in the insert string argument of the procedures
'pregexp-replace' and 'pregexp-replace*'.  The insert string can use
'\n' as a backreference to refer back to the n-th submatch, i.e., the
substring that matched the n-th subpattern.  '\0' refers to the entire
match, and it can also be specified as '\&'.

     (pregexp-replace "_(.+?)_"
       "the _nina_, the _pinta_, and the _santa maria_"
       "*\\1*")
     => "the *nina*, the _pinta_, and the _santa maria_"

     (pregexp-replace* "_(.+?)_"
       "the _nina_, the _pinta_, and the _santa maria_"
       "*\\1*")
     => "the *nina*, the *pinta*, and the *santa maria*"

recall: '\S' stands for non-whitespace character:

     (pregexp-replace "(\\S+) (\\S+) (\\S+)"
       "eat to live"
       "\\3 \\2 \\1")
     => "live to eat"

   Use '\\' in the insert string to specify a literal backslash.  Also,
'\$' stands for an empty string, and is useful for separating a
backreference '\n' from an immediately following number.

   Backreferences can also be used within the regexp pattern to refer
back to an already matched subpattern in the pattern.  '\n' stands for
an exact repeat of the n-th submatch.(1)

     (pregexp-match "([a-z]+) and \\1"
       "billions and billions")
     => ("billions and billions" "billions")

   Note that the backreference is not simply a repeat of the previous
subpattern.  Rather it is a repeat of the particular substring already
matched by the subpattern.

   In the above example, the backreference can only match billions.  It
will not match millions, even though the subpattern it harks back to
'([a-z]+)' would have had no problem doing so:

     (pregexp-match "([a-z]+) and \\1"
       "billions and millions")
     => #f

   The following corrects doubled words:

     (pregexp-replace* "(\\S+) \\1"
       "now is the the time for all good men to to come to the aid of of the party"
       "\\1")
     => "now is the time for all good men to come to the aid of the party"

   The following marks all immediately repeating patterns in a number
string:

     (pregexp-replace* "(\\d+)\\1"
       "123340983242432420980980234"
       "{\\1,\\1}")
     => "12{3,3}40983{24,24}3242{098,098}0234"

Non-capturing clusters
......................

It is often required to specify a cluster (typically for quantification)
but without triggering the capture of submatch information.  Such
clusters are called non-capturing.  In such cases, use '(?:' instead of
'(' as the cluster opener.  In the following example, the non-capturing
cluster eliminates the "directory" portion of a given pathname, and the
capturing cluster identifies the basename.

     (pregexp-match "^(?:[a-z]*/)*([a-z]+)$"
       "/usr/local/bin/mzscheme")
     => ("/usr/local/bin/mzscheme" "mzscheme")

Cloisters
.........

The location between the '?' and the ':' of a non-capturing cluster is
called a cloister.(2)  We can put modifiers there that will cause the
enclustered subpattern to be treated specially.  The modifier 'i' causes
the subpattern to match case-insensitively:

     (pregexp-match "(?i:hearth)" "HeartH")
     => ("HeartH")

   The modifier 'x' causes the subpattern to match space-insensitively,
i.e., spaces and comments within the subpattern are ignored.  Comments
are introduced as usual with a semicolon (';') and extend till the end
of the line.  If we need to include a literal space or semicolon in a
space-insensitized subpattern, escape it with a backslash.

     (pregexp-match "(?x: a   lot)" "alot")
     => ("alot")

     (pregexp-match "(?x: a  \\  lot)" "a lot")
     => ("a lot")

     (pregexp-match "(?x:
        a \\ man  \\; \\   ; ignore
        a \\ plan \\; \\   ; me
        a \\ canal         ; completely
        )"
      "a man; a plan; a canal")
     => ("a man; a plan; a canal")

   The parameter 'pregexp-comment-char' contains the comment character
(#\;).  For Perl-like comments,

     (parameterise ((pregexp-comment-char #\#))
        ---)

   We can put more than one modifier in the cloister.

     (pregexp-match "(?ix:
        a \\ man  \\; \\   ; ignore
        a \\ plan \\; \\   ; me
        a \\ canal         ; completely
        )"
      "A Man; a Plan; a Canal")
     => ("A Man; a Plan; a Canal")

   A minus sign before a modifier inverts its meaning.  Thus, we can use
'-i' and '-x' in a subcluster to overturn the insensitivities caused by
an enclosing cluster.

     (pregexp-match "(?i:the (?-i:TeX)book)"
       "The TeXbook")
     => ("The TeXbook")

   This regexp will allow any casing for the and book but insists that
TeX not be differently cased.

   ---------- Footnotes ----------

   (1) '0', which is useful in an insert string, makes no sense within
the regexp pattern, because the entire regexp has not matched yet that
you could refer back to it.

   (2) A useful, if terminally cute, coinage from the abbots of Perl.


File: vicare-libs.info,  Node: pregexp syntax alternation,  Next: pregexp syntax backtrack,  Prev: pregexp syntax clusters,  Up: pregexp syntax

51.3.5 Alternation
------------------

You can specify a list of alternate subpatterns by separating them by
'|'.  The '|' separates subpatterns in the nearest enclosing cluster (or
in the entire pattern string if there are no enclosing parens).

     (pregexp-match "f(ee|i|o|um)" "a small, final fee")
     => ("fi" "i")

     (pregexp-replace* "([yi])s(e[sdr]?|ing|ation)"
        "it is energising to analyse an organisation
        pulsing with noisy organisms"
        "\\1z\\2")
     => "it is energizing to analyze an organization
        pulsing with noisy organisms"

   Note again that if we wish to use clustering merely to specify a list
of alternate subpatterns but do not want the submatch, use '(?:' instead
of '('.

     (pregexp-match "f(?:ee|i|o|um)" "fun for all")
     => ("fo")

   An important thing to note about alternation is that the leftmost
matching alternate is picked regardless of its length.  Thus, if one of
the alternates is a prefix of a later alternate, the latter may not have
a chance to match.

     (pregexp-match "call|call-with-current-continuation"
       "call-with-current-continuation")
     => ("call")

   To allow the longer alternate to have a shot at matching, place it
before the shorter one:

     (pregexp-match "call-with-current-continuation|call"
       "call-with-current-continuation")
     => ("call-with-current-continuation")

   In any case, an overall match for the entire regexp is always
preferred to an overall nonmatch.  In the following, the longer
alternate still wins, because its preferred shorter prefix fails to
yield an overall match.

     (pregexp-match "(?:call|call-with-current-continuation) constrained"
       "call-with-current-continuation constrained")
     => ("call-with-current-continuation constrained")


File: vicare-libs.info,  Node: pregexp syntax backtrack,  Next: pregexp syntax look,  Prev: pregexp syntax alternation,  Up: pregexp syntax

51.3.6 Backtracking
-------------------

We've already seen that greedy quantifiers match the maximal number of
times, but the overriding priority is that the overall match succeed.
Consider:

     (pregexp-match "a*a" "aaaa")

   The regexp consists of two subregexps, 'a*' followed by 'a'.  The
subregexp 'a*' cannot be allowed to match all four 'a''s in the text
string 'aaaa', even though '*' is a greedy quantifier.  It may match
only the first three, leaving the last one for the second subregexp.
This ensures that the full regexp matches successfully.

   The regexp matcher accomplishes this via a process called
backtracking.  The matcher tentatively allows the greedy quantifier to
match all four 'a''s, but then when it becomes clear that the overall
match is in jeopardy, it backtracks to a less greedy match of three
'a''s.  If even this fails, as in the call:

     (pregexp-match "a*aa" "aaaa")

the matcher backtracks even further.  Overall failure is conceded only
when all possible backtracking has been tried with no success.

   Backtracking is not restricted to greedy quantifiers.  Nongreedy
quantifiers match as few instances as possible, and progressively
backtrack to more and more instances in order to attain an overall
match.  There is backtracking in alternation too, as the more rightward
alternates are tried when locally successful leftward ones fail to yield
an overall match.

Disabling backtracking
......................

Sometimes it is efficient to disable backtracking.  For example, we may
wish to commit to a choice, or we know that trying alternatives is
fruitless.  A nonbacktracking regexp is enclosed in '(?>...)'.

     (pregexp-match "(?>a+)." "aaaa")
     => #f

   In this call, the subregexp '?>a+' greedily matches all four 'a''s,
and is denied the opportunity to backpedal.  So the overall match is
denied.  The effect of the regexp is therefore to match one or more
'a''s followed by something that is definitely non-'a'.


File: vicare-libs.info,  Node: pregexp syntax look,  Prev: pregexp syntax backtrack,  Up: pregexp syntax

51.3.7 Looking ahead and behind
-------------------------------

We can have assertions in our pattern that look ahead or behind to
ensure that a subpattern does or does not occur.  These "look around"
assertions are specified by putting the subpattern checked for in a
cluster whose leading characters are:

'?='
     Positive lookahead.

'?!'
     Negative lookahead.

'?<='
     Positive lookbehind.

'?<!'
     Negative lookbehind.

   Note that the subpattern in the assertion does not generate a match
in the final result.  It merely allows or disallows the rest of the
match.

Lookahead
.........

Positive lookahead ('?=') peeks ahead to ensure that its subpattern
could match.

     (pregexp-match-positions "grey(?=hound)"
       "i left my grey socks at the greyhound")
     => ((28 . 32))

   The regexp 'grey(?=hound)' matches grey, but only if it is followed
by hound.  Thus, the first grey in the text string is not matched.

   Negative lookahead ('?!') peeks ahead to ensure that its subpattern
could not possibly match.

     (pregexp-match-positions "grey(?!hound)"
       "the gray greyhound ate the grey socks")
     => ((27 . 31))

   The regexp 'grey(?!hound)' matches 'grey', but only if it is not
followed by 'hound'.  Thus the 'grey' just before 'socks' is matched.

Lookbehind
..........

Positive lookbehind ('?<=') checks that its subpattern could match
immediately to the left of the current position in the text string.

     (pregexp-match-positions "(?<=grey)hound"
       "the hound in the picture is not a greyhound")
     => ((38 . 43))

   The regexp '(?<=grey)hound' matches hound, but only if it is preceded
by grey.

   Negative lookbehind ('?<!') checks that its subpattern could not
possibly match immediately to the left.

     (pregexp-match-positions "(?<!grey)hound"
       "the greyhound in the picture is not a hound")
     => ((38 . 43))

   The regexp '(?<!grey)hound' matches 'hound', but only if it is not
preceded by 'grey'.

   Lookaheads and lookbehinds can be convenient when they are not
confusing.


File: vicare-libs.info,  Node: pregexp example,  Prev: pregexp syntax,  Up: pregexp

51.4 An extended example
========================

Here's an extended example(1) that covers many of the features in
'(vicare pregexp)'.  The problem is to fashion a regexp that will match
any and only IP addresses or dotted quads, i.e., four numbers separated
by three dots, with each number between 0 and 255.  We will use the
commenting mechanism to build the final regexp with clarity.  First, a
subregexp 'n0-255' that matches '0' through '255'.

     (define n0-255
       "(?x:
       \\d          ;  0 through   9
       | \\d\\d     ; 00 through  99
       | [01]\\d\\d ;000 through 199
       | 2[0-4]\\d  ;200 through 249
       | 25[0-5]    ;250 through 255
       )")

   The first two alternates simply get all single- and double-digit
numbers.  Since zero-padding is allowed, we need to match both '1' and
'01'.  We need to be careful when getting 3-digit numbers, since numbers
above 255 must be excluded.  So we fashion alternates to get '000'
through '199', then '200' through '249', and finally '250' through
'255'.(2)

   An IP-address is a string that consists of four 'n0-255's with three
dots separating them.

     (define ip-re1
       (string-append
         "^"        ;nothing before
         n0-255     ;the first n0-255,
         "(?x:"     ;then the subpattern of
         "\\."      ;a dot followed by
         n0-255     ;an n0-255,
         ")"        ;which is
         "{3}"      ;repeated exactly 3 times
         "$"        ;with nothing following
         ))

   Let's try it out.

     (pregexp-match ip-re1
       "1.2.3.4")
     => ("1.2.3.4")

     (pregexp-match ip-re1
       "55.155.255.265")
     => #f

which is fine, except that we also have:

     (pregexp-match ip-re1
       "0.00.000.00")
     => ("0.00.000.00")

   All-zero sequences are not valid IP addresses!  Lookahead to the
rescue.  Before starting to match 'ip-re1', we look ahead to ensure we
don't have all zeros.  We could use positive lookahead to ensure there
is a digit other than zero.

     (define ip-re
       (string-append
         "(?=.*[1-9])" ;ensure there's a non-0 digit
         ip-re1))

   Or we could use negative lookahead to ensure that what's ahead isn't
composed of only zeros and dots.

     (define ip-re
       (string-append
         "(?![0.]*$)" ;not just zeros and dots
                      ;(note: dot is not metachar inside [])
         ip-re1))

   The regexp 'ip-re' will match all and only valid IP addresses.

     (pregexp-match ip-re
       "1.2.3.4")
     => ("1.2.3.4")

     (pregexp-match ip-re
       "0.0.0.0")
     => #f

   ---------- Footnotes ----------

   (1) From: Jeffrey E. F. Friedl, Mastering Regular Expressions, 2/e,
O'Reilly, 2002.

   (2) Note that 'n0-255' lists prefixes as preferred alternates,
something we cautioned against.  However, since we intend to anchor this
subregexp explicitly to force an overall match, the order of the
alternates does not matter.


File: vicare-libs.info,  Node: formations,  Next: silex,  Prev: pregexp,  Up: Top

52 Formatting strings
*********************

The library '(vicare formations)' defines a sophisticated 'format'
function: a powerful way to print numbers, strings and other objects
together with literal text under the control of a template string.

     The library '(vicare formations)' is a distribution of the 'format'
     function written by Dirk Lutzebaeck (<lutzeb@cs.tu-berlin.de>),
     originally by Ken Dickey and Aubrey Jaffer, included in the Guile
     distribution and later adapted to R6RS Scheme by Marco Maggi.

* Menu:

* formations output::           Formatted output.
* formations escape generic::   Escape sequences for generic values.
* formations escape char::      Escape sequences for characters.
* formations escape case::      Escape sequences for case conversion.
* formations escape integers::  Escape sequences for integers.
* formations escape flonums::   Escape sequences for flonums.
* formations escape complex::   Escape sequences for complex numbers.
* formations escape args::      Escape sequences for special
                                arguments handling.
* formations escape lines::     Escape sequences for output lines.
* formations escape columns::   Escape sequences for columns
                                and indentation.
* formations escape misc::      Miscellaneous escape sequences.


File: vicare-libs.info,  Node: formations output,  Next: formations escape generic,  Up: formations

52.1 Formatted output
=====================

A format string is generally more compact and easier than using just the
standard procedures like 'display', 'write' and 'newline'.  Parameters
in the output string allow various output styles, and parameters can be
taken from the arguments for runtime flexibility.

   'format' is similar to the Common Lisp procedure of the same name,
but it's not identical and doesn't have quite all the features found in
Common Lisp(1).

   C programmers will note the similarity between 'format' and
'printf()', though escape sequences are marked with '~' instead of '%',
and are more powerful.

 -- Function: format TEMPLATE-STRING
 -- Function: format TEMPLATE-STRING ARGS ...
 -- Function: format DEST TEMPLATE-STRING
 -- Function: format DEST TEMPLATE-STRING ARG ...
     Write output specified by the TEMPLATE-STRING string to DEST;
     assume that the zero-based starting column number is the one
     specified by the parameter 'format-output-column'.

     DEST can be:

        * An output port.

        * '#t' for 'current-output-port'.

        * A number for 'current-error-port'.

        * '#f' to return the output as a string.

     If DEST is not given (that is: the first argument is a string): the
     output is returned as if '#f' is used as DEST argument.

     TEMPLATE-STRING can contain literal text to be output, and '~'
     escapes.  Each escape has the form:

          ~ [PARAM [, PARAM ...] [:] [@] CODE

     CODE is a character determining the escape sequence; the CODE
     letters are *not* case-sensitive, upper and lower case are the
     same.  The ':' and '@' characters are optional modifiers, one or
     both of which change the way various codes operate.  Optional
     parameters are accepted by some codes too.  Parameters have the
     following forms:

     '[+/-]number'
          An integer, with optional '+' or '-' sign in front of it.

     '''
          The quote.  The following character in the format string, for
          instance ''z' for 'z'.

     'v'
          The next function argument as the parameter.  'v' stands for
          "variable", a parameter can be calculated at runtime and
          included in the arguments.  Upper case 'V' can be used too.

     '#'
          The number of arguments remaining.

     Parameters are separated by commas (',').  A parameter can be left
     empty to keep its default value when supplying later parameters.

     It's an error if there are not enough arguments for the escapes in
     the format string, but any excess arguments are ignored.

 -- Parameter: format-output-column
     The zero-based starting column number for the next invocations of
     'format'.  The value is initialised to 0 and must be a non-negative
     fixnum.

   Iterations '~{' '~}' and conditionals '~[' '~;' '~]' can be nested,
but must be properly nested, meaning the inner form must be entirely
within the outer form.  So it's not possible, for instance, to try to
conditionalize the endpoint of an iteration.

     (format "~{ ~[ ... ~] ~}" ...)       ;; good
     (format "~{ ~[ ... ~} ... ~]" ...)   ;; bad

   The same applies to case conversions '~(' '~)', they must properly
nest with respect to iterations and conditionals (though currently a
case conversion cannot nest within another case conversion).

   When a sub-format ('~?') is used, that sub-format string must be
self-contained.  It cannot for instance give a '~{' to begin an
iteration form and have the '~}' up in the originating format, or
similar.

   ---------- Footnotes ----------

   (1) For the original Common Lisp specification see (URL last verified
Sep 16, 2013):
<http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html>


File: vicare-libs.info,  Node: formations escape generic,  Next: formations escape char,  Prev: formations output,  Up: formations

52.2 Escape sequences for generic values
========================================

 -- Format Escape Sequence: ~a
 -- Format Escape Sequence: ~s
     Object output.  Parameters: MINWIDTH, PADINC, MINPAD, PADCHAR.

     '~a' outputs an argument like 'display', '~s' outputs an argument
     like 'write'.

          (format #t "~a" "foo") -| foo
          (format #t "~s" "foo") -| "foo"

     '~:a' and '~:s' put objects that don't have an external
     representation in quotes like a string.

          (format #t "~:a" car) -| "#<primitive-procedure car>"

     If the output is less than MINWIDTH characters (default 0), it's
     padded on the right with PADCHAR (default space).  '~@a' and '~@s'
     put the padding on the left instead.

          (format #f "~5a" 'abc)       => "abc  "
          (format #f "~5,,,'-@a" 'abc) => "--abc"

     The number of padding characters, PADCHAR, included in the output
     is computed with: MINPAD + N * PADINC, where N is the smallest
     integer making the total object plus padding greater than or equal
     to MINWIDTH.  The default MINPAD is 0 and the default PADINC is 1
     (imposing no minimum or multiple).

          (format #f "~5,1,4a" 'abc) => "abc    "

   More examples:

     (import (except (vicare) format)
       (vicare formations))

     (format #f "ciao ~:a" display)
     => "ciao \"#<procedure display>\""

     (format "~5a" 123)              => "123  "
     (format "~5s" 123)              => "123  "

     (format "~5@a" 123)            => "  123"
     (format "~5@s" 123)            => "  123"

     (format "~5,,,'.a" 123)         => "123.."
     (format "~5,,,'.s" 123)         => "123.."

     (format "~5,,,'.@a" 123)       => "..123"
     (format "~5,,,'.@s" 123)       => "..123"

     (format "~5,,4,'.@a" 123)      => "....123"
     (format "~5,,4,'.@s" 123)      => "....123"
     ;;;                                1234

     (format "~10,,,'a@a" 123)      => "aaaaaaa123"
     (format "~10,,,'a@s" 123)      => "aaaaaaa123"
     ;;;                                1234567

     (format "~10,3,,'u@a" 123)     => "uuuuuuuuu123"
     (format "~10,3,,'u@s" 123)     => "uuuuuuuuu123"
     ;;;                                123456789

     (format "~11,2,,'u@a" 123)     => "uuuuuuuu123"
     (format "~11,2,,'u@s" 123)     => "uuuuuuuu123"
     ;;;                                12345678

     (format "~8,2,,'u@a" 1)        => "uuuuuuuu1"
     (format "~8,2,,'u@s" 1)        => "uuuuuuuu1"
     ;;;                                12345678


File: vicare-libs.info,  Node: formations escape char,  Next: formations escape case,  Prev: formations escape generic,  Up: formations

52.3 Escape sequences for characters
====================================

 -- Format Escape Sequence: ~c
     Character.  Parameter: CHARNUM.

     Output a character.  The default is to simply output, as per
     'write-char'.  '~@c' prints in 'write' style.  '~:c' prints control
     characters (ASCII 0 to 31) in '^X' form.

          (format #t "~c" #\z)        -| z
          (format #t "~@c" #\z)       -| #\z
          (format #t "~:c" #\newline) -| ^J

     If the CHARNUM parameter is given then an argument is not taken but
     instead the character is '(integer->char CHARNUM)'.  This can be
     used for instance to output characters given by their Unicode code.

          (format #t "~65c")  -| A


File: vicare-libs.info,  Node: formations escape case,  Next: formations escape integers,  Prev: formations escape char,  Up: formations

52.4 Escape sequences for case conversion
=========================================

 -- Format Escape Sequence: ~( ~)
     Case conversion.  No parameters.

     Between '~(' and '~)' the case of all output is changed.  The
     modifiers on '~(' control the conversion.

     '~('
          Lower case using 'string-downcase'.

     '~:('
          Title case using 'string-titlecase'.

     '~@('
          Fold case using 'string-foldcase'.  *NOTE* Currently broken.

     '~:@('
          Upper case using 'string-upcase'.

     For example:

          (format #t "~(Hello~)")   -| hello
          (format #t "~:@(Hello~)") -| HELLO

     Case conversions do not nest, currently (an exception is raised).
     This might change in the future, but if it does then it will be to
     Common Lisp style where the outermost conversion has priority,
     overriding inner ones (making those fairly pointless).


File: vicare-libs.info,  Node: formations escape integers,  Next: formations escape flonums,  Prev: formations escape case,  Up: formations

52.5 Escape sequences for integers
==================================

 -- Format Escape Sequence: ~d
 -- Format Escape Sequence: ~x
 -- Format Escape Sequence: ~o
 -- Format Escape Sequence: ~b
     Integer.  Parameters: MINWIDTH, PADCHAR, COMMACHAR, COMMAWIDTH.

     Output an integer argument as a decimal, hexadecimal, octal or
     binary integer (respectively).

          (format #t "~d" 123) -| 123

     If the output is less than the MINWIDTH parameter (default no
     minimum), it's padded on the left with the PADCHAR parameter
     (default space).

          (format #t "~5,'*d" 12)   -| ***12
          (format #t "~5,'0d" 12)   -| 00012
          (format #t "~3d"    1234) -| 1234

     The '@' modifier causes a '+' sign to be prepended to positive
     numbers, zero included.

          (format #t "~@b" 12) -| +1100
          (format #t "~@d" 0)  -| +0

     The ':' modifier adds a COMMACHAR (default comma) every COMMAWIDTH
     digits (default 3).

          (format #t "~:d" 1234567)         -| 1,234,567
          (format #t "~10,'*,'/,2:d" 12345) -| ***1/23/45

     Hexadecimal '~x' output is in lower case, but the '~(' and '~)'
     case conversion directives described elsewhere can be used to get
     upper case.

          (format #t "~x"       65261) -| feed
          (format #t "~:@(~x~)" 65261) -| FEED

 -- Format Escape Sequence: ~r
     Integer in words, roman numerals, or a specified radix.
     Parameters: RADIX, MINWIDTH, PADCHAR, COMMACHAR, COMMAWIDTH.

     With no parameters output is in words as a cardinal like "ten", or
     '~:r' prints an ordinal like "tenth".

          (format #t "~r" 9)  -| nine        ;; cardinal
          (format #t "~r" -9) -| minus nine  ;; cardinal
          (format #t "~:r" 9) -| ninth       ;; ordinal

     And also with no parameters, '~@r' gives roman numerals and '~:@r'
     gives old roman numerals.  In old roman numerals there's no
     "subtraction", so 9 is 'VIIII' instead of 'IX'.  In both cases only
     positive numbers can be output.

          (format #t "~@r" 89)  -| LXXXIX     ;; roman
          (format #t "~:@r" 89) -| LXXXVIIII  ;; old roman

     When a parameter is given it means numeric output in the specified
     RADIX (which can be any integer, *not* only 2, 8, 10 or 16).  The
     modifiers and parameters following the radix are the same as
     described for '~d' above.

          (format #f "~3r" 27)   => "1000"    ;; base 3
          (format #f "~3,5r" 26) => "  222"   ;; base 3 width 5


File: vicare-libs.info,  Node: formations escape flonums,  Next: formations escape complex,  Prev: formations escape integers,  Up: formations

52.6 Escape sequences for flonums
=================================

 -- Format Escape Sequence: ~f
     Real fixed-point float.  Parameters: WIDTH, DECIMALS, SCALE,
     OVERFLOWCHAR, PADCHAR.

     Output a number or number string in fixed-point format, ie. with a
     decimal point.

          (format #t "~f" 5)              -| 5.0
          (format #t "~f" 1e-1)           -| 0.1
          (format #t "~f" "123")          -| 123.0
          (format #t "~f" "#d123")        -| 123.0
          (format #t "~f" "#d-1e-1")      -| -0.1

     '~@f' prints a '+' sign on positive numbers (including zero).

          (format #t "~@f" 0) -| +0.0

     If the output is less than WIDTH characters (default is no limit
     and no padding) it's padded on the left with PADCHAR (space by
     default).  If the output equals or exceeds WIDTH then there's no
     padding and the decimals after the comma are truncated if this
     makes the number fit the WIDTH.

          (format "~6f" -1.5)                     => "  -1.5"
          (format "~6,,,,'*f" 23)                 => "**23.0"
          (format "~6f" 1234567.0)                => "1234567.0"
          (format "~10,,,,'.f" 123.456789123)     => "123.456789"
          (format "~5,,,,'.f" 1e9)                => "1000000000.0"
          (format "~5,,,,'.f" 1000000000.123456)  => "1000000000.123456"

     DECIMALS is how many digits to print after the decimal point, with
     the value rounded or padded with zeros as necessary.  (The default
     is to output as many decimals as required.)

          (format #t "~1,2f" 3.125) -| 3.13
          (format #t "~1,2f" 1.5)   -| 1.50

     Decimals are rounded only when requested.  If not requested they
     are not rounded nor truncated when the output exceeds the requested
     WIDTH.

          (format #t "~1f"   0.123) -| "0.123")
          (format #t "~1,2f" 0.123) -| ".12")

     SCALE is a power of 10 applied to the value, moving the decimal
     point that many places.  A positive SCALE increases the value
     shown, a negative decreases it.

          (format #t "~,,2f" 1234)  -| 123400.0
          (format #t "~,,-2f" 1234) -| 12.34

     If OVERFLOWCHAR and WIDTH are both given and if the output would
     exceed WIDTH, then that many OVERFLOWCHARs are printed instead of
     the value.

          (format #t "~5,,,'xf" 12345) -| 12345
          (format #t "~4,,,'xf" 12345) -| xxxx

 -- Format Escape Sequence: ~e
     Real exponential float.  Parameters: WIDTH, DECIMALS, EXPDIGITS,
     INTDIGITS, OVERFLOWCHAR, PADCHAR, EXPCHAR.

     Output a number or number string in exponential notation.

          (format #t "~e" 5000.25) -| 5.00025E+3
          (format #t "~e" "123.4") -| 1.234E+2
          (format #t "~e" "1e4")   -| 1.0E+4

     '~@e' prints a '+' sign on positive numbers (including zero).
     (This is for the mantissa, a '+' or '-' sign is always shown on the
     exponent.)

          (format #t "~@e" 5000.0) -| +5.0E+3

     If the output is less than WIDTH characters it's padded on the left
     with PADCHAR (space by default).  The default for WIDTH is to
     output with no padding.

          (format #f "~10e" 1234.0)       => "  1.234E+3"
          (format #f "~10,,,,,'*e" 0.5)   => "****5.0E-1"

     If the output is more than WIDTH characters: decimals in the
     exponential representation are rounded to make the output fit the
     WIDTH; if rounding does not make the output fit, the full output
     without rounding is printed.  When DECIMALS is specified: no
     rounding is done to remove those decimals, even if the output
     exceeds the WIDTH.

          ;; here rounding succeeds in making the output fit
          (format #f "~5e" 123456)        => "1.E+5"

          ;; here rounding fails in making the output fit
          (format #f "~2e" 123456)        => "1.23456E+5"

          ;; here DECIMALS causes the output to overflow
          (format "~6,3e" 123.3456)       => "1.233E+2"

     DECIMALS is the number of digits shown in the mantissa after the
     decimal point.  The value is rounded or trailing zeros are added as
     necessary.  The default DECIMALS is to show as much as needed by
     the value.

          (format #f "~,3e" 11111.0) => "1.111E+4"
          (format #f "~,8e" 123.0)   => "1.23000000E+2"

     EXPDIGITS is the minimum number of digits shown for the exponent,
     with leading zeros added if necessary.  The default for EXPDIGITS
     is to show only as many digits as required.  At least 1 digit is
     always shown.

          (format #f "~,,1e" 1.0e99) => "1.0E+99"
          (format #f "~,,6e" 1.0e99) => "1.0E+000099"

     INTDIGITS (default 1) is the number of digits to show before the
     decimal point in the mantissa.  INTDIGITS can be zero, in which
     case the integer part is a single '0', or it can be negative, in
     which case leading zeros are shown after the decimal point.

          (format #t "~,,,3e" 12345.0)  -| 123.45E+2
          (format #t "~,,,0e" 12345.0)  -| 0.12345E+5
          (format #t "~,,,-3e" 12345.0) -| 0.00012345E+8

     If OVERFLOWCHAR is given then WIDTH is a hard limit.  If the output
     would exceed WIDTH then instead that many OVERFLOWCHARs are
     printed.

          (format #f "~6,,,,'xe" 100.0) => "1.0E+2"
          (format #f "~3,,,,'xe" 100.0) => "xxx"

     EXPCHAR is the exponent marker character (default 'E').

          (format #t "~,,,,,,'ee" 100.0) -| 1.0e+2


File: vicare-libs.info,  Node: formations escape complex,  Next: formations escape args,  Prev: formations escape flonums,  Up: formations

52.7 Escape sequences for complex numbers
=========================================

 -- Format Escape Sequence: ~i
     Complex fixed-point float.  Parameters: WIDTH, DECIMALS, SCALE,
     OVERFLOWCHAR, PADCHAR.

     Output the argument as a complex number, with both real and
     imaginary part shown (even if one or both are zero).

     The parameters and modifiers are the same as for fixed-point '~f'
     described above.  The real and imaginary parts are both output with
     the same given parameters and modifiers, except that for the
     imaginary part the '@' modifier is always enabled, so as to print a
     '+' sign between the real and imaginary parts.

          (format #t "~i" 1)  -| 1.0+0.0i

     Notice that the imaginary unit character 'i' is excluded from the
     counting for width and padding.


File: vicare-libs.info,  Node: formations escape args,  Next: formations escape lines,  Prev: formations escape complex,  Up: formations

52.8 Escape sequences for special arguments handling
====================================================

 -- Format Escape Sequence: ~?
 -- Format Escape Sequence: ~k
     Sub-format.  No parameters.

     Take a format string argument and a second argument which is a list
     of arguments for that string, and output the result.

          (format #t "~?" "~d ~d" '(1 2))    -| 1 2

     '~@?' takes arguments for the sub-format directly rather than in a
     list.

          (format #t "~@? ~s" "~d ~d" 1 2 "foo") -| 1 2 "foo"

     '~?' and '~k' are the same, '~k' is provided for T-Scheme
     compatibility.

 -- Format Escape Sequence: ~*
     Argument jumping.  Parameter: N.

     Move forward N arguments (default 1) in the argument list.  '~:*'
     moves backwards.  (N cannot be negative.)

          (format #f "~d ~2*~d" 1 2 3 4) => "1 4"
          (format #f "~d ~:*~d" 6)       => "6 6"

     '~@*' moves to argument number N.  The first argument is number 0
     (and that's the default for N).

          (format #f "~d~d again ~@*~d~d" 1 2) => "12 again 12"
          (format #f "~d~d~d ~1@*~d~d" 1 2 3)  => "123 23"

     A '#' moves to the end; when followed by a ':' modifier it can be
     used to select an absolute position relative to the end of the
     argument list, a reverse of what the '@' modifier does.

          (format #t "~#*~2:*~a" 'a 'b 'c 'd)   -| c

     At the end of the format string the current argument postion does
     not matter, any further arguments are ignored.

 -- Format Escape Sequence: ~{ ~}
     Iteration.  Parameter: MAXREPS (for '~{').

     The format between '~{' and '~}' is iterated.  The modifiers to
     '~{' determine how arguments are taken.  The default is a list
     argument with each iteration successively consuming elements from
     it.  This is a convenient way to output a whole list.

          (format "~{~d~}" '(1 2 3))
          => "123"

          (format "~{~s=~d ~}" '("x" 1 "y" 2))
          => "\"x\"=1 \"y\"=2 "

     '~:{' takes a single argument which is a list of lists, each of
     those contained lists gives the arguments for the iterated format.

          (format "~:{~dx~d ~}" '((1 2) (3 4) (5 6)))
          => "1x2 3x4 5x6 "

     '~@{' takes arguments directly, with each iteration successively
     consuming arguments.

          (format "~@{~d~}" 1 2 3)
          => "123"

          (format "~@{~s=~d ~}" "x" 1 "y" 2)
          => "\"x\"=1 \"y\"=2 "

     '~:@{' takes list arguments, one argument for each iteration, using
     that list for the format.

          (format "~:@{~dx~d ~}" '(1 2) '(3 4) '(5 6))
          => "1x2 3x4 5x6 "

     Iterating stops when there are no more arguments or when the
     MAXREPS parameter to '~{' is reached (default no maximum).

          (format "~2{~d~}" '(1 2 3 4))
          => 12

     If the format between '~{' and '~}' is empty, then a format string
     argument is taken (before iteration argument(s)) and used instead.
     This allows a sub-format (like '~?' above) to be iterated.

          (format "~{~}" "~d" '(1 2 3))
          => 123

     Iterations can be nested, an inner iteration operates in the same
     way as described, but of course on the arguments the outer
     iteration provides it; this can be used to work into nested list
     structures.  For example in the following the inner '~{~d~}x' is
     applied to '(1 2)' then '(3 4 5)' etc.

          (format "~{~{~d~}x~}" '((1 2) (3 4 5)))
          => "12x345x"

     See also '~^' below for escaping from iteration.

 -- Format Escape Sequence: ~[ ~; ~]
     Conditional.  Parameter: SELECTOR.

     A conditional block is delimited by '~[' and '~]', and '~;'
     separates clauses within the block.  '~[' takes an integer argument
     and that number clause is used.  The first clause is number '0'.

          (format "~[peach~;banana~;mango~]" 0)   => "peach"
          (format "~[peach~;banana~;mango~]" 1)   => "banana"
          (format "~[peach~;banana~;mango~]" 2)   => "mango"

     The SELECTOR parameter can be used for the clause number, instead
     of taking an argument.

          (format "~0[peach~;banana~;mango~]")    => "peach"
          (format "~1[peach~;banana~;mango~]")    => "banana"
          (format "~2[peach~;banana~;mango~]")    => "mango"

     If the clause number is out of range then nothing is output.  Or
     the last clause can be '~:;' to use that for a number out of range.

          (format "~[banana~;mango~]"         99) => ""
          (format "~[banana~;mango~:;fruit~]" 99) => "fruit"

     '~:[' treats the argument as a flag, and expects two clauses.  The
     first is used if the argument is '#f' or the second otherwise.

          (format "~:[false~;not false~]" #f)   => "false"
          (format "~:[false~;not false~]" 'abc) => "not false"

          (let ((n 3))
            (format "~d gnu~:[s are~; is~] here" n (= 1 n)))
          => "3 gnus are here"

     '~@[' also treats the argument as a flag, and expects one clause.
     If the argument is '#f' then no output is produced and the argument
     is consumed, otherwise the clause is used and the argument is not
     consumed, it's left for the clause.  This can be used for instance
     to suppress output if '#f' means something not available.

          (format "~@[temperature=~d~]" 27) => "temperature=27"
          (format "~@[temperature=~d~]" #f) => ""

 -- Format Escape Sequence: ~^
     Escape.  Parameters: VAL1, VAL2, VAL3.

     Stop formatting if there are no more arguments.  This can be used
     for instance to have a format string adapt to a variable number of
     arguments.

          (format "~d~^ ~d" 1)            => "1"
          (format "~d~^ ~d" 1 2)          => "1 2"

     Within a '~{' '~}' iteration, '~^' stops the current iteration step
     if there are no more arguments to that step, but continuing with
     possible further steps and the rest of the format.  This can be
     used for instance to avoid a separator on the last iteration, or to
     adapt to variable length argument lists.

          (format "~{~d~^/~} go"    '(1 2 3))
          => "1/2/3 go"

          (format "~:{ ~d~^~d~} go" '((1) (2 3)))
          => " 1 23 go"

     Within a '~?' sub-format, '~^' operates just on that sub-format.
     If it terminates the sub-format then the originating format will
     still continue.

          (format "~? items" "~d~^ ~d" '(1))
          => "1 items"

          (format "~? items" "~d~^ ~d" '(1 2))
          => "1 2 items"

     The parameters to '~^' (which are numbers) change the condition
     used to terminate.  For a single parameter, termination is when
     that value is zero (notice this makes plain '~^' equivalent to
     '~#^').  For two parameters, termination is when those two are
     equal.  For three parameters, termination is when VAL1 <= VAL2 and
     VAL2 <= VAL3.


File: vicare-libs.info,  Node: formations escape lines,  Next: formations escape columns,  Prev: formations escape args,  Up: formations

52.9 Escape sequences for output lines
======================================

 -- Format Escape Sequence: ~%
     Newline.  Parameter: N.

     Without modifiers: output a newline character, or N many if a
     parameter is given.  A newline (or a few newlines) can of course be
     output just by including them in the format string as '"\n"'.

          (format "A~%Z")         => "A\nZ"
          (format "A~3%Z")        => "A\n\n\nZ"

     '~:%' outputs line endings as carriage returns followed by
     newlines, as in '"\r\n"'.

          (format "A~:%Z")        => "A\r\nZ"
          (format "A~3:%Z")       => "A\r\n\r\n\r\nZ"

 -- Format Escape Sequence: ~&
     Start a new line.  Parameter: N.

     Output a newline if not already at the start of a line.  With a
     parameter, output that many newlines, but with the *first* only if
     not already at the start of a line.

          (format "A~&Z")         => "A\nZ"
          (format "A~3&Z")        => "A\n\n\nZ"

          ;; at the start of a line
          (format "~&Z")          => "Z"
          (format "~3&Z")         => "\n\nZ"

 -- Format Escape Sequence: ~|
     Formfeed character.  Parameter: N.

     Output a formfeed character, or N feeds if a parameter is given.

          (format "A~|Z")         => "A\fZ"
          (format "A~3|Z")        => "A\f\f\fZ"

 -- Format Escape Sequence: ~\n
     Continuation line.  No parameters.

     Skip this newline and any following whitespace in the format
     string, i.e. don't send it to the output.  This can be used to
     break up a long format string for readability, but not print the
     extra whitespace.

          (format "abc~
                   ~d def~
                   ~d" 1 2)               => "abc1 def2"

          (format "abc~\ndef~\nghi")      => "abcdefghi"

     '~:\n' skips the newline but leaves any further whitespace to be
     printed normally.

          (format "abc~:\n def~:\n ghi")  => "abc def ghi"

     '~@\n' prints the newline then skips following whitespace.

          (format "abc~@\n def~@\n ghi")  => "abc\ndef\nghi"


File: vicare-libs.info,  Node: formations escape columns,  Next: formations escape misc,  Prev: formations escape lines,  Up: formations

52.10 Escape sequences for columns and indentation
==================================================

 -- Format Escape Sequence: ~y
     Pretty print.  No parameters.

     Output an argument with 'pretty-print'.

 -- Format Escape Sequence: ~_
     Space character.  Parameter: N.

     Output a space character, or N spaces if a parameter is given.

     With a variable parameter this is one way to insert runtime
     calculated padding ('~t' or the various field widths can do similar
     things).

          (format "~_foo" 4)      => " foo"
          (format "~3_foo" 4)     => "   foo"

 -- Format Escape Sequence: ~t
     Advance to a column position.  Parameters: COLNUM, COLINC, PADCHAR.

     Output PADCHAR (space by default) to move to the given COLNUM
     column.  The start of the line is column 0, the default for COLNUM
     is 1.

          (format "~tX")          => " X"
          (format "~0tX")         => "X"
          (format "~1tX")         => " X"
          (format "~2tX")         => "  X"
          (format "~3tX")         => "   X"

          (format "~,,'.tX")      => ".X"
          (format "~0,,'.tX")     => "X"
          (format "~1,,'.tX")     => ".X"
          (format "~2,,'.tX")     => "..X"
          (format "~3,,'.tX")     => "...X"

     If the current column is already past COLNUM, then the move is to
     column 'COLNUM + N * COLINC' for the smallest N which makes that
     value greater than or equal to the current column.  The default
     COLINC is 1 (which means no further move).  In the following
     examples '~t' is found when the next character should be output at
     column 4:

          ;; COLNUM + N * COLINC = 0+N*5 = 0+1*5 = 5
          (format "abcd~0,5,'.tX")        => "abcd.X"
          ;;;                                 0123456789

          ;; COLNUM + N * COLINC = 1+N*5 = 1+1*5 = 6
          (format "abcd~1,5,'.tX")        => "abcd..X"
          ;;;                                 0123456789

          ;; COLNUM + N * COLINC = 2+N*5 = 2+1*5 = 7
          (format "abcd~2,5,'.tX")        => "abcd...X"
          ;;;                                 0123456789

          ;; COLNUM + N * COLINC = 3+N*5 = 3+1*5 = 8
          (format "abcd~3,5,'.tX")        => "abcd....X"
          ;;;                                 0123456789

     '~@t' takes COLNUM as an offset from the current column.  COLNUM
     pad characters are output, then further padding to make the current
     column a multiple of COLINC, if it isn't already so.

          (format #f "a~3,5'*@tx") => "a****x"

 -- Format Escape Sequence: ~/
     Tab character.  Parameter: N.

     Output a tab character, or N tabs if a parameter is given.

          (format "A~/Z")         => "A\tZ"
          (format "A~3/Z")        => "A\t\t\tZ"


File: vicare-libs.info,  Node: formations escape misc,  Prev: formations escape columns,  Up: formations

52.11 Miscellaneous escape sequences
====================================

 -- Format Escape Sequence: ~p
     Plural.  No parameters.

     Output nothing if the argument is 1, or 's' for any other value.

          (format #t "enter name~p" 1) -| enter name
          (format #t "enter name~p" 2) -| enter names

     '~@p' prints 'y' for 1 or 'ies' otherwise.

          (format #t "pupp~@p" 1) -| puppy
          (format #t "pupp~@p" 2) -| puppies

     '~:p' re-uses the preceding argument instead of taking a new one,
     which can be convenient when printing some sort of count.

          (format #t "~d cat~:p" 9)   -| 9 cats
          (format #t "~d pupp~:@p" 5) -| 5 puppies

     '~p' is designed for English plurals and there's no attempt to
     support other languages.  '~[' conditionals (below) may be able to
     help.

 -- Format Escape Sequence: ~~
     Tilde character.  Parameter: N.

     Output a tilde character '~', or N many if a parameter is given.
     Normally '~' introduces an escape sequence, '~~' is the way to
     output a literal tilde.

          (format "A~~Z")         => "A~Z"
          (format "A~3~Z")        => "A~~~Z"

 -- Format Escape Sequence: ~!
     Force output.  No parameters.

     At the end of output, call 'flush-output-port' to flush any buffers
     on the destination.  '~!' can occur anywhere in the format string,
     but the force is done at the end of output.

     When output is to a string: '~!' does nothing.


File: vicare-libs.info,  Node: silex,  Next: parser-tools,  Prev: formations,  Up: Top

53 A lexical analyser generator
*******************************

The library '(vicare parser-tools silex)' generates a lexical analyser
table from a Lex-like specification file.  The library '(vicare
parser-tools silex lexer)' generates a Scheme lexical analyser using a
supplied table.  It is suggested to import these libraries with the
'lex.' prefix, as in:

     (import (vicare)
       (prefix (vicare parser-tools silex)       lex.)
       (prefix (vicare parser-tools silex lexer) lex.))

     "SILex" stands for "Scheme Implementation of Lex".  The library is
     a port to R6RS Scheme of SILex version 1.0 by Danny Dube'.  The
     original code is available at (URL last verified Oct 8, 2013):

                 <http://www.iro.umontreal.ca/~dube/>

   The library '(vicare parser-tools silex utilities)' implements
convenience facilities to use SILex.  It is suggested to use SILex with
the facilities of the libraries in the hierarchy '(nausicaa parser-tools
---)'.

* Menu:

* silex example::               A lexer example for a calculator.
* silex tables::                Creating lexer tables.
* silex input::                 Input systems.
* silex lexer::                 Building and using lexical analysers.
* silex syntax::                Syntax of the specification.
* silex semantics::             Semantics of the specification file.
* silex format::                Tables output format.
* silex utilities::             Utility functions.


File: vicare-libs.info,  Node: silex example,  Next: silex tables,  Up: silex

53.1 A lexer example for a calculator
=====================================

The following is a lexer specification file that can be used to tokenise
a mathematical expression.

     blanks          [ \9\10\13]+

     decint          [0-9]+
     binint          #[bB][01]+
     octint          #[oO][0-7]+
     hexint          #[xX][0-9A-Fa-f]+
     integer         {decint}|{binint}|{octint}|{hexint}

     exponent        ([eE][+\-]?[0-9]+)
     truereal        [0-9]+\.|[0-9]*\.[0-9]+{exponent}?|[0-9]+{exponent}
     real            {truereal}|{integer}

     imag            ({decint}|{real})i

     nan             \-nan\.0|\+nan\.0|nan\.0
     pinf            \+inf\.0|inf\.0
     minf            \-inf\.0

     initial         [a-zA-Z_]
     subsequent      {initial}|[0-9\.!$&:<=>?~\-]
     symbol          {initial}{subsequent}*

     operator        <=|>=|//|[\+\-*/%\^<>=]

     comma           ,

     oparen          \(
     cparen          \)

     %%
     {blanks}        ;; skip blanks, tabs and newlines
     {imag}          (string->number (string-append "+" yytext))
     {real}          (string->number yytext)
     {nan}           +nan.0
     {pinf}          +inf.0
     {minf}          -inf.0
     {operator}      (case (string->symbol yytext)
                         ((+) '+)
                         ((-) '-)
                         ((*) '*)
                         ((/) '/)
                         ((%) 'mod)
                         ((^) 'expt)
                         ((//) 'div)
                         ((=) '=)
                         ((<) '<)
                         ((>) '>)
                         ((<=) '<=)
                         ((>=) '>=))
     {symbol}        (string->symbol yytext)
     {comma}         'cons

     {oparen}        #\(
     {cparen}        #\)

     <<EOF>>         (eof-object)
     <<ERROR>>       (assertion-violation #f "invalid lexer token")

   Let's say the file is called 'calc.l', then the table for this lexer
can be created with one of the following forms (and other forms not
described here):

     (import (vicare)
       (prefix (vicare parser-tools silex)       lex.)
       (prefix (vicare parser-tools silex lexer) lex.))

     ;;Generate a proper Scheme library called "(calc)",
     ;;containing the table definition, and save it in the
     ;;file "calc-lib.sls".  Use the default table format.
     ;;The library exports the table bound to "calc-table".
     ;;
     (lex.lex (lex.input-file:   "calc.l")
              (lex.output-file:  "calc-lib.sls")
              (lex.library-spec: "(calc)")
              (lex.table-name:   'calc-table))

     ;;Generate a standalone DEFINE form that binds the
     ;;lexer table to the symbol "calc-table" and save it
     ;;in the file "calc-def.sls".  Use the Scheme code
     ;;table format.
     ;;
     (lex.lex (lex.input-file:   "calc.l")
              (lex.output-file:  "calc-def.sls")
              (lex.lexer-format: 'code)
              (lex.table-name:   'calc-table))

     ;;Generate the lexer table, evaluate it and return it
     ;;as value immediately usable.  Use the Scheme code
     ;;table format.
     ;;
     (define calc-table
       (lex.lex (lex.input-file:   "calc.l")
                (lex.output-value: #t)
                (lex.lexer-format: 'code)))

   Once we have created the lexer table, let's say bound to
'calc-table', we can use it as follows; we take advantage of the fact
that: when the input reaches the end, the lexer closure returns the
'(eof-object)' value.

     (define (tokenize table string)
       (let* ((IS    (lex.make-IS (lex.string: string)))
              (lexer (lex.make-lexer table IS))
         (do ((token (lexer) (lexer))
              (out   '()))
             ((eof-object? token)
              (reverse out))
           (set-cons! out token)))))

     (tokenize calc-table "1*(2/3)")
     => (1 * #\( 2 / 3 #\))

     (tokenize calc-table "fun(1+a, sin(2), 3, 4)")
     => (fun #\( 1 + a cons sin #\( 2 #\) cons 3 cons 4 #\))


File: vicare-libs.info,  Node: silex tables,  Next: silex input,  Prev: silex example,  Up: silex

53.2 Creating lexer tables
==========================

The following bindings are exported by the '(vicare parser-tools silex)'
library.

 -- Syntax: lex ?CLAUSE ...
     Build a new lexer table from a lexer specification, which can be:
     loaded from a file, read from a textual input port, acquired from a
     Scheme string; *note Syntax of the specification: silex syntax.

     The output is the lexer's "table", a Scheme vector representing the
     lexer automaton; it can be: saved to a file, written to a port,
     evaluated using the library '(rnrs eval (6))' and returned as
     value.

     The behaviour of this function is configured with the given ?CLAUSE
     arguments; see below for the list of supported options.

     The table's code must be evaluated in an environment with the
     following libraries:

          (rnrs)
          (vicare parser-tools silex input-system)
          (vicare system $fx)

 -- Auxiliary Syntax: input-string: ?SPEC-STR
     Instruct 'lex' to build the lexer tables from the specification in
     the given Scheme string.  This clause is mutually exclusive with
     'input-file:' and 'input-port:'.

 -- Auxiliary Syntax: input-port: ?PORT
     Instruct 'lex' to build the lexer tables from the specification
     read from the given textual input port.  This clause is mutually
     exclusive with 'input-string:' and 'input-file:'.

 -- Auxiliary Syntax: input-file: ?PATHNAME
     Instruct 'lex' to build the lexer tables from the specification in
     the selected file.  ?PATHNAME must be an expression evaluating to a
     string representing an existent file pathname.  This clause is
     mutually exclusive with 'input-string:' and 'input-port:'.

 -- Auxiliary Syntax: library-spec: ?LIBRARY-NAME
     Instruct 'lex' to build the output as a proper Scheme library.
     This means a Scheme string is built, representing a 'library' form.
     The string may contain Scheme comments.  When this clause is not
     used the output is the raw table vector or a 'define' form.

     The argument LIBRARY-NAME must represent a valid library name; the
     following formats are accepted:

        * A string, including the parentheses.  Example:

               (library-spec: "(calc-lexer)")
               ; -> (library (calc-lexer) ---)

        * A symbol, which will be converted to string and to which
          parentheses will be added.  Example:

               (library-spec: 'calc-lexer)
               ; -> (library (calc-lexer) ---)

        * A list of values, which will be simply converted to string.
          Example:

               (library-spec: '(calc-lexer))
               ; -> (library (calc-lexer) ---)

     It is mandatory to use the clause 'table-name:' along with
     'library-spec:'.

 -- Auxiliary Syntax: library-language: ?LANG
     Select ?LANG as language to use for the library; the language is
     the first import specification after 'import' in the 'library'
     form.  By default the language is '(rnrs)'.

 -- Auxiliary Syntax: library-imports: ?IMPORT-LIST
     Select a list of libraries which must be imported when using the
     generated lexer.  ?IMPORT-LIST must be a list of library
     specifications; for example, if we want to include the '(vicare
     language-extensions sentinels)' and '(vicare language-extensions
     variables)' libraries we do:

          (library-imports:
             '((vicare language-extensions sentinels)
               (vicare language-extensions variables)))

     If the lexer table is written to a proper Scheme library:
     ?IMPORT-LIST is added to the import specification of the generated
     library.  If the lexer table is directly evaluated: ?IMPORT-LIST is
     added to the environment which is handed to 'eval'.

     This clause is ignored when the selected output is neither a
     library, nor an evaluated form.

 -- Auxiliary Syntax: table-name: ?NAME
     Instruct 'lex' to output a 'define' form defining a binding between
     ?NAME and the table vector.  ?NAME can be a string or symbol, and
     it must represent a valid identifier.

     When this clause is used along with 'library-spec:', the 'library'
     form will export the identifier ?NAME.

 -- Auxiliary Syntax: output-value: #t
 -- Auxiliary Syntax: output-value: #f
     When the argument is '#t', instruct 'lex' to evaluate the vector
     table using the '(rnrs eval (6))' library and to return the result,
     which is then directly usable.

     The list of libraries selected by 'library-imports:' is added to
     the environment used for the evaluation.  By default, the
     environment always includes '(rnrs)', and also '(vicare
     parser-tools silex lexer)' when the selected lexer format is
     'code'.

     This clause is mutually exclusive with 'table-name:',
     'output-file:' and 'output-port:'.

 -- Auxiliary Syntax: output-port: ?PORT
     Instruct 'lex' to write the output as string in the given textual
     output port.

     This clause is mutually exclusive with 'output-value:' and
     'output-file:'.

 -- Auxiliary Syntax: output-file: ?PATHNAME
     Instruct 'lex' to save the output in a file with given pathname;
     this is especially useful when the output is a proper 'library' or
     'define' form.  ?PATHNAME must be an expression evaluating to a
     string representing the file pathname.

     This clause is mutually exclusive with 'output-value:' and
     'output-port:'.

 -- Auxiliary Syntax: lexer-format: ?FORMAT
     Instruct 'lex' about the format of the lexer table.  ?FORMAT can be
     one among the following symbols: 'decision-tree', 'code',
     'portable'; the default is 'decision-tree'.  *note Tables output
     format: silex format.

 -- Auxiliary Syntax: pretty-print: #t
 -- Auxiliary Syntax: pretty-print: #f
     Instruct 'lex' to pretty-print the contents of the table.
     Normally, the table is displayed as a compact mass of characters
     fitting in about 75 columns.  This clause is useful only for a
     developer of '(vicare parser-tools silex)'.  The Scheme code
     generated with the 'code' clause is always pretty-printed, the
     others are not by default.

 -- Auxiliary Syntax: counters: ?WHICH-ONES
     Instruct 'lex' about which counters will be available to the lexer;
     counters are managed by the input system, and can be used by the
     lexer.  The following values for ?WHICH-ONES are available:

     'all'
          Expect all the counters to be available from the input system:
          'yyline', 'yycolumn', 'yyoffset'.

     'line'
          Expect only the counter 'yyline' to be available from the
          input system.

     'none'
          Expect no counter to be available.

     'line' is the default.

     Notice that the same 'counters:' clause must be given to 'lex' and
     to 'make-IS', a mismatch will result in undefined behaviour.  This
     is because an input system is independent from a lexer table, and
     it is more efficient to build tables for a specific set of counters
     rather than to configure them at run time.


File: vicare-libs.info,  Node: silex input,  Next: silex lexer,  Prev: silex tables,  Up: silex

53.3 Input systems
==================

An "input system" provides the buffering, the line counting and similar
low level services.  The following bindings are exported by the library
'(vicare parser-tools silex input-system)' and reexported by the library
'(vicare parser-tools silex lexer)'.

 -- Syntax: make-IS ?CLAUSES ...
     Build and return a new input system.  The behaviour of this
     function is configured with the given ?CLAUSES; see below for the
     list of supported options.

     Input characters can come from a string, a port or the return value
     of a procedure.  When an input port is used by an input system, the
     program should avoid reading characters directly from the port.
     This is because the input system may have needed a look-ahead to do
     the analysis of the preceding token.  The program would not find
     what it expects on the port.  The input system provides safe
     functions to get characters from the input.

 -- Auxiliary Syntax: string: ?STRING
     Instruct 'make-IS' to build an input system that will take
     characters from the supplied string.  When the input system is
     initialized with a string, it takes a copy of it.  This way,
     eventual mutations of the string do not affect the analysis.

     This clause is mutually exclusive with 'port:' and 'procedure:'.

 -- Auxiliary Syntax: port: ?PORT
     Instruct 'make-IS' to build an input system that will read
     characters from the supplied textual input port.  The input system
     never closes itself the port it has received, this task is left to
     the program.

     This clause is mutually exclusive with 'string:' and 'procedure:'.

 -- Auxiliary Syntax: procedure: ?PROC
     Instruct 'make-IS' to build an input system that will read
     characters invoking the supplied procedure.

     The use of a function as character source allows the input system
     to parse any character stream, no matter how it is obtained.  For
     example, the characters may come from the decompression or
     decryption of a huge file, the task being done lazily in order to
     save space.

     The function must take no argument and return a character each time
     it is called.  When the end of file (or its logical equivalent) is
     reached, the function must return an object that is not a character
     (for example, the symbol 'eof').  After the function has returned
     an end of file indicator, it is not called again.

     This clause is mutually exclusive with 'string:' and 'port:'.

 -- Auxiliary Syntax: counters: ?WHICH-ONES
     Instruct 'make-IS' about which counters to make available to the
     lexer; counters are managed by the input system, and can be used by
     the lexer.  The following values for ?WHICH-ONES are available:

     'all'
          Make available all the counters: 'yyline', 'yycolumn',
          'yyoffset'.

     'line'
          Make avilable only the counter 'yyline'.  Accessing any of the
          bindings 'yycolumn', 'yyoffset' will raise an unbound
          identifier error.

     'none'
          Make available no counter.  Accessing any of the bindings:
          'yyline', 'yycolumn', 'yyoffset' will raise an unbound
          identifier error.

     'line' is the default.  The more counters the input system
     maintains, the more it is slowed down.

     Notice that the same 'counters:' option must be given to 'lex' and
     to 'make-IS', a mismatch will result in undefined behaviour.  This
     is because an input system is independent from a lexer table, and
     it is more efficient to build tables for a specific set of counters
     rather than to configure them at run time.

          (import (vicare)
            (prefix (vicare parser-tools silex)       lex.)
            (prefix (vicare parser-tools silex lexer) lex.))

          ;;Build table with no knowledge of the input system.
          ;;
          (define table
            (lex.lex (lex.input-string: "...")
                     (les.output-value: #t)
                     (lex.counters:     'line))) ;!!!

          ;;Build input system with no knowledge of the table.
          ;;
          (define IS
            (lex.make-IS (lex.string: "1+2+3")
                         (lex.counters: 'all)))  ;!!!

          ;;Build lexer using the table and the input system.
          ;;Error!!!
          ;;
          (define lexer
            (lex.make-lexer table IS))

 -- Function: lexer-input-system? OBJ
     Return '#t' if OBJ is an input system object, otherwise return
     '#f'.

 -- Function: lexer-get-func-line INPUT-SYSTEM
     Return a closure which, when invoked with no arguments, will return
     the current line number in INPUT-SYSTEM.

 -- Function: lexer-get-func-column INPUT-SYSTEM
     Return a closure which, when invoked with no arguments, will return
     the current column number in INPUT-SYSTEM.

 -- Function: lexer-get-func-offset INPUT-SYSTEM
     Return a closure which, when invoked with no arguments, will return
     the current offset in INPUT-SYSTEM.

 -- Function: lexer-get-func-getc INPUT-SYSTEM
     Return a closure which, when invoked with no arguments, will return
     the next character from INPUT-SYSTEM.  The closure allows client
     code to perform a lookahead.

     The returned character is not forgotten by the lexer, this function
     just increments by 1 a pointer into the internal buffer.  Multiple
     invocations of this function will return the sequence of characters
     about to be analysed by the lexer.  When there are no more
     characters, the return value is the EOF object.

     The returned characters are *skipped* by the lexer, unless we put
     them back with the closure returned by 'lexer-get-func-ungetc'.

 -- Function: lexer-get-func-ungetc INPUT-SYSTEM
     Return a closure which, when invoked with no arguments, will
     decrement a pointer into the buffer of INPUT-SYSTEM.  This function
     puts back a character previously read by a closure returned by
     'lexer-get-func-getc'.

     It is not possible to replace characters in the input system.


File: vicare-libs.info,  Node: silex lexer,  Next: silex syntax,  Prev: silex input,  Up: silex

53.4 Building and using lexical analysers
=========================================

Each lexer is associated to a lexer table and an input system.  Any
number of lexers, using any table, can be created using the same input
system.  Multiple lexers sharing the same input system can be invoked in
turn to parse complex inputs.

   For all the lexer makers: the INPUT-SYSTEM argument is the input
system from which the analyser will take its input; it is mandatory to
build the input system with the same 'counters:' specification of the
table handed to the maker.

Format agnostic lexer maker
...........................

The following bindings are exported from the library '(vicare
parser-tools silex lexer)'.

 -- Function: make-lexer LEXER-TABLE INPUT-SYSTEM
     Build and return a new lexical analyser: an analysis function
     which, when invoked with no arguments, returns the next token.

     LEXER-TABLE must be a table generated by 'lex', in any format.

Decision tree lexer maker
.........................

The following bindings are exported from the library '(vicare
parser-tools silex tree-lexer-driver)'.

 -- Function: make-tree-lexer LEXER-TABLE INPUT-SYSTEM
     Build and return a new lexical analyser: an analysis function
     which, when invoked with no arguments, returns the next token.

     LEXER-TABLE must be a table generated by 'lex' using the
     'decision-tree' format.

Portable tree lexer maker
.........................

The following bindings are exported from the library '(vicare
parser-tools silex char-lexer-driver)'.

 -- Function: make-char-lexer LEXER-TABLE INPUT-SYSTEM
     Build and return a new lexical analyser: an analysis function
     which, when invoked with no arguments, returns the next token.

     LEXER-TABLE must be a table generated by 'lex' using the 'portable'
     format.

Scheme code lexer maker
.......................

The following bindings are exported from the library '(vicare
parser-tools silex code-lexer-driver)'.

 -- Function: make-code-lexer LEXER-TABLE INPUT-SYSTEM
     Build and return a new lexical analyser: an analysis function
     which, when invoked with no arguments, returns the next token.

     LEXER-TABLE must be a table generated by 'lex' using the 'code'
     format.


File: vicare-libs.info,  Node: silex syntax,  Next: silex semantics,  Prev: silex lexer,  Up: silex

53.5 Syntax of the specification
================================

A specification for a lexical analyser contains two parts: the "macro
definitions part", or "header", and the "rules part".  The two parts are
separated by the mark '%%'.  Example:

     blanks          [ \9\10\13]+
     decint          [0-9]+

     %%

     {blanks}        ;; skip blanks, tabs and newlines
     {decint}        (string->number yytext)

   The first part is used to define "macros"; that is, to give names to
some regular expressions.  The second part is used to indicate the
regular expressions with which the input will have to match, and the
"actions" associated with each expression.

   Comments can be inserted any place where white space is allowed and
is considered as white space itself.  Line comments begin with a
semicolon ';' and extend up to the end of a line; the semicolon is a
valid token in many languages, so we should take care not to comment out
an entire line when writing a regular expression matching a semicolon.
Nested comments begin with a '#|' sequence and extend up to the
corresponding '|#' sequence.

* Menu:

* silex syntax macros::         Syntax of the macro definitions.
* silex syntax includes::       Including macro files.
* silex syntax rules::          Syntax of the rule-action pairs.
* silex syntax regexp atomic::  Atomic regular expressions.
* silex syntax regexp compose:: Composing regular expressions.
* silex syntax regexp marker::  Markers.
* silex syntax regexp space::   White spaces in regular expressions.
* silex syntax sample::         Show some frequent mistakes.


File: vicare-libs.info,  Node: silex syntax macros,  Next: silex syntax includes,  Up: silex syntax

53.5.1 Macro definitions part
-----------------------------

The first part of a specification contains zero or more macro
definitions.  A definition consists of a name and a regular expression,
separated by white spaces (meaning: horizontal blank characters,
vertical blank characters like newlines and comments).  It looks better
when each definition is written on a separate line.

   The syntax for a macro name is that of an R6RS symbol.  For example,
'abcd', '+', '...', 'Digit' and 'digit' are all valid macro names; the
last two being different.  It is an error to write two macro definitions
with the same name, unless they have equal regexp specification.

   The defined macros can be referenced in regular expressions using the
syntax '{NAME}'.  The scope of a macro definition includes the remaining
definitions and the rules part; it is analogous to 'let*' in Scheme,
where the macro definitions correspond to the bindings and the rules
part corresponds to the body.

   We end the macro definitions part with '%%'.


File: vicare-libs.info,  Node: silex syntax includes,  Next: silex syntax rules,  Prev: silex syntax macros,  Up: silex syntax

53.5.2 Including macro files
----------------------------

The special syntax:

     %[PATHNAME]

can be used to include a macro definition file whose pathname is
PATHNAME, which can be any string not including the ']' character; the
PATHNAME is handled as follows:

  1. If PATHNAME is absolute, test its existence: when found, convert it
     to a string representing the real, absolute file pathname.

  2. If PATHNAME is relative and it has a directory part, test its
     existence from the current process working directory: when found,
     convert it to a string representing the real, absolute file
     pathname.

  3. If PATHNAME is relative and it has no directory part, read the
     system environment variable 'SILEX_PATH' as colon-separated list of
     directories and search the file in them, from the first to the
     last: when found, convert it to a string representing the real,
     absolute file pathname.

     Notice that the file is searched in the process' current working
     directory only if such directory is listed in the given path.

the result of converting ?PATHNAME to a real, absolute pathname is
handed as is to 'open-input-file'.  If the file is not found: an
exception is raised.

   Two macros with the same name are allowed if they have the same
regexp specification, this allows an include file to be loaded multiple
times.  Recursive inclusion of files is detected by comparing real,
absolute file pathnames.


File: vicare-libs.info,  Node: silex syntax rules,  Next: silex syntax regexp atomic,  Prev: silex syntax includes,  Up: silex syntax

53.5.3 Rules part
-----------------

The rules part contains the rules up to the end of the specification.
Each rule is a "pattern" optionally followed by an "action".  The
pattern is a regular expression.  The action, if there is one, is formed
of one or more Scheme expressions.

   The actions can span over several lines.  To distinguish between the
rest of the current action and the start of a new rule, SILex checks the
indentation.  A new rule must start at the beginning of the line.  That
is, the action starts right after the pattern and contains all the
following lines that start with white space.

   SILex does not parse the actions.  It simply captures the text up to
the start of the next rule.  So a syntax error in an action is not
detected by SILex.

   Nevertheless, SILex is able to detect that an action has been
omitted.  In that case, a default action is supplied.


File: vicare-libs.info,  Node: silex syntax regexp atomic,  Next: silex syntax regexp compose,  Prev: silex syntax rules,  Up: silex syntax

53.5.4 Atomic regular expressions
---------------------------------

The following constructs are regular expressions:

'C'
     "Ordinary character".  It is a regular expression that matches the
     character C itself.  C must *not* be one of the following
     characters:

          . \ { " [ | ? + * ( ) ^ $ ;

     or any white space.  If C is the '#' character: notice that it
     could match a hex character specification (explained below);
     remember that SILex gives precedence to the longest match.

'.'
     "Wild card".  It matches any character except the newline
     character.

'\n'
'\INTEGER'
'\C'
     "Backslash".  The backslash is used for two things: protect a
     character from special meaning; generating non-printable
     characters.

     The expression '\n' matches the newline character.

     The expression '\INTEGER' matches the character that has number
     INTEGER (in the sense of 'char->integer').  INTEGER must be a valid
     character number on the underlying Scheme implementation.  Notice
     that '\9' represents the horizontal tabulation '#\tab', '\10' the
     newline character '#\newline', and '\13' the carriage return
     character '#\return'.

     The expression '\C' matches the character C if C is not 'n', '-'
     nor a digit.

'#xHEX'
'#XHEX'
     "Hexadecimal characters".  The expressions '#xHEX' and '#XHEX'
     match the character that has hex number HEX (in the sense of
     'string->number').  Remembering that SILex lexers match the longest
     input sequence: HEX terminates at the first non-hexadecimal digit
     character (uppercase or lowercase).

'{NAME}'
     "Macro reference".  This expression matches the same lexemes as
     those matched by the regular expression named NAME.  We can imagine
     that the reference is replaced by the text of the named expression.
     However, it works as if parentheses had been added to protect the
     substituting expression.

'"SOME TEXT"'
     "String".  A string matches a lexeme identical to its contents.
     The format of the string is the same defined by R6RS, including the
     quoted line wrapping.

'[LIST OF CHARACTERS]'
'[]LIST OF CHARACTERS]'
'[-LIST OF CHARACTERS]'
'[^LIST OF CHARACTERS]'
     "Character class".  The expression matches one of the enumerated
     characters.  For example, the expression '[abc]' matches one of
     'a', 'b' and 'c'.

     We can list a range of characters by writing the first character,
     the '-' and the last character.  For example, '[A-Za-z]' matches
     one letter.

     The special characters in a class are ']', which closes the class,
     '-', which denotes a range of characters, and '\', which keeps its
     usual meaning.

     There is an exception with the first character in a class.  If the
     first character is ']' or '-', it loses its special meaning.  If
     the first character is '^', the expression matches one character if
     it is *not* enumerated in LIST OF CHARACTERS.


File: vicare-libs.info,  Node: silex syntax regexp compose,  Next: silex syntax regexp marker,  Prev: silex syntax regexp atomic,  Up: silex syntax

53.5.5 Composing regular expressions
------------------------------------

Suppose R and S are regular expressions.  Then the following expressions
can be built:

'R|S'
     "Union".  This regular expression matches a lexeme if the lexeme is
     matched by R or by S.

'RS'
     "Concatenation".  This expression matches a lexeme if the lexeme
     can be written as the concatenation of a lexeme matched by R and a
     lexeme matched by S.

'R?'
     "Optional expression".  A lexeme matches this expression if it is
     the empty lexeme or if it matches R.

'R+'
     "Positive closure".  This expression matches a lexeme that can be
     written as the concatenation of one or more lexemes, where each of
     those matches R.

'R*'
     "Kleene closure".  A lexeme is matched by this expression if it can
     be written as the concatenation of zero or more lexemes, where each
     of those matches R.

'R{I}'
'R{I,}'
'R{I,J}'
     "Power or repetition of an expression".  These expressions allow
     the "repetition" of a regular expression a certain number of times.
     I and J must be positive integers and J must be greater than, or
     equal to, I.

     The first form repeats the expression R exactly I times.  The
     second form repeats R at least I times.  The last form repeats R at
     least I times and at most J times.

     We should avoid using large numbers (more than 10), because the
     finite automaton for R is copied once for each repetition.  The
     tables of the analyser may quickly become very large.  We should
     note that the syntax of these expressions does not conflict with
     the syntax of the macro reference.

'(R)'
     "Parentheses".  This expression matches the same lexemes as R.  It
     is used to override the precedence of the operators.

   The building operators are listed in order of increasing precedence.
The '?', '+', '*' and repetition operators have the same precedence.


File: vicare-libs.info,  Node: silex syntax regexp marker,  Next: silex syntax regexp space,  Prev: silex syntax regexp compose,  Up: silex syntax

53.5.6 Markers
--------------

The remaining "expressions" would better be called "markers".  They all
match the empty lexeme but require certain conditions to be respected in
the input.  They cannot be used in all regular expressions.  Suppose
that R is a regular expression without markers.

'^R'
'R$'
     "Beginning and end of line".  These markers require that the lexeme
     is found at the beginning or at the end of the line, respectively.
     The markers lose their special meaning if they are not placed at
     the beginning or end of the regular expression, or if they are used
     in the first part of the specification.  In those cases, they are
     treated as regular characters.

'<<EOF>>'
     "End of file".  This marker is matched only when the input system
     is at the end of input.  The marker must be used alone in its
     pattern, and only in the second part of the specification.  There
     can be at most one rule with this particular pattern.

'<<ERROR>>'
     "Error".  This marker is matched only when there is a parsing
     error.  It can be used under the same conditions as '<<EOF>>'.


File: vicare-libs.info,  Node: silex syntax regexp space,  Next: silex syntax sample,  Prev: silex syntax regexp marker,  Up: silex syntax

53.5.7 White spaces in regular expressions
------------------------------------------

White space ends the regular expressions.  In order to include white
space in a regular expression, it must be protected by a backslash or
placed in a string.


File: vicare-libs.info,  Node: silex syntax sample,  Prev: silex syntax regexp space,  Up: silex syntax

53.5.8 An example of a specification file
-----------------------------------------

Here is an example of a SILex specification file.  The file is
syntactically correct from the SILex point of view.  However, many
common mistakes are shown.  The file is not a useful one.

     ; This is a syntactically correct but silly file.

     partial     hel
     complete    {partial}lo            ; Backward macro ref. only
     digit       [0-9]
     letter      [a-zA-Z]

     %%

     -?{digit}+    (cons 'integer yytext)   ; 'yytext' contains
                                            ; the lexeme
     -?{digit}+\.{digit}+[eE][-+]?{digit}+
                   (cons                ; An action
                    'float              ; spanning multiple
                    yytext)             ; lines

     ;             (list 'semicolon)    ; Probably a mistake

     begin         )list 'begin(        ; No error detected here
     end                                ; The action is optional

     \73           (list 'bell-3)       ; It does not match the
                                        ; char. # 7 followed by '3'
     \0073         (list 'bell-3)       ; Neither does it
     (\7)3         (list 'bell-3)       ; This does it

     "*()+|{}[].? are ordinary but \" and \\ are special"

     [^\n]         (list 'char)         ; Same thing as '.'
     ({letter}|_)({letter}|_|{digit})*  ; A C identifier
     [][]                               ; One of the square brackets

     Repe(ti){2}on   (list 'repetition)

     ^{letter}+:   (cons 'label yytext) ; A label placed at the
                                        ; beginning of the line
     $^                                 ; No special meaning
     <<EOF>>       (list 'eof)          ; Detection of the end of file
     <<ERROR>>     (my-error)           ; Error handling


File: vicare-libs.info,  Node: silex semantics,  Next: silex format,  Prev: silex syntax,  Up: silex

53.6 Semantics of the specification
===================================

An important part of the semantics of a specification is described with
the syntax of the regular expressions, the remainder is presented here.
We begin with the role of the actions, information on the matching
method follows.

* Menu:

* silex semantics action::      What does an action do.
* silex semantics rules::       When does a regular expression
                                matches the input.


File: vicare-libs.info,  Node: silex semantics action,  Next: silex semantics rules,  Up: silex semantics

53.6.1 Evaluation of the actions
--------------------------------

The action of a rule is evaluated when the corresponding pattern is
matched.  The result of its evaluation is the result that the lexical
analyser returns to its caller.

   We can think of an action like this: it is a form which is placed in
the body of a 'lambda' function, which in turn is invoked when a token
matching the regular expression is found.  So the following
specification:

     decint          [0-9]+

     %%

     {decint}        (string->number yytext)

will cause the following code to be put in the generated lexer tables:

     (lambda (yytext)
       (string->number yytext))

arguments in the formals of the 'lambda' are local bindings we can use
in our actions.  There are a few local bindings that are accessible by
the action when it is evaluated: 'yycontinue', 'yygetc', 'yyungetc',
'yytext', 'yyline', 'yycolumn' and 'yyoffset'.

 -- Binding: yycontinue
     Contains the lexical analysis function itself.  Use '(yycontinue)'
     to ask for the next token.  Typically, the action associated with a
     pattern that matches white space is a call to 'yycontinue'; it has
     the effect of skipping the white space.

 -- Binding: yygetc
 -- Binding: yyungetc
     Contain functions to get and unget characters from the input of the
     analyser.  They take no argument.  'yygetc' returns a character, or
     the '(eof-object)' value if the end-of-input is reached.

     They should be used to read characters instead of accessing
     directly the input port because the analyser may have read more
     characters in order to have a look-ahead.

     If we get more characters than we unget: those characters are
     skipped by the lexer function at the next invocation.  If we want
     to perform a lookahead without loosing characters, we must unget
     all the characters we have got.

     It is incorrect to try to unget more characters than has been
     gotten since _the parsing of the last token_.  If such an attempt
     is made, 'yyungetc' silently refuses.

 -- Binding: yytext
     Bound to a string containing the lexeme.  This string is guaranteed
     not to be mutated.  The string is created only if the action
     _seems_ to need it.  The action is considered to need the lexeme
     when 'yytext' appears somewhere in the text of the action.

 -- Binding: yyline
 -- Binding: yycolumn
 -- Binding: yyoffset
     Indicate the position in the input at the beginning of the lexeme.
     'yyline' is the number of the line; the first line is numbered 1.
     'yycolumn' is the number of the column; the first column numbered
     1.

     It is important to mention that characters such as the tabulation
     generate a variable length output when they are printed.  So it
     would be more accurate to say that 'yycolumn' is the index of the
     first character of the lexeme, starting at the beginning of the
     line.

     'yyoffset' indicates the distance from the beginning of the input;
     the first lexeme has offset 0.

     The three bindings may not all be existent depending on options
     given to the function 'lex' when generating the tables.

   There is a default action that is provided for a rule when its action
is omitted.

   * If the pattern is '<<EOF>>', the default action returns the
     end-of-file object, '(eof-object)'.

   * If the pattern is '<<ERROR>>', the default action raises an
     assertion violation.  Notice that the error message of this
     assertion cannot hold the line and column numbers, because this
     default action must be usable by lexers that do not use such
     counters, too.

   * The default action for the other patterns is to call the analyser
     again.

   It is clearer (and normally more useful) to specify explicitly the
action associated with each rule.


File: vicare-libs.info,  Node: silex semantics rules,  Prev: silex semantics action,  Up: silex semantics

53.6.2 Matching the rules
-------------------------

All lexical analysers generated by SILex are interactive.  That is, they
read as few characters as possible to get the longest match.  This is a
useful property when the input is coming from a terminal.  A lexical
analyser is normally based on a finite automaton; it is the case for the
analysers generated by SILex.  A non-interactive analyser always needs
an extra character to provoke an invalid transition in the automaton.
The longest match is detected this way.  With an interactive analyser,
an extra character is not required when it is impossible to obtain a
longer match.

   A lexical analyser generated by SILex does not impose any _a priori_
limit on the size of the lexemes.  The internal buffer is extended each
time it is necessary.

   Each time the analyser is asked to return a token, it tries to match
a prefix of the input with a pattern.  There may be more than one
possible match; when it is the case, we say there is a conflict.  For
example, suppose we have those regular expressions:

     begin
     [a-z]*

and the input is 'beginning1 ...'.  We have a match with the first
expression and we have many different matches with the second.  To
resolve such a conflict, the longest match is chosen.  So the chosen
match is the one between the lexeme 'beginning' and the second pattern.

   Suppose we have the same regular expressions but the input is 'begin+
...'.  We have _two_ longest match.  This conflict is resolved by
choosing the first pattern that allows a longest match.  So the chosen
match is between the lexeme 'begin' and the first pattern.

   The analyser generated by SILex allows the empty lexeme to be matched
if there is no longer match.  However, we should take care not to call
the analyser again without consuming at least one character of the
input: it would cause an infinite loop.

   The pattern '<<EOF>>' is matched when the analyser is called and the
input system is at end of input.  In this situation, the marker is
matched even if there is a pattern that matches the empty lexeme.  The
analyser can be called again and again and the '<<EOF>>' pattern will be
matched each time, causing its corresponding action to be evaluated each
time, too.

   The pattern '<<ERROR>>' is matched when the input system is not at
end of input and no other match is possible.  Depending on the action
associated with this pattern, our program may choose to stop or choose
to try to recover from the error.  To recover from the error, our
program has to read some characters from the input before it can call
the analyser again.

   As example of error recovery consider the following code which just
shows the mechanism:

     #!r6rs
     (import (nausicaa)
       (prefix (nausicaa parser-tools lexical-tokens) lt.)
       (prefix (vicare parser-tools silex) lex.)
       (prefix (vicare parser-tools silex lexer) lex.))

     (define description "%%
     A          (lt.<lexical-token>
                  ((lt.category: 'A)
                   (lt.location: (lt.<source-location>
                                   ((lt.input:  #f)
                                    (lt.line:   yyline)
                                    (lt.column: yycolumn)
                                    (lt.offset: yyoffset))))
                   (lt.value:    yytext)
                   (lt.length:   (string-length yytext))))

     <<EOF>>    (lt.<lexical-token>
                  ((lt.category: '*eoi*)
                   (lt.location: (lt.<source-location>
                                   ((lt.input:  #f)
                                    (lt.line:   yyline)
                                    (lt.column: yycolumn)
                                    (lt.offset: yyoffset))))
                   (lt.value:    (eof-object))
                   (lt.length:   1)))

     <<ERROR>>  (lt.<lexical-token>
                  ((lt.category: '*lexer-error*)
                   (lt.location: (lt.<source-location>
                                   ((lt.input:  #f)
                                    (lt.line:   yyline)
                                    (lt.column: yycolumn)
                                    (lt.offset: yyoffset))))
                   (lt.value:    yytext)
                   (lt.length:   (string-length yytext))))
     ")

     (define table
       (lex.lex
         (lex.input-string:     description)
         (lex.counters:         'all)
         (lex.library-language: '(vicare))
         (lex.library-imports:
           '((prefix (nausicaa parser-tools lexical-token) lt.)))
         (lex.output-value:     #t)
         (lex.lexer-format:     'decision-tree)))

     ;; correct string
     (let* ((IS    (lex.make-IS
                     (lex.string: "AAA")
                     (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 lt.<lexical-token>) (lexer))
             ((T2 lt.<lexical-token>) (lexer))
             ((T3 lt.<lexical-token>) (lexer))
             ((T4 lt.<lexical-token>) (lexer)))
         (list (T1 category) (T2 category)
               (T3 category) (T4 category))))
     => (A A A *eoi*)

     ;; lexer error
     (let* ((IS    (lex.make-IS
                     (lex.string: "AAAB")
                     (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 lt.<lexical-token>) (lexer))
             ((T2 lt.<lexical-token>) (lexer))
             ((T3 lt.<lexical-token>) (lexer))
             ((T4 lt.<lexical-token>) (lexer)))
         (list (T1 category) (T2 category)
               (T3 category) (T4 category))))
     => (A A A *lexer-error*)

     ;; lexer error and recovery
     (let* ((IS    (lex.make-IS
                     (lex.string: "AAABBAA")
                     (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 lt.<lexical-token>) (lexer))
             ((T2 lt.<lexical-token>) (lexer))
             ((T3 lt.<lexical-token>) (lexer))
             ((T4 lt.<lexical-token>) (lexer)))
         ;; discard invalid characters,
         ;; we know there are 2 of them
         (let ((getc (lex.lexer-get-func-getc IS)))
           (getc)
           (getc))
         (let (((T5 lt.<lexical-token>) (lexer))
               ((T6 lt.<lexical-token>) (lexer))
               ((T7 lt.<lexical-token>) (lexer)))
           (list (T1 category) (T2 category) (T3 category)
                 (T4 category)
                 (T5 category) (T6 category) (T7 category)))))
     => (A A A *lexer-error* A A *eoi*)


File: vicare-libs.info,  Node: silex format,  Next: silex utilities,  Prev: silex semantics,  Up: silex

53.7 Tables output format
=========================

SILex provides three different table encodings: the "decision tree"
encoding, the "portable" encoding and the "compilation" to Scheme code;
the decision tree is the default.

   With the decision tree encoding, the finite automaton of the analyser
is represented with data structures holding integers representation of
the characters (in the sense of 'char->integer').  This representation
is the most compact, but it relies on the character integer
representations in R6RS Schemes.

   With the portable encoding, the data structures describing the
automaton contain characters directly.  If the automaton, as generated,
contains a transition from state S to state T on character C, then
somewhere in the table there is the Scheme character '#\C'.  When the
file containing the analyser is loaded in any implementation, the
character is read as is, and not as the number '(char->integer #\C)'.

   This encoding should be portable to non-R6RS Schemes.  However, it is
less compact.  This is because something like '(65 90)' is more compact
than something like '(#\A #\B ... #\Y #\Z)' to represent '[A-Z]'.  The
construction of an analyser from a portable table takes more time than
the construction from a default table.  But, once built, the performance
of the analyser is the same in both cases.

   It is important to note that in some character sets, the letters or
the digits are not contiguous.  So, in those cases, the regular
expression '[A-Z]' does not necessarily accept only the uppercase
letters.

   The last encoding is the compilation to Scheme code; it produces a
fast lexical analyser.  Instead of containing data structures
representing the behavior of the automaton, the table contains Scheme
code that "hard-codes" the automaton.  This encoding often generates big
tables.  Such an analyser is not portable to non-R6RS Schemes.


File: vicare-libs.info,  Node: silex utilities,  Prev: silex format,  Up: silex

53.8 Utility functions
======================

The following bindings are exported by the '(vicare parser-tools silex
utilities)' library.

 -- Function: make-max-count-lexer LEXER MAX-NUMBER-OF-TOKENS
          ERROR-HANDLER
     Return a lexer function wrapping LEXER; if the number of returned
     tokens reaches MAX-NUMBER-OF-TOKENS: the thunk ERROR-HANDLER is
     invoked.


File: vicare-libs.info,  Node: parser-tools,  Next: Package License,  Prev: silex,  Up: Top

54 Lexers and parsers
*********************

* Menu:

* parser-tools unix-pathnames::    Parsing Unix file system pathnames.


File: vicare-libs.info,  Node: parser-tools unix-pathnames,  Up: parser-tools

54.1 Parsing Unix file system pathnames
=======================================

The library '(vicare parser-tools unix-pathnames)' implements facilities
for parsing and manipulating Unix file system pathnames.  When importing
it, it is suggested to prefix the bindings with 'uxptn.' as in:

     (import (vicare)
       (prefix (vicare parser-tools unix-pathnames) uxptn.))

* Menu:

* parser-tools unix-pathnames grammar:: Grammar of Unix pathnames.
* parser-tools unix-pathnames errors::  Condition object types.
* parser-tools unix-pathnames preds::   Predicates for Unix pathnames.
* parser-tools unix-pathnames conv::    Converting Unix pathnames.
* parser-tools unix-pathnames parser::  Parsing Unix pathnames.
* parser-tools unix-pathnames manip::   Manipulating Unix pathnames.
* parser-tools unix-pathnames comp::    Components of Unix pathnames.


File: vicare-libs.info,  Node: parser-tools unix-pathnames grammar,  Next: parser-tools unix-pathnames errors,  Up: parser-tools unix-pathnames

54.1.1 Grammar of Unix pathnames
--------------------------------

A Unix pathname has the following grammar:

     pathname           = absolute-pathname
                        | relative-pathname

     absolute-pathname  = "/" segment *( "/" segment )
     relative-pathname  = segment-nz *( "/" segment )

     segment            = *char
     segment-nz         = 1*char

     char               = [1, 255]

where [1, 255] represents the octet interval between 1 included and 255
included.  Notice that: an empty 'pathname' is invalid; an empty
'segment' is valid and interpreted as equivalent to a pathname segment
representing the current directory '.'.


File: vicare-libs.info,  Node: parser-tools unix-pathnames errors,  Next: parser-tools unix-pathnames preds,  Prev: parser-tools unix-pathnames grammar,  Up: parser-tools unix-pathnames

54.1.2 Condition object types
-----------------------------

The following bindings are exported by the library '(vicare parser-tools
unix-pathnames)'.

Parser errors
.............

 -- Condition Type: &unix-pathname-parser-error
     Signals an error while parsing a Unix pathname representation; it
     is derived from '&error'.

 -- Function: make-unix-pathname-parser-error
     Build and return a new condition object of type
     '&unix-pathname-parser-error'.

 -- Function: unix-pathname-parser-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&unix-pathname-parser-error'; otherwise return '#f'.

Normalisation errors
....................

 -- Condition Type: &unix-pathname-normalisation-error
     Signals an error while normalising a Unix pathname representation;
     it is derived from '&error'.

 -- Function: make-unix-pathname-normalisation-error
     Build and return a new condition object of type
     '&unix-pathname-normalisation-error'.

 -- Function: unix-pathname-normalisation-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&unix-pathname-normalisation-error'; otherwise return '#f'.

Raising exceptions
..................

 -- Function: raise-unix-pathname-parser-error WHO MESSAGE IRRITANT ...
     Raise a non-continuable exception with compound condition object of
     types: '&unix-pathname-parser-error', '&who', '&message',
     '&irritants'.

 -- Function: raise-unix-pathname-normalisation-error WHO MESSAGE
          IRRITANT ...
     Raise a non-continuable exception with compound condition object of
     types: '&unix-pathname-normalisation-error', '&who', '&message',
     '&irritants'.

