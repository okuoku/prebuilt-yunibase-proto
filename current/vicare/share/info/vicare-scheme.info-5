This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: iklib io pathnames,  Next: iklib io codecs,  Up: iklib io

6.44.1 String and bytevector pathnames handling
-----------------------------------------------

All the file-related functions defined by R6RS accept a Scheme string as
representing a file pathname; internally such string is converted to a
bytevector to be handed to the underlying operating system.

   The following bindings are exported by the library '(vicare)'.

 -- Parameter: string->filename-func
 -- Parameter: string->pathname-func
     In Vicare the string-to-filename conversion is performed by the
     function returned by 'string->filename-func', which defaults to
     'string->utf8'.

 -- Parameter: filename->string-func
 -- Parameter: pathname->string-func
     In Vicare the filename-to-string conversion is performed by the
     function returned by 'filename->string-func', which defaults to
     'utf8->string'.

 -- Function: directory-exists? PTN
     Return '#t' if PTN is a string or bytevector representing the
     pathname of an existent directory; otherwise return '#f'.

   The following bindings are exported by the library '(vicare
language-extensions posix)'.

 -- Function: file-pathname? OBJ
 -- Function: file-string-pathname? OBJ
 -- Function: file-bytevector-pathname? OBJ
     Return '#t' if OBJ is a string or bytevector, not empty, not
     including a character whose ASCII representation is the null byte.

 -- Function: file-absolute-pathname? PATHNAME
 -- Function: file-string-absolute-pathname? PATHNAME
 -- Function: file-bytevector-absolute-pathname? PATHNAME
     The argument PATHNAME must be a string or bytevector.  Return '#t'
     if PATHNAME starts with a '/' character, which means it is valid as
     Unix-style absolute pathname; otherwise return '#f'.

     This function only acts upon its argument, never accessing the file
     system.

 -- Function: file-relative-pathname? PATHNAME
 -- Function: file-string-relative-pathname? PATHNAME
 -- Function: file-bytevector-relative-pathname? PATHNAME
     The argument PATHNAME must be a string or bytevector.  Return '#t'
     if PATHNAME doest *not* start with a '/' character, which means it
     is valid as Unix-style relative pathname; otherwise return '#f'.

     This function only acts upon its argument, never accessing the file
     system.

 -- Function: split-pathname-root-and-tail PATHNAME
     Given a string representing a pathname: split it into the directory
     part and the tail part.  Return 2 values: a string representing the
     directory part and a string representing the tail name part.  If
     PATHNAME is just the name of a file or directory relative to the
     current directory: the directory part is empty and the first
     returned value is the empty string.

     Assume the pathname components separator is '/', which is
     Unix-specific.

          (receive (root tail)
              (split-pathname-root-and-tail "a/b")
            (list root tail))
          => ("a" "b")

          (receive (root tail)
              (split-pathname-root-and-tail "ciao")
            (list root tail))
          => ("" "ciao")

 -- Function: file-colon-search-path? OBJ
 -- Function: file-string-colon-search-path? OBJ
 -- Function: file-bytevector-colon-search-path? OBJ
     Return '#t' if OBJ is a string or bytevector, possibly empty, not
     including a character whose ASCII representation is the null byte.

 -- Function: split-search-path PATH
 -- Function: split-search-path-bytevector BYTEVECTOR-PATH
 -- Function: split-search-path-string STRING-PATH
     Split a file search path into its components and return a list of
     pathnames.  A search path is meant to be a list of directory
     pathnames separated by a colon character; BYTEVECTOR-PATH must be a
     bytevector, STRING-PATH must be a Scheme string, PATH must be a
     Scheme string or bytevector.  Empty pathnames are discarded.

          #!vicare
          (import (vicare))

          (split-search-path-bytevector '#vu8())
          => ()

          (split-search-path-bytevector #ve(ascii "ciao:hello"))
          => (#ve(ascii "ciao") #ve(ascii "hello"))

          (split-search-path-bytevector '#ve(ascii "::::"))
          => ()

          (split-search-path-string "")
          => ()

          (split-search-path-string "ciao:hello:salut")
          => ("ciao" "hello" "salut")

          (split-search-path-string "::::")
          => ()

          (split-search-path "ciao:hello:salut")
          => ("ciao" "hello" "salut")

          (split-search-path '#ve(ascii "ciao:hello:salut"))
          => (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))

 -- Function: list-of-pathnames? OBJ
 -- Function: list-of-string-pathnames? OBJ
 -- Function: list-of-bytevector-pathnames? OBJ
     Return '#t' if OBJ is a proper list of pathnames according to
     'file-pathname?', 'file-string-pathname?',
     'file-bytevector-pathname?'.

 -- Function: split-pathname PATHNAME
 -- Function: split-pathname-bytevector BYTEVECTOR-PATHNAME
 -- Function: split-pathname-string STRING-PATHNAME
     Split a file pathname into its components and return two values: a
     boolean, true if the pathname starts with a slash characters; the
     list of components which can be empty.

     A pathname is meant to be a file or directory name with components
     separated by a slash character; BYTEVECTOR-PATHNAME must be a
     bytevector, STRING-PATHNAME must be a Scheme string, PATH must be a
     Scheme string or bytevector.

     Empty components are discarded.

          #!vicare
          (import (vicare))

          (split-pathname-bytevector '#vu8())
          error-> "invalid pathname"

          (split-pathname-bytevector '#ve(ascii "ciao/hello"))
          => #f (#ve(ascii "ciao") #ve(ascii "hello"))

          (split-pathname-bytevector '#ve(ascii "////"))
          => #t ()

          (split-pathname-string "")
          error-> "invalid pathname"

          (split-pathname-string "ciao/hello/salut")
          => #f ("ciao" "hello" "salut")

          (split-pathname-string "////")
          => #t ()

          (split-pathname "ciao/hello/salut")
          => #f ("ciao" "hello" "salut")

          (split-pathname '#ve(ascii "/ciao/hello/salut"))
          => #t (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))

 -- Function: search-file-in-environment-path PATHNAME
          ENVIRONMENT-VARIABLE
     Search a file pathname (regular file or directory) in the given
     search path.

     PATHNAME must be a string representing a file pathname;
     ENVIRONMENT-VARIABLE must be a string representing a system
     environment variable.

        * If PATHNAME is absolute, test its existence: when found,
          return a string representing the real absolute file pathname;
          otherwise return '#f'.

        * If PATHNAME is relative and it has a directory part, test its
          existence: when found, return a string representing the real
          absolute file pathname; otherwise return '#f'.

        * If PATHNAME is relative and it has no directory part, read the
          environment variable as colon-separated list of directories
          and search the file in them, from the first to the last: when
          found, return a string representing the real absolute file
          pathname; otherwise return '#f'.

          Notice that the file is searched in the process' current
          working directory only if such directory is listed in the
          given path.

 -- Function: search-file-in-list-path PATHNAME LIST-OF-DIRECTORIES
     Search a file pathname (regular file or directory) in the given
     search path.

     PATHNAME must be a string representing a file pathname;
     LIST-OF-DIRECTORIES must be a list of strings representing
     directory pathnames.

        * If PATHNAME is absolute, test its existence: when found,
          return a string representing the real absolute file pathname;
          otherwise return '#f'.

        * If PATHNAME is relative and it has a directory part, test its
          existence: when found, return a string representing the real
          absolute file pathname; otherwise return '#f'.

        * If PATHNAME is relative and it has no directory part, search
          the file in the given directories, from the first to the last:
          when found, return a string representing the real absolute
          file pathname; otherwise return '#f'.

          Notice that the file is searched in the process' current
          working directory only if such directory is listed in the
          given path.


File: vicare-scheme.info,  Node: iklib io codecs,  Next: iklib io non-blocking,  Prev: iklib io pathnames,  Up: iklib io

6.44.2 Transcoders and additional codecs
----------------------------------------

The following bindings are exported by the '(vicare)' library.

 -- Function: transcoder? OBJ
     Return '#t' if OBJ is a transcoder, else return '#f'.

 -- Function: list-of-transcoders? OBJ
     Return '#t' if OBJ is a list of transcoders, else return '#f'.

 -- Parameter: native-transcoder
     The function 'native-transcoder' defined by R6RS returns a
     transcoder representing acceptable defaults for the platform on
     which the Scheme implementation is running.  Under Vicare such
     default is:

          (make-transcoder (utf-8-codec) (native-eol-style) 'replace)

     and additionally the function is a parameter, so the default can be
     configured.  Notice that the following functions create Scheme
     ports using the transcoder returned by 'native-transcoder':

          open-input-file         open-output-file
          with-input-from-file    with-output-to-file
          call-with-input-file    call-with-output-file

 -- Function: transcoder=? TRAN0 TRAN ...
 -- Function: transcoder!=? TRAN0 TRAN ...
 -- Function: transcoder<? TRAN0 TRAN ...
 -- Function: transcoder>? TRAN0 TRAN ...
 -- Function: transcoder<=? TRAN0 TRAN ...
 -- Function: transcoder>=? TRAN0 TRAN ...
     Compare the given transcoders and return '#t' or '#f'.

 -- Function: transcoder-min TRAN0 TRAN ...
 -- Function: transcoder-max TRAN0 TRAN ...
     Return the minimum or maximum transcoder among the arguments.

 -- Function: transcoder-hash TRAN
     Hash function for transcoder objects.

   The codec returned by 'utf-16-codec', defined by R6RS, has different
semantics depending upon the type of the port:

   * For output and input/output ports it defaults to UTF-16 big endian
     (which seems mandated by the Unicode Consortium).

   * For input ports the endianness is left unspecified until the first
     bytes are read: such bytes must be a valid UTF-16 Byte Order Mark
     which dynamically configures the port.(1)

 -- Procedure: utf-16le-codec
 -- Procedure: utf-16be-codec
     Codecs for the UTF-16 encoding schemes, little endian and big
     endian.  A call to any of these procedures returns a value that is
     equal in the sense of 'eqv?' to the result of any other call to the
     same procedure.

 -- Procedure: utf-16n-codec
     Return a codec for the UTF-16 encoding scheme, with endianness
     equal to the one returned by '(native-endianness)'.  A call to this
     procedure returns a value that is equal in the sense of 'eqv?' to
     the result of any other call to the same procedure.

 -- Procedure: utf-bom-codec
     Codec for UTF encoding schemes whose data open with a Byte Order
     Mark.  A call to this procedure returns a value that is equal in
     the sense of 'eqv?' to the result of any other call to the same
     procedure.

     At present this codec is supported only by input ports.

   ---------- Footnotes ----------

   (1) The big endian BOM for UTF-16 is the sequence of bytes '#xFE
#xFF'; the little endian BOM for UTF-16 is the sequence of bytes '#xFF
#xFE'.


File: vicare-scheme.info,  Node: iklib io non-blocking,  Next: iklib io binary,  Prev: iklib io codecs,  Up: iklib io

6.44.3 Handling non-blocking devices
------------------------------------

R6RS defines the input operations on Scheme ports as properly blocking
when no input data is available; this is fine when the underlying device
is configured in blocking mode.  Vicare extends the Scheme input/output
ports to support underlying devices configured in non-blocking mode;
such ports are typically the ones whose underlying device is a POSIX
file or socket descriptor.

   The implementation of Scheme ports read from the underlying device
through a function 'read!'; if the device is configured in non-blocking
mode: 'read!' might raise an exception with condition object type
'&i/o-eagain', which means: there are no available bytes, but this is
not the end-of-file.  This scenario corresponds to the case in which a
POSIX function fails with 'errno' set to 'EAGAIN' or 'EWOULDBLOCK'.

   The functions extended by Vicare behave as described in this section.
The extended behaviour is disabled when running with the command line
'--strict-r6rs': in this case the port will block as mandated by R6RS.

* Menu:

* iklib io non-blocking object::  The would-block object.
* iklib io non-blocking mode::    Ports and non-blocking mode.
* iklib io non-blocking binary::  Extended binary input functions.
* iklib io non-blocking textual:: Extended textual input functions.


File: vicare-scheme.info,  Node: iklib io non-blocking object,  Next: iklib io non-blocking mode,  Up: iklib io non-blocking

6.44.3.1 The would-block object
...............................

 -- Function: would-block-object
     Return a unique object representing the condition "no bytes, not
     EOF" on a device configured in non-blocking mode.  The would-block
     object can be compared with 'eq?'.

 -- Function: would-block-object? OBJ
     Return '#t' if OBJ is the would-block object, else return '#f'.


File: vicare-scheme.info,  Node: iklib io non-blocking mode,  Next: iklib io non-blocking binary,  Prev: iklib io non-blocking object,  Up: iklib io non-blocking

6.44.3.2 Ports and non-blocking mode
....................................

 -- Function: port-set-non-blocking-mode! PORT
     Set non-blocking mode for PORT; if successful return unspecified
     values, if an error occurs raise an exception.  PORT must have a
     file descriptor as underlying device.

 -- Function: port-unset-non-blocking-mode! PORT
     Unset non-blocking mode for PORT; if successful return unspecified
     values, if an error occurs raise an exception.  PORT must have a
     file descriptor as underlying device.

 -- Function: port-in-non-blocking-mode? PORT
     Query PORT for its non-blocking mode; if successful: return '#t' if
     the port is in non-blocking mode, '#f' otherwise.  If an error
     occurs: raise an exception.

     PORT can be any Scheme port: this function will recognise
     non-blocking mode only for ports having a file descriptor as
     underlying device; for all the other ports the return value is
     '#f'.


File: vicare-scheme.info,  Node: iklib io non-blocking binary,  Next: iklib io non-blocking textual,  Prev: iklib io non-blocking mode,  Up: iklib io non-blocking

6.44.3.3 Extended binary input functions
........................................

 -- Function: get-u8 PORT
     Return the EOF object, the would-block object or a fixnum:

        * If a byte is available: return the byte as an octet and update
          PORT to point just past that byte.

        * If no input byte is seen before an end of file is reached: the
          EOF object is returned.

        * If the underlying device is in non-blocking mode and no bytes
          are available: return the would-block object.

 -- Function: lookahead-u8 PORT
     Like GET-U8, but it does not update PORT to point past the byte.

 -- Function: get-bytevector-n PORT COUNT
     Return the EOF object, the would-block object or a bytevector:

        * If COUNT bytes are available before an end of file: return a
          bytevector of size COUNT.  The input port is updated to point
          just past the bytes read.

        * If fewer than COUNT bytes are available before an end of file:
          return a bytevector containing those bytes.  The input port is
          updated to point just past the bytes read.

        * If an end of file is reached before any bytes are available:
          return the EOF object.

        * If the underlying device is in non-blocking mode and fewer
          than COUNT bytes are available: return a bytevector containing
          those bytes.  The input port is updated to point just past the
          bytes read.

        * If the underlying device is in non-blocking mode and no bytes
          are available: return the would-block object.

 -- Function: get-bytevector-n! PORT DST.BV DST.START COUNT
     Return the EOF object, the would-block object or the number of
     bytes written in the given bytevector:

        * If COUNT bytes are available before the end of file: they are
          written into DST.BV starting at index DST.START, and the
          result is COUNT.  The input port is updated to point just past
          the bytes read.

        * If fewer than COUNT bytes are available before the end of
          file: the available bytes are written into DST.BV starting at
          index DST.START, and the result is a number object
          representing the number of bytes actually read.  The input
          port is updated to point just past the bytes read.

        * If the end of file is reached before any bytes are available:
          return the EOF object.

        * If the underlying device is in non-blocking mode and fewer
          than COUNT bytes are available: the available bytes are
          written into DST.BV starting at index DST.START, and the
          result is a number object representing the number of bytes
          actually read.  The input port is updated to point just past
          the bytes read.

        * If the underlying device is in non-blocking mode and no bytes
          are available: return the would-block object.

 -- Function: get-bytevector-some PORT
     Return the EOF object, the would-block object or a bytevector:

        * If bytes are available: return a freshly allocated bytevector
          containing the initial available bytes (at least one), and
          update PORT to point just past these bytes.

        * If no input bytes are seen before an end of file is reached:
          the EOF object is returned.

        * If the underlying device is in non-blocking mode and no bytes
          are available: return the would-block object.


File: vicare-scheme.info,  Node: iklib io non-blocking textual,  Prev: iklib io non-blocking binary,  Up: iklib io non-blocking

6.44.3.4 Extended textual input functions
.........................................

 -- Function: get-char PORT
     Return the EOF object, the would-block object or a character:

        * If a complete character is available before the next end of
          file: return that character and update the input port to point
          past the character.

        * If an end of file is reached before any character is read:
          return the EOF object.

        * If the underlying device is in non-blocking mode and no full
          character is available: return the would-block object.

 -- Function: read-char
 -- Function: read-char PORT
     Like 'get-char'.

 -- Function: lookahead-char PORT
     Like 'get-char', but it does not update PORT to point past the
     character.

 -- Function: peek-char
 -- Function: peek-char PORT
     Like 'lookahead-char'.

 -- Function: get-string-n PORT REQUESTED-COUNT
     Return the EOF object, the would-block object or a string and
     update the input port to point past the consumed characters:

        * If REQUESTED-COUNT characters are available before end of
          file: return a string consisting of those REQUESTED-COUNT
          characters.

        * If fewer than REQUESTED-COUNT characters are available before
          an end of file, but one or more characters can be read: return
          a string containing those characters.

        * If no characters can be read before an end of file: return the
          EOF object.

        * If the underlying device is in non-blocking mode and no
          characters are available: return the would-block object.

 -- Function: get-string-n! PORT DST.STR DST.START COUNT
     Return the EOF object, the would-block object or a string and
     update the input port to point past the consumed characters:

        * If COUNT characters are available before an end of file: they
          are written into DST.STR starting at index DST.START, and
          COUNT is returned.

        * If fewer than COUNT characters are available before an end of
          file, but one or more can be read: those characters are
          written into DST.STR starting at index DST.START and the
          number of characters actually read is returned as an exact
          integer object.

        * If no characters can be read before an end of file: the EOF
          object is returned.

        * If the underlying device is in non-blocking mode and fewer
          than COUNT characters are available before a would-block
          condition, but one or more can be read: those characters are
          written into DST.STR starting at index DST.START and the
          number of characters actually read is returned as an exact
          integer object.

        * If the underlying device is in non-blocking mode and no
          characters are available: return the would-block object.

 -- Function: get-string-all PORT
     Return the EOF object or a string and update the input port to
     point past the consumed characters:

        * If characters are available before the end of file: a string
          containing all the characters decoded from that data is
          returned.  Further reading from the port will return the EOF
          object.

        * If no character precedes the end of file: the EOF object is
          returned.

     Even when the underlying device is in non-blocking mode: this
     function attempts to read input until the EOF is found.

 -- Function: get-string-some PORT
     Return the EOF object, the would-block object or a string and
     update the input port to point past the consumed characters:

        * If characters become available before the end of file: return
          a freshly allocated string containing the initial available
          characters (at least one), and update PORT to point just past
          these characters.

        * If no input characters are available before the end of file:
          the EOF object is returned.

        * If no input characters are available before a would-block
          condition: the would-block object is returned.


File: vicare-scheme.info,  Node: iklib io binary,  Next: iklib io textual,  Prev: iklib io non-blocking,  Up: iklib io

6.44.4 Additional binary port features
--------------------------------------

The following bindings are exported by the '(vicare)' library.

 -- Function: binary-input-port? OBJ
 -- Function: binary-output-port? OBJ
 -- Function: binary-input/output-port? OBJ
     Return '#t' if OBJ is a binary port and, respectively, it is: input
     or input/output; output or input/output; input/output.

 -- Function: binary-input-only-port? OBJ
 -- Function: binary-output-only-port? OBJ
     Return '#t' if OBJ is a binary port and, respectively, it is
     input-only or output-only.

 -- Function: open-binary-port? OBJ
 -- Function: open-binary-input-port? OBJ
 -- Function: open-binary-output-port? OBJ
 -- Function: open-binary-input/output-port? OBJ
     Return '#t' if OBJ is an open binary port and, respectively, it is
     input, output or input/output.

 -- Function: lookahead-two-u8 PORT
     Like 'lookahead-u8' but peeks at 2 octets and return two values:
     the EOF object, the would-block object or a fixnum representing
     first octet; the EOF object, the would-block object or a fixnum
     representing the second octet.

 -- Function: console-input-port
 -- Function: console-input-port TEXTUAL-INPUT-PORT
     Return the default textual input port: the default value of the
     parameter 'current-input-port'; each call returns the same port.
     When the readline interface is not used, this port is used by the
     REPL and the debugger.

     When applied to an argument: the argument must be a textual input
     port which replaces the old value; the old port is left untouched
     (it is not closed).  When selecting a new console input port: the
     same port should be used as top value for the parameter
     'current-input-port'.

 -- Function: console-output-port
 -- Function: console-output-port TEXTUAL-OUTPUT-PORT
     Return the default textual output port: the default value of the
     parameter 'current-output-port'; each call returns the same port.
     This port is used by the REPL and the debugger.

     When applied to an argument: the argument must be a textual output
     port which replaces the old value; the old port is left untouched
     (it is not closed).  When selecting a new console output port: the
     same port should be used as top value for the parameter
     'current-output-port'.

 -- Function: console-error-port
 -- Function: console-error-port TEXTUAL-OUTPUT-PORT
     Return the default textual error port: the default value of the
     parameter 'current-input-port'; each call returns the same port.

     When applied to an argument: the argument must be a textual output
     port and it replaces the old value; the old port is left untouched
     (it is not closed).  When selecting a new console error port: the
     same port should be used as top value for the parameter
     'current-error-port'.

 -- Constant: stdin
 -- Constant: stdout
 -- Constant: stderr
     Bound to the values returned by 'console-input-port',
     'console-output-port', 'console-error-port' respectively.

 -- Function: make-binary-file-descriptor-input-port FD IDENTIFIER
 -- Function: make-binary-file-descriptor-output-port FD IDENTIFIER
 -- Function: make-binary-file-descriptor-input/output-port FD
          IDENTIFIER
     Build and return binary Scheme ports using the platform file
     descriptor FD as device.  IDENTIFIER must be a string used for
     better error reporting.  Closing the Scheme ports will close the
     file descriptors too.

     File descriptor ports do support port position operations.

 -- Function: make-binary-file-descriptor-input-port* FD IDENTIFIER
 -- Function: make-binary-file-descriptor-output-port* FD IDENTIFIER
 -- Function: make-binary-file-descriptor-input/output-port* FD
          IDENTIFIER
     Build and return binary Scheme ports using the platform file
     descriptor FD as device.  IDENTIFIER must be a string used for
     better error reporting.  Closing the Scheme ports will *not* close
     the file descriptors.

     File descriptor ports do support port position operations.

 -- Function: make-binary-socket-input-port SOCK IDENTIFIER
 -- Function: make-binary-socket-output-port SOCK IDENTIFIER
 -- Function: make-binary-socket-input/output-port SOCK IDENTIFIER
     Build and return a binary Scheme port using the platform socket
     descriptor SOCK as device.  IDENTIFIER must be a string used for
     better error reporting.  Closing the Scheme port will close the
     socket descriptor too.

     Socket ports do *not* support port position operations.

 -- Function: make-binary-socket-input-port* SOCK IDENTIFIER
 -- Function: make-binary-socket-output-port* SOCK IDENTIFIER
 -- Function: make-binary-socket-input/output-port* SOCK IDENTIFIER
     Build and return a binary Scheme port using the platform socket
     descriptor SOCK as device.  IDENTIFIER must be a string used for
     better error reporting.  Closing the Scheme port will *not* close
     the socket descriptor.

     Socket ports do *not* support port position operations.


File: vicare-scheme.info,  Node: iklib io textual,  Next: iklib io buffer,  Prev: iklib io binary,  Up: iklib io

6.44.5 Additional textual port features
---------------------------------------

The following bindings are exported by the '(vicare)' library.

 -- Parameter: current-input-port
     As defined by R6RS: return a default textual port for input.
     Vicare extends its definition to allow selecting a new textual
     input port.

 -- Parameter: current-output-port
     As defined by R6RS: return a default textual port for output.
     Vicare extends its definition to allow selecting a new textual
     output port.

 -- Parameter: current-error-port
     As defined by R6RS: return a default textual port for error
     messages output.  Vicare extends its definition to allow selecting
     a new textual output port.

 -- Function: textual-input-port? OBJ
 -- Function: textual-output-port? OBJ
 -- Function: textual-input/output-port? OBJ
     Return '#t' if OBJ is a textual port and, respectively, it is:
     input or input/output; output or input/output; input/output.

 -- Function: textual-input-only-port? OBJ
 -- Function: textual-output-only-port? OBJ
     Return '#t' if OBJ is a textual port and, respectively, it is
     input-only or output-only.

 -- Function: open-textual-port? OBJ
 -- Function: open-textual-input-port? OBJ
 -- Function: open-textual-output-port? OBJ
 -- Function: open-textual-input/output-port? OBJ
     Return '#t' if OBJ is an open textual port and, respectively, it is
     input, output or input/output.

 -- Function: open-string-input-port STRING
 -- Function: open-string-input-port STRING EOL-STYLE
     As defined by R6RS: return a textual input port whose characters
     are drawn from STRING.  When EOL-STYLE is given: it must be a
     symbol selecting an end-of-line style conversion, as accepted by
     'eol-style'; such conversion is applied to the characters drawn
     from STRING.

     If STRING is modified after 'open-string-input-port' has been
     called, the effect on the returned port is unspecified.

 -- Function: open-string-input-port/id STRING ID
 -- Function: open-string-input-port/id STRING ID EOL-STYLE
     Like 'open-string-input-port' but allows the specification of a
     customised port identifier ID, which must be a Scheme string.

 -- Function: open-string-output-port
 -- Function: open-string-output-port EOL-STYLE
     As defined by R6RS, return two values: a textual output port and an
     extraction procedure; the output port accumulates the characters
     written to it for later extraction by the procedure.

     As a Vicare extension, when EOL-STYLE is given: it must be a symbol
     selecting an end-of-line style conversion, as accepted by
     'eol-style'; such conversion is applied to the characters written
     to the port.

 -- Function: get-output-string PORT
     Return the string accumulated in the PORT opened by
     'open-string-output-port'.  This function can be called also when
     the port has been closed.

 -- Function: get-char-and-track-textual-position PORT
     Like 'get-char' but track the textual position.  Recognise only
     linefeed characters as line-ending.

 -- Function: port-textual-position PORT
     Given a textual port, return the current textual position as a
     condition object of type '&source-position'.

 -- Function: make-textual-file-descriptor-input-port FD IDENTIFIER
          TRANSCODER
 -- Function: make-textual-file-descriptor-output-port FD IDENTIFIER
          TRANSCODER
 -- Function: make-textual-file-descriptor-input/output-port FD
          IDENTIFIER TRANSCODER
     Build and return textual Scheme ports using the platform file
     descriptor FD as device.  IDENTIFIER must be a string used for
     better error reporting.  TRANSCODER must be a transcoder object.
     Closing the Scheme ports will close the file descriptors too.

     File descriptor ports do support port position operations.

 -- Function: make-textual-file-descriptor-input-port* FD IDENTIFIER
          TRANSCODER
 -- Function: make-textual-file-descriptor-output-port* FD IDENTIFIER
          TRANSCODER
 -- Function: make-textual-file-descriptor-input/output-port* FD
          IDENTIFIER TRANSCODER
     Build and return textual Scheme ports using the platform file
     descriptor FD as device.  IDENTIFIER must be a string used for
     better error reporting.  TRANSCODER must be a transcoder object.
     Closing the Scheme ports will *not* close the file descriptors.

     File descriptor ports do support port position operations.

 -- Function: make-textual-socket-input/output-port SOCK IDENTIFIER
          TRANSCODER
     Build and return a textual Scheme port using the platform socket
     descriptor SOCK as device.  IDENTIFIER must be a string used for
     better error reporting.  TRANSCODER must be a transcoder object.
     Closing the Scheme port will close the socket descriptor too.

     Socket ports do *not* support port position operations.

 -- Function: make-textual-socket-input/output-port* SOCK IDENTIFIER
          TRANSCODER
     Build and return a textual Scheme port using the platform socket
     descriptor SOCK as device.  IDENTIFIER must be a string used for
     better error reporting.  TRANSCODER must be a transcoder object.
     Closing the Scheme port will *not* close the socket descriptor.

     Socket ports do *not* support port position operations.

 -- Function: read-line
 -- Function: read-line PORT
     Read from the textual input PORT up to and including the linefeed
     character or end of file, decoding characters in the same manner as
     'get-string-n' and 'get-string-n!'.  This function is exactly like
     'get-line', defined by '(rnrs io ports (6))', but it uses the
     return value of 'current-input-port' if no PORT argument is used.

 -- Function: get-string-some PORT
     Defined by Vicare.  Read from the textual input PORT, blocking as
     necessary, until characters are available or until an end of file
     is reached.

     If characters become available, 'get-string-some' returns a freshly
     allocated string containing the initial available characters (at
     least one), and it updates PORT to point just past these
     characters.

     If no input characters are available: the EOF object is returned.

 -- Function: with-input-from-string STRING THUNK
     THUNK must be a procedure and it must accept zero arguments.
     STRING must be a Scheme string.

     The STRING is used as argument for 'open-string-input-port'; during
     the dynamic extent of the call to THUNK, the obtained port is made
     the value returned by 'current-input-port'; the previous default
     value is reinstated when the dynamic extent is exited.

     When THUNK returns, the port is closed automatically.  The values
     returned by THUNK are returned.

     If, after THUNK has returned, an escape procedure is used to
     reenter the dynamic extent of the call to THUNK: the behaviour is
     unspecified.

 -- Function: with-output-to-string THUNK
     Create a textual output port that accumulates the characters
     written to it, set it as the current output port and call THUNK
     with no arguments.  The port is the current output port only for
     the extent of the call to THUNK.

     Whenever THUNK returns, a string consisting of all of the port's
     accumulated characters (regardless of the port's current position)
     is returned and the port is closed.


File: vicare-scheme.info,  Node: iklib io buffer,  Next: iklib io plists,  Prev: iklib io textual,  Up: iklib io

6.44.6 Buffer size customisation
--------------------------------

The following bindings are exported by the '(vicare)' library.

 -- Parameter: bytevector-port-buffer-size
 -- Parameter: bytevector-port-buffer-size FIXNUM
     Hold the buffer size for bytevector ports, like the one returned by
     'open-bytevector-output-port'.  It is initialised to 16384.

 -- Parameter: string-port-buffer-size
 -- Parameter: string-port-buffer-size FIXNUM
     Hold the buffer size for string ports, like the one returned by
     'open-string-output-port'.  It is initialised to 256.

 -- Parameter: input-file-buffer-size
 -- Parameter: input-file-buffer-size FIXNUM
     Hold the buffer size for input file ports, like the one returned by
     'open-input-file'.  It is initialised to 16384.

 -- Parameter: output-file-buffer-size
 -- Parameter: output-file-buffer-size FIXNUM
     Hold the buffer size for output file ports, like the one returned
     by 'open-output-file'.  It is initialised to 16384.

 -- Parameter: input/output-file-buffer-size
 -- Parameter: input/output-file-buffer-size FIXNUM
     Hold the buffer size for input/output file ports, like the one
     returned by 'open-file-input/output-prot'.  It is initialised to
     16384.

 -- Parameter: input/output-socket-buffer-size
 -- Parameter: input/output-socket-buffer-size FIXNUM
     Hold the buffer size for socket ports.  It is initialised to 16384.


File: vicare-scheme.info,  Node: iklib io plists,  Next: iklib io misc,  Prev: iklib io buffer,  Up: iklib io

6.44.7 Port property lists
--------------------------

Port property work like symbol property lists; they are a simple way to
tag I/O ports with values.

 -- Function: port-putprop PORT KEY VALUE
     Add a new property KEY with VALUE to the property list of PORT.  If
     KEY is already set: the old entry is mutated to reference VALUE.
     KEY must be a symbol.

 -- Function: port-getprop PORT KEY
     Return the value of the property KEY in the property list of PORT;
     if KEY is not set return '#f'.  KEY must be a symbol.

 -- Function: port-remprop PORT KEY
     Remove the property KEY from the property list of PORT.  KEY must
     be a symbol.

 -- Function: port-property-list PORT
     Return a new association list representing the property list of
     PORT.


File: vicare-scheme.info,  Node: iklib io misc,  Prev: iklib io plists,  Up: iklib io

6.44.8 Miscellaneous port functions
-----------------------------------

The following bindings are exported by the '(vicare)' library.

 -- Function: input-only-port? OBJ
 -- Function: input-only-port? OBJ
     Return a boolean, '#t' if OBJ is a port and it is, respectively, an
     input-only or an output-only port; otherwise return '#f'.  If OBJ
     is an input/output port: return '#f'.

 -- Function: input/output-port? OBJ
     Return a boolean, '#t' if OBJ is a port and it is an input and
     output port; otherwise return '#f'.  If OBJ is an input-only or
     output-only port: return '#f'.

 -- Function: port-fd PORT
     If PORT is a port with a file descriptor as device: return a fixnum
     representing the device, else return '#f'.

 -- Function: port-id PORT
     Return a Scheme string representing the identifier of PORT.

 -- Function: port-uid PORT
     Return a gensym uniquely associated to PORT.  The gensym is
     generated the first time this function is applied to PORT.

 -- Function: port-hash PORT
     Return a fixnum associated to PORT to be used as hash key.  The
     gensym is generated the first time this function is applied to
     PORT.

 -- Function: port-closed? PORT
     Return '#t' if PORT has already been closed, else return '#f'.

 -- Function: open-port? OBJ
 -- Function: closed-port? OBJ
     Return '#t' if OBJ is a port and it is, respectively, open or
     closed; otherwise return '#f'.

 -- Function: open-input-port? OBJ
 -- Function: open-output-port? OBJ
 -- Function: open-input/output-port? OBJ
     Return '#t' if OBJ is an open port and, respectively, it is input,
     output or input/output.

 -- Function: set-port-buffer-mode! PORT BUFFER-MODE
     Reset the port buffer mode to BUFFER-MODE, which must be one of the
     arguments accepted by 'buffer-mode'.  It is an error to select
     'line' mode if PORT is a binary port.

 -- Function: port-dump-status PORT
     To be used for debugging purposes.  Write to the current error port
     some informations on the internals of PORT.

 -- Function: reset-input-port! INPUT-PORT
 -- Function: reset-output-port! OUTPUT-PORT
     Reset to empty the port buffer; return unspecified values.  These
     procedures should be used to attempt an error recovery, only when
     the port's underlying device is stateless, for example at the REPL.

 -- Function: make-file-options LIST-OF-SYMBOLS
     Return an enumeration set as defined by 'file-options'.

 -- Syntax: file-options ?FILE-OPTIONS-SYMBOL ...
     As defined by R6RS: return a file-options object that encapsulates
     the specified options.  Each ?FILE-OPTIONS-SYMBOL must be a symbol.

     Vicare extends the standard options adding the following:

     'executable'
          Open the file with executable permissions; before the process'
          file mode creation mask is applied, executable permissions are
          granted to user, group and others.  *note Set file mode
          creation mask: (*manpages*)umask.


File: vicare-scheme.info,  Node: iklib pointers,  Next: iklib memory,  Prev: iklib io,  Up: iklib

6.45 Handling pointer objects
=============================

Pointer objects are a disjoint type identified by the 'pointer?'
predicate.

* Menu:

* iklib pointers cons::         Constructors.
* iklib pointers pred::         Predicates.
* iklib pointers compar::       Comparison.
* iklib pointers conv::         Conversion.
* iklib pointers misc::         Miscellaneous operations.
* iklib pointers poke::         Poking values.
* iklib pointers peek::         Peeking values.
* iklib arrays poke::           Poking values into arrays.
* iklib arrays peek::           Peeking values from arrays.


File: vicare-scheme.info,  Node: iklib pointers cons,  Next: iklib pointers pred,  Up: iklib pointers

6.45.1 Constructors
-------------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: null-pointer
     Return a newly allocated pointer object representing 'NULL'.

 -- Function: pointer-clone PTR
     Return a new pointer object being a copy of PTR.  This is useful
     when we need a pointer that might be reset to another value in the
     future.


File: vicare-scheme.info,  Node: iklib pointers pred,  Next: iklib pointers compar,  Prev: iklib pointers cons,  Up: iklib pointers

6.45.2 Predicates
-----------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: pointer? OBJ
     Return '#t' if OBJ is a pointer object, return '#f' otherwise.

 -- Function: false-or-pointer? OBJ
     Return '#t' if OBJ is a pointer object or '#f', return '#f'
     otherwise.

 -- Function: pointer-null? OBJ
     Return '#t' if OBJ is a pointer object and it represents 'NULL';
     otherwise return '#f'.  If OBJ is not a pointer: return '#f'.

 -- Function: pointer-non-null? OBJ
     Return '#t' if OBJ is a pointer object and it is not 'NULL';
     otherwise return '#f'.  If OBJ is not a pointer: return '#f'.

 -- Function: pointer-and-offset? PTR DIFF
     Return true if the exact integer DIFF can be added to PTR without
     causing a pointer overflow or underflow.

 -- Function: list-of-pointers? OBJ
     Return '#t' if OBJ is a, possibly empty, proper list of pointer
     objects; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib pointers compar,  Next: iklib pointers conv,  Prev: iklib pointers pred,  Up: iklib pointers

6.45.3 Comparison
-----------------

When applied to pointer objects:

   * The result of calling 'eq?' is true only if the two arguments are
     both pointers and they refer to the same Scheme storage location.

   * The result of calling 'eqv?' and 'equal?' is true only if the two
     arguments are both pointers and they reference the same raw memory
     location.

pointers also have 'pointer=?' as specialised comparison predicate.

   The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: pointer=? PTR0 PTR ...
 -- Function: pointer<? PTR0 PTR ...
 -- Function: pointer>? PTR0 PTR ...
 -- Function: pointer<=? PTR0 PTR ...
 -- Function: pointer>=? PTR0 PTR ...
     Compare the pointer arguments as indicated by the name.

 -- Function: pointer!=? PTR0 PTR ...
     The arguments must be pointers.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.

 -- Function: pointer-max PTR0 PTR ...
 -- Function: pointer-min PTR0 PTR ...
     Return the maximal or minimal pointer argument according to
     'pointer<?'.


File: vicare-scheme.info,  Node: iklib pointers conv,  Next: iklib pointers misc,  Prev: iklib pointers compar,  Up: iklib pointers

6.45.4 Conversion
-----------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: pointer->integer POINTER
     Convert the value of POINTER to an exact integer value.  The result
     may be a fixnum or a bignum depending on the pointer.

 -- Function: integer->pointer EXACT-INTEGER
     Convert EXACT-INTEGER to a pointer value.  The argument must be
     non-negative and in the appropriate range for 32-bit or 64-bit
     platforms.  It is guaranteed that:

          (integer->pointer (pointer->integer p))

     points to the same address as P.


File: vicare-scheme.info,  Node: iklib pointers misc,  Next: iklib pointers poke,  Prev: iklib pointers conv,  Up: iklib pointers

6.45.5 Miscellaneous operations
-------------------------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: set-pointer-null! POINTER
     Mutate the pointer object POINTER to represent the 'NULL' pointer.

 -- Function: pointer-diff PTR1 PTR2
     Return an exact integer representing the difference between the two
     pointer objects PTR1 and PTR2.  The returned value is such that:

          (pointer=? P (pointer-add Q (pointer-diff P Q)))
          => #t

 -- Function: pointer-add PTR DIFF
     Return a new pointer object holding the memory reference resulting
     from adding DIFF, which must be an exact integer, to PTR.  If the
     addition would cause an overflow or underflow in machine words:
     raise an assertion violation.


File: vicare-scheme.info,  Node: iklib pointers poke,  Next: iklib pointers peek,  Prev: iklib pointers misc,  Up: iklib pointers

6.45.6 Poking values
--------------------

With all the following functions: the MEMORY argument must be a valid
pointer object or 'memory-block' instance; the OFFSET argument must be
an exact integer in the range of the C language type 'ptrdiff_t'.  When
adding an offset to a pointer: all the following functions *do not*
scale the offset to the size of the poked value; pointer arithmetics is
performed with byte offsets.

   The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

Poking bitwise sized exact integers
...................................

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.

 -- Function: pointer-set-c-sint8! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-uint8! MEMORY OFFSET VALUE
     Set to VALUE the single byte of memory located at OFFSET from
     MEMORY.  VALUE must be an exact integer in the range representable
     by 8 bits.

 -- Function: pointer-set-c-sint16! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-uint16! MEMORY OFFSET VALUE
     Set to VALUE the two bytes of memory located at OFFSET from MEMORY.
     VALUE must be an exact integer in the range representable by 16
     bits.

 -- Function: pointer-set-c-sint32! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-uint32! MEMORY OFFSET VALUE
     Set to VALUE the four bytes of memory located at OFFSET from
     MEMORY.  VALUE must be an exact integer in the range representable
     by 32 bits.

 -- Function: pointer-set-c-sint64! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-uint64! MEMORY OFFSET VALUE
     Set to VALUE the eigth bytes of memory located at OFFSET from
     MEMORY.  VALUE must be an exact integer in the range representable
     by 64 bits.

Poking C language exact integers
................................

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.

 -- Function: pointer-set-c-signed-char! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-unsigned-char! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'signed char'
     or 'unsigned char' type located at OFFSET from MEMORY.

 -- Function: pointer-set-c-signed-short! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-unsigned-short! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'signed short
     int' or 'unsigned short int' type located at OFFSET from MEMORY.

 -- Function: pointer-set-c-signed-int! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-unsigned-int! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'signed int' or
     'unsigned int' type located at OFFSET from MEMORY.

 -- Function: pointer-set-c-signed-long! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-unsigned-long! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'signed long'
     or 'unsigned long' type located at OFFSET from MEMORY.

 -- Function: pointer-set-c-signed-long-long! MEMORY OFFSET VALUE
 -- Function: pointer-set-c-unsigned-long-long! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'signed long
     long' or 'unsigned long long' type located at OFFSET from MEMORY.

 -- Function: pointer-set-c-size_t! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'size_t' type
     located at OFFSET from MEMORY.

 -- Function: pointer-set-c-ssize_t! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'ssize_t' type
     located at OFFSET from MEMORY.

 -- Function: pointer-set-c-off_t! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'off_t' type
     located at OFFSET from MEMORY.

 -- Function: pointer-set-c-ptrdiff_t! MEMORY OFFSET VALUE
     Set to VALUE a number of bytes corresponding to the 'ptrdiff_t'
     type located at OFFSET from MEMORY.

Poking floating point numbers
.............................

 -- Function: pointer-set-c-float! MEMORY OFFSET FLONUM
     Convert the Scheme floating point number FLONUM (represented in
     Vicare as an IEEE 754 double precision floating point number) to a
     float (an IEEE 754 single precision floating point number) and
     store the result in the four bytes at OFFSET from MEMORY.

 -- Function: pointer-set-c-double! MEMORY OFFSET FLONUM
     Store the double precision IEEE 754 floating point value of the
     Scheme FLONUM in the eight bytes at OFFSET from MEMORY.

 -- Function: pointer-set-c-double-complex! MEMORY OFFSET CFLONUM
     Store the double precision IEEE 754 floating point values composing
     the Scheme CFLONUM in the 16 bytes at OFFSET from MEMORY, real part
     at the lowest address.

Poking pointers
...............

 -- Function: pointer-set-c-pointer! MEMORY OFFSET VALUE
     Store address of the raw memory location referenced by the pointer
     VALUE at OFFSET from MEMORY.


File: vicare-scheme.info,  Node: iklib pointers peek,  Next: iklib arrays poke,  Prev: iklib pointers poke,  Up: iklib pointers

6.45.7 Peeking values
---------------------

With all the following functions: the MEMORY argument must be a valid
pointer object; the OFFSET argument must be an exact integer in the
range of the C language type 'ptrdiff_t'.  When adding an offset to a
pointer: all the following functions *do not* scale the offset to the
size of the peeked value; pointer arithmetics is performed with byte
offsets.

   The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

Peeking bitwise sized exact integers
....................................

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.

 -- Function: pointer-ref-c-sint8 MEMORY OFFSET
 -- Function: pointer-ref-c-uint8 MEMORY OFFSET
     Peek the 8 bits located at OFFSET from MEMORY and return them as
     signed or unsigned exact integer.

 -- Function: pointer-ref-c-sint16 MEMORY OFFSET
 -- Function: pointer-ref-c-uint16 MEMORY OFFSET
     Peek the 16 bits located at OFFSET from MEMORY and return them as
     signed or unsigned exact integer.

 -- Function: pointer-ref-c-sint32 MEMORY OFFSET
 -- Function: pointer-ref-c-uint32 MEMORY OFFSET
     Peek the 32 bits located at OFFSET from MEMORY and return them as
     signed or unsigned exact integer.

 -- Function: pointer-ref-c-sint64 MEMORY OFFSET
 -- Function: pointer-ref-c-uint64 MEMORY OFFSET
     Peek the 64 bits located at OFFSET from MEMORY and return them as
     signed or unsigned exact integer.

Peeking C language exact integers
.................................

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.

 -- Function: pointer-ref-c-signed-char MEMORY OFFSET
 -- Function: pointer-ref-c-signed-char MEMORY OFFSET
     Peek the 'signed char' or 'unsigned char' integer located at OFFSET
     from MEMORY and return it as signed or unsigned exact integer.

 -- Function: pointer-ref-c-signed-short MEMORY OFFSET
 -- Function: pointer-ref-c-unsigned-short MEMORY OFFSET
     Peek the 'signed short int' or 'unsigned short int' integer located
     at OFFSET from MEMORY and return it as signed or unsigned exact
     integer.

 -- Function: pointer-ref-c-signed-int MEMORY OFFSET
 -- Function: pointer-ref-c-unsigned-int MEMORY OFFSET
     Peek the 'signed int' or 'unsigned int' integer located at OFFSET
     from MEMORY and return it as signed or unsigned exact integer.

 -- Function: pointer-ref-c-signed-long MEMORY OFFSET
 -- Function: pointer-ref-c-unsigned-long MEMORY OFFSET
     Peek the 'signed long' or 'unsigned long' integer located at OFFSET
     from MEMORY and return it as signed or unsigned exact integer.

 -- Function: pointer-ref-c-signed-long-long MEMORY OFFSET
 -- Function: pointer-ref-c-unsigned-long-long MEMORY OFFSET
     Peek the 'signed long long' or 'unsigned long long' integer located
     at OFFSET from MEMORY and return it as signed or unsigned exact
     integer.

 -- Function: pointer-ref-c-size_t MEMORY OFFSET
     Peek the 'size_t' integer located at OFFSET from MEMORY and return
     it as exact integer.

 -- Function: pointer-ref-c-ssize_t MEMORY OFFSET
     Peek the 'ssize_t' integer located at OFFSET from MEMORY and return
     it as exact integer.

 -- Function: pointer-ref-c-off_t MEMORY OFFSET
     Peek the 'off_t' integer located at OFFSET from MEMORY and return
     it as exact integer.

 -- Function: pointer-ref-c-ptrdiff_t MEMORY OFFSET
     Peek the 'ptrdiff_t' integer located at OFFSET from MEMORY and
     return it as exact integer.

Peeking floating point numbers
..............................

 -- Function: pointer-ref-c-float MEMORY OFFSET
     Return the four-byte float (represented as IEEE 754 single
     precision floating point number) stored at OFFSET from MEMORY.  The
     value is extended to an IEEE 754 double precision floating point
     number that Vicare uses to represent inexact numbers.

 -- Function: pointer-ref-c-double MEMORY OFFSET
     Return the eight-byte float (represented as IEEE 754 double
     precision floating point number) stored at OFFSET from MEMORY.

 -- Function: pointer-ref-c-double-complex MEMORY OFFSET
     Return a cflonum built from the two eight-byte floats (represented
     as IEEE 754 double precision floating point numbers) stored at
     OFFSET from MEMORY, real part at the lowest address.

Peeking pointers
................

 -- Function: pointer-ref-c-pointer MEMORY OFFSET
     Return the pointer stored at OFFSET from MEMORY.  The size of the
     pointer (also the number of bytes loaded) depends on the
     architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
     systems.


File: vicare-scheme.info,  Node: iklib arrays poke,  Next: iklib arrays peek,  Prev: iklib pointers peek,  Up: iklib pointers

6.45.8 Poking values into arrays
--------------------------------

With all the following functions: the MEMORY argument must be a valid
pointer object or 'memory-block' instance; the INDEX argument must be an
exact integer in the range of the C language type 'ptrdiff_t'.  When
adding an offset to a pointer: all the following functions *do* scale
the index to the size of the poked value.

   The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

Poking bitwise sized exact integers
...................................

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.

 -- Function: array-set-c-sint8! MEMORY INDEX VALUE
 -- Function: array-set-c-uint8! MEMORY INDEX VALUE
     Set to VALUE the single byte of memory located at INDEX from
     MEMORY.  VALUE must be an exact integer in the range representable
     by 8 bits.

 -- Function: array-set-c-sint16! MEMORY INDEX VALUE
 -- Function: array-set-c-uint16! MEMORY INDEX VALUE
     Set to VALUE the two bytes of memory located at INDEX from MEMORY.
     VALUE must be an exact integer in the range representable by 16
     bits.

 -- Function: array-set-c-sint32! MEMORY INDEX VALUE
 -- Function: array-set-c-uint32! MEMORY INDEX VALUE
     Set to VALUE the four bytes of memory located at INDEX from MEMORY.
     VALUE must be an exact integer in the range representable by 32
     bits.

 -- Function: array-set-c-sint64! MEMORY INDEX VALUE
 -- Function: array-set-c-uint64! MEMORY INDEX VALUE
     Set to VALUE the eight bytes of memory located at INDEX from
     MEMORY.  VALUE must be an exact integer in the range representable
     by 64 bits.

Poking C language exact integers
................................

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.

 -- Function: array-set-c-signed-char! MEMORY INDEX VALUE
 -- Function: array-set-c-unsigned-char! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'signed char'
     or 'unsigned char' type located at INDEX from MEMORY.

 -- Function: array-set-c-signed-short! MEMORY INDEX VALUE
 -- Function: array-set-c-unsigned-short! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'signed short
     int' or 'unsigned short int' type located at INDEX from MEMORY.

 -- Function: array-set-c-signed-int! MEMORY INDEX VALUE
 -- Function: array-set-c-unsigned-int! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'signed int' or
     'unsigned int' type located at INDEX from MEMORY.

 -- Function: array-set-c-signed-long! MEMORY INDEX VALUE
 -- Function: array-set-c-unsigned-long! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'signed long'
     or 'unsigned long' type located at INDEX from MEMORY.

 -- Function: array-set-c-signed-long-long! MEMORY INDEX VALUE
 -- Function: array-set-c-unsigned-long-long! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'signed long
     long' or 'unsigned long long' type located at INDEX from MEMORY.

 -- Function: array-set-c-size_t! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'size_t' type
     located at INDEX from MEMORY.

 -- Function: array-set-c-ssize_t! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'ssize_t' type
     located at INDEX from MEMORY.

 -- Function: array-set-c-off_t! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'off_t' type
     located at INDEX from MEMORY.

 -- Function: array-set-c-ptrdiff_t! MEMORY INDEX VALUE
     Set to VALUE a number of bytes corresponding to the 'ptrdiff_t'
     type located at INDEX from MEMORY.

Poking floating point numbers
.............................

 -- Function: array-set-c-float! MEMORY INDEX FLONUM
     Convert the Scheme floating point number FLONUM (represented in
     Vicare as an IEEE 754 double precision floating point number) to a
     float (an IEEE 754 single precision floating point number) and
     store the result in the four bytes at INDEX from MEMORY.

 -- Function: array-set-c-double! MEMORY INDEX FLONUM
     Store the double precision IEEE 754 floating point value of the
     Scheme FLONUM in the eight bytes at INDEX from MEMORY.

 -- Function: array-set-c-double-complex! MEMORY INDEX CFLONUM
     Store the double precision IEEE 754 floating point values composing
     the Scheme CFLONUM in the 16 bytes at INDEX from MEMORY.

Poking pointers
...............

 -- Function: array-set-c-pointer! MEMORY INDEX VALUE
     Store address of the raw memory location referenced by the pointer
     VALUE at INDEX from MEMORY.


File: vicare-scheme.info,  Node: iklib arrays peek,  Prev: iklib arrays poke,  Up: iklib pointers

6.45.9 Peeking values from arrays
---------------------------------

With all the following functions: the MEMORY argument must be a valid
pointer object; the INDEX argument must be an exact integer in the range
of the C language type 'ptrdiff_t'.  When adding an offset to a pointer:
all the following functions *do* scale the index to the size of the
peeked value.

   The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

Peeking bitwise sized exact integers
....................................

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.

 -- Function: array-ref-c-sint8 MEMORY INDEX
 -- Function: array-ref-c-uint8 MEMORY INDEX
     Peek the 8 bits located at INDEX from MEMORY and return them as
     signed or unsigned exact integer.

 -- Function: array-ref-c-sint16 MEMORY INDEX
 -- Function: array-ref-c-uint16 MEMORY INDEX
     Peek the 16 bits located at INDEX from MEMORY and return them as
     signed or unsigned exact integer.

 -- Function: array-ref-c-sint32 MEMORY INDEX
 -- Function: array-ref-c-uint32 MEMORY INDEX
     Peek the 32 bits located at INDEX from MEMORY and return them as
     signed or unsigned exact integer.

 -- Function: array-ref-c-sint64 MEMORY INDEX
 -- Function: array-ref-c-uint64 MEMORY INDEX
     Peek the 64 bits located at INDEX from MEMORY and return them as
     signed or unsigned exact integer.

Peeking C language exact integers
.................................

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.

 -- Function: array-ref-c-signed-char MEMORY INDEX
 -- Function: array-ref-c-signed-char MEMORY INDEX
     Peek the 'signed char' or 'unsigned char' integer located at INDEX
     from MEMORY and return it as signed or unsigned exact integer.

 -- Function: array-ref-c-signed-short MEMORY INDEX
 -- Function: array-ref-c-unsigned-short MEMORY INDEX
     Peek the 'signed short int' or 'unsigned short int' integer located
     at INDEX from MEMORY and return it as signed or unsigned exact
     integer.

 -- Function: array-ref-c-signed-int MEMORY INDEX
 -- Function: array-ref-c-unsigned-int MEMORY INDEX
     Peek the 'signed int' or 'unsigned int' integer located at INDEX
     from MEMORY and return it as signed or unsigned exact integer.

 -- Function: array-ref-c-signed-long MEMORY INDEX
 -- Function: array-ref-c-unsigned-long MEMORY INDEX
     Peek the 'signed long' or 'unsigned long' integer located at INDEX
     from MEMORY and return it as signed or unsigned exact integer.

 -- Function: array-ref-c-signed-long-long MEMORY INDEX
 -- Function: array-ref-c-unsigned-long-long MEMORY INDEX
     Peek the 'signed long long' or 'unsigned long long' integer located
     at INDEX from MEMORY and return it as signed or unsigned exact
     integer.

 -- Function: array-ref-c-size_t MEMORY INDEX
     Peek the 'size_t' integer located at INDEX from MEMORY and return
     it as signed or unsigned exact integer.

 -- Function: array-ref-c-ssize_t MEMORY INDEX
     Peek the 'ssize_t' integer located at INDEX from MEMORY and return
     it as signed or unsigned exact integer.

 -- Function: array-ref-c-off_t MEMORY INDEX
     Peek the 'off_t' integer located at INDEX from MEMORY and return it
     as signed or unsigned exact integer.

 -- Function: array-ref-c-ptrdiff_t MEMORY INDEX
     Peek the 'ptrdiff_t' integer located at INDEX from MEMORY and
     return it as signed or unsigned exact integer.

Peeking floating point numbers
..............................

 -- Function: array-ref-c-float MEMORY INDEX
     Return the four-byte float (represented as IEEE 754 single
     precision floating point number) stored at INDEX from MEMORY.  The
     value is extended to an IEEE 754 double precision floating point
     number that Vicare uses to represent inexact numbers.

 -- Function: array-ref-c-double MEMORY INDEX
     Return the eight-byte float (represented as IEEE 754 double
     precision floating point number) stored at INDEX from MEMORY.

 -- Function: array-ref-c-double-complex MEMORY INDEX
     Return a cflonum composed by the two eight-byte floats (represented
     as IEEE 754 double precision floating point numbers) stored at
     INDEX from MEMORY.

Peeking pointers
................

 -- Function: array-ref-c-pointer MEMORY INDEX
     Return the pointer stored at INDEX from MEMORY.  The size of the
     pointer (also the number of bytes loaded) depends on the
     architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
     systems.


File: vicare-scheme.info,  Node: iklib memory,  Next: iklib cstrings,  Prev: iklib pointers,  Up: iklib

6.46 Memory management
======================

* Menu:

* iklib memory intro::          Introduction to managing memory.
* iklib memory alloc::          Allocating and freeing memory.
* iklib memory ops::            Memory operations.
* iklib memory blocks::         Memory blocks.
* iklib memory condition::      Memory allocation condition objects.


File: vicare-scheme.info,  Node: iklib memory intro,  Next: iklib memory alloc,  Up: iklib memory

6.46.1 Introduction to managing memory
--------------------------------------

Vicare Scheme is a managed environment: Scheme objects are allocated in
a special memory region (the Scheme heap) and have type-specific object
layouts; this allows the run time system to distinguish object types and
the garbage collector to locate all potentially live objects, and
reclaim the memory of dead objects.

   Scheme objects are also _opaque_ in the sense that the data
structures used to represent Scheme objects are not exposed, at the
Scheme level, to the programmer who can only interact with objects
through an interface.

   Unmanaged environments, such as the operating system on which Vicare
runs, require that the programmer manages the allocation and
deallocation of system resources herself.  Memory regions, file handles,
external devices, the screen, etc., are all examples of resources whose
management must be coordinated among the different parts of the system,
and this becomes the responsibility of the programmer who is wiring the
different subsystems together.

   The procedures acting on pointer objects are meant to provide a way
to interface with the low level memory operations such as setting and
getting bytes from specific locations in memory.


File: vicare-scheme.info,  Node: iklib memory alloc,  Next: iklib memory ops,  Prev: iklib memory intro,  Up: iklib memory

6.46.2 Allocating and freeing memory
------------------------------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: malloc NUMBER-OF-BYTES
 -- Function: guarded-malloc NUMBER-OF-BYTES
     Interface to the C function 'malloc()', *note malloc: (libc)Basic
     Allocation.  Allocate a block of memory NUMBER-OF-BYTES wide;
     NUMBER-OF-BYTES must be an exact integer in the range of the C
     language type 'size_t'.  If successful return a pointer object; if
     allocation fails raise a non-continuable exception with components:
     '&who', '&message', '&out-of-memory-error'.

     Memory allocated by 'malloc' must be released by 'free'; memory
     allocated by 'guarded-malloc' is automatically released whenever
     the returned pointer object is garbage collected.

 -- Function: realloc MEMORY NUMBER-OF-BYTES
 -- Function: guarded-realloc MEMORY NUMBER-OF-BYTES
     Interface to the C function 'realloc()', *note realloc:
     (libc)Changing Block Size.  Reallocate the block of memory
     referenced by MEMORY to the new size NUMBER-OF-BYTES.

     MEMORY must be a pointer object or 'memory-block' instance.

     NUMBER-OF-BYTES must be an exact integer in the range of the C
     language type 'size_t'.

     If successful: mutate the pointer in MEMORY to reference the new
     memory block and return MEMORY itself; when MEMORY is a
     'memory-block': mutate the size field to NUMBER-OF-BYTES.  If
     reallocation fails raise a non-continuable exception with
     components: '&who', '&message', '&out-of-memory-error' and leave
     untouched both MEMORY and its referenced memory.

     Memory allocated by 'realloc' must be released by 'free', unless
     MEMORY was already scheduled to be removed by the garbage
     collector; when 'guarded-realloc' is used:

        * When MEMORY is a pointer object: the allocated memory is
          automatically released whenever the returned pointer object is
          garbage collected.  If MEMORY was already scheduled to be
          removed by the garbage collector: we should use 'realloc' not
          'guarded-realloc'.

        * When MEMORY is an instance of 'memory-block': the allocated
          memory is automatically released by the garbage collector only
          if 'memory-block' was built by 'make-memory-block/guarded'.

 -- Function: calloc NUMBER-OF-ELEMENTS ELEMENT-SIZE
 -- Function: guarded-calloc NUMBER-OF-ELEMENTS ELEMENT-SIZE
     Interface to the C function 'calloc()', *note calloc:
     (libc)Allocating Cleared Space.  Allocate and clear to zero a block
     of memory capable of holding NUMBER-OF-ELEMENTS each ELEMENT-SIZE
     wide; both the arguments must be exact integers in the range of the
     C language type 'size_t'.  If successful return a pointer object;
     if allocation fails raise a non-continuable exception with
     components: '&who', '&message', '&out-of-memory-error'.

     Memory allocated by 'calloc' must be released by 'free'; memory
     allocated by 'guarded-calloc' is automatically released whenever
     the returned pointer object is garbage collected.

 -- Function: free MEMORY
     Release the memory referenced by MEMORY, which must be either a
     pointer object returned by 'malloc()', 'realloc()', 'calloc()' or a
     similar system procedure or an instance of 'memory-block'.  The
     pointer object in MEMORY is mutated to reference the 'NULL'
     pointer; when MEMORY is a 'memory-block': the 'size' field is also
     reset to zero.

     If memory allocated by a guarding function is released by 'free':
     Vicare will *not* try to automatically release the old memory
     again.

     If the pointer in MEMORY is 'NULL' nothing happens.

 -- Function: with-local-storage LENGTHS PROC
     Call PROC with arguments being pointers to memory blocks allocated
     just for the dynamic extent of PROC.  The number and size of the
     memory blocks is determined by LENGTHS, which must be a vector of
     non-negative fixnums.

     *NOTE* We must not let control flow go through a call to
     'with-local-storage' with an escaping continuation.

          #!r6rs
          (import (rnrs)
            (prefix (vicare ffi) ffi.))

          ;; no allocated memory
          (let ((a 1) (b 2))
            (ffi.with-local-storage '#()
              (lambda ()
                (+ a b 4))))
          => 7

          ;; allocate a single block of 4 bytes
          (let ((a 1) (b 2))
            (ffi.with-local-storage '#(4)
              (lambda (&int32)
                (ffi.pointer-set-c-sint32! &int32 0 4)
                (+ a b (ffi.pointer-ref-c-sint32 &int32 0)))))
          => 7

          ;; allocate two blocks of 4 and 8 bytes
          (let ((a 1) (b 2))
            (ffi.with-local-storage '#(4 8)
              (lambda (&int32 &int64)
                (ffi.pointer-set-c-sint32! &int32 0 4)
                (ffi.pointer-set-c-sint64! &int64 0 8)
                (+ a b
                   (ffi.pointer-ref-c-sint32 &int32 0)
                   (ffi.pointer-ref-c-sint64 &int64 0)))))
          => 15

     The memory blocks are actually allocated on the stack of Vicare's
     runtime.


File: vicare-scheme.info,  Node: iklib memory ops,  Next: iklib memory blocks,  Prev: iklib memory alloc,  Up: iklib memory

6.46.3 Memory operations
------------------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: memcpy DST SRC COUNT
     Interface to the C function 'memcpy()', *note memcpy: (libc)Copying
     and Concatenation.  Copy COUNT bytes from the memory referenced by
     the pointer SRC to the memory referenced by the pointer DST; COUNT
     must be an exact integer in the range of the C language type
     'size_t'.  The two memory regions must not overlap.  Return
     unspecified values.

 -- Function: memmove DST SRC COUNT
     Interface to the C function 'memmove()', *note memmove:
     (libc)Copying and Concatenation.  Copy COUNT bytes from the memory
     referenced by the pointer SRC to the memory referenced by the
     pointer DST; COUNT must be an exact integer in the range of the C
     language type 'size_t'.  The two memory regions can be overlapping.
     Return unspecified values.

 -- Function: memset PTR VALUE COUNT
     Interface to the C function 'memset()', *note memset: (libc)Copying
     and Concatenation.Set to VALUE COUNT bytes of the memory referenced
     by the pointer PTR.  COUNT must be an exact integer in the range of
     the C language type 'size_t', VALUE must be an exact fixnum in the
     range [-128, 255].  Return unspecified values.

 -- Function: memcmp POINTER1 POINTER2 COUNT
     Interface to the C function 'memcmp()', *note memcmp:
     (libc)String/Array Comparison.  Compare COUNT bytes in the memory
     blocks referenced by POINTER1 and POINTER2, return a fixnum
     representing the classic comparison ternary result.  COUNT must be
     an exact integer in the range of the C language type 'size_t'.

 -- Function: memory-copy dst dst.start src src.start count
     Copy COUNT bytes from SRC starting at offset SRC.START to DST
     starting at offset DST.START.  SRC and DST can be pointers or
     bytevectors; DST.START, SRC.START and COUNT must be non-negative
     fixnums.  The two memory regions must not overlap.  Return
     unspecified values.

 -- Function: memory->bytevector POINTER NUMBER-OF-BYTES
     Build and return a new bytevector object holding NUMBER-OF-BYTES
     from the memory region starting at POINTER.  NUMBER-OF-BYTES must
     be a non-negative fixnum.

 -- Function: bytevector->memory BV
 -- Function: bytevector->guarded-memory BV
     Allocate a new raw memory block and copy into it the contents of
     BV.  If successful return two values being the pointer object
     referencing the memory and a fixnum representing the length of the
     memory block; if allocation fails raise a non-continuable exception
     with components: '&who', '&message', '&out-of-memory-error'.

     Memory allocated by 'bytevector->memory' must be released by
     'free'; memory allocated by 'bytevector->guarded-memory' is
     automatically released whenever the returned pointer object is
     garbage collected.


File: vicare-scheme.info,  Node: iklib memory blocks,  Next: iklib memory condition,  Prev: iklib memory ops,  Up: iklib memory

6.46.4 Memory blocks
--------------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Object Type: '<memory-block>'
     Disjoint object used to reference a raw memory block through a
     pointer and number of bytes.  It has the following public fields:

     'pointer'
          A pointer object referencing the first byte of memory.

     'size'
          The number of bytes in the memory block; it is an exact
          integer in the range of the C language type 'size_t'.

 -- Function: make-memory-block POINTER SIZE
 -- Function: make-memory-block/guarded POINTER SIZE
     Build and return a new instance of 'memory-block' referencing a
     memory block pointed to by POINTER and of SIZE number of bytes.

     When a 'memory-block' built by 'make-memory-block' is garbage
     collected: nothing happens.

     When a 'memory-block' built by 'make-memory-block/guarded' is
     garbage collected: the referenced memory block is released with
     'free' from '(vicare)'.

 -- Function: memory-block? OBJ
     Return '#t' if OBJ is an instance of 'memory-block'.

 -- Function: memory-block?/non-null OBJ
 -- Function: memory-block?/not-null OBJ
     Return '#t' if OBJ is an instance of 'memory-block' and the pointer
     is not 'NULL'.

 -- Function: memory-block-pointer MBLOCK
 -- Function: memory-block-size MBLOCK
     Accessors for the fields of 'memory-block' instances.  The pointer
     object returned by 'memory-block-pointer' is a copy of the pointer
     object in MBLOCK.

 -- Function: memory-block-reset MBLOCK
     Reset an instance of 'memory-block' to a 'NULL' pointer and zero
     size; return unspecified values.  If MBLOCK has been created to
     release the referenced memory block: the memory block is freed.

 -- Function: null-memory-block
     Build and return a new instance of 'memory-block' holding a new
     'NULL' pointer object and zero as size.

 -- Function: memory-block=? MBLOCK0 MBLOCK ...
     All the arguments must be instances of '<memory-block>'.  Return
     '#t' if all the arguments have equal memory address and block size;
     otherwise return '#f'.  When applied to a single argument: return
     '#t'.

 -- Function: memory-block!=? MBLOCK0 MBLOCK ...
     The arguments must be '<memory-block>' instances.  Return '#t' if
     the arguments are all different: no two arguments are equal;
     otherwise return '#f'.  When applied to a single argument: return
     '#f'.


File: vicare-scheme.info,  Node: iklib memory condition,  Prev: iklib memory blocks,  Up: iklib memory

6.46.5 Memory allocation condition objects
------------------------------------------

The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Condition Type: &out-of-memory-error
     Condition object type used to tag conditions representing memory
     allocation errors; it is derived from '&error'.  It has no fields.

 -- Function: make-out-of-memory-error
 -- Function: out-of-memory-error? OBJ
     Maker and predicate for condition objects of type
     '&out-of-memory-error'.


File: vicare-scheme.info,  Node: iklib cstrings,  Next: iklib errno,  Prev: iklib memory,  Up: iklib

6.47 Raw C strings
==================

The following functions perform operations on raw ASCII coded strings
terminated by a zero byte, for short ASCIIZ strings; some functions act
upon raw UTF-16 strings.  The following bindings are exported by the
libraries '(vicare)' and '(vicare system $foreign)' and reexported by
the library '(vicare ffi)'.

 -- Function: bytevector->cstring BV
 -- Function: bytevector->guarded-cstring BV
     Convert from a Scheme bytevector to an ASCIIZ string.  If
     successful return a pointer object referencing the string, else
     return '#f'.

     Memory allocated by 'bytevector->cstring' must be explicitly
     released by 'free'; memory allocated by
     'bytevector->guarded-cstring' is automatically released by the
     garbage collector whenever the returned pointer is garbage
     collected.

 -- Function: bytevector->cstring* BV
 -- Function: bytevector->guarded-cstring* BV
     Like 'bytevector->cstring' and 'bytevector->guarded-cstring', but
     if allocation fails raise a non-continuable exception with
     components: '&who', '&message', '&out-of-memory-error'.

 -- Function: cstring->bytevector POINTER
 -- Function: cstring->bytevector POINTER COUNT
     Convert between an ASCIIZ string and a Scheme bytevector.  When
     used, COUNT must be a fixnum representing the number of bytes to
     include in the bytevector.

 -- Function: string->cstring STR
 -- Function: string->guarded-cstring STR
     Convert from a Scheme string to an ASCIIZ string.  If successful
     return a pointer object referencing the string, else return '#f'.

     The string argument must contain only characters with Unicode code
     points in the range [0, 255].

     Memory allocated by 'string->cstring' must be explicitly released
     by 'free'; memory allocated by 'string->guarded-cstring' is
     automatically released by the garbage collector whenever the
     returned pointer is garbage collected.

 -- Function: cstring16->bytevector POINTER
     Convert between an UTF-16 string and a Scheme bytevector; this
     function works with all the possible encodings of the string.  The
     end of the string is determined by searching for a sequence of two
     consecutive zero bytes, starting at even offset.

 -- Function: cstring16n->string POINTER
 -- Function: cstring16le->string POINTER
 -- Function: cstring16be->string POINTER
     Like 'cstring16->bytevector', but convert the result to a Scheme
     string assuming the specified byte order (native, little endian,
     big endian).

 -- Function: string->cstring* STR
 -- Function: string->guarded-cstring* STR
     Like 'string->cstring' and 'string->guarded-cstring', but if
     allocation fails raise a non-continuable exception with components:
     '&who', '&message', '&out-of-memory-error'.

 -- Function: cstring->string POINTER
 -- Function: cstring->string POINTER COUNT
     Convert between an ASCIIZ string and a Scheme string.  When used,
     COUNT must be a fixnum representing the number of bytes to include
     in the string.

 -- Function: strlen POINTER
     Interface to the C function 'strlen()', *note strlen: (libc)String
     Length.  Return an exact integer representing the length of the
     ASCIIZ string referenced by POINTER.

 -- Function: strcmp POINTER1 POINTER2
     Interface to the C function 'strcmp()', *note strcmp:
     (libc)String/Array Comparison.  Return a fixnum representing the
     classic comparison ternary result of comparing the ASCIIZ strings
     referenced by POINTER1 and POINTER2.

 -- Function: strncmp POINTER1 POINTER2 COUNT
     Interface to the C function 'strncmp()', *note strncmp:
     (libc)String/Array Comparison.  Return a fixnum representing the
     classic comparison ternary result of comparing the first COUNT
     bytes in the ASCIIZ strings referenced by POINTER1 and POINTER2.
     COUNT must be an exact integer in the range of the C language type
     'size_t'.

 -- Function: strdup POINTER
 -- Function: guarded-strdup POINTER
     Interface to the C function 'strdup()', *note strdup: (libc)Copying
     and Concatenation.  Duplicate the ASCIIZ string referenced by
     POINTER; if successful return a new pointer object, if allocation
     fails raise a non-continuable exception with components: '&who',
     '&message', '&out-of-memory-error'

     Memory allocated by 'strdup' must be explicitly released by 'free';
     memory allocated by 'guarded-strdup' is automatically released by
     the garbage collector whenever the returned pointer is garbage
     collected.

 -- Function: strndup POINTER COUNT
 -- Function: guarded-strndup POINTER COUNT
     Interface to the C function 'strndup()', *note strndup:
     (libc)Copying and Concatenation.  Duplicate the first COUNT bytes
     in the ASCIIZ string referenced by POINTER; if successful return a
     new pointer object, if allocation fails raise a non-continuable
     exception with components: '&who', '&message',
     '&out-of-memory-error'.  COUNT must be an exact integer in the
     range of the C language type 'size_t'.

     Memory allocated by 'strdup' must be explicitly released by 'free';
     memory allocated by 'guarded-strdup' is automatically released by
     the garbage collector whenever the returned pointer is garbage
     collected.

 -- Function: bytevectors->argv LIST-OF-BYTEVECTORS
 -- Function: bytevectors->guarded-argv LIST-OF-BYTEVECTORS
     Given a list of bytevectors: convert them into ASCIIZ strings and
     build a 'NULL' terminated array of C pointers referencing the
     strings.  The strings and the array are stored in a single memory
     block.  If successful return the pointer object; if allocation
     fails raise a non-continuable exception with components: '&who',
     '&message', '&out-of-memory-error'.

     Memory allocated by 'bytevectors->argv' must be explicitly released
     by 'free'; memory allocated by 'bytevectors->guarded-argv' is
     automatically released by the garbage collector whenever the
     returned pointer is garbage collected.

 -- Function: argv->bytevectors POINTER
     Given a pointer to a 'NULL' terminated array of C pointers
     referencing ASCIIZ strings: build and return a list of bytevectors
     holding the same bytes of the strings.

 -- Function: strings->argv LIST-OF-STRINGS
 -- Function: strings->guarded-argv LIST-OF-STRINGS
     Given a list of Scheme strings: convert them into ASCIIZ strings
     and build a 'NULL' terminated array of C pointers referencing the
     strings.  If successful return a pointer to the array; if
     allocation fails raise a non-continuable exception with components:
     '&who', '&message', '&out-of-memory-error'.  The strings and the
     array are stored in a single memory block.

     The string arguments must contain only characters with Unicode code
     points in the range [0, 255].

     Memory allocated by 'strings->argv' must be explicitly released by
     'free'; memory allocated by 'strings->guarded-argv' is
     automatically released by the garbage collector whenever the
     returned pointer is garbage collected.

 -- Function: argv->strings POINTER
     Given a pointer to a 'NULL' terminated array of C pointers
     referencing ASCIIZ strings: build and return a list of strings
     holding the same bytes of the strings.

 -- Function: argv-length ARGV
     Return the number of strings in the 'NULL'-terminated array of
     strings referenced by the ARGV pointer.


File: vicare-scheme.info,  Node: iklib errno,  Next: iklib time,  Prev: iklib cstrings,  Up: iklib

6.48 Interface to 'errno'
=========================

Most C language system functions report errors by setting a the special
variable 'errno' to some predefined integer constant, *note errno:
(libc)Checking for Errors.  The Scheme code accessing 'errno' values
should be agnostic with respect to the actual error codes; for this to
happen we should use the following facilities along with bindings from
'(vicare platform errno)', *note More features for 'errno':
(vicare-libs)errno. for details.

   Values for the C language variable 'errno' are encoded as negated
fixnum values: if 'EPERM' is defined to '1' at the C language level,
Vicare defines it as the fixnum '-1'; at present all the known error
codes fit into fixnums range.  One syntax identifier binding for each
known 'errno' value is exported by the library '(vicare platform errno)'
and reexported by the library '(vicare platform constants)'.

   If some error codes are not defined on a platform: the corresponding
binding evaluates to '#t'.  Notice that if no error occurred 'errno' is
set to the fixnum zero.

   The following bindings are exported by the libraries '(vicare)' and
'(vicare system $foreign)' and reexported by the library '(vicare ffi)'.

 -- Function: errno
 -- Function: errno CODE
     Interface to the C language level 'errno' variable to be used with
     the foreign-functions interface (FFI).

     When called with no values return the value of the C variable
     'errno' right after the last call to a C function performed by the
     current process through the FFI.  When called with one argument:
     set the C variable 'errno' of the current process to CODE,
     appropriately handling the coding of the value.

     Notice that bindings exported by '(vicare posix)', '(vicare glibc)'
     and '(vicare linux)' do *not* use this mechanism; rather they raise
     an exception whenever an error happen.

     As special cases: when the C variable 'errno' is set to zero,
     'errno' returns '#f'; when CODE is '#f', the C variable 'errno' is
     set to zero; when CODE is '#t', the C variable 'errno' is set to
     'EFAULT'.

     The mechanism is such that the following form:

          (let ((rv (call-foreign-function)))
            (values rv (errno)))

     performs a foreign-function call and evaluates to two values: the
     return value from the foreign function and the value of the C
     variable 'errno' right after the foreign call.


File: vicare-scheme.info,  Node: iklib time,  Next: iklib readline,  Prev: iklib errno,  Up: iklib

6.49 Basic time and date functions
==================================

* Menu:

* iklib time time::             Time spans object-type.
* iklib time epoch::            Time spans since the Epoch.
* iklib time date::             Date functions.


File: vicare-scheme.info,  Node: iklib time time,  Next: iklib time epoch,  Up: iklib time

6.49.1 Time spans object-type
-----------------------------

Time spans are represented by instances of '<time>' objects, which is a
disjoint object-type.  A '<time>' object can represent both absolute
times (typically elapsed times since the Epoch) and positive and
negative time spans relative to an arbitrary origin.  The internal time
representation has nanosecond resolution and it is immutable.

   The following bindings are exported by the library '(vicare)'.

 -- Function: <time> make-time {SECONDS <exact-integer>} {NANOSECONDS
          <exact-integer>}
 -- Function: <time> make-time {MEGASECONDS <exact-integer>} {SECONDS
          <exact-integer>} {NANOSECONDS <exact-integer>}
     Build and return a new '<time>' object.  If NANOSECONDS exceeds
     '#e1e9' its value is normalised and the excess added to SECONDS.
     If SECONDS exceeds '#e1e6' its value is normalised and the excess
     added to MEGASECONDS.

 -- Function: <boolean> time? OBJ
     Return '#t' if OBJ is a '<time>' object; otherwise return '#f'.

 -- Function: <boolean> list-of-times? OBJ
     Return '#t' if OBJ is a (possibly empty) proper list of '<time>'
     objects; otherwise return '#f'.

Accessors
.........

 -- Function: <exact-integer> time-seconds {T <time>}
 -- Function: <fixnum> time-nanoseconds {T <time>}
     The number of seconds and nanoseconds in the represented time span.

 -- Function: <ratnum> time-ratnum {T <time>}
 -- Function: <flonum> time-flonum {T <time>}
     Return a real number representing the time in seconds.  This single
     number is built from seconds and nanoseconds.

Arithmetics
...........

 -- Function: <time> time-addition {T1 <time>} {T <time>} ...
     Compute the addition between time objects: 'T1 + T + ...' and
     return a time struct representing it.

 -- Function: <time> time-difference {T1 <time>} {T <time>} ...
     When only one argument is given: return the negation of the time
     object.  When multiple arguments are given, compute the difference
     between time objects: 'T1 - (T + ...)' and return a time struct
     representing it.

Time comparison
...............

 -- Function: <boolean> time=? {T0 <time>} {T <time>} ...
     Return '#t' if the time objects are equal, else return '#f'.

 -- Function: <boolean> time!=? {T0 <time>} {T <time>} ...
     Return '#t' if the arguments are all different: no two arguments
     are equal; otherwise return '#f'.  When applied to a single
     argument: return '#f'.

 -- Function: <boolean> time<? {T0 <time>} {T <time>} ...
     Return '#t' if the time objects are monotonically increasing; else
     return '#f'.

 -- Function: <boolean> time<=? {T0 <time>} {T <time>} ...
     Return '#t' if the time objects are monotonically non-decreasing;
     else return '#f'.

 -- Function: <boolean> time>? {T0 <time>} {T <time>} ...
     Return '#t' if the time objects are monotonically decreasing; else
     return '#f'.

 -- Function: <boolean> time>=? {T0 <time>} {T <time>} ...
     Return '#t' if the time objects are monotonically non-decreasing;
     else return '#f'.

 -- Function: <boolean> time-max {T0 <time>} {T <time>} ...
 -- Function: <boolean> time-min {T0 <time>} {T <time>} ...
     Return the maximum or minimum between the arguments.


File: vicare-scheme.info,  Node: iklib time epoch,  Next: iklib time date,  Prev: iklib time time,  Up: iklib time

6.49.2 Time spans since the Epoch
---------------------------------

Time spans since the Epoch are represented by instances of
'<epoch-time>' objects, which is a disjoint object-type; the object-type
'<epoch-time>' is a subtype of '<time>'.  An '<epoch-time>' object
represents the time elapsed since the Epoch as determined by the POSIX
function 'clock_gettime()' with the argument 'CLOCK_REALTIME'; *note
Clock and time functions: (*manpages*)clock_gettime.

   The following bindings are exported by the library '(vicare)'.

 -- Function: <epoch-time> make-epoch-time {SECONDS <exact-integer>}
          {NANOSECONDS <fixnum>}
     Build and return a new '<epoch-time>' object.  The arguments are
     normalised as explained for 'make-time'.

 -- Function: <epoch-time> current-time
     Return an instance of '<epoch-time>' representing the current time
     elapsed since the Epoch as determined by the POSIX function
     'clock_gettime()' (*note Clock and time functions:
     (*manpages*)clock_gettime.) with the argument 'CLOCK_REALTIME'.

 -- Function: <epoch-time> faraway-time
     Return an instance of '<epoch-time>' representing a time since the
     Epoch that is "far" in the future.

 -- Function: <boolean> epoch-time? OBJ
     Return '#t' if OBJ is a '<epoch-time>' object; otherwise return
     '#f'.

 -- Function: <boolean> list-of-epoch-times? OBJ
     Return '#t' if OBJ is a (possibly empty) proper list of
     '<epoch-time>' objects; otherwise return '#f'.

 -- Function: <fixnum> time-gmt-offset
     We can interpret the Epoch time as time as expressed in the UTC or
     GMT+00 time zone.  This function returns the offset in seconds from
     the local time zone to UTC; in Rome (GMT+01) this function returns
     '3600'.

 -- Function: <epoch-time> epoch-time-addition {ET <epoch-time>} {T
          <time>}
     Add T to ET and return the result.

 -- Function: <epoch-time> epoch-time-subtraction {ET <epoch-time>} {T
          <time>}
     Subtract T from ET and return the result.


File: vicare-scheme.info,  Node: iklib time date,  Prev: iklib time epoch,  Up: iklib time

6.49.3 Date functions
---------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: <string> date-string
     Return a string representing the current date in the simple format:
     year, month, day.


File: vicare-scheme.info,  Node: iklib readline,  Next: iklib debug,  Prev: iklib time,  Up: iklib

6.50 Readline interface
=======================

The following bindings are exported by the library '(vicare)'.  An
extended API for GNU Readline is available through the '(vicare
readline)' library; *note Extended interface to GNU Readline:
(vicare-libs)readline. for details.

 -- Function: readline-enabled?
     Return '#t' is support for readline is enabled, return '#f'
     otherwise.  When this function returns '#f': no other readline
     functions must be called, lest the process be aborted.

 -- Function: readline
 -- Function: readline PROMPT
     Read a single line and return it as a Scheme string *not*
     terminated by a newline character.  PROMPT must be '#f', a
     bytevector or a string to be used as input prompt; when '#f' or not
     present: no prompt will be displayed.

 -- Function: make-readline-input-port
 -- Function: make-readline-input-port PROMPT-MAKER
     Return a custom textual input port reading character through
     'readline'.

     PROMPT-MAKER must be a '#f' or a thunk, when not used it defaults
     to '#f'; the thunk, when evaluated, must return a string or
     bytevector representing the input prompt in ASCII characters; if
     the return value is '#f' or PROMPT-MAKER is not used: no prompt
     will be displayed.


File: vicare-scheme.info,  Node: iklib debug,  Next: iklib sentinel,  Prev: iklib readline,  Up: iklib

6.51 Debugging utilities
========================

 -- Function: integer->machine-word EXACT-INTEGER
 -- Function: machine-word->integer WORD
     Convert between an exact integer and a machine word.  This
     operation shows at the Scheme level the internal representation of
     values.  Care must be taken when using these functions because it
     is very easy to cause undefined behaviour.

          ;; on 32-bit platforms
          (integer->machine-word #b11100) => #b111

          ;; on 64-bit platforms
          (integer->machine-word #b111000) => #b111

          (integer->machine-word #x3F)    => #t
          (integer->machine-word #x2F)    => #f

          (machine-word->integer #t)      => #x3F
          (machine-word->integer #f)      => #x2F

 -- Function: flonum->bytevector FLO
 -- Function: bytevector->flonum BV
     Convert a flonum to a bytevector and vice versa.  The flonum's
     memory block is copied byte by byte in the data area of the
     bytevector; and vice versa.

     For 'bytevector->flonum': if the bytevector does not have the
     length of a flonum's memory block, the return value is '#f'.

 -- Function: bignum->bytevector FLO
 -- Function: bytevector->bignum BV
     Convert a bignum to a bytevector and vice versa.  The bignum's
     memory block is copied byte by byte in the data area of the
     bytevector; and vice versa.


File: vicare-scheme.info,  Node: iklib sentinel,  Next: iklib misc,  Prev: iklib debug,  Up: iklib

6.52 The sentinel object
========================

The sentinel object is a unique object.  It is meant to be used with
'hashtable-ref' as follows:

     (hashtable-ref ?TABLE ?KEY (sentinel))

and for other similar uses.

 -- Function: sentinel
     Return the sentinel object.

 -- Function: sentinel? OBJ
     Return '#t' if OBJ is the sentinel object, otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib misc,  Prev: iklib sentinel,  Up: iklib

6.53 Miscellaneous functions
============================

 -- Function: neq? OBJ1 OBJ2
     Compare the arguments as 'eq?' would do, but return a negated
     result.  Equivalent (but more efficient) to:

          (not (eq? OBJ1 OBJ2))

 -- Function: immediate? OBJ
     Return true if OBJ is an immediate object: an object contained in a
     single machine word.  Compound objects (like lists and vectors) are
     *not* immediate.

 -- Function: void
     Return the void value.  We should never use the void object as
     argument for a function application, because the only legitimate
     use of the void object is as single return value of functions
     returning "unspecified values" (under Vicare returning a single
     value is faster than returning zero values).  If we need a unique
     value: we should use the sentinel value (*note The sentinel object:
     iklib sentinel.).

 -- Function: void-object? OBJ
     Return '#t' if OBJ is the void value; otherwise return '#f'.

 -- Function: always-true ARG ...
 -- Function: always-false ARG ...
     Always return '#t' or '#f', ignoring the arguments.

 -- Function: expect-single-argument-and-return-it ARG
 -- Function: expect-single-argument-and-return-true ARG
 -- Function: expect-single-argument-and-return-false ARG
     These function are used by some syntaxes to check at run-time that
     an expression returns a single value.  If zero, two or more values
     are returned: the built-in validation mechanism raises an exception
     at run-time; otherwise the argument is returned or discarded and
     the return value is '#t' or '#f'.

 -- Function: apropos KEY
     Given a string or symbol KEY, search among the internally installed
     libraries all the exported bindings having KEY as substring of
     their name and print a report to the standard output port.  Useful
     when using the REPL.  Example:

          vicare> (apropos "-length")
          *** in library (vicare):
          (bitwise-length bytevector-length string-length
            struct-length vector-length)

          *** in library (rnrs):
          (bitwise-length bytevector-length string-length
            vector-length)

          *** in library (rnrs arithmetic bitwise):
          (bitwise-length)

          *** in library (rnrs base):
          (string-length vector-length)

          *** in library (rnrs bytevectors):
          (bytevector-length)

          *** in library (vicare):
          (bitwise-length bytevector-length string-length
            struct-length vector-length)

          vicare>

 -- Function: getenv VARNAME
     Interface to the C function 'getenv()', *note getenv:
     (libc)Environment Access.  Retrieve the value of environment
     variables.  VARIABLE must reference a string object representing
     the name of the environment variable.  If the environment variable
     is set: return a string representing its value; else return false.

          (getenv "PATH")
          => "/usr/local/bin:/usr/bin:/bin"

     The Scheme level representation of environment variables names and
     values is a string, but internally it is a bytevector; strings are
     internally converted to bytevectors using 'string->utf8'.

 -- Function: environ
     Interface to the global C variable 'environ', *note unsetenv:
     (libc)Environment Access.  Retrieve the full environment.  Return a
     list of strings representing the contents of the 'environ' array;
     if the environment is empty (no environment variables set) return
     nil.

 -- Function: strerror ERRNO
     Return a string describing the 'errno' code ERRNO.  Makes use of
     the system function 'strerror()'.  If ERRNO is not a valid 'errno'
     value: return a string telling it.  As special cases ERRNO can be
     also '#t', meaning "unknown error", and '#f', meaning "no error".

     *note Error Messages: (libc)Error Messages.

 -- Function: warning WHO MESSAGE IRRITANT ...
     Similar to 'error', but raise a *continuable* exception with
     condition components: '&warning', '&who', '&message', '&irritants'.

 -- Function: random FX
     Return a random fixnum object between zero (included) and FX
     (excluded).  FX must be a strictly positive fixnum.

 -- Parameter: exit-hooks
     Contains null or a list of thunks to be evaluated by 'exit'
     whenever the process is normally terminated.  Any exception raised
     by the thunks is catched and discarded.  To add an exit hook:

          (define (do-something-at-exit)
            ---)

          (exit-hooks (cons do-something-at-exit
                            (exit-hooks)))


File: vicare-scheme.info,  Node: libutils,  Next: progutils,  Prev: iklib,  Up: Top

7 Scheme libraries utilities
****************************

The library '(vicare libraries)' exports bindings to deal with the
libraries infrastructure of Vicare; this library is integrated in the
boot image.  It is suggested to import it using the prefix 'libs.', as
in

     (import (prefix (vicare libraries) libs.))

* Menu:

* libutils names::              Library name utilities.
* libutils refs::               Library reference utilities.
* libutils libraries::          Library objects.
* libutils interning::          Interning libraries.
* libutils expanding::          Expanding libraries from source.
* libutils loading::            Loading libraries.
* libutils locating::           Locating libraries.
* libutils file-system::        Locating libraries on the file system.
* libutils dynamic::            Dynamically loading Scheme libraries.
* libutils compiling::          Compiling libraries.


File: vicare-scheme.info,  Node: libutils names,  Next: libutils refs,  Up: libutils

7.1 Library name utilities
==========================

Library names are defined by R6RS to be used in 'library' forms to
uniquely identify a library; *note Library names: scheme library form
names.

* Menu:

* libutils names pred::         Library name predicates.
* libutils names split::        Decomposing library names.
* libutils names compar::       Library names comparison.


File: vicare-scheme.info,  Node: libutils names pred,  Next: libutils names split,  Up: libutils names

7.1.1 Library name predicates
-----------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: library-name? SEXP
     Return '#t' if SEXP is a symbolic expressions compliant with the
     definition of ?LIBRARY-NAME according to R6RS.

          (library-name? '())                             => #f
          (library-name? '(alpha))                        => #t
          (library-name? '(alpha beta))                   => #t
          (library-name? '(alpha beta gamma))             => #t
          (library-name? '(alpha beta gamma ()))          => #t
          (library-name? '(alpha beta gamma (1)))         => #t
          (library-name? '(alpha beta gamma (1 2 3)))     => #t
          (library-name? '(alpha 123 gamma))              => #f
          (library-name? '(alpha beta gamma (1 ciao)))    => #f

 -- Function: library-version-numbers? OBJ
     Return '#t' if OBJ is a list of library version numbers according
     to R6RS, this includes OBJ being null.

          (library-version-numbers? '(1))         => #t
          (library-version-numbers? '(1 2 3))     => #t
          (library-version-numbers? '(1 -2 3))    => #f
          (library-version-numbers? '(1 A 3))     => #f

          *NOTE* According to R6RS: OBJ should be an exact integer,
          which means a finxum or bignum for Vicare.  This predicate
          accepts only fixnums because they are faster to handle and
          "big enough".

 -- Function: library-version-number? OBJ
     Return '#t' if OBJ is a single version number according to R6RS.


File: vicare-scheme.info,  Node: libutils names split,  Next: libutils names compar,  Prev: libutils names pred,  Up: libutils names

7.1.2 Decomposing library names
-------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: library-name-decompose OBJ
     Scan OBJ validating it as a ?LIBRARY-NAME as specified by R6RS.
     Return two values: the list of identifiers, the version
     specification.  The version can be null.  If OBJ is not a valid
     ?LIBRARY-NAME: return '#f' and '#f'.  The returned values may share
     structure with OBJ.

          (library-name-decompose '(alpha))
          => (alpha) ()

          (library-name-decompose '(alpha beta))
          => (alpha beta) ()

          (library-name-decompose '(alpha beta gamma))
          => (alpha beta gamma) ()

          (library-name-decompose '(alpha beta gamma ()))
          => (alpha beta gamma) ()

          (library-name-decompose '(alpha beta gamma (1)))
          => (alpha beta gamma) (1)

          (library-name-decompose '(alpha beta gamma (1 2 3)))
          => (alpha beta gamma) (1 2 3)

          (library-name-decompose '(alpha beta gamma (1 A 3)))
          => #f #f

          (library-name-decompose '(alpha 1 gamma (1 2 3)))
          => #f #f

 -- Function: library-name->identifiers SEXP
     Given a symbolic expression compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return the list of identifiers.
     If SEXP is not compliant return '#f'.

          (library-name->identifiers '(alpha))
          => (alpha)

          (library-name->identifiers '(alpha beta))
          => (alpha beta)

          (library-name->identifiers '(alpha beta gamma))
          => (alpha beta gamma)

          (library-name->identifiers '(alpha beta gamma ()))
          => (alpha beta gamma)

          (library-name->identifiers '(alpha beta gamma (1)))
          => (alpha beta gamma)

          (library-name->identifiers '(alpha beta gamma (1 2 3)))
          => (alpha beta gamma)

 -- Function: library-name->version SEXP
     Given a symbolic expression compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return the list of version
     numbers.  If SEXP is not compliant return '#f'.

          (library-name->version '(alpha))
          => ()

          (library-name->version '(alpha beta))
          => ()

          (library-name->version '(alpha beta gamma))
          => ()

          (library-name->version '(alpha beta gamma ()))
          => ()

          (library-name->version '(alpha beta gamma (1)))
          => (1)

          (library-name->version '(alpha beta gamma (1 2 3)))
          => (1 2 3)


File: vicare-scheme.info,  Node: libutils names compar,  Prev: libutils names split,  Up: libutils names

7.1.3 Library names comparison
------------------------------

The following functions can be used to sort library names according to
the version number:

     (list-sort library-name<? '((x y (1 2))
                                 (x y (1 3))))
     => ((x y (1 2))
         (x y (1 3)))

     (list-sort library-name<? '((x y (1 4))
                                 (x y (1 2))
                                 (x y (2 1))
                                 (x y (1 3))))
     => ((x y (1 2))
         (x y (1 3))
         (x y (1 4))
         (x y (2 1)))

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Function: library-name=? SEXP1 SEXP2
     Given two symbolic expressions compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if they have the same
     list of identifiers and the same version numbers.

 -- Function: library-name<? SEXP1 SEXP2
     Given two symbolic expressions compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if they have the same
     list of identifiers and the version of SEXP1 is less than the
     version of SEXP2.

 -- Function: library-name<=? SEXP1 SEXP2
     Given two symbolic expressions compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if they have the same
     list of identifiers and the version of SEXP1 is less than or equal
     to the version of SEXP2.

 -- Function: library-name-identifiers=? SEXP1 SEXP2
     Given two symbolic expressions compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if they have the same
     list of identifiers.

 -- Function: library-version=? VRS1 VRS2
     Given two lists of version numbers compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if they have the same
     numbers.

     If one of the lists is longer and the elements up to the end of the
     shortest are equal: the lists are "equal" if the tail of the
     longest is made of zeros.

     Examples:

          (1 2 3) == (1 2 3)
          (1 2 3) != (1 2 3 4)
          (1 2 3) == (1 2 3 0 0 0)

 -- Function: library-version<? VRS1 VRS2
     Given two lists of version numbers compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if the version number
     represented by VRS1 is less than the version number represented by
     VRS2.

     Comparison of digits stops at the first digit for which '<' or '>'
     return true.

     If one of the lists is longer and the elements up to the end of the
     shortest are equal: the lists are "equal" if the tail of the
     longest is made of zeros.

     Examples:

          (1 2 3) <  (4 2 3)
          (1 2 3) <  (1 4 3)
          (1 2 3) <  (1 2 4)
          (1 2 3) <  (1 2 3 4)
          (1 2 3) !< (1 2 3 0 0 0)

 -- Function: library-version<=? VRS1 VRS2
     Given two lists of version numbers compliant with the definition of
     ?LIBRARY-NAME according to R6RS: return '#t' if the version number
     represented by VRS1 is less than or equal to the version number
     represented by VRS2.

     Comparison of digits stops at the first digit for which '<='
     returns false.

     If one of the lists is longer and the elements up to the end of the
     shortest are equal: the lists are "equal" if the tail of the
     longest is made of zeros.

     Examples:

          (1 2 3) <= (1 2 3)
          (1 2 3) <= (4 2 3)
          (1 2 3) <= (1 4 3)
          (1 2 3) <= (1 2 4)
          (1 2 3) <= (1 2 3 4)
          (1 2 3 0) <= (1 2 3)


File: vicare-scheme.info,  Node: libutils refs,  Next: libutils libraries,  Prev: libutils names,  Up: libutils

7.2 Library reference utilities
===============================

Library references are defined by R6RS to be used in 'import' forms to
select a dependency library; *note The import specification: scheme
library form import.

* Menu:

* libutils refs pred::          Library reference predicates.
* libutils refs split::         Decomposing library references.
* libutils refs compar::        Library references comparison.
* libutils refs conform::       Conformity among library references
                                and names.


File: vicare-scheme.info,  Node: libutils refs pred,  Next: libutils refs split,  Up: libutils refs

7.2.1 Library reference predicates
----------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: library-reference? OBJ
     Return '#t' if OBJ is a valid library reference as specified by
     R6RS.

          (library-reference? '())                        => #f
          (library-reference? '(alpha))                   => #t
          (library-reference? '(alpha beta gamma))        => #t
          (library-reference? '(alpha beta gamma ()))     => #t
          (library-reference? '(alpha beta gamma (1)))    => #t
          (library-reference?
              '(alpha beta (1
                            (<= 2)
                            (or 10 (and (>= 4)
                                        (<= 2))))))
          => #t

 -- Function: library-version-reference? OBJ
     Return '#t' if OBJ is a valid library version reference as
     specified by R6RS.

          (library-version-reference? '())                => #t
          (library-version-reference? '(1))               => #t
          (library-version-reference? '(1 2 3))           => #t

          (library-version-reference? '(and))             => #t
          (library-version-reference? '(and (1)))         => #t
          (library-version-reference? '(and (1) (2)))     => #t

          (library-version-reference? '(or))              => #t
          (library-version-reference? '(or (1)))          => #t
          (library-version-reference? '(or (1) (2)))      => #t

          (library-version-reference? '(not))             => #f
          (library-version-reference? '(not (1)))         => #t

          (library-version-reference?
             '(1
               (<= 2)
               (or 10
                   (and (<= 4)
                        (>= 2)))))
          => #t

 -- Function: library-sub-version-reference? OBJ
     Return '#t' if OBJ is a valid library sub-version reference as
     specified by R6RS.

 -- Function: library-sub-version? OBJ
     Return '#t' if OBJ is a ?SUB-VERSION number according to R6RS.

          *NOTE* According to R6RS: OBJ should be an exact non-negative
          integer, which means a non-negative finxum or bignum.  Vicare
          accepts only fixnums because they are faster to handle and
          "big enough".


File: vicare-scheme.info,  Node: libutils refs split,  Next: libutils refs compar,  Prev: libutils refs pred,  Up: libutils refs

7.2.2 Decomposing library references
------------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: library-reference-decompose OBJ
     Interpret OBJ as a symbolic expression representing a library
     reference as specified by R6RS.  Return two values: the list of
     identifiers, the version reference.  If OBJ is not a valid library
     reference: return '#f' and '#f'.

          (library-reference-decompose
             '(alpha beta (1 (<= 2) (or 10 (and (>= 4) (>= 2))))))
          => (alpha beta) (1 (<= 2) (or 10 (and (>= 4) (>= 2))))

 -- Function: library-reference->identifiers OBJ
     If OBJ is a valid library reference as specified by R6RS, return
     the list of identifiers; else return '#f'.

 -- Function: library-reference->version OBJ
     If OBJ is a valid library reference as specified by R6RS, return
     the version reference; else return '#f'.


File: vicare-scheme.info,  Node: libutils refs compar,  Next: libutils refs conform,  Prev: libutils refs split,  Up: libutils refs

7.2.3 Library references comparison
-----------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: library-reference-identifiers=? REFERENCE1 REFERENCE2
     Return '#t' if the arguments are library references having equal
     lists of identifiers; else return '#f'.


File: vicare-scheme.info,  Node: libutils refs conform,  Prev: libutils refs compar,  Up: libutils refs

7.2.4 Conformity among library references and names
---------------------------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: conforming-sub-version-and-sub-version-reference?
          SUB-VERSION SUB-VERSION-REFERENCE
     Interpret SUB-VERSION as a sub-version number as specified by R6RS
     and SUB-VERSION-REFERENCE as a sub-version reference as specified
     by R6RS.  Return '#t' if the sub-version conforms to the
     sub-version reference; else return '#f'; if the arguments are
     invalid: raise an assertion violation.

          (conforming-sub-version-and-sub-version-reference?
              1 1)
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 0)
          => #f

          (conforming-sub-version-and-sub-version-reference?
              1 '(<= 1))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              2 '(<= 1))
          => #f

          (conforming-sub-version-and-sub-version-reference?
              0 '(<= 1))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(>= 1))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              2 '(>= 1))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              0 '(>= 1))
          => #f

          (conforming-sub-version-and-sub-version-reference?
              1 '(not 1))
          => #f

          (conforming-sub-version-and-sub-version-reference?
              1 '(not 0))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(or 1 2))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(or 2 1))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(or 2 3))
          => #f

          (conforming-sub-version-and-sub-version-reference?
              1 '(or 2 3 4))
          => #f

          (conforming-sub-version-and-sub-version-reference?
              4 '(or 2 3 4))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(and (>= 0) (<= 2)))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              0 '(and (>= 0) (<= 2)))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(and (>= 0) (<= 2) (not 3)))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              1 '(and (>= 0) (<= 2) (not 1)))
          => #f


          (conforming-sub-version-and-sub-version-reference?
              4 '(or (and (>= 0) (<= 2)) 4))
          => #t

          (conforming-sub-version-and-sub-version-reference?
              3 '(or (and (>= 0) (<= 2)) 4))
          => #f

 -- Function: conforming-version-and-version-reference? VERSION1
          VERSION-REFERENCE2
     Interpret VERSION as a version symbolic expression as specified by
     R6RS and VERSION-REFERENCE as a version reference symbolic
     expression as specified by R6RS.  Return '#t' if the version
     conforms to the version reference; else return '#f'; if the
     arguments are invalid: raise an assertion violation.

          (conforming-version-and-version-reference?
              '() '())
          => #t

          (conforming-version-and-version-reference?
              '(1) '())
          => #t

          (conforming-version-and-version-reference?
              '() '(1))
          => #f

          (conforming-version-and-version-reference?
              '(1) '(1))
          => #t

          (conforming-version-and-version-reference?
              '(1) '(0))
          => #f

          (conforming-version-and-version-reference?
              '(1) '((<= 1)))
          => #t

          (conforming-version-and-version-reference?
              '(2) '((<= 1)))
          => #f

          (conforming-version-and-version-reference?
              '(0) '((<= 1)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((>= 1)))
          => #t

          (conforming-version-and-version-reference?
              '(2) '((>= 1)))
          => #t

          (conforming-version-and-version-reference?
              '(0) '((>= 1)))
          => #f

          (conforming-version-and-version-reference?
              '(1) '((not 1)))
          => #f

          (conforming-version-and-version-reference?
              '(1) '((not 0)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((or 1 2)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((or 2 1)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((or 2 3)))
          => #f

          (conforming-version-and-version-reference?
              '(1) '((or 2 3 4)))
          => #f

          (conforming-version-and-version-reference?
              '(4) '((or 2 3 4)))
          => #t

          (conforming-version-and-version-reference?
              '(5) '((or 2 (or 3 (or 4 (or 5))))))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and 1)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and 1 1)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and 1 1 1)))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and 1 (and 1 (and 1 (and 1))))))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and (>= 0) (<= 2))))
          => #t

          (conforming-version-and-version-reference?
              '(0) '((and (>= 0) (<= 2))))
          => #t

          (conforming-version-and-version-reference?
              '(2) '((and (>= 0) (<= 2))))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and (>= 0) (<= 2) (not 3))))
          => #t

          (conforming-version-and-version-reference?
              '(1) '((and (>= 0) (<= 2) (not 1))))
          => #f

          (conforming-version-and-version-reference?
              '(1) '((or (and (>= 0) (<= 2)) 4)))
          => #t

          (conforming-version-and-version-reference?
              '(4) '((or (and (>= 0) (<= 2)) 4)))
          => #t

          (conforming-version-and-version-reference?
              '(3) '((or (and (>= 0) (<= 2)) 4)))
          => #f

          (conforming-version-and-version-reference?
              '(1 2 3) '(1 2 3))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 3) '(1 2 4))
          => #f

          (conforming-version-and-version-reference?
              '(1 2 0) '(1 2))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 1) '(1 2))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 3)
              '(1 (>= 1) (not 1)))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 3)
              '(1 (<= 1) (not 1)))
          => #f

          (conforming-version-and-version-reference?
              '(1 2 3)
              '(or (1 (<= 1) (not 1)) (1 (>= 1) (not 1))))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 3) '(or (1 2 5) (1 2 10)))
          => #f

          (conforming-version-and-version-reference?
              '(1 2 3)
              '(and (1 (>= 1) (not 1)) (1 2 (not 5))))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 3)
              '(and (1 (<= 1) (not 1)) (1 2 (not 5))))
          => #f)

          (conforming-version-and-version-reference?
              '(1 2 3) '(not (1 5 4)))
          => #t

          (conforming-version-and-version-reference?
              '(1 2 3) '(not (1 2 3)))
          => #f

 -- Function: conforming-library-name-and-library-reference? NAME
          REFERENCE
     Interpret NAME as a library name symbolic expression as specified
     by R6RS and REFERENCE as a library reference symbolic expression as
     specified by R6RS.  Return '#t' if the name conforms to the
     reference; else return '#f'; if the arguments are invalid: raise an
     assertion violation.

          (conforming-library-name-and-library-reference?
              '(a (1)) '(a (1)))
          => #t

          (conforming-library-name-and-library-reference?
              '(a (1)) '(a (0)))
          => #f

          (conforming-library-name-and-library-reference?
              '(a b c (1)) '(a b c (1)))
          => #t

          (conforming-library-name-and-library-reference?
              '(a b c (1)) '(a b c (0)))
          => #f

          (conforming-library-name-and-library-reference?
              '(a b c (1)) '(a z c (1)))
          => #f


File: vicare-scheme.info,  Node: libutils libraries,  Next: libutils interning,  Prev: libutils refs,  Up: libutils

7.3 Library objects
===================

Objects of type '<library>' are created when a source library is
processed by the expander and when a binary library is loaded from a
FASL file; '<library>' is a disjoint type.

* Menu:

* libutils libraries typedef::       '<library>' object type.
* libutils libraries global-env::    The 'global-env' field.
* libutils libraries ops::           Library operations.


File: vicare-scheme.info,  Node: libutils libraries typedef,  Next: libutils libraries global-env,  Up: libutils libraries

7.3.1 '<library>' object type
-----------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Record Type: <library>
     Record type representing Scheme libraries.

 -- Function: library? OBJ
     Return '#t' if OBJ is an object of type '<library>'; otherwise
     return '#f'.

 -- Accessor for '<library>': library-uid LIB
     Return a gensym uniquely identifying this interned library; it also
     identifies the corresponding serialised library.  This gensym is
     registered in:

        * The '<library>' object created by a 'vicare' process at
          run-time.

        * The binary file containing this library in compiled and
          serialised form.

        * The binary files containing the compiled libraries that import
          this one.

     Whenever a compiled library imports this one, the UID stored in the
     binary file is compared to this field: if they are 'eq?' the
     compiled versions are in sync, otherwise the importing library must
     be recompiled.

 -- Accessor for '<library>': library-name LIB
     A library name as defined by R6RS; it is the symbolic expression:

          (?IDENTIFIER0 ?IDENTIFIER ...)
          (?IDENTIFIER0 ?IDENTIFIER ... ?VERSION)

     where the ?IDENTIFIER are symbols and ?VERSION is a list of
     non-negative fixnums representing the version numbers.  Library
     names can be manipulated with appropriate functions, *note Library
     name utilities: libutils names.

 -- Accessor for '<library>': library-imp-lib* LIB
     The list of '<library>' objects selected by the 'import' clause in
     the source code of LIB.

 -- Accessor for '<library>': library-vis-lib* LIB
     The list of '<library>' objects selecting libraries needed by the
     visit code.

 -- Accessor for '<library>': library-inv-lib* LIB
     The list of '<library>' objects selecting libraries needed by the
     invoke code.

 -- Accessor for '<library>': library-export-subst LIB
     Return the 'export-subst' of LIB: an alist representing the global
     bindings exported by the library.  The cars of the alist are
     symbols representing the public names of the exported syntactic
     bindings.  The cdrs of the alist are the label gensyms of the
     exported syntactic bindings.

     The 'export-subst' includes both syntactic bindings defined by the
     library itself and syntactic bindings imported and re-exported by
     the library.  For example:

          (define ell
            (expand-library->sexp
               '(library (demo)
                  (options typed-language)
                  (export display <fixnum>)
                  (import (vicare))
                  (define {x <fixnum>} 123))))

          (cdr (assq 'export-subst ell))
          => ((<fixnum> . prim-label.<fixnum>) (display . g14256))

          (cdr (assq 'global-env ell))
          => ((g9 . (global-typed . g8)))

     notice that the re-exported bindings do not appear in the
     'global-env'.

 -- Accessor for '<library>': library-typed-locs LIB
     Return an alist having labels as keys and loc gensyms as values.
     The labels are the ones of the 'global-env' whose descriptor has
     type 'global-typed' or 'global-typed-mutable'.  The loc gensyms are
     the ones of the variables actually holding the typed values.  This
     alist allows to map the public name of global typed variables to
     the loc gensyms holding the values.

 -- Accessor for '<library>': library-visit-state LIB
     When set to a procedure: it is the thunk to call to compile and
     evaluate the visit code.  When set to something else: this library
     has been already visited.

 -- Accessor for '<library>': library-invoke-state LIB
     When set to a procedure: it is the thunk to call to compile and
     evaluate the invoke code.  When set to something else: this library
     has been already invoked.

 -- Accessor for '<library>': library-visit-code LIB
     When LIB is created from source code: this field is a core language
     symbolic expression representing the visit code.  When LIB is
     created from a binary file: this field is a thunk to evaluate to
     visit the library.

 -- Accessor for '<library>': library-invoke-code LIB
     When LIB is created from source code: this field is a core language
     symbolic expression representing the invoke code.  When LIB is
     created from a binary file: this field is a thunk to evaluate to
     invoke the library.

 -- Accessor for '<library>': library-guard-code LIB
     When LIB is created from source code: this field is a core language
     symbolic expression representing the guard code.  When LIB is
     created from a binary file: this field is a thunk to evaluate to
     run the 'stale-when' composite test expression.

 -- Accessor for '<library>': library-guard-lib* LIB
     The list of '<library>' objects selecting libraries needed by the
     'stale-when' composite test expression.

          *NOTE* These are the libraries accumulated by the
          'inv-collector' while expanding the 'stale-when' test
          expressions.

 -- Accessor for '<library>': library-visible? LIB
     A boolean determining if the library is visible.  This attribute is
     used by 'interned-libraries' to select libraries to report as
     interned.

     A library should be marked as visible if it is meant to be imported
     by client code in "normal" use; unsafe libraries in the hierarchy
     '(vicare system ---))' should *not* be visible.

 -- Accessor for '<library>': library-source-file-name LIB
     The boolean '#f' or a string representing the pathname of the file
     from which the source code of the library was read.

 -- Accessor for '<library>': library-option* LIB
     A list of symbolic expressions holding library options.

 -- Accessor for '<library>': library-foreign-library* LIB
     A list of strings each representing the identifier of a foreign
     library that must be dynamically loaded for this LIB object.  These
     libraries are the ones especially written to interface Vicare with
     platform-specific services.

 -- Function: library-loaded-from-source-file? LIB
     The argument LIB must be a '<library>' object.  Return '#t' if LIB
     was loaded from a source file; otherwise return '#f'.

 -- Function: library-loaded-from-binary-file? LIB
     The argument LIB must be a '<library>' object.  Return '#t' if LIB
     was loaded from a binary file; otherwise return '#f'.

 -- Function: library-descriptor LIB
     Given a '<library>' object return an object representing the
     library descriptor.  Library descriptors are uniquely associated to
     a compiled library.

 -- Function: library-descriptor? OBJ
     Return '#t' if OBJ is a library descriptor object; otherwise return
     '#f'.

 -- Function: library-descriptor-uid LIBDESCR
     Given a library descriptor object return the UID.

 -- Function: library-descriptor-name LIBDESCR
     Given a library descriptor object return the R6RS library name.

   As example of '<library>' fields, expanding the library:

     (library (ciao)
       (export var fun mac etv)
       (import (vicare))
       (define var 1)
       (define (fun)
         2)
       (define-syntax (mac stx)
         3)
       (define-syntax etv
         (make-expand-time-value
          (+ 4 5))))

yields the 'invoke-code':

     (library-letrec*
         ((lex.var loc.var '1)
          (lex.fun loc.fun (annotated-case-lambda fun (() '2))))
       ((primitive void)))

the 'visit-code':

     (begin
       (set! loc.mac
             (annotated-case-lambda
                 (#'lambda (#'stx) #'3)
               ((lex.stx) '3)))
       (set! loc.etv
             (annotated-call
                 (make-expand-time-value (+ 4 5))
               (primitive make-expand-time-value)
               (annotated-call (+ 4 5) (primitive +) '4 '5))))

the 'export-subst':

     ((etv . lab.etv)
      (mac . lab.mac)
      (fun . lab.fun)
      (var . lab.var))

the 'global-env':

     ((lab.var global        . loc.var)
      (lab.fun global        . loc.fun)
      (lab.mac global-macro  . loc.mac)
      (lab.etv global-etv    . loc.etv))

   Another example, for the library:

     (library (ciao (1 2))
       (export doit)
       (import (vicare))
       (stale-when (< 1 2)
         (define a 123))
       (stale-when (< 2 3)
         (define b 123))
       (define (doit)
         123))

the 'guard-code' is:

     (if (if '#f
             '#t
            (annotated-call (< 1 2) (primitive <) '1 '2))
         '#t
       (annotated-call (< 2 3) (primitive <) '2 '3))


File: vicare-scheme.info,  Node: libutils libraries global-env,  Next: libutils libraries ops,  Prev: libutils libraries typedef,  Up: libutils libraries

7.3.2 The 'global-env' field
----------------------------

 -- Accessor for '<library>': library-global-env LIB
     Return the lexical environment exported by the '<library>' object
     LIB.

   The 'global-env' is a data structure used to map the label gensyms of
top level syntactic bindings defined by a library to the corresponding
storage location gensyms.  "Top level bindings" does not mean "exported
bindings": not all the entries in 'global-env' represent exported
bindings, it is the role of the 'export-subst' to select the exported
ones.

   An 'global-env' is an alist whose entries have the format:

     (?LABEL . ?EXPORT-DESCRIPTOR)

and ?EXPORT-DESCRIPTOR has the format:

     (?BINDING-TYPE . ?BINDING-VALUE)

where: ?LABEL is the syntactic binding's label gensym; ?BINDING-TYPE is
a symbol representing the syntactic binding's type; the format of
?BINDING-VALUE depends upon the type.

   The symbol ?BINDING-TYPE is one among:

'global'
     Denotes a syntactic binding representing a variable binding which
     is never assigned in the code (it is initialised to a value and
     that value never changes).  The export descriptor has the format:

          (global . ?LEX/LOC)

     where ?LEX/LOC is a gensym acting both as lexical gensym and
     storage location gensym; after the library is invoked: the loc
     gensym holds the variable's value in its 'value' slot (immutable).
     This binding can be exported.

'mutable'
     Denotes a syntactic binding representing a variable binding which
     is assigned somewhere in the code.  The export descriptor has the
     format:

          (mutable . ?LEX/LOC)

     where ?LEX/LOC is a gensym acting both as lexical gensym and
     storage location gensym; after the library is invoked: the loc
     gensym holds the variable's value in its 'value' slot (mutable).
     This binding *cannot* be exported.

'global-macro'
     Denotes a syntactic binding representing a non-variable macro.  The
     export descriptor has the format:

          (global-macro . ?LOC)

     where ?LOC is the storage location gensym; after the library has
     been visited: ?LOC holds the macro transformer in its 'value' slot.
     This binding can be exported.

     Syntactic bindings of this type are established by uses of
     'define-syntax', 'let-syntax' and similar when the result of
     evaluating the right-hand side expression is a function.

'global-macro!'
     Denotes a syntactic binding representing a variable macro.  The
     export descriptor has the format:

          (global-macro! . ?LOC)

     where ?LOC is the storage location gensym; after the library has
     been visited: ?LOC holds the macro transformer in its 'value' slot.
     This binding can be exported.

     Syntactic bindings of this type are established by uses of
     'define-syntax', 'let-syntax' and similar when the result of
     evaluating the right-hand side expression is the return value of a
     call to 'make-variable-transformer'.

'global-etv'
     Denotes a syntactic binding representing an expand-time value.  The
     export descriptor has the format:

          (global-etv . ?LOC)

     where ?LOC is the storage location gensym; after the library has
     been visited: ?LOC holds the actual expand-time object.  This
     binding can be exported.

     Syntactic bindings of this type are established by 'define-syntax',
     'let-syntax' and similar when the result of evaluating their
     right-hand side expression is the return value of a call to
     'make-expand-time-value'.

'$struct-type-descriptor'
     Denotes a syntactic binding representing a Vicare's struct-type
     name.  The export descriptor has the format:

          ($struct-type-descriptor . ?TYPE-DESCRIPTOR-STRUCT)

     where ?TYPE-DESCRIPTOR-STRUCT is a struct representing the
     struct-type descriptor.

     Syntactic bindings of this type are established by uses of the
     syntax 'define-struct'.

'$record-type-descriptor'
     Denotes a syntactic binding representing a R6RS record-type name.
     The export descriptor has one of the formats:

          ($record-type-descriptor . (?RTD-ID ?RCD-ID))
          ($record-type-descriptor . (?RTD-ID ?RCD-ID . ?SPEC))

     where: ?RTD-ID is the syntactic identifier to which the record-type
     descriptor is bound; ?RCD-ID is the syntactic identifier to which
     the default record-constructor descriptor is bound; ?SPEC is an
     instance of record type 'r6rs-record-type-spec'.

     Syntactic bindings of this type are established by uses of the
     syntaxes 'define-record-type' and 'define-condition-type'.

'$module'
     Denotes a syntactic binding representing a module interface.  The
     export descriptor has format:

          ($module . ?MODULE-INTERFACE)

     where ?MODULE-INTERFACE is a record of type 'module-interface'.

     Syntactic bindings of this type are established by uses of the
     syntax 'module'.

'$fluid'
     Denotes a syntactic binding representing a fluid syntax.  The
     export descriptor has format:

          ($fluid . ?FLUID-LABEL)

     where ?FLUID-LABEL is the label gensym associated to the fluid
     syntax.

'$synonym'
     Denotes a syntactic binding representing a synonym syntax.  The
     export descriptor has format:

          ($synonym . ?SYNONYM-LABEL)

     where ?SYNONYM-LABEL is the label gensym associated to the aliased
     syntax.

Example library
...............

We can toy with the 'global-env' with the following program:

     (import (vicare)
       (vicare libraries))

     (library (demo)
       (export var macro var-macro macro-id
               etv color <color> modu fluid synonym alias)
       (import (vicare))
       (define var 1)
       (define (fun) 2)
       (define-syntax macro (lambda (stx) 3))
       (define-syntax macro-id (identifier-syntax 4))
       (define-syntax var-macro
         (make-variable-transformer (lambda (stx) 5)))
       (define-syntax etv (make-expand-time-value 6))
       (module modu (modu-var) (define modu-var 7))
       (define-fluid-syntax fluid (lambda (stx) 8))
       (define-syntax synonym (make-synonym-transformer #'var))
       (define-alias alias var)
       (define-struct color (red green blue))
       (define-record-type <color> (fields red green blue))
       (define mvar 9)
       (set! mvar 10)
       #| end of library |# )

     (define lib
       (find-library-by-name '(demo)))

     (print-gensym #f)
     (pretty-print
      (library-global-env lib))

     (flush-output-port (current-output-port))


File: vicare-scheme.info,  Node: libutils libraries ops,  Prev: libutils libraries global-env,  Up: libutils libraries

7.3.3 Library operations
------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: invoke-library LIB
     Evaluate the invoke code of the '<library>' object LIB and all its
     dependency libraries.  When successful: return LIB itself;
     otherwise raise an exception.  If we apply this function to LIB
     multiple times: the code is evaluated only the first time;
     subsequent applications do nothing.

 -- Function: visit-library LIB
     Evaluate the visit code of the '<library>' object LIB and all its
     dependency libraries When successful: return LIB itself; otherwise
     raise an exception.  If we apply this function to LIB multiple
     times: the code is evaluated only the first time; subsequent
     applications do nothing.


File: vicare-scheme.info,  Node: libutils interning,  Next: libutils expanding,  Prev: libutils libraries,  Up: libutils

7.4 Interning libraries
=======================

When a library is loaded in source or binary form, it is "interned"; to
intern a library means to add it to an internal collection along with
all its dependency libraries.  Interned libraries are neither invoked
nor visited; the invoke-time and visit-time depend upon the usage we
make of them.

   In a Vicare process, there can be only one library with a given
sequence of symbols in its name; if we have already loaded the library
'(a b (1))', it is not possible to load a library '(a b (2))', because
they have the sequence '(a b)' in common.

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Function: interned-libraries
 -- Function: interned-libraries ALL?
     Return a list of '<library>' objects representing interned
     libraries.  If ALL? is non-false: return all the interned
     libraries, else return only the visible ones.

 -- Function: find-library-by-name LIBNAME
     Given a R6RS library name: try to search and intern the
     corresponding library, if it is not already interned; when
     successful return the corresponding '<library>' object, otherwise
     raise an exception.

     First search for the library among the interned ones then, if not
     found, in an external libraries repository using the procedure
     referenced by the parameter 'current-library-loader'.

 -- Function: find-library-by-reference LIBREF
     Given a R6RS library reference: try to search and intern the
     corresponding library, if it is not already interned; when
     successful return the corresponding '<library>' object, otherwise
     raise an exception.

     First search for the library among the interned ones then, if not
     found, in an external libraries repository using the procedure
     referenced by the parameter 'current-library-loader'.

 -- Function: find-library-by-descriptor LIBDESCR
     Given a library descriptor, as generated by the function
     'library-descriptor' (*note library-descriptor: libutils
     libraries.): try to search and intern the corresponding library, if
     it is not already interned; when successful return the
     corresponding '<library>' object, otherwise raise an exception.

     First search for the library among the interned ones then, if not
     found, in an external libraries repository using the procedure
     referenced by the parameter 'current-library-loader'.

 -- Function: find-library-in-collection-by-predicate PRED
     Visit the collection of interned libraries and return the first for
     which PRED returns non-false.  If PRED returns '#f' for all the
     interned libraries: return '#f'.

     PRED must be a function accepting as single argument a '<library>'
     object.

 -- Function: find-library-in-collection-by-name LIBNAME
     Given a symbolic expression representing a R6RS library name: visit
     the collection of interned libraries and return the first
     '<library>' object having conforming library name identifiers.  If
     no matching library is found: return '#f'.

 -- Function: find-library-in-collection-by-reference LIBREF
     Given a symbolic expression representing a R6RS library reference:
     visit the collection of interned libraries and return the first
     '<library>' object having conforming library name identifiers.  If
     no matching library is found: return '#f'.

 -- Function: find-library-in-collection-by-descriptor LIBDESCR
     Given a library descriptor, as generated by the function
     'library-descriptor': visit the collection of interned libraries
     and return the first '<library>' object having the same library
     UID.  If no matching library is found: *raise an exception*.

 -- Function: unintern-library LIBNAME
 -- Function: unintern-library LIBNAME ERR?
     Interned libraries can be uninterned, either to free system
     resources or to allow reinterning from new files.

     This function uninterns a library given its R6RS library name.  If
     ERR? is non-false: if the library is not currently interned an
     exception is raised; otherwise nothing happens.  Return unspecified
     values.

          *NOTE* The implementation of this function is incomplete.  It
          is to be used at the REPL when experimenting does not hurt.


File: vicare-scheme.info,  Node: libutils expanding,  Next: libutils loading,  Prev: libutils interning,  Up: libutils

7.5 Expanding libraries from source
===================================

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: expand-library SEXP
 -- Function: expand-library SEXP FILENAME
 -- Function: expand-library SEXP FILENAME VERIFY-LIBNAME
     Expand the symbolic expression SEXP and intern the result (*note
     libutils interning::).  When successful: return a '<library>'
     object; if an error occurs: raise an exception.

     SEXP must be a symbolic expression '(library . ---)' representing a
     R6RS library form with optional Vicare extensions.

     The optional FILENAME must be '#f' or a string representing the
     source file from which the library was loaded; it is used for
     information purposes.  When not given defaults to '#f'.

     The optional argument VERIFY-LIBNAME must be a procedure accepting
     a R6RS library name as argument and returning unspecified values;
     it is meant to perform some validation upon the library name
     components and raise an exception if something is wrong; otherwise
     it should just return.

 -- Function: expand-library->sexp SEXP
     This function is for debugging purposes.  Expand the library form
     SEXP and return the return values of 'expand-library' in an alist
     with the following symbols as keys:

          uid libname
          import-libdesc* visit-libdesc* invoke-libdesc*
          invoke-code visit-code
          export-subst global-env
          guard-code guard-libdesc*
          option*

   We can toy with the library expander using the following code:

     #!r6rs
     (import (vicare)
       (prefix (vicare libraries) libs.))
     (print-gensym #f)
     (debug-print (libs.expand-library->sexp ?SEXP))

where ?SEXP is the 'library' symbolic expression.  For example,
expanding the library:

     (library (ciao)
       (export var fun mac etv)
       (import (vicare))
       (define var 1)
       (define (fun)
         2)
       (define-syntax (mac stx)
         3)
       (define-syntax etv
         (make-expand-time-value
          (+ 4 5))))

yields the 'invoke-code':

     (library-letrec*
         ((lex.var loc.lex.var '1)
          (lex.fun loc.lex.fun (annotated-case-lambda fun (() '2))))
       ((primitive void)))

the 'visit-code':

     (begin
       (set! loc.lab.mac
             (annotated-case-lambda
                 (#'lambda (#'stx) #'3)
               ((lex.stx) '3)))
       (set! loc.lab.etv
             (annotated-call
                 (make-expand-time-value (+ 4 5))
               (primitive make-expand-time-value)
               (annotated-call (+ 4 5) (primitive +) '4 '5))))

the 'export-subst':

     ((etv . lab.etv)
      (mac . lab.mac)
      (fun . lab.fun)
      (var . lab.var))

the 'global-env':

     ((lab.var global        . loc.lex.var)
      (lab.fun global        . loc.lex.fun)
      (lab.mac global-macro  . loc.lab.mac)
      (lab.etv global-etv    . loc.lab.etv))

   Another example, for the library:

     (library (ciao (1 2))
       (export doit)
       (import (vicare))
       (stale-when (< 1 2)
         (define a 123))
       (stale-when (< 2 3)
         (define b 123))
       (define (doit)
         123))

the 'guard-code' is:

     (if (if '#f
             '#t
            (annotated-call (< 1 2) (primitive <) '1 '2))
         '#t
       (annotated-call (< 2 3) (primitive <) '2 '3))


File: vicare-scheme.info,  Node: libutils loading,  Next: libutils locating,  Prev: libutils expanding,  Up: libutils

7.6 Loading libraries
=====================

Libraries are interned using the functions 'find-library-*', *note
Interning libraries: libutils interning.  All those functions first
search the internal collection, then load libraries through the
procedure referenced by the parameter 'current-library-loader'.

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Parameter: current-library-loader
     Reference a function used to load a library, either source or
     binary, given a R6RS library reference; the referenced function
     must intern the library and all its dependencies.  The parameter is
     used as follows:

          ((current-library-loader) ?LIBREF)

     The referenced function is meant to be called after we have checked
     that a compliant library is not already interned.  The referenced
     function is allowed to return unspecified values.

 -- Function: default-library-loader LIBREF
     Default value for the parameter 'current-library-loader'.  Given a
     R6RS library reference: attempt to locate the library in an
     external repository and load it; all the dependency libraries are
     interned.  Return unspecified values.

     This function makes use of: the library locator referenced by the
     parameter 'current-library-locator'; the source library loader
     referenced by the parameter 'current-source-library-loader'; the
     binary library loader referenced by the parameter
     'current-binary-library-loader'.

     LIBREF must be a library reference as defined by R6RS:

          (?IDENTIFIER0 ?IDENTIFIER)
          (?IDENTIFIER0 ?IDENTIFIER ... ?VERSION-REFERENCE)

     *note scheme library form import:: for details on library
     references.

Interning source libraries
..........................

Any function we set in the parameter 'current-library-loader' can use
the following API to intern a source library.

 -- Parameter: current-source-library-loader
     Reference a function used to load a source library from a textual
     input port.

     The referenced function must accept two arguments: a R6RS library
     reference, a textual input port from which the source library can
     be read.  It must: read from the port a 'library' symbolic
     expression; verify that its library name conforms to the library
     reference; load and intern all its dependency libraries; expand it;
     compile it; intern it.

     If successful the function must return a symbolic expression
     representing the R6RS library name of the loaded library; otherwise
     return '#f'.

 -- Function: default-source-library-loader LIBREF TEXTUAL-PORT
     Default value for the parameter 'current-source-library-loader'.
     Given a textual input port:

       1. Read from it a 'library' symbolic expression.

       2. Verify that its version reference conforms to LIBREF.

       3. Using the expander procedure referenced by
          'current-library-expander': load and intern all its dependency
          libraries; expand it; compile it; intern it.

     If successful return a symbolic expression representing the R6RS
     library name of the loaded library; otherwise return '#f'.

     This function assumes that applying the function 'port-id' to
     TEXTUAL-PORT will return a string representing a file name
     associated to the port (or equivalent).

Interning binary libraries
..........................

Any function we set in the parameter 'current-library-loader' can use
the following API to intern a binary library.

 -- Parameter: current-binary-library-loader
     Reference a function used to load a binary library.

     The referenced function must accept two arguments: a R6RS library
     reference, a binary input port from which the serialised library
     can be read.  It must: read from the port a serialised library;
     verify that its library name conforms to the library reference;
     intern it along with all its dependency libraries.

     If successful the function must return a symbolic expression
     representing the R6RS library name of the interned library;
     otherwise return '#f'.

 -- Function: default-binary-library-loader LIBREF BINARY-PORT
     Default value for the parameter 'current-binary-library-loader'.
     Given a binary input port: read from it a serialised library;
     verify that its version reference conforms to LIBREF; intern it
     along with all its dependency libraries.

     If successful return a symbolic expression representing the R6RS
     library name of the interned library; otherwise return '#f'.

     This function assumes that applying the function 'port-id' to
     BINARY-PORT will return a string representing a file name
     associated to the port (or equivalent).


File: vicare-scheme.info,  Node: libutils locating,  Next: libutils file-system,  Prev: libutils loading,  Up: libutils

7.7 Locating libraries
======================

The function 'default-library-loader' is the default value of the
parameter 'current-library-loader', which is used to intern libraries;
*note default-library-loader: libutils loading.  Such default procedure
makes use of the function referenced by the parameter
'current-library-locator' to find libraries in some external repository.

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Parameter: current-library-locator
     Hold a function used to locate a library from its R6RS library
     reference.  The selected locator function must accept as single
     argument a R6RS library reference and it must return a thunk as
     single value.

   When invoked, the returned thunk must return two values:

   * When a matching source library is found:

       1. A textual input port from which the library can be read.

       2. A thunk to be called to continue the search in case the source
          library is rejected.

   * When a matching binary library is found:

       1. A binary input port from which the library can be read.

       2. A thunk to be called to continue the search in case the binary
          library is rejected.

   * When a matching library is found and interned by the thunk itself:

       1. The boolean '#t'.

       2. A thunk to be called to continue the search in case the
          library is rejected.

   * When no matching library is found:

       1. The boolean '#f'.

       2. The boolean '#f'.

   When an input port is returned as first value: it is responsibility
of the caller to close the returned port when no more needed; the thunk
discharges any responsibility.

   When a thunk is returned as second value: it must have the same API
of the thunk returned by the locator function; the possibility to
continue the search allows the caller to reject a library if it does not
meet some additional constraint.

   The parameter is meant to be used as in the following pseudo-code:

     (let loop
         ((next-locator-search ((current-library-locator) libref)))
       (receive (rv further-locator-search)
           (next-locator-search)
         (cond ((binary-port?  rv)
                (read-validate-intern-binary-library rv
                   (lambda ()
                     (loop further-locator-search))))
               ((textual-port? rv)
                (read-validate-intern-source-library rv
                   (lambda ()
                     (loop further-locator-search))))
               ((and (boolean? rv) rv)
                (library-already-interned))
               ((not rv)
                (no-matching-library-was-found))
               (else
                (assertion-violation __who__
                  "invalid return values from library locator" rv)))))

   Usually the locator function visits the host file system in search of
a file whose pathname matches the given library reference; other
possibilities are: programmatically fabricating the library on the spot;
downloading the library from a remote site.


File: vicare-scheme.info,  Node: libutils file-system,  Next: libutils dynamic,  Prev: libutils locating,  Up: libutils

7.8 Locating libraries on the file system
=========================================

The library '(vicare libraries)' exports an API to configure and extend
the process of searching for library files in source or binary format.
Here is an overview of the "finding libraries" process:

  1. To use a library we must first intern it.  Libraries are interned
     by the functions 'find-library-*' (*note Interning libraries:
     libutils interning.), which make use of the parameter
     'current-library-loader'.

  2. The parameter 'current-library-loader' references a function used
     to intern libraries given a R6RS library reference (*note
     current-library-loader: libutils loading.).

  3. The function 'default-library-loader' is the default value of the
     parameter 'current-library-loader' (*note default-library-loader:
     libutils loading.).

  4. The function 'default-library-loader' makes use of the function
     referenced by the parameter 'current-library-locator' to find
     libraries in some external repository (*note
     current-library-locator: libutils locating.).

  5. The parameter 'current-library-locator' is usually initialised to
     one of the functions:

              run-time-library-locator
          compile-time-library-locator
                source-library-locator

     either by default, or by direct selection with the command line
     option '--library-locator' (*note library-locator: using
     invoking.).

  6. The library locators 'run-time-library-locator',
     'compile-time-library-locator' and 'source-library-locator' search
     the file system for a library file pathname matching a specified
     R6RS library reference.

* Menu:

* libutils file-system extensions::     File extensions.
* libutils file-system pathnames::      Library file pathnames.
* libutils file-system paths::          Library search paths.
* libutils file-system binary::         Scanning the compiled
                                        libraries path.
* libutils file-system source::         Scanning the source
                                        libraries path.
* libutils file-system locators::       Library file locators.


File: vicare-scheme.info,  Node: libutils file-system extensions,  Next: libutils file-system pathnames,  Up: libutils file-system

7.8.1 File extensions
---------------------

Usually file extensions are the tail part of a file name: everything
after the last dot character; if the file name has no dot character: the
extension is the empty string.  Vicare extends this concept by defining
as file extensions strings that must be appended to a library stem to
build a library pathname (*note libutils file-system pathnames:: for
details on library stems).

   Source library file extensions are basically:

     .vicare.sls
     .sls

and, usually, '.sls' is used.  If the command line option
'--more-file-extensions' is used, the following extensions are also
considered:

     /main.vicare.sls
     /main.sls
     /main.vicare.ss
     /main.ss
     /main.vicare.scm
     /main.scm
     .vicare.ss
     .ss
     .vicare.scm
     .scm

   There is a single binary library file extension: '.fasl'.

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Parameter: library-extensions
     Hold a list of strings representing source library file name
     extensions, leading dot included.  This parameter is initialised
     to:

          (".vicare.sls" ".sls")


File: vicare-scheme.info,  Node: libutils file-system pathnames,  Next: libutils file-system paths,  Prev: libutils file-system extensions,  Up: libutils file-system

7.8.2 Library file pathnames
----------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: library-name->filename-stem LIBNAME
 -- Function: library-reference->filename-stem LIBREF
     Convert the non-empty list of identifiers from a R6RS library name
     LIBNAME or reference LIBREF into a string representing the
     corresponding relative file pathname, without extension but
     including a leading '#\/' character.  Examples:

          (library-name->filename-stem '(alpha beta gamma (1 2 3)))
          => "/alpha/beta/gamma"

          (library-name->filename-stem '(alpha beta main (1 2 3)))
          => "/alpha/beta/main_"

          (library-reference->filename-stem '(alpha beta gamma ((>= 3))))
          => "/alpha/beta/gamma"

          (library-reference->filename-stem '(alpha beta main ((>= 3))))
          => "/alpha/beta/main_"

     notice how the component 'main', when appearing last, is "quoted"
     by appending an underscore.

     The returned value can be used as:

        * Source library name, by appending an extension like '.sls'.

        * Compiled library name, by appending an extension like '.fasl'.

 -- Function: directory+library-stem->library-source-pathname DIRECTORY
          STEM
 -- Function: directory+library-stem->library-binary-pathname DIRECTORY
          STEM
     Given a string directory pathname and a string library stem: build
     and return a source or binary library file pathname.

          (directory+library-stem->library-source-pathname "a/b/c" "/d/e")
          => "a/b/c/d/e.sls"

          (directory+library-stem->library-binary-pathname "a/b/c" "/d/e")
          => "a/b/c/d/e.fasl"

 -- Function: library-name->library-binary-pathname-in-build-directory
          LIBNAME
 -- Function:
          library-reference->library-binary-pathname-in-build-directory
          LIBREF
     Given a R6RS compliant library name or reference: build and return
     a string representing the pathname of a binary library in the
     current build directory.  The current build directory is the
     pathname currently referenced by the parameter
     'compiled-libraries-build-directory'.

          (parametrise ((compiled-libraries-build-directory "/a/b"))
             (library-name->library-binary-pathname-in-build-directory
                '(c d (1 2 3))))
          => "/a/b/c/d.fasl"

          (parametrise ((compiled-libraries-build-directory "/a/b"))
             (library-reference->library-binary-pathname-in-build-directory
                '(c d ((>= 2)))))
          => "/a/b/c/d.fasl"

 -- Function: library-source-pathname->library-stem-pathname
          SOURCE-PATHNAME
     Given a string representing the file pathname of a source library:
     strip the file extensions if it is equal to a supported Vicare file
     extension and return the result.  If the file extension is not
     recognised: return SOURCE-PATHNAME itself.

          (library-source-pathname->library-stem-pathname "a/b/c.sls")
          => "a/b/c"

          (library-source-pathname->library-stem-pathname "a/b/c.vicare.sls")
          => "a/b/c"

          (library-source-pathname->library-stem-pathname "a/b/c.scm")
          => "a/b/c"

          (library-source-pathname->library-stem-pathname "a/b/c.ss")
          => "a/b/c"

          (library-source-pathname->library-stem-pathname "a/b/c.ciao")
          => "a/b/c.ciao"

 -- Function: library-source-pathname->library-binary-tail-pathname
          SOURCE-PATHNAME
     Given a string representing the file pathname of a source library:
     strip the file extension if it is equal to a supported Vicare file
     extension, append the binary library extension and return the
     result.  If the file extension is not recognised: return
     SOURCE-PATHNAME itself with the binary library extension appended.

          (library-source-pathname->library-binary-tail-pathname
             "a/b/c.sls")
          => "a/b/c.fasl"

          (library-source-pathname->library-binary-tail-pathname
             "a/b/c.vicare.sls")
          => "a/b/c.fasl"

          (library-source-pathname->library-binary-tail-pathname
             "a/b/c.scm")
          => "a/b/c.fasl"

          (library-source-pathname->library-binary-tail-pathname
             "a/b/c.ss")
          => "a/b/c.fasl"

          (library-source-pathname->library-binary-tail-pathname
             "a/b/c.ciao")
          => "a/b/c.ciao.fasl"


File: vicare-scheme.info,  Node: libutils file-system paths,  Next: libutils file-system binary,  Prev: libutils file-system pathnames,  Up: libutils file-system

7.8.3 Library search paths
--------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Parameter: library-binary-search-path
     Hold a list of strings representing relative or absolute directory
     pathnames; the strings must represent syntactically valid pathname
     specifications, but the directories might not exist.  The list is
     used as search path for binary libraries serialised in FASL files,
     iterating from head to tail.

     Files in the binary search path have pathnames formed by appending
     a binary library file extension to the library stem and prepending
     a directory from the search path to the result.  Such pathnames can
     be constructed as follows:

          (define dir-pathname
            (car (library-binary-search-path)))

          (define libstem
            (library-reference->filename-stem ?LIBREF))

          (define binary-pathname
            (directory+library-stem->library-binary-pathname
               dir-pathname libstem))

     The value of the parameter 'library-binary-search-path' is composed
     as follows:

       1. The parameter is initialised to a list of directory pathnames
          built at package configuration time; the list contains:

               $(libdir)/vicare-scheme

          on 64-bit GNU+Linux systems, it is usually:

               /usr/local/lib64/vicare-scheme

          and on 32-bit GNU+Linux systems:

               /usr/local/lib/vicare-scheme

       2. At the beginning of execution Vicare consults the environment
          variable 'VICARE_LIBRARY_PATH'; when set, it is expected to
          hold a colon separated list of directory pathnames, in
          Unix-style.  The list is parsed and the directories are
          pepended, in the given order, in 'library-binary-search-path'.

       3. If the option '-L' or '--library-path' is present on the
          command line one or more time: every option's value is
          expected to be a string representing a directory pathname.
          Such pathnames are prepended, in the given order, to
          'library-binary-search-path'.

       4. While 'vicare' is running: we can modify at will the content
          of 'library-binary-search-path'.

 -- Parameter: library-source-search-path
     Hold a list of strings representing relative or absolute directory
     pathnames; the strings must represent syntactically valid pathname
     specifications, but the directories might not exist.  The list is
     used as search path for source libraries stored in text files (in
     ASCII or UTF-8 format), iterating from head to tail.

     Files in the source search path have pathnames formed by appending
     a source library file extension to the library stem and prepending
     a directory from the search path to the result.  Such pathnames can
     be constructed as follows:

          (define dir-pathname
            (car (library-binary-search-path)))

          (define libstem
            (library-name->filename-stem ?LIBNAME))

          (define source-pathname
            (directory+library-stem->library-source-pathname
               dir-pathname libstem))

     The value of the parameter 'library-source-search-path' is composed
     as follows:

       1. The parameter is initialised to the empty list.

       2. At the beginning of execution, Vicare consults the environment
          variable 'VICARE_SOURCE_PATH'; when set, it is expected to
          hold a colon separated list of directory pathnames, in
          Unix-style.  The list is parsed and the directories are
          prepended, in the given order, to
          'library-source-search-path'.

       3. If the option '--source-path' is present on the command line
          one or more time: every option's value is expected to be a
          string representing a directory pathname.  Such pathnames are
          prepended, in the given order, to
          'library-source-search-path'.

       4. While 'vicare' is running: we can modify at will the content
          of 'library-source-search-path'.


File: vicare-scheme.info,  Node: libutils file-system binary,  Next: libutils file-system source,  Prev: libutils file-system paths,  Up: libutils file-system

7.8.4 Scanning the compiled libraries path
------------------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Parameter: current-library-binary-search-path-scanner
     Hold a function used to convert a R6RS library reference into the
     corresponding compiled library file pathname in the search path
     specified by the parameter 'library-binary-search-path'.

     The referenced function must accept, as single value, a R6RS
     library reference and it must return two values.  When successful:
     a string representing the FASL file pathname; a thunk to be called
     to continue the search from the next directory in the search path.
     When no matching library is found: it must return '#f' and '#f'.

     This parameter can be used as follows:

          (define scanner
            (current-library-binary-search-path-scanner))

          (let loop ((next-file-match (lambda ()
                                        (scanner libref))))
            (receive (pathname further-file-match)
                (next-file-match)
              (if pathname
                  (if (valid-library? pathname)
                      (use-the-library pathname)
                    (loop further-file-match))
                (search-failed))))

 -- Function: default-library-binary-search-path-scanner LIBREF
     Default value for the parameter
     'current-library-binary-search-path-scanner'.  Given a R6RS library
     reference: scan the search path specified by the parameter
     'library-binary-search-path' for the corresponding file.

     Return two values.  When successful: a string representing the file
     pathname; a thunk to be called to continue the search from the next
     directory in the search path.  When no matching library is found:
     return '#f' and '#f'.

     The file pathname is built using the stem returned by
     'library-reference->filename-stem'.  Notice that the file pathnames
     built by this function have no version number embedded in the
     pathname; if we want to search for a binary file with version
     number included: we must set the parameter
     'current-library-binary-search-path-scanner' to a different
     function.


File: vicare-scheme.info,  Node: libutils file-system source,  Next: libutils file-system locators,  Prev: libutils file-system binary,  Up: libutils file-system

7.8.5 Scanning the source libraries path
----------------------------------------

The following bindings are exported by the library '(vicare libraries)'.

 -- Parameter: current-library-source-search-path-scanner
     Hold a function used to convert a R6RS library reference into the
     corresponding source library file pathname in the search path
     specified by the parameter 'library-source-search-path'.

     The referenced function must accept, as single value, a R6RS
     library reference and it must return two values.  When successful:
     a string representing the source file pathname; a thunk to be
     called to continue the search from the next directory in the search
     path.  Otherwise it must return '#f' and '#f'.

     This parameter can be used as follows:

          (define scanner
            (current-library-source-search-path-scanner))

          (let loop ((next-file-match (lambda ()
                                        (scanner libref))))
            (receive (pathname further-file-match)
                (next-file-match)
              (if pathname
                  (if (valid-library? pathname)
                      (use-the-library pathname)
                    (loop further-file-match))
                (search-failed))))

 -- Function: default-library-source-search-path-scanner LIBREF
     Default value for the parameter
     'current-library-source-search-path-scanner'.  Given a R6RS library
     reference: scan the source library search path for the
     corresponding file.

     Return two values.  When successful: a string representing the
     source file pathname; a thunk to be called to continue the search
     from the next directory in the search path.  Otherwise it must
     return '#f' and '#f'.

     The file pathname is built using the stem returned by
     'library-reference->filename-stem'.  Notice that the file pathnames
     built by this function have no version number embedded in the
     pathname; if we want to search for a source file with version
     number included: we must set the parameter
     'current-library-source-search-path-scanner' to a different
     function.


File: vicare-scheme.info,  Node: libutils file-system locators,  Prev: libutils file-system source,  Up: libutils file-system

7.8.6 Library file locators
---------------------------

* Menu:

* libutils file-system locators run::     Run-time library file locator.
* libutils file-system locators compile:: Compile-time library file locator.
* libutils file-system locators source::  Source library file locator.


File: vicare-scheme.info,  Node: libutils file-system locators run,  Next: libutils file-system locators compile,  Up: libutils file-system locators

7.8.6.1 Run-time library file locator
.....................................

The run-time library locator is the default; it can be selected
explicitly with the command line option '--library-locator run-time' or
by setting the parameter 'current-library-locator' to
'run-time-library-locator'; it is meant to be used by an installation of
Vicare to run applications.  The reference scenario for the run-time
library locator is this:

  1. We install the package Vicare Scheme, compiling bundled libraries
     and putting them in some system directory; the libraries might be
     installed with pathnames like:

           '/usr/local/lib/vicare-scheme/vicare/posix.fasl'

  2. We install additional packages, compiling distributed libraries and
     putting them in some system directory; the libraries might be
     installed with pathnames like:

         '/usr/local/lib/vicare-scheme/vicare/something.fasl'

  3. We configure the library binary search path to make sure that it
     includes the system directory:

          (library-binary-search-path)
          => (... "/usr/local/lib/vicare-scheme" ...)

  4. We configure the library binary file scanner parameter:

          (current-library-binary-search-path-scanner
             default-library-binary-search-path-scanner)

     which will scan the search path returned by
     '(library-binary-search-path)'.

  5. We compose a Scheme program 'demo.sps' which imports the libraries:

          (import (vicare)
            (prefix (vicare posix) px.)
            (vicare something))

     and we execute it selecting the run-time library locator:

          $ vicare --library-locator run-time --r6rs-script demo.sps

     the command line option '--library-locator' will put
     'run-time-library-locator' in the parameter
     'current-library-locator'.

the result is that Vicare will search the binary libraries search path
for library files.

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Function: run-time-library-locator LIBREF
     Possible value for the parameter 'current-library-locator'; this
     function is meant to be used to search for libraries when running
     an application.

     Given a R6RS library reference: return a thunk to be used to start
     the search for a matching library.  The returned thunk scans the
     search path for compiled libraries in search of a matching binary
     file; if a matching compiled library is not found: it scans the
     search path for source libraries in search of a matching source
     file.

     When successful the returned thunk returns 2 values:

       1. An input port from which the library can be read; if the port
          is binary: a compiled library can be read from it; if the port
          is textual a source library can be read from it.  It is
          responsibility of the caller to close the returned port when
          no more needed.

       2. A thunk to be called to continue the search.  This thunk
          allows the caller to reject a library if it does not meet some
          additional constraints; for example: if its version number
          does not conform to LIBREF.

     When no matching library is found: the returned thunk returns '#f'
     and '#f'.


File: vicare-scheme.info,  Node: libutils file-system locators compile,  Next: libutils file-system locators source,  Prev: libutils file-system locators run,  Up: libutils file-system locators

7.8.6.2 Compile-time library file locator
.........................................

The compile-time library locator must be selected explicitly with the
command line option '--library-locator compile-time' or by setting the
parameter 'current-library-locator' to 'compile-time-library-locator';
it is meant to be used from the build directory of a package while
compiling libraries for development or future installation.  The
reference scenario for the compile-time library locator is this:

  1. We install the package Vicare Scheme, compiling bundled libraries
     and putting them in some system directory; the libraries might be
     installed with pathnames like:

           '/usr/local/lib/vicare-scheme/vicare/posix.fasl'

  2. We install additional packages, compiling distributed libraries and
     putting them in some system directory; the libraries might be
     installed with pathnames like:

         '/usr/local/lib/vicare-scheme/vicare/something.fasl'

  3. We unpack the distribution tarball of a package providing even more
     libraries.  We have the source libraries under:

          $(srcdir)/lib/vicare/this.sls
          $(srcdir)/lib/vicare/that.sls

     we want to compile them under the build directory:

          $(builddir)/lib/vicare/this.fasl
          $(builddir)/lib/vicare/that.fasl

     and then install them in a system directory:

          /usr/local/lib/vicare-scheme/vicare/this.fasl
          /usr/local/lib/vicare-scheme/vicare/that.fasl

     In the package's building infrastructure (for example a Makefile
     managed by the GNU Autotools) we need to write appropriate
     invocations of 'vicare' to build the libraries locally and pick the
     appropriate source libraries and compiled libraries.

  4. It may be that the libraries in the source tree need to load
     installed libraries and also have local dependencies:

          (library (vicare this)
            (export)
            (import (vicare)
              (vicare that))
            ---)

          (library (vicare that)
            (export)
            (import (vicare)
              (prefix (vicare posix) px.)
              (vicare something))
            ---)

  5. It may be that an older version of the package is already
     installed, so there already exist installed binary libraries:

          /usr/local/lib/vicare-scheme/vicare/this.fasl
          /usr/local/lib/vicare-scheme/vicare/that.fasl

     we want the libraries under '$(builddir)/lib' to take precedence
     over the libraries under '/usr/local/lib/vicare-scheme'.  It may be
     that there exist installed source libraries:

          /usr/local/lib/vicare-scheme/vicare/this.sls
          /usr/local/lib/vicare-scheme/vicare/that.sls

     we want the libraries under '$(srcdir)/lib' to take precedence over
     the libraries under '/usr/local/lib/vicare-scheme'.

   At the Scheme level we want the following:

   * Configure the library source search path to include only the local
     source directory:

          (library-source-search-path)
          => ("$(srcdir)/lib")

   * Configure the library binary search path to include the system
     directory:

          (library-binary-search-path)
          => (... "/usr/local/lib/vicare-scheme" ...)

   * Configure the build directory to reference the local build
     directory:

          (compiled-libraries-build-directory)
          => "$(builddir)/lib

   * Configure the library binary file scanner parameter:

          (current-library-binary-search-path-scanner
             default-library-binary-search-path-scanner)

     which will scan the search path returned by
     '(library-binary-search-path)'.

   * Configure the library source file scanner parameter:

          (current-library-source-search-path-scanner
             default-library-source-search-path-scanner)

     which will scan the search path returned by
     '(library-source-search-path)'.

   * Configure the library locator parameter:

          (current-library-locator compile-time-library-locator)

     which implements the appropriate policy.

   Assuming Makefiles generated by GNU Automake: to achieve the desired
result, we have two options:

  1. For every library to be compiled locally, we write in the Makefile
     an explicit dependency rule:

          lib/vicare/that.fasl: lib/vicare/that.sls
                  VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH;    \
                  vicare --library-locator compile-time              \
                     --library-path    /usr/local/lib/vicare-scheme  \
                     --source-path     $(srcdir)/lib                 \
                     --build-directory $(builddir)/lib               \
                     -o $@ -c $<

          lib/vicare/this.fasl: lib/vicare/this.sls lib/vicare/that.fasl
                  VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH;    \
                  vicare --library-locator compile-time              \
                     --library-path    /usr/local/lib/vicare-scheme  \
                     --source-path     $(srcdir)/lib                 \
                     --build-directory $(builddir)/lib               \
                     -o $@ -c $<

     this is the solution to prefer, because it allows parallel builds.

  2. We write a script 'compile-all.sps' that imports at least the local
     libraries that are leaves in the local package dependency tree:

          (import (only (vicare that))
                  (only (vicare this)))

     write a single Makefile rule that compiles in the build directory
     all the dependencies of the script:

          .PHONY: vfasl

          vfasl:
                  VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH;    \
                  vicare --library-locator compile-time              \
                     --library-path    /usr/local/lib/vicare-scheme  \
                     --source-path     $(srcdir)/lib                 \
                     --build-directory $(builddir)/lib               \
                     --compile-dependencies compile-all.sps

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Function: compile-time-library-locator LIBREF
     Possible value for the parameter 'current-library-locator'; this
     function is meant to be used to search for libraries to be compiled
     for installation.

     Given a R6RS library reference: return a thunk to be used to start
     the search for a matching library.  The search for source libraries
     is performed using the library source file scanner in
     'current-library-source-search-path-scanner'.  The search for
     compiled libraries is performed using the library binary file
     scanner in 'current-library-binary-search-path-scanner'.

     The returned thunk does the following:

       1. Ask the library source file scanner for the next matching
          source file.

       2. If a matching source is found: look for an already compiled
          library file in the 'compiled-libraries-build-directory':

            a. If no compiled file exists or it if exists but it is
               older than the source file: accept the source file as
               matching.

            b. If a compiled file exists and it is newer than the source
               file: accept the compiled file as matching.

            c. Return to the caller the matching file pathname.

            d. If the caller rejects the binary file pathname: return to
               the caller the source file pathname.

            e. If the caller rejects the source file: loop to 1.

       3. If no source file exists: loop to 1.

     Remember that the binary file can be rejected if it has been
     compiled by another boot image or it has the wrong library UID.

     When successful (a source or binary file matching LIBREF is found)
     the returned thunk returns 2 values:

       1. An input port.  If the port is binary: a compiled library can
          be read from it.  If the port is textual: a source library can
          be read from it.  It is responsibility of the caller to close
          the returned port when no more needed.

       2. A thunk to be called to continue the search.  This thunk
          allows the caller to reject a library if it does not meet some
          additional constraint; for example: if its version number does
          not conform to LIBREF.

     When no matching library is found: the returned thunk returns '#f'
     and '#f'.


File: vicare-scheme.info,  Node: libutils file-system locators source,  Prev: libutils file-system locators compile,  Up: libutils file-system locators

7.8.6.3 Source library file locator
...................................

The source library locator must be selected explicitly with the command
line option '--library-locator source' or by setting the parameter
'current-library-locator' to 'source-library-locator'; it is meant to be
used to search for source libraries first and then for compiled ones.
The reference scenario for the source library locator is this:

  1. We install the package Vicare Scheme, compiling bundled libraries
     and putting them in some system directory; the libraries might be
     installed with pathnames like:

           '/usr/local/lib/vicare-scheme/vicare/posix.fasl'

  2. We install additional packages, compiling distributed libraries and
     putting them in some system directory; the libraries might be
     installed with pathnames like:

         '/usr/local/lib/vicare-scheme/vicare/something.fasl'

  3. We checkout the source tree of a package repository to develop even
     more libraries.  We have the source libraries under:

          $(srcdir)/lib/vicare/this.sls
          $(srcdir)/lib/vicare/that.sls

     we want to compile them under the build directory:

          $(builddir)/lib/vicare/this.fasl
          $(builddir)/lib/vicare/that.fasl

     and then install them in a system directory:

          /usr/local/lib/vicare-scheme/vicare/this.fasl
          /usr/local/lib/vicare-scheme/vicare/that.fasl

     In the package's building infrastructure (for example a Makefile
     managed by the GNU Autotools) we need to write appropriate
     invocations of 'vicare' to build the libraries locally and pick the
     appropriate source libraries and compiled libraries.

     This is the gist: we want to automatically generate an include
     Makefile holding the compilation and installation recipes correctly
     describing the dependencies among libraries.  For this we need to
     load all the source libraries in the package's source tree.

  4. It may be that the libraries in the source tree need to load
     installed libraries and also have local dependencies:

          (library (vicare this)
            (export)
            (import (vicare)
              (vicare that))
            ---)

          (library (vicare that)
            (export)
            (import (vicare)
              (prefix (vicare posix) px.)
              (vicare something))
            ---)

  5. It may be that an older version of the package is already
     installed, so there already exist installed binary libraries:

          /usr/local/lib/vicare-scheme/vicare/this.fasl
          /usr/local/lib/vicare-scheme/vicare/that.fasl

     we want these installed libraries to be ignored.  It may be that
     there exist installed source libraries:

          /usr/local/lib/vicare-scheme/vicare/this.sls
          /usr/local/lib/vicare-scheme/vicare/that.sls

     we want the libraries under '$(srcdir)/lib' to take precedence over
     the libraries under '/usr/local/lib/vicare-scheme'.

   At the Scheme level we want the following:

   * Configure the library source search path to include only the local
     source directory:

          (library-source-search-path)
          => ("$(srcdir)/lib")

   * Configure the library binary search path to include the system
     directory:

          (library-binary-search-path)
          => (... "/usr/local/lib/vicare-scheme" ...)

   * Configure the library binary file scanner parameter:

          (current-library-binary-search-path-scanner
              default-library-binary-search-path-scanner)

     which will scan the search path returned by
     '(library-binary-search-path)'.

   * Configure the library source file scanner parameter:

          (current-library-source-search-path-scanner
              default-library-source-search-path-scanner)

     which will scan the search path returned by
     '(library-source-search-path)'.

   * Configure the library locator parameter:

          (current-library-locator source-library-locator)

     which implements the appropriate policy.

   To achieve the desired result, in the Makefile we write rules as
follows:

     .PHONY: dependencies

     DEPSCRIPT = $(srcdir)/scripts/build-makefile-rules.sps

     dependencies:
             VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH; \
             vicare --library-locator source                 \
               --library-path /usr/local/lib/vicare-scheme   \
               --source-path  $(srcdir)/lib                  \
               --r6rs-script  $(DEPSCRIPT) --                \
               $(slsdir)/libraries.scm >$(slsdir)/dependencies.make

where the executed Scheme script generates the Makefile rules
automatically.

   The following bindings are exported by the library '(vicare
libraries)'.

 -- Function: source-library-locator LIBREF
     Possible value for the parameter 'current-library-locator'; this
     function is meant to be used to search for source libraries first
     and for binary libraries later.

     Given a R6RS library reference: return a thunk to be used to start
     the search for a matching library.  The returned thunk uses the
     current source library scanner referenced by
     'current-library-source-search-path-scanner', with the purpose of
     finding a library file that matches a given R6RS library reference.
     If no source library is found: the current binary library scanner
     referenced by 'current-library-binary-search-path-scanner' is used.

     When successful the returned thunk returns 2 values:

       1. An input port.  If it is a textual input port: a source
          library can be read from it.  If it is a binary input port: a
          binary library can be read from it.  It is responsibility of
          the caller to close the returned port when no more needed.

       2. A thunk to be called to continue the search.  This thunk
          allows the caller to reject a library if it does not meet some
          additional constraint; for example: if its version number does
          not conform to LIBREF.

     When no matching library is found: the returned thunk returns '#f'
     and '#f'.


File: vicare-scheme.info,  Node: libutils dynamic,  Next: libutils compiling,  Prev: libutils file-system,  Up: libutils

7.9 Dynamically loading Scheme libraries
========================================

It is possible to dynamically load a Scheme library after the program
has been compiled.  Here is an example of: creating a library, importing
it, then dynamically loading its syntactic bindings:

     (import (vicare)
       (prefix (vicare libraries) libs.))

     (library (demo-01)
       (export fun var)
       (import (rnrs))
       (define (fun a b)
         (+ a b))
       (define var 123))

     (import (demo-01))

     (let* ((lib (libs.library-dynamic-load-and-intern '(demo-01)))
            (fun (libs.library-dynamic-retrieve lib 'fun))
            (var (libs.library-dynamic-retrieve lib 'var)))
       (values (fun 1 2) var))
     => 3 123

another example which loads the installed '(vicare pregexp)':

     (import (vicare)
       (prefix (vicare libraries) libs.))

     (define-values (pregexp-match)
       (let ((lib (libs.library-dynamic-load-and-intern
                      '(vicare pregexp))))
         (values (libs.library-dynamic-retrieve lib 'pregexp-match))))

     (pregexp-match "[a-z]+" "ciao hello ciao")
     => ("ciao")

 -- Function: library-dynamic-load-and-intern LIBREF
     Search for a library whose name matches the library reference
     LIBREF, intern it and invoke it.  When successful return a
     '<library>' object.  If an error occurs: raise an exception.

     This function makes use of 'find-library-by-name' to search and
     intern the requested library.

 -- Function: library-dynamic-retrieve LIB NAME
     Search in the GLOBAL-ENV of the '<library>' object LIB an exported
     syntactic binding whose public name is the symbol NAME.  When
     successful: return the value bound to the syntactic binding.  If an
     error occurs: raise an exception.


File: vicare-scheme.info,  Node: libutils compiling,  Prev: libutils dynamic,  Up: libutils

7.10 Compiling libraries
========================

* Menu:

* libutils compiling special::  Special directories.


File: vicare-scheme.info,  Node: libutils compiling special,  Up: libutils compiling

7.10.1 Special directories
--------------------------

* Menu:

* libutils compiling special build::  The build directory.


File: vicare-scheme.info,  Node: libutils compiling special build,  Up: libutils compiling special

7.10.1.1 The build directory
............................

The following bindings are exported by the library '(vicare libraries)'.

 -- Parameter: compiled-libraries-build-directory
     Hold '#f' or a string representing the absolute or relative
     pathname of a directory; the string must represent a syntactically
     valid pathname, but the directory might not exist.  The build
     directory is meant to be used when compiling libraries in the build
     directory of a source package for later installation.

     When the selected library locator is 'compile-time': the store
     directory is used to search for compiled libraries.  It is an error
     if the library locator is 'compile-time' and no build directory is
     selected.

     Under the build directory: FASL files are stored with pathnames
     composed from the library stem, which is generated from the library
     name.  For example, if the build directory is '$(builddir)/lib' the
     source library:

          $(srcdir)/lib/vicare/posix.sls

     is stored as:

          $(builddir)/lib/vicare/posix.fasl

     Such pathnames can be built as follows:

          (define binary-pathname-0
            (library-name->library-binary-pathname-in-build-directory
              ?LIBNAME))

          (define binary-pathname-1
            (library-reference->library-binary-pathname-in-build-directory
              ?LIBREF))

     The value of the parameter 'compiled-libraries-build-directory' is
     composed as follows:

       1. The parameter is initialised to '#f'.

       2. If the environment variable 'VICARE_STORE_DIRECTORY' is set
          and holding an valid directory pathname: select its value as
          parameter value; the directory itself might not exist.

       3. If the option '--build-directory' is present on the command
          line: its value is expected to be a string representing a
          directory pathname, otherwise an error is raised; the
          directory itself might not exist.  Such pathname becomes the
          value of 'compiled-libraries-build-directory'.

       4. While 'vicare' is running: we can modify at will the content
          of 'compiled-libraries-build-directory'.


File: vicare-scheme.info,  Node: progutils,  Next: includes,  Prev: libutils,  Up: Top

8 Scheme programs utilities
***************************

The library '(vicare programs)' exports bindings to deal with the
programs infrastructure of Vicare; this library is integrated in the
boot image.  It is suggested to import it using the prefix 'progs.', as
in

     (import (prefix (vicare programs) progs.))

* Menu:

* progutils pathanmes::         Processing file pathnames.
* progutils expanding::         Expanding programs.


File: vicare-scheme.info,  Node: progutils pathanmes,  Next: progutils expanding,  Up: progutils

8.1 Processing file pathnames
=============================

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: program-source-pathname->program-binary-pathname
          SOURCE-PATHNAME
     Given a string representing the pathname of a Scheme program: build
     and return the pathname of the corresponding compiled program.

     If SOURCE-PATHNAME has file extension '.sps': strip such extension;
     otherwise append the extension '.fasl'.

          (program-source-pathname->program-binary-pathname
             "demo.sps")
          => "demo"

          (program-source-pathname->program-binary-pathname
             "tests/demo.sps")
          => "tests/demo"

          (program-source-pathname->program-binary-pathname
             "demo.ciao")
          => "demo.ciao.fasl"

          (program-source-pathname->program-binary-pathname
             "tests/demo.ciao")
          => "tests/demo.ciao.fasl"


File: vicare-scheme.info,  Node: progutils expanding,  Prev: progutils pathanmes,  Up: progutils

8.2 Expanding programs
======================

The following bindings are exported by the library '(vicare libraries)'.

 -- Function: expand-top-level-program SEXP
     Expand an R6RS program whose symbolic expression is SEXP.  Return 6
     values:

     INVOKE-LIB*
          A list of 'library' objects representing the libraries that
          need to be invoked to run the code.

     INVOKE-CODE
          The fully expanded code from the body of the program.

     MACRO*
          A list of sublists representing the macros defined in the
          program.

     EXPORT-SUBST
          A subst representing the top-level bindings.

     GLOBAL-ENV
          A list representing the bindings exported by the program.

     OPTION*
          A list of symbols representing the options enabled for this
          program; *note iklib programs:: for details.

 -- Function: expand-top-level-program->sexp SEXP
     This function is for debugging purposes.  Expand the program form
     SEXP and return the return values of 'expand-top-level-program' in
     an alist with the following symbols as keys:

          invoke-lib* invoke-code
          visit-code
          export-subst global-env
          option*

   We can toy with the program expander using the following code:

     #!r6rs
     (import (vicare)
       (prefix (vicare programs) progs.))
     (print-gensym #f)
     (print-graph  #f)
     (debug-print (progs.expand-top-level-program->sexp ?SEXP))

where ?SEXP is the program symbolic expression.  For example, expanding
the program:

     (import (vicare))
     (define var 1)
     (define-syntax (mac stx)
       2)
     (display var)

yields the 'invoke-code':

     (library-letrec*
         ((lex.var   loc.lex.var   '1)
          (lex.dummy loc.lex.dummy
             (begin
               (annotated-call (display var)
                  (primitive display) lex.var)
               '#!void)))
       '#!void)

the 'visit-code':

     (set! loc.lab.mac
           (annotated-case-lambda
               (#'lambda #'stx #'2)
             ((lex.stx) '2)))

where the procedure is the result of compiling and evaluating the
expanded code; the 'export-subst' (with many entries removed):

     ((flmod          . g2374)
      (flonum->string . g990)
      (flsquare       . g743)
      ...
      (var            . lab.var)
      (mac            . lab.mac))

the 'global-env':

     ((lab.var global       . loc.lex.var)
      (lab.mac global-macro . loc.lab.mac))


File: vicare-scheme.info,  Node: includes,  Next: foreign,  Prev: progutils,  Up: Top

9 Including source files at expand-time
***************************************

Include files are loaded at expand-time by the syntax 'include'.  Here
is a usage example with the default configuration for searching and
loading files:

  1. Let's create a source file in the current directory:

          ;; demo.scm --
          ;;

          (define (doit)
            (display "hello world!\n"))

          ;;; end of file

  2. Let's create a library file in the current directory, including the
     source file:

          ;; demo.sls --
          ;;

          (library (demo)
            (export doit)
            (import (vicare))
            (include "demo.scm" #t))

          ;;; end of file

  3. Let's enter the REPL, adding the current directory to the search
     path for source files:

          $ vicare --source-path $PWD --option print-loaded-libraries
          ...
          vicare> (import (demo))
          vicare: searching include file: demo.scm
          vicare: including file: /tmp/demo.scm
          vicare: loaded library "(demo)" from: /tmp/demo.sls
          vicare> (doit)
          hello world!
          vicare>

     the syntax 'include' makes uses the same search path selected for
     source libraries.

  4. Now we can compile the library:

          $ vicare --source-path $PWD --option print-loaded-libraries \
             --compile-library demo.sls --output demo.fasl
          vicare: compile-source-library: loading library: demo.sls
          vicare: searching include file: demo.scm
          vicare: including file: /tmp/demo.scm
          vicare: serialising library: demo.fasl
          vicare: library serialisation done

     and remember that 'include' is and expand-time thing, so the
     compiled library will not perform any inclusion.

  5. Finally we enter the REPL adding the current directory to the
     search path for binary libraries:

          $ vicare -L $PWD --option print-loaded-libraries
          ...
          vicare> (import (demo))
          vicare: loaded library "(demo)" from: /tmp/demo.fasl
          vicare> (doit)
          hello world!
          vicare>

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Syntax: include ?FILENAME
 -- Syntax: include ?FILENAME #t
     Include in the enclosing source file the contents of the file
     selected by the pathname ?FILENAME, which must be a string.
     Everything happens as if the code was present in place of the
     'include' form.  When the optional '#t' argument is given: print a
     message on the current error port describing the include operation.

Customisation of include operation
..................................

 -- Parameter: current-include-loader
     Hold a function used to load an include file.  The referenced
     function is called as follows:

          ((current-include-loader) ?INCLUDE-PATHNAME ?VERBOSE ?SYNNER)

     where: ?INCLUDE-PATHNAME must be a string representing an absolute
     or relative pathname; ?VERBOSE can be any value; ?SYNNER must be a
     procedure used to raise an exception when an error occurs:

          (?SYNNER ?MESSAGE-STRING ?IRRITANTS)

     When successful, the referenced function must return two values:
     the absolute pathname from which the file was loaded, a symbolic
     expression representing the file contents (usually such expression
     is generated by the reader).  When an error occurs: call the
     procedure ?SYNNER, which is meant to raise an exception.

     If ?VERBOSE is non-false: the referenced function must display
     verbose messages on the current error port describing the including
     process.

 -- Function: default-include-loader INCLUDE-PATHNAME VERBOSE? SYNNER
     Default value for the parameter 'current-include-loader'.  Load the
     file with pathname INCLUDE-PATHNAME.  When successful return two
     values: the absolute pathname from which the file was loaded, a
     symbolic expression representing the file contents.  When an error
     occurs: call the procedure SYNNER, which is meant to raise an
     exception.

     If VERBOSE? is non-false: display verbose messages on the current
     error port describing the including process.

     The include file is searched using the procedure referenced by the
     parameter 'current-include-file-locator'.  The file is loaded using
     the procedure referenced by the parameter
     'current-include-file-loader'.

Locating the file to be included
................................

 -- Parameter: current-include-file-locator
     Hold a function used to convert an include file name into the
     corresponding file pathname.  The referenced function must accept
     three arguments: a string representing the include file name; a
     boolean, true if the process of loading must display verbose
     messages on the current error port; a synner function used to
     report errors.

     The synner function is called as:

          (synner ?ERROR-MESSAGE ?IRRITANTS)

 -- Function: default-include-file-locator INCLUDE-PATHNAME SYNNER
     Default value for the parameter 'current-include-file-locator'.
     Given a string INCLUDE-PATHNAME, which must represent an absolute
     or relative file pathname, convert it into the absolute pathname of
     an existing file, as string.  Return the absolute string pathname.

     If INCLUDE-PATHNAME is a relative pathname: the file is searched in
     the search path represented by 'library-source-search-path', by
     appending INCLUDE-PATHNAME to the directories in the search path;
     *note Search path for source libraries: library-source-search-path.

     SYNNER must be a procedure used to raise an exception when an error
     occurs.

Loading the file to be included
...............................

 -- Parameter: current-include-file-loader
     Hold a function used to load an include file.  The referenced
     function must accept two arguments: a string representing an
     existent file pathname; a synner function used to report errors.

     The synner function is called as:

          (synner ?ERROR-MESSAGE ?IRRITANTS)

 -- Function: default-include-file-loader INCLUDE-PATHNAME SYNNER
     Default value for the parameter 'current-include-file-loader'.
     Open the file INCLUDE-PATHNAME, read all the datums and return
     them.  If an error occurs call SYNNER.  The returned value is a
     list of annotated symbolic expressions as generated by Vicare's
     source code reader.


File: vicare-scheme.info,  Node: foreign,  Next: ffi,  Prev: includes,  Up: Top

10 Interfacing with adapting foreign libraries
**********************************************

The core macro 'foreign-call', exported by the library '(vicare)', is
expanded to the core language syntax 'foreign-call', which in turn is
compiled to code invoking a C function from the operating system's
process image; the first argument to 'foreign-call' is a string naming
the C function.

   Whenever the code:

     (foreign-call "function_name" ?ARG ...)

is compiled, the C pointer referencing the entry point of the named
function is retrieved with a C language call:

     dlsym(RTLD_DEFAULT, "function_name");

so all the public functions from the running 'vicare' executable are
available; also available are all the functions from host's shared
libraries loaded with 'dlopen()' using the flags 'RTLD_NOW |
RTLD_GLOBAL'.

   This API for C language functions call is meant to be used to
interface with functions specifically written to be called from Scheme
code; examples are interface libraries installed by the Vicare extension
packages like Vicare/CURL and Vicare/SQLite.  This API *cannot* be used
to directly call a generic C language function from, say, 'libz.so' or
'libgmp.so'.

   It is possible to associate one or more host's shared libraries to a
FASL file, so that: whenever the FASL file is loaded, the shared library
is loaded too and the functions required by 'foreign-call' are
available.  This is especially useful to implement bindings to foreign
libraries without relying on the FFI and making full use of garbage
collection facilities and access to Scheme values' memory
representations.

   A Vicare's library might have the format:

     (library (libname)
       (foreign-library ?FOREIGN-LIBRARY-ID)
       (export . ?EXPORT-SPECS)
       (import . ?IMPORT-SPECS)
       . ?BODY)

and a Vicare's top-level program might have the format:

     (program (progname)
       (foreign-library ?FOREIGN-LIBRARY-ID)
       (import . ?IMPORT-SPECS)
       . ?BODY)

the ?FOREIGN-LIBRARY-ID form must be a string representing the
identifier of a host's shared object.  There can be any number of
'foreign-library' clauses, all before 'export' for libraries and before
'import' for programs.

   The identifier is used to build the file name of a shared object; for
example the identifier 'vicare-curl' is used to build the following file
names:

'libvicare-curl.so'
     On Unix-like systems, including GNU+Linux.

'libvicare-curl.dylib'
     On Darwin systems.

'vicare-curl.dll'
     On Cygwin systems.

   Whenever the library or program are expanded: the shared objects are
immediately loaded using 'dlopen()'.

   Whenever a library or program in binary form is written to a FASL
file: an object field with header 'O' is written to the *beginning* of
the FASL file; such object will cause the shared object to be
dynamically loaded whenever the FASL file is loaded.


File: vicare-scheme.info,  Node: ffi,  Next: syslib,  Prev: foreign,  Up: Top

11 Foreign functions interface
******************************

The library '(vicare ffi)' interfaces with the host operating system and
other external libraries exposing a C language interface; it is
suggested to import the FFI library with the prefix 'ffi::', as in the
following prelude:

     #!r6rs
     (import (rnrs)
       (prefix (vicare ffi) ffi::))

   The facilities of the '(vicare ffi)' give the Scheme program
unrestricted access to the computer memory, allowing one to allocate,
access, modify, and free memory as needed.  The facilities also allow
the Scheme program to "call out" to system procedures as well as allow
the native procedures to "call back" into Scheme.

   Additionally, '(vicare ffi)' reexports all the bindings from the
library '(vicare system $foreign)'.

   The availability of the Libffi API can be tested at run-time with the
function 'vicare-built-with-ffi-enabled' from '(vicare)' (*note
vicare-built-with-ffi-enabled: iklib config.), and at expand-time with
the clause 'ffi-enabled' of 'cond-expand' from SRFI-0 (*note
ffi-enabled: (vicare-libs)srfi cond-expand vicare.).

   Vicare defines an API to handle pointer objects, *note iklib
pointers:: for details.

* Menu:

* ffi libffi::                  Installing and using Libffi.
* ffi dl::                      Accessing shared libraries.
* ffi shared::                  System-agnostic shared libraries API.
* ffi call::                    Callouts and callbacks.
* ffi foreign wrapper::         Wrapper for foreign pointers.


File: vicare-scheme.info,  Node: ffi libffi,  Next: ffi dl,  Up: ffi

11.1 Installing and using Libffi
================================

Currently Vicare implements the foreign-functions interface (FFI) using
an extenal library: Libffi, originally by Anthony Green.  Libffi can be
found at:

                    <http://sourceware.org/libffi/>

and it is distributed under a liberal license (look for it at the site,
basically we can do everything but remove the original copyright
notice).

   On Unix-like systems, we can install Libffi with the traditional
sequence:

     $ ./configure [options]
     $ make
     $ make install

and the makefile supports the 'DESTDIR' environment variable for
installation under a different directory prefix.

     *NOTE* Libffi version 3.0.10 installs its header files under:

          ${prefix}/lib/libffi-3.0.10/include

     and trying to use the '--includedir' option to 'configure' will
     *not* work in changing this.  It means that when configuring Vicare
     for installation we have to specify where the Libffi headers are to
     be found; *note overview install:: for details.


File: vicare-scheme.info,  Node: ffi dl,  Next: ffi shared,  Prev: ffi libffi,  Up: ffi

11.2 Accessing foreign objects from Scheme
==========================================

Most system implementations of dynamic loading employ reference counting
for 'dlopen' and 'dlclose' in that library resources are not freed until
the number of calls to 'dlclose' matches the number of calls to
'dlopen'.  The following bindings are exported by '(vicare ffi)'.

 -- Function: dlopen
 -- Function: dlopen LIBRARY-NAME
 -- Function: dlopen LIBRARY-NAME LAZY? GLOBAL?
     Interface to the C function 'dlopen()', see the manual page
     'dlopen(3)'.  Load a platform shared library and return a pointer
     object representing a handler for the library, which can be used as
     argument for 'dlsym' and 'dlclose'.  If the library cannot be
     loaded: return '#f' and the procedure 'dlerror' can be used to
     obtain the cause of the failure.

     When no arguments are present: the returned pointer handler
     references the current process and it can be used to retrieve
     pointers to functions already loaded, for example the functions
     exported by the standard C library.  The LAZY? and GLOBAL?
     arguments are meaningless in this case.

     When given: LIBRARY-NAME must be a string or a bytevector
     representing the name of the library; if it is a string: it is
     converted to bytevector using the function referenced by
     'filename->string-func'.

     Library names are system-dependent and must include the appropriate
     suffix (for exapmle '*.so' on Linux, '*.dylib' on Darwin and
     '*.dll' on Cygwin).  LIBRARY-NAME may include a full path which
     identifies the location of the library, or it may just be the name
     of the library in which case the system will lookup the library
     name using the 'LD_LIBRARY_PATH' environment variable.

     The argument LAZY? specifies how library dependencies are loaded.
     If true, 'dlopen' delays the resolution and loading of dependent
     libraries until they are actually used.  If false, all library
     dependencies are loaded before the call to 'dlopen' returns.  LAZY?
     defaults to '#f'.

     The argument GLOBAL? specifies the scope of the symbols exported
     from the loaded library.  If true, all exported symbols become part
     of the running image, and subsequent 'dlsym' calls may not need to
     specify the library from which the symbol is loaded.  If false, the
     exported symbols are not global and the library pointer needs to be
     specified for 'dlsym'.  GLOBAL? defaults to '#f'.

 -- Function: dlclose HANDLE
     Interface to the C function 'dlclose()', see the manual page
     'dlclose(3)'.  Release the resources loaded from the library
     referenced by the pointer handler HANDLE.  If successful return
     '#t', else return '#f' and 'dlerror' can be used to obtain the
     cause of the error.

     Closing a library renders all symbols and static data structures
     that the library exports invalid and the program may crash or
     corrupt its memory if such symbols are used after a library is
     closed.

 -- Function: dlsym HANDLE NAME
     Interface to the C function 'dlsym()', see the manual page
     'dlsym(3)'.  Search the loaded library referenced by the pointer
     HANDLE for an exported symbol whose name is represented by the
     string NAME.  If successful return a pointer object, else return
     '#f' and 'dlerror' can be used to obtain the cause of the error.

     If the returned value references a function: it can be used as
     argument to the callout generators built by 'make-c-callout-maker'.

 -- Function: dlerror
     Interface to the C function 'dlerror()', see the manual page
     'dlerror(3)'.  If any of the dynamic loading operations fails, the
     cause of the error can be obtained by calling 'dlerror' which
     returns a string describing the error; return '#f' if there was no
     dynamic loading error.


File: vicare-scheme.info,  Node: ffi shared,  Next: ffi call,  Prev: ffi dl,  Up: ffi

11.3 System-agnostic shared libraries API
=========================================

This API to load shared libraries is more system-agnostic with respect
to the functions described in *note ffi dl::.  The following bindings
are exported by '(vicare ffi)'.

 -- Function: open-shared-object
 -- Function: open-shared-object SO-NAME
     Load a platform shared library and return a pointer object
     representing a handler for the library.  If the library cannot be
     loaded: raise a non-continuable exception with condition types
     '&who', '&message', '&shared-object-opening-error'.

     When no arguments are present: the returned pointer handler
     references the current process and it can be used to retrieve
     pointers to functions already loaded, for example the functions
     exported by the standard C library.

     When given: SO-NAME must be a string representing the name of the
     library; library names are system-dependent and must include the
     appropriate suffix (for exapmle '*.so' on Linux, '*.dylib' on
     Darwin and '*.dll' on Cygwin).  SO-NAME may include a full path
     which identifies the location of the library, or it may just be the
     name of the library.

          *For Unix* We can find documentation about the search path of
          shared objects in the manual page of 'dlopen()'.  The system
          will lookup the library name using the 'LD_LIBRARY_PATH'
          environment variable.

 -- Function: close-shared-object SO-HANDLE
     Release the resources loaded from the library referenced by the
     SO-HANDLE.  If the library cannot be closed: raise a
     non-continuable exception with condition types '&who', '&message',
     '&shared-object-closing-error'.

     Closing a library renders all symbols and static data structures
     that the library exports invalid and the program may crash or
     corrupt its memory if such symbols are used after a library is
     closed.

 -- Function: lookup-shared-object SO-HANDLE NAME
     Search the loaded library referenced by the SO-HANDLE for an
     exported symbol whose name is represented by the Scheme string
     NAME.  If successful return a pointer object, else raise a
     non-continuable exception with condition types '&who', '&message',
     '&shared-object-lookup-error'.

     If the returned value references a function: it can be used as
     argument to the callout generators built by 'make-c-callout-maker'.

Shared object errors
....................

 -- Condition Type: &shared-object-error
     Base condition type for all the exceptions associated to a shared
     object; it is derived from '&error'.  It has no fields.

 -- Function: make-shared-object-error
     Build and return a new instance of '&shared-object-error'.

 -- Function: shared-object-error? OBJ
     Return '#t' if OBJ is an instance of '&shared-object-error', else
     return '#f'.

Opening shared objects
......................

 -- Condition Type: &shared-object-opening-error
     Condition type tagging exceptions associated to opening a shared
     object; it is derived from '&shared-object-error'.  It has the
     following fields:

     'name'
          Scheme string representing the file name of the shared object.

 -- Function: make-shared-object-opening-error SO-NAME
     Build and return a new instance of '&shared-object-opening-error'.

 -- Function: shared-object-opening-error? OBJ
     Return '#t' if OBJ is an instance of
     '&shared-object-opening-error', else return '#f'.

 -- Function: condition-shared-object-opening-name SO-OPENING
     Accessor for the field of '&shared-object-opening-error'.

Closing shared objects
......................

 -- Condition Type: &shared-object-closing-error
     Condition type tagging exceptions associated to closing a shared
     object; it is derived from '&shared-object-error'.  It has the
     following fields:

     'so-handle'
          Pointer object referencing the shared object; it is the value
          returned by 'open-shared-object'.

 -- Function: make-shared-object-closing-error SO-HANDLE
     Build and return a new instance of '&shared-object-closing-error'.

 -- Function: shared-object-closing-error? OBJ
     Return '#t' if OBJ is an instance of
     '&shared-object-closing-error', else return '#f'.

 -- Function: condition-shared-object-closing-so-handle SO-CLOSING
     Accessor for the field of '&shared-object-closing-error'.

Inspecting shared objects
.........................

 -- Condition Type: &shared-object-lookup-error
     Condition type tagging exceptions associated to looking up a symbol
     in a shared object; it is derived from '&shared-object-error'.  It
     has the following fields:

     'so-handle'
          Pointer object referencing the shared object; it is the value
          returned by 'open-shared-object'.

     'foreign-symbol'
          Scheme string representing the shared object exported symbol
          whose address was requested.

 -- Function: make-shared-object-lookup-error SO-HANDLE SYMBOL
     Build and return a new instance of '&shared-object-lookup-error'.

 -- Function: shared-object-lookup-error? OBJ
     Return '#t' if OBJ is an instance of '&shared-object-lookup-error',
     else return '#f'.

 -- Function: condition-shared-object-lookup-so-handle SO-LOOKUP
 -- Function: condition-shared-object-lookup-foreign-symbol SO-LOOKUP
     Accessors for the fields of '&shared-object-lookup-error'.


File: vicare-scheme.info,  Node: ffi call,  Next: ffi foreign wrapper,  Prev: ffi shared,  Up: ffi

11.4 Callouts and callbacks
===========================

Callouts allow Scheme code to invoke C functions in a foreign library;
callbacks allow foreign C code to call a Scheme function.  The following
example shows how Scheme code can call a callout which in turns calls a
callback:

     #!r6rs
     (import (rnrs)
       (prefix (vicare ffi) ffi::))

     (define callout-maker
       (ffi::make-c-callout-maker  'unsigned-int '(unsigned-int)))

     (define callback-maker
       (ffi::make-c-callback-maker 'unsigned-int '(unsigned-int)))

     (define callback
       (callback-maker values))

     (define callout
       (callout-maker callback))

     (callout 123)   => 123

     (ffi::free-c-callback callback)

* Menu:

* ffi call intro::              Overview of FFI function calls.
* ffi call out::                Calling out to foreign procedures.
* ffi call back::               Calling back to Scheme.
* ffi call types::              Specifying native types.


File: vicare-scheme.info,  Node: ffi call intro,  Next: ffi call out,  Up: ffi call

11.4.1 Overview of FFI function calls
-------------------------------------

Both callouts and callbacks are built on top of function signatures
specifying the type of function arguments and returned value.  Libffi
allows us to specify such signatures through a Call InterFace (CIF) data
structure; Vicare internally extends such a structure with additional
data to speed up marshaling of values from Scheme to native
representation and back.

   At present, CIF data structures are allocated with 'malloc()' and
never released.  Callouts and callbacks make use of CIF structures of
the same format, so such structures are internally cached; a single CIF
associated to a given function signature is used by all the callouts and
callbacks having the same signature.

Calling out to foreign functions
................................

Callouts require only a CIF structure and the address of the foreign C
function; no additional structure needs to be allocated and then
released.

   Vicare organises the callout API by creating a callout maker
function, closed upon a CIF structure, which can build any number of
callout functions associating the CIF to foreign function pointers.
Maker functions are cached internally, so only one maker function for a
given signature is created in a running process.

Calling back to Scheme functions
................................

Callbacks require an additional data structure, because they must
generate at runtime callable machine code referenced by a pointer; such
additional data structure cannot be automatically released by the
garbage collector, but it can be explicitly freed by the program when
the callback is no longer needed.

   We can think of the code handling a callback as organised like the
following pseudo-code:

     cif_t  call_interface;

     int
     specific_callback (int a, long b, double c)
     {
       void *  args[3] = { &a, &b, &c };
       int     result;
       generic_callback(&call_interface, &result, args);
       return result;
     }

     void
     generic_callback (cif_t * call_interface,
                       void * result, void * args)
     {
       scheme_value  s_a, s_b, s_c;
       scheme_value  s_result;
       s_a = native_to_scheme(call_interface, 0, args);
       s_b = native_to_scheme(call_interface, 1, args);
       s_c = native_to_scheme(call_interface, 2, args);
       s_result = scheme_callback(s_a, s_b, s_c);
       scheme_to_native(call_interface, result, s_result);
     }

     scheme_value
     scheme_callback (scheme_value s_a,
                      scheme_value s_b,
                      scheme_value s_c)
     {
       /* process arguments, return result */
     }

where: 'specific_callback' is generated at runtime by Libffi;
'generic_callback', 'scheme_to_native' and 'native_to_scheme' are
implemented by Vicare's runtime (using generic operations); 'scheme
callback' is implemented by the Scheme program.  A pointer to
'specific_callback' is the one we need to acquire when creating a
callback from Scheme.

   Vicare organises the callback API by creating a callback maker
function, closed upon a CIF structure, which can build any number of
callback functions associating the CIF to Scheme functions.  Maker
functions are cached internally, so only one maker function for each
given signature is created in a running process.


File: vicare-scheme.info,  Node: ffi call out,  Next: ffi call back,  Prev: ffi call intro,  Up: ffi call

11.4.2 Calling out to foreign procedures
----------------------------------------

In order to call out to a foreign procedure, we must provide two pieces
of information: the signature of the foreign procedure and the address
of the procedure in memory.  The signature must usually be hard-coded
into the program; the address is obtained using 'dlsym'.

   Using the signature, the FFI determines how Scheme values are
converted to and from native values; a signature is composed of two
parts: a Scheme symbol specifying the return type, a list of Scheme
symbols specifying the argument types.

   Here is a simple example, without error checking, showing how to
interface to the C function 'sinh()':

     #!r6rs
     (import (vicare)
       (prefix (vicare ffi) ffi::))

     (define libc
       (ffi::dlopen))

     (define sinh-address
       (ffi::dlsym libc "sinh"))

     (define callout-maker
       (ffi::make-c-callout-maker 'double '(double)))

     (define sinh
       (callout-maker sinh-address))

     (sinh 1.2)      => 1.5094613554121725

using the FFI we build a callout function generator which can be used to
create any number of callout functions having the same signature.
Generated callout functions are garbage collected like any other Scheme
value.

 -- Function: make-c-callout-maker RET-TYPE ARG-TYPES
     Build and return a function to be used to generate callout Scheme
     functions wrapping foreign functions which follow the C language
     conventions for calling, arguments and return values.

     The returned generator function accepts as single argument a
     pointer object representing the address of a foreign function; the
     value returned by the generator function is a Scheme closure
     wrapping the foreign function.  The wrapper Scheme closure takes
     care of marshaling Scheme values as appropriate for the underlying
     platform.

     RET-TYPE must be a Scheme symbol specifying the type of the
     returned value; if the foreign function returns no value: RET-TYPE
     must be the symbol 'void'.

     ARG-TYPES must be a list of Scheme symbols specifying the type of
     the arguments; if the foreign function accepts no arguments:
     ARG-TYPES must be nil or the list '(void)'.

     *note ffi call types:: for the specification of accepted type
     symbols.

 -- Function: make-c-callout-maker/with-errno RET-TYPE ARG-TYPES
     Like 'make-c-callout-maker', but the generated callout closures
     will return two values: the return value from the foreign function
     call and the value of the C language variable 'errno' right after
     the foreign function call.


File: vicare-scheme.info,  Node: ffi call back,  Next: ffi call types,  Prev: ffi call out,  Up: ffi call

11.4.3 Calling back to Scheme
-----------------------------

In order to arrange for a foreign library to callback to a Scheme
function we need a suitable Scheme function and the signature of the
procedure the foreign library expects.  The signature must usually be
hard-coded in the program.

   Using the signature, the FFI determines how native values are
converted to and from Scheme values; a signature is composed of two
parts: a Scheme symbol specifying the return type, a list of Scheme
symbols specifying the argument types.  The signature format is the same
as the one used for callouts; *note ffi call out:: for details.

   Note that a callback function is indistinguishable from other native
procedures whose address is obtained using 'dlsym' or similar means.  In
particular, such native pointers can be passed to callout generators
resulting in a Scheme procedure that calls out to the native procedure
that in turn calls back into Scheme.

   The following example shows how to create an identity function for
native integers composed by a Scheme function calling out to a foreign
function, calling back to the Scheme function 'values':

     #!r6rs
     (import (vicare)
       (prefix (vicare ffi) ffi::))

     (define callout-maker
       (ffi::make-c-callout-maker  'unsigned-int '(unsigned-int)))

     (define callback-maker
       (ffi::make-c-callback-maker 'unsigned-int '(unsigned-int)))

     (define identity
       (callout-maker (callback-maker values)))

     (identity 123)  => 123

using the FFI we build a callback function generator which can be used
to create any number of callback functions having the same signature.
Generated callback functions are *not* garbage collected like the other
Scheme values.

 -- Function: make-c-callback-maker RET-TYPE ARG-TYPES
     Build and return a function to be used to generate callback
     functions following the C language conventions for calling,
     arguments and return values and wrapping Scheme functions.

     The returned generator function accepts as single argument the
     Scheme function to be wrapped; the value returned by the generator
     function is a pointer object referencing a native function.  The
     wrapper native function takes care of marshaling Scheme values as
     appropriate for the underlying platform.

     RET-TYPE must be a Scheme symbol specifying the type of the
     returned value; if the callback function must return no value:
     RET-TYPE must be the symbol 'void'.

     ARG-TYPES must be a list of Scheme symbols specifying the type of
     the arguments; if the callback function must accept no arguments:
     ARG-TYPES must be nil or the list '(void)'.

     *note ffi call types:: for the specification of accepted type
     symbols.

 -- Function: free-c-callback C-CALLBACK-POINTER
     Release the resources associated to the given C pointer referencing
     a callback function.  If the pointer is not a callback pointer:
     raise an assertion violation.

 -- Function: c-callback? OBJ
 -- Function: false-or-c-callback? OBJ
     Return '#t' if OBJ is a callback pointer (or '#f'); otherwise
     return '#f'.  These predicates only test if OBJ is a pointer
     object; at present there is no way to distinguish a callback
     pointer from a non-callback pointer.

 -- Function: maybe-callback? OBJ
     Return '#t' if OBJ is a callback object or '#!void', return '#f'
     otherwise.  This predicate only tests if OBJ is a pointer object;
     at present there is no way to distinguish a callback pointer from a
     non-callback pointer.


File: vicare-scheme.info,  Node: ffi call types,  Prev: ffi call back,  Up: ffi call

11.4.4 Specifying native types
------------------------------

The following is a list of Scheme symbols used to specify native types
for both callouts and callbacks.  If a type is not available on a
platform: the callout and callback generators will raise an error if the
associated type specifier is used.

'signed-char'
'unsigned-char'
     Exact integers in the range for 'char' and 'unsigned char'.

'signed-short'
'unsigned-short'
     Exact integers in the range for 'short int' and 'unsigned short
     int'.

'signed-int'
'unsigned-int'
     Exact integers in the range for 'int' and 'unsigned int'.

'signed-long'
'unsigned-long'
     Exact integers in the range for 'long' and 'unsigned long'.

'signed-long-long'
'unsigned-long-long'
     Exact integers in the range for 'long long' and 'unsigned long
     long'.

'float'
'double'
     Flonum.

'pointer'
'callback'
     Pointer object.  The symbol 'callback' can be used to specify a
     pointer to a callback, but it is a full synonym of 'pointer'.

'int8_t'
'uint8_t'
     Exact integers in the range for 'int8_t' and 'uint8_t'.

'int16_t'
'uint16_t'
     Exact integers in the range for 'int16_t' and 'uint16_t'.

'int32_t'
'uint32_t'
     Exact integers in the range for 'int32_t' and 'uint32_t'.

'int64_t'
'uint64_t'
     Exact integers in the range for 'int64_t' and 'uint64_t'.

'size_t'
'ssize_t'
     Exact integers in the range for 'size_t' and 'ssize_t'.

'off_t'
     Exact integers in the range for 'off_t'.

'ptrdiff_t'
     Exact integers in the range for 'ptrdiff_t'.


File: vicare-scheme.info,  Node: ffi foreign wrapper,  Prev: ffi call,  Up: ffi

11.5 Wrapper for foreign pointers
=================================

The library '(vicare ffi foreign-pointer-wrapper)' proposes a Scheme
data struct definition, and related facilities, to be used to wrap
Scheme pointer objects referencing data structures defined by foreign
libraries.

* Menu:

* ffi foreign wrapper syntax::  Defining wrapper structures.
* ffi foreign wrapper binds::   Defined bindings.


File: vicare-scheme.info,  Node: ffi foreign wrapper syntax,  Next: ffi foreign wrapper binds,  Up: ffi foreign wrapper

11.5.1 Defining wrapper structures
----------------------------------

The following bindings are exported by the library '(vicare ffi
foreign-pointer-wrapper)'.

 -- Syntax: define-foreign-pointer-wrapper ?TYPE-ID ?FIELDS-CLAUSE
          ?DESTRUCTOR-CLAUSE ?COLLECTOR-CLAUSE ?COLLECTED-CLAUSE ...
 -- Auxiliary Syntax: fields
 -- Auxiliary Syntax: foreign-destructor
 -- Auxiliary Syntax: collector-struct-type
 -- Auxiliary Syntax: collected-struct-type
     Wrapper for 'define-struct' from '(vicare)' defining a struct type
     with some opaque fields.  ?TYPE-ID must be an identifier
     representing the name of the struct type.

     Two categories of struct instances exist: those who *own* the
     foreign data structure referenced by the pointer object; those who
     *do not* own the foreign data structure referenced by the pointer
     object.  There are situations where the latter data structures are
     unsafe to use; Vicare discharges on the application the
     responsibility of using or not using such structures.

     ?FIELDS-CLAUSE
          This clause is *optional*.  It must have one of the forms:

               (fields)
               (fields FIELD-ID ...)

          where 'fields' is the auxiliary keyword exported by '(rnrs
          rnrs (6))' and the FIELD-ID are field name identifiers.  The
          listed fields become normal fields of the defined structure.

     ?DESTRUCTOR-CLAUSE
          It must have one of the forms:

               (foreign-destructor #f)
               (foreign-destructor ?DESTRUCTOR-ID)

          where ?DESTRUCTOR-ID must be an identifier bound to the
          foreign data structure destructor Scheme function; when the
          value in the clause is '#f': the data struct has no destructor
          function.

          Whenever a struct instance owning the pointer object is
          finalised: the referenced destructor function is applied to
          the Scheme data struct; its responsibility is to extract the
          pointer object and apply to it whatever finalisation procedure
          the foreign library provides.

     ?COLLECTOR-CLAUSE
          It must have one of the forms:

               (collector-struct-type #f)
               (collector-struct-type ?COLLECTOR-ID)

          where ?COLLECTOR-ID must be an identifier representing the
          name of another data struct type defined with this syntax;
          when the value of the clause is '#f': ?TYPE-ID has no
          collector struct type.

          Instances of ?TYPE-ID are meant to be, in some way,
          subordinate to ?COLLECTOR-ID; when building a new instance of
          type ?TYPE-ID, it is possible, but not mandatory, to specify
          an instance of type ?COLLECTOR-ID that "collects" it:

             * Whenever the instance of type ?COLLECTOR-ID is finalised:
               the collected instances of type ?TYPE-ID are finalised
               too.

             * Whenever the instance of type ?TYPE-ID is finalised: it
               unregisters itself from the collection in the instance of
               type ?COLLECTOR-ID.

     ?COLLECTED-CLAUSE
          These clauses are optional and can be present in any number;
          when used, they must have the form:

               (collected-struct-type ?COLLECTED-ID)

          where ?COLLECTED-ID must be an identifier representing the
          name of another data struct type defined with this syntax.

          Instances of ?COLLECTED-ID are meant to be, in some way,
          subordinate to ?TYPE-ID; when building a new insance of type
          ?COLLECTED-ID, it is possible, but not mandatory, to specify
          an instance of ?TYPE-ID that "collects" it:

             * Whenever the instance of type ?TYPE-ID is finalised: the
               collected instances of type ?COLLECTED-ID are finalised
               too.

             * Whenever the instance of type ?COLLECTED-ID is finalised:
               it unregisters itself from the collection in the instance
               of type ?TYPE-ID.


File: vicare-scheme.info,  Node: ffi foreign wrapper binds,  Prev: ffi foreign wrapper syntax,  Up: ffi foreign wrapper

11.5.2 Defined bindings
-----------------------

The syntax 'define-foreign-pointer-wrapper' defines a number of bindings
associated to the struct type; all the defined bindings are prefixed by
the identifier ?TYPE-ID or by '$' followed by the identifier ?TYPE-ID.

   Here only the bindings in the public API are documented:

'(make-?TYPE-ID/owner POINTER FIELD ...)'
'(make-?TYPE-ID/owner POINTER COLLECTOR FIELD ...)'
     Build and return a new struct instance of type ?TYPE-ID wrapping
     the pointer object POINTER; the returned instance *owns* the
     POINTER object.

     If the definition of ?TYPE-ID includes a clause
     'collector-struct-type' with value '#f': this maker function
     accepts a single argument.

     If the definition of ?TYPE-ID includes a clause
     'collector-struct-type' with an identifier ?COLLECTOR-ID as value:
     this maker function accepts two arguments, the second being the
     instance of type ?COLLECTOR-ID or '#f' if there is no collector
     instance.

     If the definition of ?TYPE-ID includes a clause 'fields': the
     constructor function accepts as many arguments as specified custom
     fields.

'(make-?TYPE-ID/not-owner POINTER FIELD ...)'
'(make-?TYPE-ID/not-owner POINTER COLLECTOR FIELD ...)'
     Build and return a new struct instance of type ?TYPE-ID wrapping
     the pointer object POINTER; the returned instance *does not own*
     the POINTER object.

     If the definition of ?TYPE-ID includes a clause
     'collector-struct-type' with value '#f': this maker function
     accepts a single argument.

     If the definition of ?TYPE-ID includes a clause
     'collector-struct-type' with an identifier ?COLLECTOR-ID as value:
     this maker function accepts two arguments, the second being the
     instance of type ?COLLECTOR-ID or '#f' if there is no collector
     instance.

'($?TYPE-ID-finalise STRUCT)'
     Perform the finalisation procedure for this STRUCT instance; it is
     safe to apply this finalisation function multiple times to the same
     STRUCT instance: the first time the finalisation takes place,
     subsequent times nothing happens.  The argument to this function
     *must* be an instance of ?TYPE-ID, else the behaviour is undefined.

     The finalisation procedure involves the following:

       1. If a custom destructor function has been registered: it is
          applied to STRUCT before any finalisation takes place.

       2. If STRUCT has a collecting struct COLLECTOR: STRUCT is
          unregistered from COLLECTOR.

       3. If STRUCT collects instances of another type: all the
          collected instances are finalised by invoking their unsafe
          finalisation functions; any exception raised by these
          finalisation functions is catched by 'guard' and discarded.

       4. If a foreign destructor function ?DESTRUCTOR-ID was specified
          in the definition of ?TYPE-ID and this struct instance owns
          the pointer object: the foreign destructor is applied to
          STRUCT; any exception raised by the destructor function is
          catched by 'guard' and discarded.  The return value of the
          foreign destructor becomes the return value of this function.

       5. The internal field holding the POINTER object is reset to
          '#f', to mark this struct instance as already finalised.

     About the returned value:

        * If this is the first time the finalisation function is
          applied, there is a foreign destructor and its application is
          successful: the returned value is the return value from the
          foreign destructor.

        * If this is the first time the finalisation function is
          applied, there is a foreign destructor and its application
          raises an exception: the returned value is '#f'.

        * If this is *not* the first time the finalisation function is
          applied: the returned value is '#f'.

'(?TYPE-ID? OBJ)'
     Type predicate function; it returns '#t' if OBJ is an instance of
     type ?TYPE-ID, otherwise it returns '#f'.

'(?TYPE-ID?/alive OBJ)'
     Type and liveness predicate function; it returns '#t' if OBJ is an
     instance of type ?TYPE-ID and its POINTER object has not yet been
     finalised, otherwise it returns '#f'.

          *NOTE* The returned information really represents the status
          of the foreign data structure only for struct instances that
          *do own* the foreign pointer.

'($?TYPE-ID-alive? STRUCT)'
     Unsafe liveness predicate function; it returns '#t' if STRUCT has a
     POINTER object not yet finalised, otherwise it returns '#f'.  The
     argument to this function *must* be an instance of ?TYPE-ID, else
     the behaviour is undefined.

          *NOTE* The returned information really represents the status
          of the foreign data structure only for struct instances that
          *do own* the foreign pointer.

'(?TYPE-ID OBJ)'
     Validation form to be used with the facilities of the library
     '(vicare arguments validation)'.  Succeed if OBJ satisfies the
     predicate '?TYPE-ID?'.

'(?TYPE-ID/alive OBJ)'
     Validation form to be used with the facilities of the library
     '(vicare arguments validation)'.  Succeed if OBJ satisfies the
     predicate '?TYPE-ID?/alive'.

'(false-or-?TYPE-ID OBJ)'
     Validation form to be used with the facilities of the library
     '(vicare arguments validation)'.  Succeed if OBJ is '#f' or
     satisfies the predicate '?TYPE-ID?'.

'(false-or-?TYPE-ID/alive OBJ)'
     Validation form to be used with the facilities of the library
     '(vicare arguments validation)'.  Succeed if OBJ is '#f' or
     satisfies the predicate '?TYPE-ID?/alive'.

'(?TYPE-ID-custom-destructor STRUCT)'
'(set-?TYPE-ID-custom-destructor! STRUCT DESTRUCTOR)'
     Retrieve or set a custom destructor function associated to STRUCT.
     Whenever the STRUCT is finalised: DESTRUCTOR is applied to STRUCT
     before the internal state of STRUCT is finalised.

'(?TYPE-ID-pointer STRUCT)'
     Return the pointer object referencing the foreign data structure;
     if STRUCT has already been finalised: the returned value is '#f'.

'(?TYPE-ID-pointer-owner? STRUCT)'
     Return '#t' if STRUCT owns the pointer object, otherwise return
     '#f'.

'(?TYPE-ID-putprop STRUCT KEY VALUE)'
     Add a new property KEY with VALUE to the property list of STRUCT.
     If KEY is already set: the old entry is mutated to reference VALUE.
     KEY must be a symbol.

'(?TYPE-ID-getprop STRUCT KEY)'
     Return the value of the property KEY in the property list of
     STRUCT; if KEY is not set return '#f'.  KEY must be a symbol.

'(?TYPE-ID-remprop STRUCT KEY)'
     Remove the property KEY from the property list of STRUCT.  KEY must
     be a symbol.

'(?TYPE-ID-property-list STRUCT)'
     Return a new association list representing the property list of
     STRUCT.

'(?TYPE-ID-hash STRUCT)'
     Return an exact integer to be used as hashtable key for STRUCT.

   If the definition of ?TYPE-ID includes a clause
'collector-struct-type' with an identifier ?COLLECTOR-ID as value, the
following bindings are available:

'(?TYPE-ID-collector-?COLLECTOR-ID STRUCT)'
     Return the instance of type ?COLLECTOR-ID that was registered as
     collector for STRUCT; if no collector was registered: return '#f'.

   If the definition of ?TYPE-ID includes a clause
'collected-struct-type' with an identifier ?COLLECTED-ID as value, the
following bindings are available:

'($?TYPE-ID-register-?COLLECTED-ID! COLLECTOR STRUCT)'
     Register STRUCT in the internal table of COLLECTOR.  No arguments
     validation is peformed: COLLECTOR must be of type ?TYPE-ID; STRUCT
     must be of type ?COLLECTED-ID.

'($?TYPE-ID-forget-?COLLECTED-ID! COLLECTOR COLLECTED)'
     Remove COLLECTED from the internal table of COLLECTOR.  No
     arguments validation is peformed: COLLECTOR must be of type
     ?TYPE-ID; COLLECTED must be of type ?COLLECTED-ID.

'($?TYPE-ID-contains-?COLLECTED-ID? COLLECTOR STRUCT)'
     Query the internal table of COLLECTED and return true if STRUCT is
     present, otherwise return false.  No arguments validation is
     peformed: COLLECTOR must be of type ?TYPE-ID.

'($?TYPE-ID-vector-of-collected-?COLLECTED-ID STRUCT)'
     Return a Scheme vector containing the instances of type
     ?COLLECTED-ID collected by STRUCT.


File: vicare-scheme.info,  Node: syslib,  Next: objects,  Prev: ffi,  Up: Top

12 Low level, fast, unsafe operations
*************************************

The bindings documented in this chapter are low level operations inlined
by the compiler; mostly they are defined in the source file
'pass-specify-rep-primops.ss'.

   They are unsafe because when acting upon wrong arguments will cause
undefined behaviour (probably a crash).  They are also faster than the
public interface exported by '(vicare)' and '(rnrs)'.

* Menu:

* syslib booleans::             Low level boolean operations.
* syslib symbols::              Low level symbol operations.
* syslib keywords::             Low level keyword operations.
* syslib fixnums::              Low level fixnum operations.
* syslib bignums::              Low level bignum operations.
* syslib flonums::              Low level flonum operations.
* syslib ratnums::              Low level ratnum operations.
* syslib compnums::             Low level compnum operations.
* syslib cflonums::             Low level cflonum operations.
* syslib numerics::             Low level numerics operations.
* syslib chars::                Low level character operations.
* syslib pairs::                Low level pair operations.
* syslib lists::                Low level list operations.
* syslib structs::              System structure operations.
* syslib records::              Low level records operations.
* syslib vectors::              Low level vector operations.
* syslib bytevectors::          Low level bytevector operations.
* syslib strings::              Low level string operations.
* syslib ports::                Low level port structures.
* syslib transcoders::          Low level transcoder operations.
* syslib pointers::             Low level pointer operations.
* syslib hashtables::           Low level hashtable objects operations.
* syslib tcbuckets::            Low level tcbucket objects operations.
* syslib codes::                Low level code objects operations.
* syslib closures::             Low level closures operations.
* syslib compar::               Comparison procedures.


File: vicare-scheme.info,  Node: syslib booleans,  Next: syslib symbols,  Up: syslib

12.1 Low level boolean operations
=================================

The arguments BOOL must be booleans.  The following bindings are
exported by the library '(vicare system booleans)'.

Comparison
..........

 -- Function: $boolean= BOOL1 BOOL0 BOOL ...
     Return '#t' if the arguments are equal; otherwise return '#f'.  If
     only one argument is given: the return value is '#t'.

 -- Function: $boolean!= BOOL1 BOOL0 BOOL ...
     The arguments must be booleans.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     If only one argument is given: the return value is '#t'.

 -- Procedure: $boolean< BOOL0 BOOL ...
 -- Procedure: $boolean> BOOL0 BOOL ...
 -- Procedure: $boolean<= BOOL0 BOOL ...
 -- Procedure: $boolean>= BOOL0 BOOL ...
     Compare the boolean arguments according to the artificial
     comparison definition:

          #t == #t
          #f == #f
          #f <  #t

     If only one argument is given: the return value is '#f'.

 -- Function: $boolean-min BOOL1 BOOL2
 -- Function: $boolean-max BOOL1 BOOL2
     Return the minimal or maximal boolean among the arguments.


File: vicare-scheme.info,  Node: syslib symbols,  Next: syslib keywords,  Prev: syslib booleans,  Up: syslib

12.2 Low level symbol operations
================================

The bindings documented in this section are exported by the library
'(vicare system $symbols)'.  For all the bindings: the arguments SYM
must be references to symbol objects; the arguments STR must be
references to string objects.

* Menu:

* syslib symbols accessors::    Symbol accessors and mutators.
* syslib symbols constructors:: Symbol constructors.
* syslib symbols comparison::   Comparison functions.
* syslib symbols conversion::   Conversion functions.
* syslib symbols plists::       Property lists.
* syslib symbols value::        Values associated to symbols.
* syslib symbols table::        The symbol table.


File: vicare-scheme.info,  Node: syslib symbols accessors,  Next: syslib symbols constructors,  Up: syslib symbols

12.2.1 Symbol accessors and mutators
------------------------------------

 -- Unsafe Operation: $symbol-string SYM
 -- Unsafe Operation: $symbol-unique-string SYM
     Accessors for the fields of SYM.

 -- Unsafe Operation: $set-symbol-string! SYM STR
 -- Unsafe Operation: $set-symbol-unique-string! SYM STR
     Mutators for the fields of SYM.


File: vicare-scheme.info,  Node: syslib symbols constructors,  Next: syslib symbols comparison,  Prev: syslib symbols accessors,  Up: syslib symbols

12.2.2 Symbol constructors
--------------------------

 -- Unsafe Operation: $make-symbol STR
     Allocate a new symbol block and initialise the 'string' field with
     STR; return the reference to the symbol block.

     The 'ustring' is initialised to the fixnum zero.  The 'value' and
     'proc' fields are initialised to a special machine word value
     meaning "unbound".  The 'plist' field is initialised to nil.


File: vicare-scheme.info,  Node: syslib symbols comparison,  Next: syslib symbols conversion,  Prev: syslib symbols constructors,  Up: syslib symbols

12.2.3 Comparison functions
---------------------------

 -- Function: $symbol= SYM1 SYM2
     Return '#t' if the symbol arguments have equal pretty string name
     according to '$string='; otherwise return '#f'.

 -- Function: $symbol!= SYM1 SYM2
     The arguments must be symbols.  Return '#t' if the arguments are
     different; otherwise return '#f'.

 -- Function: $symbol< SYM1 SYM2
 -- Function: $symbol> SYM1 SYM2
 -- Function: $symbol<= SYM1 SYM2
 -- Function: $symbol>= SYM1 SYM2
     Return '#t' if the symbol arguments have pretty string names
     satisfying, respectively: '$string<', '$string>', '$string<=',
     '$string>='; otherwise return '#f'.

 -- Function: $symbol-max SYM1 SYM2
 -- Function: $symbol-min SYM1 SYM2
     Return the symbol argument having maximal or minimal pretty string
     name according to '$string-max' and 'string-min'.


File: vicare-scheme.info,  Node: syslib symbols conversion,  Next: syslib symbols plists,  Prev: syslib symbols comparison,  Up: syslib symbols

12.2.4 Conversion functions
---------------------------

 -- Unsafe Operation: $string->symbol STR
     Return an interned symbol having the string STR as name.

 -- Unsafe Operation: $symbol->string SYM
     Return the string name of SYM, generating one if needed.


File: vicare-scheme.info,  Node: syslib symbols plists,  Next: syslib symbols value,  Prev: syslib symbols conversion,  Up: syslib symbols

12.2.5 Property lists
---------------------

 -- Unsafe Operation: $symbol-plist SYM
 -- Unsafe Operation: $set-symbol-plist! SYM ELL
     Accessor and mutator for the field 'plist' of symbol objects.

 -- Unsafe Operation: $putprop SYMBOL KEY VALUE
     Add a new property KEY with VALUE to the property list of SYMBOL.
     KEY must be a symbol, VALUE can be any value.

     If KEY is already set: the old entry is mutated to reference the
     new VALUE.

 -- Unsafe Operation: $getprop SYMBOL KEY
     Return the value of the property KEY in the property list of
     SYMBOL; if KEY is not set return false.  KEY must be a symbol.

 -- Unsafe Operation: $remprop SYMBOL KEY
     Remove property KEY from the list associated to SYMBOL.

 -- Unsafe Operation: $property-list SYMBOL
     Return a new association list representing the property list of
     SYMBOL.  The order of the entries is the same as the property
     creation order.


File: vicare-scheme.info,  Node: syslib symbols value,  Next: syslib symbols table,  Prev: syslib symbols plists,  Up: syslib symbols

12.2.6 Values associated to symbols
-----------------------------------

 -- Unsafe Operation: $symbol-value SYM
 -- Unsafe Operation: $set-symbol-value! SYM VAL
     The 'value' field has multiple purposes:

        * When SYM is the unique identifier of a data structure type:
          the 'value' field holds the RTD of the data structure.

        * When SYM is a label gensym associated to a syntactic binding
          exported by the boot image: 'value' holds the syntactic
          binding descriptor.

        * When SYM is a label gensym associated to a syntactic binding
          imported in the current lexical environment: 'value' holds the
          syntactic binding descriptor.

        * When SYM is a fresh symbol returned by a call to 'gensym': we
          can use this field for any purpose we want.

     Notice that this field is initialised to the unbound object, so we
     can test the value of a newly created symbols with:

          ($unbound-object? ($symbol-value? SYM))

 -- Unsafe Operation: $unbound-object? OBJ
     Return '#t' if OBJ is the special unbound machine word value,
     otherwise return '#f'.

 -- Unsafe Operation: $symbol-proc SYM
 -- Unsafe Operation: $set-symbol-proc! SYM PROC
     Accessor and mutator for the field 'proc'.

 -- Unsafe Operation: $set-symbol-value/proc! SYM VAL
     Set both the fields 'value' and 'proc' of SYM to VAL.

 -- Unsafe Operation: $init-symbol-function! SYM PROC
     Still to be documented.


File: vicare-scheme.info,  Node: syslib symbols table,  Prev: syslib symbols value,  Up: syslib symbols

12.2.7 The symbol table
-----------------------

The following bindings are related to the symbol table collecting
interned symbols.

 -- Function: $symbol-table-size
     Return the number of interned symbols.

 -- Function: $log-symbol-table-status
     Write to the current error port a description of the current symbol
     table status.  Example:

          vicare> (import (vicare system $symbols))
          vicare> ($log-symbol-table-status)
          Vicare internal symbol table status:
                  number of interned symbols: 2962
                  number of hash table buckets: 4096

          vicare>


File: vicare-scheme.info,  Node: syslib keywords,  Next: syslib fixnums,  Prev: syslib symbols,  Up: syslib

12.3 Low level keyword operations
=================================

The arguments KEY must be references to keyword objects, the arguments
SYMB must be references to symbol objects.  The following bindings are
exported by the library '(vicare system $keywords)'.

 -- Unsafe Operation: $symbol->keyword SYM
 -- Unsafe Operation: $keyword->symbol KEY
     Convert between a symbol and a keyword.

 -- Unsafe Operation: $keyword->string KEY
     Return the string representation of a keyword.

 -- Unsafe Operation: $keyword=? KEY1 KEY2
     Return '#t' if the arguments are equal.  A keyword object is equal
     to itself; two distinct keyword objects are equal if they have the
     same symbol.

 -- Unsafe Operation: $keyword-hash KEYWORD
     Return an exact integer suitable to be used as hash value for
     KEYWORD used as key for hashtables.


File: vicare-scheme.info,  Node: syslib fixnums,  Next: syslib bignums,  Prev: syslib keywords,  Up: syslib

12.4 Low level fixnum operations
================================

The following bindings are exported by the library '(vicare system
$fx)'.  The arguments to these operations must be fixnums.  *note
objects fixnums:: for details on the representation of fixnums.

Predicates
..........

 -- Unsafe Operation: $fxzero? FX
     Evaluate to true if FX is zero.

 -- Unsafe Operation: $fxpositive? FX
 -- Unsafe Operation: $fxnegative? FX
     Evaluate to true if FX is strictly positive or strictly negative.

 -- Unsafe Operation: $fxnonpositive? FX
 -- Unsafe Operation: $fxnonnegative? FX
     Evaluate to true if FX is non-positive or non-negative.

 -- Unsafe Operation: $fxsign FX
     Return one of the fixnums '+1', '-1', '0' representing the sign of
     FX.

 -- Unsafe Operation: $fxeven? FX
 -- Unsafe Operation: $fxodd? FX
     Evaluate to true if FX is even or odd.

Comparison operations
.....................

 -- Unsafe Operation: $fx= FX1 FX2
     Evaluate to true if the arguments are equal.

 -- Unsafe Operation: $fx=! FX1 FX2
     Evaluate to true if the arguments are different.

 -- Unsafe Operation: $fx< FX1 FX2
     Evaluate to true if FX1 is less than FX2.

 -- Unsafe Operation: $fx<= FX1 FX2
     Evaluate to true if FX1 is less than or equal to FX2.

 -- Unsafe Operation: $fx> FX1 FX2
     Evaluate to true if FX1 is greater than FX2.

 -- Unsafe Operation: $fx>= FX1 FX2
     Evaluate to true if FX1 is greater than or equal to FX2.

 -- Unsafe Operation: $fxmax FX1 FX2
 -- Unsafe Operation: $fxmin FX1 FX2
     Return either the maximum or minimum between the arguments.

Arithmetic operations
.....................

 -- Unsafe Operation: $fxadd1 FX
     Increment the operand by one and return the result.

 -- Unsafe Operation: $fxsub1 FX
     Decrement the operand by one and return the result.  The result of
     this operation is a fixnum, but notice that if FX is
     '(least-fixnum)': the result overflows the fixnum capacity and the
     return value is invalid.

 -- Unsafe Operation: $fx+ FX1 FX2
     Sum the operands and return the result.  The result of this
     operatio is a fixnum, but notice that it could overflow the fixnum
     capacity.

 -- Unsafe Operation: $fx- FX
 -- Unsafe Operation: $fx- FX1 FX2
     With one operand: return FX negated.  With two operands: subtract
     the operands and return the result.  The result of this operation
     is a fixnum, but notice that it could overflow the fixnum capacity
     and the return value would be invalid.

     Also with a single argument, knowing that '(- (least-fixnum))' is a
     bignum, if FX is '(least-fixnum)' the result overflows the fixnum
     capacity and the return value is invalid.

     With two arguments: if FX1 is zero and FX2 is '(least-fixnum)' the
     result overflows the fixnum capacity and the return value is
     invalid.

 -- Unsafe Operation: $fx* FX1 FX2
     Multiply the operands and return the result.  The result of this
     operation is a fixnum, but notice that if one operand is '-1' and
     the other is '(least-fixnum)': the result overflows the fixnum
     capacity and the return value is invalid.

 -- Unsafe Operation: $fxdiv FX1 FX2
 -- Unsafe Operation: $fxdiv0 FX1 FX2
 -- Unsafe Operation: $fxmod FX1 FX2
 -- Unsafe Operation: $fxmod0 FX1 FX2
 -- Unsafe Operation: $fxdiv-and-mod FX1 FX2
 -- Unsafe Operation: $fxdiv0-and-mod0 FX1 FX2
     Perform the number theoretic division.

          (import (rnrs)
            (vicare system $fx))

          ($fxmod +12 +12)        => 0
          ($fxmod +12 -12)        => 0
          ($fxmod -12 +12)        => 0
          ($fxmod -12 -12)        => 0

          ($fxmod +12 +3)         => 0
          ($fxmod +12 -3)         => 0
          ($fxmod -12 +3)         => 0
          ($fxmod -12 -3)         => 0

          ($fxmod +12 +4)         => 0
          ($fxmod +12 -4)         => 0
          ($fxmod -12 +4)         => 0
          ($fxmod -12 -4)         => 0

          ($fxmod +12 +5)         => +2
          ($fxmod +12 -5)         => +2
          ($fxmod -12 +5)         => +3
          ($fxmod -12 -5)         => +3

          ($fxmod +12 +7)         => +5
          ($fxmod +12 -7)         => +5
          ($fxmod -12 +7)         => +2
          ($fxmod -12 -7)         => +2

          ($fxmod +12 +24)        => +12
          ($fxmod +12 -24)        => +12
          ($fxmod -12 +24)        => +12
          ($fxmod -12 -24)        => +12

          ($fxmod +12 +20)        => +12
          ($fxmod +12 -20)        => +12
          ($fxmod -12 +20)        => +8
          ($fxmod -12 -20)        => +8

 -- Unsafe Operation: $fxquotient FX1 FX2
     Compute the quotient between the operands and return the result.
     The result of this operation is a fixnum, but notice that:

        * When FX2 is '0': the result is undefined, most likely the
          process will abort.

        * When FX1 is '(least-fixnum)' and FX2 is '-1': the result will
          overflow the fixnum capacity, and the return value will be
          invalid (the result should be a bignum).

 -- Unsafe Operation: $fxmodulo FX1 FX2
     Compute the modulo between the operands and return the result.  The
     result of this operation can be a fixnum or bignum.

          (import (rnrs)
            (vicare system $fx))

          ($fxmodulo +12 +12)     => 0
          ($fxmodulo +12 -12)     => 0
          ($fxmodulo -12 +12)     => 0
          ($fxmodulo -12 -12)     => 0

          ($fxmodulo +12 +3)      => 0
          ($fxmodulo +12 -3)      => 0
          ($fxmodulo -12 +3)      => 0
          ($fxmodulo -12 -3)      => 0

          ($fxmodulo +12 +4)      => 0
          ($fxmodulo +12 -4)      => 0
          ($fxmodulo -12 +4)      => 0
          ($fxmodulo -12 -4)      => 0

          ($fxmodulo +12 +5)      => +2
          ($fxmodulo +12 -5)      => -3
          ($fxmodulo -12 +5)      => +3
          ($fxmodulo -12 -5)      => -2

          ($fxmodulo +12 +7)      => +5
          ($fxmodulo +12 -7)      => -2
          ($fxmodulo -12 +7)      => +2
          ($fxmodulo -12 -7)      => -5

          ($fxmodulo +12 +24)     => +12
          ($fxmodulo +12 -24)     => -12
          ($fxmodulo -12 +24)     => +12
          ($fxmodulo -12 -24)     => -12

          ($fxmodulo +12 +20)     => +12
          ($fxmodulo +12 -20)     =>  -8
          ($fxmodulo -12 +20)     =>  +8
          ($fxmodulo -12 -20)     => -12

 -- Unsafe Operation: $fxabs FX
     Return the absolute value of FX as a fixnum.  When FX is
     '(least-fixnum)': its absolute value would be a fixnum, in which
     case this operation raises an implementation restriction violation.

     To compute the general absolute value without overflow we must use
     'abs' or '$abs-fixnum'.

Bitwise logic operations
........................

 -- Unsafe Operation: $fxnot FX
     Perform the bitwise NOT on the operand and return the result.

 -- Unsafe Operation: $fxand FX1 FX2
     Perform the bitwise AND on the operands and return the result.

 -- Unsafe Operation: $fxior FX1 FX2
     Perform the bitwise inclusive OR on the operands and return the
     result.

 -- Unsafe Operation: $fxxor FX1 FX2
     Perform the bitwise exclusive OR on the operands and return the
     result.

 -- Unsafe Operation: $fxif FX1 FX2 FX3
     Return the fixnum that is the bit-wise "if" of the two's complement
     representations of its arguments, i.e.  for each bit, if it is 1 in
     FX1, the corresponding bit in FX2 becomes the value of the
     corresponding bit in the result, and if it is 0, the corresponding
     bit in FX3 becomes the corresponding bit in the value of the
     result.

Other bitwise operations
........................

 -- Unsafe Operation: $fxsll FX1 FX2
     Perform bitwise shift left of FX1 by FX2 positions and return the
     result.

 -- Unsafe Operation: $fxsra FX1 FX2
     Perform bitwise shift right of FX1 by FX2 positions and return the
     result.

 -- Unsafe Operation: $fxcopy-bit FX1 FX2 FX3
     Unsafe version of 'fxcopy-bit'.

 -- Unsafe Operation: $fxcopy-bit-field FX1 FX2 FX3 FX4
     Unsafe version of 'fxcopy-bit-field'.

 -- Unsafe Operation: $fxrotate-bit-field FX1 FX2 FX3 FX4
     Unsafe version of 'fxrotate-bit-field'.

 -- Unsafe Operation: $fxbit-field FX1 FX2 FX3
     Unsafe version of 'fxbit-field'.

Conversion operations
.....................

 -- Unsafe Operation: $fixnum->string FX BASE
     Return a string object representing FX in BASE.  BASE must be one
     among: 2, 8, 10, 16.

 -- Unsafe Operation: $fixnum->char FX
     Return a new character value whose code point equals FX.

 -- Unsafe Operation: $char->fixnum CH
     Return a fixnum representing the code point of the operand.

 -- Unsafe Operation: $fixnum->flonum FX
     Convert the fixnum operand into a flonum and return a reference to
     the result.

Miscellaneous operations
........................

 -- Unsafe Operation: $fxinthash FX
     Evaluate to a fixnum which can be used as hash value.

          *NOTE* This appears to be unused in the source.


File: vicare-scheme.info,  Node: syslib bignums,  Next: syslib flonums,  Prev: syslib fixnums,  Up: syslib

12.5 Low level bignum operations
================================

The arguments BN to these operations must be bignums.  The following
bindings are exported by the library '(vicare system $bignums)'.  *note
iklib numerics:: for more functions acting on bignums.

 -- Unsafe Operation: $bignum-positive? BN
 -- Unsafe Operation: $bignum-negative? BN
     Evaluate to true if the operand is positive or negative.

 -- Unsafe Operation: $bignum-non-positive? BN
 -- Unsafe Operation: $bignum-non-negative? BN
     Evaluate to true if the operand is non-positive or non-negative.

 -- Unsafe Operation: $bignum-even? BN
 -- Unsafe Operation: $bignum-odd? BN
     Evaluate to true if the operand is even or odd.

 -- Unsafe Operation: $bignum-byte-ref BN FX
     Return a fixnum representing the byte at index FX in the data of
     BN.

 -- Unsafe Operation: $bignum-size BN
     Return a fixnum representing the number of machine words in the
     data portion of a bignum memory block.

 -- Unsafe Operation: $bignum->flonum BN
     Return a flonum object representing BN as inexact number.


File: vicare-scheme.info,  Node: syslib flonums,  Next: syslib ratnums,  Prev: syslib bignums,  Up: syslib

12.6 Low level flonum operations
================================

For all the low level operations, the arguments FL to these operations
must be flonums, the arguments FX must be fixnums.  The bindings
documented here are exported by the library '(vicare system $flonums)'.
*note iklib numerics:: for more functions acting on flonums.

* Menu:

* syslib flonums constr::       Flonum constructors.
* syslib flonums inspect::      Binary representation inspection.
* syslib flonums arithmetic::   Arithmetic operations.
* syslib flonums conversion::   Exactness and conversion.
* syslib flonums predicates::   Predicates.
* syslib flonums comparison::   Comparison functions.
* syslib flonums rounding::     Rounding function.
* syslib flonums parts::        Parts function.
* syslib flonums trigon::       Trigonometric operations.
* syslib flonums hyperbol::     Hyperbolic functions.
* syslib flonums log::          Exponentials and logarithms.
* syslib flonums power::        Power operations.


File: vicare-scheme.info,  Node: syslib flonums constr,  Next: syslib flonums inspect,  Up: syslib flonums

12.6.1 Flonum constructors
--------------------------

 -- Unsafe Operation: $make-flonum
     Allocate a new flonum memory block and return a reference to it.
     Does not initialise the data area.


File: vicare-scheme.info,  Node: syslib flonums inspect,  Next: syslib flonums arithmetic,  Prev: syslib flonums constr,  Up: syslib flonums

12.6.2 Binary representation inspection
---------------------------------------

 -- Unsafe Operation: $flonum-u8-ref FL FX
     Return the octet at index FX in the data area of FL.

     Notice that the FX offset is positive, but it represents an offset
     from the end of the data area; on a 32-bit platform, the indexes of
     the bytes are:

             1st word    2nd word    3rd word    4th word
          |-----------|-----------|-----------|-----------|
                                  |--|--|--|--|--|--|--|--| bytes
                                    7  6  5  4  3  2  1  0  offsets
                                  |.......................|
                                       IEEE 754 flonum

 -- Unsafe Operation: $flonum-set! FL FX-INDEX FX-VALUE
     Store the byte or octet represented by FX-VALUE at index FX-INDEX
     in the data area of FL.

 -- Unsafe Operation: $flonum-sbe FL
     Return a fixnum... Still undocumented, read the code look at the
     format of IEEE double precision flonums.


File: vicare-scheme.info,  Node: syslib flonums arithmetic,  Next: syslib flonums conversion,  Prev: syslib flonums inspect,  Up: syslib flonums

12.6.3 Arithmetic operations
----------------------------

 -- Unsafe Operation: $fl+ FL1 FL2 FL ...
 -- Unsafe Operation: $fl* FL1 FL2 FL ...
 -- Unsafe Operation: $fl/ FL1 FL2 FL ...
     Perform arithmetic operations.

 -- Unsafe Operation: $fl- FL
 -- Unsafe Operation: $fl- FL1 FL2 FL ...
     With one operand: return FL negated.  With two operands: subtract
     the operands and return the result.

 -- Unsafe Operation: $fldiv FL1 FL2
 -- Unsafe Operation: $flmod FL1 FL2
 -- Unsafe Operation: $fldiv0 FL1 FL2
 -- Unsafe Operation: $flmod0 FL1 FL2
 -- Unsafe Operation: $fldiv-and-mod FL1 FL2
 -- Unsafe Operation: $fldiv0-and-mod0 FL1 FL2
     Implement the number-theoretic integer divisions.


File: vicare-scheme.info,  Node: syslib flonums conversion,  Next: syslib flonums predicates,  Prev: syslib flonums arithmetic,  Up: syslib flonums

12.6.4 Exactness and conversion
-------------------------------

 -- Unsafe Operation: $flonum->maybe-exact FL
     Rationalize the operand and return the result.  If FL has an
     acceptable exact representation: return such representation;
     otherwise return '#f'.

 -- Unsafe Operation: $flexact FL
     Rationalize the operand and return the result.  If FL has an
     acceptable exact representation (it is finite): return such
     representation; otherwise raise a '&&implementation-restriction'
     exception.

 -- Unsafe Operation: $fixnum->flonum FX
     Convert the fixnum operand into a flonum and return a reference to
     the result.


File: vicare-scheme.info,  Node: syslib flonums predicates,  Next: syslib flonums comparison,  Prev: syslib flonums conversion,  Up: syslib flonums

12.6.5 Predicates
-----------------

 -- Unsafe Operation: $flnan? FL
     Return '#t' if the operand is a representation of not-a-number;
     otherwise return '#f'.

 -- Unsafe Operation: $flinfinite? FL
     Return '#t' if the operand is a representation of infinity:
     '+inf.0' or '-inf.0'; otherwise return '#f'.

 -- Unsafe Operation: $flzero? FL
     Return true if the operand is zero.  Notice that the return value
     will be true for both '+0.0' or '-0.0'.

 -- Unsafe Operation: $flzero?/positive FL
 -- Unsafe Operation: $flzero?/negative FL
     Return true if the operand is '+0.0' or '-0.0', respectively.

 -- Unsafe Operation: $flpositive? FL
     Return true if the operand is strictly positive.  This predicate
     fails when applied to '+0.0'; to check for positivity including
     '+0.0' we must use:

          (or ($flzero?/positive FL) ($fl> FL +0.0))

 -- Unsafe Operation: $flnegative? FL
     Return true if the operand is strictly negative.  This predicate
     fails when applied to '-0.0'; to check for negativity including
     '-0.0' we must use:

          (or ($flzero?/negative FL) ($fl< FL -0.0))

 -- Unsafe Operation: $flnonpositive? FL
     Return '#t' if the operand is non-positive.  This predicate returns
     '#f' when applied to '-0.0'.

 -- Unsafe Operation: $flnonnegative? FL
     Return '#t' if the operand is non-negative.  This predicate returns
     '#f' when applied to '+0.0'.

 -- Unsafe Operation: $fleven? FL
     Return true if the operand is even.

 -- Unsafe Operation: $flodd? FL
     Return true if the operand is odd.

 -- Unsafe Operation: $flonum-integer? FL
     Return true if the operand is integer.

 -- Unsafe Operation: $flonum-rational? FL
     Return true if the operand is rational.  All the flonums are
     rational with the exception of infinities and not-a-number.


File: vicare-scheme.info,  Node: syslib flonums comparison,  Next: syslib flonums rounding,  Prev: syslib flonums predicates,  Up: syslib flonums

12.6.6 Comparison functions
---------------------------

 -- Unsafe Operation: $fl= FL1 FL2 FL ...
 -- Unsafe Operation: $fl< FL1 FL2 FL ...
 -- Unsafe Operation: $fl<= FL1 FL2 FL ...
 -- Unsafe Operation: $fl> FL1 FL2 FL ...
 -- Unsafe Operation: $fl>= FL1 FL2 FL ...
     Perform comparison operations.

 -- Unsafe Operation: $fl!= FL1 FL2 FL ...
     The arguments must be flonums.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.  This operation
     does *not* distinguish between '+0.0' and '-0.0'.

 -- Unsafe Operation: $flmax FL1 FL2 . FL
     Return the maximum between the operands.

 -- Unsafe Operation: $flmin FL1 FL2 . FL
     Return the minimum between the operands.


File: vicare-scheme.info,  Node: syslib flonums rounding,  Next: syslib flonums parts,  Prev: syslib flonums comparison,  Up: syslib flonums

12.6.7 Rounding function
------------------------

 -- Unsafe Operation: $flround FL
     Return the closest integral flonum to the operand, rounding to even
     when FL represents a number halfway between two integers.

 -- Unsafe Operation: $flfloor FL
     Return the largest integral flonum not larger than the operand.

 -- Unsafe Operation: $flceiling FL
     Return the smallest integral flonum not larger than the operand.

 -- Unsafe Operation: $fltruncate FL
     Return the integral flonum closest to the operand whose absolute
     value is not larger than the absolute value of the operand itself.


File: vicare-scheme.info,  Node: syslib flonums parts,  Next: syslib flonums trigon,  Prev: syslib flonums rounding,  Up: syslib flonums

12.6.8 Parts function
---------------------

 -- Unsafe Operation: $flnumerator FL
 -- Unsafe Operation: $fldenominator FL
     Return the numerator or denominator of the operand.

 -- Unsafe Operation: $flabs FL
     Return the absolute value of the operand.


File: vicare-scheme.info,  Node: syslib flonums trigon,  Next: syslib flonums hyperbol,  Prev: syslib flonums parts,  Up: syslib flonums

12.6.9 Trigonometric operations
-------------------------------

 -- Unsafe Operation: $flsin FL
 -- Unsafe Operation: $flcos FL
 -- Unsafe Operation: $fltan FL
     Return the sine, cosine and tangent of the operand.

 -- Unsafe Operation: $flasin FL
 -- Unsafe Operation: $flacos FL
 -- Unsafe Operation: $flatan FL
 -- Unsafe Operation: $flatan FL1 FL2
     Return the arcsine, arccosine and arctangent of the operand.  When
     '$flatan' is applied to two arguments, it returns an equivalent of:

          (angle (make-rectangular FL2 FL1))

 -- Unsafe Operation: $flatan2 FL1 FL2
     Return an equivalent of:

          (angle (make-rectangular FL2 FL1))


File: vicare-scheme.info,  Node: syslib flonums hyperbol,  Next: syslib flonums log,  Prev: syslib flonums trigon,  Up: syslib flonums

12.6.10 Hyperbolic functions
----------------------------

 -- Function: $flsinh FL
 -- Function: $flcosh FL
 -- Function: $fltanh FL
     Compute the hyperbolic functions.  Return flonum objects.

 -- Function: $flasinh FL
 -- Function: $flacosh FL
 -- Function: $flatanh FL
     Compute the inverse hyperbolic functions.  Return flonum objects.


File: vicare-scheme.info,  Node: syslib flonums log,  Next: syslib flonums power,  Prev: syslib flonums hyperbol,  Up: syslib flonums

12.6.11 Exponentials and logarithms
-----------------------------------

 -- Unsafe Operation: $flcbrt FL
     Return the real cube root function of FL.

 -- Unsafe Operation: $flexp FL
     Return the base e exponential of the operand.

 -- Unsafe Operation: $fllog FL
 -- Unsafe Operation: $fllog FL1 FL2
     When applied to one argument: return the natural logarithm of the
     operand.  For non-negative FL the return value is a numeric flonum;
     for negative FL the return value is not-a-number.  See also
     '$log-flonum' to compute the logarithm of negative flonums as a
     complex number.

     When applied to two arguments: return the base-FL2 logarithm of
     FL1.

 -- Unsafe Operation: $fllog2 FL1 FL2
     Return the base-FL2 logarithm of FL1.

 -- Unsafe Operation: $flexpm1 FL
     Return an equivalent of exp(FL) - 1.

 -- Unsafe Operation: $fllog1p FL
     Return an equivalent of log(1 + FL).

 -- Unsafe Operation: $flhypot FL1 FL2
     Compute the Euclidean distance function: \sqrt(X*X+Y*Y). *note
     hypot: (libc)Exponents and Logarithms.


File: vicare-scheme.info,  Node: syslib flonums power,  Prev: syslib flonums log,  Up: syslib flonums

12.6.12 Power operations
------------------------

 -- Unsafe Operation: $flexpt FL1 FL2
     Return FL1 raised to the power of FL2.

 -- Unsafe Operation: $flsqrt FL
     Return the square root of the operand.

 -- Unsafe Operation: $flsquare FL
     Return the square of FL: FL times FL.

 -- Unsafe Operation: $flcube FL
     Return the cube of FL: FL times FL times FL.


File: vicare-scheme.info,  Node: syslib ratnums,  Next: syslib compnums,  Prev: syslib flonums,  Up: syslib

12.7 Low level ratnum operations
================================

The arguments RAT to these operations must be ratnums, the arguments NUM
and DEN must be references to either fixnums or bignums.  The following
bindings are exported by the library '(vicare system $ratnums)'.  *note
iklib numerics:: for more functions acting on ratnums.

 -- Unsafe Operation: $make-ratnum NUM DEN
     Allocate a new ratnum memory block, store NUM as reference to the
     numerator and DEN as reference to the denominator; return a
     reference to the ratnum.

     The following conditions must be met, else the returned value will
     be invalid:

        * NUM and DEN must be exact integers.

        * NUM and DEN must be non-zero.

        * DEN must be strictly positive.

        * NUM and DEN must have greatest common divisor equal to '1'
          (that is: they cannot be simplified).

 -- Unsafe Operation: $ratnum-num RAT
     Return the reference to the numerator.

 -- Unsafe Operation: $ratnum-den RAT
     Return the reference to the denominator.

 -- Unsafe Operation: $ratnum->flonum RAT
     Return a flonum object representing RAT as inexact number.

 -- Unsafe Operation: $ratnum-positive? RAT
 -- Unsafe Operation: $ratnum-negative? RAT
     Return '#t' if RAT is, respectively, positive or negative;
     otherwise return '#f'.

 -- Unsafe Operation: $ratnum-non-positive? RAT
 -- Unsafe Operation: $ratnum-non-negative? RAT
     Return '#t' if RAT is, respectively, non-positive or non-negative;
     otherwise return '#f'.


File: vicare-scheme.info,  Node: syslib compnums,  Next: syslib cflonums,  Prev: syslib ratnums,  Up: syslib

12.8 Low level compnum operations
=================================

The arguments CN to these operations must be compnums, the arguments NUM
must be references to either fixnums, bignums or flonums.  The following
bindings are exported by the library '(vicare system $compnums)'.  *note
iklib numerics:: for more functions acting on compnums.

 -- Unsafe Operation: $make-compnum NUM1 NUM2
     Allocate a new compnum memory block, store NUM1 as reference to the
     real part and NUM2 as reference to the imaginary part.  Return a
     reference to the compnum.

 -- Unsafe Operation: $make-rectangular REP IMP
     Return a real numebr, a new compnum or a new cflonum; REP and IMP
     can be any combination of real numbers.  If IMP is exact zero: the
     returned value is REP, a real.

 -- Unsafe Operation: $compnum-real CN
     Return the reference to the real part.

 -- Unsafe Operation: $compnum-imag CN
     Return the reference to the imaginary part.

 -- Unsafe Operation: $compnum->cflonum CN
     Return the inexact representation of a compnum as a cflonum.


File: vicare-scheme.info,  Node: syslib cflonums,  Next: syslib numerics,  Prev: syslib compnums,  Up: syslib

12.9 Low level cflonum operations
=================================

The arguments CMP to these operations must be cflonums, the arguments FL
must be references to flonums.  The following bindings are exported by
the library '(vicare system $compnums)'.  *note iklib numerics:: for
more functions acting on cflonums.

 -- Unsafe Operation: $make-cflonum FL1 FL2
     Allocate a new cflonum memory block, store FL1 as reference to the
     real part and FL2 as reference to the imaginary part.  Return a
     reference to the cflonum.

 -- Unsafe Operation: $cflonum-real CMP
     Return the reference to the real part.

 -- Unsafe Operation: $cflonum-imag CMP
     Return the reference to the imaginary part.


File: vicare-scheme.info,  Node: syslib numerics,  Next: syslib chars,  Prev: syslib cflonums,  Up: syslib

12.10 Low level numerics operations
===================================

The library '(vicare system $numerics)' export bindings for low level
operations on numbers.

* Menu:

* syslib numerics neg::         Numbers negation.
* syslib numerics inv::         Numbers inversion.
* syslib numerics add1::        Exact integers increment.
* syslib numerics sub1::        Exact integers decrement.
* syslib numerics add::         Numbers addition.
* syslib numerics sub::         Numbers subtraction.
* syslib numerics mul::         Numbers multiplication.
* syslib numerics div::         Numbers division.
* syslib numerics square::      Squaring of numbers.
* syslib numerics cube::        Cube of numbers.
* syslib numerics gcd::         Greatest common divisor.
* syslib numerics lcm::         Least common multiple.
* syslib numerics quorem::      Quotient and remainder.
* syslib numerics quotient::    Quotient between numbers.
* syslib numerics remainder::   Remainder between numbers.
* syslib numerics modulo::      Modulo between numbers.
* syslib numerics max::         Maximum between numbers.
* syslib numerics min::         Minimum between numbers.
* syslib numerics abs::         Absolute value of real numbers.
* syslib numerics sign::        Sign of real numbers.
* syslib numerics numerator::   Numerator of real numbers.
* syslib numerics denominator:: Denominator of real numbers.
* syslib numerics exact::       Conversion to exact number.
* syslib numerics inexact::     Conversion to inexact number.
* syslib numerics expt::        Raising numbers to power.
* syslib numerics sqrt::        Square root of numbers.
* syslib numerics cbrt::        Cubic root of numbers.
* syslib numerics log::         Logarithms of numbers.
* syslib numerics exp::         Exponentials of numbers.
* syslib numerics sin::         Trigonometric sine.
* syslib numerics cos::         Trigonometric cosine.
* syslib numerics tan::         Trigonometric tangent.
* syslib numerics asin::        Trigonometric arc sine.
* syslib numerics acos::        Trigonometric arc cosine.
* syslib numerics atan::        Trigonometric arc tangent.
* syslib numerics sinh::        Hyperbolic sine.
* syslib numerics cosh::        Hyperbolic cosine.
* syslib numerics tanh::        Hyperbolic tangent.
* syslib numerics asinh::       Hyperbolic arc sine.
* syslib numerics acosh::       Hyperbolic arc cosine.
* syslib numerics atanh::       Hyperbolic arc tangent.
* syslib numerics conjugate::   Complex conjugate.
* syslib numerics magnitude::   Magnitude of complex numbers.
* syslib numerics angle::       Angle of complex numbers.
* syslib numerics bitnot::      Bitwise logic not.
* syslib numerics bitand::      Bitwise logic and.
* syslib numerics bitior::      Bitwise logic inclusive or.
* syslib numerics bitxor::      Bitwise logic exclusive or.
* syslib numerics floor::       Floor rounding.
* syslib numerics ceiling::     Ceiling rounding.
* syslib numerics truncate::    Truncate rounding.
* syslib numerics round::       Round rounding.


File: vicare-scheme.info,  Node: syslib numerics neg,  Next: syslib numerics inv,  Up: syslib numerics

12.10.1 Negation negation
-------------------------

 -- Unsafe Operation: $neg-number NUM
     Negate any number object and return the result.

 -- Unsafe Operation: $neg-fixnum FX
     Negate a fixnum; return a fixnum or a bignum, the latter when FX is
     '(least-fixnum)'.

 -- Unsafe Operation: $neg-bignum BN
     Negate a bignum; return a bignum or a fixnum, the latter when BN is
     equal to '(- (least-fixnum))'.

 -- Unsafe Operation: $neg-flonum FL
     Negate a flonum and return the result as a flonum.

 -- Unsafe Operation: $neg-ratnum RT
     Negate a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $neg-compnum CN
     Negate a compnum and return the result as a compunm.

 -- Unsafe Operation: $neg-cflonum CFL
     Negate a cflonum and return the result as cflonum.


File: vicare-scheme.info,  Node: syslib numerics inv,  Next: syslib numerics add1,  Prev: syslib numerics neg,  Up: syslib numerics

12.10.2 Numbers inversion
-------------------------

If the operand is zero: the following operations raise an exception.

 -- Unsafe Operation: $inv-number NUM
     Compute the inverse of any number object and return the result.

 -- Unsafe Operation: $inv-fixnum FX
     Compute the inverse of a fixnum and return the result as a fixnum
     or ratnum.  A fixnum is returned if FX is '+1' or '-1'.

 -- Unsafe Operation: $inv-bignum BN
     Compute the inverse of a bignum and return the result as a ratnum.

 -- Unsafe Operation: $inv-flonum FL
     Compute the inverse of a flonum and return the result as a flonum.

 -- Unsafe Operation: $inv-ratnum RT
     Compute the inverse of a ratnum and return the result as a fixnum,
     bignum or ratnum.  A fixnum or bignum is returned when the
     numerator of RT is '+1' or '-1'.

 -- Unsafe Operation: $inv-compnum CN
     Compute the inverse of a compnum and return the result as a compnum
     or cflonum.

 -- Unsafe Operation: $inv-cflonum CFL
     Compute the inverse of a cflonum and return the result as a
     cflonum.


File: vicare-scheme.info,  Node: syslib numerics add1,  Next: syslib numerics sub1,  Prev: syslib numerics inv,  Up: syslib numerics

12.10.3 Exact integers increment
--------------------------------

 -- Unsafe Operation: $add1-integer N
     Increment by 1 the fixnum or bignum N and return the result.

 -- Unsafe Operation: $add1-bignum N
     Increment by 1 the bignum N and return the result.

 -- Unsafe Operation: $add1-fixnum N
     Increment by 1 the fixnum N and return the result.


File: vicare-scheme.info,  Node: syslib numerics sub1,  Next: syslib numerics add,  Prev: syslib numerics add1,  Up: syslib numerics

12.10.4 Exact integers decrement
--------------------------------

 -- Unsafe Operation: $sub1-integer N
     Decrement by 1 the fixnum or bignum N and return the result.

 -- Unsafe Operation: $sub1-bignum N
     Decrement by 1 the bignum N and return the result.

 -- Unsafe Operation: $sub1-fixnum N
     Decrement by 1 the fixnum N and return the result.


File: vicare-scheme.info,  Node: syslib numerics add,  Next: syslib numerics sub,  Prev: syslib numerics sub1,  Up: syslib numerics

12.10.5 Numbers addition
------------------------

 -- Unsafe Operation: $add-number-number NUM1 NUM2
     Add any couple of numbers and return the result.

Generic number as second operand
................................

 -- Unsafe Operation: $add-fixnum-number FX NUM
     Add a fixnum with a number and return the result.

 -- Unsafe Operation: $add-bignum-number BN NUM
     Add a bignum with a number and return the result.

 -- Unsafe Operation: $add-flonum-number FL NUM
     Add a flonum with a number and return the result.

 -- Unsafe Operation: $add-ratnum-number RT NUM
     Add a ratnum with a number and return the result.

 -- Unsafe Operation: $add-compnum-number CN NUM
     Add a compnum with a number and return the result.

 -- Unsafe Operation: $add-cflonum-number CFL NUM
     Add a cflonum with a number and return the result.

Generic number as first operand
...............................

 -- Unsafe Operation: $add-number-fixnum NUM FX
     Add any number with a fixnum and return the result.

 -- Unsafe Operation: $add-number-bignum NUM BN
     Add any number with a bignum and return the result.

 -- Unsafe Operation: $add-number-flonum NUM FL
     Add any number with a flonum and return the result.

 -- Unsafe Operation: $add-number-ratnum NUM RT
     Add any number with a ratnum and return the result.

 -- Unsafe Operation: $add-number-compnum NUM CN
     Add any number with a compnum and return the result.

 -- Unsafe Operation: $add-number-cflonum NUM CFL
     Add any number with a cflonum and return the result.

Fixnum as first operand
.......................

 -- Unsafe Operation: $add-fixnum-fixnum FX1 FX2
     Add a fixnum with a fixnum and return the result as a fixnum or
     bignum.

 -- Unsafe Operation: $add-fixnum-bignum FX BN
     Add a fixnum with a bignum and return the result as a fixnum or
     bignum.

 -- Unsafe Operation: $add-fixnum-flonum FX FL
     Add a fixnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $add-fixnum-ratnum FX RT
     Add a fixnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $add-fixnum-compnum FX CN
     Add a fixnum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $add-fixnum-cflonum FX CFL
     Add a fixnum with a cflonum and return the result as a cflonum.

Bignum as first operand
.......................

 -- Unsafe Operation: $add-bignum-fixnum BN FX
     Add a bignum with a fixnum and return the result as a fixnum or
     bignum.

 -- Unsafe Operation: $add-bignum-bignum BN1 BN2
     Add a bignum with a bignum and return the result as a fixnum or
     bignum.

 -- Unsafe Operation: $add-bignum-flonum BN FL
     Add a bignum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $add-bignum-ratnum BN RT
     Add a bignum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $add-bignum-compnum BN CN
     Add a bignum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $add-bignum-cflonum BN CFL
     Add a bignum with a cflonum and return the result as a cflonum.

Flonum as first operand
.......................

 -- Unsafe Operation: $add-flonum-fixnum FL FX
     Add a flonum with a fixnum and return the result as a flonum.

 -- Unsafe Operation: $add-flonum-bignum FL BN
     Add a flonum with a bignum and return the result as a flonum.

 -- Unsafe Operation: $add-flonum-flonum FL1 FL2
     Add a flonum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $add-flonum-ratnum FL RT
     Add a flonum with a ratnum and return the result as a flonum.

 -- Unsafe Operation: $add-flonum-compnum FL CN
     Add a flonum with a compnum and return the result as a compnum or
     cflonum.

 -- Unsafe Operation: $add-flonum-cflonum FL CFL
     Add a flonum with a cflonum and return the result as a cflonum.

Ratnum as first operand
.......................

 -- Unsafe Operation: $add-ratnum-fixnum RT FX
     Add a ratnum with a fixnum and return the result as a ratnum.

 -- Unsafe Operation: $add-ratnum-bignum RT BN
     Add a ratnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $add-ratnum-flonum RT FL
     Add a ratnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $add-ratnum-ratnum RT1 RT2
     Add a ratnum with a ratnum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $add-ratnum-compnum RT CN
     Add a ratnum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $add-ratnum-cflonum RT CFL
     Add a ratnum with a cflonum and return the result as a cflonum.

Compnum as first operand
........................

 -- Unsafe Operation: $add-compnum-fixnum CN FX
     Add a compnum with a fixnum and return the result as a compnum.

 -- Unsafe Operation: $add-compnum-bignum CN BN
     Add a compnum with a bignum and return the result as a compnum.

 -- Unsafe Operation: $add-compnum-ratnum CN RT
     Add a compnum with a ratnum and return the result as a compnum.

 -- Unsafe Operation: $add-compnum-compnum CN1 CN2
     Add a compnum with a compnum and return the result as a number (not
     necessarily a compnum).

 -- Unsafe Operation: $add-compnum-flonum CN FL
     Add a compnum with a flonum and return the result as a compnum or
     cflonum.

 -- Unsafe Operation: $add-compnum-cflonum CN CFL
     Add a compnum with a cflonum and return the result as a cflonum.

Cflonum as first operand
........................

 -- Unsafe Operation: $add-cflonum-fixnum CFL FX
     Add a cflonum with a fixnum and return the result as a cflonum.

 -- Unsafe Operation: $add-cflonum-bignum CFL BN
     Add a cflonum with a bignum and return the result as a cflonum.

 -- Unsafe Operation: $add-cflonum-ratnum CFL RT
     Add a cflonum with a ratnum and return the result as a cflonum.

 -- Unsafe Operation: $add-cflonum-flonum CFL FL
     Add a cflonum with a flonum and return the result as a cflonum.

 -- Unsafe Operation: $add-cflonum-compnum CFL CN
     Add a cflonum with a compnum and return the result as a cflonum.

 -- Unsafe Operation: $add-cflonum-cflonum CFL1 CFL2
     Add a cflonum with a cflonum and return the result as a cflonum.

