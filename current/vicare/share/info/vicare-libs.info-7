This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: gcc,  Next: flonum format,  Prev: parser logic,  Up: Top

12 A toy library interface to GCC
*********************************

The library '(vicare gcc)' is installed along with Vicare; it implements
a toy interface to 'gcc', the GNU C Compiler.  Its purpose is to build,
at runtime, a C language shared library from possibly dynamically
constructed C code; then load the library and access a C function as FFI
callout.

   '(vicare gcc)' must be considered as a toy to demonstrate the
features of Vicare; it is installed only if the POSIX, GNU C library and
Libffi APIs are enabled at package configuration time.

   The following is an example of function to increment an integer:

     #!r6rs
     (import (vicare)
       (prefix (vicare gcc) gcc.))

     (gcc.initialise "/usr/local/bin/gcc" "/home/marco/var/tmp/")

     (gcc.define-c-function
       signed-int incr (signed-int)
       "#include <stdio.h>
        int incr (int a) {
          return 1+a;
        }")

     (incr 1)        => 2

the code creates a shared library 'libincr.so' in a subdirectory of the
given initialisation directory, then load it and access the symbol
'incr'.

   '(vicare gcc)' depends upon the following libraries:

     (vicare ffi)
     (vicare posix)
     (vicare glibc)
     (vicare platform constants)
     (vicare language-extensions syntaxes)

 -- Function: initialise GCC TMPDIR
     Initialise the library.  GCC must be the string full filename of
     the GCC executable.  TMPDIR must be the string pathname of an
     existing directory on a partition with executable permissions; it
     is used to create temporary files, including the shared libraries.

     Temporary files go in a subdirectory of TMPDIR; it is the
     responsibility of the system administrator to clean up regularly
     such subdirectories.

 -- Syntax: define-c-function ?RETVAL ?NAME ?ARGS ?CODE
     Define a new Scheme function wrapping a C function from a shared
     library.  ?NAME must be an identifier representing the name of the
     function.

     ?RETVAL must be a symbol selecting the type of the return value;
     ?ARGS must be a list of symbols selecting the types of the
     arguments; *note Specifying native types: (vicare-scheme)ffi call
     types. for details.

     ?CODE must be a Scheme string representing the C code to be
     compiled.

 -- Parameter: COMPILE-FLAGS
     References a list of string.  Base options for the compiler, it is
     initialised to '("-c")'.

 -- Parameter: LINK-FLAGS
     References a list of string.  Base options for the linker, it is
     initialised to '("-pipe" "-shared" "-fPIC")'.

 -- Parameter: CFLAGS
     References a list of string.  Additional options for the compiler,
     it is initialised to '("-O2")'.

 -- Parameter: LDFLAGS
     References a list of string.  Additional options for the linker, it
     is initialised to nil.


File: vicare-libs.info,  Node: flonum format,  Next: flonum parser,  Prev: gcc,  Up: Top

13 Formatting flonums
*********************

The following bindings are exported by the library '(vicare numerics
flonum-formatter)'.

 -- Function: format-flonum POSITIVE? DIGITS EXPONENT
     Given a list of characters DIGITS and a fixnum EXPONENT compose a
     string representing the corresponding flonum.  POSITIVE? determines
     the sign.

          #!r6rs
          (import (vicare)
            (vicare numerics flonum-formatter))

          (define digits
            '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

          (format-flonum #t digits 0)     => "0.123456789"
          (format-flonum #t digits 1)     => "1.23456789"
          (format-flonum #t digits 2)     => "12.3456789"
          (format-flonum #t digits 3)     => "123.456789"
          (format-flonum #t digits 8)     => "12345678.9"
          (format-flonum #t digits 9)     => "123456789.0"
          (format-flonum #t digits 10)    => "1.23456789e9"

          (format-flonum #t digits -1)    => "0.0123456789"
          (format-flonum #t digits -2)    => "0.00123456789"
          (format-flonum #t digits -3)    => "0.000123456789"
          (format-flonum #t digits -4)    => "1.23456789e-5"

          (format-flonum #f digits 1)     => "-1.23456789"
          (format-flonum #f digits 2)     => "-12.3456789"
          (format-flonum #f digits 3)     => "-123.456789"
          (format-flonum #f digits 8)     => "-12345678.9"
          (format-flonum #f digits 9)     => "-123456789.0"
          (format-flonum #f digits 10)    => "-1.23456789e9"

          (format-flonum #f digits -1)    => "-0.0123456789"
          (format-flonum #f digits -2)    => "-0.00123456789"
          (format-flonum #f digits -3)    => "-0.000123456789"
          (format-flonum #f digits -4)    => "-1.23456789e-5"


File: vicare-libs.info,  Node: flonum parser,  Next: debugging,  Prev: flonum format,  Up: Top

14 Parsing flonums
******************

The following bindings are exported by the library '(vicare numerics
flonum-parser)'.

 -- Function: parse-flonum FLONUM REAL-FUNC UNREAL-FUNC
     Parse the FLONUM its components for string formatting.

     If FLONUM is representable as real number, apply the function
     REAL-FUNC to 3 arguments: a boolean, true if FLONUM is positive; a
     list of characters representing the digits of FLONUM; a fixnum
     representing the exponent of FLONUM.  Return the result of the
     application.

     If FLONUM is not representable as real number, apply the function
     UNREAL-FUNC to a single argument being the string representation of
     FLONUM.  Return the result of the application.

     Notice how the arguments handed to REAL-FUNC match the argument of
     'format-flonum' from '(vicare flonum-formatter)'.

          #!r6rs
          (import (vicare)
            (vicare numerics flonum-parser))

          (parse-flonum 1.23456789
                        (lambda args (cons 'real args))
                        (lambda args (cons 'unreal args)))
          => (real #t
              (#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
               #\0 #\0 #\0 #\0 #\0 #\0 #\0 #\1)
              1)

          (parse-flonum 12.34e5
                        (lambda args (cons 'real args))
                        (lambda args (cons 'unreal args)))
          => (real #t (#\1 #\2 #\3 #\4) 7)

          (parse-flonum -12.34e5
                        (lambda args (cons 'real args))
                        (lambda args (cons 'unreal args)))
          => (real #f (#\1 #\2 #\3 #\4) 7)

          (parse-flonum +inf.0
                        (lambda args (cons 'real args))
                        (lambda args (cons 'unreal args)))
          => (unreal "+inf.0")

          (parse-flonum +nan.0
                        (lambda args (cons 'real args))
                        (lambda args (cons 'unreal args)))
          => (unreal "+nan.0")


File: vicare-libs.info,  Node: debugging,  Next: getopts,  Prev: flonum parser,  Up: Top

15 Debugging facilities
***********************

* Menu:

* debugging compiler::          Inspecting the compiler internals.


File: vicare-libs.info,  Node: debugging compiler,  Up: debugging

15.1 Inspecting the compiler internals
======================================

The following bindings are exported by the library '(vicare debugging
compiler)'.


File: vicare-libs.info,  Node: getopts,  Next: checks,  Prev: debugging,  Up: Top

16 Parsing command line arguments
*********************************

The library '(vicare getopts)' implements basic parsing of Unix-style
command line arguments.  It is meant to be used as low-level module in
an infrastructure for command line interface programs (CLI).  It is
alternative to SRFI-37, *note SRFI-37 a program argument processor: srfi
args-fold.

   It is suggested to import this library with the prefix 'getopts.', as
in:

     (import (vicare)
       (prefix (vicare getopts) getopts.))

* Menu:

* getopts intro::               Introduction.
* getopts types::               Type definitions.
* getopts config::              Parser configuration.
* getopts parser::              Parsing arguments.
* getopts conditions::          Exceptions and condition objects.


File: vicare-libs.info,  Node: getopts intro,  Next: getopts types,  Up: getopts

16.1 Introduction
=================

Command line arguments are available through the 'command-line' function
from the '(rnrs programs (6))' library.  For the purposes of this
documentation, command line arguments are divided into three categories:

Option without value
     A string selecting a configuration option that can be turned on or
     off.  It can be a single character (brief option) or a full-word
     (long option).

Option with value
     A string selecting a value for a configuration option; an option's
     value is a string of any length, including the empty string.

Non-option
     A value to be passed to the program.

   Let's assume that:

   * '-v', '-i' and '-h' are brief options that do not require a value.

   * '-f', '-o' and '-I' are brief options that do require a value.

   * '--verbose', '--interactive' and '--help' are long options that do
     not require a value.

   * '--file', '--output' and '--include' are long options that do
     require a value.

the following command line chunks are so interpreted:

'-vh -o green -i -Iwhite -f red'
     The '-v', '-h' and '-i' options without value; the '-o' option with
     value 'green'; the '-I' option with value 'white'; the '-f' option
     with value 'red'.

'--verbose --help --output=green --interactive'
'--include white --file=red'
     The '--verbose', '--help' and '--interactive' options without
     value; the '--output' option with value 'green'; the '--include'
     option with value 'white'; the '--file' option with value 'red'.

   The argument '--' is recognised as "end of options" marker: all the
arguments following it are interpreted as non-options, even if their
string starts with a dash or double dash.

   Chains of brief options are allowed: the options '-v', '-i' and '-h'
can be selected with the single argument '-vih'.  Notice, though, that
only options with no value can be chained; an option with value can
appear only as last in the train, with no value attached.  For example:

     -vihI white

is interpreted as the options '-v', '-i' and '-h' with no value followed
by the option '-I' with value 'white'; the following:

     -vihIwhite              ;forbidden

could be made possible but, being unreadable, it is forbidden.

   Notice that a single dash, '-', is a valid non-option argument.


File: vicare-libs.info,  Node: getopts types,  Next: getopts config,  Prev: getopts intro,  Up: getopts

16.2 Type definitions
=====================

 -- R6RS Record Type: command-line-option
     Type of records representing command line options.

 -- Immutable Field of command-line-option: brief
     A Scheme character representing a dash plus single character
     (brief) option selector; to specify an option with no brief
     selector, we can set this field to '#f'.

 -- Immutable Field of command-line-option: long
     A Scheme string representing a long option selector, without the
     double-dash prefix; to specify an option with no long selector, we
     can set this field to '#f'.

 -- Immutable Field of command-line-option: requires-argument?
     Boolean, true if this option requires an argument.

 -- Immutable Field of command-line-option: description
     Scheme string describing this option, to be used in help screens.

 -- Immutable Field of command-line-option: action
     Semantic action, a closure to be invoked when this option is found
     on the command line.

        * If the field 'requires-argument?' is set to '#f': the closure
          is applied to a single value being the 'command-line-option'
          record representing the option.

        * If the field 'requires-argument?' is set to '#t': the closure
          is applied to two values being the 'command-line-option'
          record representing the option and the Scheme string
          representing the option's value.

     We have to remember that 'command-line-option' records can be
     compared with 'eq?'.

 -- Function: make-command-line-option BRIEF LONG REQUIRES-ARGUMENT?
          DESCRIPTION ACTION
     Build and return a new 'command-line-option' record.

 -- Function: command-line-option? OBJ
     Return '#t' if OBJ is a record of type 'command-line-option',
     otherwise return '#f'.

 -- Syntax: define-command-line-option ?NAME ?CLAUSE ...
 -- Auxiliary Syntax: brief ?CHAR
 -- Auxiliary Syntax: long ?STRING
 -- Auxiliary Syntax: requires-argument ?BOOL
 -- Auxiliary Syntax: description ?STRING
 -- Auxiliary Syntax: action ?FUNCTION
     Build a new 'command-line-option' record and bind it to ?NAME,
     which must be a Scheme symbol.  All the ?CLAUSE arguments must be
     subforms with an auxiliary syntactic keyword as first element.
     Example:

          (define-command-line-option interactive
            (brief               #\i)
            (long                "interactive")
            (requires-argument   #f)
            (description         "ask the user first")
            (action              (lambda (option) ---)))

 -- Function: command-line-option-brief OPT
 -- Function: command-line-option-long OPT
 -- Function: command-line-option-requires-argument? OPT
 -- Function: command-line-option-description OPT
 -- Function: command-line-option-action OPT
     Accessors for the fields of a 'command-line-option' record.


File: vicare-libs.info,  Node: getopts config,  Next: getopts parser,  Prev: getopts types,  Up: getopts

16.3 Parser configuration
=========================

 -- Enumeration: getopts-configuration
     Enumeration to be used to configure the 'getopts' parser.  It
     contains the following symbols:

     'delayed'
          If given, action closures invocations are returned in a list
          rather that immediately evaluated; this allows 'getopts' to
          parse the whole command line without changing the state of the
          program.

          The returned list has a thunk for each semantic action, in the
          same order in which the corresponding arguments appear on the
          command line.  We can evaluate the thunks with:

               (let ((thunks (getopts ---)))
                 (for-each (lambda (T) (T)) thunks))

     'ignore-multiple-double-dashes'
          The first double-dash argument, '--', always marks the end of
          options.  If this option is given, multiple '--' after the
          first are all ignored; else they are interpreted as non-option
          arguments.

 -- Syntax: getopts-options SYMBOL ...
     Expand into an enumerated set of symbols to be used to configure
     the operations of the 'getopts' parser.


File: vicare-libs.info,  Node: getopts parser,  Next: getopts conditions,  Prev: getopts config,  Up: getopts

16.4 Parsing arguments
======================

 -- Function: getopts COMMAND-LINE OPTIONS ARGUMENT-ACTION
 -- Function: getopts COMMAND-LINE OPTIONS ARGUMENT-ACTION
          CONFIG-OPTIONS
     Parse the Scheme strings in the list COMMAND-LINE as command line
     arguments, according to the options described by the list OPTIONS
     of 'command-line-option' records.  If the configuration option
     'delayed' is not used, the return value is '#f'.

     ARGUMENT-ACTION must be a Scheme function accepting a single
     argument: a Scheme string representing a command line non-option.

     The optional CONFIG-OPTIONS must be an enumerated set of values
     from the 'getopts-configuration' enumeration.

   Meaningless usage example:

     (import (vicare)
       (vicare getopts)
       (only (vicare language-extensions syntaxes)
             set-cons!))

     (define result #f)

     (define (register-with opt val)
       (set-cons! result (list (command-line-option-long opt) val)))

     (define (register-without opt)
       (set-cons! result (list (command-line-option-long opt))))

     (define (register-non-option arg)
       (set-cons! result arg))

     (define-command-line-option interactive
       (brief               #\i)
       (long                "interactive")
       (requires-argument   #f)
       (description         "ask the user first")
       (action              register-without))

     (define-command-line-option force
       (brief               #\f)
       (long                "force")
       (requires-argument   #f)
       (description         "hurt me plenty")
       (action              register-without))

     (define-command-line-option help
       (brief               #\h)
       (long                "help")
       (requires-argument?  #f)
       (description         "print help screen")
       (action              register-without))

     (define-command-line-option file
       (brief               #\F)
       (long                "file")
       (requires-argument   #t)
       (description         "input file")
       (action              register-with))

     (define-command-line-option archive
       (brief               #\A)
       (long                "archive")
       (requires-argument   #t)
       (description         "output archive")
       (action              register-with))

     (getopts (command-line)
              (list interactive force help file archive)
              register-non-option
              (getopts-options ignore-multiple-double-dashes))


File: vicare-libs.info,  Node: getopts conditions,  Prev: getopts parser,  Up: getopts

16.5 Exceptions and condition objects
=====================================

When 'getopts' detects an error in the input command line arguments, it
raises a continuable exception; returning from the exception is possible
and makes 'getopts' go on parsing with the next argument.  It is not
always advisable to continue parsing after an error has been signaled.

   The raised exception values are compound condition of the types
described below.

Base condition object
.....................

 -- Condition Type: &getopts
     Base type for all the condition objects thrown by 'getopts'; it is
     derived from '&error'.  It has no fields.

 -- Function: make-getopts-condition
 -- Function: getopts-condition? OBJ
     Constructor and predicate for the '&getopts' condition object.

Option data object
..................

 -- Condition Type: &option
     Data condition type used to hold records of type
     'command-line-option' describing an option involved in an error; it
     is derived from '&condition'.

 -- Function: make-option-condition OPTION-RECORD
 -- Function: option-condition? OBJ
     Constructor and predicate for the '&option' condition object.

 -- Function: condition-option OPTION-CONDITION
     Accessor for the 'option' field of a '&option' condition object.

Argument data object
....................

 -- Condition Type: &argument
     Data condition type used to hold Scheme strings representing
     command line arguments involved in an error; it is derived from
     '&condition'.

 -- Function: make-argument-condition ARGUMENT-STRING
 -- Function: argument-condition? OBJ
     Constructor and predicate for the '&argument' condition object.

 -- Function: condition-argument ARGUMENT-CONDITION
     Accessor for the 'argument' field of a '&argument' condition
     object.

Option selector data object
...........................

 -- Condition Type: &brief/long
     Data condition type used to hold Scheme strings or characters
     representing option selectors involved in an error; it is derived
     from '&condition'.

 -- Function: make-brief/long-condition BRIEF/LONG-STRING
 -- Function: brief/long-condition? OBJ
     Constructor and predicate for the '&brief/long' condition object.

 -- Function: condition-brief/long BRIEF/LONG-CONDITION
     Accessor for the field of a '&brief/long' condition object.

Unknown option error
....................

 -- Condition Type: &unknown-option
     Condition type used to signal an "unknown option" error; it is
     derived from '&getopts'.  It has no fields.

 -- Function: make-unknown-option-condition
 -- Function: unknown-option-condition? OBJ
     Constructor and predicate for '&unknown-option' condition objects.

 -- Function: raise-unknown-option WHO BRIEF/LONG ARGUMENT MESSAGE
     Raise a continuable exception describing an "unknown option" error;
     the raised object is a compound condition with components of the
     following types: '&who', '&brief/long', '&argument', '&message'.

Option requires value error
...........................

 -- Condition Type: &option-requires-value
     Condition type used to signal an "option requires value" error; it
     is derived from '&getopts'.  It has no fields.

 -- Function: make-option-requires-value-condition
 -- Function: option-requires-value-condition? OBJ
     Constructor and predicate for '&option-requires-value' condition
     objects.

 -- Function: raise-option-requires-value WHO OPTION ARGUMENT MESSAGE
     Raise a continuable exception describing an "option requires value"
     error; the raised object is a compound condition with components of
     the following types: '&who', '&option', '&argument', '&message'.

Option requires no value error
..............................

 -- Condition Type: &option-requires-no-value
     Condition type used to signal an "option requires no value" error;
     it is derived from '&getopts'.  It has no fields.

 -- Function: make-option-requires-no-value-condition
 -- Function: option-requires-no-value-condition? OBJ
     Constructor and predicate for '&option-requires-no-value' condition
     objects.

 -- Function: raise-option-requires-no-value WHO OPTION ARGUMENT MESSAGE
     Raise a continuable exception describing an "option requires no
     value" error; the raised object is a compound condition with
     components of the following types: '&who', '&option', '&argument',
     '&message'.

Invalid option error
....................

 -- Condition Type: &invalid-option
     Condition type used to signal an "invalid option" error; it is
     derived from '&getopts'.  It has no fields.

 -- Function: make-invalid-option-condition
 -- Function: invalid-option-condition? OBJ
     Constructor and predicate for '&invalid-option' condition objects.

 -- Function: raise-invalid-option WHO OPTION ARGUMENT MESSAGE
     Raise a continuable exception describing an "invalid option" error;
     the raised object is a compound condition with components of the
     following types: '&who', '&option', '&argument', '&message'.


File: vicare-libs.info,  Node: checks,  Next: tracing,  Prev: getopts,  Up: Top

17 Lightweight testing
**********************

The library '(vicare checks)' aprovides a simple mechanism for testing
Scheme programs.  As a primitive example, the expression:

     (check (+ 1 1) => 3)

evaluates the expression '(+ 1 1)' and compares the result with the
expected result '3' provided after the syntactic keyword '=>'.  Then the
outcome of this comparison is reported in human-readable form by
printing a message of the form:

     (+ 1 1)
      => 2
      ; *** failed ***
      ; expected result: 3

   The library '(vicare checks)' is derived by SRFI-78; *note SRFI-78
lightweight testing: srfi lightweight-testing, for details.

* Menu:

* checks select::               Selecting tests to be run.
* checks eval::                 Evaluating code.
* checks result::               Handling multiple results.
* checks output::               Special output functions.


File: vicare-libs.info,  Node: checks select,  Next: checks eval,  Up: checks

17.1 Selecting tests to be run
==============================

As usage example, let's assume that the system environment variable
'CHECK_TEST_NAME' is set to 'yellow':

     (parameterise ((check-test-name 'yellow))

       ;; this is evaluated
       (check
           (do-something)
         => 123)

       ;; this is evaluated, too
       (check
           (do-some-other-thing)
         => 456))

     (parameterise ((check-test-name 'blue))

       ;; this is NOT evaluated
       (check
           (do-something)
         => #t)

       ;; this is NOT evaluated
       (check
           (do-some-other-thing)
         => #f))

     ;; this is evaluated
     (check "yellow-one"
         (do-something)
       => 123)

     ;; this is NOT evaluated
     (check 'red
         (do-something)
       => #t)

 -- Environment Variable: CHECK_TEST_NAME
     The system environment variable used to select tests in a test
     suite file.  The value of the variable must be the name, or the
     prefix of the name, or the suffix of the name, of one or more
     tests.

 -- Parameter: check-test-name
     Holds the name of the current test or tests.  Must be set to '#f',
     a string or a symbol.


File: vicare-libs.info,  Node: checks eval,  Next: checks result,  Prev: checks select,  Up: checks

17.2 Evaluating code
====================

 -- Syntax: check EXPR (=> EQUAL) EXPECTED
 -- Syntax: check EXPR => EXPECTED
 -- Syntax: check NAME EXPR (=> EQUAL) EXPECTED
 -- Syntax: check NAME EXPR => EXPECTED
     Evaluate EXPR and compare its return value to the return value of
     EXPECTED using the predicate EQUAL, which is 'equal?' when omitted.
     Then a report is printed according to the current mode setting (see
     below) and the outcome is recorded in a global state to be used in
     'check-report'.

     The precise order of evaluation is that first EQUAL and EXPECTED
     are evaluated (in unspecified order) and then EXPR is evaluated.
     Example: '(check (+ 1 1) => 2)'.

     When NAME is given: it is the name of this test, *note Selecting
     tests to be run: checks select.

 -- Function: check-report
     Print a summary and the first failed check, if there is any,
     depending on the current mode settings.  Call 'exit' to exit the
     current process with code:

     '0'
          If all the tests were run successfully.

     '1'
          If at least one test failed.

 -- Function: check-set-mode! MODE
     Set the current mode to MODE, which must be a symbol among: 'off',
     'summary', 'report-failed', 'report'; the default is 'report'.
     Note that you can change the mode at any time, and that 'check' and
     'check-report' use the current value.

     The mode symbols have the following meaning:

     'off'
          do not execute any of the checks;

     'summary'
          print only summary in 'check-report' and nothing else;

     'report-failed'
          report failed checks when they happen, and in summary;

     'report'
          report every example executed.

 -- Function: check-reset!
     Reset the global state (counters of correct/failed examples) to the
     state immediately after loading the module for the first time, i.e.
     no checks have been executed.

 -- Function: check-passed? EXPECTED-TOTAL-COUNT
     Return '#t' if there were no failed checks and EXPECTED-TOTAL-COUNT
     correct checks, '#f' otherwise.

     Rationale: This procedure can be used in automatized tests by
     terminating a test program with the statement:

          (exit (if (check-passed? n) 0 1))

 -- Syntax: false-if-exception FORM0 FORM ...
     Evaluate all the FORMs as in 'begin'.  If an exception is raised:
     return '#f'.

 -- Syntax: check-for-true EXPR
 -- Syntax: check-for-true NAME EXPR
 -- Syntax: check-for-false EXPR
 -- Syntax: check-for-false NAME EXPR
     Evaluate EXPR in a 'check' form, expecting a non-false or '#f'
     value as result.

     When NAME is given: it is the name of this test, *note Selecting
     tests to be run: checks select.

 -- Syntax: check-for-assertion-violation ?BODY =>
          ?EXPECTED-WHO/IRRITANTS
 -- Auxiliary Syntax: =>
     Expand to:

          (check
              (guard (E ((assertion-violation? E)
                         (list (condition-who E)
                               (condition-irritants E))
                        (else E))
                ?body)
            => ?expected-who/irritants))

 -- Syntax: check-for-procedure-argument-violation ?BODY =>
          ?EXPECTED-WHO/IRRITANTS
 -- Auxiliary Syntax: =>
     Expand to:

          (check
              (guard (E ((procedure-argument-violation? E)
                         (list (condition-who E)
                               (condition-irritants E))
                        (else E))
                ?body)
            => ?expected-who/irritants))

 -- Syntax: check-for-procedure-signature-argument-violation ?BODY =>
          ?EXPECTED-WHO/IRRITANTS
 -- Auxiliary Syntax: =>
     Expand to:

          (check
              (guard (E ((procedure-argument-violation? E)
                         (list (condition-who E)
                               (procedure-argument-violation.one-based-argument-index E)
                               (procedure-argument-violation.failed-expression E)
                               (procedure-argument-violation.offending-value E)))
                        (else E))
                ?BODY)
            => ?EXPECTED-WHO/IRRITANTS)

 -- Syntax: check-for-procedure-signature-return-value-violation ?BODY
          => ?EXPECTED-WHO/IRRITANTS
 -- Auxiliary Syntax: =>
     Expand to:

          (check
              (guard (E ((procedure-signature-return-value-violation? E)
                         (list (condition-who E)
                               (procedure-signature-return-value-violation.one-based-return-value-index E)
                               (procedure-signature-return-value-violation.failed-expression E)
                               (procedure-signature-return-value-violation.offending-value E)))
                        (else E))
                ?BODY)
            => ?EXPECTED-WHO/IRRITANTS)

 -- Syntax: check-for-procedure-arguments-consistency-violation ?BODY =>
          ?EXPECTED-WHO/IRRITANTS
 -- Auxiliary Syntax: =>
     Expand to:

          (check
              (guard (E ((procedure-arguments-consistency-violation? E)
                         (list (condition-who E)
                               (condition-irritants E)))
                        (else E))
                ?BODY)
            => ?EXPECTED-WHO/IRRITANTS)

 -- Syntax: check-for-expression-return-value-violation ?BODY =>
          ?EXPECTED-WHO/IRRITANTS
 -- Auxiliary Syntax: =>
     Expand to:

          (check
              (guard (E ((expression-return-value-violation? E)
                         (list (condition-who E)
                               (condition-irritants E)))
                        (else E))
                ?BODY)
            => ?EXPECTED-WHO/IRRITANTS)


File: vicare-libs.info,  Node: checks result,  Next: checks output,  Prev: checks eval,  Up: checks

17.3 Handling multiple results
==============================

 -- Syntax: with-result FORM0 FORM ...
     Evaluate all the FORMs, as in 'internal-body', in a dynamic
     environment in which an implicit result variable is defined.  The
     implicit variable is handled as a list.

     Return a list whose first value is the return value of the last
     FORM and whose second value is the value of the implicit variable.

 -- Function: add-result OBJ
     Append OBJ to the list in the implicit variable defined by
     'with-result', return OBJ itself.

 -- Function: get-result
     Return the current value of the implicit variable defined by
     'with-result'.


File: vicare-libs.info,  Node: checks output,  Prev: checks result,  Up: checks

17.4 Special output functions
=============================

 -- Constant: check-quiet-tests?
     Set to a boolean value.  It is initialised from the system
     environment variable 'VICARE_CHECK_QUIET': when the variable is set
     to 'yes' or a non-zero fixnum, the boolean is '#t'; otherwise it is
     '#f'.

 -- Function: check-display OBJ
     Display OBJ to the current error port if 'check-quiet-tests?' is
     set to '#t'.

 -- Function: check-write OBJ
     Write OBJ to the current error port if 'check-quiet-tests?' is set
     to '#t'.

 -- Function: check-newline
     Display a newline character to the current error port if
     'check-quiet-tests?' is set to '#t'.

 -- Function: check-pretty-print OBJ
     Pretty prints OBJ to the current error port if 'check-quiet-tests?'
     is set to '#t'.


File: vicare-libs.info,  Node: tracing,  Next: multimethods,  Prev: checks,  Up: Top

18 Tracing syntaxes
*******************

 -- Procedure: make-traced-procedure NAME PROC
     The procedure 'make-traced-procedure' takes a name (typically a
     symbol) and a procedure.  It returns a procedure similar to PROC
     except that it traces its arguments and values.

          > (define (fact n)
              (if (zero? n)
                  (lambda (k) (k 1))
                  (lambda (k)
                    ((fact (- n 1))
                     (make-traced-procedure `(k ,n)
                       (lambda (v)
                         (k (* v n))))))))
          > (call/cc
              (lambda (k)
                ((fact 5) (make-traced-procedure 'K k))))
          |((k 1) 1)
          |((k 2) 1)
          |((k 3) 2)
          |((k 4) 6)
          |((k 5) 24)
          |(K 120)
          120

 -- Syntax: trace-define (?NAME . ?ARGS) ?BODY0 ?BODY ...
 -- Syntax: trace-define ?NAME ?EXPRESSION
     The 'trace-define' syntax is similar to 'define' except that the
     bound value, which must be a procedure, becomes a traced procedure.
     A traced procedure prints its arguments when it is called and
     prints its values when it returns.

          > (trace-define (fact n)
              (if (zero? n) 1 (* n (fact (- n 1)))))
          > (fact 5)
          |(fact 5)
          | (fact 4)
          | |(fact 3)
          | | (fact 2)
          | | |(fact 1)
          | | | (fact 0)
          | | | 1
          | | |1
          | | 2
          | |6
          | 24
          |120
          120

     The tracing facility in Vicare preserves and shows tail recursion
     and distinguishes it from non-tail recursion by showing tail calls
     starting at the same line in which their parent was called.

          > (trace-define (fact n)
              (trace-define (fact-aux n m)
                (if (zero? n) m (fact-aux (- n 1) (* n m))))
              (fact-aux n 1))
          > (fact 5)
          |(fact 5)
          |(fact-aux 5 1)
          |(fact-aux 4 5)
          |(fact-aux 3 20)
          |(fact-aux 2 60)
          |(fact-aux 1 120)
          |(fact-aux 0 120)
          |120
          120

     Moreover, the tracing facility interacts well with continuations
     and exceptions.

          > (call/cc
              (lambda (k)
                (trace-define (loop n)
                  (if (zero? n)
                      (k 'done)
                      (+ (loop (- n 1)) 1)))
                (loop 5)))
          |(loop 5)
          | (loop 4)
          | |(loop 3)
          | | (loop 2)
          | | |(loop 1)
          | | | (loop 0)
          done

 -- Syntax: trace-lambda ?NAME ?ARGS ?BODY0 ?BODY ...
     The 'trace-lambda' macro is similar to 'lambda' except that the
     resulting procedure is traced: it prints the arguments it receives
     and the results it returns.

 -- Syntax: trace-define-syntax ?KEYWORD ?EXPRESSION
     Like 'define-syntax' but create a tracing transformer function.
     Whenever the macro is expanded the transformer function will print
     its argument (the input form) and its return value (the output
     form).  Example:

          (trace-define-syntax ciao
            (syntax-rules ()
              ((_ ?a)
               (list 1 ?a 3))))

          (ciao 2)
          -| |(ciao (ciao 2))
          -| |(list 1 2 3)

     the first printed symbolic expression '(ciao (ciao 2))' shows the
     called tranformer function '(ciao ---)' and its argument being the
     input form '(ciao 2)', filtered through 'syntax->datum'.

 -- Syntax: trace-let-syntax ?BINDINGS ?FORM ...
 -- Syntax: trace-letrec-syntax ?BINDINGS ?FORM ...
     Like 'let-syntax' and 'letrec-syntax' but define tracing
     transformer functions.


File: vicare-libs.info,  Node: multimethods,  Next: net channels,  Prev: tracing,  Up: Top

19 Multimethods dispatching
***************************

In the context of the library '(vicare language-extensions
multimethods)': "generic functions", or "multimethods", are interfaces
to procedures that can be specialised to the (possibly conventional)
data types of their arguments; each specialisation of a generic function
is called "method".  When applying a generic function to a tuple of
arguments, the most specific method with respect to the arguments' types
is chosen.

   The library defines two kinds of generic functions: ordinary and
starred.  "Ordinary generic functions" only have one (primary) method
for each possible tuple of argument types.  "Starred generic functions"
may have qualified primary, before, after and around methods for each
possible tuple of argument types; the methods are applied (composed)
according to a defined protocol.

   Multimethods are meant to be used with the typed language.

* Menu:

* multimethods examples::       Examples of method dispatching.
* multimethods application::    How generic functions and methods
                                are invoked.
* multimethods dispatching::    How methods are dispatched.
* multimethods definers::       Declaring multimethod definers.
* multimethods defining::       Built-in multimethod definers.
* multimethods methods::        Adding methods to a multimethod.
* multimethods next::           Invoking the next method.
* multimethods predefined::     Predefined multimethods.


File: vicare-libs.info,  Node: multimethods examples,  Next: multimethods application,  Up: multimethods

19.1 Examples of method dispatching
===================================

Here we look at some examples of what we have to expect from
multimethods dispatching.  We will always assume that the code in the
examples is wrapped into a 'program' form as follows:

     #!vicare
     (program (demo)
       (options typed-language)
       (import (vicare)
         (vicare language-extensions multimethods))

       ... ;here goes the code

       #| end of program |# )

   Let's examine an example using the generic functions definer
'define-generic':

     (define-record-type <one>                  (nongenerative one))
     (define-record-type <two>   (parent <one>) (nongenerative two))
     (define-record-type <three> (parent <two>) (nongenerative three))

the type hierarchy is:

     <top> -> <struct> -> <record> -> <one> -> <two> -> <three>

the list of UIDs for '<three>' is:

     (type-unique-identifiers <three>)
     => (three two one
         vicare:scheme-type:<record>
         vicare:scheme-type:<struct>
         vicare:scheme-type:<top>)

so for the generic function:

     (define-generic doit (o))
     (define-method (doit {o <one>}) 'one)
     (define-method (doit {o <two>}) 'two)

applied to a value of type '<three>': the method with '<two>' in the
signature is _more specific_ than the method with '<one>' in the
signature:

     (doit (new <three>)) => two

also the method with '<one>' in the signature is the "next method" of
the method with '<two>' in the signature, we can call it using
'call-next-method'.  The following example shows a call to the next
method:

     (define-generic fluff (o))

     (define-method (fluff {o <one>})
       'one)

     (define-method (fluff {o <two>})
       (cons 'two (call-next-method)))

     (define o (new <three>))

     (fluff o)
     => (two . one)

   The syntax 'define-generic' defines a macro which can be used as a
function; the syntax 'define-method' adds a new method to the generic
function; 'define-generic' establishes the number of arguments for the
generic function: all the methods must have the same number of
arguments.

   It is possible to define a function accepting different numbers of
arguments as follows:

     (case-define fluff
       ((a)
        (fluff-1 a))
       ((a b)
        (fluff-2 a b))
       ((a b . rest)
        (fluff-3 a b rest)))

     (define-generic fluff-1 (o))
     (define-generic fluff-2 (o p))
     (define-generic fluff-3 (o p rest))

     (define-method (fluff-1 {o <one>})
       ---)

     (define-method (fluff-2 {o <one>} {p <two>})
       ---)

     (define-method (fluff-3 {o <one>} {p <two>} rest)
       ---)

this way we turn a set of macros into a single "generic function" which
is truly a function.  If we avoid wrapping the macros into a function we
may gain a bit of speed in function calls.


File: vicare-libs.info,  Node: multimethods application,  Next: multimethods dispatching,  Prev: multimethods examples,  Up: multimethods

19.2 How generic functions and methods are invoked
==================================================

The library '(vicare language-extensions multimethods)' is designed to
work with type definitions from the library '(vicare)' ('<fixnum>',
'<string>', et cetera); these types and their hierarchy are identified
by unique symbols (UID).  For example:

     (type-unique-identifiers <string>)
     => (vicare:scheme-type:<string>
         vicare:scheme-type:<top>)

   Every method has arguments specified by a tuple of type identifiers;
for example, the method definition:

     (define-method (fluff {A <string>} {B <struct>} {C <top>})
       ---)

has arguments specified by the tuple of identifiers:

     (<string> <struct> <top>)

   Every tuple of operands to which a multimethod is applied is
associated to a tuple of type identifiers; for example, in the
multimethod application:

     (define {B <struct>} ---)
     (define {C <top>}    ---)
     (fluff "ciao" B C)

the type of the operands is specified by the tuple of type identifiers:

     (<string> <struct> <top>)

   This way each tuple of method's arguments and each tuple of operands
is associated to a tuple of UIDs lists.  For example, the tuple of type
identifiers:

     (<string> <struct> <top>)

is associated to the tuple of UID lists:

     ((vicare:scheme-type:<string> vicare:scheme-type:<top>)
      (vicare:scheme-type:<struct> vicare:scheme-type:<top>)
      (vicare:scheme-type:<top>))

   A tuple of UID lists is called "signature".  Each multimethod holds
an internal collection in which every method's closure object is
associated to a signature.

Ordinary multimethods
.....................

Ordinary multimethods allow the association of a single method to a type
signature.  When an ordinary multimethod is applied to a tuple of
operands, the following happens:

  1. For each operand a type is determined and the list of UIDs
     representing the type hierarchy is acquired.  The operands'
     signature is formed.

  2. The internal collection of methods is queried for all the methods
     applicable to the tuple of operands, using the operands' signature
     as search key.

  3. The list of applicable methods is sorted from the most specific to
     the least specific for the operands' signature.  From now on the
     list of sorted, applicable methods is handled as a stack.

  4. The next method is popped from the stack and its closure applied to
     the tuple of arguments; the return value of this application
     becomes the return value of the generic function application.  If
     the function calls its "next method": recurse to step 4 (*note
     Invoking the next method: multimethods next.).

Starred multimethods
....................

Starred multimethods allow the definition of four qualified methods:
':primary', ':around', ':before' and ':after'; we can think of ordinary
multimethods as starred generics supporting only ':primary' methods.
The short description is that: ':around' methods are applied first, then
':before', ':primary' and ':after' methods are applied in this order.

   For each method qualification (':primary', ':around', ...): a starred
multimethod holds an internal collection in which every method's closure
is associated to an arguments' signature.

   When a starred multimethod is applied to a tuple of operands, the
following happens:

  1. For each operand a type is determined and the list of UIDs
     representing the type hierarchy is acquired.  The operands'
     signature is formed.

  2. For each method qualification: the internal collection is queried
     for all the methods applicable to the tuple of operands, using the
     operands' signature as search key.

  3. For each method qualification: the list of applicable methods is
     sorted from the most specific to the least specific for the
     operands' signature.  The list of ':after' methods is reversed:
     from the least specific to the most specific.

   From now on the lists of sorted applicable methods are handled as
stacks; the stacks of ':primary', ':around' and ':before' methods have
the most specific method on the top; the stack of ':after' methods has
the least specific method on the top.

   From now on the application of the multimethod enters an implicit
loop in which more methods' closures can be applied to the same tuple of
operands.  The loop can terminate if a method's closure throws an
exception or, for ':around' and ':primary' methods, if it does not take
the special action of calling 'call-next-method'.

   The loop is a bit articulated, so we may have to read the following
descriptions multiple times.  We split the description in two branches:
First a simplified invocation for multimethods having at least one
applicable ':primary' method, no ':around' methods, and performing no
calls to 'call-next-method'; then the full application algorithm.

   Here is the simplified branch with no ':around' methods and no calls
to 'call-next-method':

  4. Pop all the ':before' methods from the stack and apply their
     closures to the tuple of operands.  The return values of these
     applications are discarded.

  5. Pop the next ':primary' method from the stack and apply its closure
     to the tuple of operands.  The return value of this application is
     saved in a temporary location.

  6. Pop all the ':after' methods from the stack and apply their
     closures to the tuple of operands.  The return values of these
     applications are discarded.

  7. Return the saved return value of the ':primary' method.

here is the full application algorithm:

  4. Test if this function application originated from a call to
     'call-next-method' from a ':before' or ':after' method; if it has:
     raise an assertion violation.

  5. Test if this function application originated from a call to
     'call-next-method' from a ':primary' method; if it has:

       a. If the stack of ':primary' methods is empty raise an assertion
          violation.

       b. Pop the next ':primary' method from the stack and apply its
          closure to the tuple of operands.

       c. Break out returning the return value of this application: it
          becomes the return value of 'call-next-method'.

  6. If the stack of ':primary' methods is empty: raise an assertion
     violation.  This condition means that the multimethod has no
     applicable methods for the tuple of operands.

  7. If the stack of ':around' methods is not empty: pop the next
     ':around' method and apply its closure to the tuple of operands.
     Break out returning the return value of this application.

  8. Pop all the ':before' methods from the stack and apply their
     closures to the tuple of operands.  The return values of these
     applications are discarded.

  9. Pop the next ':primary' method from the stack and apply its closure
     to the tuple of operands.  The return value of this application is
     saved in a temporary location.

  10. Pop all the ':after' methods from the stack and apply their
     closures to the tuple of operands.  The return values of these
     applications are discarded.

  11. Return the saved return value of the ':primary' method.

   The ':primary' methods are meant to do the real work of the function.
Only the most specific is applied to the operands, however it can use
'call-next-method' to invoke a least specialised version and use its
return value, and so on recursively until there are no more next
methods.

   ':before' and ':after' methods are meant to execute additional work
before and after the primary methods; for example test pre and post
conditions on the operands.  While ':before' methods are applied from
the most specific to the least specific, ':after' methods are applied
from the least specific to the most specific.  Notice that the ':after'
methods have no access to the return value of the ':primary' methods.

   ':around' methods are yet another level for performing tasks before
and after the primary methods; only the most specific is applied to the
operands.  It is expected, but not mandatory, that an ':around' method
invokes 'call-next-method'; when such invocations are performed
recursively: they will consume all the applicable ':around' methods,
from the most specific to the least specific, and then will start the
application of ':before', ':primary' and ':after' methods.

   The protocol of application for methods in a starred multimethod is
meant to be the same as the standard method combination for CLOS methods
as defined by the Common Lisp standard(1).

   ---------- Footnotes ----------

   (1) See for example (URL last verified Aug 7, 2013):

     <http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node285.html>


File: vicare-libs.info,  Node: multimethods dispatching,  Next: multimethods definers,  Prev: multimethods application,  Up: multimethods

19.3 How methods are dispatched
===============================

Here we attempt the formulation of the rules of method dispatching.  A
method is identified by a couple of values: the signature and the
closure.

Applicability
.............

First we need to understand when a method is applicable to a tuple of
operands:

  1. Methods in a multimethod have the same number of arguments, so the
     tuple of operands must match that number.

  2. Given a tuple of operands, position by position, the type of the
     method's argument is equal to, or a parent of, the type of the
     given operand.

Specificity
...........

Now we can understand how to determine which one, among two applicable
methods, is more specific for a tuple of operands.  Let's call the
methods A and B.

   Notice that it is forbidden to two distinct methods, in the same
multimethod, to have the same signature.

   Vicare types support only single inheritance, so if two methods are
applicable: the homologous lists of UIDs in their signatures, have at
least one 'eq?' member (different from '<top>').

   The lists of UIDs in the signatures are compared in couples, from the
first argument/first operand to the last argument/last operand, and from
list head to list tail.

  1. If the first UIDs are 'eq?': the next couple is inspected.

  2. If the UID from B is a member of the list from A: A is more
     specific than B.


File: vicare-libs.info,  Node: multimethods definers,  Next: multimethods defining,  Prev: multimethods dispatching,  Up: multimethods

19.4 Declaring multimethod definers
===================================

The following syntaxes allow the definition and merging of generic
functions; merging multimethods can be useful when two libraries export
generic functions bound to identifiers having the same name.

 -- Syntax: define-generic-definer ?DEFINER ?CLAUSE ...
 -- Auxiliary Syntax: operand-type-inspector ?FUNC
     Define a new syntax, bound to the identifier ?DEFINER, to be used
     to define ordinary generic functions.

     The argument of the clause 'operand-type-inspector' must be an
     expression which, evaluated at run-time, returns a function; such
     function, applied to a multimethod operand, must return the list of
     type UIDs.  This clause is mandatory.  See below for details.

     The library '(vicare language-extensions multimethods)' defines the
     macro 'define-generic' as follows:

          (define-generic-definer define-generic
            (operand-type-inspector type-unique-identifiers-of))

 -- Syntax: define-generic*-definer ?DEFINER ?CLAUSE ...
 -- Auxiliary Syntax: operand-type-inspector ?FUNC
 -- Auxiliary Syntax: reverse-before-methods? ?BOOL
     Define a new syntax, bound to the identifier ?DEFINER, to be used
     to define starred generic functions.

     The argument of the clause 'operand-type-inspector' must be an
     expression which, evaluated at run-time, returns a function; such
     function, applied to a multimethod operand, must return the list of
     type UIDs.  This clause is mandatory.  See below for details.

     The argument of the clause 'reverse-before-methods?' must be a
     boolean datum: '#t' if the methods qualified as ':before' must be
     reversed and so applied from the least specific to the most
     specific; '#f' if the standard method protocol must be adopted.
     This clause is optional: the default is to use the standard method
     protocol.  See below for details.

     The library '(vicare language-extensions multimethods)' defines the
     macro 'define-generic*' as follows:

          (define-generic*-definer define-generic*
            (operand-type-inspector  type-unique-identifiers-of)
            (reverse-before-methods? #f))

 -- Auxiliary Syntax: operand-type-inspector ?FUNC
     The clause 'operand-type-inspector' allows the specification of a
     function to map a multimethod operand to the list of UIDs
     representing its type.  ?FUNC must be an expression which,
     evaluated at run-time, returns a function.

     When merging generic functions: the type inspector function is the
     one of the multimethod in which the others are merged.

     Usually the 'operand-type-inspector' clause selects a wrapper for
     'type-unique-identifiers-of'.

 -- Auxiliary Syntax: reverse-before-methods? ?BOOL
     The default methods composition protocol states that ':before' and
     ':around' methods are evaluated from the most specific to the least
     specific, while ':after' methods are evaluated from the least
     specific to the most specific.

     When the clause 'reverse-before-methods?' is used and ?BOOL is
     '#t': the order of ':before' methods is reversed to "from the least
     specific to the most specific" prior to evaluating them.  *note
     multimethods methods:: for an example of why this customisation is
     useful.


File: vicare-libs.info,  Node: multimethods defining,  Next: multimethods methods,  Prev: multimethods definers,  Up: multimethods

19.5 Built-in multimethod definers
==================================

 -- Function: type-unique-identifiers-of OBJ
     Object-type inspector function; return the list of UIDs in the type
     hierarchy of OBJ.  When this function does not recognise an
     object's type: the return value just identifies OBJ as of type
     '<top>'.  This function can recognise automatically all the
     instances of types declared by 'define-record-type'.  This function
     recognises only the following built-in types:

          <compound-condition> <record> <struct> <hashtable>
          <positive-fixnum> <negative-fixnum> <zero-fixnum>
          <positive-bignum> <negative-bignum>
          <positive-flonum> <negative-flonum>
          <positive-zero-flonum> <negative-zero-flonum>
          <positive-ratnum> <negative-ratnum>
          <zero-cflonum> <non-zero-cflonum>
          <zero-compnum> <inexact-compnum> <exact-compnum>
          <char> <empty-string> <nestring>
          <gensym> <symbol>
          <empty-vector> <nevector>
          <empty-bytevector> <nebytevector>
          <null> <pair>
          <binary-input/output-port> <textual-input/output-port>
          <binary-input-port>  <textual-input-port>
          <binary-output-port> <textual-output-port>
          <transcoder>
          <procedure>
          <top>

 -- Syntax: define-generic ?NAME ?FORMALS ?CLAUSE ...
 -- Auxiliary Syntax: merge-with-multimethods ?GENERIC ...
     Define a new ordinary multimethod (a macro) and bind it to ?NAME.
     The number of arguments is specified by ?FORMALS: a list of
     identifiers, one for each argument; the list is used only to
     determine the number of arguments (it can be used to document the
     intended meaning of the arguments).

     When the optional 'merge-with-multimethods' clause is used: the
     internal methods table is initialised to the union of the methods
     tables from the ?GENERIC arguments, which must be ordinary
     multimethod identifiers.  The union is performed by visiting
     arguments from left to right; when two methods have the same
     signature, the one from the leftmost multimethod takes precedence.

 -- Syntax: define-generic* ?NAME ?FORMALS ?CLAUSE ...
 -- Auxiliary Syntax: merge-with-multimethods ?GENERIC ...
     Define a new starred multimethod (a macro) and bind it to ?NAME.
     The number of arguments is specified by ?FORMALS: a list of
     identifiers, one for each argument; the list is used only to
     determine the number of arguments (it can be used to document the
     intended meaning of arguments).

     When the optional 'merge-with-multimethods' clause is used: the
     internal methods tables are initialised to the unions of the
     methods tables from the ?GENERIC arguments, which must be starred
     multimethod identifiers.  The union is performed by visiting
     arguments from left to right; when two methods have the same
     signature, the one from the leftmost multimethod takes precedence.


File: vicare-libs.info,  Node: multimethods methods,  Next: multimethods next,  Prev: multimethods defining,  Up: multimethods

19.6 Adding methods to a multimethod
====================================

 -- Syntax: define-method (?GENERIC ?ARG-SPEC ...) ?BODY0 ?BODY ...
 -- Syntax: define-method ((brace ?GENERIC ?TYPE0 ?TYPE ...) ?ARG-SPEC
          ...) ?BODY0 ?BODY ...
 -- Syntax: define-method ?GENERIC (?ARG-SPEC ...) ?BODY0 ?BODY ...
 -- Syntax: define-method ?QUALIFIER ?GENERIC (?ARG-SPEC ...) ?BODY0
          ?BODY ...
 -- Syntax: define-method ?GENERIC ?QUALIFIER (?ARG-SPEC ...) ?BODY0
          ?BODY ...
 -- Auxiliary Syntax: :primary
 -- Auxiliary Syntax: :around
 -- Auxiliary Syntax: :before
 -- Auxiliary Syntax: :after
 -- Auxiliary Syntax: brace
     Add a new method to an already existent generic function ?GENERIC,
     either ordinary or starred:

        * When the ?QUALIFIER argument is not present or it is the
          ':primary' syntax: ?GENERIC can be either an ordinary or
          starred generic function.

        * When the ?QUALIFIER argument is the ':before', ':after' or
          ':around' syntax: ?GENERIC must be a starred generic function.

     The list of ?ARG-SPEC specifies the type of the arguments for which
     this method specialises the generic function; an ?ARG-SPEC can be:

     '(brace ?ARG ?TYPE)'
          Where ?ARG is the formal name of the argument, ?TYPE the type
          identifier of the expected operand, 'brace' is the identifier
          exported by '(vicare)' and reexported by '(vicare
          language-extensions multimethods)'.

     '?ARG'
          Where ?ARG is the formal name of the argument.  In this case
          the type defaults to '<top>', which is interpreted as parent
          of every other type (and so it has the least specificity).

     If the ?GENERIC function name comes with ?TYPE arguments: such
     arguments specify the type of the return values.  The types are
     used to validate the return values of the method's closure object,
     but they do *not* constitute the types of values returned by the
     multimethod application.

     If a method is defined with the same signature of an already
     registered method: the old method is overwritten by the new one.

     In the lexical context of the ?BODY forms: the fluid syntax
     '__who__' is bound to the quoted name of the multimethod, ?GENERIC.

 -- Syntax: add-method ?GENERIC ?TYPES ?CLOSURE
 -- Syntax: add-method ?GENERIC ?QUALIFIER ?TYPES ?CLOSURE
 -- Auxiliary Syntax: :primary
 -- Auxiliary Syntax: :around
 -- Auxiliary Syntax: :before
 -- Auxiliary Syntax: :after
     Add a new method to an already existent multimethod ?GENERIC,
     either ordinary or starred:

        * When the ?QUALIFIER argument is not present or it is the
          ':primary' syntax: ?GENERIC can be either an ordinary or
          starred multimethod.

        * When the ?QUALIFIER argument is the ':before', ':after' or
          ':around' syntax: ?GENERIC must be a starred multimethod.

     ?TYPES must be a list of type identifiers for which this method
     specialises the generic function.  ?CLOSURE must be an expression
     which, evaluated at run-time, returns the method's implementation
     closure.  It is responsibility of the programmer to make sure that
     ?TYPES and ?CLOSURE are coherent.


File: vicare-libs.info,  Node: multimethods next,  Next: multimethods predefined,  Prev: multimethods methods,  Up: multimethods

19.7 Invoking the next method
=============================

The library '(vicare language-extensions multimethods)' makes use of
parameters to implement the "next method" facility(1); this allows, for
example, functions from foreign libraries to be used directly as
methods, through 'add-method'.  The bindings are available also to code
outside the method implementations, but this is not a big problem.

 -- Function: call-next-method
     Call the next most specific method.

 -- Function: next-method?
     Return true if a next method is available.

   ---------- Footnotes ----------

   (1) A "traditional" way to make the bindings 'call-next-method' and
'next-method?' available in the body of methods (rejected by this
implementation) is to add two arguments to the function at expand time;
the following method function:

     (lambda (arg1 arg2)
       ---)

is changed to:

     (lambda (call-next-method next-method? arg1 arg2)
       ---)

this way the bindings are available only to the methods.  This
implementation requires the source syntax object of the method to be
available at expansion time, and to hold a 'lambda' form.


File: vicare-libs.info,  Node: multimethods predefined,  Prev: multimethods next,  Up: multimethods

19.8 Predefined multimethods
============================

 -- Ordinary Multimethod: object->string OBJ
     Return a string representation for OBJ.  A non-specialised method
     is predefined to use the following implementation:

          (call-with-string-output-port
             (lambda (port)
               (display obj port)))


File: vicare-libs.info,  Node: net channels,  Next: comparators,  Prev: multimethods,  Up: Top

20 Interprocess connection channels
***********************************

The library '(vicare net channels)' implements facilities to let
software entities exchange messages in a controlled environment, through
Scheme input/output ports; the library expects the entities to take turn
in sending messages terminated with a known sequence of bytes.  A set of
interface-types is defined to allow other software units to implement a
compatible API, possibly using other underlying devices.

   The reference use is to let processes exchange messages through
network sockets.  The library is *not* meant to be used in the wild,
where rogue or malicious entities may attempt to corrupt the other side.

   The library is implemented with the typed language and it is meant to
be used by programs and libraries using the typed language.  This
documentation describes the library version '(0 4 2016 10 20)'.

* Menu:

* net channels ann::            Useful type annotations.
* net channels channels::       Channels definitions.
* net channels ifaces::         Interface-type definitions.
* net channels conditions::     Condition object types.


File: vicare-libs.info,  Node: net channels ann,  Next: net channels channels,  Up: net channels

20.1 Useful type annotations
============================

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Type: <binary-terminators>
     Type of message terminators for binary channels.  It is defined as
     non-empty vector of non-empty bytevectors.

 -- Type: <textual-terminators>
     Type of message terminators for textual channels.  It is defined as
     non-empty vector of non-empty strings.


File: vicare-libs.info,  Node: net channels channels,  Next: net channels ifaces,  Prev: net channels ann,  Up: net channels

20.2 Interface-type definitions
===============================

* Menu:

* net channels channels channel::     Type '<channel>'.
* net channels channels bichannel::   Type '<binary-input-channel>'.
* net channels channels bochannel::   Type '<binary-output-channel>'.
* net channels channels biochannel::  Type '<binary-input/output-channel>'.
* net channels channels tichannel::   Type '<textual-input-channel>'.
* net channels channels tochannel::   Type '<textual-output-channel>'.
* net channels channels tiochannel::  Type '<textual-input/output-channel>'.


File: vicare-libs.info,  Node: net channels channels channel,  Next: net channels channels bichannel,  Up: net channels channels

20.2.1 The '<channel>' type
---------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <channel>
     Expose the basic configuration and inspection methods for all the
     channels.

 -- Method on <channel>: <epoch-time> expiration-time THIS
 -- Method on <channel>: <void> expiration-time THIS {TIME <epoch-time>}
     Accessor and mutator for the message transfer expiration time.  The
     argument TIME must be an instance of '<epoch-time>' (as defined by
     '(vicare)') representing the maximum time before which the message
     transfer must be completed.

     If the time limit is violated: an exception is raised at the first
     attempted operation.

 -- Method on <channel>: <positive-fixnum> maximum-message-size THIS
 -- Method on <channel>: <positive-fixnum> maximum-message-size THIS
          {LEN <positive-fixnum>}
     Accessor and mutator for the maximum message size.  The argument
     LEN must be the maximum allowed length for a whole message,
     measured in bytes for binary channels and in characters for textual
     channels.

 -- Method on <channel>: <non-negative-fixnum> current-message-size THIS
     Accessor for the current message size: the number of bytes or
     characters sent so far or received so far.  The returned value
     represents the current message length, measured in bytes for binary
     channels and in characters for textual channels.

 -- Method on <channel>: <boolean> sending? THIS
     Return '#t' if THIS is in the course of sending a message;
     otherwise return '#f'.

 -- Method on <channel>: <boolean> receiving? THIS
     Return '#t' if THIS is in the course of receiving a message;
     otherwise return '#f'.

 -- Method on <channel>: <boolean> inactive? THIS
     Return '#t' if THIS is neither in the course of sending nor
     receiving a message; otherwise return '#f'.

 -- Method on <channel>: <boolean> delivery-timeout-expired? THIS
     Return '#t' if the delivery timeout has expired; otherwise return
     '#f'.  We can use this method to query this status even without
     attempting an input/output operation.


File: vicare-libs.info,  Node: net channels channels bichannel,  Next: net channels channels bochannel,  Prev: net channels channels channel,  Up: net channels channels

20.2.2 The '<binary-input-only-channel>' type
---------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <binary-input-only-channel>
 -- Parent Type: <channel>
     Expose the methods for all the binary input-only channels.

 -- Method on <binary-input-only-channel>: <binary-input-port>
          connect-in-port THIS
     The input or input/output binary port used to receive messages from
     a remote process.

 -- Method on <binary-input-only-channel>: <positive-fixnum>
          maximum-message-portion-size THIS
 -- Method on <binary-input-only-channel>: <void>
          maximum-message-portion-size THIS <positive-fixnum>
     Accessor and mutator for the maximum number of bytes read at each
     "receive message portion" operation.

 -- Method on <binary-input-only-channel>: <binary-terminators>
          message-terminators THIS
 -- Method on <binary-input-only-channel>: <void> message-terminators
          THIS {TERMINATORS <binary-terminators>}
     Accessor and mutator for the message termination markers.  The
     argument TERMINATORS must represent the possible message
     terminators for this channel; when a terminator is received *at the
     end* of a chunk of data, the message is considered terminated.

 -- Method on <binary-input-only-channel>: <void> recv-begin! THIS
     Configure the channel to receive a new message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <binary-input-only-channel>: recv-end!/rbl THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.

     Return two values:

       1. A '<positive-fixnum>' representing the total length of the
          message as number of bytes.

       2. A '(list-of <nebytevector>)' representing the received data as
          reverse buffer list (RBL), including the message terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <binary-input-only-channel>: <nebytevector> recv-end! THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.  If THIS is
     not in "message terminated" status: an assertion is raised.  Return
     a bytevector holding the full message, including the message
     terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <binary-input-only-channel>: <void> recv-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of receiving a message: an assertion is
     raised.

 -- Method on <binary-input-only-channel>: (or <eof> <would-block>
          <boolean>) recv-message-portion! THIS
     Receive a portion of message.  If THIS is not in the course of
     receiving a message: an assertion is raised.

        * Return '#f' if a portion of message was read, and it does not
          terminate with a message terminator; in this case we need to
          call this function again to receive further message portions.

        * Return '#t' if a portion of message was read, terminating with
          a configured message terminator.  The channel is put in
          "message terminated" status.

        * Return '#t' if the channel already read a terminator in a
          previous operation and is in "message terminated" status.

        * Return the EOF object if EOF is read from the input device.

        * Return the would-block object if a would-block object is read
          from the input device.

        * If the message delivery timeout is expired or expires while
          receiving data: raise an exception.

        * If the accumulated data exceeds the maximum message size:
          raise an exception.

 -- Method on <binary-input-only-channel>: (or <eof> <bytevector>)
          recv-full-message THIS
     Receive a full message.  When successful return a bytevector
     representing the full message.  If THIS is not inactive: an
     assertion is raised.  If the underlying device is closed before the
     message is completed: return the EOF object.


File: vicare-libs.info,  Node: net channels channels bochannel,  Next: net channels channels biochannel,  Prev: net channels channels bichannel,  Up: net channels channels

20.2.3 The '<binary-output-only-channel>' type
----------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <binary-output-only-channel>
 -- Parent Type: <channel>
     Expose the methods for all the binary output-only channels.

 -- Method on <binary-output-only-channel>: <binary-output-port>
          connect-ou-port THIS
     The output or input/output binary port used to send messages to a
     remote process.

 -- Method on <binary-output-only-channel>: <void> send-begin! THIS
     Configure a channel to start sending a message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <binary-output-only-channel>: <non-negative-fixnum>
          send-end! THIS
     Finish sending a message by flushing the underlying device and
     returning the total number of bytes sent.  If THIS is not in the
     course of sending a message: an assertion is raised.

     After this function is applied to a channel: the channel itself is
     configured as inactive; so it is available to start sending or
     receiving a message.

 -- Method on <binary-output-only-channel>: <void> flush THIS
     Flush to the destination the data buffered in the underlying
     device.  If THIS is not in the course of sending a message: an
     assertion is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <binary-output-only-channel>: <void> send-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  If some data is in the output buffer of the underlying
     device: it is left untouched.

 -- Method on <binary-output-only-channel>: <void> send-message-portion!
          THIS {PORTION <bytevector>}
     Send a portion of output message through the given channel.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  The argument PORTION must be a bytevector representing the
     message portion.  This function does not flush the underlying
     device.

     If the current message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <binary-output-port>: <non-negative-fixnum>
          send-full-message THIS {PORTION <bytevector>} ...
     Send a full message composed of the given PORTION arguments; return
     the total number of bytes sent.  If THIS is not inactive: an
     assertion is raised.

     If the message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.


File: vicare-libs.info,  Node: net channels channels biochannel,  Next: net channels channels tichannel,  Prev: net channels channels bochannel,  Up: net channels channels

20.2.4 The '<binary-input/output-channel>' type
-----------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <binary-input/output-channel>
 -- Parent Type: <channel>
     Expose the methods for all the binary input/output channels.  These
     channels implement all the methods of '<binary-input-only-channel>'
     and all the methods of '<binary-output-only-channel>'.


File: vicare-libs.info,  Node: net channels channels tichannel,  Next: net channels channels tochannel,  Prev: net channels channels biochannel,  Up: net channels channels

20.2.5 The '<textual-input-only-channel>' type
----------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <textual-input-only-channel>
 -- Parent Type: <channel>
     Expose the methods for all the textual input-only channels.

 -- Method on <textual-input-only-channel>: <textual-input-port>
          connect-in-port THIS
     The input or input/output textual port used to receive messages
     from a remote process.

 -- Method on <textual-input-only-channel>: <positive-fixnum>
          maximum-message-portion-size THIS
 -- Method on <textual-input-only-channel>: <void>
          maximum-message-portion-size THIS <positive-fixnum>
     Accessor and mutator for the maximum number of characters read at
     each "receive message portion" operation.

 -- Method on <textual-input-only-channel>: <textual-terminators>
          message-terminators THIS
 -- Method on <textual-input-only-channel>: <void> message-terminators
          THIS {TERMINATORS <textual-terminators>}
     Accessor and mutator for the message termination markers.  The
     argument TERMINATORS must represent the possible message
     terminators for this channel; when a terminator is received *at the
     end* of a chunk of data, the message is considered terminated.

 -- Method on <textual-input-only-channel>: <void> recv-begin! THIS
     Configure the channel to receive a new message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <textual-input-only-channel>: recv-end!/rbl THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.

     Return two values:

       1. A '<positive-fixnum>' representing the total length of the
          message as number of characters.

       2. A '(list-of <nestring>)' representing the received data as
          reverse buffer list (RBL), including the message terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <textual-input-only-channel>: <nestring> recv-end! THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.  If THIS is
     not in "message terminated" status: an assertion is raised.  Return
     a string holding the full message, including the message
     terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <textual-input-only-channel>: <void> recv-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of receiving a message: an assertion is
     raised.

 -- Method on <textual-input-only-channel>: (or <eof> <would-block>
          <boolean>) recv-message-portion! THIS
     Receive a portion of message.  If THIS is not in the course of
     receiving a message: an assertion is raised.

        * Return '#f' if a portion of message was read, and it does not
          terminate with a message terminator; in this case we need to
          call this function again to receive further message portions.

        * Return '#t' if a portion of message was read, terminating with
          a configured message terminator.  The channel is put in
          "message terminated" status.

        * Return '#t' if the channel already read a terminator in a
          previous operation and is in "message terminated" status.

        * Return the EOF object if EOF is read from the input device.

        * Return the would-block object if a would-block object is read
          from the input device.

        * If the message delivery timeout is expired or expires while
          receiving data: raise an exception.

        * If the accumulated data exceeds the maximum message size:
          raise an exception.

 -- Method on <textual-input-only-channel>: (or <eof> <string>)
          recv-full-message THIS
     Receive a full message.  When successful return a string
     representing the full message.  If THIS is not inactive: an
     assertion is raised.  If the underlying device is closed before the
     message is completed: return the EOF object.


File: vicare-libs.info,  Node: net channels channels tochannel,  Next: net channels channels tiochannel,  Prev: net channels channels tichannel,  Up: net channels channels

20.2.6 The '<textual-output-only-channel>' type
-----------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <textual-output-only-channel>
 -- Parent Type: <channel>
     Expose the methods for all the textual output-only channels.

 -- Method on <binary-output-only-channel>: <binary-output-port>
          connect-ou-port THIS
     The output or input/output binary port used to send messages to a
     remote process.

 -- Method on <textual-output-only-channel>: <void> send-begin! THIS
     Configure a channel to start sending a message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <textual-output-only-channel>: <non-negative-fixnum>
          send-end! THIS
     Finish sending a message by flushing the underlying device and
     returning the total number of characters sent.  If THIS is not in
     the course of sending a message: an assertion is raised.

     After this function is applied to a channel: the channel itself is
     configured as inactive; so it is available to start sending or
     receiving a message.

 -- Method on <textual-output-only-channel>: <void> flush THIS
     Flush to the destination the data buffered in the underlying
     device.  If THIS is not in the course of sending a message: an
     assertion is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <textual-output-only-channel>: <void> send-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  If some data is in the output buffer of the underlying
     device: it is left untouched.

 -- Method on <textual-output-only-channel>: <void>
          send-message-portion! THIS {PORTION <string>}
     Send a portion of output message through the given channel.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  The argument PORTION must be a string representing the
     message portion.  This function does not flush the underlying
     device.

     If the current message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <textual-output-port>: <non-negative-fixnum>
          send-full-message THIS {PORTION <string>} ...
     Send a full message composed of the given PORTION arguments; return
     the total number of characters sent.  If THIS is not inactive: an
     assertion is raised.

     If the message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.


File: vicare-libs.info,  Node: net channels channels tiochannel,  Prev: net channels channels tochannel,  Up: net channels channels

20.2.7 The '<textual-input/output-channel>' type
------------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Record Type: <textual-input/output-channel>
 -- Parent Type: <channel>
     Expose the methods for all the textual input/output channels.
     These channels implement all the methods of
     '<textual-input-only-channel>' and all the methods of
     '<textual-output-only-channel>'.


File: vicare-libs.info,  Node: net channels ifaces,  Next: net channels conditions,  Prev: net channels channels,  Up: net channels

20.3 Interface-type definitions
===============================

The concrete object-types implemented by '(vicare net channels)'
implement the interfaces documented in this section.

* Menu:

* net channels ifaces channel::     Interface '<<channel>>'.
* net channels ifaces bichannel::   Interface '<<binary-input-channel>>'.
* net channels ifaces bochannel::   Interface '<<binary-output-channel>>'.
* net channels ifaces tichannel::   Interface '<<textual-input-channel>>'.
* net channels ifaces tochannel::   Interface '<<textual-output-channel>>'.


File: vicare-libs.info,  Node: net channels ifaces channel,  Next: net channels ifaces bichannel,  Up: net channels ifaces

20.3.1 The '<<channel>>' interface
----------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Interface Type: <<channel>>
     Expose the basic configuration and inspection methods for all the
     channels.

 -- Method on <<channel>>: <epoch-time> expiration-time THIS
 -- Method on <<channel>>: <void> expiration-time THIS {TIME
          <epoch-time>}
     Accessor and mutator for the message transfer expiration time.  The
     argument TIME must be an instance of '<epoch-time>' (as defined by
     '(vicare)') representing the maximum time before which the message
     transfer must be completed.

     If the time limit is violated: an exception is raised at the first
     attempted operation.

 -- Method on <<channel>>: <positive-fixnum> maximum-message-size THIS
 -- Method on <<channel>>: <positive-fixnum> maximum-message-size THIS
          {LEN <positive-fixnum>}
     Accessor and mutator for the maximum message size.  The argument
     LEN must be the maximum allowed length for a whole message,
     measured in bytes for binary channels and in characters for textual
     channels.

 -- Method on <<channel>>: <non-negative-fixnum> current-message-size
          THIS
     Accessor for the current message size: the number of bytes or
     characters sent so far or received so far.  The returned value
     represents the current message length, measured in bytes for binary
     channels and in characters for textual channels.

 -- Method on <<channel>>: <boolean> sending? THIS
     Return '#t' if THIS is in the course of sending a message;
     otherwise return '#f'.

 -- Method on <<channel>>: <boolean> receiving? THIS
     Return '#t' if THIS is in the course of receiving a message;
     otherwise return '#f'.

 -- Method on <<channel>>: <boolean> inactive? THIS
     Return '#t' if THIS is neither in the course of sending nor
     receiving a message; otherwise return '#f'.

 -- Method on <<channel>>: <boolean> delivery-timeout-expired? THIS
     Return '#t' if the delivery timeout has expired; otherwise return
     '#f'.  We can use this method to query this status even without
     attempting an input/output operation.


File: vicare-libs.info,  Node: net channels ifaces bichannel,  Next: net channels ifaces bochannel,  Prev: net channels ifaces channel,  Up: net channels ifaces

20.3.2 The '<<binary-input-channel>>' interface
-----------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Interface Type: <<binary-input-channel>>
 -- Parent Type: <<channel>>
     Expose the methods for all the binary input channels.

 -- Method on <<binary-input-channel>>: <binary-terminators>
          message-terminators THIS
 -- Method on <<binary-input-channel>>: <void> message-terminators THIS
          {TERMINATORS <binary-terminators>}
     Accessor and mutator for the message termination markers.  The
     argument TERMINATORS must represent the possible message
     terminators for this channel; when a terminator is received *at the
     end* of a chunk of data, the message is considered terminated.

 -- Method on <<binary-input-channel>>: <void> recv-begin! THIS
     Configure the channel to receive a new message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <<binary-input-channel>>: recv-end!/rbl THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.

     Return two values:

       1. A '<positive-fixnum>' representing the total length of the
          message as number of bytes.

       2. A '(list-of <nebytevector>)' representing the received data as
          reverse buffer list (RBL), including the message terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <<binary-input-channel>>: <nebytevector> recv-end! THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.  If THIS is
     not in "message terminated" status: an assertion is raised.  Return
     a bytevector holding the full message, including the message
     terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <<binary-input-channel>>: <void> recv-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of receiving a message: an assertion is
     raised.

 -- Method on <<binary-input-channel>>: (or <eof> <would-block>
          <boolean>) recv-message-portion! THIS
     Receive a portion of message.  If THIS is not in the course of
     receiving a message: an assertion is raised.

        * Return '#f' if a portion of message was read, and it does not
          terminate with a message terminator; in this case we need to
          call this function again to receive further message portions.

        * Return '#t' if a portion of message was read, terminating with
          a configured message terminator.  The channel is put in
          "message terminated" status.

        * Return '#t' if the channel already read a terminator in a
          previous operation and is in "message terminated" status.

        * Return the EOF object if EOF is read from the input device.

        * Return the would-block object if a would-block object is read
          from the input device.

        * If the message delivery timeout is expired or expires while
          receiving data: raise an exception.

        * If the accumulated data exceeds the maximum message size:
          raise an exception.

 -- Method on <<binary-input-channel>>: (or <eof> <bytevector>)
          recv-full-message THIS
     Receive a full message.  When successful return a bytevector
     representing the full message.  If THIS is not inactive: an
     assertion is raised.  If the underlying device is closed before the
     message is completed: return the EOF object.


File: vicare-libs.info,  Node: net channels ifaces bochannel,  Next: net channels ifaces tichannel,  Prev: net channels ifaces bichannel,  Up: net channels ifaces

20.3.3 Interface '<<binary-output-channel>>'
--------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Interface Type: <<binary-output-channel>>
 -- Parent Type: <<channel>>
     Expose the methods for all the binary output channels.

 -- Method on <<binary-output-channel>>: <void> send-begin! THIS
     Configure a channel to start sending a message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <<binary-output-channel>>: <non-negative-fixnum> send-end!
          THIS
     Finish sending a message by flushing the underlying device and
     returning the total number of bytes sent.  If THIS is not in the
     course of sending a message: an assertion is raised.

     After this function is applied to a channel: the channel itself is
     configured as inactive; so it is available to start sending or
     receiving a message.

 -- Method on <<binary-output-channel>>: <void> flush THIS
     Flush to the destination the data buffered in the underlying
     device.  If THIS is not in the course of sending a message: an
     assertion is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <<binary-output-channel>>: <void> send-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  If some data is in the output buffer of the underlying
     device: it is left untouched.

 -- Method on <<binary-output-channel>>: <void> send-message-portion!
          THIS {PORTION <bytevector>}
     Send a portion of output message through the given channel.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  The argument PORTION must be a bytevector representing the
     message portion.  This function does not flush the underlying
     device.

     If the current message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <<binary-output-port>>: <non-negative-fixnum>
          send-full-message THIS {PORTION <bytevector>} ...
     Send a full message composed of the given PORTION arguments; return
     the total number of bytes sent.  If THIS is not inactive: an
     assertion is raised.

     If the message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.


File: vicare-libs.info,  Node: net channels ifaces tichannel,  Next: net channels ifaces tochannel,  Prev: net channels ifaces bochannel,  Up: net channels ifaces

20.3.4 Interface '<<textual-input-channel>>'
--------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Interface Type: <<textual-input-channel>>
 -- Parent Type: <<channel>>
     Expose the methods for all the textual input channels.

 -- Method on <<textual-input-channel>>: <textual-terminators>
          message-terminators THIS
 -- Method on <<textual-input-channel>>: <void> message-terminators THIS
          {TERMINATORS <textual-terminators>}
     Accessor and mutator for the message termination markers.  The
     argument TERMINATORS must represent the possible message
     terminators for this channel; when a terminator is received *at the
     end* of a chunk of data, the message is considered terminated.

 -- Method on <<textual-input-channel>>: <void> recv-begin! THIS
     Configure the channel to receive a new message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <<textual-input-channel>>: recv-end!/rbl THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.

     Return two values:

       1. A '<positive-fixnum>' representing the total length of the
          message as number of characters.

       2. A '(list-of <nestring>)' representing the received data as
          reverse buffer list (RBL), including the message terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <<textual-input-channel>>: <nestring> recv-end! THIS
     Terminate the action of receiving a message.  If THIS is not in the
     course of receiving a message: an assertion is raised.  If THIS is
     not in "message terminated" status: an assertion is raised.  Return
     a string holding the full message, including the message
     terminator.

     After this function is applied to a channel: the channel itself is
     reset to inactive; so it is available to start receiving another
     message or to send a message.

 -- Method on <<textual-input-channel>>: <void> recv-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of receiving a message: an assertion is
     raised.

 -- Method on <<textual-input-channel>>: (or <eof> <would-block>
          <boolean>) recv-message-portion! THIS
     Receive a portion of message.  If THIS is not in the course of
     receiving a message: an assertion is raised.

        * Return '#f' if a portion of message was read, and it does not
          terminate with a message terminator; in this case we need to
          call this function again to receive further message portions.

        * Return '#t' if a portion of message was read, terminating with
          a configured message terminator.  The channel is put in
          "message terminated" status.

        * Return '#t' if the channel already read a terminator in a
          previous operation and is in "message terminated" status.

        * Return the EOF object if EOF is read from the input device.

        * Return the would-block object if a would-block object is read
          from the input device.

        * If the message delivery timeout is expired or expires while
          receiving data: raise an exception.

        * If the accumulated data exceeds the maximum message size:
          raise an exception.

 -- Method on <<textual-input-channel>>: (or <eof> <string>)
          recv-full-message THIS
     Receive a full message.  When successful return a string
     representing the full message.  If THIS is not inactive: an
     assertion is raised.  If the underlying device is closed before the
     message is completed: return the EOF object.


File: vicare-libs.info,  Node: net channels ifaces tochannel,  Prev: net channels ifaces tichannel,  Up: net channels ifaces

20.3.5 Interface '<<textual-output-channel>>'
---------------------------------------------

The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Interface Type: <<textual-output-channel>>
 -- Parent Type: <<channel>>
     Expose the methods for all the textual output channels.

 -- Method on <<textual-output-channel>>: <void> send-begin! THIS
     Configure a channel to start sending a message.  If THIS is not
     inactive: an assertion is raised.

 -- Method on <<textual-output-channel>>: <non-negative-fixnum>
          send-end! THIS
     Finish sending a message by flushing the underlying device and
     returning the total number of characters sent.  If THIS is not in
     the course of sending a message: an assertion is raised.

     After this function is applied to a channel: the channel itself is
     configured as inactive; so it is available to start sending or
     receiving a message.

 -- Method on <<textual-output-channel>>: <void> flush THIS
     Flush to the destination the data buffered in the underlying
     device.  If THIS is not in the course of sending a message: an
     assertion is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <<textual-output-channel>>: <void> send-abort! THIS
     Abort the current operation and reset the channel to inactive.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  If some data is in the output buffer of the underlying
     device: it is left untouched.

 -- Method on <<textual-output-channel>>: <void> send-message-portion!
          THIS {PORTION <string>}
     Send a portion of output message through the given channel.  If
     THIS is not in the course of sending a message: an assertion is
     raised.  The argument PORTION must be a string representing the
     message portion.  This function does not flush the underlying
     device.

     If the current message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.

 -- Method on <<textual-output-port>>: <non-negative-fixnum>
          send-full-message THIS {PORTION <string>} ...
     Send a full message composed of the given PORTION arguments; return
     the total number of characters sent.  If THIS is not inactive: an
     assertion is raised.

     If the message size exceeds the maximum configured size: an
     exception is raised.  If the maximum delivery time is exceeded: an
     exception is raised.


File: vicare-libs.info,  Node: net channels conditions,  Prev: net channels ifaces,  Up: net channels

20.4 Condition object types
===========================

Whenever an error condition happens: the functions of the library
'(vicare net channels)' react by raising non-continuable exceptions
whose raised objects are compound conditions of the following types.

   The following syntactic bindings are exported by the library '(vicare
net channels)'.

 -- Condition Type: &channel
     Condition object containing an instance of '<channel>'; it is
     derived from '&condition'.  It has the following fields:

     'channel'
          The instance of '<channel>'.

 -- Condition Type: &delivery-timeout-expired
     Condition object used to tag exceptions as of type "message
     delivery timeout expired"; it is derived from '&error'.

 -- Condition Type: &maximum-message-size-exceeded
     Condition object used to tag exceptions as of type "maximum message
     size exceeded; it is derived from '&error'.


File: vicare-libs.info,  Node: comparators,  Next: iteration thunks,  Prev: net channels,  Up: Top

21 Comparators
**************

The library '(vicare containers comparators)' implements comparator
objects, which can be used for: type checking; comparison; hash value
computation.

   This library is actually the reference implementation of SRFI-114
adapted to Vicare.  The library exports the same syntactic bindings of
the library '(srfi :114 comparators)'.  *note SRFI-114 comparators: srfi
comparators, for the documentation.


File: vicare-libs.info,  Node: iteration thunks,  Next: lists,  Prev: comparators,  Up: Top

22 Iteration thunks
*******************

The library '(vicare containers iteration-thunks)' implements some
iteration methods over collections of objects.  An "iteration thunk" is
a thunk that returns the next object from an iteration over a compound
object; when no more objects are available, it returns the sentinel
object (*note The sentinel object: (vicare-scheme)iklib sentinel.).

* Menu:

* iteration thunks common::     Iterators for common objects.
* iteration thunks folding::    Folding over iterators.
* iteration thunks mapping::    Mapping iterators.
* iteration thunks searching::  Searching with iterators.
* iteration thunks filtering::  Filtering with iterators.


File: vicare-libs.info,  Node: iteration thunks common,  Next: iteration thunks folding,  Up: iteration thunks

22.1 Iterators for common objects
=================================

The following syntactic bindings are exported by the library '(vicare
containers iteration-thunks)'.

 -- Function: make-list-iteration-thunk ELL
     Return an iteration thunk for the objects in the proper list ELL.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-list-iteration-thunk '(0 1 2 3 4)))
          => (4 3 2 1 0)

 -- Function: make-spine-iteration-thunk ELL
     Return an iteration thunk for the pairs in the proper list ELL.

          (define (kons knil pair)
            (cons (car pair) knil))

          (iteration-thunk-fold kons
            '()
            (make-list-iteration-thunk '(0 1 2 3 4)))
          => (4 3 2 1 0)

 -- Function: make-vector-iteration-thunk VEC
     Return an iteration thunk for the objects in the vector VEC.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-vector-iteration-thunk '#(0 1 2 3 4)))
          => (4 3 2 1 0)

 -- Function: make-string-iteration-thunk STR
     Return an iteration thunk for the characters in the string STR.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-string-iteration-thunk "01234"))
          => (#\4 #\3 #\2 #\1 #\0)

 -- Function: make-bytevector-u8-iteration-thunk BV
     Return an iteration thunk for the octets in the bytevector BV.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-bytevector-u8-iteration-thunk '#vu8(0 1 2 3 4)))
          => (4 3 2 1 0)

 -- Function: make-bytevector-s8-iteration-thunk BV
     Return an iteration thunk for the bytes in the bytevector BV.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-bytevector-s8-iteration-thunk '#vs8(0 -1 -2 -3 -4)))
          => (-4 -3 -2 -1 0)


File: vicare-libs.info,  Node: iteration thunks folding,  Next: iteration thunks mapping,  Prev: iteration thunks common,  Up: iteration thunks

22.2 Folding over iterators
===========================

The following syntactic bindings are exported by the library '(vicare
containers iteration-thunks)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe: they *do not* validate their arguments.

 -- Function: iteration-thunk-fold KONS KNIL ITER0 ITER ...
 -- Function: $iteration-thunk-fold KONS KNIL ITER0 ITER ...
     Fold operation over the objects from the iteration thunks ITER.
     When multiple iteration thunks are given: the iteration stops when
     one of the thunks returns the sentinel.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-list-iteration-thunk '(0 1 2 3 4)))
          => (4 3 2 1 0)

          (receive-and-return (ell)
              '()
            (iteration-thunk-fold (lambda (knil item1 item2)
                                    (set-cons! ell (+ knil item1 item2))
                                    knil)
              0
              (make-list-iteration-thunk '(0  1  2  3  4))
              (make-list-iteration-thunk '(0 10 20 30 40))))
          => (44 33 22 11 0)


File: vicare-libs.info,  Node: iteration thunks mapping,  Next: iteration thunks searching,  Prev: iteration thunks folding,  Up: iteration thunks

22.3 Maping iterators
=====================

The following syntactic bindings are exported by the library '(vicare
containers iteration-thunks)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe: they *do not* validate their arguments.

 -- Function: iteration-thunk-map ACCEPTOR FUN ITER0 ITER ...
 -- Function: $iteration-thunk-map ACCEPTOR FUN ITER0 ITER ...
     Apply 'fun' to the items from the iteration thunks ITER.  When
     multiple iteration thunks are given: the iteration stops when one
     of the thunks returns the sentinel.  The function ACCEPTOR is
     applied to the the results of the applications.  The return value
     of the mapping form is the return value of the last application of
     ACCEPTOR; if the iteration thunk is empty: the return value is the
     sentinel.

          (let ((ell '()))
            (iteration-thunk-map (lambda (rv)
                                   (set-cons! ell rv)
                                   ell)
              -
              (make-list-iteration-thunk '(0 1 2 3 4))))
          => (-4 -3 -2 -1 0)

          (let ((ell '()))
            (iteration-thunk-map (lambda (rv)
                                   (set-cons! ell rv)
                                   ell)
              +
              (make-list-iteration-thunk '(0  1  2  3  4))
              (make-list-iteration-thunk '(0 10 20 30 40))))
          => (44 33 22 11 0)

 -- Function: iteration-thunk-for-each FUN ITER0 ITER ...
 -- Function: $iteration-thunk-for-each FUN ITER0 ITER ...
     Apply 'fun' to the items from the iteration thunks ITER and discard
     the return values.  When multiple iteration thunks are given: the
     iteration stops when one of the thunks returns the sentinel.

          (receive-and-return (ell)
              '()
            (iteration-thunk-for-each
                (lambda (item)
                  (set-cons! ell (- item)))
              (make-list-iteration-thunk '(0 1 2 3 4))))
          => (-4 -3 -2 -1 0)

          (receive-and-return (ell)
              '()
            (iteration-thunk-for-each
                (lambda (item1 item2)
                  (set-cons! ell (+ item1 item2)))
              (make-list-iteration-thunk '(0  1  2  3  4))
              (make-list-iteration-thunk '(0 10 20 30 40))))
          => (44 33 22 11 0)


File: vicare-libs.info,  Node: iteration thunks searching,  Next: iteration thunks filtering,  Prev: iteration thunks mapping,  Up: iteration thunks

22.4 Searching with iterators
=============================

The following syntactic bindings are exported by the library '(vicare
containers iteration-thunks)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe: they *do not* validate their arguments.

 -- Function: iteration-thunk-for-all FUN ITER0 ITER ...
 -- Function: $iteration-thunk-for-all FUN ITER0 ITER ...
     Apply 'fun' to the items from the iteration thunks ITER.  When
     multiple iteration thunks are given: the iteration stops when one
     of the thunks returns the sentinel.

     If all the applications of FUN return true: the return value is
     '#t'.  If an application of FUN returns '#f': the iteration stops
     immediately and the return value is '#f'.

          (iteration-thunk-for-all
              even?
            (make-list-iteration-thunk '(2 4 5 6 8)))
          => #f

          (iteration-thunk-for-all
              even?
            (make-list-iteration-thunk '(2 4 6 8)))
          => #t

          (iteration-thunk-for-all
              =
            (make-list-iteration-thunk '(+1 +2 +3 +4))
            (make-list-iteration-thunk '(+1 +2 +3 +4))
            (make-list-iteration-thunk '(+1 +2 +3 +4)))
          => #t

 -- Function: iteration-thunk-exists FUN ITER0 ITER ...
 -- Function: $iteration-thunk-exists FUN ITER0 ITER ...
     Apply 'fun' to the items from the iteration thunks ITER.  When
     multiple iteration thunks are given: the iteration stops when one
     of the thunks returns the sentinel.

     If all the applications of FUN return '#f': the return value is
     '#f'.  If an application of FUN returns a non-'#f' value: the
     iteration stops immediately and the returned value is returned.

          (iteration-thunk-exists
              even?
            (make-list-iteration-thunk '(1 3 5 7)))
          => #f

          (iteration-thunk-exists
              even?
            (make-list-iteration-thunk '(1 3 4 5 7)))
          => #t

          (iteration-thunk-exists
              =
            (make-list-iteration-thunk '(+1 +2 +3 +4))
            (make-list-iteration-thunk '(-1 -2 +3 -4))
            (make-list-iteration-thunk '( 0  0 +3  0)))a
          => #t

 -- Function: iteration-thunk-find FUN ITER
 -- Function: iteration-thunk-find FUN ITER NOT-FOUND-HANDLER
 -- Function: $iteration-thunk-find FUN ITER NOT-FOUND-HANDLER
     Apply 'fun' to the items from the iteration thunk ITER:

        * If all the applications of FUN return '#f' and
          NOT-FOUND-HANDLER is not given: the return value is '#f'.

        * If all the applications of FUN return '#f' and
          NOT-FOUND-HANDLER is given: NOT-FOUND-HANDLER must be a thunk
          and the return value is the return value of the thunk;
          NOT-FOUND-HANDLER is called in tail position.

        * If an application of FUN returns a non-'#f' value: the
          iteration stops immediately and the return value is the item
          from the iteration thunks.

          (iteration-thunk-find
              even?
            (make-list-iteration-thunk '(1 3 5 7)))
          => #f

          (iteration-thunk-find
              even?
            (make-list-iteration-thunk '(1 3 5 7))
            (lambda () 'not-found))
          => not-found

          (iteration-thunk-find
              even?
            (make-list-iteration-thunk '(1 3 4 5 7)))
          => 4


File: vicare-libs.info,  Node: iteration thunks filtering,  Prev: iteration thunks searching,  Up: iteration thunks

22.5 Filtering with iterators
=============================

The following syntactic bindings are exported by the library '(vicare
containers iteration-thunks)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe: they *do not* validate their arguments.

 -- Function: iteration-thunk-filter ACCEPTOR PRED ITER
 -- Function: $iteration-thunk-filter ACCEPTOR PRED ITER
     Iterate over the items from ITER, apply PRED to them, apply
     ACCEPTOR to the items for which PRED returns true.  Return
     unspecified values.

          (receive-and-return (ell)
              '()
            (iteration-thunk-filter
                (lambda (rv)
                  (set-cons! ell rv))
                even?
              (make-list-iteration-thunk '(1 3 5 7))))
          => ()

          (receive-and-return (ell)
              '()
            (iteration-thunk-filter
                (lambda (rv)
                  (set-cons! ell rv))
                even?
              (make-list-iteration-thunk '(1 3 4 5 7 8))))
          => (8 4)

 -- Function: iteration-thunk-partition MATCH-ACCEPTOR NO-MATCH-ACCEPTOR
          PRED ITER
 -- Function: $iteration-thunk-partition MATCH-ACCEPTOR
          NO-MATCH-ACCEPTOR PRED ITER
     Iterate over the items from ITER and apply PRED to them: if the
     return value is true, apply MATCH-ACCEPTOR to the item; if the
     return value is '#f', apply NO-MATCH-ACCEPTOR to the item.  Return
     unspecified values.

          (receive-and-return (match-ell no-match-ell)
              (values '() '())
            (iteration-thunk-partition
                (lambda (match-rv)
                  (set-cons! match-ell match-rv))
                (lambda (no-match-rv)
                  (set-cons! no-match-ell no-match-rv))
                even?
              (make-list-iteration-thunk '(1 3 5 7))))
          => () (7 5 3 1)

          (receive-and-return (match-ell no-match-ell)
              (values '() '())
            (iteration-thunk-partition
                (lambda (match-rv)
                  (set-cons! match-ell match-rv))
                (lambda (no-match-rv)
                  (set-cons! no-match-ell no-match-rv))
                even?
              (make-list-iteration-thunk '(1 3 4 5 7 8))))
          => (8 4) (7 5 3 1)


File: vicare-libs.info,  Node: lists,  Next: vectors,  Prev: iteration thunks,  Up: Top

23 List library
***************

The libraries '(vicare containers lists)' and '(vicare containers lists
stx)' implement a collection of functions and macros to manipulate
lists; additionally, '(vicare containers lists low)' implements a
collection of low level utilities.  These libraries have two purposes:
to provide a rich set of functions and macros and to be a source code
repository from which code can be taken and specialised.  For the last
purpose, the libraries export macros that may make little sense in most
scenarios (beside the fact that they are always inlined).

     *NOTE* The libraries in the hierarchy '(vicare containers lists
     ---)' and this section of documentation are derived from the SRFI-1
     document and reference implementation by Olin Shivers, but they are
     *not* compatible with it.  Read carefully this documentation!

   To avoid identifier collisions: it is suggested to import these
libraries with the prefix 'list.', as in:

     (import (vicare)
       (prefix (vicare containers lists) list.))

* Menu:

* lists intro::                 Introduction.
* lists conventions::           Conventions.
* lists cons::                  Constructors.
* lists pred::                  Predicates.
* lists compar::                Comparison.
* lists select::                Selectors.
* lists misc::                  Length, append, concatenate,
                                reverse, zip and count.
* lists fold::                  Fold, unfold and map.
* lists filter::                Filtering and partitioning.
* lists search::                Searching.
* lists delete::                Deletion.
* lists sorted::                Utilities for sorted lists.
* lists alist::                 Association lists.
* lists circ::                  Circular lists.
* lists set::                   Set operations on lists.
* lists low::                   Low level utilities.


File: vicare-libs.info,  Node: lists intro,  Next: lists conventions,  Up: lists

23.1 Introduction
=================

Scheme does not properly have a list type, just as the C language does
not have a string type.  Rather, Scheme has a binary-tuple type, from
which one can build binary trees.  There is an interpretation of Scheme
values that allows one to treat these trees as lists.  Further
complications ensue from the fact that Scheme allows side-effects to
these tuples, raising the possibility of lists of unbounded length, and
trees of unbounded depth (that is, circular data structures).

   What follows is a classification of concrete values with respect to
"list" as an abstract concept.

Null value
..........

It is a special value which can be identified with the predicate
'null?'.  Null is meant to represent empty lists and to be the
terminator for proper lists.

   'length' applied to null returns zero.  In light of what follows, it
makes sense to consider null as a list of length zero for all the list
classes: proper, circular, dotted, generalised.

Proper lists
............

A finite, null-terminated list; more precisely a proper list is defined
as: A pair whose cdr is a proper list or null.  The opposite of proper
is "improper"; everything that is not null or a proper list, is an
improper list.

     (a b c)
     (32)

   We can build a proper list in a single function call with 'list', or
we can do it in steps using 'cons' and 'cons*'; we can detect if a list
is proper with 'list?'.

Circular list
.............

An infinite, unterminated list; a circular list is a value such that
'cdr' applied any number of times always returns a pair.  The opposite
of circular is "finite".

   We can build a list having a circular tail as follows:

     (define end  (cons  1 '()))
     (define tail (cons* 3 2 end))
     (define ell  (cons* 5 4 tail))
     (set-cdr! end tail)

the list structure bound to 'ell' looks like this:

                                cdr
                       ----------------
                      |                |
          cdr    cdr  v cdr    cdr     |
        O----->O----->O----->O----->O--
        |      |      |      |      |
     car|   car|   car|   car|   car|
        v      v      v      v      v
        5      4      3      2      1

so that the following happens:

     (car ell)            => 5
     (cadr ell)           => 4
     (caddr ell)          => 3
     (cadddr ell)         => 2
     (cadddr (cdr ell))   => 1
     (cdddr (cddr ell))   => tail
     (cadddr (cddr ell))  => 3
     (cadddr (cdddr ell)) => 2

it is impossible to build a circular list without mutating a pair.
Notice that the following is *not* a circular list:

                                car
                --------------------
               |                    |
          cdr  v cdr    cdr    cdr  | cdr
        O----->O----->O----->O----->O----->()
        |      |      |      |
     car|   car|   car|   car|
        v      v      v      v
        5      4      3      2

it is a proper list in which the car of the last pair references one of
the previous pairs.

   We can build a circular list, a ring, with 'circular-list' and we can
detect if a list is a ring or has a circular tail with 'circular-list?'.

Dotted list
...........

A finite, non-nil terminated list, such as:

     (a b c . d)
     (x . y)

a dotted list is a value for which there exists an integer n > 0, such
that 'cdr' applied n times yields neither a pair nor null.  This means
that, for a dotted list, either 'null?' or 'pair?' return '#t'.

   Users of the '(vicare containers lists ---)' libraries should note
that dotted lists are not commonly used, and are considered by many
Scheme programmers to be an ugly artifact of Scheme's lack of a true
list type.  However, dotted lists do play a noticeable role in the
syntax of Scheme, in the "rest" parameters used by n-ary lambdas:

     (lambda (x y . rest)
       ---)

   Dotted lists are not fully supported by the list libraries; most
procedures are defined only on proper lists.  The procedures that will
also handle circular or dotted lists are specifically marked.  While
this design decision restricts the domain of possible arguments one can
pass to these procedures, it has the benefit of allowing the procedures
to catch the error cases where programmers inadvertently pass scalar
values to a list procedure by accident (for example, by switching the
arguments to a procedure call).

Improper list
.............

A finite, non-nil terminated list, such as:

     (a b c . d)
     (x . y)
     42
     george

a improper list is a value for which there exists an integer n >= 0,
such that 'cdr' applied n times yields neither a pair nor null.  This
includes non-pair, non-null values (symbols, numbers, etc.), which are
considered to be improper lists of length 0.  Dotted lists are improper
lists.


File: vicare-libs.info,  Node: lists conventions,  Next: lists cons,  Prev: lists intro,  Up: lists

23.2 Conventions
================

All the functions are exported by the '(vicare containers lists)'
library, while all the macros are exported by '(vicare containers lists
stx)'.  Each macro has a corresponding function version, but some
functions were not translated to macros.  Macro names always end with
the suffix '/stx'.

   It is an error to pass a circular or dotted list to a procedure not
defined to accept such an argument; it is an error to pass a proper or
dotted list to a procedure defined for circular lists.

   All the functions and macros whose main name ends with '!', are
allowed to alter their arguments.

   The documentation of this library obeys the following conventions for
procedure formals:

ELL
     A proper (finite, nil-terminated) list.

CIRC
     A proper or circular list.

DOTTED
     A dotted list.

PAIR
     A pair.

N
I
     A non-negative exact integer object.

PROC
     A procedure.

PRED
     A procedure whose return value is treated as a boolean.

ITEM=
     A boolean procedure taking two arguments.

FILL
     Can be any value; it is used to indicate values used to fill a
     compound data structure.

OBJ
     Any value, including dotted lists.


File: vicare-libs.info,  Node: lists cons,  Next: lists pred,  Prev: lists conventions,  Up: lists

23.3 Constructors
=================

 -- Function: xcons OBJ1 OBJ2
     The name stands for "eXchanged CONS", it is like 'cons' but
     reverses the arguments.  Of utility only as a value to be
     conveniently passed to higher-order procedures.

          (cons 1 2)  => (1 . 2)
          (xcons 1 2) => (2 . 1)

 -- Function: make-list N
 -- Function: make-list N FILL
 -- Syntax: make-list/stx N
 -- Syntax: make-list/stx N FILL
     Return an N-element list, whose elements are all the value FILL.
     If FILL is not given, the elements of the list may be arbitrary
     values.

          (make-list 4 'c)
          => (c c c c)

          (make-list 0)
          => ()

 -- Function: list-copy FELL
 -- Syntax: list-copy/stx FELL
     Copy the spine of the argument.

 -- Function: tree-copy FELL
 -- Syntax: tree-copy/stx FELL
     Copy the whole tree of FELL, not only the spine (which is what
     'list-copy' does).

 -- Function: list-tabulate N INIT-PROC
 -- Function: list-tabulate/reverse N INIT-PROC
 -- Syntax: list-tabulate/stx N INIT-PROC
 -- Syntax: list-tabulate/reverse/stx N INIT-PROC
     Return an N-element list.  Element i of the list, where 0 <= i < n,
     is produced by '(init-proc i)'.

     The basic variants build the list from element 0 to element n-1.
     The '/reverse' variants build the lists in reversed order, with
     element n-1 created first.  The '/reverse' variants may be a little
     faster, especially for long lists.

          (list-tabulate 4 values)
          => (0 1 2 3)

 -- Function: iota COUNT
 -- Function: iota COUNT START
 -- Function: iota COUNT START STEP
 -- Syntax: iota/stx COUNT
 -- Syntax: iota/stx COUNT START
 -- Syntax: iota/stx COUNT START STEP
     Return a list containing the elements:

          (start start+step ... start+(count-1)*step)

     The START and STEP parameters default to '0' and '1', respectively.
     COUNT must be a non-negative number.  The resulting list is built
     in reverse, starting from the last element.

          (iota 5)
          => (0 1 2 3 4)

          (iota 5 0 -0.1)
          => (0 -0.1 -0.2 -0.3 -0.4)


File: vicare-libs.info,  Node: lists pred,  Next: lists compar,  Prev: lists cons,  Up: lists

23.4 Predicates
===============

 -- Function: not-pair? OBJ
     Defined as:

          (lambda (x) (not (pair? x)))

     provided as a procedure as it can be useful as the termination
     condition for list-processing procedures that wish to handle all
     finite lists, both proper and dotted.

 -- Function: circular-list? OBJ
 -- Function: circular-list?/or-null OBJ
     Return '#t' if OBJ is a circular list.  The '/or-null' variant
     returns '#t' also if OBJ is null.

 -- Function: dotted-list? OBJ
 -- Function: dotted-list?/or-null OBJ
     Return '#t' if OBJ is a dotted list.  The '/or-null' variant
     returns '#t' also if OBJ is null.

 -- Function: and-null? ELL ...
 -- Syntax: and-null?/stx ELL ...
     Return '#t' if all the ELL are null or no arguments are given.

 -- Function: or-null? ELL ...
 -- Syntax: or-null?/stx ELL ...
     Return '#t' if at least one of the ELL is null.  Return '#f' if no
     arguments are given.

 -- Function: and/or-null? ELL ...
 -- Syntax: and/or-null?/stx ELL ...
     Return two values being the return values of 'and-null?' and
     'or-null?' applied to the ELL arguments.


File: vicare-libs.info,  Node: lists compar,  Next: lists select,  Prev: lists pred,  Up: lists

23.5 Comparison
===============

 -- Function: list=? ITEM= ELL0 ...
     Determines list equality, given an element-equality procedure
     ITEM=.  Proper list ELL1 equals proper list ELL2 if:

       1. They are of the same length.

       2. Their corresponding elements are equal, according to ITEM=.

     If there are no list arguments, or only one list argument: The
     return value is '#t'.  If there are two or more list arguments they
     are compared in couples: First ELL0 is compared to ELL1, then ELL1
     is compared to ELL2, etc.  The iteration over list arguments stops
     if two list arguments are found different.

     ITEM= is applied to elements from two list arguments taken with the
     same order; the first from ELL1, the second from ELL2, etc.  ITEM=
     must be consistent with 'eq?':

          (eq? x y) => (elm=? x y)

     this implies that two lists which are 'eq?' are always 'list=?', as
     well.

     Examples:

          (list=? eq?)
          => #t

          (list=? eq? '(a))
          => #t

          (list=? = '(1 2 3 4)
                    '(1 2 3 4))
          => #t

          (list=? = '(1 2 3 4)
                    '(1 9 3 4))
          => #f

          (list=? = '(1 2 3 4)
                    '(1 2 3 4)
                    '(1 2 3 4))
          => #t

          (list=? = '(1 2 3 4)
                    '(1 2 3 4 5)
                    '(1 2 3 4))
          => #f

          (list=? = '())
          => #t

          (list=? = '() '())
          => #t

          (list=? = '() '() '())
          => #t


File: vicare-libs.info,  Node: lists select,  Next: lists misc,  Prev: lists compar,  Up: lists

23.6 Selectors
==============

 -- Function: first PAIR
 -- Function: second PAIR
 -- Function: third PAIR
 -- Function: fourth PAIR
 -- Function: fifth PAIR
 -- Function: sixth PAIR
 -- Function: seventh PAIR
 -- Function: eighth PAIR
 -- Function: ninth PAIR
 -- Function: tenth PAIR
 -- Syntax: fifth/stx PAIR
 -- Syntax: sixth/stx PAIR
 -- Syntax: seventh/stx PAIR
 -- Syntax: eighth/stx PAIR
 -- Syntax: ninth/stx PAIR
 -- Syntax: tenth/stx PAIR
     Synonyms for 'car', 'cadr', 'caddr', ...

          (third '(a b c d e))
          => c

 -- Function: car+cdr PAIR
     The fundamental pair deconstructor:

          (lambda (p)
            (values (car p) (cdr p)))

 -- Function: take-left DOTTED I
 -- Function: drop-left DOTTED I
 -- Syntax: take-left/stx DOTTED I
 -- Syntax: drop-left/stx DOTTED I
     'take-left' returns the first I elements of list DOTTED.
     'drop-left' returns all but the first I elements of list DOTTED.

          (take-left '(a b c d e) 2)
          => (a b)

          (drop-left '(a b c d e) 2)
          => (c d e)

     DOTTED may be any value: a proper, circular, or dotted list:

          (take-left '(1 2 3 . d) 2)
          => (1 2)

          (drop-left '(1 2 3 . d) 2)
          => (3 . d)

          (take-left '(1 2 3 . d) 3)
          => (1 2 3)

          (drop-left '(1 2 3 . d) 3)
          => d

     For a legal I, 'take-left' and 'drop-left' partition the list in a
     manner which can be inverted with append:

          (append (take-left x i) (drop-left x i)) = x

     'drop-left' is exactly equivalent to performing I 'cdr' operations
     on DOTTED; the returned value shares a common tail with DOTTED.

     If the argument is a list of non-zero length, 'take-left' is
     guaranteed to return a freshly-allocated list, even in the case
     where the entire list is taken: '(take-left dotted (length+
     dotted))'.

 -- Function: take-right DOTTED I
 -- Function: drop-right DOTTED I
 -- Syntax: take-right/stx DOTTED I
 -- Syntax: drop-right/stx DOTTED I
     'take-right' returns the last I elements of DOTTED.  'drop-right'
     returns all but the last I elements of DOTTED.

          (take-right '(a b c d e) 2)
          => (d e)

          (drop-right '(a b c d e) 2)
          => (a b c)

     The returned list may share a common tail with the argument list.

     DOTTED may be any finite list, either proper or dotted:

          (take-right '(1 2 3 . d) 2)
          => (2 3 . d)

          (drop-right '(1 2 3 . d) 2)
          => (1)

          (take-right '(1 2 3 . d) 0)
          => d

          (drop-right '(1 2 3 . d) 0)
          => (1 2 3)

     For a legal I, 'take-right' and 'drop-right' partition the list in
     a manner which can be inverted with append:

          (append (drop-right flist i) (take-right flist i)) = flist

     The return value of 'take-right' is guaranteed to share a common
     tail with DOTTED.

     If the argument is a list of non-zero length, 'drop-right' is
     guaranteed to return a freshly-allocated list, even in the case
     where nothing is dropped, e.g.  '(drop-right dotted 0)'.

 -- Function: take-left! DOTTED I
 -- Function: drop-right! DOTTED I
 -- Syntax: take-left!/stx DOTTED I
 -- Syntax: drop-right!/stx DOTTED I
     'take!' and 'drop-right!' are like 'take' and 'drop-right', but
     they are allowed to alter the argument list to produce the result.

     An error is raised if the length of the list is less than I.

 -- Function: split-at DOTTED I
 -- Function: split-at! DOTTED I
 -- Syntax: split-at/stx DOTTED I
 -- Syntax: split-at!/stx DOTTED I
     'split-at' splits the list DOTTED at index I, returning a list of
     the first I elements, and the remaining tail.  It is equivalent to:

          (values (take-left x i) (drop-left x i))

     'split-at!' is allowed to alter the argument list to produce the
     result.

          (split-at '(a b c d e f g h) 3)
          => (a b c) (d e f g h)

 -- Function: last PAIR
 -- Function: last-pair PAIR
 -- Syntax: last/stx PAIR
 -- Syntax: last-pair/stx PAIR
     'last' returns the last element of the non-empty, finite list PAIR.
     'last-pair' returns the last pair in the non-empty, finite list
     PAIR.

          (last '(a b c)) => c
          (last-pair '(a b c)) => (c)


File: vicare-libs.info,  Node: lists misc,  Next: lists fold,  Prev: lists select,  Up: lists

23.7 Length, append, concatenate, reverse, zip and count
========================================================

 -- Function: length+ CIRC
     Return the length of the argument, or '#f' if CIRC is a circular
     list.  The length of a proper list is a non-negative integer n such
     that 'cdr' applied n times to the list produces the empty list.

 -- Function: append! ELL ...
     Return a list consisting of the elements of ELL followed by the
     elements of the other list arguments; it is allowed to alter cons
     cells in the argument lists to construct the result list.  The last
     argument is never altered; the result list shares structure with
     this parameter.

          (append! '(x) '(y))        =>  (x y)
          (append! '(a) '(b c d))    =>  (a b c d)
          (append! '(a (b)) '((c)))  =>  (a (b) (c))
          (append! '(a b) '(c . d))  =>  (a b c . d)
          (append! '() 'a)           =>  a
          (append! '(x y))           =>  (x y)
          (append!)                  =>  ()

     Notice that 'append' is implemented by '(rnrs base (6))'.  *note
     Pairs and lists: (vicare-scheme)baselib lists.

 -- Function: concatenate LIST-OF-LISTS
 -- Function: concatenate! LIST-OF-LISTS
 -- Syntax: concatenate/stx LIST-OF-LISTS
 -- Syntax: concatenate!/stx LIST-OF-LISTS
     These functions append the elements of their argument together;
     that is, 'concatenate' returns:

          (apply append list-of-lists)

     'concatenate!' is allowed to alter the arguments to build the
     result.  As with 'append' and 'append!', the last element of the
     input list may be any value at all.

 -- Function: reverse! LIST
     Return a newly allocated list consisting of the elements of LIST in
     reverse order; it is allowed to alter the argument's cons cells to
     produce the reversed list.

          (reverse! '(a b c))              =>  (c b a)
          (reverse! '(a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)

     Notice that 'reverse' is implemented by '(rnrs base (6))'.  *note
     Pairs and lists: (vicare-scheme)baselib lists.

 -- Function: append-reverse REV-HEAD TAIL
 -- Function: append-reverse! REV-HEAD TAIL
 -- Syntax: append-reverse/stx REV-HEAD TAIL
 -- Syntax: append-reverse!/stx REV-HEAD TAIL
     'append-reverse' returns:

          (append (reverse rev-head) tail)

     It is provided because it is a common operation; a common
     list-processing style calls for this exact operation to transfer
     values accumulated in reverse order onto the front of another list,
     and because the implementation is significantly more efficient than
     the simple composition it replaces.

          But note that this pattern of iterative computation followed
          by a 'reverse' can frequently be rewritten as a recursion,
          dispensing with the 'reverse' and 'append-reverse' steps, and
          shifting temporary, intermediate storage from the heap to the
          stack, which is typically a win for reasons of cache locality
          and eager storage reclamation.

     'append-reverse!' is allowed to alter REV-HEAD's cons cells to
     construct the result.

 -- Function: zip LIST1 LIST ...
 -- Function: zip* CIRC1 CIRC ...
 -- Syntax: zip/stx ?LIST1 ?LIST ...
 -- Syntax: zip*/stx ?CIRC1 ?CIRC ...
     The function 'zip' is defined as:

          (lambda ells (apply map list ells))

     while 'zip*' is defined as:

          (lambda ells (apply map* list ells))

     If 'zip*' is passed N lists, it returns a list as long as the
     shortest of these lists, each element of which is an N-element list
     comprised of the corresponding elements from the parameter lists.

          (zip* '(one two three)
                '(1 2 3)
                '(odd even odd even odd even odd even))
          => ((one 1 odd) (two 2 even) (three 3 odd))

          (zip* '(1 2 3))
          => ((1) (2) (3))

     When applying 'zip*', at least one of the argument lists must be
     finite:

          (zip* '(3 1 4 1)
                (circular-list #f #t))
          => ((3 #f)
              (1 #t)
              (4 #f)
              (1 #t))

 -- Function: unzip1 ELL
 -- Function: unzip2 ELL
 -- Function: unzip3 ELL
 -- Function: unzip4 ELL
 -- Function: unzip5 ELL
 -- Syntax: unzip1/stx ELL
 -- Syntax: unzip2/stx ELL
 -- Syntax: unzip3/stx ELL
 -- Syntax: unzip4/stx ELL
 -- Syntax: unzip5/stx ELL
     'unzip1' takes a list of lists, where every list must contain at
     least one element, and returns a list containing the initial
     element of each such list.  That is, it returns '(map car lists)'.

     'unzip2' takes a list of lists, where every list must contain at
     least two elements, and returns two values: a list of the first
     elements, and a list of the second elements.

     'unzip3' does the same for the first three elements of the lists,
     and so forth.

          (unzip2 '((1 one) (2 two) (3 three)))
          => (1 2 3)
             (one two three)

 -- Function: count PRED CIRC ...
 -- Syntax: count/stx PRED CIRC ...
     PRED is a procedure taking as many arguments as there are lists and
     returning a single value.  It is applied element-wise to the
     elements of the lists, and a count is tallied of the number of
     elements that produce a true value.  This count is returned.

     'count' is "iterative" in that it is guaranteed to apply PRED to
     the list elements in a left-to-right order.  The counting stops
     when the shortest list expires.

          (count even? '(3 1 4 1 5 9 2 5 6))
          => 3

          (count < '(1 2 4 8) '(2 4 6 8 10 12 14 16))
          => 3

     At least one of the argument lists must be finite:

          (count < '(3 1 4 1) (circular-list 1 10))
          => 2


File: vicare-libs.info,  Node: lists fold,  Next: lists filter,  Prev: lists misc,  Up: lists

23.8 Fold, unfold and map
=========================

The "left-folding" operator is the fundamental list iterator, the
"right-folding" operator is the fundamental list recursion operator.

* Menu:

* lists fold examples::         Folding usage examples.
* lists fold rnrs::             Folding with R6RS style.
* lists fold traditional::      Folding with traditional style.
* lists fold derived::          Derived folding.
* lists fold pair::             Folding pairs.
* lists fold reduce::           Reducing.
* lists fold unfold::           Unfolding.
* lists fold map::              Mapping.
* lists fold foreach::          Producing side effects.


File: vicare-libs.info,  Node: lists fold examples,  Next: lists fold rnrs,  Up: lists fold

23.8.1 Folding usage examples
-----------------------------

In the single list argument case, for a list of 4 elements, the return
value of a left-folding with R6RS style, is computed as with:

     (fold-left kons knil ell) ==
       (kons (kons (kons (kons knil
                               (list-ref ell 0))
                         (list-ref ell 1))
                   (list-ref ell 2))
             (list-ref ell 3))

while with the "traditional" style:

     (fold kons knil ell) ==
       (kons (list-ref ell 3)
             (kons (list-ref ell 2)
                   (kons (list-ref ell 1)
                         (kons (list-ref ell 0)
                               knil))))

the return value of a right-folding with both R6RS style and
"traditional" style, is computed as with:

     (fold-right kons knil ell) ==
          (fold* kons knil ell) ==
       (kons (list-ref ell 0)
             (kons (list-ref ell 1)
                   (kons (list-ref ell 2)
                         (kons (list-ref ell 3)
                               knil))))

   In the multiple list arguments case, for three lists of 4 elements,
the return value of a left-folding with R6RS style, is computed as with:

     (fold-left kons knil ell0 ell1 ell2) ==
       (kons (kons (kons (kons knil
                               (list-ref ell0 0)
                               (list-ref ell1 0)
                               (list-ref ell2 0))
                         (list-ref ell0 1)
                         (list-ref ell1 1)
                         (list-ref ell2 1))
                   (list-ref ell0 2)
                   (list-ref ell1 2)
                   (list-ref ell2 2))
             (list-ref ell0 3)
             (list-ref ell1 3)
             (list-ref ell2 3))

while with the "traditional" style:

     (fold kons knil ell0 ell1 ell2) ==
       (kons (list-ref ell0 3)
             (list-ref ell1 3)
             (list-ref ell2 3)
             (kons (list-ref ell0 2)
                   (list-ref ell1 2)
                   (list-ref ell2 2)
                   (kons (list-ref ell0 1)
                         (list-ref ell1 1)
                         (list-ref ell2 1)
                         (kons (list-ref ell0 0)
                               (list-ref ell1 0)
                               (list-ref ell2 0)
                               knil))))

the return value of a right-folding with both R6RS style and
"traditional" style, is computed as with:

     (fold-right kons knil ell0 ell1 ell2) ==
          (fold* kons knil ell0 ell1 ell2) ==
       (kons (list-ref ell0 0)
             (list-ref ell1 0)
             (list-ref ell2 0)
             (kons (list-ref ell0 1)
                   (list-ref ell1 1)
                   (list-ref ell2 1)
                   (kons (list-ref ell0 2)
                         (list-ref ell1 2)
                         (list-ref ell2 2)
                         (kons (list-ref ell0 3)
                               (list-ref ell1 3)
                               (list-ref ell2 3)
                               knil))))

   Left-folding, usage examples for 'fold' in the single list argument
case:

     ;; add the elements
     (fold + 0 '(1 2 3))             => 6

     ;; reverse a list
     (fold cons '() '(1 2 3))        => (3 2 1)

     ;; append in reverse order
     (fold cons '(4 5 6) '(3 2 1))   => (1 2 3 4 5 6)

     ;; how many symbols?
     (fold (lambda (x count)
             (if (symbol? x)
                 (+ count 1)
               count))
           0
           '(a 1 b 2 c 3))           => 3

   Right-folding usage examples for 'fold*' in the single list argument
case:

     ;; copy the list
     (fold* cons '() '(1 2 3))       => (1 2 3)

     ;; add elements
     (fold* + 0 numbers)             => 45

     ;; prepend elements
     (fold* cons '(4 5 6) '(1 2 3))  => (1 2 3 4 5 6)

     ;; filter the even numbers
     (fold* (lambda (x l)
              (if (even? x)
                  (cons x l)
                l))
            '()
            '(0 1 2 3 4 5 6 7 8 9))
     => (0 2 4 6 8)

   Usage examples for 'fold' and 'fold*' in the multiple list argument
case:

     (fold (lambda (a b c knil)
             (cons (list a b c) knil))
           '()
           '(1 2 3)
           '(10 20 30)
           '(100 200 300))
     => '((3 30 300)
          (2 20 200)
          (1 10 100))

     (fold* (lambda (a b c knil)
              (cons (list a b c)
                     knil))
            '()
            '(1 2 3)
            '(10 20 30)
            '(100 200 300))
     => ((1 10 100)
         (2 20 200)
         (3 30 300))


File: vicare-libs.info,  Node: lists fold rnrs,  Next: lists fold traditional,  Prev: lists fold examples,  Up: lists fold

23.8.2 Folding with R6RS style
------------------------------

Exactly as with the 'fold-left' and 'fold-right' functions defined by
R6RS:

   * With left-folding functions and syntaxes, the *first* argument to
     the first call to COMBINE is KNIL, then it is the return value of
     the previous calls to COMBINE.

   * With right-folding functions and syntaxes, the *last* argument to
     to the first evaluated call to COMBINE is KNIL, then it is the
     return value of the previous calls to COMBINE.

 -- Syntax: fold-left/stx COMBINE KNIL CIRC1 CIRC2 ...
 -- Syntax: fold-right/stx COMBINE KNIL CIRC1 CIRC2 ...
     Like 'fold-left' and 'fold-right', defined by R6RS, but implemented
     as syntaxes.  These syntaxes exist only for completeness.

 -- Function: fold-left* COMBINE KNIL CIRC1 CIRC2 ...
 -- Function: fold-right* COMBINE KNIL CIRC1 CIRC2 ...
 -- Syntax: fold-left*/stx COMBINE KNIL CIRC1 CIRC2 ...
 -- Syntax: fold-right*/stx COMBINE KNIL CIRC1 CIRC2 ...
     Like 'fold-left' and 'fold-right', defined by R6RS, but accept
     lists of different length and stop at the end of the shortest list.
     At least one of the list arguments must be finite.  The syntaxes
     may be a little faster than the functions when multiple CIRC
     arguments are involved.


File: vicare-libs.info,  Node: lists fold traditional,  Next: lists fold derived,  Prev: lists fold rnrs,  Up: lists fold

23.8.3 Folding with traditional style
-------------------------------------

The functions 'fold' and 'fold*' are similar to 'fold-left*' and
'fold-right*' but KNIL is always the *last* argument of the calls to
KONS.

 -- Function: fold KONS KNIL CIRC1 CIRC2 ...
 -- Syntax: fold/stx KONS KNIL CIRC1 CIRC2 ...
     Left fold the function KONS over the elements of the list
     arguments.  Accept lists of different length and stop at the end of
     the shortest list.  At least one of the list arguments must be
     finite.  The syntax may be a little faster than the function when
     multiple CIRC arguments are involved.

 -- Function: fold* KONS KNIL CIRC1 CIRC2 ...
 -- Syntax: fold*/stx KONS KNIL CIRC1 CIRC2 ...
     Right fold the function KONS over the elements of the list
     arguments.  Accept lists of different length and stop at the end of
     the shortest list.  At least one of the list arguments must be
     finite.  The syntax may be a little faster than the function when
     multiple CIRC arguments are involved.


File: vicare-libs.info,  Node: lists fold derived,  Next: lists fold pair,  Prev: lists fold traditional,  Up: lists fold

23.8.4 Derived folding
----------------------

 -- Function: and-fold-left* COMBINE KNIL CIRC1 CIRC2 ...
 -- Function: and-fold-right* COMBINE KNIL CIRC1 CIRC2 ...
 -- Syntax: and-fold-left*/stx COMBINE KNIL CIRC1 CIRC2 ...
 -- Syntax: and-fold-right*/stx COMBINE KNIL CIRC1 CIRC2 ...
     Like 'fold-left*' and 'fold-right*', but stop the folding if the
     value returned by COMBINE is '#f', in which case the return value
     is '#f'.

 -- Function: fold-left/pred PRED KNIL CIRC
     Apply PRED to successive couples of elements from CIRC; return true
     if all the evaluations of PRED were true.  The iteration stops at
     the first '#f' return value from PRED.

     This function is implemented as:

          (define (fold-left/pred pred knil ell)
            (and-fold-left*/stx (lambda (knil item)
                                  (and (pred knil item) item))
                                knil ell))

     and it can be used to implement predicates for ordering like '<':

          (fold-left/pred < 0 '(1 2 3 4 5 6))
          => 6

          (fold-left/pred < 0 '(1 2 3 -4 5 6))
          => #f


File: vicare-libs.info,  Node: lists fold pair,  Next: lists fold reduce,  Prev: lists fold derived,  Up: lists fold

23.8.5 Folding pairs
--------------------

 -- Function: pair-fold KONS KNIL CIRC1 CIRC2 ...
     Analogous to 'fold', but KONS is applied to successive sublists of
     the lists, rather than successive elements; that is, KONS is
     applied to the pairs making up the lists, giving this (tail)
     recursion:

          (pair-fold kons knil ell) == (let ((tail (cdr ell)))
                                         (pair-fold kons
                                                    (kons ell knil)
                                                    tail))
          (pair-fold kons knil '()) == knil

     For finite lists, the KONS function may reliably apply 'set-cdr!'
     to the pairs it is given without altering the sequence of
     execution.

     Examples:

          (pair-fold (lambda (elm knil)
                       (cons (car elm) knil))
                     '(999)
                     '(1 2 3))
          => (3 2 1 999)

          ;;; destructively reverse a list
          (pair-fold (lambda (pair tail)
                       (set-cdr! pair tail)
                       pair)
                     '()
                     '(0 1 2 3 4 5))
          => (5 4 3 2 1 0)

     At least one of the list arguments must be finite.

 -- Function: pair-fold* KONS KNIL CIRC1 CIRC2 ...
     Hold the same relationship with 'fold*' that 'pair-fold' holds with
     'fold'; obey the recursion:

          (pair-fold* kons knil lis) ==
              (kons lis (pair-fold* kons knil (cdr lis)))
          (pair-fold* kons knil '()) == knil

     example:

          (pair-fold* cons '() '(a b c))
          => ((a b c) (b c) (c))

     At least one of the list arguments must be finite.

     Examples:

          (pair-fold* (lambda (elm knil)
                        (cons (car elm) knil))
                      '(999)
                      '(1 2 3))
          => (1 2 3 999)

          (pair-fold* (lambda (pair tail)
                        (set-cdr! pair tail)
                        pair)
                      '()
                      '(0 1 2 3 4 5))
          => (0 1 2 3 4 5)

          (pair-fold* (lambda (a b c knil)
                        (cons (list (car a)
                                    (car b)
                                    (car c))
                              knil))
                      '(999)
                      '(1 2 3)
                      '(10 20 30)
                      '(100 200 300))
          => '((1 10 100)
               (2 20 200)
               (3 30 300)
               999)


File: vicare-libs.info,  Node: lists fold reduce,  Next: lists fold unfold,  Prev: lists fold pair,  Up: lists fold

23.8.6 Reducing
---------------

 -- Function: reduce F RIDENTITY ELL
 -- Syntax: reduce/stx F RIDENTITY ELL
     'reduce' is a variant of 'fold'.  RIDENTITY should be a "right
     identity" of the procedure F; that is, for any value X acceptable
     to F:

          (f x ridentity) == x

     'reduce' has the following definition:

          if list = (), return ridentity;
          otherwise, return (fold f (car list) (cdr list)).

     in other words, we compute '(fold f ridentity list)'.

     Note that RIDENTITY is used only in the empty-list case.

     We typically use 'reduce' when applying F is expensive and we would
     like to avoid the extra application incurred when 'fold' applies F
     to the head of list and the identity value, redundantly producing
     the same value passed in to F.  For example, if F involves
     searching a file directory or performing a database query, this can
     be significant.  In general, however, 'fold' is useful in many
     contexts where 'reduce' is not.

     Examples:

          ;; take the max of a list of non-negative integers
          (reduce max 0 '(1 2 3 4 5 6))
          => 6

          (reduce + 0 '(0 1 2 3 4 5 6 7 8 9))
          => 45

 -- Function: reduce* F RIDENTITY ELL
 -- Syntax: reduce*/stx F RIDENTITY ELL
     'reduce*' is the 'fold*' variant of 'reduce'.  It obeys the
     following definition:

          (reduce* f ridentity '()) == ridentity
          (reduce* f ridentity '(e1)) == (f e1 ridentity)
                                      == e1
          (reduce* f ridentity '(e1 e2 ...)) ==
              (f e1 (reduce f ridentity (e2 ...)))

     in other words, we compute '(fold* f ridentity list)'.

          ;; append a bunch of lists together
          (reduce* append
                   '()
                   '((1 2 3)
                     (4 5)
                     (6 7 8 9)
                     (0)))
          => (1 2 3 4 5 6 7 8 9 0)


File: vicare-libs.info,  Node: lists fold unfold,  Next: lists fold map,  Prev: lists fold reduce,  Up: lists fold

23.8.7 Unfolding
----------------

 -- Function: unfold STOP? MAP-TO-ELM SEED-STEP FIRST-SEED
 -- Function: unfold STOP? MAP-TO-ELM SEED-STEP FIRST-SEED TAIL-GEN
 -- Syntax: unfold/stx STOP? MAP-TO-ELM SEED-STEP FIRST-SEED
 -- Syntax: unfold/stx STOP? MAP-TO-ELM SEED-STEP FIRST-SEED TAIL-GEN
     Generate a list from a starting value; return the result.  It is is
     the fundamental recursive list constructor, just as 'fold-right' is
     the fundamental recursive list consumer.  It is best described by
     its basic recursion:

          (unfold stop? map-to-elm seed-step seed tail-gen) =
              (if (stop? seed)
                  (tail-gen seed)
                (cons (map-to-elm seed)
                      (unfold stop? map-to-elm
                              seed-step (seed-step seed)
                              tail-gen)))

     The arguments are:

     STOP?
          Determines when to stop: it is applied to the current seed
          value, and if the return value is '#t': unfolding stops.  If
          it evaluates to '#t' at the first invocation: the return value
          of 'unfold' is the return value of TAIL-GEN.

     MAP-TO-ELM
          Maps each seed value to the corresponding list element.  It is
          applied to the current seed value and must return the value to
          append to the result list.

     SEED-STEP
          Maps each seed value to next seed value.

     FIRST-SEED
          The "state" value for the unfold.  It is the first seed value.

     TAIL-GEN
          Applied to the seed value that caused 'stop?' to return '#t',
          must return the tail of the result list.  Defaults to '(lambda
          (x) '())'.

     While 'unfold' may seem a bit abstract to novice functional
     programmers, it can be used in a number of ways:

          ;; List of squares: 1^2 ... 5^2
          (unfold (lambda (x) (> x 5))
                  (lambda (x) (* x x))
                  (lambda (x) (+ x 1))
                  1)
          => (1 4 9 16 25)

          ;; Copy a proper list.
          (unfold null-list? car cdr '(1 2 3 4 5))
          => (1 2 3 4 5)

          ;; Read current input port into a list of values.
          (unfold eof-object? values (lambda (x) (read)) (read))

          ;; Copy a possibly non-proper list:
          (unfold not-pair? car cdr '(1 2 3 4 . 5) values)
          => (1 2 3 4 . 5)

          ;; Append HEAD onto TAIL:
          (unfold null-list? car cdr '(1 2 3) (lambda (x) '(4 5 6)))
          => (1 2 3 4 5 6)

          *NOTE* Interested functional programmers may enjoy noting that
          'fold-right' and 'unfold' are in some sense inverses.  That
          is, given operations KNULL?, KAR, KDR, KONS, and KNIL
          satisfying:

               (kons (kar x) (kdr x)) = x and (knull? knil) = #t

          then:

               (fold-right kons knil (unfold knull? kar kdr x)) = x

          and:

               (unfold knull? kar kdr (fold-right kons knil x)) = x

          This combinator sometimes is called an "anamorphism"; when an
          explicit TAIL-GEN procedure is supplied, it is called an
          "apomorphism".

 -- Function: unfold-right STOP? MAP-TO-ELM SEED-STEP FIRST-SEED
 -- Function: unfold-right STOP? MAP-TO-ELM SEED-STEP FIRST-SEED TAIL
 -- Syntax: unfold-right/stx STOP? MAP-TO-ELM SEED-STEP FIRST-SEED
 -- Syntax: unfold-right/stx STOP? MAP-TO-ELM SEED-STEP FIRST-SEED TAIL
     Generate a list from a starting value; return the result.  It is
     the fundamental iterative list constructor, just as 'fold' is the
     fundamental iterative list consumer.  Construct a list with the
     following loop:

          (let loop ((seed seed)
                     (ell  tail))
            (if (stop? seed)
                ell
              (loop (seed-step seed)
                    (cons (map-to-elm seed) ell))))

     Arguments are:

     STOP?
          Determine when to stop unfolding.

     MAP-TO-ELM
          Map each seed value to the corresponding list element.

     SEED-STEP
          Map each seed value to next seed value.

     FIRST-SEED
          The "state" value for the unfold.

     TAIL
          List terminator; defaults to ''()'.

     While 'unfold-right' may seem a bit abstract to novice functional
     programmers, it can be used in a number of ways:

          ;; List of squares: 1^2 ... 10^2
          (unfold-right zero?
                        (lambda (x) (* x x))
                        (lambda (x) (- x 1))
                        5)
          => (1 4 9 16 25)

          ;; Reverse a proper list.
          (unfold-right null-list? car cdr '(1 2 3 4 5))
          => (5 4 3 2 1)

          ;; Read current input port into a list of values.
          (unfold-right eof-object? values (lambda (x) (read)) (read))

          ;; Equivalent to: (append-reverse rev-head tail)
          (unfold-right null-list? car cdr '(3 2 1) '(4 5 6))
          => (1 2 3 4 5 6)

          *NOTE* Interested functional programmers may enjoy noting that
          'fold' and 'unfold-right' are in some sense inverses.  That
          is, given operations KNULL?, KAR, KDR, KONS, and KNIL
          satisfying:

               (kons (kar x) (kdr x)) = x and (knull? knil) = #t

          then:

               (fold kons knil (unfold-right knull? kar kdr x)) = x

          and:

               (unfold-right knull? kar kdr (fold kons knil x)) = x.

          This combinator presumably has some pretentious mathematical
          name; interested readers are invited to communicate it to the
          author.


File: vicare-libs.info,  Node: lists fold map,  Next: lists fold foreach,  Prev: lists fold unfold,  Up: lists fold

23.8.8 Mapping
--------------

 -- Function: map* PROC CIRC0 CIRC ...
 -- Syntax: map*/stx PROC CIRC0 CIRC ...
     This procedure extends the R6RS specification of 'map' to allow the
     arguments to be of unequal length; it terminates when the shortest
     list runs out of elements.

     PROC is a procedure taking as many arguments as there are list
     arguments and returning a single value.  'map' applies PROC
     element-wise to the elements of the lists and returns a list of the
     results, in order.  The dynamic order in which PROC is applied to
     the elements of the lists is unspecified.

          (map* cadr '((a b)
                       (d e)
                       (g h)))
          =>  (b e h)

          (map* (lambda (n)
                  (expt n n))
            '(1 2 3 4 5))
          => (1 4 27 256 3125)

          (map* + '(1 2 3)
                  '(4 5 6))
          => (5 7 9)

          (let ((count 0))
            (map*
                (lambda (ignored)
                  (set! count (+ count 1))
                  count)
              '(a b)))
          => (1 2) or (2 1)

     At least one of the list arguments must be a finite list:

          (map* +
                '(3 1 4 1)
                (circular-list 1 0))
          => (4 1 5 1)

 -- Function: map-in-order* F CIRC0 CIRC ...
 -- Syntax: map-in-order*/stx F CIRC0 CIRC ...
     A variant of the 'map' procedure that guarantees to apply F across
     the elements of the CIRC arguments in a left-to-right order.  This
     is useful for mapping procedures that both have side effects and
     return useful values.

     At least one of the list arguments must be finite.

 -- Function: append-map F CIRC0 CIRC ...
 -- Function: append-map! F CIRC0 CIRC ...
     Equivalent to:

          (apply append (map f clist1 clist2 ...))

     and:

          (apply append! (map f clist1 clist2 ...))

     so it makes sense to use these functions only when the list
     returned by the map process is a list of lists.

     Map F over the elements of the lists, just as in the 'map'
     function.  However, the results of the applications are appended
     together to make the final result.  'append-map' uses 'append' to
     append the results together; 'append-map!' uses 'append!'.

     The dynamic order in which the various applications of F are made
     is not specified.

     Example:

          (append-map!
              (lambda (x)
                (list x (- x)))
            '(1 3 8))
          => (1 -1 3 -3 8 -8)

          (append-map! list
                       '(1 2 3)
                       '(10 20 30))
          => (1 10 2 20 3 30)

     At least one of the list arguments must be a finite list.

 -- Function: map! F ELL0 ELL ...
 -- Syntax: map!/stx F ELL0 ELL ...
     Like 'map' and 'map/stx', but they are allowed to alter the cons
     cells of ELL0 to construct the result list.

     The dynamic order in which the various applications of F are made
     is not specified.  In the n-ary case, all the list arguments must
     have the same number of elements.

 -- Function: map*! F ELL CIRC ...
 -- Syntax: map*!/stx F ELL CIRC ...
     Like 'map*' and 'map*!/stx', but they are allowed to alter the cons
     cells of ELL to construct the result list.

     The dynamic order in which the various applications of F are made
     is not specified.  In the n-ary case, CIRC ...  must have at least
     as many elements as ELL.

 -- Function: filter-map F ELL0 ELL ...
 -- Syntax: filter-map/stx F ELL0 ELL ...
     Like 'map', but only true values are mapped:

          (filter-map
              (lambda (x)
                (and (number? x)
                     (* x x)))
            '(a 1 b 3 c 7))
          => (1 9 49)

     The dynamic order in which the various applications of F are made
     is not specified.  At least one of the list arguments must be
     finite.

 -- Function: filter-map* F CIRC0 CIRC ...
 -- Syntax: filter-map*/stx F CIRC0 CIRC ...
     Like 'filter-map' and 'filter-map/stx', but accept list arguments
     of different length.


File: vicare-libs.info,  Node: lists fold foreach,  Prev: lists fold map,  Up: lists fold

23.8.9 Producing side effects
-----------------------------

 -- Function: for-each* PROC CIRC0 CIRC ...
 -- Syntax: for-each*/stx PROC CIRC0 CIRC ...
     This procedure extends the R6RS specification for 'for-each' to
     allow the arguments to be of unequal length; it terminates when the
     shortest list runs out of elements.

     The arguments to 'for-each*' are like the arguments to 'map*', but
     'for-each*' calls PROC for its side effects rather than for its
     values.  Unlike 'map*', 'for-each*' is guaranteed to call PROC on
     the elements of the lists in order from the first element(s) to the
     last, and the value returned by 'for-each*' is unspecified.

          (let ((v (make-vector 5)))
            (for-each*
                 (lambda (i)
                   (vector-set! v i (* i i)))
              '(0 1 2 3 4))
            v)
          => #(0 1 4 9 16)

     At least one of the list arguments must be a finite list.

 -- Function: pair-for-each F ELL0 ELL ...
 -- Syntax: pair-for-each/stx F ELL0 ELL ...
     Like 'for-each', but F is applied to successive sublists of the
     argument lists.  That is, F is applied to the cons cells of the
     lists, rather than the lists' elements.  These applications occur
     in left-to-right order.

     The F procedure may reliably apply 'set-cdr!' to the pairs it is
     given without altering the sequence of execution.

          (pair-for-each
              (lambda (pair)
                (display pair)
                (newline))
            '(a b c))
          -| (a b c)
          -| (b c)
          -| (c)

     The list arguments must have equal length.

 -- Function: pair-for-each* F CIRC0 CIRC ...
 -- Syntax: pair-for-each*/stx F CIRC0 CIRC ...
     Like 'for-each*', but F is applied to successive sublists of the
     argument lists.  That is, F is applied to the cons cells of the
     lists, rather than the lists' elements.  These applications occur
     in left-to-right order.

     The F procedure may reliably apply 'set-cdr!' to the pairs it is
     given without altering the sequence of execution.

          (pair-for-each*
              (lambda (pair)
                (display pair)
                (newline))
            '(a b c))
          -| (a b c)
          -| (b c)
          -| (c)

     At least one of the list arguments must be a finite list.


File: vicare-libs.info,  Node: lists filter,  Next: lists search,  Prev: lists fold,  Up: lists

23.9 Filtering and partitioning
===============================

 -- Function: filter! PRED ELL
     Return all the elements of ELL that satisfy the predicate PRED.
     The list is not disordered: Elements that appear in the result list
     occur in the same order as they occur in ELL.  The returned list
     may share a common tail with ELL.  The dynamic order in which the
     various applications of PRED are made is not specified.

          (filter! even? '(0 7 8 8 43 -4))
          => (0 8 8 -4)

     'filter!' may alter the cons cells in ELL to construct the result
     lists.  Notice that 'filter' is exported by '(rnrs lists (6))'.
     *note List utilities: (vicare-scheme)stdlib list.

 -- Function: partition! PRED ELL
     Partition the elements of ELL with predicate PRED, and return two
     values: the list of in-elements and the list of out-elements.  The
     list is not disordered: Elements occur in the result lists in the
     same order as they occur in ELL.  The dynamic order in which the
     various applications of PRED are made is not specified.  One of the
     returned lists may share a common tail with ELL.

          (partition! symbol? '(one 2 3 four five 6))
          => (one four five) (2 3 6)

     'partition!' may alter the cons cells in ELL to construct the
     result lists.  Notice that 'partition' is exported by '(rnrs lists
     (6))'.  *note List utilities: (vicare-scheme)stdlib list.

 -- Function: remove* PRED ELL
 -- Function: remove*! PRED ELL
     Return ELL without the elements that satisfy predicate PRED:

          (lambda (pred list)
            (filter (lambda (x)
                      (not (pred x)))
                    list))

     The list is not disordered: Elements that appear in the result list
     occur in the same order as they occur in ELL.  The returned list
     may share a common tail with ELL.  The dynamic order in which the
     various applications of pred are made is not specified.

          (remove* even? '(0 7 8 8 43 -4)) => (7 43)

     'remove*!' is allowed to alter the cons cells in ELL to construct
     the result lists.

     Notice that '(rnrs lists (6))' exports 'remove', which accepts a
     Scheme object as first argument.  *note List utilities:
     (vicare-scheme)stdlib list.


File: vicare-libs.info,  Node: lists search,  Next: lists delete,  Prev: lists filter,  Up: lists

23.10 Searching
===============

The following procedures search lists for the leftmost elements
satisfying some criteria; this means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list.  Here are the
general rules describing how these procedures work when applied to
different kinds of lists:

_Proper lists_
     The standard, canonical behavior happens in this case.

_Dotted lists_
     It is an error to pass these procedures a dotted list that does not
     contain an element satisfying the search criteria.  That is, it is
     an error if the procedure has to search all the way to the end of
     the dotted list.  In this case the result is undefined.

_Circular lists_
     It is an error to pass these procedures a circular list that does
     not contain an element satisfying the search criteria.  Note that
     the procedures do not detect this case, they will simply diverge.
     It is, however, acceptable to search a circular list if the search
     is successful; that is, if the list contains an element satisfying
     the search criteria.

 -- Function: take-while PRED CIRC
 -- Function: take-while! PRED CIRC
     Return the longest initial prefix of CIRC whose elements all
     satisfy PRED.  'take-while!' is allowed to alter the argument list
     to produce the result.

          (take-while even? '(2 18 3 10 22 9))
          => (2 18)

 -- Function: drop-while PRED CIRC
     Drop the longest initial prefix of CIRC whose elements all satisfy
     PRED and return the rest of the list.

          (drop-while even? '(2 18 3 10 22 9))
          => (3 10 22 9)

     The circular-list case may be viewed as "rotating" the list.

 -- Function: span PRED CIRC
 -- Function: span! PRED ELL
 -- Function: break PRED CIRC
 -- Function: break! PRED ELL
     'span' splits the list into the longest initial prefix whose
     elements all satisfy PRED and the remaining tail.  'break' inverts
     the sense of the predicate: The tail commences with the first
     element of the input list that satisfies the predicate.

     In other words: 'span' finds the intial span of elements satisfying
     PRED, and 'break' breaks the list at the first element satisfying
     PRED.

     'span' is equivalent to:

          (values (take-while pred clist)
                  (drop-while pred clist))

     'span!' and 'break!' are allowed to alter the argument list to
     produce the result.

          (span even? '(2 18 3 10 22 9))
          => (2 18) (3 10 22 9)

          (break even? '(3 1 4 1 5 9))
          => (3 1) (4 1 5 9)

 -- Function: any PRED ELL0 ELL ...
 -- Function: any* PRED CIRC0 CIRC ...
     Apply the predicate across the lists, returning true if the
     predicate returns true on any application.  If there are N list
     arguments, then PRED must be a procedure taking N arguments and
     returning a boolean result.  If all the list arguments are empty:
     The return value is '#f'.

     The list arguments of 'any' must have the same length; 'any*'
     accepts lists of different length.

     'any' applies PRED to the first elements of the list arguments, if
     this application return true, 'any' immediately returns that value;
     otherwise, it iterates, applying pred to the second elements of the
     lits arguments and so forth.  The iteration stops when a true value
     is produced or one of the lists runs out of values; in the latter
     case, 'any' returns '#f'.  The application of PRED to the last
     element of the lists is a tail call.

     Note the difference between 'find' and 'any': 'find' returns the
     element that satisfied the predicate; 'any' returns the true value
     that the predicate produced.

     The identifier 'any' does not end with a question mark: This is to
     indicate that it does not return a simple boolean ('#t' or '#f'),
     but a general value.

          (any integer? '(a 3 b 2.7))
          => #t

          (any integer? '(a 3.1 b 2.7))
          => #f

          (any < '(3 1 4 1 5)
                 '(2 7 1 8 2))
          => #t

 -- Function: every PRED ELL0 ELL ...
 -- Function: every* PRED CIRC0 CIRC ...
     Apply the predicate across the lists, returning true if the
     predicate returns true on every application.  If there are N list
     arguments, then PRED must be a procedure taking N arguments and
     returning a boolean result.  If all the list arguments are empty:
     The return value is '#t'.

     The list arguments of 'every' must have the same length; 'every*'
     accepts lists of different length.

     'every' applies PRED to the first elements of the list arguments,
     if this application returns '#f', 'every' immediately returns '#f';
     otherwise, it iterates, applying PRED to the second elements of the
     list arguments and so forth.  The iteration stops when a '#f' value
     is produced or one of the lists runs out of values.  In the latter
     case, 'every' returns the true value produced by its final
     application of PRED.  The application of PRED to the last element
     of the lists is a tail call.

     If one of the list arguments has no elements, 'every' simply
     returns '#t'.

     The identifier 'every' does not end with a question mark: This is
     to indicate that it does not return a simple boolean ('#t' or
     '#f'), but a general value.

 -- Function: list-index PRED ELL0 ELL ...
 -- Function: list-index* PRED CIRC0 CIRC ...
     Return the index of the leftmost element that satisfies PRED.  If
     there are N list arguments, then PRED must be a function taking N
     arguments and returning a boolean result.

     The list arguments of 'list-index' must have the same length;
     'list-index*' accepts lists of different length.

     'list-index' applies PRED to the first elements of the list
     arguments, if this application returns true, 'list-index'
     immediately returns zero; otherwise, it iterates, applying PRED to
     the second elements of the list arguments and so forth.  When it
     finds a tuple of list elements that cause PRED to return true, it
     stops and returns the zero-based index of that position in the
     lists.

     The iteration stops when one of the lists runs out of values; in
     this case, 'list-index' returns '#f'.

          (list-index even? '(3 1 4 1 5 9))
          => 2

          (list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2))
          => 1

          (list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2))
          => #f

 -- Function: position OBJ ELL
 -- Function: position/stx OBJ ELL
     Return the index of the leftmost OBJ in ELL.  If OBJ is not present
     in ELL, return '#f'.

 -- Function: member* OBJ ELL
 -- Function: member* OBJ ELL ITEM=
     Return the first sublist of ELL whose car is OBJ, where the
     sublists of ELL are the non-empty lists returned by '(drop ell i)'
     for I less than the length of ELL.  If OBJ does not occur in ELL,
     then '#f' is returned.

     Examples:

          (member* '(a) '(b (a) c))
          => ((a) c)

     'member*' extends the R6RS definition of 'member' to allow the
     client to pass in an optional equality procedure ITEM= used to
     compare keys.  ITEM= defaults to 'equal?'.

     The comparison procedure is used to compare the elements Ei of list
     to the key OBJ in this way:

          (= x ei) ; list is (E1 ... En)

     that is, the first argument is always OBJ, and the second argument
     is one of the list elements.  Thus one can reliably find the first
     element of list that is greater than five with:

          (member* 5 ell <)

     Note that fully general list searching may be performed with the
     'find-tail' and 'find' procedures.

 -- Function: find-tail PRED CIRC
     Return the first pair of CIRC whose car satisfies PRED.  If no pair
     does, return '#f'.  'find-tail' can be viewed as a
     general-predicate variant of the 'member*' function.

     Examples:

          (find-tail even? '(3 1 37 -8 -5 0 0))
          => (-8 -5 0 0)

          (find-tail even? '(3 1 37 -5))
          => #f

     In the circular-list case, this procedure "rotates" the list.

     'find-tail' is essentially 'drop-while', where the sense of the
     predicate is inverted: 'find-tail' searches until it finds an
     element satisfying the predicate; 'drop-while' searches until it
     finds an element that doesn't satisfy the predicate.

          *NOTE* The 'find' function defined by R6RS has an ambiguity in
          its lookup semantics: if 'find' returns '#f', we cannot tell
          (in general) if it found a '#f' element that satisfied PRED,
          or if it did not find any element at all.

          In many situations, this ambiguity cannot arise: either the
          list being searched is known not to contain any '#f' elements,
          or the list is guaranteed to have an element satisfying PRED.

          However, in cases where this ambiguity can arise, we should
          use 'find-tail' instead of 'find', 'find-tail' has no such
          ambiguity.


File: vicare-libs.info,  Node: lists delete,  Next: lists sorted,  Prev: lists search,  Up: lists

23.11 Deletion
==============

 -- Function: delete OBJ ELL
 -- Function: delete OBJ ELL ITEM=
 -- Function: delete! OBJ ELL
 -- Function: delete! OBJ ELL ITEM=
     Use the comparison procedure ITEM= (which defaults to 'equal?') to
     find all the elements of ELL that are equal to OBJ, and delete them
     from ELL.  The dynamic order in which the various applications of
     ITEM= are made is not specified.

     The list is not disordered: Elements that appear in the result list
     occur in the same order as they occur in ELL.  The result may share
     a common tail with ELL.

     Note that fully general element deletion can be performed with the
     'remove' and 'remove!' procedures.

     The comparison procedure is used as '(item= obj Ei)', that is: OBJ
     is always the first argument and a list element is always the
     second argument.  The comparison procedure will be used to compare
     each element of list exactly once; the order in which it is applied
     to the various Ei is not specified.  Thus, one can reliably remove
     all the numbers greater than 5 from a list with '(delete 5 ell <)'.

     'delete!' is allowed to alter the cons cells in ELL to construct
     the result.

 -- Function: delete-duplicates ELL
 -- Function: delete-duplicates ELL ITEM=
 -- Function: delete-duplicates! ELL
 -- Function: delete-duplicates! ELL ITEM=
     Remove duplicate elements from ELL.  If there are multiple equal
     elements in ELL, the result list only contains the first or
     leftmost of these elements in the result.  The order of these
     surviving elements is the same as in the original list:
     'delete-duplicates' does not disorder the list (hence it is useful
     for "cleaning up" association lists).

     The ITEM= parameter is used to compare the elements of the list; it
     defaults to 'equal?'.  If x comes before y in ELL, then the
     comparison is performed as '(item= x y)'.  The comparison procedure
     will be used to compare each pair of elements in ELL no more than
     once; the order in which it is applied to the various pairs is not
     specified.

     The list argument may share a common tail with the returned list.

     'delete-duplicates!' is allowed to alter the cons cells in its
     argument list to construct the result.

          (delete-duplicates '(a b a c a b c z)) => (a b c z)

          ;; Clean up an alist:
          (delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                             (lambda (x y)
                               (eq? (car x) (car y))))
          => ((a . 3) (b . 7) (c . 1))


File: vicare-libs.info,  Node: lists sorted,  Next: lists alist,  Prev: lists delete,  Up: lists

23.12 Utilities for sorted lists
================================

 -- Function: sorted-list-insert OBJ ELL ITEM>
     Build a new list holding the same arguments of ELL, a list sorted
     in increasing order, and OBJ inserted in such a position that the
     order is preserved.  The returned list may share structure with
     ELL.

     ITEM> must be a predicate accepting two arguments and returning
     true if the first is greater than the second.  If OBJ is equal to
     one of the items in ELL: OBJ is added before the item from ELL.

 -- Function: sorted-list-insert/uniq OBJ ELL ITEM< ITEM>
     Like 'sorted-list-insert', but if OBJ is equal to one of the items
     in ELL: OBJ is discarded, and ELL it self is returned.

 -- Function: union-of-sorted-lists ELL1 ELL2 ITEM< ITEM>
     Build a new list representing the union of the lists arguments.
     ELL1 and ELL2 are interpreted as lists sorted in increasing order,
     and the result of the union is a sorted list.  The returned list
     may share structure with the list arguments.

     ITEM< and ITEM> must be predicates accepting two arguments and
     returning true if the first is less than/greater than the second.

     When both ITEM< and ITEM> return '#f', the two items are considered
     equal; in this case all the equal items are added to the result, in
     such a way that the items from ELL1 all come before the items from
     ELL2.

 -- Function: union-of-sorted-lists/uniq ELL1 ELL2 ITEM< ITEM>
     Like 'union-of-sorted-lists', but when equal items are found only
     the ones from ELL1 are added to the result.

          (union-of-sorted-lists/uniq
            '(0 1   3     8 9 10)
            '(  1 2   4 5        11 23)
            < >)
          => '(0 1 2 3 4 5 8 9 10 11 23)
          ;;     ^
          ;; from ell1

          (union-of-sorted-lists/uniq
            '(0 1 1   3)
            '(  1   2   4)
            < >)
          => '(0 1 1 2 3 4 5)
          ;;     ^ ^
          ;; both from ell1


File: vicare-libs.info,  Node: lists alist,  Next: lists circ,  Prev: lists sorted,  Up: lists

23.13 Association lists
=======================

An "association list" (or "alist") is a list of pairs.  The car of each
pair contains a key value, and the cdr contains the associated data
value.  They can be used to construct simple look-up tables in Scheme.
Note that association lists are probably inappropriate for
performance-critical use on large data; in these cases, hash tables or
some other alternative should be employed.

 -- Function: assoc* KEY ALIST
 -- Function: assoc* KEY ALIST ITEM=
     ALIST must be an association list: A list of pairs.  These
     procedures find the first pair in ALIST whose car field is KEY, and
     returns that pair.  If no pair in ALIST has KEY as its car, then
     '#f' is returned.

     The functions use 'equal?' to compare the keys and they allow the
     client to pass in an optional equality procedure ITEM= used to
     compare keys.  Notice that 'assq' and 'assv' are exported by '(rnrs
     lists (6))'.  *note List utilities: (vicare-scheme)stdlib list.

          (assoc* (list 'a) '(((a)) ((b)) ((c))))
          => ((a))

     The comparison procedure is used to compare the elements Ei of list
     to the key parameter in this way:

          (item= key (car Ei)) ; list is (E1 ... En)

     that is, the first argument is always KEY, and the second argument
     is one of the list elements.  Thus one can reliably find the first
     entry of ALIST whose KEY is greater than five with '(assoc* 5 alist
     <)'.

     Note that fully general alist searching may be performed with the
     'find-tail' and 'find' procedures.

 -- Function: alist-cons KEY OBJ ALIST
     Defined as:

          (lambda (key datum alist)
            (cons (cons key datum) alist))

     cons a new alist entry mapping KEY to OBJ onto ALIST.

 -- Function: alist-copy ALIST
     Make a fresh copy of ALIST.  This means copying each pair that
     forms an association as well as the spine of the list:

          (lambda (a)
            (map (lambda (elt)
                   (cons (car elt) (cdr elt)))
                 a))

 -- Function: alist-delete KEY ALIST
 -- Function: alist-delete KEY ALIST ITEM=
 -- Function: alist-delete! KEY ALIST
 -- Function: alist-delete! KEY ALIST ITEM=
     Delete all associations from ALIST with the given KEY, using the
     key-comparison procedure ITEM=, which defaults to 'equal?'.  The
     dynamic order in which the various applications of ITEM= are made
     is not specified.

     The returned value may share common tail with ALIST.  The alist is
     not disordered: Elements that appear in the result alist occur in
     the same order as they occur in ALIST.

     The comparison procedure is used to compare the element keys Ki of
     ALIST's entries to the KEY argumentd as '(item= key Ki)'; thus, one
     can reliably remove all entries of ALIST whose key is greater than
     five with '(alist-delete 5 alist <)'.

     'alist-delete!' is allowed to alter cons cells from the alist
     parameter to construct the result.


File: vicare-libs.info,  Node: lists circ,  Next: lists set,  Prev: lists alist,  Up: lists

23.14 Circular lists
====================

Constructors
............

 -- Function: circular-list OBJ1 OBJ2 ...
 -- Syntax: circular-list/stx OBJ1 OBJ2 ...
     Construct a circular list (a ring) of the elements.

          (circular-list 'z 'q)
          => (z q z q z q ...)

 -- Function: list->circular-list! ELL
 -- Syntax: list->circular-list!/stx ELL
     Take a proper list and make it circular (a ring).  Return the
     circular list.

 -- Function: circular-list->list! CIRC
 -- Function: circular-list->list!/stx CIRC
     Take a circular list and "open it" returning a proper list.  The
     car of the returned list is the car of CIRC.  If CIRC is null,
     return null.

 -- Function: circular-list-copy CIRC
 -- Syntax: circular-list-copy/stx CIRC
     Build and return a copy of CIRC.  If CIRC is null, return null.

Inspection
..........

 -- Function: circular-list-length CIRC
 -- Syntax: circular-list-length/stx CIRC
     Return the number of elements in CIRC.  The length of a circular
     list is a non-negative exact integer N such that: 'cdr' applied N
     times to CIRC, returns the CIRC pair itself.

Comparison
..........

 -- Function: circular-list= ITEM= CLIST ...
 -- Function: circular-list=/stx ITEM= CLIST1 CLIST2
     Compare the list arguments using ITEM=, return true if the lists
     are equal.  If all the list arguments are null, return '#t'.  If at
     least one list arguments is null, but not all, return '#f'.  If the
     list arguments have different length, return '#f'.


File: vicare-libs.info,  Node: lists set,  Next: lists low,  Prev: lists circ,  Up: lists

23.15 Set operations on lists
=============================

These procedures implement operations on sets represented as lists of
elements.  They all take an ITEM= argument used to compare elements of
lists; this equality procedure is required to be consistent with 'eq?';
that is, it must be the case that:

     (eq? x y) => (= x y)

   Note that this implies, in turn, that two lists that are 'eq?' are
also set-equal by any legal comparison procedure.  This allows for
constant-time determination of set operations on 'eq?' lists.

   Be aware that these procedures typically run in time O(n * m) for n
and m elements list arguments.  Performance-critical applications
operating upon large sets will probably wish to use other data
structures and algorithms.

 -- Function: lset<=? ITEM= ELL ...
     Return true if, and only if, every ELLI is a subset of ELLI+1.
     List AL is a subset of list BL if every element in AL is equal to
     some element of BL.  When performing an element comparison, the
     ITEM= procedure's first argument is an element of AL, its second
     argument an element of BL.

          (lset<=? eq? '(a) '(a b a) '(a b c c))
          => #t

          (lset<=? eq?)
          => #t

          (lset<=? eq? '(a))
          => #t

     If invoked with all null lists, the return value is '#t'.

 -- Function: lset=? ITEM= ELL ...
     Return true if, and only if, every ELLI is set-equal to ELLI+1.
     "Set-equal" simply means that ELLI is a subset of ELLI+1, and
     ELLI+1 is a subset of ELLI.  The ITEM= procedure's first argument
     is an element of ELLI, its second argument is an element of ELLI+1.

          (lset=? eq? '(b e a) '(a e b) '(e e b a))
          => #t

          (lset=? eq?)
          => #t

          (lset=? eq? '(a))
          => #t

 -- Function: lset-adjoin ITEM= ELL0 ELL ...
     Add the Ei elements from the ELL ...  arguments, not already in
     ELL0, to the result list.  The result shares a common tail with the
     ELL argument.  The new elements are added to the front of the list,
     but no guarantees are made about their order.

     ITEM= is an equality procedure used to determine if an Ei is
     already a member of ELL0; its first argument is an element of ELL0,
     its second is one of the Ei.

     The ELL0 parameter is always a suffix of the result; even if the
     list parameter contains repeated elements, these are not reduced.

          (lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u)
          => (u o i a b c d c e)

 -- Function: lset-union ITEM= ELL ...
 -- Function: lset-union! ITEM= ELL ...
     Return the union of the lists.  The union of lists AL and BL is
     constructed as follows:

       1. If AL is the empty list, the answer is BL (or a copy of BL).

       2. Otherwise, the result is initialised to be list AL (or a copy
          of AL).

       3. Proceed through the elements of list BL in a left-to-right
          order.  If B is such an element of BL, compare every element R
          of the current result list to B: '(item= r b)'.  If all
          comparisons fail, B is consed onto the front of the result.

     However, there is no guarantee that ITEM= will be applied to every
     pair of arguments from AL and BL.  In particular, if AL is 'eq?' to
     BL, the operation may immediately terminate.

     In the N-ary case, the two-argument 'list-union' operation is
     simply folded across the argument lists.

          (lset-union eq? '(a b c d e) '(a e i o u))
          => (u o i a b c d e)

          ;; Repeated elements in the first argument are preserved.
          (lset-union eq? '(a a c) '(x a x))
          => (x a a c)

          (lset-union eq?)
          => ()

          (lset-union eq? '(a b c))
          => (a b c)

     'lset-union!' is allowed to use the cons cells in the first list
     parameter to construct its answer; 'lset-union!' is permitted to
     recycle cons cells from any of its list arguments.

 -- Function: lset-intersection ITEM= ELL0 ELL ...
 -- Function: lset-intersection! ITEM= ELL0 ELL ...
     Return the intersection of the lists.  The intersection of lists AL
     and BL is comprised of every element of AL that is ITEM= to some
     element of BL: '(item= a b)', for A in AL, and B in BL.  Note this
     implies that an element which appears in BL and multiple times in
     list AL will also appear multiple times in the result.

     The order in which elements appear in the result is the same as
     they appear in ELL0; that is, 'lset-intersection' essentially
     filters ELL0, without disarranging element order.  The result may
     share a common tail with ELL0.

     In the N-ary case, the two-argument 'list-intersection' operation
     is simply folded across the argument lists.  However, the dynamic
     order in which the applications of ITEM= are made is not specified.

          (lset-intersection eq? '(a b c d e) '(a e i o u))
          => (a e)

          ;; Repeated elements in the first argument are preserved.
          (lset-intersection eq? '(a x y a) '(x a x z))
          => '(a x a)

          (lset-intersection eq? '(a b c))
          => (a b c)

     'lset-intersection!' is allowed to use the cons cells in the first
     list parameter to construct its answer.

 -- Function: lset-difference ITEM= ELL0 ELL ...
 -- Function: lset-difference! ITEM= ELL0 ELL ...
     Return the difference of the lists: All the elements of ELL0 that
     are not ITEM= to any element from one of the other ELL parameters.

     The ITEM= procedure's first argument is always an element of ELL0;
     its second is an element of one of the other ELL.  The dynamic
     order in which the applications of ITEM= are made is not specified.
     Elements that are repeated multiple times in the ELL0 parameter
     will occur multiple times in the result.

     The order in which elements appear in the result is the same as
     they appear in ELL0; that is, 'lset-difference' essentially filters
     ELL0, without disarranging element order.  The result may share a
     common tail with ELL0.

          (lset-difference eq? '(a b c d e) '(a e i o u))
          => (b c d)

          (lset-difference eq? '(a b c))
          => (a b c)

     'lset-difference!' is allowed to use the cons cells in the first
     list parameter to construct its answer.

 -- Function: lset-xor ITEM= ELL ...
 -- Function: lset-xor! ITEM= ELL ...
     Return the exclusive-or of the sets.  If there are exactly two
     lists, this is all the elements that appear in exactly one of the
     two lists.  The operation is associative, and thus extends to the
     N-ary case, in which the result is a list of the elements that
     appear in an odd number of the lists.  The result may share a
     common tail with any of the ELL parameters.

     More precisely, for two lists AL and BL, AL xor BL is a list of:

        * Every element A of AL such that there is no element B of BL
          such that '(item= a b)', and

        * Every element B of BL such that there is no element A of AL
          such that '(item= b a)'.

     In the n-ary case, the binary-xor operation is simply folded across
     the lists.

          (lset-xor eq? '(a b c d e) '(a e i o u))
          => (d c b i o u)

          (lset-xor eq?)
          => ()

          (lset-xor eq? '(a b c d e))
          => (a b c d e)

     'lset-xor!' is allowed to use the cons cells in the first list
     parameter to construct its answer.

 -- Function: lset-diff+intersection ITEM= ELL0 ELL ...
 -- Function: lset-diff+intersection! ITEM= ELL0 ELL ...
     Return two values: The difference and the intersection of the
     lists.  It is equivalent to:

          (values (lset-difference = list1 list2 ...)
                  (lset-intersection = list1
                                       (lset-union = list2 ...)))

     but can be implemented more efficiently.

     The ITEM= procedure's first argument is an element of ELL0; its
     second is an element of one of the other ELL arguments.

     Either of the returned lists may share a common tail with ELL0.
     This operation essentially partitions ELL0.

     'lset-diff+intersection!' is allowed to use the cons cells in the
     first list argument to construct its answer.


File: vicare-libs.info,  Node: lists low,  Prev: lists set,  Up: lists

23.16 Low level utilities
=========================

The following bindings are exported by '(vicare containers lists low)'.

 -- Function: %and/or-null? ELL ...
     This is the implementation of 'and/or-null?'.  Return two values
     being the return values of 'and-null?' and 'or-null?' applied to
     the LIST arguments.

 -- Function: %and/or-eq? LIST-OF-CLISTS1 LIST-OF-CLISTS2
     Given two lists of lists (possibly circular), compare with 'eq?'
     the sublists from the arguments, and return two boolean values:

       1. True if each sublist from LIST-OF-CLISTS1 is 'eq?' to its
          homologous from LIST-OF-CLISTS2.

       2. True if at least one sublist from LIST-OF-CLISTS1 is 'eq?' to
          its homologous from LIST-OF-CLISTS2.

     LIST-OF-CLISTS1 and LIST-OF-CLISTS2 are meant to have the same
     length, but this is not tested.  The iteration will stop when the
     end of the shorter list is found.

     To understand how this function is used, consider the following:

          (define (circular-list= item= . list-of-clists)
            (let-values (((and-nil or-nil)
                         (apply %and/or-null? list-of-clists)))
              (cond (and-nil #t)
                    (or-nil  #f)
                    (else
                     (let loop ((cells list-of-clists))
                       (let-values (((cars cdrs) (%cars/cdrs* cells)))
                         (or
                          (null? cars)
                          (and
                           (apply item= cars)
                           (let-values (((and-eq or-eq)
                                        (%and/or-eq? list-of-clists cdrs)))
                             (cond (and-eq #t)
                                   (or-eq  #f)
                                   (else (loop cdrs))))))))))))

 -- Function: %cars LIST-OF-LISTS
 -- Function: %cars LIST-OF-LISTS WHO
     Return the list of cars of the sublists of LIST-OF-LISTS, which
     must be a non-empty list of lists.

     If all the sublists are null: The return value is null.  If at
     least one sublist, but not all, is null: Raise an assertion
     violation using WHO as value for the '&who' condition.  WHO
     defaults to '#f'.

 -- Function: %cars* LIST-OF-LISTS
     Like %CARS but accept sublists of different length.  If at least
     one sublist is null: The return value is null.

 -- Function: %cdrs LIST-OF-LISTS
 -- Function: %cdrs LIST-OF-LISTS WHO
     Return the list of cdrs of the sublists of LIST-OF-LISTS, which
     must be a non-empty list of lists.

     If all the sublists are null: The return value is null.  If at
     least one sublist, but not all, is null: Raise an assertion
     violation using WHO as value for the '&who' condition.  WHO
     defaults to '#f'.

 -- Function: %cdrs* LIST-OF-LISTS
     Like %CDRS but accept sublists of different length.  If at least
     one sublist is null: The return value is null.

 -- Function: %cars/cdrs LIST-OF-LISTS
     Given a list of sublists, return two values being the list of cars
     and the list of cdrs from LIST-OF-LISTS.  If the sublists are
     detected not to have equal length, raise an error.

 -- Function: %cars/cdrs* LIST-OF-LISTS
     Like '%cars/cdrs', but accept lists of different length.  If a list
     in LIST-OF-LISTS is null: Return 2 null values.

 -- Function: %cars+cdrs*/no-test LIST-OF-LISTS
     Like '%cars/cdrs*', but do not test if one sublist is null.  If one
     sublist is null, the behaviour is undefined.

 -- Function: %cars+knil LIST-OF-LISTS KNIL
 -- Function: %knil+cars LIST-OF-LISTS KNIL
 -- Function: %cars+knil LIST-OF-LISTS KNIL WHO
 -- Function: %knil+cars LIST-OF-LISTS KNIL WHO
     Return the list of cars of the sublists of LIST-OF-LISTS, which
     must be a non-empty list of lists.  '%cars+knil' adds KNIL as last
     value.  '%knil+cars' adds KNIL as first value.

     If all the sublists are null: The return value is null.  If at
     least one sublist, but not all, is null: Raise an assertion
     violation using WHO as value for the '&who' condition.  WHO
     defaults to '#f'.

 -- Function: %cars+knil* LIST-OF-LISTS KNIL
 -- Function: %knil+cars* LIST-OF-LISTS KNIL
     Like '%cars+knil' and '%knil+cars', but accept sublists of
     different length.  If at least one sublist is null: The return
     value is null.

 -- Function: %cars+knil/cdrs LIST-OF-LISTS KNIL
 -- Function: %knil+cars/cdrs LIST-OF-LISTS KNIL
 -- Function: %cars+knil/cdrs LIST-OF-LISTS KNIL WHO
 -- Function: %knil+cars/cdrs LIST-OF-LISTS KNIL WHO
     Given that LIST-OF-LISTS must be a non-empty list of lists, return
     two values: The list of cars and the lists of cdrs of the sublists.
     '%cars+knil/cdrs' adds KNIL as last value of the cars.
     '%knil+cars/cdrs' adds KNIL as first value of the cars.

     If all the sublists are null: The return values are both null.  If
     at least one sublist, but not all, is null: Raise an assertion
     violation using WHO as value for the '&who' condition.  WHO
     defaults to '#f'.

 -- Function: %cars+knil/cdrs* LIST-OF-LISTS KNIL
 -- Function: %knil+cars/cdrs* LIST-OF-LISTS KNIL
     Like '%cars+knil/cdrs' and '%knil+cars/cdrs', but accept sublists
     of different length.  If at least one sublist is null: The return
     value is null.

Queues
......

The following macros handle queue values: Pairs whose car is a list and
whose cdr is the last pair in the list.  They allow user friendly
insertion of elements at the end of the list.  Experiments show that
building a list in reverse and then applying 'reverse' to it, is almost
always faster than using these queue macros.

               -----------
       queue  | car | cdr |
               -----------
                 |     |
             ----       ----------------
            |                           |
            v                           v
           ---    ---    ---    ---    ---
     list | | |->| | |->| | |->| | |->| | |->()
           ---    ---    ---    ---    ---
           |      |      |      |      |
           o      o      o      o      o

 -- Syntax: %make-queue OBJ
     Build and return a new queue having OBJ as first argument.  Takes
     care of evaluating OBJ only once.

 -- Syntax: %list->queue ELL
     Embed LIST into a queue and return it.  Takes care of evaluating
     ELL only once.

 -- Syntax: enqueue! QUEUE OBJ
     Enqueue OBJ at the end of QUEUE and return a new queue value.
     Takes care of evaluating OBJ only once, but evaluates QUEUE
     multiple times.

 -- Syntax: %queue-list-ref QUEUE
     Return the list inside of QUEUE.  It is a synonym of 'car'.

 -- Syntax: %queue-last-pair-ref QUEUE
     Return the last pair of the list inside of QUEUE.  It is a synonym
     of 'cdr'.

   Examples of building a list using a queue:

     (define max-value+1 10)

     (do ((i 1 (+ 1 i))
          (l (%make-queue 0) (%enqueue! l i)))
         ((= i max-value+1)
          (%queue-list-ref l)))
     => '(0 1 2 3 4 5 6 7 8 9)

     (let loop ((l (%make-queue 0))
                (i 1))
       (if (= i max-value+1)
           (%queue-list-ref l)
         (loop (%enqueue! l i) (+ 1 i))))
     => '(0 1 2 3 4 5 6 7 8 9)

which is the same of doing:

     (define max-value+1 10)

     (do ((i 1 (+ 1 i))
          (l '(0) (cons i l)))
         ((= i max-value+1)
          (reverse l)))
     => '(0 1 2 3 4 5 6 7 8 9)

     (let loop ((l '(0))
                (i 1))
       (if (= i max-value+1)
           (reverse l)
         (loop (cons i l) (+ 1 i))))
     => '(0 1 2 3 4 5 6 7 8 9)


File: vicare-libs.info,  Node: vectors,  Next: strings,  Prev: lists,  Up: Top

24 Vectors library
******************

The library '(vicare containers vectors)' extends the vector operations
available in the base library (*note Vectors: (vicare-scheme)baselib
vectors.) and Vicare's extensions (*note Additional vector functions:
(vicare-scheme)iklib vectors.).  While '(vicare containers vectors)' is
a high level interface, '(vicare containers vectors low)' is a low level
interface with the same functionalities.

   To avoid identifiers collision: it is suggested to import the
libraries in the hierarchy '(vicare containers vectors ---)' with the
prefix 'vector.', as in:

     (import (vicare)
       (prefix (vicare containers vectors) vector.))

* Menu:

* vectors intro::               Introduction.
* vectors convention::          Interface conventions.
* vectors views::               Views over vectors.
* vectors cons::                Constructors.
* vectors pred::                Predicates.
* vectors compar::              Comparison.
* vectors fold::                Fold and unfold.
* vectors select::              Selection.
* vectors pad::                 Padding and trimming.
* vectors prefix::              Prefixes and suffixes.
* vectors search::              Searching.
* vectors filter::              Filtering and deleting.
* vectors list::                List and vector conversion.
* vectors replicate::           Replicate and rotate.
* vectors mutate::              Mutators.
* vectors misc::                Miscellaneous functions.


File: vicare-libs.info,  Node: vectors intro,  Next: vectors convention,  Up: vectors

24.1 Introduction
=================

Library organisation
....................

The functions are split in a high level library, '(vicare containers
vectors)', and a low level one, '(vicare containers vectors low)'.  The
main difference between the two layers is that the high level library
makes heavy usage of macros to implement the "vector views", which allow
accessing subvectors using a friendly syntax.

   All the functions in the low level library are bound to identifiers
starting with '%'; for example: 'vector-prefix?' is a high level macro,
'%vector-prefix?' is its low level function homologous.

Direction of iteration
......................

The library accesses the values of a vector in left-to-right or
right-to-left order depending on the convenience of the algorithm.

Handling side effects
.....................

Care must be taken when using functions with side effects.  One reason
for this is that some of the supported Scheme implementations will treat
a literal vector as a constant, so the following raises an error:

     (import (rnrs))

     (define vec '#(0 1 2 3 4))
     (vector-set! vec 2 #\9)

To avoid this problem completely, we can change the program in this way:

     (import (rnrs))

     (define vec (vector-copy '#(0 1 2 3 4)))
     (vector-set! vec 2 #\9)

of course we may want to wrap into 'vector-copy' only the vectors that
are meant to be mutated.


File: vicare-libs.info,  Node: vectors convention,  Next: vectors views,  Prev: vectors intro,  Up: vectors

24.2 Interface conventions
==========================

In order to simplify text in this documentation section, the values of a
vector are called "items".

   The following naming convention holds:

   * Procedures whose names end in '!' are side-effecting variants.
     What values these procedures return is usually not specified.

   * The order of common arguments is consistent across the different
     procedures in the high level library, and consistent across the
     different procedures in the low level library.  Arguments to some
     functions in the high level library have different order from the
     one of the homologous low level functions.

   * Procedures that have left/right directional variants use the
     following convention:

     Direction       Suffix
     -------------------------
     left-to-right   ?NONE
     right-to-left   -right
     both            -both

   In the procedure specifications:

   * A V argument is a vector view, which is expanded by a macro in a
     triplet of values: the vector, the index of the first value in the
     selected subvector, the index of the value past the last in the
     selected position.  *note vectors views:: for details.

   * A VEC argument is a vector.

   * The START and PAST arguments are half-open vector indices
     specifying a subvector within a vector argument; when unspecified,
     they default to zero and the length of the vector, respectively.
     When specified, it must be the case that:

          0 <= start <= past <= (vector-length s)

     for the corresponding argument VEC.  They typically restrict a
     procedure's action to the indicated subvector; when START equals
     PAST the selected subvector is the empty vector.

   * A PRED argument is a unary value predicate procedure, returning a
     true/false value when applied to a value.

   * A ITEM= argument is a binary function applied to two items, it must
     return true when they are equal, false otherwise.

   * A ITEM< argument is a binary function applied to two items, it must
     return true when the first is less than the second, false
     otherwise.

   * An I or K argument is an exact non-negative integer specifying an
     index into a vector.

   * The LEN and NVALUES arguments are exact non-negative integers
     specifying a length of a vector or some number of values.

   * An OBJ argument can be any value.

   An argument followed by '...' means zero-or-more elements.  So the
procedure with the signature:

     sum-squares x ...

takes zero or more arguments (X, ...), while the procedure with
signature:

     spell-check doc dict1 dict2 ...

takes two mandatory arguments (DOC and DICT1) and zero or more optional
arguments (DICT2 ...).

   If a procedure is said to return "unspecified", this means that
nothing at all is known about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g.  as the value of an expression appearing as a
non-terminal subform of a begin expression.


File: vicare-libs.info,  Node: vectors views,  Next: vectors cons,  Prev: vectors convention,  Up: vectors

24.3 Views over vectors
=======================

Vector views are syntactic sugar to allow subvector specification with
minimum overhead; views make use of auxiliary syntaxes exported by the
library '(vicare containers auxiliary-syntaxes)' and reexported by
'(vicare containers vectors)'.  Many low level vector functions act on
subvectors specified with triplets of arguments:

   * The full vector.

   * The "start index": The index of the first item in the selected
     subvector.

   * The "past index": The index of the item past the last item in the
     selected subvector.

   To select the subvector '#(2 3 4)' from the vector '#(0 1 2 3 4 5 6)'
we have to determine the half-open range of items, which is [2, 5), then
apply a function to the arguments:

     (%the-function '#(0 1 2 3 4 5 6) 2 5)

while to select the whole vector we can do:

     (%the-function '#(0 1 2 3 4 5 6) 0 7)

or:

     (let ((vec '#(0 1 2 3 4 5 6)))
       (%the-function vec 0 (vector-length vec)))

   With the vector views implemented by '(vicare containers vectors)',
the low level function is wrapped by a high level syntax which can be
invoked as:

     (the-function '#(0 1 2 3 4 5 6 7))
             ; select the whole vector

     (the-function (view '#(0 1 2 3 4 5 6 7)))
             ; select the whole vector

     (the-function (view '#(0 1 2 3 4 5 6 7)
                     (start 3)))
             ; select the subvector [3, 8)

     (the-function (view '#(0 1 2 3 4 5 6 7)
                     (start 3)
                     (past 6)))
             ; select the subvector [3, 6)

     (the-function (view '#(0 1 2 3 4 5 6 7)
                     (past 5)))
             ; select the subvector [0, 5)

instead of a triplet of arguments, the vector view is a single argument
that can be:

'?VECTOR'
'(view ?VECTOR)'
     The vector itself or an unquoted list holding the vector itself,
     prefixed by the 'view' auxiliary syntax: it selects the whole
     vector.

'(view ?VECTOR (start ?START-INDEX))'
     An unquoted list holding the vector and the start index, with
     auxiliary syntaxes 'view' and 'start': it selects the subvector
     from the start index to the end.

'(view ?VECTOR (past ?PAST-INDEX))'
     An unquoted list holding the vector and the past index, with
     auxiliary syntaxes 'view' and 'past': it selects the subvector from
     zero to the selected past index.

'(view ?VECTOR (start ?START-INDEX) (past ?PAST-INDEX))'
     An unquoted list holding the vector, the start index and the past
     index, with auxiliary syntaxes 'view', 'start' and 'past': it
     selects the subvector between the start and past indexes.

'?VECTOR', '?START-INDEX' and '?PAST-INDEX' can be arbitrary Scheme
expressions.  High level macros accepting two or more subvectors as
arguments, support vector views for all of them.  When we are concerned
with the overhead of vector views, we can use the low level functions
directly.

   When the start and past index are negative, the 'view' syntax
normalises them as:

     (if (negative? IDX)
         (+ IDX (vector-length STRING))
        IDX)

so that negative indices are counted from the end of the vector: -1
selects the ultimate character, -2 selected the penultimate character
and so on.

   In the following documentation: low level functions and high level
macros are documented together; only the meaning of arguments to the low
level function are described, the meaning of high level arguments is
obvious.


File: vicare-libs.info,  Node: vectors cons,  Next: vectors pred,  Prev: vectors views,  Up: vectors

24.4 Constructors
=================

 -- Function: vector-concatenate VECTOR-LIST
     Append the elements of VECTOR-LIST together into a single vector.
     Guaranteed to return a freshly allocated vector.

 -- Function: %vector-concatenate-reverse VECTOR-LIST FINAL-VECTOR
          NVALUES
 -- Macro: vector-concatenate-reverse VECTOR-LIST
 -- Macro: vector-concatenate-reverse VECTOR-LIST FINAL-VECTOR
 -- Macro: vector-concatenate-reverse VECTOR-LIST FINAL-VECTOR NVALUES
     Reverse VECTOR-LIST then concatenate the elements, which must be
     vectors.  The first NVALUES items in FINAL-VECTOR are consed onto
     the beginning of VECTOR-LIST before performing the the reversal and
     concatenation operations.

     FINAL-VECTOR defaults to the empty vector and NVALUES defaults to
     the length of FINAL-VECTOR.

     This procedure is useful in the construction of procedures that
     accumulate data into lists of vector buffers, and wish to convert
     the accumulated data into a single vector when done.

 -- Function: vector-append VEC ...
     Return a newly allocated vector that contains all elements in order
     from the subsequent locations in the vector arguments.

          (vector-append '#(x) '#(y))
          => #(x y)

          (vector-append '#(a) '#(b c d))
          => #(a b c d)

          (vector-append '#(a #(b)) '#(#(c)))
          => #(a #(b) #(c))

 -- Function: vector-tabulate INTEGER->ITEM LEN
     Construct a vector of size LEN by applying INTEGER->ITEM to each
     index from zero (included) to LEN (excluded), in increasing order,
     to produce the corresponding vector element.


File: vicare-libs.info,  Node: vectors pred,  Next: vectors compar,  Prev: vectors cons,  Up: vectors

24.5 Predicates
===============

 -- Function: vector-null? OBJ
     Return '#t' if OBJ is the empty vector, otherwise return '#f'.

 -- Function: %vector-every PRED VEC START PAST
 -- Function: %vector-any PRED VEC START PAST
 -- Macro: subvector-every PRED V
 -- Macro: subvector-any PRED V
     Check to see if the given predicate is true on every/any item in
     VEC, proceeding from left (index START) to right (index PAST).  If
     the selected subvector is empty, the return value is '#f'.

     The predicate is "witness-generating":

        * If 'subvector-any' returns true: the returned true value is
          the one produced by the application of the predicate.

        * If 'subvector-every' returns true: the returned true value is
          the one produced by the application of the predicate to the
          last item in the subvector.

     If the predicate is applied to the final item of the selected
     subvector, that final application is a tail call.

     The names of these procedures do not end with a question mark; this
     is to indicate that they do not return a simple boolean ('#t' or
     '#f'), but a general value.

 -- Function: vector-every PRED VEC0 VEC ...
 -- Function: vector-any PRED VEC0 VEC ...
     Like 'subvector-every' and 'subvector-any', but apply the predicate
     to the elements of all the vectors used as arguments.  All the
     arguments must have the same number of elements.


File: vicare-libs.info,  Node: vectors compar,  Next: vectors fold,  Prev: vectors pred,  Up: vectors

24.6 Comparison
===============

 -- Function: %vector-compare ITEM= ITEM< VEC1 BEG1 PAST1 VEC2 BEG2
          PAST2 PROC< PROC= PROC>
 -- Macro: vector-compare ITEM= ITEM< V1 V2 PROC< PROC= PROC>
     Determine the "mismatch index" between the two subvectors: the
     largest index i such that for every 0 <= j < i, vec1[j] = vec2[j];
     that is, i is the first position that does not match.

     The mismatch index is always an index into VEC1; in the case of
     equal vectors, it is always PAST1; the functions observe the
     protocol in this redundant case for uniformity.

     The items before the mismatch index are tested for equality using
     ITEM=; the items at the mismatch index are also compared using
     ITEM<, to determine the smallest.

     PROC<, PROC=, or PROC> are applied to the mismatch index (not
     item), depending upon whether the subvector of VEC1 is less than,
     equal to, or greater than the subvector of VEC2.  The result of the
     application is returned.

     If we just want to have the mismatch index as return value: We can
     use 'values' as value for PROC<, PROC= and PROC>.  Another
     interesting option is to use '(lambda (mismatch-index) #f)' or
     '(lambda (mismatch-index) #t)'.

     Examples:

          (vector-compare '#(0 1 2 3) '#(0 1 2 3) values values values)
          => 4

          (vector-compare '#(0 1 2 3) '#(0 1 2 3) values values values)
          => 4

 -- Function: %vector= ITEM= VEC1 BEG1 PAST1 VEC2 BEG2 PAST2
 -- Macro: vector= ITEM= V1 V2
     Compare two subvectors: Return true if they are equal according to
     ITEM=, '#f' otherwise.

 -- Function: %vector<> ITEM= VEC1 BEG1 PAST1 VEC2 BEG2 PAST2
 -- Macro: vector<> ITEM= V1 V1
     Compare two subvectors: Return '#f' if they are equal according to
     ITEM=, true otherwise.

   The following predicates compare two subvectors according to the
following rules:

  1. Two subvectors are equal if: they have the same length and all
     their items are equal according to ITEM=.

  2. A subvector V1 is less than V2 if:

        * V1 is shorter than V2 and the all the items in V1 are equal to
          the corresponding items in V2 according to ITEM=.

        * The items in V1 and V2 are equal up to a certain index
          according to ITEM=, and the item at the mismatch index in V1
          is less than the corresponding item in V2 according to ITEM<.

  3. A subvector V1 is greater than V2 if:

        * V1 is longer than V2 and the all the items in V1 are equal to
          the corresponding items in V2 according to ITEM=.

        * The items in V1 and V2 are equal up to a certain index
          according to ITEM=, and the item at the mismatch index in V1
          is greater than the corresponding item in V2 according to
          ITEM<.

 -- Function: %vector< ITEM= ITEM< VEC1 BEG1 PAST1 VEC2 BEG2 PAST2
 -- Macro: vector< ITEM= ITEM< V1 V2
     Compare two subvectors: Return true if the first is less than the
     second, '#f' otherwise.

 -- Function: %vector<= ITEM= ITEM< VEC1 BEG1 PAST1 VEC2 BEG2 PAST2
 -- Macro: vector<= ITEM= ITEM< V1 V2
     Compare two subvectors: Return true if the first is less than, or
     equal to, the second; '#f' otherwise.

 -- Function: %vector> ITEM= ITEM< VEC1 BEG1 PAST1 VEC2 BEG2 PAST2
 -- Macro: vector> ITEM= ITEM< V1 V2
     Compare two subvectors: Return true if the first is greater than
     the second, '#f' otherwise.

 -- Function: %vector>= ITEM= ITEM< VEC1 BEG1 PAST1 VEC2 BEG2 PAST2
 -- Macro: vector>= ITEM= ITEM< V1 V2
     Compare two subvectors: Return true if the first is greater than,
     or equal to, the second; '#f' otherwise.


File: vicare-libs.info,  Node: vectors fold,  Next: vectors select,  Prev: vectors compar,  Up: vectors

24.7 Fold and unfold
====================

* Menu:

* vectors fold rnrs::           Folding with R6RS style.
* vectors fold sub::            Folding over subvectors.
* vectors fold unfold::         Unfolding vectors.
* vectors fold map::            Mapping functions.


File: vicare-libs.info,  Node: vectors fold rnrs,  Next: vectors fold sub,  Up: vectors fold

24.7.1 Folding with R6RS style
------------------------------

 -- Function: vector-fold-left COMBINE KNIL VEC0 VEC ...
 -- Function: vector-fold-right COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-fold-left/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-fold-right/stx COMBINE KNIL VEC0 VEC ...
     Fold the function COMBINE over the vector arguments, which must
     have the same length.  The return value is the return value of the
     last evaluated call to COMBINE; if all the vector arguments are
     empty, the return value is KNIL.  The syntaxes may be a little
     faster in the multiple vector arguments case.

     The left-folding variants iterate COMBINE left-to-right over each
     element of equal index in all the vectors; COMBINE is applied as:

          (COMBINE STATE
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            )

     where STATE is the current state value, and it is the *first*
     argument; the current state value begins with KNIL, and becomes
     whatever COMBINE returned at the respective iteration.

     The right-folding variants iterate COMBINE right-to-left over each
     element of equal index in all the vectors; COMBINE is applied as:

          (COMBINE
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            
            STATE)

     in which STATE is the *last* argument.

 -- Function: vector-fold-left* COMBINE KNIL VEC0 VEC ...
 -- Function: vector-fold-right* COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-fold-left*/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-fold-right*/stx COMBINE KNIL VEC0 VEC ...
     Like the above functions, but accept vectors of different length,
     iterating until the end of the shortest.

 -- Function: vector-fold-left/with-index COMBINE KNIL VEC0 VEC ...
 -- Function: vector-fold-left*/with-index COMBINE KNIL VEC0 VEC ...
 -- Function: vector-fold-right/with-index COMBINE KNIL VEC0 VEC ...
 -- Function: vector-fold-right*/with-index COMBINE KNIL VEC0 VEC ...
     Folding operators variants which apply COMBINE using the index of
     the current elements as first argument.  For the left-folding
     operators:

          (COMBINE IDX STATE
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            )

     for the right-folding operators:

          (COMBINE IDX
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            
            STATE)

     Here is a possible implementation for 'vector-map!':

          (define (vector-map! proc vec0 . vectors)
            (apply vector-fold-left/with-index
                   (lambda (index state . items)
                     (vector-set! state index (apply proc index items))
                     state)
                   vec0 vec0 vectors))

 -- Function: vector-and-fold-left COMBINE KNIL VEC0 VEC ...
 -- Function: vector-and-fold-left* COMBINE KNIL VEC0 VEC ...
 -- Function: vector-and-fold-right COMBINE KNIL VEC0 VEC ...
 -- Function: vector-and-fold-right* COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-and-fold-left/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-and-fold-left*/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-and-fold-right/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-and-fold-right*/stx COMBINE KNIL VEC0 VEC ...
     Like the functions above, but stop the iteration if COMBINE returns
     '#f'.  The return value is the return value of the last evaluated
     call to COMBINE; if all the vector arguments are empty, the return
     value is KNIL.

     These functions can be used to implement functions like
     'vector-every':

          (define (vector-every pred vec0 . vectors)
            (apply vector-and-fold-left (lambda (state . items)
                                          (apply pred items))
                   #t ;must be true
                   (cons vec0 vectors)))

 -- Function: vector-or-fold-left COMBINE KNIL VEC0 VEC ...
 -- Function: vector-or-fold-left* COMBINE KNIL VEC0 VEC ...
 -- Function: vector-or-fold-right COMBINE KNIL VEC0 VEC ...
 -- Function: vector-or-fold-right* COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-or-fold-left/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-or-fold-left*/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-or-fold-right/stx COMBINE KNIL VEC0 VEC ...
 -- Syntax: vector-or-fold-right*/stx COMBINE KNIL VEC0 VEC ...
     Like the functions above, but stop the iteration if COMBINE returns
     true as state.  The return value is the return value of the last
     evaluated call to COMBINE.  If all the vectors are empty, the
     return value is KNIL.

     These functions can be used to implement functions like
     'vector-any':

          (define (vector-any pred vec0 . vectors)
            (apply vector-or-fold-left (lambda (state . items)
                                         (apply pred items))
                   #f ;must be false
                   (cons vec0 vectors)))

 -- Function: vector-fold-left/pred PRED KNIL VEC
     Apply PRED to adjacent couples of elements from VEC; return true if
     all the evaluations of PRED were true.  The iteration stops at the
     first '#f' return value from PRED.

     This function is implemented as:

          (define (fold-left/pred pred knil ell)
            (vector-and-fold-left/stx (lambda (state item)
                                        (and (pred state item) item))
               knil ell))

     and it can be used to implement predicates for ordering like '<':

          (vector-fold-left/pred < 0 '(1 2 3 4 5 6))
          => 6

          (vector-fold-left/pred < 0 '(1 2 3 -4 5 6))
          => #f


File: vicare-libs.info,  Node: vectors fold sub,  Next: vectors fold unfold,  Prev: vectors fold rnrs,  Up: vectors fold

24.7.2 Folding over subvectors
------------------------------

 -- Function: %subvector-fold-left COMBINE KNIL VEC START PAST
 -- Function: %subvector-fold-right COMBINE KNIL VEC START PAST
 -- Macro: subvector-fold-left COMBINE KNIL S
 -- Macro: subvector-fold-right COMBINE KNIL S
     Fold COMBINE over each item of the selected subvector, return the
     return value of the last evaluated call to COMBINE; if the selected
     subvector is empty, the return value is KNIL.  The left-fold
     operator builds the return value as:

          (COMBINE
            (COMBINE
                  ...
                  (COMBINE
                     (COMBINE
                        (vector-ref VEC START)
                        KNIL)
                     (vector-ref VEC (+ START 1)))
                  ...
              (vector-ref VEC (- PAST 2)))
              ...
            (vector-ref VEC (- PAST 1)))

     the right-fold iterator builds the return value as:

          (COMBINE
            (vector-ref VEC START
            (COMBINE
              (vector-ref VEC (+ START 1))
              ...
                (COMBINE
                  (vector-ref VEC (- PAST 3))
                  (COMBINE
                     (vector-ref VEC (- PAST 2))
                     (COMBINE
                        (vector-ref VEC (- PAST 1))
                        KNIL)))))


File: vicare-libs.info,  Node: vectors fold unfold,  Next: vectors fold map,  Prev: vectors fold sub,  Up: vectors fold

24.7.3 Unfolding vectors
------------------------

 -- Function: vector-unfold STOP? SEED->ITEM MAKE-SEED FIRST-SEED
 -- Function: vector-unfold STOP? SEED->ITEM MAKE-SEED FIRST-SEED
          BASE-VECTOR
 -- Function: vector-unfold STOP? SEED->ITEM MAKE-SEED FIRST-SEED
          BASE-VECTOR MAKE-FINAL
     This is a fundamental constructor for vectors.  Arguments
     description follows.

     MAKE-SEED
          A map function used to generate a series of "seed" values from
          the initial seed:

               FIRST-SEED
               (MAKE-SEED FIRST-SEED)            => seed2
               (MAKE-SEED seed2)                 => seed3
               (MAKE-SEED seed3)                 => seed4
               ...

     STOP?
          A predicate function telling when to stop generating items:
          When it returns true when applied to one of the seed values.

     SEED->ITEM
          Map function mapping each seed value to the corresponding item
          in the result vector.  These items are assembled into the
          vector in a left-to-right order.

     BASE
          An optional vector which is used as initial/leftmost portion
          of the constructed vector.  Defaults to the empty vector.

     MAKE-FINAL
          Optional function applied to the terminal seed value (on which
          STOP? returns true) to produce the final/rightmost portion of
          the constructed vector.  Defaults to '(lambda (x) '#())'.

     More precisely, the following (simple, inefficient) definitions
     hold:

          ;; iterative
          (define (vector-unfold stop? seed->item make-seed
                                 first-seed base-vector make-final)
            (let loop ((seed    first-seed)
                       (result  base-vector))
              (if (stop? seed)
                  (vector-append result (make-final seed))
                (loop (make-seed seed)
                      (vector-append result
                                     (vector (seed->item seed)))))))

          ;; recursive
          (define (vector-unfold stop? seed->item make-seed
                                 first-seed base-vector make-final)
            (vector-append
               base-vector
               (let loop ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (vector-append (vector (seed->item seed))
                                  (loop (make-seed seed)))))))

     This function is a fairly powerful vector constructor; we can use
     it to convert a list to a vector, read a port into a vector,
     reverse a vector, copy a vector, and so forth.  Examples:

          (port->vector p) = (vector-unfold eof-object? values
                                            (lambda (x) (read-item p))
                                            (read-item p))

          (list->vector lis) = (vector-unfold null? car cdr lis)

          (vector-tabulate f size) = (vector-unfold (lambda (i)
                                                      (= i size))
                                                    f add1 0)

     to map 'proc' over a list LIS, producing a vector:

          (vector-unfold null? (compose proc car) cdr lis)

     Interested functional programmers may enjoy noting that
     'vector-fold-right' and 'vector-unfold' are in some sense inverses.
     That is, given operations KNULL?, KAR, KDR, COMBINE, and KNIL
     satisfying:

          (combine (kar x) (kdr x)) => x
          (knull? knil) => #t

     then:

          (vector-fold-right combine knil
                             (vector-unfold knull? kar kdr x))
          => x

     and:

          (vector-unfold knull? kar kdr
                         (vector-fold-right combine knil s))
          => s

     The final vector constructed does not share storage with either
     BASE-VECTOR or the value produced by MAKE-FINAL.

 -- Function: vector-unfold-right STOP? SEED->ITEM MAKE-SEED FIRST-SEED
 -- Function: vector-unfold-right STOP? SEED->ITEM MAKE-SEED FIRST-SEED
          BASE-VECTOR
 -- Function: vector-unfold-right STOP? SEED->ITEM MAKE-SEED FIRST-SEED
          BASE-VECTOR MAKE-FINAL
     This is a fundamental constructor for vectors.  The arguments are
     like the ones of 'vector-unfold'.  The difference from
     'vector-unfold' is that this function builds the vector from right
     to left; more precisely, the following (simple, inefficient)
     definitions hold:

          ;; iterative
          (define (vector-unfold-right
                     stop? seed->item make-seed
                     first-seed base-vector make-final)
            (let lp ((seed    first-seed)
                     (result  base))
              (if (stop? seed)
                  (vector-append (make-final seed) result)
                (loop (make-seed seed)
                      (vector-append (vector (seed->item seed))
                                     result)))))

          ;; recursive
          (define (vector-unfold-right
                     stop? seed->item make-seed
                     first-seed base-vector make-final)
            (vector-append
               (let loop ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (vector-append (loop (make-seed seed))
                                  (vector (seed->item seed)))))
               base))

     Interested functional programmers may enjoy noting that
     'vector-fold' and 'vector-unfold-right' are in some sense inverses.
     That is, given operations KNULL?, KAR, KDR, KONS, and KNIL
     satisfying:

          (kons (kar x) (kdr x)) => x
          (knull? knil) => #t

     then:

          (vector-fold kons knil
                       (vector-unfold-right knull? kar kdr x))
          => x

     and:

          (vector-unfold-right knull? kar kdr
                               (vector-fold kons knil s))
          => s

     The final vector constructed does not share storage with either
     BASE-VECTOR or the value produced by 'make-final'.


File: vicare-libs.info,  Node: vectors fold map,  Prev: vectors fold unfold,  Up: vectors fold

24.7.4 Mapping functions
------------------------

All the functions described here map their PROC function argument over
all the elements of the vector arguments, or the subvector argument,
from zero to the end in increasing order.  In all the following
descriptions:

   * Functions and syntaxes whose main name portion ends without a '!',
     build and return a new vector, storing into it the results of
     mapping PROC.

   * Functions and syntaxes whose main name portion ends with a '!',
     mutate their VEC0 vector argument, storing into it the results of
     mapping PROC.

   * Functions and syntaxes whose main name portion ends without a '*',
     accept only vector arguments of equal length.

   * Functions and syntaxes whose main name portion ends with a '*',
     accept vector arguments of different length, stopping the iteration
     at the end of the shortest.

   * Functions whose name ends without the '/with-index' suffix, apply
     their PROC function argument as:

          (PROC
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            ...)

   * Functions whose name ends with the '/with-index' suffix, apply
     their PROC function argument as:

          (PROC IDX
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            ...)

     where IDX is the index of the current element.

 -- Function: vector-map* PROC VEC0 VEC ...
 -- Function: vector-map/with-index PROC VEC0 VEC ...
 -- Function: vector-map*/with-index PROC VEC0 VEC ...
     Build and return a new vector holding the return values of mapping
     PROC over all the elements of the vector arguments.

 -- Function: vector-map! PROC VEC0 VEC ...
 -- Function: vector-map*! PROC VEC0 VEC ...
 -- Function: vector-map!/with-index PROC VEC0 VEC ...
 -- Function: vector-map*!/with-index PROC VEC0 VEC ...
     Mutate VEC0 setting its elements to the return values of mapping
     PROC over all the elements of the vector arguments.

 -- Function: vector-for-each* PROC VEC0 VEC ...
 -- Function: vector-for-each*/with-index PROC VEC0 VEC ...
     Apply PROC over all the elements of the vector arguments.

Mapping over subvectors
.......................

 -- Function: %subvector-map PROC VEC START PAST
 -- Function: %subvector-map/with-index PROC VEC START PAST
 -- Macro: subvector-map PROC S
 -- Macro: subvector-map/with-index PROC S
     Build and return a new vector mapping PROC over the items in the
     selected subvector of VEC, from index START to index PAST in
     increasing order.

 -- Function: %subvector-map! PROC VEC START PAST
 -- Function: %subvector-map!/with-index PROC VEC START PAST
 -- Macro: subvector-map! PROC S
 -- Macro: subvector-map!/with-index PROC S
     Mutate the selected subvector of VEC, mapping PROC over its items
     from index START to index PAST in increasing order.

 -- Function: %subvector-for-each PROC VEC START PAST
 -- Function: %subvector-for-each/with-index PROC VEC START PAST
 -- Macro: subvector-for-each PROC V
 -- Macro: subvector-for-each/with-index PROC V
     Apply PROC to each item in the selected subvector of VEC, from
     index START to index PAST in increasing order.

 -- Function: %subvector-for-each-index PROC VEC START PAST
 -- Macro: subvector-for-each-index PROC V
     Apply PROC to each index in the selected subvector of VEC, from
     index START to index PAST in increasing order.  This is simply a
     method of looping over a vector that is guaranteed to be safe and
     correct.

Syntax variants
...............

The following syntaxes are like the corresponding functions.  They can
be a little faster when multiple vector arguments are present.

 -- Syntax: vector-map/stx PROC VEC0 VEC ...
 -- Syntax: vector-map*/stx PROC VEC0 VEC ...
     Like 'vector-map' and 'vector-map*', but implemented as a syntax.

 -- Syntax: vector-map!/stx PROC VEC0 VEC ...
 -- Syntax: vector-map*!/stx PROC VEC0 VEC ...
     Like 'vector-map!' and 'vector-map*!', but implemented as a syntax.

 -- Syntax: vector-for-each/stx PROC VEC0 VEC ...
 -- Syntax: vector-for-each*/stx PROC VEC0 VEC ...
     Like 'vector-for-each' and 'vector-for-each*', but implemented as a
     syntax.


File: vicare-libs.info,  Node: vectors select,  Next: vectors pad,  Prev: vectors fold,  Up: vectors

24.8 Selection
==============

 -- Function: %vector-copy VEC START PAST
 -- Macro: subvector* V
 -- Macro: vector-copy V
     Build and return a new vector holding the selected subvector of
     VEC.

 -- Function: %vector-reverse-copy VEC START PAST
 -- Macro: vector-reverse-copy V
     Like '%vector-copy', but copy the elements in the reverse order
     from the selected subvector of VEC.

          (vector-reverse-copy (view '#(5 4 3 2 1 0)
                                 (start 1)
                                 (past  5)))
          => #(1 2 3 4)

 -- Function: %vector-copy! DST-VEC DST-START SRC-VEC SRC-START SRC-PAST
 -- Macro: vector-copy! DST-V SRC-V
     Write the selected source subvector into the selected destination
     subvector.  This function supports copying over the same vector.

     The selected destination subvector starts at DST-START in DST-VEC
     and may extend until the end of the vector.  In the destination
     vector view DST-V: If a past index is specified, it is ignored.

 -- Function: %vector-reverse-copy! DST-VEC DST-START SRC-VEC SRC-START
          SRC-PAST
 -- Macro: vector-reverse-copy! V-DST V-SRC
     Like '%vector-copy!', but this copies the elements in the reverse
     order.  This function supports copying over the same vector.

 -- Function: %vector-take NITEMS VEC START PAST
 -- Function: %vector-take-right NITEMS VEC START PAST
 -- Macro: vector-take V NITEMS
 -- Macro: vector-take-right V NITEMS
     Return the first or last NITEMS of the selected subvector.  These
     functions always return a newly allocated vector.

 -- Function: %vector-drop NITEMS VEC START PAST
 -- Function: %vector-drop-right NITEMS VEC START PAST
 -- Macro: vector-drop V NITEMS
 -- Macro: vector-drop-right V NITEMS
     Drop the first or last NITEMS of the selected subvector and return
     the resulting vector.  These functions always return a newly
     allocated vector.


File: vicare-libs.info,  Node: vectors pad,  Next: vectors prefix,  Prev: vectors select,  Up: vectors

24.9 Padding and trimming
=========================

 -- Function: %vector-pad REQUESTED-LEN FILL-ITEM VEC START PAST
 -- Function: %vector-pad-right REQUESTED-LEN FILL-ITEM VEC START PAST
 -- Macro: vector-pad V REQUESTED-LEN
 -- Macro: vector-pad V REQUESTED-LEN FILL-ITEM
 -- Macro: vector-pad-right V REQUESTED-LEN
 -- Macro: vector-pad-right V REQUESTED-LEN FILL-ITEM
     Build a vector of length REQUESTED-LEN comprised of VEC padded on
     the left or right by as many occurrences of the item FILL-ITEM as
     needed.  Always return a newly allocated vector.

     If VEC has more than REQUESTED-LEN items, it is truncated on the
     left or right to length REQUESTED-LEN.  For the macros: FILL-ITEM
     defaults to '#f'.

          (vector-pad '#(1 2 3))           => #(#f #f 1 2 3)
          (vector-pad '#(1 2 3 4 5) 5)     => #(1 2 3 4 5)
          (vector-pad '#(9 9 1 2 3 4 5) 5) => #(1 2 3 4 5)

 -- Function: %vector-trim PRED VEC START PAST
 -- Function: %vector-trim-right PRED VEC START PAST
 -- Function: %vector-trim-both PRED VEC START PAST
 -- Macro: vector-trim V PRED
 -- Macro: vector-trim-right V PRED
 -- Macro: vector-trim-both V PRED
     Trim the selected subvector of VEC by skipping over all items on
     the left/on the right/on both sides that satisfy PRED: A test
     predicate that is applied to the items in VEC, an item causing it
     to return true is skipped.

     Always return a newly allocated vector.


File: vicare-libs.info,  Node: vectors prefix,  Next: vectors search,  Prev: vectors pad,  Up: vectors

24.10 Prefixes and suffixes
===========================

 -- Function: %vector-prefix-length VEC1 START1 PAST1 VEC2 START2 PAST2
 -- Macro: vector-prefix-length V1 V2
     Return the length of the longest common prefix of the two
     subvectors.  This is equivalent to the mismatch index for the
     vectors (modulo the start index offsets).

 -- Function: %vector-suffix-length VEC1 START1 PAST1 VEC2 START2 PAST2
 -- Macro: vector-suffix-length V1 V2
     Return the length of the longest common suffix of the two
     subvectors.

 -- Function: %vector-prefix? VEC1 START1 PAST1 VEC2 START2 PAST2
 -- Macro: vector-prefix? V1 V2
     Return '#t' if the selected subvector of VEC1 is a prefix of the
     selected subvector of VEC2, otherwise return '#f'.  Notice that the
     empty vector is a prefix of every vector.

 -- Function: %vector-suffix? VEC1 START1 PAST1 VEC2 START2 PAST2
 -- Macro: vector-suffix? V1 V2
     Return '#t' if the selected subvector of VEC1 is a suffix of the
     selected subvector of VEC2, otherwise return '#f'.  Notice that the
     empty vector is *not* a suffix of every vector.


File: vicare-libs.info,  Node: vectors search,  Next: vectors filter,  Prev: vectors prefix,  Up: vectors

24.11 Searching
===============

 -- Function: %vector-index PRED VEC START PAST
 -- Function: %vector-index-right PRED VEC START PAST
 -- Macro: vector-index V PRED
 -- Macro: vector-index-right V PRED
     Search through the subvector from the left or right, returning the
     index of the first occurrence of an item which satisfies the
     predicate PRED.  If no match is found: Return '#f'.

 -- Function: %vector-skip PRED VEC START PAST
 -- Function: %vector-skip-right PRED VEC START PAST
 -- Macro: vector-skip V PRED
 -- Macro: vector-skip-right V PRED
     Search through the vector from the left or right, returning the
     index of the first occurrence of an item which does not satisfy the
     predicate PRED.  If no match is found: Return '#f'.

 -- Function: %vector-count PRED VEC START PAST
 -- Macro: vector-count V PRED
     Return a count of the number of items in VEC that satisfy the PRED
     argument.

 -- Function: %vector-contains VEC1 START1 PAST1 VEC2 START2 PAST2
 -- Macro: vector-contains V1 V2
     Return true if the selected subvector of VEC1 contains the selected
     subvector of VEC2, else return '#f'.  The return value is the index
     in VEC1 where the subvector of VEC2 occurs.

 -- Function: %vector-binary-search OBJ CMP VEC START PAST
 -- Macro: vector-binary-search V OBJ CMP
     Similar to 'vector-index' and 'vector-index-right', but instead of
     searching left to right or right to left, perform a binary search.
     CMP should be a procedure of two arguments and return:

        * A negative integer, indicating that its first argument is less
          than its second.

        * Zero, indicating that they are equal.

        * A positive integer, indicating that the first argument is
          greater than the second argument.

     An example CMP might be:

          (lambda (char1 char2)
            (cond ((char<? char1 char2) -1)
                  ((char=? char1 char2)  0)
                  (else                  1)))


File: vicare-libs.info,  Node: vectors filter,  Next: vectors list,  Prev: vectors search,  Up: vectors

24.12 Filtering and deleting
============================

 -- Function: %vector-filter PRED VEC START PAST
 -- Macro: vector-filter V PRED
     Filter the selected subvector, retaining only those characters that
     satisfy the PRED argument.  Always return a newly allocated vector.

 -- Function: %vector-delete PRED VEC START PAST
 -- Macro: vector-delete V PRED
     Filter the selected subvector, retaining only those characters that
     do *not* satisfy the PRED argument.  Always return a newly
     allocated vector.


File: vicare-libs.info,  Node: vectors list,  Next: vectors replicate,  Prev: vectors filter,  Up: vectors

24.13 List and vector conversion
================================

 -- Function: %vector->list* VEC START PAST
 -- Macro: vector->list* V
     Return a newly allocated list of the items that make up the given
     subvector.  This is an extension of the 'vector->list' function
     that adds support for subvectors.

 -- Function: %reverse-vector->list VEC START PAST
 -- Macro: reverse-vector->list V
     Like '%vector->list*' but reverses the order of the items from the
     subvector.

 -- Function: reverse-list->vector CHAR-LIST
     Reverse the given list of items, then compose a vector with the
     result.

          (reverse-list->vector '(#\a #\B #\c))
          => #(#\c #\B #\a)


File: vicare-libs.info,  Node: vectors replicate,  Next: vectors mutate,  Prev: vectors list,  Up: vectors

24.14 Replicate and rotate
==========================

 -- Function: %xsubvector FROM TO VEC START PAST
 -- Macro: xsubvector V FROM TO
     Extended subvector procedure replicating the selected subvector "up
     and down" index space, in both the positive and negative
     directions.

     The call:

          (%xsubvector from to '#(#\a #\b #\c #\d #\e #\f #\g) 3 6)

     selects the subvector '#(#\d #\e #\f)' and defines the conceptual
     bidirectionally-infinite vector:

          ...  e  f  d  e  f  d  e  f  d  e  f ...
          ... -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 ...
                              ^

     that is '#(#\d #\e #\f)' repeated in both directions.
     '%xsubvector' returns the subvector of this vector beginning at
     index FROM, and ending at TO.

     We can use this function to perform a variety of tasks:

        * To replicate a vector:

               (xsubvector '#(#\a #\b #\c) 0 7)
               => #(#\a #\b #\c #\a #\b #\c #\a)

        * To rotate a vector left:

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) 1  7)
               => #(#\b #\c #\d #\e #\f #\a)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) 2  8)
               => #(#\c #\d #\e #\f #\a #\b)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) 3  9)
               => #(#\d #\e #\f #\a #\b #\c)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) 4 10)
               => #(#\e #\f #\a #\b #\c #\d)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) 5 11)
               => #(#\f #\a #\b #\c #\d #\e)

        * To rotate a vector right:

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) -1 5)
               => #(#\f #\a #\b #\c #\d #\e)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) -2 4)
               => #(#\e #\f #\a #\b #\c #\d)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) -3 3)
               => #(#\d #\e #\f #\a #\b #\c)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) -4 2)
               => #(#\c #\d #\e #\f #\a #\b)

               (xsubvector '#(#\a #\b #\c #\d #\e #\f) -5 1)
               => #(#\b #\c #\d #\e #\f #\a)

     Note that:

        * The FROM/TO indices give a half-open range; the items from
          index FROM up to, but not including, index TO.

        * The FROM/TO indices are not in terms of the index space for
          vector VEC.  They are in terms of the replicated index space
          of the subvector defined by VEC, START, and PAST.

     It is an error if START equals PAST.

 -- Function: xvector-xcopy! FROM TO TARGET TARGET-START SOURCE
          SOURCE-START SOURCE-PAST
 -- Macro: vector-xcopy! TARGET-S SOURCE-S FROM TO
     Exactly the same as '%xsubvector', but the extracted text is
     written into the selected subvector of TARGET.

     This operation is not defined if '(eq? target start)'; we cannot
     copy a vector on top of itself.


File: vicare-libs.info,  Node: vectors mutate,  Next: vectors misc,  Prev: vectors replicate,  Up: vectors

24.15 Mutators
==============

 -- Function: vector-swap! VEC I J
     Swap the items in VEC at positions I and J.

 -- Function: %vector-fill*! FILL-ITEM VEC START PAST
 -- Macro: vector-fill*! V FILL-ITEM
     Fill the selected subvector with FILL-ITEM, modifying the original
     vector.


File: vicare-libs.info,  Node: vectors misc,  Prev: vectors mutate,  Up: vectors

24.16 Miscellaneous functions
=============================

 -- Function: %vector-replace VEC1 START1 PAST1 VEC2 START2 PAST2
 -- Macro: vector-replace V1 V2
     Replace the selected subvector in VEC1 with the selected subvector
     in VEC2.  Return a newly allocated vector.

 -- Function: %vector-reverse VEC START PAST
 -- Function: %vector-reverse! VEC START PAST
 -- Macro: vector-reverse V
 -- Macro: vector-reverse! V
     Reverse the vector.  '%vector-reverse' returns the result vector
     and does not alter its VEC parameter.  '%vector-reverse!' is the
     in-place side-effecting variant.


File: vicare-libs.info,  Node: strings,  Next: char-sets,  Prev: vectors,  Up: Top

25 Strings library
******************

The '(vicare containers strings)' library extends the string operations
available in the base library (*note Strings: (vicare-scheme)baselib
strings.) and Vicare's extensions (*note Additional string functions:
(vicare-scheme)iklib strings.).  While '(vicare containers strings)' is
a high level ainterface, '(vicare containers strings low)' is a low
level interface with the same functionalities.

   To avoid identifiers collision: it is suggested to import the
libraries in the hierarchy '(vicare containers strings ---)' with the
prefix 'string.', as in:

     (import (vicare)
       (prefix (vicare containers strings) string.))

* Menu:

* strings intro::               Introduction.
* strings convention::          Interface conventions.
* strings views::               Views over strings.
* strings cons::                Constructors.
* strings pred::                Predicates.
* strings compar::              Comparison.
* strings map::                 Mapping functions.
* strings case::                Case mapping.
* strings fold::                Fold and unfold.
* strings select::              Selection.
* strings pad::                 Padding and trimming.
* strings prefix::              Prefixes and suffixes.
* strings search::              Searching.
* strings filter::              Filtering and deleting.
* strings list::                List and string conversion.
* strings replicate::           Replicate and rotate.
* strings mutate::              Mutators.
* strings misc::                Miscellaneous functions.
* strings rabin-karp::          Rabin-Karp string search.


File: vicare-libs.info,  Node: strings intro,  Next: strings convention,  Up: strings

25.1 Introduction
=================

Library organisation
....................

The functions are split in a high level library, '(vicare containers
strings)', and a low level one, '(vicare containers strings low)'.  The
main difference between the two layers is that the high level library
makes heavy usage of macros to implement the "string views", which allow
accessing substrings using a friendly syntax.

   All the functions in the low level library are bound to identifiers
starting with '%'; for example: 'string-prefix?' is a high level macro,
'%string-prefix?' is its low level function homologous.

The model for strings
.....................

This library relies on the string representation of the underlying
Scheme implementation: Strings are sequences of "code points" or
character encodings.  Operations such as comparison or reversal are
always done code point by code point.

   It's possible that a legal string might not be a sensible "text"
sequence; for example, consider a string comprised entirely of
zero-width Unicode accent characters with no preceding base character to
modify: It is a legal string, albeit one that does not make sense when
interpreted as a sequence of natural-language text.  The routines in
'(vicare containers strings)' do not handle these "text" concerns.

Direction of iteration
......................

The library accesses the characters of a string in left-to-right or
right-to-left order depending on the convenience of the algorithm.

Handling side effects
.....................

Care must be taken when using functions with side effects.  One reason
for this is that some of the supported Scheme implementations will
collapse equal datum strings in the source code to the same string in
the program.  Mutating such a string in a point of the program, will
make the change visible to other points in the program.  For example:

     (import (rnrs)
       (rnrs mutable-strings))

     (define str1 "abcd")
     (define str2 "abcd")

     (string-set! str1 2 #\9)
     (write str2)

when executed by Ypsilon will print '"ab9d"', while when executed by
Mosh will print '"abcd"' (last verified with revisions checked out on
Fri Jun 5, 2009).  To avoid this problem completely, we can change the
program in this way:

     (import (rnrs)
       (rnrs mutable-strings))

     (define str1 (string-copy "abcd"))
     (define str2 (string-copy "abcd"))

     (string-set! str1 2 #\9)
     (write str2)

of course we may want to wrap into 'string-copy' only the strings that
are meant to be mutated.


File: vicare-libs.info,  Node: strings convention,  Next: strings views,  Prev: strings intro,  Up: strings

25.2 Interface conventions
==========================

The following conventions hold:

   * Procedures whose names end in '-ci' are case-insensitive variants.

   * Procedures whose names end in '!' are side-effecting variants.
     What values these procedures return is usually not specified.

   * The order of common arguments is consistent across the different
     procedures in the high level library, and consistent across the
     different procedures in the low level library.  Arguments to some
     functions in the high level library have different order from the
     ones of the homologous low level functions.

   * Procedures that have left/right directional variants use the
     following convention:

     Direction       Suffix
     -------------------------
     left-to-right   ?NONE
     right-to-left   -right
     both            -both

   In the procedure specifications:

   * An S argument is a string view, which is expanded by a macro in a
     triplet of values: the string, the index of the first char in the
     selected substring, the index of the character past the last in the
     selected position.  *note strings views:: for details.

   * A STR argument is a string.

   * A CHAR argument is a character.

   * The START and PAST arguments are half-open string indices
     specifying a substring within a string argument; when unspecified,
     they default to zero and the length of the string, respectively.
     When specified, it must be the case that:

          0 <= start <= past <= (string-length s)

     for the corresponding argument STR.  They typically restrict a
     procedure's action to the indicated substring; when START equals
     PAST the selected substring is the empty string.

   * A PRED argument is a unary character predicate procedure, returning
     a true/false value when applied to a character.

   * A CHAR/CHAR-SET/PRED argument is a value used to select/search for
     a character in a string.  If it is a character, it is used in an
     equality test; if it is a character set, it is used in a membership
     test; if it is a procedure, it is applied to the characters as a
     test predicate.

   * An I or K argument is an exact non-negative integer specifying an
     index into a string.

   * The LEN and NCHARS arguments are exact non-negative integers
     specifying a length of a string or some number of characters.

   * An OBJ argument can be any value.

   An argument followed by '...' means zero-or-more elements.  So the
procedure with the signature:

     sum-squares x ...

takes zero or more arguments (X, ...), while the procedure with
signature:

     spell-check doc dict1 dict2 ...

takes two mandatory arguments (DOC and DICT1) and zero or more optional
arguments (DICT2 ...).

   If a procedure is said to return "unspecified", this means that
nothing at all is known about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g.  as the value of an expression appearing as a
non-terminal subform of a begin expression.

   Comparison is simply done on individual code-points of the string.
Unless explicitly stated, for all the functions: Case-insensitive
comparison is done using the functions:

     char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?

provided by the underlying implementation, or by case-folding characters
with the operation:

     (char-downcase (char-upcase c))

where the two case-mapping operations are assumed to be one-to-one,
locale-insensitive and context-insensitive, and compatible with the
one-to-one case mappings specified by Unicode's 'UnicodeData.txt' table:

        <ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt>


File: vicare-libs.info,  Node: strings views,  Next: strings cons,  Prev: strings convention,  Up: strings

25.3 Views over strings
=======================

String views are syntactic sugar to allow substring specification with
minimum overhead; views make use of auxiliary syntaxes exported by the
library '(vicare containers auxiliary-syntaxes)' and reexported by the
'(vicare containers strings)' library.  Many low level string functions
act on substrings specified with triplets of arguments:

   * The full string.

   * The "start index": The index of the first code point included in
     the selected substring.

   * The "past index": The index of the code point past the last code
     point included in the selected substring.

   To select the substring '"hello"' from the string '"ciao, hello,
salut"' we have to determine the half-open range of code points, which
is [6, 11), then apply a function to the arguments:

     (%the-function "ciao, hello, salut" 6 11)

     ;;              0123456789012345678
     ;;              0         1

while to select the whole string we can do:

     (%the-function "ciao, hello, salut" 0 18)

or:

     (let ((str "ciao, hello, salut"))
       (%the-function str 0 (string-length str)))

   With the string views implemented by '(vicare containers strings)',
the low level function is wrapped by a high level syntax which can be
invoked as:

     (the-function "ciao, hello, salut")
             ; select the whole string

     (the-function (view "ciao, hello, salut"))
             ; select the whole string

     (the-function (view "ciao, hello, salut"
                     (start 6)))
             ; select the substring [6, 18)

     (the-function (view "ciao, hello, salut"
                     (start 6)
                     (past 11)))
             ; select the substring [6, 11)

     (the-function (view "ciao, hello, salut"
                     (past 11)))
             ; select the substring [0, 11)

instead of a triplet of arguments, the string view is a single argument
that can be:

'?STRING'
'(view ?STRING)'
     The string itself or an unquoted list holding the string itself,
     prefixed by the 'view' auxiliary syntax: It selects the whole
     string.

'(view ?STRING (start ?START-INDEX))'
     An unquoted list holding the string and the start index, with
     auxiliary syntaxes 'view' and 'start': it selects the substring
     from the start index to the end.

'(view ?STRING (past ?PAST-INDEX))'
     An unquoted list holding the string and the past index, with
     auxiliary syntaxes 'view' and 'past': it selects the substring from
     zero to the selected past index.

'(view ?STRING (start ?START-INDEX) (past ?PAST-INDEX))'
     An unquoted list holding the string, the start index and the past
     index, with auxiliary syntaxes 'view', 'start' and 'past': it
     selects the substring between the start and past indexes.

'?STRING', '?START-INDEX' and '?PAST-INDEX' can be arbitrary Scheme
expressions.  High level macros accepting two or more substrings as
arguments, support string views for all of them.  When we are concerned
with the overhead of string views, we can use the low level functions
directly.

   When the start and past index are negative, the 'view' syntax
normalises them as:

     (if (negative? IDX)
         (+ IDX (string-length STRING))
        IDX)

so that negative indices are counted from the end of the string: -1
selects the ultimate character, -2 selected the penultimate character
and so on.

   In the following documentation: low level functions and high level
macros are documented together; only the meaning of arguments to the low
level function are described, the meaning of high level arguments is
obvious.


File: vicare-libs.info,  Node: strings cons,  Next: strings pred,  Prev: strings views,  Up: strings

25.4 Constructors
=================

 -- Function: string-concatenate STRING-LIST
     Append the elements of STRING-LIST together into a single string.
     Guaranteed to return a freshly allocated string.

 -- Function: %string-concatenate-reverse STRING-LIST FINAL-STRING
          NCHARS
 -- Macro: string-concatenate-reverse STRING-LIST
 -- Macro: string-concatenate-reverse STRING-LIST FINAL-STRING
 -- Macro: string-concatenate-reverse STRING-LIST FINAL-STRING NCHARS
     Reverse STRING-LIST then concatenate the elements, which must be
     strings.  The first NCHARS code points in FINAL-STRING are consed
     onto the beginning of STRING-LIST before performing the reversal
     and concatenation operations.

     FINAL-STRING defaults to the empty string and NCHARS defaults to
     the length of FINAL-STRING.

     This procedure is useful in the construction of procedures that
     accumulate character data into lists of string buffers, and wish to
     convert the accumulated data into a single string when done.

 -- Function: string-tabulate INTEGER->CHAR LEN
     Construct a string of size LEN by applying INTEGER->CHAR to each
     index in the range [0, LEN) to produce the corresponding string
     element.  The order in which INTEGER->CHAR is applied to the
     indices is not specified.


File: vicare-libs.info,  Node: strings pred,  Next: strings compar,  Prev: strings cons,  Up: strings

25.5 Predicates
===============

 -- Function: string-null? OBJ
     Return '#t' if OBJ is the empty string, otherwise return '#f'.

 -- Function: %string-every CHAR/CHAR-SET/PRED STR START PAST
 -- Function: %string-any CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-every CHAR/CHAR-SET/PRED S
 -- Macro: string-any CHAR/CHAR-SET/PRED S
     Check to see if the given criteria is true on every/any character
     in STR, proceeding from left (index START) to right (index PAST).

     If the selected substring is empty, the return value is '#f'.

     If CHAR/CHAR-SET/PRED is a character, it is tested for equality
     with the elements of S.

     If CHAR/CHAR-SET/PRED is a character set, the elements of S are
     tested for membership in the set.

     If CHAR/CHAR-SET/PRED is a predicate procedure, it is applied to
     the elements of S.  The predicate is "witness-generating":

        * If 'string-any' returns true, the returned true value is the
          one produced by the application of the predicate.

        * If 'string-every' returns true, the returned true value is the
          one produced by the application of the predicate to the last
          code point in the substring.

     If the predicate is applied to the final element of the selected
     substring, that final application is a tail call.

     The names of these procedures do not end with a question mark; this
     is to indicate that, in the predicate case, they do not return a
     simple boolean ('#t' or '#f'), but a general value.


File: vicare-libs.info,  Node: strings compar,  Next: strings map,  Prev: strings pred,  Up: strings

25.6 Comparison
===============

* Menu:

* strings compar lexi::         Lexicographic comparison.
* strings compar dict::         String dictionary comparison.
* strings compar number::       String and numeric parts lexicographic
                                comparison.
* strings compar dictnumber::   String and numeric parts dictionary
                                comparison.


File: vicare-libs.info,  Node: strings compar lexi,  Next: strings compar dict,  Up: strings compar

25.6.1 Lexicographic comparison
-------------------------------

 -- Function: %string-compare STR1 BEG1 PAST1 STR2 BEG2 PAST2 PROC<
          PROC= PROC>
 -- Function: %string-compare-ci STR1 BEG1 PAST1 STR2 BEG2 PAST2 PROC<
          PROC= PROC>
 -- Macro: string-compare S1 S2 PROC< PROC= PROC>
 -- Macro: string-compare-ci S1 S2 PROC< PROC= PROC>
     Determine the "mismatch index" between the two substrings: the
     largest index i such that for every 0 <= j < i, str1[j] = str2[j];
     that is, i is the first position that does not match.

     The mismatch index is always an index into STR1; in the case of
     equal strings, it is always PAST1; the functions observe the
     protocol in this redundant case for uniformity.

     The characters at the mismatch index are compared using 'char<?' or
     'char-ci<?'.  PROC<, PROC=, or PROC> are applied to the mismatch
     index (not character), depending upon whether the substring of STR1
     is less than, equal to, or greater than the substring of STR2.  The
     result of the application is returned.

     If we just want to have the mismatch index as return value: We can
     use 'values' as value for PROC<, PROC= and PROC>.  Another
     interesting option is to use '(lambda (mismatch-index) #f)' or
     '(lambda (mismatch-index) #t)'.

     Examples:

          (string-compare "abcd" "abcd" values values values)
          => 4

          (string-compare "abcd" "abcd12" values values values)
          => 4

 -- Function: %string= STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Function: %string-ci= STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Macro: string= S1 S2
 -- Macro: string-ci= S1 S2
     Compare two substrings: Return true if they are equal according to
     'char=?' or 'char-ci=?', '#f' otherwise.

 -- Function: %string<> STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Function: %string-ci<> STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Macro: string<> S1 S1
 -- Macro: string-ci<> S1 S2
     Compare two substrings: Return '#f' if they are equal according to
     'char=?' or 'char-ci=?', true otherwise.

   The following predicates are the lexicographic extensions of the
corresponding character predicates.  A string STR1 is
"lexicographically" less than STR2 if STR1 would come first in a
dictionary.

 -- Function: %string< STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Function: %string-ci< STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Macro: string< S1 S2
 -- Macro: string-ci< S1 S2
     Compare two substrings: Return true if the first is
     lexicographically less than the second, '#f' otherwise.  If STR2 is
     longer than STR1 but the substrings are equal up to the end of
     STR1: Return '#t'.

          (string< "abcd" "abcd") => #f
          (string< "abc"  "abcd") => #t
          (string< "abcd" "abc") => #f
          (string< "ABcd" "abcd") => #t
          (string< "abcd" "a2cd") => #f

          (string-ci< "abcd" "abcd") => #f
          (string-ci< "abc"  "abcd") => #t
          (string-ci< "abcd" "abc") => #f
          (string-ci< "ABcd" "abcd") => #f
          (string-ci< "abcd" "a2cd") => #f

 -- Function: %string<= STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Function: %string-ci<= STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Macro: string<= S1 S2
 -- Macro: string-ci<= S1 S2
     Compare two substrings: Return true if the first is
     lexicographically less than, or equal to, the second; '#f'
     otherwise.  If STR2 is longer than STR1 but the substrings are
     equal up to the end of STR1: Return '#t'.

          (string<= "abcd" "abcd") => #t
          (string<= "abc"  "abcd") => #t
          (string<= "abcd" "abc") => #f
          (string<= "ABcd" "abcd") => #t
          (string<= "abcd" "a2cd") => #f

          (string-ci<= "abcd" "abcd") => #t
          (string-ci<= "abc"  "abcd") => #t
          (string-ci<= "abcd" "abc") => #f
          (string-ci<= "ABcd" "abcd") => #t
          (string-ci<= "abcd" "a2cd") => #f

 -- Function: %string> STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Function: %string-ci> STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Macro: string> S1 S2
 -- Macro: string-ci> S1 S2
     Compare two substrings: Return true if the first is
     lexicographically greater than the second, '#f' otherwise.  If STR1
     is longer than STR2 but the substrings are equal up to the end of
     STR2: Return '#t'.

          (string> "abcd" "abcd") => #f
          (string> "abcd" "abc") => #t
          (string> "abc"  "abcd") => #f
          (string> "abcd" "ABcd") => #t
          (string> "a2cd" "abcd") => #f

          (string-ci> "abcd" "abcd") => #f
          (string-ci> "abcd" "abc") => #t
          (string-ci> "abc"  "abcd") => #f
          (string-ci> "abcd" "ABcd") => #f
          (string-ci> "a2cd" "abcd") => #f

 -- Function: %string>= STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Function: %string-ci>= STR1 BEG1 PAST1 STR2 BEG2 PAST2
 -- Macro: string>= S1 S2
 -- Macro: string-ci>= S1 S2
     Compare two substrings: Return true if the first is
     lexicographically greater than, or equal to, the second; '#f'
     otherwise.  If STR1 is longer than STR2 but the substrings are
     equal up to the end of STR2: Return '#t'.

          (string>= "abcd" "abcd") => #t
          (string>= "abcd" "abc") => #t
          (string>= "abc" "abcd") => #f
          (string>= "abcd" "ABcd") => #t
          (string>= "a2cd" "abcd") => #f

          (string-ci>= "abcd" "abcd") => #t
          (string-ci>= "abcd" "abc") => #t
          (string-ci>= "abc"  "abcd") => #f
          (string-ci>= "abcd" "ABcd") => #t
          (string-ci>= "a2cd" "abcd") => #f


File: vicare-libs.info,  Node: strings compar dict,  Next: strings compar number,  Prev: strings compar lexi,  Up: strings compar

25.6.2 String dictionary comparison
-----------------------------------

Dictionary comparison is like lexicographic string comparison, but white
space characters in the string arguments are ignored; for example, the
string 'foo 4bar\t3za\nb10' is equivalent to 'foo4bar3zab10'.
Recognised white spaces are:

     #\space         #\tab           #\vtab
     #\linefeed      #\return        #\page

 -- Function: string-dictionary-compare STR1 STR2
 -- Function: %string-dictionary-compare STR1 STR2
     Compare the string arguments and return a ternary result: '-1' if
     STR1 is less than STR2, '0' if STR1 is equal to STR2, '+1' if STR1
     is greater than STR2.  The comparison is case sensitive.

 -- Function: string-dictionary=? STR1 STR2
 -- Function: string-dictionary<>? STR1 STR2
 -- Function: string-dictionary<? STR1 STR2
 -- Function: string-dictionary<=? STR1 STR2
 -- Function: string-dictionary>? STR1 STR2
 -- Function: string-dictionary>=? STR1 STR2
 -- Function: %string-dictionary=? STR1 STR2
 -- Function: %string-dictionary<>? STR1 STR2
 -- Function: %string-dictionary<? STR1 STR2
 -- Function: %string-dictionary<=? STR1 STR2
 -- Function: %string-dictionary>? STR1 STR2
 -- Function: %string-dictionary>=? STR1 STR2
     Return '#t' or '#f', whether the string-dictionary arguments comply
     with the predicate.

 -- Function: string-dictionary-compare-ci STR1 STR2
 -- Function: %string-dictionary-compare-ci STR1 STR2
     Compare the string arguments and return a ternary result: '-1' if
     STR1 is less than STR2, '0' if STR1 is equal to STR2, '+1' if STR1
     is greater than STR2.  The comparison is case insensitive.

 -- Function: string-dictionary-ci=? STR1 STR2
 -- Function: string-dictionary-ci<>? STR1 STR2
 -- Function: string-dictionary-ci<? STR1 STR2
 -- Function: string-dictionary-ci>? STR1 STR2
 -- Function: string-dictionary-ci<=? STR1 STR2
 -- Function: string-dictionary-ci>=? STR1 STR2
 -- Function: %string-dictionary-ci=? STR1 STR2
 -- Function: %string-dictionary-ci<>? STR1 STR2
 -- Function: %string-dictionary-ci<? STR1 STR2
 -- Function: %string-dictionary-ci>? STR1 STR2
 -- Function: %string-dictionary-ci<=? STR1 STR2
 -- Function: %string-dictionary-ci>=? STR1 STR2
     Return '#t' or '#f', whether the string arguments comply with the
     predicate.  The comparison is case insensitive.


File: vicare-libs.info,  Node: strings compar number,  Next: strings compar dictnumber,  Prev: strings compar dict,  Up: strings compar

25.6.3 String and numeric parts lexicographic comparison
--------------------------------------------------------

String/numbers comparison splits the strings to compare into their
numeric and non-numeric parts and compares the parts one by one; for
example, the string 'foo4bar3zab10' is split into the following list:

     ("foo" 4 "bar" 3 "zab" 10)

in which non-numeric parts are retained as Scheme strings and numeric
parts become exact integers; numeric parts only become *exact* integer,
never flonums.  String parts are compared with the ordinary
lexicographic operators 'string<?' and 'string=?' (or 'string-ci<?' and
'string-ci=?'), while numeric parts are compared with the ordinary '<'
and '=' operators; a string part and a numeric part are compared by
converting the number into a string, then using 'string<?' and
'string=?'.

   Miscellaneous examples:

     (string/numbers<? "123" "45")
     => #f

     (string/numbers<? "ciao3" "ciao10")
     => #t

     (string/numbers<? "foo4bar3zab10" "foo4bar3zab2")
     => #f

     (string/numbers<? "foo4bar10" "foo4bar3zab")
     => #f

 -- Function: string/numbers-compare STR1 STR2
 -- Function: %string/numbers-compare STR1 STR2
     Compare the string and numeric parts of the arguments and return a
     ternary result: '-1' if STR1 is less than STR2, '0' if STR1 is
     equal to STR2, '+1' if STR1 is greater than STR2.  The comparison
     is case sensitive.

 -- Function: string/numbers=? STR1 STR2
 -- Function: string/numbers<>? STR1 STR2
 -- Function: string/numbers<? STR1 STR2
 -- Function: string/numbers<=? STR1 STR2
 -- Function: string/numbers>? STR1 STR2
 -- Function: string/numbers>=? STR1 STR2
 -- Function: %string/numbers=? STR1 STR2
 -- Function: %string/numbers<>? STR1 STR2
 -- Function: %string/numbers<? STR1 STR2
 -- Function: %string/numbers<=? STR1 STR2
 -- Function: %string/numbers>? STR1 STR2
 -- Function: %string/numbers>=? STR1 STR2
     Return '#t' or '#f', whether the string arguments comply with the
     predicate.

 -- Function: string/numbers-compare-ci STR1 STR2
 -- Function: %string/numbers-compare-ci STR1 STR2
     Compare the string and numeric parts of the arguments and return a
     ternary result: '-1' if STR1 is less than STR2, '0' if STR1 is
     equal to STR2, '+1' if STR1 is greater than STR2.  The comparison
     is case insensitive.

 -- Function: string/numbers-ci=? STR1 STR2
 -- Function: string/numbers-ci<>? STR1 STR2
 -- Function: string/numbers-ci<? STR1 STR2
 -- Function: string/numbers-ci>? STR1 STR2
 -- Function: string/numbers-ci<=? STR1 STR2
 -- Function: string/numbers-ci>=? STR1 STR2
 -- Function: %string/numbers-ci=? STR1 STR2
 -- Function: %string/numbers-ci<>? STR1 STR2
 -- Function: %string/numbers-ci<? STR1 STR2
 -- Function: %string/numbers-ci>? STR1 STR2
 -- Function: %string/numbers-ci<=? STR1 STR2
 -- Function: %string/numbers-ci>=? STR1 STR2
     Return '#t' or '#f', whether the string arguments comply with the
     predicate.  The comparison is case insensitive.


File: vicare-libs.info,  Node: strings compar dictnumber,  Prev: strings compar number,  Up: strings compar

25.6.4 String and numeric parts dictionary comparison
-----------------------------------------------------

String/numbers dictionary comparison is like string/numbers comparison,
but white space characters in the string arguments are ignored; for
example, the string 'foo 4bar\t3za\nb10' is split into the following
list:

     ("foo" 4 "bar" 3 "zab" 10)

in which non-numeric parts are retained as Scheme strings, numeric parts
become exact integers and white spaces are dropped.  Recognised white
spaces are:

     #\space         #\tab           #\vtab
     #\linefeed      #\return        #\page

 -- Function: string/numbers-dictionary-compare STR1 STR2
 -- Function: %string/numbers-dictionary-compare STR1 STR2
     Compare the string and numeric parts of the arguments and return a
     ternary result: '-1' if STR1 is less than STR2, '0' if STR1 is
     equal to STR2, '+1' if STR1 is greater than STR2.  The comparison
     is case sensitive.

 -- Function: string/numbers-dictionary=? STR1 STR2
 -- Function: string/numbers-dictionary<>? STR1 STR2
 -- Function: string/numbers-dictionary<? STR1 STR2
 -- Function: string/numbers-dictionary<=? STR1 STR2
 -- Function: string/numbers-dictionary>? STR1 STR2
 -- Function: string/numbers-dictionary>=? STR1 STR2
 -- Function: %string/numbers-dictionary=? STR1 STR2
 -- Function: %string/numbers-dictionary<>? STR1 STR2
 -- Function: %string/numbers-dictionary<? STR1 STR2
 -- Function: %string/numbers-dictionary<=? STR1 STR2
 -- Function: %string/numbers-dictionary>? STR1 STR2
 -- Function: %string/numbers-dictionary>=? STR1 STR2
     Return '#t' or '#f', whether the string arguments comply with the
     predicate.

 -- Function: string/numbers-dictionary-compare-ci STR1 STR2
 -- Function: %string/numbers-dictionary-compare-ci STR1 STR2
     Compare the string and numeric parts of the arguments and return a
     ternary result: '-1' if STR1 is less than STR2, '0' if STR1 is
     equal to STR2, '+1' if STR1 is greater than STR2.  The comparison
     is case insensitive.

 -- Function: string/numbers-dictionary-ci=? STR1 STR2
 -- Function: string/numbers-dictionary-ci<>? STR1 STR2
 -- Function: string/numbers-dictionary-ci<? STR1 STR2
 -- Function: string/numbers-dictionary-ci>? STR1 STR2
 -- Function: string/numbers-dictionary-ci<=? STR1 STR2
 -- Function: string/numbers-dictionary-ci>=? STR1 STR2
 -- Function: %string/numbers-dictionary-ci=? STR1 STR2
 -- Function: %string/numbers-dictionary-ci<>? STR1 STR2
 -- Function: %string/numbers-dictionary-ci<? STR1 STR2
 -- Function: %string/numbers-dictionary-ci>? STR1 STR2
 -- Function: %string/numbers-dictionary-ci<=? STR1 STR2
 -- Function: %string/numbers-dictionary-ci>=? STR1 STR2
     Return '#t' or '#f', whether the string arguments comply with the
     predicate.  The comparison is case insensitive.


File: vicare-libs.info,  Node: strings map,  Next: strings case,  Prev: strings compar,  Up: strings

25.7 Mapping functions
======================

 -- Function: string-map PROC STR0 STR ...
     Build and return a newly allocated string mapping PROC over all the
     characters of the string arguments, from zero to the end in
     increasing order.  It is an error if the strings have different
     length.

     PROC must return a character and it is applied to the elements as:

          (PROC IDX
            (string-ref STR0 IDX)
            (string-ref STR  IDX)
            ...)

     where IDX is the current index.

 -- Function: string-map! PROC STR0 STR ...
 -- Function: string-map*! PROC STR0 STR ...
     Mutate string STR0 mapping PROC over all the elements of the string
     arguments, from zero to the end in increasing order.

     'string-map!' must be applied to strings of the same length;
     'string-map*!' accepts strings of different length and iterates
     until the end of the shorter is reached.

     PROC is applied to the elements as:

          (PROC IDX
            (string-ref STR0 IDX)
            (string-ref STR  IDX)
            ...)

     where IDX is the current index.

 -- Function: string-for-each* PROC STR0 STR ...
     Apply PROC over all the elements of the string arguments, from zero
     to the end in increasing order.  This function accepts strings of
     different length and iterates until the end of the shorter is
     reached.

     PROC is applied to the elements as:

          (PROC IDX
            (string-ref STR0 IDX)
            (string-ref STR  IDX)
            ...)

     where IDX is the current index.

Mapping over substrings
.......................

 -- Function: %substring-map PROC STR START PAST
 -- Macro: substring-map PROC S
     Build and return a new string mapping PROC over the characters in
     the selected substring of STR, from index START to index PAST in
     increasing order.  PROC must be a 'char->char' procedure.

 -- Function: %substring-map! PROC STR START PAST
 -- Macro: substring-map! PROC S
     Mutate the selected substring of STR, mapping PROC over its
     characters from index START to index PAST in increasing order.
     PROC must be a 'char->char' procedure.

 -- Function: %substring-for-each PROC STR START PAST
 -- Macro: substring-for-each PROC S
     Apply PROC to each character in the selected substring of STR, from
     index START to index PAST in increasing order.

 -- Function: %substring-for-each-index PROC STR START PAST
 -- Macro: substring-for-each-index PROC S
     Apply PROC to each index in the selected substring of STR, from
     index START to index PAST in increasing order.  This is simply a
     method of looping over a string that is guaranteed to be safe and
     correct.


File: vicare-libs.info,  Node: strings case,  Next: strings fold,  Prev: strings map,  Up: strings

25.8 Case mapping
=================

 -- Function: %string-titlecase*! STR START PAST
 -- Macro: string-titlecase* S
 -- Macro: string-titlecase*! S
     For every character c in the selected range of STR, if c is
     preceded by a cased character, it is downcased; otherwise it is
     titlecased.

     'string-titlecase*' returns the result string and does not alter
     its s argument.  'string-titlecase!' is the in-place side-effecting
     variant.

     Examples:

          (string-titlecase* "--capitalize tHIS sentence.")
          => "--Capitalize This Sentence."

          (string-titlecase* "see Spot run. see Nix run.")
          => "See Spot Run. See Nix Run."

          (string-titlecase* "3com makes routers.")
          => "3Com Makes Routers."

     Note that the character preceding 'str[start]' has no effect on the
     titlecase decision for character 'str[start]':

          (string-titlecase* ("greasy fried chicken" 2))
          => "Easy Fried Chicken"

 -- Macro: string-upcase* S
 -- Macro: string-upcase*! S
 -- Macro: string-downcase* S
 -- Macro: string-downcase*! S
     Raise or lower the case of the alphabetic characters in the string.
     There are no low level functions for these macros because they are
     just wrappers for '%string-map' and '%string-map!'.

     'string-upcase' and 'string-downcase' return the result string and
     do not alter their argument.  'string-upcase!' and
     'string-downcase!' are the in-place side-effecting variants.


File: vicare-libs.info,  Node: strings fold,  Next: strings select,  Prev: strings case,  Up: strings

25.9 Fold and unfold
====================

 -- Function: string-fold-left KONS KNIL STR0 STR ...
 -- Function: string-fold-right KONS KNIL STR0 STR ...
     The fundamental string iterator.  The string arguments must have
     the same length.

     KONS is iterated left-to-right over each index in all of the
     strings, stopping at the end of the shortest; KONS is applied as:

          (KONS IDX STATE
            (string-ref STR0 IDX)
            (string-ref STR  IDX)
            )

     where STATE is the current state value; the current state value
     begins with KNIL, and becomes whatever KONS returned at the
     respective iteration; IDX is the current index.

     'string-fold-right' is similar to 'string-fold', but it iterates
     right-to-left.

          Notice that to allow for an unspecified number of arguments,
          these folds hand the state as first argument to KONS, as
          opposed to the usual fold arguments.

 -- Function: string-fold-left* KONS KNIL STR0 STR ...
 -- Function: string-fold-right* KONS KNIL STR0 STR ...
     Like 'string-fold' and 'string-unfold' but accept strings of
     different length, iterating until the end of the shortest one.

 -- Function: %substring-fold-left KONS KNIL STR START PAST
 -- Function: %substring-fold-right KONS KNIL STR START PAST
 -- Macro: string-fold KONS KNIL S
 -- Macro: string-fold-right KONS KNIL S
     Fundamental iterators for substrings.  KONS is iterated over each
     character of the selected substring:

          (KONS
            (string-ref STR (+ START IDX))
            STATE)

     where STATE is the current state value; the current state value
     begins with KNIL, and becomes whatever KONS returned at the
     respective iteration; IDX is the current index.

     The left-fold iterator, '%substring-fold-left', builds the return
     value as:

          (KONS
            (string-ref STR (- PAST 1))
            (KONS
              (string-ref STR (- PAST 2))
              ...
                (KONS
                  (string-ref STR (+ START 2))
                  (KONS
                     (string-ref STR (+ START 1))
                     (KONS
                        (string-ref STR START)
                        KNIL)))))

     The right-fold iterator, '%substring-fold-right', builds the return
     value as:

          (KONS
            (string-ref STR START
            (KONS
              (string-ref STR (+ START 1))
              ...
                (KONS
                  (string-ref STR (- PAST 3))
                  (KONS
                     (string-ref STR (- PAST 2))
                     (KONS
                        (string-ref STR (- PAST 1))
                        KNIL)))))

     Examples:

          ;; Convert a string to a list of chars.
          (substring-fold-left cons '() "abcd")
          => (#\d #\c #\b #\a))

          ;; Count the number of upper-case characters in a string.
          (substring-fold-left (lambda (c count)
                                 (if (char-upper-case? c)
                                     (+ count 1)
                                   count))
                               0
                               "ABCdefGHi")
          => 5

          ;; Double every backslash character in S.
          (let* ((str "abc\\de\\f\\ghi")
                 (ans-len (string-fold
                           (lambda (c sum)
                             (+ sum (if (char=? c #\\) 2 1)))
                           0 str))
                 (ans (make-string ans-len)))
            (substring-fold-left
             (lambda (c i)
               (let ((i (if (char=? c #\\)
                            (begin
                              (string-set! ans i #\\)
                              (+ i 1))
                          i)))
                  (string-set! ans i c)
                  (+ i 1)))
              0 str)
             ans)
          => "abc\\\\de\\\\f\\\\ghi"

 -- Function: string-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
 -- Function: string-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STRING
 -- Function: string-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STRING MAKE-FINAL
     This is a fundamental constructor for strings.  Arguments
     description follows.

     MAKE-SEED
          A map function used to generate a series of "seed" values from
          the initial seed:

               FIRST-SEED
               (MAKE-SEED FIRST-SEED)            => seed2
               (MAKE-SEED seed2)                 => seed3
               (MAKE-SEED seed3)                 => seed4
               ...

     STOP?
          A predicate function telling when to stop generating
          characters; when it returns true when applied to one of the
          seed values.

     SEED->CHAR
          Map function mapping each seed value to the corresponding
          character in the result string.  These chars are assembled
          into the string in a left-to-right order.

     BASE-STRING
          An optional string which is used as initial/leftmost portion
          of the constructed string.  Defaults to the empty string.

     MAKE-FINAL
          Optional function applied to the terminal seed value (on which
          STOP? returns true) to produce the final/rightmost portion of
          the constructed string.  Defaults to '(lambda (x) "")'.

     More precisely, the following (simple, inefficient) definitions
     hold:

          ;; iterative
          (define (string-unfold stop? seed->char make-seed
                                 first-seed base-string make-final)
            (let loop ((seed    first-seed)
                       (result  base-string))
              (if (stop? seed)
                  (string-append result (make-final seed))
                (loop (make-seed seed)
                      (string-append result
                                     (string (seed->char seed)))))))

          ;; recursive
          (define (string-unfold stop? seed->char make-seed
                                 first-seed base-string make-final)
            (string-append
               base-string
               (let loop ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (string-append (string (seed->char seed))
                                  (loop (make-seed seed)))))))

     This function is a fairly powerful string constructor; we can use
     it to convert a list to a string, read a port into a string,
     reverse a string, copy a string, and so forth.  Examples:

          (port->string p) = (string-unfold eof-object? values
                                            (lambda (x) (read-char p))
                                            (read-char p))

          (list->string lis) = (string-unfold null? car cdr lis)

          (string-tabulate f size) = (string-unfold (lambda (i)
                                                      (= i size))
                                                    f add1 0)

     to map 'proc' over a list LIS, producing a string:

          (string-unfold null? (compose proc car) cdr lis)

     Interested functional programmers may enjoy noting that
     'string-fold-right' and 'string-unfold' are in some sense inverses.
     That is, given operations KNULL?, KAR, KDR, KONS, and KNIL
     satisfying:

          (kons (kar x) (kdr x)) => x
          (knull? knil) => #t

     then:

          (string-fold-right kons knil
                             (string-unfold knull? kar kdr x))
          => x

     and:

          (string-unfold knull? kar kdr
                         (string-fold-right kons knil s))
          => s

     The final string constructed does not share storage with either
     BASE-STRING or the value produced by MAKE-FINAL.

 -- Function: string-unfold-right STOP? SEED->CHAR MAKE-SEED FIRST-SEED
 -- Function: string-unfold-right STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STRING
 -- Function: string-unfold-right STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STRING MAKE-FINAL
     This is a fundamental constructor for strings.  The arguments are
     like the ones of 'string-unfold'.  The difference from
     'string-unfold' is that this function builds the string from right
     to left; more precisely, the following (simple, inefficient)
     definitions hold:

          ;; iterative
          (define (string-unfold-right
                     stop? seed->char make-seed
                     first-seed base-string make-final)
            (let lp ((seed    first-seed)
                     (result  base))
              (if (stop? seed)
                  (string-append (make-final seed) result)
                (loop (make-seed seed)
                      (string-append (string (seed->char seed))
                                     result)))))

          ;; recursive
          (define (string-unfold-right
                     stop? seed->char make-seed
                     first-seed base-string make-final)
            (string-append
               (let loop ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (string-append (loop (make-seed seed))
                                  (string (seed->char seed)))))
               base))

     Interested functional programmers may enjoy noting that
     'string-fold' and 'string-unfold-right' are in some sense inverses.
     That is, given operations KNULL?, KAR, KDR, KONS, and KNIL
     satisfying:

          (kons (kar x) (kdr x)) => x
          (knull? knil) => #t

     then:

          (string-fold kons knil
                       (string-unfold-right knull? kar kdr x))
          => x

     and:

          (string-unfold-right knull? kar kdr
                               (string-fold kons knil s))
          => s

     The final string constructed does not share storage with either
     BASE-STRING or the value produced by MAKE-FINAL.

