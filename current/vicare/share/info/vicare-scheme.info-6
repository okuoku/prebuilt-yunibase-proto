This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: syslib numerics sub,  Next: syslib numerics mul,  Prev: syslib numerics add,  Up: syslib numerics

12.10.6 Numbers subtraction
---------------------------

 -- Unsafe Operation: $sub-number-number NUM1 NUM2
     Subtract any couple of numbers and return the result.

Generic number as second operand
................................

 -- Unsafe Operation: $sub-fixnum-number FX NUM
     Subtract a fixnum with a number and return the result.

 -- Unsafe Operation: $sub-bignum-number BN NUM
     Subtract a bignum with a number and return the result.

 -- Unsafe Operation: $sub-flonum-number FL NUM
     Subtract a flonum with a number and return the result.

 -- Unsafe Operation: $sub-ratnum-number RT NUM
     Subtract a ratnum with a number and return the result.

 -- Unsafe Operation: $sub-compnum-number CN NUM
     Subtract a compnum with a number and return the result.

 -- Unsafe Operation: $sub-cflonum-number CFL NUM
     Subtract a cflonum with a number and return the result.

Generic number as first operand
...............................

 -- Unsafe Operation: $sub-number-fixnum NUM FX
     Subtract any number with a fixnum and return the result.

 -- Unsafe Operation: $sub-number-bignum NUM BN
     Subtract any number with a bignum and return the result.

 -- Unsafe Operation: $sub-number-flonum NUM FL
     Subtract any number with a flonum and return the result.

 -- Unsafe Operation: $sub-number-ratnum NUM RT
     Subtract any number with a ratnum and return the result.

 -- Unsafe Operation: $sub-number-compnum NUM CN
     Subtract any number with a compnum and return the result.

 -- Unsafe Operation: $sub-number-cflonum NUM CFL
     Subtract any number with a cflonum and return the result.

Fixnum as first operand
.......................

 -- Unsafe Operation: $sub-fixnum-fixnum FX1 FX2
     Subtract a fixnum with a fixnum and return the result as a fixnum
     or bignum.

 -- Unsafe Operation: $sub-fixnum-bignum FX BN
     Subtract a fixnum with a bignum and return the result as a fixnum
     or bignum.

 -- Unsafe Operation: $sub-fixnum-flonum FX FL
     Subtract a fixnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $sub-fixnum-ratnum FX RT
     Subtract a fixnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $sub-fixnum-compnum FX CN
     Subtract a fixnum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $sub-fixnum-cflonum FX CFL
     Subtract a fixnum with a cflonum and return the result as a
     cflonum.

Bignum as first operand
.......................

 -- Unsafe Operation: $sub-bignum-fixnum BN FX
     Subtract a bignum with a fixnum and return the result as a fixnum
     or bignum.

 -- Unsafe Operation: $sub-bignum-bignum BN1 BN2
     Subtract a bignum with a bignum and return the result as a fixnum
     or bignum.

 -- Unsafe Operation: $sub-bignum-flonum BN FL
     Subtract a bignum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $sub-bignum-ratnum BN RT
     Subtract a bignum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $sub-bignum-compnum BN CN
     Subtract a bignum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $sub-bignum-cflonum BN CFL
     Subtract a bignum with a cflonum and return the result as a
     cflonum.

Flonum as first operand
.......................

 -- Unsafe Operation: $sub-flonum-fixnum FL FX
     Subtract a flonum with a fixnum and return the result as a flonum.

 -- Unsafe Operation: $sub-flonum-bignum FL BN
     Subtract a flonum with a bignum and return the result as a flonum.

 -- Unsafe Operation: $sub-flonum-flonum FL1 FL2
     Subtract a flonum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $sub-flonum-ratnum FL RT
     Subtract a flonum with a ratnum and return the result as a flonum.

 -- Unsafe Operation: $sub-flonum-compnum FL CN
     Subtract a flonum with a compnum and return the result as a compnum
     or cflonum.

 -- Unsafe Operation: $sub-flonum-cflonum FL CFL
     Subtract a flonum with a cflonum and return the result as a
     cflonum.

Ratnum as first operand
.......................

 -- Unsafe Operation: $sub-ratnum-fixnum RT FX
     Subtract a ratnum with a fixnum and return the result as a ratnum.

 -- Unsafe Operation: $sub-ratnum-bignum RT BN
     Subtract a ratnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $sub-ratnum-flonum RT FL
     Subtract a ratnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $sub-ratnum-ratnum RT1 RT2
     Subtract a ratnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $sub-ratnum-compnum RT CN
     Subtract a ratnum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $sub-ratnum-cflonum RT CFL
     Subtract a ratnum with a cflonum and return the result as a
     cflonum.

Compnum as first operand
........................

 -- Unsafe Operation: $sub-compnum-fixnum CN FX
     Subtract a compnum with a fixnum and return the result as a
     compnum.

 -- Unsafe Operation: $sub-compnum-bignum CN BN
     Subtract a compnum with a bignum and return the result as a
     compnum.

 -- Unsafe Operation: $sub-compnum-ratnum CN RT
     Subtract a compnum with a ratnum and return the result as a
     compnum.

 -- Unsafe Operation: $sub-compnum-compnum CN1 CN2
     Subtract a compnum with a compnum and return the result as a number
     (not necessarily a compnum).

 -- Unsafe Operation: $sub-compnum-flonum CN FL
     Subtract a compnum with a flonum and return the result as a compnum
     or cflonum.

 -- Unsafe Operation: $sub-compnum-cflonum CN CFL
     Subtract a compnum with a cflonum and return the result as a
     cflonum.

Cflonum as first operand
........................

 -- Unsafe Operation: $sub-cflonum-fixnum CFL FX
     Subtract a cflonum with a fixnum and return the result as a
     cflonum.

 -- Unsafe Operation: $sub-cflonum-bignum CFL BN
     Subtract a cflonum with a bignum and return the result as a
     cflonum.

 -- Unsafe Operation: $sub-cflonum-ratnum CFL RT
     Subtract a cflonum with a ratnum and return the result as a
     cflonum.

 -- Unsafe Operation: $sub-cflonum-flonum CFL FL
     Subtract a cflonum with a flonum and return the result as a
     cflonum.

 -- Unsafe Operation: $sub-cflonum-compnum CFL CN
     Subtract a cflonum with a compnum and return the result as a
     cflonum.

 -- Unsafe Operation: $sub-cflonum-cflonum CFL1 CFL2
     Subtract a cflonum with a cflonum and return the result as a
     cflonum.


File: vicare-scheme.info,  Node: syslib numerics mul,  Next: syslib numerics div,  Prev: syslib numerics sub,  Up: syslib numerics

12.10.7 Numbers multiplication
------------------------------

 -- Unsafe Operation: $mul-number-number NUM1 NUM2
     Multiply any couple of numbers and return the result.

Generic number as second operand
................................

 -- Unsafe Operation: $mul-fixnum-number FX NUM
     Multiply a fixnum with a number and return the result.

 -- Unsafe Operation: $mul-bignum-number BN NUM
     Multiply a bignum with a number and return the result.

 -- Unsafe Operation: $mul-flonum-number FL NUM
     Multiply a flonum with a number and return the result.

 -- Unsafe Operation: $mul-ratnum-number RT NUM
     Multiply a ratnum with a number and return the result.

 -- Unsafe Operation: $mul-compnum-number CN NUM
     Multiply a compnum with a number and return the result.

 -- Unsafe Operation: $mul-cflonum-number CFL NUM
     Multiply a cflonum with a number and return the result.

Generic number as first operand
...............................

 -- Unsafe Operation: $mul-number-fixnum NUM FX
     Multiply any number with a fixnum and return the result.

 -- Unsafe Operation: $mul-number-bignum NUM BN
     Multiply any number with a bignum and return the result.

 -- Unsafe Operation: $mul-number-flonum NUM FL
     Multiply any number with a flonum and return the result.

 -- Unsafe Operation: $mul-number-ratnum NUM RT
     Multiply any number with a ratnum and return the result.

 -- Unsafe Operation: $mul-number-compnum NUM CN
     Multiply any number with a compnum and return the result.

 -- Unsafe Operation: $mul-number-cflonum NUM CFL
     Multiply any number with a cflonum and return the result.

Fixnum as first operand
.......................

 -- Unsafe Operation: $mul-fixnum-fixnum FX1 FX2
     Multiply a fixnum with a fixnum and return the result as a fixnum
     or bignum.

 -- Unsafe Operation: $mul-fixnum-bignum FX BN
     Multiply a fixnum with a bignum and return the result as a fixnum
     or bignum.

 -- Unsafe Operation: $mul-fixnum-flonum FX FL
     Multiply a fixnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $mul-fixnum-ratnum FX RT
     Multiply a fixnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $mul-fixnum-compnum FX CN
     Multiply a fixnum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-fixnum-cflonum FX CFL
     Multiply a fixnum with a cflonum and return the result as a
     cflonum.

Bignum as first operand
.......................

 -- Unsafe Operation: $mul-bignum-fixnum BN FX
     Multiply a bignum with a fixnum and return the result as a bignum.

 -- Unsafe Operation: $mul-bignum-bignum BN1 BN2
     Multiply a bignum with a bignum and return the result as a bignum.

 -- Unsafe Operation: $mul-bignum-flonum BN FL
     Multiply a bignum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $mul-bignum-ratnum BN RT
     Multiply a bignum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $mul-bignum-compnum BN CN
     Multiply a bignum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-bignum-cflonum BN CFL
     Multiply a bignum with a cflonum and return the result as a
     cflonum.

Flonum as first operand
.......................

 -- Unsafe Operation: $mul-flonum-fixnum FL FX
     Multiply a flonum with a fixnum and return the result as a flonum.

 -- Unsafe Operation: $mul-flonum-bignum FL BN
     Multiply a flonum with a bignum and return the result as a flonum.

 -- Unsafe Operation: $mul-flonum-flonum FL1 FL2
     Multiply a flonum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $mul-flonum-ratnum FL RT
     Multiply a flonum with a ratnum and return the result as a flonum.

 -- Unsafe Operation: $mul-flonum-compnum FL CN
     Multiply a flonum with a compnum and return the result as cflonum.

 -- Unsafe Operation: $mul-flonum-cflonum FL CFL
     Multiply a flonum with a cflonum and return the result as a
     cflonum.

Ratnum as first operand
.......................

 -- Unsafe Operation: $mul-ratnum-fixnum RT FX
     Multiply a ratnum with a fixnum and return the result as a ratnum.

 -- Unsafe Operation: $mul-ratnum-bignum RT BN
     Multiply a ratnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $mul-ratnum-flonum RT FL
     Multiply a ratnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $mul-ratnum-ratnum RT1 RT2
     Multiply a ratnum with a ratnum and return the result as a ratnum.

 -- Unsafe Operation: $mul-ratnum-compnum RT CN
     Multiply a ratnum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-ratnum-cflonum RT CFL
     Multiply a ratnum with a cflonum and return the result as a
     cflonum.

Compnum as first operand
........................

 -- Unsafe Operation: $mul-compnum-fixnum CN FX
     Multiply a compnum with a fixnum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-compnum-bignum CN BN
     Multiply a compnum with a bignum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-compnum-ratnum CN RT
     Multiply a compnum with a ratnum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-compnum-compnum CN1 CN2
     Multiply a compnum with a compnum and return the result as a
     compnum.

 -- Unsafe Operation: $mul-compnum-flonum CN FL
     Multiply a compnum with a flonum and return the result as cflonum.

 -- Unsafe Operation: $mul-compnum-cflonum CN CFL
     Multiply a compnum with a cflonum and return the result as a
     cflonum.

Cflonum as first operand
........................

 -- Unsafe Operation: $mul-cflonum-fixnum CFL FX
     Multiply a cflonum with a fixnum and return the result as a
     cflonum.

 -- Unsafe Operation: $mul-cflonum-bignum CFL BN
     Multiply a cflonum with a bignum and return the result as a
     cflonum.

 -- Unsafe Operation: $mul-cflonum-ratnum CFL RT
     Multiply a cflonum with a ratnum and return the result as a
     cflonum.

 -- Unsafe Operation: $mul-cflonum-flonum CFL FL
     Multiply a cflonum with a flonum and return the result as a
     cflonum.

 -- Unsafe Operation: $mul-cflonum-compnum CFL CN
     Multiply a cflonum with a compnum and return the result as a
     cflonum.

 -- Unsafe Operation: $mul-cflonum-cflonum CFL1 CFL2
     Multiply a cflonum with a cflonum and return the result as a
     cflonum.


File: vicare-scheme.info,  Node: syslib numerics div,  Next: syslib numerics square,  Prev: syslib numerics mul,  Up: syslib numerics

12.10.8 Numbers division
------------------------

 -- Unsafe Operation: $div-number-number NUM1 NUM2
     Divide any couple of numbers and return the result.

Generic number as second operand
................................

 -- Unsafe Operation: $div-fixnum-number FX NUM
     Divide a fixnum with a number and return the result.

 -- Unsafe Operation: $div-bignum-number BN NUM
     Divide a bignum with a number and return the result.

 -- Unsafe Operation: $div-flonum-number FL NUM
     Divide a flonum with a number and return the result.

 -- Unsafe Operation: $div-ratnum-number RT NUM
     Divide a ratnum with a number and return the result.

 -- Unsafe Operation: $div-compnum-number CN NUM
     Divide a compnum with a number and return the result.

 -- Unsafe Operation: $div-cflonum-number CFL NUM
     Divide a cflonum with a number and return the result.

Generic number as first operand
...............................

 -- Unsafe Operation: $div-number-fixnum NUM FX
     Divide any number with a fixnum and return the result.

 -- Unsafe Operation: $div-number-bignum NUM BN
     Divide any number with a bignum and return the result.

 -- Unsafe Operation: $div-number-flonum NUM FL
     Divide any number with a flonum and return the result.

 -- Unsafe Operation: $div-number-ratnum NUM RT
     Divide any number with a ratnum and return the result.

 -- Unsafe Operation: $div-number-compnum NUM CN
     Divide any number with a compnum and return the result.

 -- Unsafe Operation: $div-number-cflonum NUM CFL
     Divide any number with a cflonum and return the result.

Fixnum as first operand
.......................

 -- Unsafe Operation: $div-fixnum-fixnum FX1 FX2
     Divide a fixnum with a fixnum and return the result as a fixnum or
     ratnum.

 -- Unsafe Operation: $div-fixnum-bignum FX BN
     Divide a fixnum with a bignum and return the result as a ratnum.

 -- Unsafe Operation: $div-fixnum-flonum FX FL
     Divide a fixnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $div-fixnum-ratnum FX RT
     Divide a fixnum with a ratnum and return the result as fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-fixnum-compnum FX CN
     Divide a fixnum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $div-fixnum-cflonum FX CFL
     Divide a fixnum with a cflonum and return the result as a cflonum.

Bignum as first operand
.......................

 -- Unsafe Operation: $div-bignum-fixnum BN FX
     Divide a bignum with a fixnum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-bignum-bignum BN1 BN2
     Divide a bignum with a bignum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-bignum-flonum BN FL
     Divide a bignum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $div-bignum-ratnum BN RT
     Divide a bignum with a ratnum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-bignum-compnum BN CN
     Divide a bignum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $div-bignum-cflonum BN CFL
     Divide a bignum with a cflonum and return the result as a cflonum.

Flonum as first operand
.......................

 -- Unsafe Operation: $div-flonum-fixnum FL FX
     Divide a flonum with a fixnum and return the result as a flonum.

 -- Unsafe Operation: $div-flonum-bignum FL BN
     Divide a flonum with a bignum and return the result as a flonum.

 -- Unsafe Operation: $div-flonum-flonum FL1 FL2
     Divide a flonum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $div-flonum-ratnum FL RT
     Divide a flonum with a ratnum and return the result as a flonum.

 -- Unsafe Operation: $div-flonum-compnum FL CN
     Divide a flonum with a compnum and return the result as a cflonum.

 -- Unsafe Operation: $div-flonum-cflonum FL CFL
     Divide a flonum with a cflonum and return the result as a cflonum.

Ratnum as first operand
.......................

 -- Unsafe Operation: $div-ratnum-fixnum RT FX
     Divide a ratnum with a fixnum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-ratnum-bignum RT BN
     Divide a ratnum with a ratnum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-ratnum-flonum RT FL
     Divide a ratnum with a flonum and return the result as a flonum.

 -- Unsafe Operation: $div-ratnum-ratnum RT1 RT2
     Divide a ratnum with a ratnum and return the result as a fixnum,
     bignum or ratnum.

 -- Unsafe Operation: $div-ratnum-compnum RT CN
     Divide a ratnum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $div-ratnum-cflonum RT CFL
     Divide a ratnum with a cflonum and return the result as a cflonum.

Compnum as first operand
........................

 -- Unsafe Operation: $div-compnum-fixnum CN FX
     Divide a compnum with a fixnum and return the result as a compnum.

 -- Unsafe Operation: $div-compnum-bignum CN BN
     Divide a compnum with a bignum and return the result as a compnum.

 -- Unsafe Operation: $div-compnum-ratnum CN RT
     Divide a compnum with a ratnum and return the result as a compnum.

 -- Unsafe Operation: $div-compnum-compnum CN1 CN2
     Divide a compnum with a compnum and return the result as a compnum.

 -- Unsafe Operation: $div-compnum-flonum CN FL
     Divide a compnum with a flonum and return the result as a cflonum.

 -- Unsafe Operation: $div-compnum-cflonum CN CFL
     Divide a compnum with a cflonum and return the result as a cflonum.

Cflonum as first operand
........................

 -- Unsafe Operation: $div-cflonum-fixnum CFL FX
     Divide a cflonum with a fixnum and return the result as a cflonum.

 -- Unsafe Operation: $div-cflonum-bignum CFL BN
     Divide a cflonum with a bignum and return the result as a cflonum.

 -- Unsafe Operation: $div-cflonum-ratnum CFL RT
     Divide a cflonum with a ratnum and return the result as a cflonum.

 -- Unsafe Operation: $div-cflonum-flonum CFL FL
     Divide a cflonum with a flonum and return the result as a cflonum.

 -- Unsafe Operation: $div-cflonum-compnum CFL CN
     Divide a cflonum with a compnum and return the result as a cflonum.

 -- Unsafe Operation: $div-cflonum-cflonum CFL1 CFL2
     Divide a cflonum with a cflonum and return the result as a cflonum.


File: vicare-scheme.info,  Node: syslib numerics square,  Next: syslib numerics cube,  Prev: syslib numerics div,  Up: syslib numerics

12.10.9 Numbers squaring
------------------------

To compute the square of any number just use 'square'; to compute the
square of a flonum use 'flsquare' or '$flsquare'.

 -- Unsafe Operation: $square-fixnum FX
     Compute the square of a fixnum and return the result as fixnum or
     bignum.

 -- Unsafe Operation: $square-bignum BN
     Compute the square of a bignum and return the result as bignum.

 -- Unsafe Operation: $square-ratnum RT
     Compute the square of a ratnum and return the result as ratnum.

 -- Unsafe Operation: $square-compnum CN
     Compute the square of a compnum and return the result as compnum or
     cflonum.

 -- Unsafe Operation: $square-cflonum CFL
     Compute the square of a cflonum and return the result as cflonum.


File: vicare-scheme.info,  Node: syslib numerics cube,  Next: syslib numerics gcd,  Prev: syslib numerics square,  Up: syslib numerics

12.10.10 Cube of numbers
------------------------

To compute the cube of any number just use 'cube'; to compute the cube
of a flonum use 'flcube' or '$flcube'.

 -- Unsafe Operation: $cube-fixnum FX
     Compute the cube of a fixnum and return the result as fixnum or
     bignum.

 -- Unsafe Operation: $cube-bignum BN
     Compute the cube of a bignum and return the result as bignum.

 -- Unsafe Operation: $cube-ratnum RT
     Compute the cube of a ratnum and return the result as ratnum.

 -- Unsafe Operation: $cube-compnum CN
     Compute the cube of a compnum and return the result as compnum or
     cflonum.

 -- Unsafe Operation: $cube-cflonum CFL
     Compute the cube of a cflonum and return the result as cflonum.


File: vicare-scheme.info,  Node: syslib numerics gcd,  Next: syslib numerics lcm,  Prev: syslib numerics cube,  Up: syslib numerics

12.10.11 Greatest common divisor
--------------------------------

 -- Unsafe Operation: $gcd-number X
     Return the greatest common divisor of standalone X, an exact or
     inexact integer; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $gcd-number-number X1 X2
     Return the greatest common divisor between any couple of exact or
     inexact integers; return a fixnum, bignum or flonum.

Exact or inexact integer as second argument
...........................................

 -- Unsafe Operation: $gcd-fixnum-number FX X
     Return the greatest common divisor between a fixnum and any exact
     or inexact integer; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $gcd-bignum-number BN X
     Return the greatest common divisor between a bignum and any exact
     or inexact integer; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $gcd-flonum-number FL X
     Return the greatest common divisor between a flonum and any exact
     or inexact integer; return a fixnum, bignum or flonum.

Exact or inexact integer as first argument
..........................................

 -- Unsafe Operation: $gcd-number-fixnum X FX
     Return the greatest common divisor between any exact or inexact
     integer and a fixnum; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $gcd-number-bignum X BN
     Return the greatest common divisor between any exact or inexact
     integer and a bignum; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $gcd-number-flonum X FL
     Return the greatest common divisor between any exact or inexact
     integer and a flonum; return a fixnum, bignum or flonum.

Fixnum as first argument
........................

 -- Unsafe Operation: $gcd-fixnum-fixnum FX1 FX2
     Return the greatest common divisor between a fixnum and a fixnum;
     return a fixnum or bignum.

 -- Unsafe Operation: $gcd-fixnum-bignum FX BN
     Return the greatest common divisor between a fixnum and a bignum;
     return a fixnum or bignum.

 -- Unsafe Operation: $gcd-fixnum-flonum FX FL
     Return the greatest common divisor between a fixnum and a flonum;
     return a flonum.

Bignum as first argument
........................

 -- Unsafe Operation: $gcd-bignum-fixnum BN FX
     Return the greatest common divisor between a bignum and a fixnum;
     return a fixnum or bignum.

 -- Unsafe Operation: $gcd-bignum-bignum BN1 BN2
     Return the greatest common divisor between a bignum and a bignum;
     return a bignum.

 -- Unsafe Operation: $gcd-bignum-flonum BN FL
     Return the greatest common divisor between a bignum and a flonum;
     return a flonum.

Flonum as first argument
........................

 -- Unsafe Operation: $gcd-flonum-fixnum FL FX
     Return the greatest common divisor between a flonum and a fixnum;
     return a flonum.

 -- Unsafe Operation: $gcd-flonum-bignum FL BN
     Return the greatest common divisor between a flonum and a bignum;
     return a flonum.

 -- Unsafe Operation: $gcd-flonum-flonum FL1 FL2
     Return the greatest common divisor between a flonum and a flonum;
     return a flonum.


File: vicare-scheme.info,  Node: syslib numerics lcm,  Next: syslib numerics quorem,  Prev: syslib numerics gcd,  Up: syslib numerics

12.10.12 Least common multiple
------------------------------

 -- Unsafe Operation: $lcm-number X
     Return the least common multiple of standalone X, an exact or
     inexact integer; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $lcm-number-number X1 X2
     Return the least common multiple between any couple of exact and
     inexact integers; return a fixnum, bignum or flonum.

Exact or inexact integer as second argument
...........................................

 -- Unsafe Operation: $lcm-fixnum-number FX X
     Return the least common multiple between a fixnum and any exact or
     inexact integer; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $lcm-bignum-number BN X
     Return the least common multiple between a bignum and any exact or
     inexact integer; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $lcm-flonum-number FL X
     Return the least common multiple between a flonum and any exact or
     inexact integer; return a fixnum, bignum or flonum.

Exact or inexact integer as first argument
..........................................

 -- Unsafe Operation: $lcm-number-fixnum X FX
     Return the least common multiple between any exact or inexact
     integer and a fixnum; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $lcm-number-bignum X BN
     Return the least common multiple between any exact or inexact
     integer and a bignum; return a fixnum, bignum or flonum.

 -- Unsafe Operation: $lcm-number-flonum X FL
     Return the least common multiple between any exact or inexact
     integer and a flonum; return a fixnum, bignum or flonum.

Fixnum as first argument
........................

 -- Unsafe Operation: $lcm-fixnum-fixnum FX1 FX2
     Return the least common multiple between a fixnum and a fixnum;
     return a fixnum or bignum.

 -- Unsafe Operation: $lcm-fixnum-bignum FX BN
     Return the least common multiple between a fixnum and a bignum;
     return a fixnum or bignum.

 -- Unsafe Operation: $lcm-fixnum-flonum FX FL
     Return the least common multiple between a fixnum and a flonum;
     return a flonum.

Bignum as first argument
........................

 -- Unsafe Operation: $lcm-bignum-fixnum BN FX
     Return the least common multiple between a bignum and a fixnum;
     return a fixnum or bignum.

 -- Unsafe Operation: $lcm-bignum-bignum BN1 BN2
     Return the least common multiple between a bignum and a bignum;
     return a bignum.

 -- Unsafe Operation: $lcm-bignum-flonum BN FL
     Return the least common multiple between a bignum and a flonum;
     return a flonum.

Flonum as first argument
........................

 -- Unsafe Operation: $lcm-flonum-fixnum FL FX
     Return the least common multiple between a flonum and a fixnum;
     return a flonum.

 -- Unsafe Operation: $lcm-flonum-bignum FL BN
     Return the least common multiple between a flonum and a bignum;
     return a flonum.

 -- Unsafe Operation: $lcm-flonum-flonum FL1 FL2
     Return the least common multiple between a flonum and a flonum;
     return a flonum.


File: vicare-scheme.info,  Node: syslib numerics quorem,  Next: syslib numerics quotient,  Prev: syslib numerics lcm,  Up: syslib numerics

12.10.13 Quotient and remainder
-------------------------------

These functions perform the integer division between exact and inexact
numbers and return two values: the quotient and the remainder.  For all
the functions: the second argument must be non-zero.

   Note that considering:

     (quotient+remainder X Y)

according to R6RS:

     (define (sign n)
       (cond ((negative? n) -1)
             ((positive? n) 1)
             (else 0)))

     (define (quotient n1 n2)
       (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

     (define (remainder n1 n2)
       (* (sign n1) (mod (abs n1) (abs n2))))

     (define (modulo n1 n2)
       (* (sign n2) (mod (* (sign n2) n1) (abs n2))))

so we have:

     sign(quotient)  = sign(X) * sign(Y)
     sign(remainder) = sign(X)
     sign(modulo)    = sign(Y)

Any number as first argument
............................

 -- Unsafe Operation: $quotient+remainder-number-fixnum NUM FX
     Perform the integer division between any exact or inexact integer
     and a fixnum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient+remainder-number-bignum NUM BN
     Perform the integer division between any exact or inexact integer
     and a bignum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient+remainder-number-flonum NUM FL
     Perform the integer division between any exact or inexact integer
     and a flonum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Any number as second argument
.............................

 -- Unsafe Operation: $quotient+remainder-fixnum-number FX NUM
     Perform the integer division between a fixnum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient+remainder-bignum-number BN NUM
     Perform the integer division between a bignum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient+remainder-flonum-number FL NUM
     Perform the integer division between a flonum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Fixnum as first argument
........................

 -- Unsafe Operation: $quotient+remainder-fixnum-fixnum FX1 FX2
     Perform the integer division between a fixnum and a fixnum; return
     a fixnum or bignum as quotient, return a fixnum as remainder.

 -- Unsafe Operation: $quotient+remainder-fixnum-bignum FX BN
     Perform the integer division between a fixnum and a bignum; return
     fixnums.

 -- Unsafe Operation: $quotient+remainder-fixnum-flonum FX FL
     Perform the integer division between a fixnum and a flonum; return
     flonums.

Bignum as first argument
........................

 -- Unsafe Operation: $quotient+remainder-bignum-fixnum BN FX
     Perform the integer division between a bignum and a fixnum; return
     fixnums.

 -- Unsafe Operation: $quotient+remainder-bignum-bignum BN1 BN2
     Perform the integer division between a bignum and a bignum; return
     fixnums or bignums.

 -- Unsafe Operation: $quotient+remainder-bignum-flonum BN FL
     Perform the integer division between a bignum and a flonum; return
     flonums.

Flonum as first argument
........................

 -- Unsafe Operation: $quotient+remainder-flonum-fixnum FL FX
     Perform the integer division between a flonum and a fixnum; return
     flonums.

 -- Unsafe Operation: $quotient+remainder-flonum-bignum FL BN
     Perform the integer division between a flonum and a bignum; return
     flonums.

 -- Unsafe Operation: $quotient+remainder-flonum-flonum FL1 FL2
     Perform the integer division between a flonum and a flonum; return
     flonums.


File: vicare-scheme.info,  Node: syslib numerics quotient,  Next: syslib numerics remainder,  Prev: syslib numerics quorem,  Up: syslib numerics

12.10.14 Quotient between numbers
---------------------------------

These functions perform the integer division between exact and inexact
numbers and return the quotient.  For all the functions: the second
argument must be non-zero.  *note syslib numerics quorem:: for more
details on the operations.

Any number as first argument
............................

 -- Unsafe Operation: $quotient-number-fixnum NUM FX
     Perform the integer division between any exact or inexact integer
     and a fixnum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient-number-bignum NUM BN
     Perform the integer division between any exact or inexact integer
     and a bignum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient-number-flonum NUM FL
     Perform the integer division between any exact or inexact integer
     and a flonum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Any number as second argument
.............................

 -- Unsafe Operation: $quotient-fixnum-number FX NUM
     Perform the integer division between a fixnum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient-bignum-number BN NUM
     Perform the integer division between a bignum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $quotient-flonum-number FL NUM
     Perform the integer division between a flonum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Fixnum as first argument
........................

 -- Unsafe Operation: $quotient-fixnum-fixnum FX1 FX2
     Perform the integer division between a fixnum and a fixnum; return
     a fixnum or bignum.

 -- Unsafe Operation: $quotient-fixnum-bignum FX BN
     Perform the integer division between a fixnum and a bignum; return
     fixnums.

 -- Unsafe Operation: $quotient-fixnum-flonum FX FL
     Perform the integer division between a fixnum and a flonum; return
     flonums.

Bignum as first argument
........................

 -- Unsafe Operation: $quotient-bignum-fixnum BN FX
     Perform the integer division between a bignum and a fixnum; return
     fixnums.

 -- Unsafe Operation: $quotient-bignum-bignum BN1 BN2
     Perform the integer division between a bignum and a bignum; return
     fixnums or bignums.

 -- Unsafe Operation: $quotient-bignum-flonum BN FL
     Perform the integer division between a bignum and a flonum; return
     flonums.

Flonum as first argument
........................

 -- Unsafe Operation: $quotient-flonum-fixnum FL FX
     Perform the integer division between a flonum and a fixnum; return
     flonums.

 -- Unsafe Operation: $quotient-flonum-bignum FL BN
     Perform the integer division between a flonum and a bignum; return
     flonums.

 -- Unsafe Operation: $quotient-flonum-flonum FL1 FL2
     Perform the integer division between a flonum and a flonum; return
     flonums.


File: vicare-scheme.info,  Node: syslib numerics remainder,  Next: syslib numerics modulo,  Prev: syslib numerics quotient,  Up: syslib numerics

12.10.15 Remainder between numbers
----------------------------------

These functions perform the integer division between exact and inexact
numbers and return the remainder.  For all the functions: the second
argument must be non-zero.  *note syslib numerics quorem:: for more
details on the operations.

Any number as first argument
............................

 -- Unsafe Operation: $remainder-number-fixnum NUM FX
     Perform the integer division between any exact or inexact integer
     and a fixnum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $remainder-number-bignum NUM BN
     Perform the integer division between any exact or inexact integer
     and a bignum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $remainder-number-flonum NUM FL
     Perform the integer division between any exact or inexact integer
     and a flonum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Any number as second argument
.............................

 -- Unsafe Operation: $remainder-fixnum-number FX NUM
     Perform the integer division between a fixnum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $remainder-bignum-number BN NUM
     Perform the integer division between a bignum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $remainder-flonum-number FL NUM
     Perform the integer division between a flonum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Fixnum as first argument
........................

 -- Unsafe Operation: $remainder-fixnum-fixnum FX1 FX2
     Perform the integer division between a fixnum and a fixnum; return
     fixnums.

 -- Unsafe Operation: $remainder-fixnum-bignum FX BN
     Perform the integer division between a fixnum and a bignum; return
     fixnums.

 -- Unsafe Operation: $remainder-fixnum-flonum FX FL
     Perform the integer division between a fixnum and a flonum; return
     flonums.

Bignum as first argument
........................

 -- Unsafe Operation: $remainder-bignum-fixnum BN FX
     Perform the integer division between a bignum and a fixnum; return
     fixnums.

 -- Unsafe Operation: $remainder-bignum-bignum BN1 BN2
     Perform the integer division between a bignum and a bignum; return
     fixnums or bignums.

 -- Unsafe Operation: $remainder-bignum-flonum BN FL
     Perform the integer division between a bignum and a flonum; return
     flonums.

Flonum as first argument
........................

 -- Unsafe Operation: $remainder-flonum-fixnum FL FX
     Perform the integer division between a flonum and a fixnum; return
     flonums.

 -- Unsafe Operation: $remainder-flonum-bignum FL BN
     Perform the integer division between a flonum and a bignum; return
     flonums.

 -- Unsafe Operation: $remainder-flonum-flonum FL1 FL2
     Perform the integer division between a flonum and a flonum; return
     flonums.


File: vicare-scheme.info,  Node: syslib numerics modulo,  Next: syslib numerics max,  Prev: syslib numerics remainder,  Up: syslib numerics

12.10.16 Modulo between numbers
-------------------------------

These functions perform the integer division between exact and inexact
numbers and return the modulo.  For all the functions: the second
argument must be non-zero.  *note syslib numerics quorem:: for more
details on the operations.

Any number as first argument
............................

 -- Unsafe Operation: $modulo-number-fixnum NUM FX
     Perform the integer division between any exact or inexact integer
     and a fixnum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $modulo-number-bignum NUM BN
     Perform the integer division between any exact or inexact integer
     and a bignum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $modulo-number-flonum NUM FL
     Perform the integer division between any exact or inexact integer
     and a flonum.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Any number as second argument
.............................

 -- Unsafe Operation: $modulo-fixnum-number FX NUM
     Perform the integer division between a fixnum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $modulo-bignum-number BN NUM
     Perform the integer division between a bignum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

 -- Unsafe Operation: $modulo-flonum-number FL NUM
     Perform the integer division between a flonum and any exact or
     inexact integer.  If NUM is not an integer: an error is raised.
     Return exact or inexact integers.

Fixnum as first argument
........................

 -- Unsafe Operation: $modulo-fixnum-fixnum FX1 FX2
     Perform the integer division between a fixnum and a fixnum; return
     fixnums.

 -- Unsafe Operation: $modulo-fixnum-bignum FX BN
     Perform the integer division between a fixnum and a bignum; return
     fixnums.

 -- Unsafe Operation: $modulo-fixnum-flonum FX FL
     Perform the integer division between a fixnum and a flonum; return
     flonums.

Bignum as first argument
........................

 -- Unsafe Operation: $modulo-bignum-fixnum BN FX
     Perform the integer division between a bignum and a fixnum; return
     fixnums.

 -- Unsafe Operation: $modulo-bignum-bignum BN1 BN2
     Perform the integer division between a bignum and a bignum; return
     fixnums or bignums.

 -- Unsafe Operation: $modulo-bignum-flonum BN FL
     Perform the integer division between a bignum and a flonum; return
     flonums.

Flonum as first argument
........................

 -- Unsafe Operation: $modulo-flonum-fixnum FL FX
     Perform the integer division between a flonum and a fixnum; return
     flonums.

 -- Unsafe Operation: $modulo-flonum-bignum FL BN
     Perform the integer division between a flonum and a bignum; return
     flonums.

 -- Unsafe Operation: $modulo-flonum-flonum FL1 FL2
     Perform the integer division between a flonum and a flonum; return
     flonums.


File: vicare-scheme.info,  Node: syslib numerics max,  Next: syslib numerics min,  Prev: syslib numerics modulo,  Up: syslib numerics

12.10.17 Maximum between numbers
--------------------------------

Notice that if one of the operands is '+nan.0' the result is '+nan.0'.

Any number as first argument
............................

 -- Unsafe Operation: $max-number-fixnum NUM FX
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-number-bignum NUM BN
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-number-ratnum NUM RT
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-number-flonum NUM FL
     Return the maximum between the arguments.

Any number as second argument
.............................

 -- Unsafe Operation: $max-fixnum-number FX NUM
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-bignum-number BN NUM
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-flonum-number FL NUM
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-ratnum-number RT NUM
     Return the maximum between the arguments.

Fixnum as first argument
........................

 -- Unsafe Operation: $max-fixnum-fixnum FX1 FX2
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-fixnum-bignum FX BN
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-fixnum-flonum FX FL
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-fixnum-ratnum FX RT
     Return the maximum between the arguments.

Bignum as first argument
........................

 -- Unsafe Operation: $max-bignum-fixnum BN FX
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-bignum-bignum BN1 BN2
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-bignum-ratnum BN RT
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-bignum-flonum BN FL
     Return the maximum between the arguments.

Flonum as first argument
........................

 -- Unsafe Operation: $max-flonum-fixnum FL FX
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-flonum-bignum FL BN
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-flonum-ratnum FL RT
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-flonum-flonum FL1 FL2
     Return the maximum between the arguments.

Ratnum as first argument
........................

 -- Unsafe Operation: $max-ratnum-fixnum RT FX
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-ratnum-bignum RT BN
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-ratnum-ratnum RT1 RT2
     Return the maximum between the arguments.

 -- Unsafe Operation: $max-ratnum-flonum RT FL
     Return the maximum between the arguments.


File: vicare-scheme.info,  Node: syslib numerics min,  Next: syslib numerics abs,  Prev: syslib numerics max,  Up: syslib numerics

12.10.18 Minimum between numbers
--------------------------------

Notice that if one of the operands is '+nan.0' the result is '+nan.0'.

Any number as first argument
............................

 -- Unsafe Operation: $min-number-fixnum NUM FX
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-number-bignum NUM BN
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-number-ratnum NUM RT
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-number-flonum NUM FL
     Return the minimum between the arguments.

Any number as second argument
.............................

 -- Unsafe Operation: $min-fixnum-number FX NUM
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-bignum-number BN NUM
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-flonum-number FL NUM
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-ratnum-number RT NUM
     Return the minimum between the arguments.

Fixnum as first argument
........................

 -- Unsafe Operation: $min-fixnum-fixnum FX1 FX2
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-fixnum-bignum FX BN
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-fixnum-flonum FX FL
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-fixnum-ratnum FX RT
     Return the minimum between the arguments.

Bignum as first argument
........................

 -- Unsafe Operation: $min-bignum-fixnum BN FX
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-bignum-bignum BN1 BN2
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-bignum-ratnum BN RT
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-bignum-flonum BN FL
     Return the minimum between the arguments.

Flonum as first argument
........................

 -- Unsafe Operation: $min-flonum-fixnum FL FX
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-flonum-bignum FL BN
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-flonum-ratnum FL RT
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-flonum-flonum FL1 FL2
     Return the minimum between the arguments.

Ratnum as first argument
........................

 -- Unsafe Operation: $min-ratnum-fixnum RT FX
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-ratnum-bignum RT BN
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-ratnum-ratnum RT1 RT2
     Return the minimum between the arguments.

 -- Unsafe Operation: $min-ratnum-flonum RT FL
     Return the minimum between the arguments.


File: vicare-scheme.info,  Node: syslib numerics abs,  Next: syslib numerics sign,  Prev: syslib numerics min,  Up: syslib numerics

12.10.19 Absolute value of real numbers
---------------------------------------

 -- Unsafe Operation: $abs-fixnum FX
     Compute the absolute value of a fixnum; return a fixnum or bignum.

 -- Unsafe Operation: $abs-bignum BN
     Compute the absolute value of a bignum; return a fixnum or bignum.

 -- Unsafe Operation: $abs-flonum FL
     Compute the absolute value of a flonum; return a flonum.

 -- Unsafe Operation: $abs-ratnum
     Compute the absolute value of a ratnum; return a ratnum.


File: vicare-scheme.info,  Node: syslib numerics sign,  Next: syslib numerics numerator,  Prev: syslib numerics abs,  Up: syslib numerics

12.10.20 Sign of real numbers
-----------------------------

 -- Unsafe Operation: $sign-fixnum FX
     Return a fixnum representing the sign of FX: '+1' for positive,
     '-1' for negative, '0' for zero.

 -- Unsafe Operation: $sign-bignum BN
     Return a fixnum representing the sign of BN: '+1' for positive,
     '-1' for negative.  Bignums do not represent zero.

 -- Unsafe Operation: $sign-flonum FL
     Return a flonum representing the sign of FX: '+1.0' for positive,
     including '+0.0' and '+inf.0'; '-1.0' for negative, including
     '-0.0' and '-inf.0'; '+nan.0' for not-a-number.

 -- Unsafe Operation: $sign-ratnum RT
     Return a fixnum representing the sign of the numerator of RT: '+1'
     for positive, '-1' for negative.  Ratnums do not represent zero.


File: vicare-scheme.info,  Node: syslib numerics numerator,  Next: syslib numerics denominator,  Prev: syslib numerics sign,  Up: syslib numerics

12.10.21 Numerator of real numbers
----------------------------------

 -- Unsafe Operation: $numerator-fixnum FX
     This is an identity function: return FX itself.

 -- Unsafe Operation: $numerator-bignum BN
     This is an identity function: return BN itself.

 -- Unsafe Operation: $numerator-flonum FL
     Return the numerator of FL as flonum.  This is an alias for
     '$flnumerator'.

 -- Unsafe Operation: $numerator-ratnum RT
     Return the numerator of RT: a fixnum or bignum.


File: vicare-scheme.info,  Node: syslib numerics denominator,  Next: syslib numerics exact,  Prev: syslib numerics numerator,  Up: syslib numerics

12.10.22 Denominator of real numbers
------------------------------------

 -- Unsafe Operation: $denominator-fixnum FX
     Always return the fixnum '1'.

 -- Unsafe Operation: $denominator-bignum BN
     Always return the fixnum '1'.

 -- Unsafe Operation: $denominator-flonum FL
     Return the denominator of FL as flonum.  This is an alias for
     '$fldenominator'.

 -- Unsafe Operation: $denominator-ratnum RT
     Return the denominator of RT: a positive fixnum or bignum.


File: vicare-scheme.info,  Node: syslib numerics exact,  Next: syslib numerics inexact,  Prev: syslib numerics denominator,  Up: syslib numerics

12.10.23 Conversion to exact number
-----------------------------------

 -- Unsafe Operation: $exact-fixnum FX
     This is an identity function: always return FX.

 -- Unsafe Operation: $exact-bignum BN
     This is an identity function: always return BN.

 -- Unsafe Operation: $exact-flonum FL
     If FL is an integer flonum: return the corresponding exact integer,
     a fixnum or bignum.  Otherwise raise an exception.

 -- Unsafe Operation: $exact-ratnum RT
     This is an identity function: always return RT.

 -- Unsafe Operation: $exact-compnum CN
     Attempt to convert the compnum CN into the corresponding exact
     compnum.  If either the real or the imaginary parts are not
     integers: raise an exception.

 -- Unsafe Operation: $exact-cflonum CFL
     Attempt to convert the cflonum CFL into the corresponding exact
     compnum.  If either the real or the imaginary parts are not
     integers: raise an exception.


File: vicare-scheme.info,  Node: syslib numerics inexact,  Next: syslib numerics expt,  Prev: syslib numerics exact,  Up: syslib numerics

12.10.24 Conversion to inexact number
-------------------------------------

 -- Unsafe Operation: $inexact-fixnum FX
     Convert the fixnum FX into the corresponding flonum.

 -- Unsafe Operation: $inexact-bignum BN
     Convert the bignum BN into the corresponding flonum.

 -- Unsafe Operation: $inexact-flonum FL
     This is an identity function: always return FL.

 -- Unsafe Operation: $inexact-ratnum RT
     Convert the ratnum RT into the corresponding flonum.

 -- Unsafe Operation: $inexact-compnum CN
     Convert the compnum CN into the corresponding cflonum.

 -- Unsafe Operation: $inexact-cflonum CFL
     This is an identity function: always return CFL.


File: vicare-scheme.info,  Node: syslib numerics expt,  Next: syslib numerics sqrt,  Prev: syslib numerics inexact,  Up: syslib numerics

12.10.25 Raising numbers to power
---------------------------------

* Menu:

* syslib numerics expt any::            Any number as first argument.
* syslib numerics expt zero::           Exact zero exponent.
* syslib numerics expt posi::           Positive fixnum exponent.
* syslib numerics expt nega::           Negative fixnum exponent.
* syslib numerics expt fixnums::        Fixnum as first argument.
* syslib numerics expt bignums::        Bignum as first argument.
* syslib numerics expt ratnums::        Ratnum as first argument.
* syslib numerics expt flonums::        Flonum as first argument.
* syslib numerics expt compnums::       Compnum as first argument.
* syslib numerics expt cflonums::       Cflonum as first argument.


File: vicare-scheme.info,  Node: syslib numerics expt any,  Next: syslib numerics expt zero,  Up: syslib numerics expt

12.10.25.1 Any number as first argument
.......................................

 -- Unsafe Operation: $expt-number-fixnum NUM FX
     Compute NUM raised to the power FX; return an unspecified number
     object.

 -- Unsafe Operation: $expt-number-bignum NUM BN
     Compute NUM raised to the power BN; return an unspecified number
     object.

 -- Unsafe Operation: $expt-number-flonum NUM FL
     Compute NUM raised to the power FL; return an unspecified inexact
     number object.

 -- Unsafe Operation: $expt-number-ratnum NUM RT
     Compute NUM raised to the power RT; return an unspecified number
     object.

 -- Unsafe Operation: $expt-number-compnum NUM CN
     Compute NUM raised to the power CN; return an unspecified number
     object, but most likely a complex number.

 -- Unsafe Operation: $expt-number-cflonum NUM CFL
     Compute NUM raised to the power CFL; return an unspecified inexact
     complex number object.


File: vicare-scheme.info,  Node: syslib numerics expt zero,  Next: syslib numerics expt posi,  Prev: syslib numerics expt any,  Up: syslib numerics expt

12.10.25.2 Exact zero exponent
..............................

 -- Unsafe Operation: $expt-number-zero-fixnum NUM
     Compute NUM raised to the power of exact zero; return an
     unspecified number object.

 -- Unsafe Operation: $expt-fixnum-zero-fixnum FX
     Compute FX raised to the power of exact zero; return a fixnum.

 -- Unsafe Operation: $expt-flonum-zero-fixnum FL
     Compute FL raised to the power of exact zero; return a flonum.

 -- Unsafe Operation: $expt-compnum-zero-fixnum CN
     Compute CN raised to the power of exact zero; return an unspecified
     number object.

 -- Unsafe Operation: $expt-cflonum-zero-fixnum CFL
     Compute CFL raised to the power of exact zero; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics expt posi,  Next: syslib numerics expt nega,  Prev: syslib numerics expt zero,  Up: syslib numerics expt

12.10.25.3 Positive fixnum exponent
...................................

 -- Unsafe Operation: $expt-number-positive-fixnum NUM FX
     Compute NUM raised to the power of positive FX; return an
     unspecified number object.  FX must be a positive fixnum.

 -- Unsafe Operation: $expt-fixnum-positive-fixnum FX1 FX2
     Compute FX1 raised to the power of positive FX2; return an exact
     number object.  FX2 must be a positive fixnum.

 -- Unsafe Operation: $expt-bignum-positive-fixnum BN FX
     Compute BN raised to the power of positive FX; return an exact
     number object.  FX must be a positive fixnum.

 -- Unsafe Operation: $expt-ratnum-positive-fixnum RT FX
     Compute RT raised to the power of positive FX; return an exact
     number object.  FX must be a positive fixnum.

 -- Unsafe Operation: $expt-flonum-positive-fixnum FL FX
     Compute FL raised to the power of positive FX; return an inexact
     number object.  FX must be a positive fixnum.

 -- Unsafe Operation: $expt-compnum-positive-fixnum CN FX
     Compute CN raised to the power of positive FX; return a cflonum.
     FX must be a positive fixnum.

 -- Unsafe Operation: $expt-cflonum-positive-fixnum CFL FX
     Compute CFL raised to the power of positive FX; return a cflonum.
     FX must be a positive fixnum.


File: vicare-scheme.info,  Node: syslib numerics expt nega,  Next: syslib numerics expt fixnums,  Prev: syslib numerics expt posi,  Up: syslib numerics expt

12.10.25.4 Negative fixnum exponent
...................................

 -- Unsafe Operation: $expt-number-negative-fixnum NUM FX
     Compute NUM raised to the power of negative FX; return an
     unspecified number object.  FX must be a negative fixnum.

 -- Unsafe Operation: $expt-fixnum-negative-fixnum FX1 FX2
     Compute FX1 raised to the power of negative FX2; return an exact
     number object.  FX2 must be a negative fixnum.

 -- Unsafe Operation: $expt-bignum-negative-fixnum BN FX
     Compute BN raised to the power of negative FX; return an exact
     number object.  FX must be a negative fixnum.

 -- Unsafe Operation: $expt-ratnum-negative-fixnum RT FX
     Compute RT raised to the power of negative FX; return an exact
     number object.  FX must be a negative fixnum.

 -- Unsafe Operation: $expt-flonum-negative-fixnum FL FX
     Compute FL raised to the power of negative FX; return an inexact
     number object.  FX must be a negative fixnum.

 -- Unsafe Operation: $expt-compnum-negative-fixnum CN FX
     Compute CN raised to the power of negative FX; return a cflonum.
     FX must be a negative fixnum.

 -- Unsafe Operation: $expt-cflonum-negative-fixnum CFL FX
     Compute CFL raised to the power of negative FX; return a cflonum.
     FX must be a negative fixnum.


File: vicare-scheme.info,  Node: syslib numerics expt fixnums,  Next: syslib numerics expt bignums,  Prev: syslib numerics expt nega,  Up: syslib numerics expt

12.10.25.5 Fixnum as first argument
...................................

 -- Unsafe Operation: $expt-fixnum-fixnum FX1 FX2
     Compute FX1 raised to the power FX2; return an exact number object.

 -- Unsafe Operation: $expt-fixnum-bignum FX BN
     Compute FX raised to the power BN; return an exact number object.

 -- Unsafe Operation: $expt-fixnum-ratnum FX RT
     Compute FX raised to the power RT; return an exact number object.

 -- Unsafe Operation: $expt-fixnum-flonum FX FL
     Compute FX raised to the power FL; return an inexact number object.

 -- Unsafe Operation: $expt-fixnum-compnum FX CN
     Compute FX raised to the power CN; return a complex number object.

 -- Unsafe Operation: $expt-fixnum-cflonum FX CFL
     Compute FX raised to the power CFL; return an inexact complex
     number object.


File: vicare-scheme.info,  Node: syslib numerics expt bignums,  Next: syslib numerics expt ratnums,  Prev: syslib numerics expt fixnums,  Up: syslib numerics expt

12.10.25.6 Bignum as first argument
...................................

 -- Unsafe Operation: $expt-bignum-fixnum BN FX
     Compute BN raised to the power of FX; return an exact number
     object.

 -- Unsafe Operation: $expt-bignum-bignum BN1 BN2
     Raise an implementation restriction violation.

 -- Unsafe Operation: $expt-bignum-ratnum BN RT
     Compute BN raised to the power RT; return an inexact number object.

 -- Unsafe Operation: $expt-bignum-flonum BN FL
     Compute BN raised to the power FL; return an inexact number object.

 -- Unsafe Operation: $expt-bignum-compnum BN CN
     Compute BN raised to the power CN; return an inexact complex number
     object.

 -- Unsafe Operation: $expt-bignum-cflonum BN CFL
     Compute BN raised to the power CFL; return an inexact complex
     number object.


File: vicare-scheme.info,  Node: syslib numerics expt ratnums,  Next: syslib numerics expt flonums,  Prev: syslib numerics expt bignums,  Up: syslib numerics expt

12.10.25.7 Ratnum as first argument
...................................

 -- Unsafe Operation: $expt-ratnum-fixnum RT FX
     Compute RT raised to the power of FX; return an exact number
     object.

 -- Unsafe Operation: $expt-ratnum-bignum RT BN
     Compute RT raised to the power BN; return an inexact number object.

 -- Unsafe Operation: $expt-ratnum-ratnum RT1 RT2
     Compute RT1 raised to the power RT2; return an inexact number
     object.

 -- Unsafe Operation: $expt-ratnum-flonum RT FL
     Compute RT raised to the power FL; return an inexact number object.

 -- Unsafe Operation: $expt-ratnum-compnum RT CN
     Compute RT raised to the power CN; return an inexact complex number
     object.

 -- Unsafe Operation: $expt-ratnum-cflonum RT CFL
     Compute RT raised to the power CFL; return an inexact complex
     number object.


File: vicare-scheme.info,  Node: syslib numerics expt flonums,  Next: syslib numerics expt compnums,  Prev: syslib numerics expt ratnums,  Up: syslib numerics expt

12.10.25.8 Flonum as first argument
...................................

 -- Unsafe Operation: $expt-flonum-fixnum FL FX
     Compute FL raised to the power of FX; return an inexact number
     object.

 -- Unsafe Operation: $expt-flonum-bignum FL BN
     Compute FL raised to the power BN; return an inexact number object.

 -- Unsafe Operation: $expt-flonum-ratnum FL RT
     Compute FL raised to the power RT; return an inexact number object.

 -- Unsafe Operation: $expt-flonum-flonum FL1 FL2
     Compute FL1 raised to the power FL2; return an inexact number
     object.

 -- Unsafe Operation: $expt-flonum-compnum FL CN
     Compute FL raised to the power CN; return an inexact complex number
     object.

 -- Unsafe Operation: $expt-flonum-cflonum FL CFL
     Compute FL raised to the power CFL; return an inexact complex
     number object.


File: vicare-scheme.info,  Node: syslib numerics expt compnums,  Next: syslib numerics expt cflonums,  Prev: syslib numerics expt flonums,  Up: syslib numerics expt

12.10.25.9 Compnum as first argument
....................................

 -- Unsafe Operation: $expt-compnum-fixnum CN FX
     Compute CN raised to the power of FX; return a cflonum.

 -- Unsafe Operation: $expt-compnum-bignum CN BN
     Compute CN raised to the power BN; return a cflonum.

 -- Unsafe Operation: $expt-compnum-ratnum CN RT
     Compute CN raised to the power RT; return a cflonum.

 -- Unsafe Operation: $expt-compnum-flonum CN FL
     Compute CN raised to the power FL; return a cflonum.

 -- Unsafe Operation: $expt-compnum-compnum CN1 CN2
     Compute CN1 raised to the power CN2; return a cflonum.

 -- Unsafe Operation: $expt-compnum-cflonum CN CFL
     Compute CN raised to the power CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics expt cflonums,  Prev: syslib numerics expt compnums,  Up: syslib numerics expt

12.10.25.10 Cflonum as first argument
.....................................

 -- Unsafe Operation: $expt-cflonum-fixnum CFL FX
     Compute CFL raised to the power of FX; return a cflonum.

 -- Unsafe Operation: $expt-cflonum-bignum CFL BN
     Compute CFL raised to the power BN; return a cflonum.

 -- Unsafe Operation: $expt-cflonum-ratnum CFL RT
     Compute CFL raised to the power RT; return a cflonum.

 -- Unsafe Operation: $expt-cflonum-flonum CFL FL
     Compute CFL raised to the power FL; return a cflonum.

 -- Unsafe Operation: $expt-cflonum-compnum CFL CN
     Compute CFL raised to the power CFL; return a cflonum.

 -- Unsafe Operation: $expt-cflonum-cflonum CFL1 CFL2
     Compute CFL1 raised to the power CFL2; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics sqrt,  Next: syslib numerics cbrt,  Prev: syslib numerics expt,  Up: syslib numerics

12.10.26 Square root of numbers
-------------------------------

 -- Unsafe Operation: $sqrt-fixnum FX
     Compute the principal square root of FX; return an unspecified
     number object.

          ($sqrt-fixnum 0)       => 0

          ($sqrt-fixnum +1)      => +1
          ($sqrt-fixnum -1)      => +1i

          ($sqrt-fixnum +4)      => +2
          ($sqrt-fixnum -4)      => +2i

          ($sqrt-fixnum +5)      => 2.23606797749979
          ($sqrt-fixnum -5)      => 0.0+2.23606797749979i

 -- Unsafe Operation: $sqrt-bignum BN
     Compute the principal square root of BN; return an unspecified
     number object.

          (define SMALLEST-POSITIVE-BIGNUM (-    (least-fixnum)))
          (define SMALLEST-NEGATIVE-BIGNUM (+ -1 (least-fixnum)))

          (define BN1 (+ +1  SMALLEST-POSITIVE-BIGNUM))
          (define BN2 (+ +10 SMALLEST-POSITIVE-BIGNUM))
          (define BN3 (+ -1  SMALLEST-NEGATIVE-BIGNUM))
          (define BN4 (+ -10 SMALLEST-NEGATIVE-BIGNUM))

          ;; on a 32-bit host
          ($sqrt-bignum BN1)      => 23170.475027499975
          ($sqrt-bignum BN2)      => 23170.47522171265
          ($sqrt-bignum BN3)      => 0.0+23170.475049079163i
          ($sqrt-bignum BN4)      => 0.0+23170.47524329184i

 -- Unsafe Operation: $sqrt-ratnum RT
     Compute the principal square root of RT; return an unspecified
     number object.

 -- Unsafe Operation: $sqrt-flonum FL
     Compute the principal square root of FL; return a flonum, compnum
     or cflonum.

          ($sqrt-flonum +0.0)     => +0.0
          ($sqrt-flonum -0.0)     => +0.0i

          ($sqrt-flonum +4.0)     => +2.0
          ($sqrt-flonum -4.0)     => +2.0i

          ($sqrt-flonum +1.0)     => +1.0
          ($sqrt-flonum -1.0)     => +1.0i

          ($sqrt-flonum +5.0)     => 2.23606797749979
          ($sqrt-flonum -5.0)     => 0.0+2.23606797749979i

          ($sqrt-flonum +inf.0)   => +inf.0
          ($sqrt-flonum -inf.0)   => +inf.0i

          ($sqrt-flonum +nan.0)   => +nan.0

 -- Unsafe Operation: $sqrt-compnum CN
     Compute the principal square root of CN; return an unspecified
     number object.

 -- Unsafe Operation: $sqrt-cflonum CFL
     Compute the principal square root of CFL; return a cflonum.

 -- Unsafe Operation: $exact-integer-sqrt-fixnum FX
     Return two non-negative exact integer objects being the root and
     the residual of FX.

 -- Unsafe Operation: $exact-integer-sqrt-bignum BN
     Return two non-negative exact integer objects being the root and
     the residual of BN.


File: vicare-scheme.info,  Node: syslib numerics cbrt,  Next: syslib numerics log,  Prev: syslib numerics sqrt,  Up: syslib numerics

12.10.27 Cubic root of numbers
------------------------------

 -- Unsafe Operation: $cbrt-fixnum FX
     Compute the principal cubic root of FX; return an unspecified
     number object.

 -- Unsafe Operation: $cbrt-bignum BN
     Compute the principal cubic root of BN; return an unspecified
     number object.

 -- Unsafe Operation: $cbrt-ratnum RT
     Compute the principal cubic root of RT; return an unspecified
     number object.

 -- Unsafe Operation: $cbrt-flonum FL
     Compute the principal cubic root of FL; return a flonum, compnum or
     cflonum.

 -- Unsafe Operation: $cbrt-compnum CN
     Compute the principal cubic root of CN; return an unspecified
     number object.

 -- Unsafe Operation: $cbrt-cflonum CFL
     Compute the principal cubic root of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics log,  Next: syslib numerics exp,  Prev: syslib numerics cbrt,  Up: syslib numerics

12.10.28 Logarithms of numbers
------------------------------

 -- Unsafe Operation: $log-fixnum FX
     Compute the natural logarithm of FX; return a fixnum, flonum or
     cflonum.

 -- Unsafe Operation: $log-bignum BN
     Compute the natural logarithm of FL; return an inexact number
     object.

 -- Unsafe Operation: $log-flonum FL
     Compute the natural logarithm of FL; return a flonum or cflonum.
     This function computes the result also when FL is a negative
     flonum, whose logarithm is a complex number; this makes it
     different from '$fllog'.

 -- Unsafe Operation: $log-ratnum RT
     Compute the natural logarithm of RT; return an inexact number
     object.

 -- Unsafe Operation: $log-compnum CN
     Compute the natural logarithm of CN; return an inexact number
     object.

 -- Unsafe Operation: $log-cflonum CFL
     Compute the natural logarithm of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics exp,  Next: syslib numerics sin,  Prev: syslib numerics log,  Up: syslib numerics

12.10.29 Exponentials of numbers
--------------------------------

 -- Unsafe Operation: $exp-fixnum FX
     Compute the base e exponential of FX; return a fixnum or flonum.

 -- Unsafe Operation: $exp-bignum BN
     Compute the base e exponential of BN; return a flonum.

 -- Unsafe Operation: $exp-ratnum RT
     Compute the base e exponential of RT; return a flonum.

 -- Unsafe Operation: $exp-flonum FL
     Compute the base e exponential of FL; return a flonum.  This is
     just an alias for '$flexp'.

 -- Unsafe Operation: $exp-compnum CN
     Compute the base e exponential of CN; return a cflonum.

 -- Unsafe Operation: $exp-cflonum CFL
     Compute the base e exponential of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics sin,  Next: syslib numerics cos,  Prev: syslib numerics exp,  Up: syslib numerics

12.10.30 Trigonometric sine
---------------------------

 -- Unsafe Operation: $sin-fixnum FX
     Compute the trigonometric sine of FX; return a fixnum or flonum.

 -- Unsafe Operation: $sin-bignum BN
     Compute the trigonometric sine of BN; return a flonum.

 -- Unsafe Operation: $sin-ratnum RT
     Compute the trigonometric sine of RT; return a flonum.

 -- Unsafe Operation: $sin-flonum FL
     Compute the trigonometric sine of FL; return a flonum.  This is an
     alias for '$flsin'.

 -- Unsafe Operation: $sin-cflonum CFL
     Compute the trigonometric sine of CFL; return a cflonum.

 -- Unsafe Operation: $sin-compnum CN
     Compute the trigonometric sine of CN; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics cos,  Next: syslib numerics tan,  Prev: syslib numerics sin,  Up: syslib numerics

12.10.31 Trigonometric cosine
-----------------------------

 -- Unsafe Operation: $cos-fixnum FX
     Compute the trigonometric cosine of FX; return a fixnum or flonum.

 -- Unsafe Operation: $cos-bignum BN
     Compute the trigonometric cosine of BN; return a flonum.

 -- Unsafe Operation: $cos-ratnum RT
     Compute the trigonometric cosine of RT; return a flonum.

 -- Unsafe Operation: $cos-flonum FL
     Compute the trigonometric cosine of FL; return a flonum.  This is
     an alias for '$flcos'.

 -- Unsafe Operation: $cos-cflonum CFL
     Compute the trigonometric cosine of CFL; return a cflonum.

 -- Unsafe Operation: $cos-compnum CN
     Compute the trigonometric cosine of CN; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics tan,  Next: syslib numerics asin,  Prev: syslib numerics cos,  Up: syslib numerics

12.10.32 Trigonometric tangent
------------------------------

 -- Unsafe Operation: $tan-fixnum FX
     Compute the trigonometric tangent of FX; return a fixnum or flonum.

 -- Unsafe Operation: $tan-bignum BN
     Compute the trigonometric tangent of BN; return a flonum.

 -- Unsafe Operation: $tan-ratnum RT
     Compute the trigonometric tangent of RT; return a flonum.

 -- Unsafe Operation: $tan-flonum FL
     Compute the trigonometric tangent of FL; return a flonum.  This is
     an alias for '$fltan'.

 -- Unsafe Operation: $tan-cflonum CFL
     Compute the trigonometric tangent of CFL; return a cflonum.

 -- Unsafe Operation: $tan-compnum CN
     Compute the trigonometric tangent of CN; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics asin,  Next: syslib numerics acos,  Prev: syslib numerics tan,  Up: syslib numerics

12.10.33 Trigonometric arc sine
-------------------------------

 -- Unsafe Operation: $asin-fixnum FX
     Compute the trigonometric arc sine of FX; return a flonum or
     cflonum.

 -- Unsafe Operation: $asin-bignum BN
     Compute the trigonometric arc sine of BN; return a flonum or
     cflonum.

 -- Unsafe Operation: $asin-ratnum RT
     Compute the trigonometric arc sine of RT; return a flonum or
     cflonum.

 -- Unsafe Operation: $asin-flonum FL
     Compute the trigonometric arc sine of FL; return a flonum or
     cflonum.

 -- Unsafe Operation: $asin-cflonum CFL
     Compute the trigonometric arc sine of FL; return a cflonum.

 -- Unsafe Operation: $asin-compnum CN
     Compute the trigonometric arc sine of FL; return a number object.


File: vicare-scheme.info,  Node: syslib numerics acos,  Next: syslib numerics atan,  Prev: syslib numerics asin,  Up: syslib numerics

12.10.34 Trigonometric arc cosine
---------------------------------

 -- Unsafe Operation: $acos-fixnum FX
     Compute the trigonometric arc cosine of FX; return a flonum or
     compnum or cflonum.

 -- Unsafe Operation: $acos-bignum BN
     Compute the trigonometric arc cosine of BN; return a flonum or
     compnum or cflonum.

 -- Unsafe Operation: $acos-ratnum RT
     Compute the trigonometric arc cosine of RT; return a flonum or
     compnum or cflonum.

 -- Unsafe Operation: $acos-flonum FL
     Compute the trigonometric arc cosine of FL; return a flonum or
     compnum or cflonum.

 -- Unsafe Operation: $acos-cflonum CFL
     Compute the trigonometric arc cosine of FL; return a cflonum.

 -- Unsafe Operation: $acos-compnum CN
     Compute the trigonometric arc cosine of FL; return a number object.


File: vicare-scheme.info,  Node: syslib numerics atan,  Next: syslib numerics sinh,  Prev: syslib numerics acos,  Up: syslib numerics

12.10.35 Trigonometric arc tangent
----------------------------------

 -- Unsafe Operation: $atan2-real-real IMP REP
     Compute the principal value of the trigonometric arc tangent of
     flonum IMP over flonum REP using the signs of the arguments to
     determine the quadrant of the result:

          \alpha = \atan (IMP/REP)

     in other words compute the angle \alpha such that:

                         \sin(\alpha)   IMP
          \tan(\alpha) = ------------ = ---
                         \cos(\alpha)   REP

     in yet other words compute the angle of the complex number having
     the flonum REP as real part and the flonum IMP as imaginary part:

          (angle (make-rectangular REP IMP))

     return a flonum.  This operation is implemented using the POSIX
     function 'atan2()'.

 -- Unsafe Operation: $atan-fixnum FX
     Compute the trigonometric arc tangent of FX; return a flonum.

 -- Unsafe Operation: $atan-bignum BN
     Compute the trigonometric arc tangent of BN; return a flonum.

 -- Unsafe Operation: $atan-ratnum RT
     Compute the trigonometric arc tangent of RT; return a flonum.

 -- Unsafe Operation: $atan-flonum FL
     Compute the trigonometric arc tangent of FL; return a flonum.

 -- Unsafe Operation: $atan-cflonum CFL
     Compute the trigonometric arc tangent of FL; return a cflonum.

 -- Unsafe Operation: $atan-compnum CN
     Compute the trigonometric arc tangent of FL; return a number
     object.


File: vicare-scheme.info,  Node: syslib numerics sinh,  Next: syslib numerics cosh,  Prev: syslib numerics atan,  Up: syslib numerics

12.10.36 Hyperbolic sine
------------------------

 -- Unsafe Operation: $sinh-fixnum FX
     Compute the hyperbolic sine of FX; return a flonum.

 -- Unsafe Operation: $sinh-bignum BN
     Compute the hyperbolic sine of BN; return a flonum.

 -- Unsafe Operation: $sinh-ratnum RT
     Compute the hyperbolic sine of RT; return a flonum.

 -- Unsafe Operation: $sinh-flonum FL
     Compute the hyperbolic sine of FL; return a flonum.  This is an
     alias for '$flsinh'.

 -- Unsafe Operation: $sinh-compnum CN
     Compute the hyperbolic sine of CN; return a number object.

 -- Unsafe Operation: $sinh-cflonum CFL
     Compute the hyperbolic sine of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics cosh,  Next: syslib numerics tanh,  Prev: syslib numerics sinh,  Up: syslib numerics

12.10.37 Hyperbolic cosine
--------------------------

 -- Unsafe Operation: $cosh-fixnum FX
     Compute the hyperbolic cosine of FX; return a flonum.

 -- Unsafe Operation: $cosh-bignum BN
     Compute the hyperbolic cosine of BN; return a flonum.

 -- Unsafe Operation: $cosh-ratnum RT
     Compute the hyperbolic cosine of RT; return a flonum.

 -- Unsafe Operation: $cosh-flonum FL
     Compute the hyperbolic cosine of FL; return a flonum.  This is an
     alias for '$flcosh'.

 -- Unsafe Operation: $cosh-compnum CN
     Compute the hyperbolic cosine of CN; return a number object.

 -- Unsafe Operation: $cosh-cflonum CFL
     Compute the hyperbolic cosine of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics tanh,  Next: syslib numerics asinh,  Prev: syslib numerics cosh,  Up: syslib numerics

12.10.38 Hyperbolic tangent
---------------------------

 -- Unsafe Operation: $tanh-fixnum FX
     Compute the hyperbolic tangent of FX; return a flonum.

 -- Unsafe Operation: $tanh-bignum BN
     Compute the hyperbolic tangent of BN; return a flonum.

 -- Unsafe Operation: $tanh-ratnum RT
     Compute the hyperbolic tangent of RT; return a flonum.

 -- Unsafe Operation: $tanh-flonum FL
     Compute the hyperbolic tangent of FL; return a flonum.  This is an
     alias for '$fltanh'.

 -- Unsafe Operation: $tanh-compnum CN
     Compute the hyperbolic tangent of CN; return a number object.

 -- Unsafe Operation: $tanh-cflonum CFL
     Compute the hyperbolic tangent of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics asinh,  Next: syslib numerics acosh,  Prev: syslib numerics tanh,  Up: syslib numerics

12.10.39 Hyperbolic arc sine
----------------------------

 -- Unsafe Operation: $asinh-fixnum FX
     Compute the inverse hyperbolic sine of FX; return a flonum.

 -- Unsafe Operation: $asinh-bignum BN
     Compute the inverse hyperbolic sine of BN; return a flonum.

 -- Unsafe Operation: $asinh-ratnum RT
     Compute the inverse hyperbolic sine of RT; return a flonum.

 -- Unsafe Operation: $asinh-flonum FL
     Compute the inverse hyperbolic sine of FL; return a flonum.  This
     is an alias for '$flsinh'.

 -- Unsafe Operation: $asinh-compnum CN
     Compute the inverse hyperbolic sine of CN; return a number object.

 -- Unsafe Operation: $asinh-cflonum CFL
     Compute the inverse hyperbolic sine of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics acosh,  Next: syslib numerics atanh,  Prev: syslib numerics asinh,  Up: syslib numerics

12.10.40 Hyperbolic arc cosine
------------------------------

 -- Unsafe Operation: $acosh-fixnum FX
     Compute the inverse hyperbolic cosine of FX; return a flonum,
     compnum or cflonum.

 -- Unsafe Operation: $acosh-bignum BN
     Compute the inverse hyperbolic cosine of BN; return a flonum,
     compnum or cflonum.

 -- Unsafe Operation: $acosh-ratnum RT
     Compute the inverse hyperbolic cosine of RT; return a flonum,
     compnum or cflonum.

 -- Unsafe Operation: $acosh-flonum FL
     Compute the inverse hyperbolic cosine of FL; return a flonum,
     compnum or cflonum.  This is different from '$flacosh' whose return
     value is a flonum begin '+nan.0' when the operand is out of the
     domain for real numbers.

 -- Unsafe Operation: $acosh-compnum CN
     Compute the inverse hyperbolic cosine of CN; return a number
     object.

 -- Unsafe Operation: $acosh-cflonum CFL
     Compute the inverse hyperbolic cosine of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics atanh,  Next: syslib numerics conjugate,  Prev: syslib numerics acosh,  Up: syslib numerics

12.10.41 Hyperbolic arc tangent
-------------------------------

 -- Unsafe Operation: $atanh-fixnum FX
     Compute the inverse hyperbolic tangent of FX; return a flonum or
     cflonum.

 -- Unsafe Operation: $atanh-bignum BN
     Compute the inverse hyperbolic tangent of BN; return a flonum or
     cflonum.

 -- Unsafe Operation: $atanh-ratnum RT
     Compute the inverse hyperbolic tangent of RT; return a flonum or
     cflonum.

 -- Unsafe Operation: $atanh-flonum FL
     Compute the inverse hyperbolic tangent of FL; return a flonum or
     cflonum.  This is different from '$flatanh' whose return value is a
     flonum begin '+nan.0' when the operand is out of the domain for
     real numbers.

 -- Unsafe Operation: $atanh-compnum CN
     Compute the inverse hyperbolic tangent of CN; return a number
     object.

 -- Unsafe Operation: $atanh-cflonum CFL
     Compute the inverse hyperbolic tangent of CFL; return a cflonum.


File: vicare-scheme.info,  Node: syslib numerics conjugate,  Next: syslib numerics magnitude,  Prev: syslib numerics atanh,  Up: syslib numerics

12.10.42 Complex conjugate
--------------------------

 -- Unsafe Operation: $complex-conjugate-compnum CN
     Return a number object representing the complex conjugate of CN.

 -- Unsafe Operation: $complex-conjugate-cflonum CFL
     Return a cflonum representing the complex conjugate of CFL.


File: vicare-scheme.info,  Node: syslib numerics magnitude,  Next: syslib numerics angle,  Prev: syslib numerics conjugate,  Up: syslib numerics

12.10.43 Magnitude of complex numbers
-------------------------------------

 -- Unsafe Operation: $magnitude-fixnum FX
     Compute the magnitude of FX; return a fixnum.

 -- Unsafe Operation: $magnitude-bignum BN
     Compute the magnitude of BN; return a bignum.

 -- Unsafe Operation: $magnitude-ratnum RT
     Compute the magnitude of RT; return a ratnum.

 -- Unsafe Operation: $magnitude-flonum FL
     Compute the magnitude of FL; return a flonum.

 -- Unsafe Operation: $magnitude-compnum CN
     Compute the magnitude of CN; return a number object.

 -- Unsafe Operation: $magnitude-cflonum CFL
     Compute the magnitude of CFL; return a flonum.


File: vicare-scheme.info,  Node: syslib numerics angle,  Next: syslib numerics bitnot,  Prev: syslib numerics magnitude,  Up: syslib numerics

12.10.44 Angle of complex numbers
---------------------------------

 -- Unsafe Operation: $angle-fixnum FX
     Compute the angle of FX; return a fixnum or flonum.

 -- Unsafe Operation: $angle-bignum BN
     Compute the angle of BN; return a fixnum or flonum.

 -- Unsafe Operation: $angle-ratnum RT
     Compute the angle of RT; return a fixnum or flonum.

 -- Unsafe Operation: $angle-flonum FL
     Compute the angle of FL; return a flonum.

 -- Unsafe Operation: $angle-compnum CN
     Compute the angle of CN; return a number object.

 -- Unsafe Operation: $angle-cflonum CFL
     Compute the angle of CFL; return a flonum.


File: vicare-scheme.info,  Node: syslib numerics bitnot,  Next: syslib numerics bitand,  Prev: syslib numerics angle,  Up: syslib numerics

12.10.45 Bitwise logic not
--------------------------

 -- Unsafe Operation: $bitwise-not-fixnum FX
     Apply the bitwise NOT operation to FX.

 -- Unsafe Operation: $bitwise-not-bignum BN
     Apply the bitwise NOT operation to BN.


File: vicare-scheme.info,  Node: syslib numerics bitand,  Next: syslib numerics bitior,  Prev: syslib numerics bitnot,  Up: syslib numerics

12.10.46 Bitwise logic and
--------------------------

 -- Unsafe Operation: $bitwise-and-fixnum-number FX NUM
     Apply the bitwise AND operation to the fixnum FX and the exact
     integer object NUM.

 -- Unsafe Operation: $bitwise-and-bignum-number BN NUM
     Apply the bitwise AND operation to the bignum BN and the exact
     integer NUM.

 -- Unsafe Operation: $bitwise-and-fixnum-fixnum FX1 FX2
     Apply the bitwise AND operation to the fixnum FX1 and the fixnum
     FX2.

 -- Unsafe Operation: $bitwise-and-fixnum-bignum FX BN
     Apply the bitwise AND operation to the fixnum FX and the bignum BN.

 -- Unsafe Operation: $bitwise-and-bignum-fixnum BN FX
     Apply the bitwise AND operation to the bignum BN and the fixnum FX.

 -- Unsafe Operation: $bitwise-and-bignum-bignum BN1 BN2
     Apply the bitwise AND operation to the bignum BN1 and the bignum
     BN2.


File: vicare-scheme.info,  Node: syslib numerics bitior,  Next: syslib numerics bitxor,  Prev: syslib numerics bitand,  Up: syslib numerics

12.10.47 Bitwise logic inclusive or
-----------------------------------

 -- Unsafe Operation: $bitwise-ior-fixnum-number FX NUM
     Apply the bitwise inclusive OR operation to the fixnum FX and the
     exact integer object NUM.

 -- Unsafe Operation: $bitwise-ior-bignum-number BN NUM
     Apply the bitwise inclusive OR operation to the bignum BN and the
     exact integer NUM.

 -- Unsafe Operation: $bitwise-ior-fixnum-fixnum FX1 FX2
     Apply the bitwise inclusive OR operation to the fixnum FX1 and the
     fixnum FX2.

 -- Unsafe Operation: $bitwise-ior-fixnum-bignum FX BN
     Apply the bitwise inclusive OR operation to the fixnum FX and the
     bignum BN.

 -- Unsafe Operation: $bitwise-ior-bignum-fixnum BN FX
     Apply the bitwise inclusive OR operation to the bignum BN and the
     fixnum FX.

 -- Unsafe Operation: $bitwise-ior-bignum-bignum BN1 BN2
     Apply the bitwise inclusive OR operation to the bignum BN1 and the
     bignum BN2.


File: vicare-scheme.info,  Node: syslib numerics bitxor,  Next: syslib numerics floor,  Prev: syslib numerics bitior,  Up: syslib numerics

12.10.48 Bitwise logic exclusive or
-----------------------------------

 -- Unsafe Operation: $bitwise-xor-fixnum-number FX NUM
     Apply the bitwise exclusive OR operation to the fixnum FX and the
     exact integer object NUM.

 -- Unsafe Operation: $bitwise-xor-bignum-number BN NUM
     Apply the bitwise exclusive OR operation to the bignum BN and the
     exact integer NUM.

 -- Unsafe Operation: $bitwise-xor-fixnum-fixnum FX1 FX2
     Apply the bitwise exclusive OR operation to the fixnum FX1 and the
     fixnum FX2.

 -- Unsafe Operation: $bitwise-xor-fixnum-bignum FX BN
     Apply the bitwise exclusive OR operation to the fixnum FX and the
     bignum BN.

 -- Unsafe Operation: $bitwise-xor-bignum-fixnum BN FX
     Apply the bitwise exclusive OR operation to the bignum BN and the
     fixnum FX.

 -- Unsafe Operation: $bitwise-xor-bignum-bignum BN1 BN2
     Apply the bitwise exclusive OR operation to the bignum BN1 and the
     bignum BN2.


File: vicare-scheme.info,  Node: syslib numerics floor,  Next: syslib numerics ceiling,  Prev: syslib numerics bitxor,  Up: syslib numerics

12.10.49 Floor rounding
-----------------------

 -- Unsafe Operation: $floor-fixnum FX
     Rounding as defined by 'floor'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $floor-bignum BN
     Rounding as defined by 'floor'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $floor-flonum FL
     Rounding as defined by 'floor'.  Return a flonum.

 -- Unsafe Operation: $floor-ratnum RN
     Rounding as defined by 'floor'.  Return an exact integer.


File: vicare-scheme.info,  Node: syslib numerics ceiling,  Next: syslib numerics truncate,  Prev: syslib numerics floor,  Up: syslib numerics

12.10.50 Ceiling rounding
-------------------------

 -- Unsafe Operation: $ceiling-fixnum FX
     Rounding as defined by 'ceiling'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $ceiling-bignum BN
     Rounding as defined by 'ceiling'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $ceiling-flonum FL
     Rounding as defined by 'ceiling'.  Return a flonum.

 -- Unsafe Operation: $ceiling-ratnum RN
     Rounding as defined by 'ceiling'.  Return an exact integer.


File: vicare-scheme.info,  Node: syslib numerics truncate,  Next: syslib numerics round,  Prev: syslib numerics ceiling,  Up: syslib numerics

12.10.51 Truncate rounding
--------------------------

 -- Unsafe Operation: $truncate-fixnum FX
     Rounding as defined by 'truncate'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $truncate-bignum BN
     Rounding as defined by 'truncate'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $truncate-flonum FL
     Rounding as defined by 'truncate'.  Return a flonum.

 -- Unsafe Operation: $truncate-ratnum RN
     Rounding as defined by 'truncate'.  Return an exact integer.


File: vicare-scheme.info,  Node: syslib numerics round,  Prev: syslib numerics truncate,  Up: syslib numerics

12.10.52 Round rounding
-----------------------

 -- Unsafe Operation: $round-fixnum FX
     Rounding as defined by 'round'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $round-bignum BN
     Rounding as defined by 'round'.  This is an identity function,
     returning N itself.

 -- Unsafe Operation: $round-flonum FL
     Rounding as defined by 'round'.  Return a flonum.

 -- Unsafe Operation: $round-ratnum RN
     Rounding as defined by 'round'.  Return an exact integer.


File: vicare-scheme.info,  Node: syslib chars,  Next: syslib pairs,  Prev: syslib numerics,  Up: syslib

12.11 Low level character operations
====================================

The arguments CH to these operations must be characters, the arguments
FX must be fixnums in the range '[0, #x10FFFF]' but not in the range
'[#xD800, #xDFFF]'.  The following bindings are exported by the library
'(vicare system $chars)'.

Comparison
..........

 -- Unsafe Operation: $char= CH1 CH2
     Evaluate to true if the operands are equal.

 -- Unsafe Operation: $char!= CH1 CH2
     The arguments must be characters.  Return '#t' if the arguments are
     different; otherwise return '#f'.

 -- Unsafe Operation: $char< CH1 CH2
     Evaluate to true if the CH1 is less than CH2.

 -- Unsafe Operation: $char<= CH1 CH2
     Evaluate to true if the CH1 is less than or equal to CH2.

 -- Unsafe Operation: $char> CH1 CH2
     Evaluate to true if the CH1 is greater than CH2.

 -- Unsafe Operation: $char>= CH1 CH2
     Evaluate to true if the CH1 is greater than or equal to CH2.

 -- Function: $chmin CH1 CH2
 -- Function: $chmax CH1 CH2
     Return the minimum or maximum character among the arguments.

Conversion
..........

 -- Unsafe Operation: $fixnum->char FX
     Return a new character value whose code point equals FX.

 -- Unsafe Operation: $char->fixnum CH
     Return a fixnum representing the code point of the operand.


File: vicare-scheme.info,  Node: syslib pairs,  Next: syslib lists,  Prev: syslib chars,  Up: syslib

12.12 Low level pair operations
===============================

The arguments P to these operations must be pairs.  The following
bindings are exported by the library '(vicare system $pairs)'.  *note
objects pairs:: for details of pair representation.

 -- Unsafe Operation: $car P
     Return the car of the operand.

 -- Unsafe Operation: $cdr P
     Return the cdr of the operand.

 -- Unsafe Operation: $set-car! P VALUE
     Store VALUE in the car location of P.

 -- Unsafe Operation: $set-cdr! P VALUE
     Store VALUE in the cdr location of P.


File: vicare-scheme.info,  Node: syslib lists,  Next: syslib structs,  Prev: syslib pairs,  Up: syslib

12.13 Low level list operations
===============================

The following bindings are exported by the library '(vicare system
$lists)'.

 -- Unsafe Operation: $length ELL
     Assume ELL is a proper list, null included: compute and return the
     length of ELL.


File: vicare-scheme.info,  Node: syslib structs,  Next: syslib records,  Prev: syslib lists,  Up: syslib

12.14 System structure operations
=================================

* Menu:

* syslib structs safe::         High level structure operations.
* syslib structs unsafe::       Low level structure operations.


File: vicare-scheme.info,  Node: syslib structs safe,  Next: syslib structs unsafe,  Up: syslib structs

12.14.1 High level structure operations
---------------------------------------

A Vicare's struct is a record object, lighter than records as defined by
R6RS.  *note objects structs:: for more informations on the internals of
structs.

* Menu:

* syslib structs safe define::  Defining struct types.
* syslib structs safe using::   Using struct types.
* syslib structs safe inspect:: Inspecting struct types.
* syslib structs safe printer:: Struct printer customisation.
* syslib structs safe final::   Finalisation of structs.
* syslib structs safe data::    Inspecting data structures.


File: vicare-scheme.info,  Node: syslib structs safe define,  Next: syslib structs safe using,  Up: syslib structs safe

12.14.1.1 Defining structure types
..................................

 -- Syntax: define-struct ?TYPE-NAME (?FIELD ...)
 -- Syntax: define-struct ?TYPE-NAME (?FIELD ...) (nongenerative ?UID)
 -- Syntax: define-struct (?TYPE-NAME ?CONSTRUCTOR ?PREDICATE) (?FIELD
          ...)
 -- Syntax: define-struct (?TYPE-NAME ?CONSTRUCTOR ?PREDICATE) (?FIELD
          ...) (nongenerative ?UID)
 -- Auxiliary Syntax: nongenerative
     Define a new struct type.  This macro is embedded in the expander.

     ?TYPE-NAME must be a symbol representing the name of the structure;
     it is used to build names for the constructor, predicate, field
     accessors and mutators.  When ?CONSTRUCTOR is used: it must be an
     identifier representing the name of the constructor.  When
     ?PREDICATE is used: it must be an identifier representing the name
     of the predicate.

     The ?FIELD values must be either symbols representing the names of
     the fields or 'brace' forms representing the name and type of
     fields:

          (brace ?FIELD-NAME ?TAG)

     they are used to build names for the accessors and mutators.

     When the 'nongenerative' clause is used: ?UID must be a symbol
     uniquely identifying the struct type.  Multiple definitions of
     struct type using the same ?UID must have the same type name and
     field names, and represent the same type definition.  See
     'make-struct-type' for more details.

     The following definition:

          (define-struct color
            (red green blue))

     expands to the definition of the following syntactic bindings:

     'color'
          A syntactic identifier representing the type name.  When the
          tagged language is enabled, we can use this identifier to tag
          a variable syntactic binding:

               (define {O color}
                 (make-color 1 2 3))

               (O red)         => 1
               (O green)       => 2
               (O blue)        => 3

          We can use the identifier as argument for the 'is-a?' syntax:

               (is-a? (make-color 1 2 3) color)        => #t
               (is-a? "ciao" color)                    => #f

          When the identifier is used in macro keyword position with the
          syntax:

               (?TYPE-NAME (?EXPR ...))

          the form is expanded to the application of the constructor to
          the results of evaluating the ?EXPR arguments:

               (color (1 2 3)) => #["color" red=1 green=2 blue=3]

     'make-color RED GREEN BLUE'
          A structure constructor accepting as much arguments as there
          are fields.  The constructor makes use of the '$struct' low
          level operation.

     'color? OBJ'
          A predicate to distinguish between references to 'color'
          structures and other values.  This predicate makes use of the
          '$struct/rtd?' low level operation.

     'color-red STRU'
     'color-green STRU'
     'color-blue STRU'
          Accessor functions for the fields of the structure.  These
          accessors make use of the '$struct/rtd?' low level operation
          to validate the argument and if successful they use
          '$struct-ref' to extract the value; if the argument is of
          invalid type: an assertion violation is raised.

     'set-color-red! STRU RED'
     'set-color-green! STRU GREEN'
     'set-color-blue! STRU BLUE'
          Mutator functions for the fields of the structure.  These
          mutators make use of the '$struct/rtd?' low level operation to
          validate the argument STRU and if successful they use
          '$struct-set!' to set the value; if the argument STRU is of
          invalid type: an assertion violation is raised.

     '$color-red STRU'
     '$color-green STRU'
     '$color-blue STRU'
          Unsafe accessor syntaxes for the fields of the structure.
          These accessors do not validate the arguments and expand
          directly to a use of '$struct-ref' to extract the value; if
          the argument is invalid: the behaviour is undefined.

     '$set-color-red! STRU RED'
     '$set-color-green! STRU GREEN'
     '$set-color-blue! STRU BLUE'
          Unsafe mutator syntaxes for the fields of the structure.
          These mutators do not validate the arguments and expand
          directly to a use of '$struct-set!' to set the value; if the
          argument STRU is invalid: the behaviour is undefined.

 -- Function: make-struct-type TYPE-NAME FIELDS
 -- Function: make-struct-type TYPE-NAME FIELDS UID
     Build and return a new struct-type descriptor.  TYPE-NAME must be a
     string representing the type name.  FIELDS must be a list of
     symbols representing the field names.

     The optional UID argument must be a symbol uniquely identifying
     this type; when not supplied, a symbol is automatically generated.
     The 'value' field of the symbol object UID is set to the newly
     created RTD; if UID already has a symbol value: such value must be
     a struct descriptor equal to the newly created RTD.

     The use of a UID allows us to define a unique struct type in
     different libraries without sharing the definition by importing
     syntactic bindings.  For example, we can define a struct type in a
     library and import the definition in other libraries:

          (library (one)
            (export
              make-color color?
              color-red color-green color-blue)
            (import (vicare))
            (define-struct color
              (red green blue)))

          (library (two)
            (export C)
            (import (vicare) (one))
            (define C (make-color 1 2 3)))

          (library (three)
            (export)
            (import (vicare) (one) (two))
            (display (color-red C)))

     but, by specifying a UID, we can also do:

          (library (two)
            (export C)
            (import (vicare))
            (define-struct color
              (red green blue)
              (nongenerative the-color))
            (define C
              (make-color 1 2 3)))

          (library (three)
            (export)
            (import (vicare))
            (define-struct color
              (red green blue)
              (nongenerative the-color))
            (display (color-red C)))

     and everything will work as before.


File: vicare-scheme.info,  Node: syslib structs safe using,  Next: syslib structs safe inspect,  Prev: syslib structs safe define,  Up: syslib structs safe

12.14.1.2 Using structure types
...............................

 -- Syntax: struct-type-descriptor ?TYPE-NAME
     Evaluate to the type descriptor of the data structure ?TYPE-NAME,
     which must be the first argument to a previous use of
     'define-struct'.

 -- Function: struct-type-descriptor? OBJ
     Return '#t' if OBJ is a struct-type descriptor, otherwise return
     '#f'.  This predicate returns '#f' when applied to R6RS record-type
     descriptors.

 -- Function: struct-type-constructor STD
     Return a constructor function for struct of type defined by the
     type descriptor STD.  The returned constructor accepts as many
     arguments as there are fields specified by STD and it returns a new
     struct instance.

          (define duo-std
            (make-struct-type "duo" '(one two)))

          (define make-duo
            (struct-type-constructor duo-std))

          (make-duo 1 2)  => #[struct duo one=1 two=2]

 -- Function: struct-type-predicate STD
     Return a predicate function for structs of type defined by the type
     descriptor STD.

          (define duo-std
            (make-struct-type "duo" '(one two)))

          (define make-duo
            (struct-type-constructor duo-std))

          (define duo?
            (struct-type-predicate duo-std))

          (duo? (make-duo 1 2))   => #t

 -- Function: struct-type-field-accessor STD INDEX/NAME
 -- Function: struct-type-field-mutator STD INDEX/NAME
     Return an accessor or mutator function for the field at INDEX/NAME
     of structs of type defined by the type descriptor STD.  INDEX/NAME
     can be a field index or a symbol representing a field name.

          (define-struct color
            (red green blue))

          (define stru
            (make-color 1 2 3))

          ((struct-type-field-accessor (struct-type-descriptor color) 'red)
           stru)
          => 1

          ((struct-type-field-accessor (struct-type-descriptor color) 0)
           stru)
          => 1

 -- Function: struct-type-field-method STD INDEX/NAME
     Return a "method" function for the field at INDEX/NAME of structs
     of type defined by the type descriptor STD.  INDEX/NAME can be a
     field index or a symbol representing a field name.  When the method
     function is applied to 1 argument: it behaves like a field
     accessor.  When the method function is applied to 2 arguments: it
     behaves like a field mutator.

          (define-struct color
            (red green blue))

          (define stru
            (make-color 1 2 3))

          (define red-method
            (struct-type-field-method (struct-type-descriptor color) 'red))

          (red-method stru)       => 1
          (red-method stru 11)
          (red-method stru)       => 11


File: vicare-scheme.info,  Node: syslib structs safe inspect,  Next: syslib structs safe printer,  Prev: syslib structs safe using,  Up: syslib structs safe

12.14.1.3 Inspecting struct types
.................................

 -- Function: struct-type-name STD
     Return a string representing the name of structs of type STD.

 -- Function: struct-type-symbol STD
     Return a symbol uniquely identifying the struct type STD.

 -- Function: struct-type-field-names STD
     Return a list of symbols representing the names of fields in
     structs of type STD.


File: vicare-scheme.info,  Node: syslib structs safe printer,  Next: syslib structs safe final,  Prev: syslib structs safe inspect,  Up: syslib structs safe

12.14.1.4 Structs printer customisation
.......................................

Vicare's built-in Scheme objects writer can print structs just fine,
handling cyclic references and shared objects:

     (import (vicare))
     (print-graph #t)
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define-struct duo (one two))

     ;; simple struct
     (display (make-duo 1 2))
     -| #[struct duo one=1 two=2]

     ;; struct with shared object
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (display B))
     -| #[struct duo one=#0=#[struct duo one=1 two=2] two=#0#]

     ;; struct with cyclic reference to itself
     (let ((A (make-duo 1 (void))))
       (set-duo-two! A A)
       (display A))
     -| #0=#[struct duo one=1 two=#0#]

   The Scheme objects writer is able to differentiate between 'display',
'write' and 'pretty-print' printing.  When printing structs, the
built-in writer makes *no* difference between printing with 'display'
and 'write'; it does it differently when printing with 'pretty-print':

     (import (vicare))
     (print-graph #t)
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define-struct duo (one two))

     ;; simple struct
     (pretty-print (make-duo 1 2))
     -| (struct duo (one 1) (two 2))

     ;; struct with shared object
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (pretty-print B))
     -| (struct duo (one #0=(struct duo (one 1) (two 2))) (two #0#))

     ;; struct with cyclic reference to itself
     (let ((A (make-duo 1 (void))))
       (set-duo-two! A A)
       (pretty-print A))
     -| #0=(struct duo (one 1) (two #0#))

Custom printers
...............

Sometimes, we need to print a struct with a customised representation.
For example keyword objects (*note Keyword objects: iklib keywords.) are
structs with a custom printer function:

     (display #:ciao)        => #:ciao

   For every struct type it is possible to set a custom printer
function; it accepts 3 arguments: the struct to be printed; a textual
output port into which to write a string representation of the struct in
the style of 'display', 'write' or 'pretty-print'; a sub-printer
function to be optionally used to print component objects.  The
sub-printer function accepts as single argument the object to print; it
allows us to interface with the shared objects printer that handles
shared and cyclic references.

   As example, the following code defines a custom printer, making use
of the parameter 'printer-printing-style' to differentiate the style:

     (import (vicare))
     (print-graph #t)
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define-struct duo (one two))

     (define (duo-printer stru port sub-printer)
       (case (printer-printing-style)
         ((display)
          (display "#{duo " port)
          (sub-printer (duo-one stru))
          (display " " port)
          (sub-printer (duo-two stru))
          (display "}" port))
         ((write)
          (display "(" port)
          ;;By using the sub-printer: we make this sexp shared too.
          (sub-printer '(struct-constructor
                           (struct-type-descriptor duo)))
          (display " " port)
          (sub-printer (duo-one stru))
          (display " " port)
          (sub-printer (duo-two stru))
          (display ")" port))
         ((pretty-print)
          (sub-printer `(struct duo
                                #:one ,(duo-one stru)
                                #:two ,(duo-two stru))))))

     (set-struct-type-printer! (struct-type-descriptor duo)
                               duo-printer)

     (define O
       (make-duo 1 2))

     (display O)
     -| #{duo 1 2}"

     (write O)
     -| ((struct-constructor (struct-type-descriptor duo)) 1 2)

     (pretty-print O)
     -| (struct duo #:one 1 #:two 2)

     ;; shared object, display
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (display B))
     -| #{duo #0=#{duo 1 2} #0#}

     ;; shared object, write
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (write B))
     -| (#0=(struct-constructor (struct-type-descriptor duo)) \
       #1=(#0# 1 2) #1#)

 -- Function: set-struct-type-printer! STD PRINTER
     Select the procedure PRINTER as printer for structs of type STD; if
     PRINTER is '#f', instances of type STD make use of the built-in
     Scheme objects printer.  Return the old printer function or '#f' if
     no printer function was set for this STD.

 -- Function: struct-type-printer STD
     Return '#f' or a function previously set as custom struct printer
     for instances of struct type STD.  When the return value is '#f':
     instances of type STD make use of the built-in Scheme objects
     printer.


File: vicare-scheme.info,  Node: syslib structs safe final,  Next: syslib structs safe data,  Prev: syslib structs safe printer,  Up: syslib structs safe

12.14.1.5 Finalisation of structs
.................................

Vicare allows structs to be finalised either explicitly or automatically
by the garbage collector, by applying a destructor function to them;
here is how automatic finalisation works:

     vicare> (define-struct duo (one two))
     vicare> (set-struct-type-destructor! (struct-type-descriptor duo)
        (lambda (stru)
          (printf "destroying ~s\n" stru)))
     vicare> (make-duo 1 2)
     $1 = (struct duo (one 1) (two 2))
     vicare> (collect)
     destroying #[struct duo one=1 two=2]
     vicare>

   A destructor function is associated to a struct-type by registering
it in the struct-type descriptor.  After a destructor is set in the
descriptor: new instances of the struct-type are registered, upon
creation, into an internal guardian, *note iklib guardians:: for
details; whenever such structs are garbage collected: the guardian
applies the destructor to them.

   When the destructor is called by the garbage collector: exceptions
raised by it are catched with 'guard' and discarded; destructor
functions should take care of exceptions by themselves.

   It is possible for a destructor function to be applied multiple times
to the same struct: once a destructor is set in the descriptor, it can
be explicitly applied to structs and later applied again by the garbage
collector.  Destructor functions must be written in such a way that
multiple applications are not a problem.  For example, it is usually
possible, upon destruction, to reset some struct fields to the void
object: when the destructor detects a field set to void, it knows that
the struct has already been finalised.

 -- Function: set-struct-type-destructor! STD DESTRUCTOR
     Select the procedure DESTRUCTOR as destructor for data structs of
     type STD; return the old destructor function or '#f' if no
     destructor was set for STD.  The destructor accepts a single
     argument being the struct instance to finalise; the destructor can
     return unspecified values.

 -- Function: struct-type-destructor STD
     Return '#f' or a procedure being the destructor for instances of
     STD.

 -- Parameter: struct-guardian-logger
     Select data structs destruction logging mode for debugging
     purposes.  When a struct is finalised by the garbage collector,
     using the destructor registered in the RTD:

        * If this parameter is set to '#f': no additional actions are
          performed.

        * If this parameter is set to '#t': the function
          'struct-guardian-log' is used to log the operations to the
          textual output port returned by 'current-error-port'.

        * If this parameter is set to a procedure: such procedure is
          used to log the operations in a user selected way.

     See the documentation of 'struct-guardian-log' for the calling
     protocol of the logger functions.

 -- Function: struct-guardian-log STRUCT EXCEPTION ACTION
     Built in logger function to be used to log struct finalisation
     operations by the garbage collector.  STRUCT is the instance to be
     finalised; EXCEPTION is '#f' or an object raised by the struct
     destructor; ACTION is one of the symbols: 'before-destruction',
     'after-destruction', 'exception'.

     When this function is used as value for the parameter
     'struct-guardian-logger':

        * The function is called whenever a struct is registered for
          destruction with ACTION set to the symbol 'registration' and
          EXCEPTION set to '#f'.

        * The function is called just before the struct is finalised
          with ACTION set to the symbol 'before-destruction' and
          EXCEPTION set to '#f'.

        * The function is called right after the struct has been
          finalised with ACTION set to the symbol 'after-destruction'
          and EXCEPTION set to '#f'.

        * If an exception is raised by the destructor: such exception is
          catched and this function is called with ACTION set to
          'exception' and EXCEPTION set to the raised object.

     The current implementation is the following:

          (define (struct-guardian-log S E action)
            (case action
              ((registration)
               (fprintf (current-error-port)
                        "*** Vicare debug: struct guardian: registered struct:\n\
                         ***\t~s\n" S))
              ((before-destruction)
               (fprintf (current-error-port)
                 "*** Vicare debug: struct guardian: before destruction:\n\
                  ***\t~s\n" S))
              ((after-destruction)
               (fprintf (current-error-port)
                 "*** Vicare debug: struct guardian: after destruction:\n\
                  ***\t~s\n" S))
              ((exception)
               (fprintf (current-error-port)
                 "*** Vicare debug: struct guardian: exception:\n\
                  ***\t~s\n\
                  ***\t~s\n" S E))
              (else
               (assertion-violation 'struct-guardian-log
                 "invalid action in struct destruction process" S action))))


File: vicare-scheme.info,  Node: syslib structs safe data,  Prev: syslib structs safe final,  Up: syslib structs safe

12.14.1.6 Inspecting data structures
....................................

 -- Function: struct? STRU
 -- Function: struct? STRU STD
     When no STD argument is given: return true if STRU is a data
     structure.  When STD is given: return true if STRU is a data
     structure and it is of type STD, which must be a struct type
     descriptor.

 -- Function: struct-and-std? STRU STD
     Return '#t' if STRU is a struct with struct-type descriptor equal
     to STD; otherwise return '#f'.  Raise an error if STD is not a
     struct-type descriptor.

 -- Function: struct-std STRU
     Return the struct-type descriptor of the data structure STRU.
     Notice that this function works with both Vicare's structs and R6RS
     records.

 -- Function: struct-length STRU
     Return the number of fields in the data structure STRU.  Notice
     that this function works with both Vicare's structs and R6RS
     records.

 -- Function: struct-field-names STRU
     Return a list of symbols representing the field names of the
     structure STRU.

 -- Function: struct-name STRU
     Return a string representing the name of the data structure STRU.
     Notice that this function works with both Vicare's structs and R6RS
     records.

 -- Function: struct-printer STRU
     Return '#f' or the procedure being the printer function for the
     data structure STRU.

 -- Function: struct-destructor STRU
     Return '#f' or the procedure being the destructor function for the
     data structure STRU.

 -- Function: struct-ref STRU INDEX
     Return the value of field at INDEX in the data structure STRU.

 -- Function: struct-set! STRU INDEX VALUE
     Store VALUE in the field at INDEX in the data structure STRU.

 -- Function: struct-and-std-ref STRU INDEX STD
     Check that STRU is a struct of type STD, then return the value of
     field at INDEX in the data structure STRU.

 -- Function: struct-and-std-set! STRU INDEX STD VALUE
     Check that STRU is a struct of type STD, store VALUE in the field
     at INDEX in the data structure STRU.

 -- Function: struct=? STRU ...
     All the arguments must be structs.  Return '#t' if all the
     arguments have the same RTD and equal field values according to
     'eqv?'.  When applied to a single argument: return '#t'.  Note that
     this function also works when applied to R6RS records.

 -- Function: struct!=? STRU ...
     All the arguments must be structs.  Return '#t' if the arguments
     are all different: no two arguments are equal; otherwise return
     '#f'.  When applied to a single argument: return '#f'.

 -- Function: struct-reset! STRU
     Reset to void all the fields of a structure.


File: vicare-scheme.info,  Node: syslib structs unsafe,  Prev: syslib structs safe,  Up: syslib structs

12.14.2 Low level structure operations
--------------------------------------

The arguments STRU to these operations must be references to data
structures, the arguments STD must be references to structure type
descriptors, the arguments FX must be fixnums of appropriate value.  The
following bindings are exported by the library '(vicare system
$structs)'.

 -- Unsafe Operation: base-rtd
     Return a reference to the type descriptor used as type for all the
     type descriptors.

 -- Unsafe Operation: $struct? OBJ
     Evaluate to true if OBJ is the reference to a structure.

 -- Unsafe Operation: $struct/rtd? STRU STD
     Evaluate to true if STRU is a structure of type STD.

 -- Unsafe Operation: $make-struct STD FX
     Allocate a new data structure of type STD capable of holding FX
     words and return a reference to it.

          *NOTE* This operation initialises only the 'std' field,
          leaving all the other fields set to a machine word with all
          the bits set to '1'.  We must be careful not to trigger a
          garbage collection before those fields are initialised with
          valid values, else the behaviour is undefined.

 -- Unsafe Operation: $make-clean-struct STD
     Allocate a new data structure of type STD and reset all the fields
     to the fixnum zero.

 -- Unsafe Operation: $struct-std STRU
     Return a reference to the type descriptor of STRU.

 -- Unsafe Operation: $struct-ref STRU FX
     Return the value in the field at index FX of STRU.

 -- Unsafe Operation: $struct-set! STRU FX VALUE
     Store VALUE in the field at index FX of STRU.

 -- Unsafe Operation: $struct STD VALUE ...
     Allocate a new data structure of type STD capable of holding as
     many words as given VALUE arguments and initialise the fields with
     such values.  Return a reference to the structure.

Operations on struct type descriptors
.....................................

 -- Unsafe Operation: $std-std STD
 -- Unsafe Operation: $set-std-std! STD NEW-STD
     Given a struct type descriptor return its struct type descriptor or
     set a new type descriptor.

 -- Unsafe Operation: $std-name STD
 -- Unsafe Operation: $set-std-name! STD NEW-NAME
     Given a struct type descriptor return its name as a string or set a
     new name.

 -- Unsafe Operation: $std-length STD
 -- Unsafe Operation: $set-std-length! STD NEW-LEN
     Given a struct type descriptor return a non-negative fixnum
     representing the number of fields or set a new number of fields.

 -- Unsafe Operation: $std-fields STD
 -- Unsafe Operation: $set-std-fields! STD FIELDS
     Given a struct type descriptor return a list of symbols
     representing the field names or set a new list of field names.

 -- Unsafe Operation: $std-printer STD
 -- Unsafe Operation: $set-std-printer! STD NEW-PRINTER
     Given a struct type descriptor return its printer function or set a
     new printer function.

 -- Unsafe Operation: $std-symbol STD
 -- Unsafe Operation: $set-std-symbol! STD NEW-UID
     Given a struct type descriptor return its UID symbol or set a new
     UID symbol.  When setting a new struct UID we must store the struct
     type descriptor in the 'value' slot of the UID.

 -- Unsafe Operation: $std-destructor STD
 -- Unsafe Operation: $set-std-destructor! STD NEW-DESTR
     Given a struct type descriptor return '#f' or its destructor
     function or set a new destructor function.


File: vicare-scheme.info,  Node: syslib records,  Next: syslib vectors,  Prev: syslib structs,  Up: syslib

12.15 Low level recordure operations
====================================

The arguments RECO to these operations must be references to records,
the arguments RTD must be references to record-type descriptors, the
arguments FX must be fixnums of appropriate value.  The following
bindings are exported by the library '(vicare system $records)'.

 -- Unsafe Operation: $record= RECO1 RECO2
     Return '#t' if the arguments are equal field by field according to
     'equal?'; otherwise return '#f'.

 -- Unsafe Operation: $record-rtd RECO
     Return a reference to the record type descriptor of RECO.

 -- Unsafe Operation: $record-ref RECO FX
     Return the value of the field at absolute index FX for the record
     RECO.

 -- Unsafe Operation: $record-and-rtd? RECO RTD
     Return '#t' if the record RECO is of type RTD; otherwise return
     '#f'.

 -- Unsafe Operation: $record-constructor RTD
     Return the constructor function for records of type RTD.

 -- Unsafe Operation: $record-destructor RTD
     Return '#f' or the destructor function for records of type RTD.

 -- Unsafe Operation: $record-printer RECO
     Return '#f' or the printer function for records of the same type of
     RECO.

 -- Unsafe Operation: $record-equality-predicate RECO
     Return '#f' or the equality predicate of records of the same type
     as RECO.

 -- Unsafe Operation: $record-comparison-procedure RECO
     Return '#f' or the comparison procedure of records of the same type
     as RECO.

 -- Unsafe Operation: $record-hash-function RECO
     Return '#f' or the hash function of records of the same type as
     RECO.

 -- Unsafe Operation: $record-method-retriever RECO
     Return '#f' or the method retriever procedure of records of the
     same type as RECO.

 -- Unsafe Operation: $record-type-destructor-set! RTD PROC
 -- Unsafe Operation: $record-type-destructor RTD
     Setter and getter for destructor functions for records of type RTD.

 -- Unsafe Operation: $record-type-printer-set! RTD PROC
 -- Unsafe Operation: $record-type-printer RTD
     Setter and getter for printer functions for records of type RTD.

 -- Unsafe Operation: $record-type-equality-predicate-set! RTD PROC
 -- Unsafe Operation: $record-type-equality-predicate RTD
     Setter and getter for equality predicates for records of type RTD.

 -- Unsafe Operation: $record-type-comparison-procedure-set! RTD PROC
 -- Unsafe Operation: $record-type-comparison-procedure RTDA
     Setter and getter for comparison procedures for records of type
     RTD.

 -- Unsafe Operation: $record-type-hash-function-set! RTD PROC
 -- Unsafe Operation: $record-type-hash-function RTD
     Setter and getter for hash functions for records of type RTD.

 -- Unsafe Operation: $record-type-method-retriever-set! RTD PROC
 -- Unsafe Operation: $record-type-method-retriever RTD
     Setter and getter for method retriever procedures for records of
     type RTD.


File: vicare-scheme.info,  Node: syslib vectors,  Next: syslib bytevectors,  Prev: syslib records,  Up: syslib

12.16 Low level vector operations
=================================

* Menu:

* syslib vectors makers::       Vector constructors.
* syslib vectors inspect::      Inspecting vectors.
* syslib vectors access::       Accessors and mutators.
* syslib vectors mapping::      Mapping over vectors.
* syslib vectors copying::      Copying between vectors.
* syslib vectors conversion::   Converting between vectors
                                and other object types.


File: vicare-scheme.info,  Node: syslib vectors makers,  Next: syslib vectors inspect,  Up: syslib vectors

12.16.1 Vector constructors
---------------------------

The arguments VEC to these operations must be fixnums, the arguments FX
must be fixnums.  The following bindings are exported by the library
'(vicare system $vectors)'.

 -- Unsafe Operation: $make-vector FX
     Allocate and return a new vector value of FX elements.

          *NOTE* This operation does not initialise the data area,
          leaving the items set to whatever is on the Scheme heap; this
          is bad for garbage collection if the newly built vector is
          moved before the items are initialised to correct Scheme
          values.  We should use the '$make-clean-vector' function.

 -- Unsafe Operation: $make-clean-vector FX
     Allocate and return a new vector value of FX elements; initialise
     all the slots to the fixnum zero.

 -- Unsafe Operation: $subvector SRC.VEC SRC.START SRC.END
     Return a new vector holding items from SRC.VEC from SRC.START
     inclusive to SRC.END exclusive.


File: vicare-scheme.info,  Node: syslib vectors inspect,  Next: syslib vectors access,  Prev: syslib vectors makers,  Up: syslib vectors

12.16.2 Inspecting vectors
--------------------------

The arguments VEC to these operations must be fixnums, the arguments FX
must be fixnums.  The following bindings are exported by the library
'(vicare system $vectors)'.

 -- Unsafe Operation: $vector-length VEC
     Evaluate to a fixnum representing the numbe of values in VEC.

 -- Unsafe Operation: $vector-empty? VEC
     Return '#t' if the vector VEC has zero length, otherwise return
     '#f'.

 -- Unsafe Operation: $vectors-of-same-length? VEC0 VEC ...
     Return '#t' if all the vector arguments have the same length;
     otherwise return '#f'.


File: vicare-scheme.info,  Node: syslib vectors access,  Next: syslib vectors mapping,  Prev: syslib vectors inspect,  Up: syslib vectors

12.16.3 Accessors and mutators
------------------------------

The arguments VEC to these operations must be fixnums, the arguments FX
must be fixnums.  The following bindings are exported by the library
'(vicare system $vectors)'.

 -- Unsafe Operation: $vector-ref VEC FX
     Return the value at index FX in VEC.

 -- Unsafe Operation: $vector-set! VEC FX VALUE
     Store VALUE at index FX in VEC.

 -- Unsafe Operation: $vector-set-void! VEC FX
     Store the void value at index FX in VEC.


File: vicare-scheme.info,  Node: syslib vectors mapping,  Next: syslib vectors copying,  Prev: syslib vectors access,  Up: syslib vectors

12.16.4 Mapping over vectors
----------------------------

The arguments VEC to these operations must be fixnums, the arguments FX
must be fixnums.  The following bindings are exported by the library
'(vicare system $vectors)'.

 -- Unsafe Operation: $vector-map1 FUNC VEC
     Like 'vector-map', but for only one vector argument: build and
     return a new vector having the same size of VEC and items equal to
     the result of applying FUNC to the items of VEC.

 -- Unsafe Operation: $vector-for-each1 FUNC VEC
     Like 'vector-for-each', but for only one vector argument: apply
     FUNC to all the items of VEC and discard the return values.

 -- Unsafe Operation: $vector-for-all1 FUNC VEC
     Like 'vector-for-all', but for only one vector argument: return
     true if FUNC returns true for all the items in VEC.  If the
     application of FUNC to the items of VEC returns true up to the
     penultimate item, the last application is performed as tail call.

 -- Unsafe Operation: $vector-for-exists1 FUNC VEC
     Like 'vector-exists', but for only one vector argument: return '#f'
     if FUNC returns '#f' for all the items in VEC.  If the application
     of FUNC to the items of VEC returns '#f' up to the penultimate
     item, the last application is performed as tail call.


File: vicare-scheme.info,  Node: syslib vectors copying,  Next: syslib vectors conversion,  Prev: syslib vectors mapping,  Up: syslib vectors

12.16.5 Copying between vectors
-------------------------------

The arguments VEC to these operations must be fixnums, the arguments FX
must be fixnums.  The following bindings are exported by the library
'(vicare system $vectors)'.

 -- Unsafe Operation: $vector-self-copy-forwards! VEC SRC.START
          DST.START COUNT
     Copy COUNT items of VEC from SRC.START inclusive to VEC itself
     starting at DST.START inclusive.  The copy happens forwards, so it
     is suitable for the case SRC.START greater than DST.START.

 -- Unsafe Operation: $vector-self-copy-backwards! VEC SRC.END DST.END
          COUNT
     Copy COUNT items of VEC from SRC.END exclusive to VEC itself
     starting at DST.END exclusive.  The copy happens backwards, so it
     is suitable for the case SRC.END less than DST.END.

 -- Unsafe Operation: $vector-copy-source-range! src.vec src.start
          src.end dst.vec dst.start
     Copy items from SRC.VEC to DST.VEC; return DST.VEC.  Copy the items
     from the source slots from index SRC.START (inclusive) to SRC.END
     (exclusive), in the destination slots starting at index DST.START.

 -- Unsafe Operation: $vector-copy-source-count! SRC.VEC SRC.START
          DST.VEC DST.START COUNT
     Copy COUNT items from SRC.VEC to DST.VEC; return DST.VEC.  Copy the
     items the source slots at index SRC.START inclusive, to the
     destination slots at index DST.START inclusive.


File: vicare-scheme.info,  Node: syslib vectors conversion,  Prev: syslib vectors copying,  Up: syslib vectors

12.16.6 Converting between vectors and other object types
---------------------------------------------------------

The arguments VEC to these operations must be fixnums, the arguments FX
must be fixnums.  The following bindings are exported by the library
'(vicare system $vectors)'.

 -- Unsafe Operation: $fill-vector-from-list! VEC START LS
     Fill the vector VEC with items from the proper list LS, starting at
     index START.


File: vicare-scheme.info,  Node: syslib bytevectors,  Next: syslib strings,  Prev: syslib vectors,  Up: syslib

12.17 Low level bytevector operations
=====================================

The low-level bindings are exported by the library '(vicare system
$bytevectors)'.

* Menu:

* syslib bytevectors constructors::  Constructors.
* syslib bytevectors predicates::    Predicates.
* syslib bytevectors comparison::    Comparison.
* syslib bytevectors inspection::    Inspection.
* syslib bytevectors accessors::     Accessors and mutators.
* syslib bytevectors copying::       Copying.
* syslib bytevectors concatenating:: Concatenating.
* syslib bytevectors encodings::     Encodings.


File: vicare-scheme.info,  Node: syslib bytevectors constructors,  Next: syslib bytevectors predicates,  Up: syslib bytevectors

12.17.1 Constructors
--------------------

 -- Unsafe Operation: $make-bytevector FX
     Allocate a new bytevector capable of holding FX bytes and return a
     reference to it.  FX must be a non-negative fixnum.

 -- Function: $subbytevector-u8 BV START END
 -- Function: $subbytevector-s8 BV START END
     Build and return a new bytevector holding octets or bytes from the
     bytevector BV starting from index START inclusive to index END
     exclusive.

 -- Function: $subbytevector-u8/count BV START COUNT
 -- Function: $subbytevector-s8/count BV START COUNT
     Build and return a new bytevector holding COUNT octets or bytes
     from the bytevector BV starting from index START inclusive.


File: vicare-scheme.info,  Node: syslib bytevectors predicates,  Next: syslib bytevectors comparison,  Prev: syslib bytevectors constructors,  Up: syslib bytevectors

12.17.2 Predicates
------------------

 -- Unsafe Operation: $bytevector-empty? BV
     Return '#t' if the bytevector BV has zero length, otherwise return
     '#f'.


File: vicare-scheme.info,  Node: syslib bytevectors comparison,  Next: syslib bytevectors inspection,  Prev: syslib bytevectors predicates,  Up: syslib bytevectors

12.17.3 Comparison
------------------

 -- Function: $bytevector= BV1 BV2
     Return '#t' if the bytevector arguments are equal, byte by byte;
     otherwise return '#f'.

 -- Function: $bytevector!= BV1 BV2
     The arguments must be bytevectors.  Return '#t' if the arguments
     are different; otherwise return '#f'.

 -- Function: $bytevector-u8< BV1 BV2
 -- Function: $bytevector-u8> BV1 BV2
 -- Function: $bytevector-u8<= BV1 BV2
 -- Function: $bytevector-u8>= BV1 BV2
     These procedures are the extensions to bytevectors of the
     corresponding orderings on unsigned fixnums; the bytevectors are
     compared octet by octet.

 -- Function: $bytevector-s8< BV1 BV2
 -- Function: $bytevector-s8> BV1 BV2
 -- Function: $bytevector-s8<= BV1 BV2
 -- Function: $bytevector-s8>= BV1 BV2
     These procedures are the extensions to bytevectors of the
     corresponding orderings on signed fixnums; the bytevectors are
     compared byte by byte.

 -- Function: $bytevector-u8-max BV1 BV2
 -- Function: $bytevector-u8-min BV1 BV2
     Return the maximal or minimal bytevector argument according to
     '$bytevector-u8<'.

 -- Function: $bytevector-s8-max BV1 BV2
 -- Function: $bytevector-s8-min BV1 BV2
     Return the maximal or minimal bytevector argument according to
     '$bytevector-s8<'.


File: vicare-scheme.info,  Node: syslib bytevectors inspection,  Next: syslib bytevectors accessors,  Prev: syslib bytevectors comparison,  Up: syslib bytevectors

12.17.4 Inspection
------------------

 -- Unsafe Operation: $bytevector-length BV
     Return a fixnum representing the number of bytes in the bytevector
     BV.


File: vicare-scheme.info,  Node: syslib bytevectors accessors,  Next: syslib bytevectors copying,  Prev: syslib bytevectors inspection,  Up: syslib bytevectors

12.17.5 Accessors and mutators
------------------------------

* Menu:

* syslib bytevectors accessors 8-bit::   8-bit setters and getters.
* syslib bytevectors accessors 16-bit::  16-bit setters and getters.
* syslib bytevectors accessors 32-bit::  32-bit setters and getters.
* syslib bytevectors accessors 64-bit::  64-bit setters and getters.
* syslib bytevectors accessors single::  Single-precision IEEE flonum
                                         setters and getters.
* syslib bytevectors accessors double::  Double-precision IEEE flonum
                                         setters and getters.


File: vicare-scheme.info,  Node: syslib bytevectors accessors 8-bit,  Next: syslib bytevectors accessors 16-bit,  Up: syslib bytevectors accessors

12.17.5.1 8-bit setters and getters
...................................

For these operations: the argument BV is a bytevector object; the
argument FX-IDX is a non-negative fixnum representing an index in the
bytevector; FX-VAL is a fixnum representing a value to be stored in a
bytevector.

 -- Unsafe Operation: $bytevector-u8-ref BV FX-IDX
     Return a fixnum representing the octet at offset FX-IDX in BV.

 -- Unsafe Operation: $bytevector-s8-ref BV FX-IDX
     Return a fixnum representing the byte at offset FX-IDX in BV.

 -- Unsafe Operation: $bytevector-set! BV FX-IDX FX-VALUE
 -- Unsafe Operation: $bytevector-u8-set! BV FX-IDX FX-VALUE
 -- Unsafe Operation: $bytevector-s8-set! BV FX-IDX FX-VALUE
     Store the octet or byte FX-VALUE at index FX-IDX of BV.


File: vicare-scheme.info,  Node: syslib bytevectors accessors 16-bit,  Next: syslib bytevectors accessors 32-bit,  Prev: syslib bytevectors accessors 8-bit,  Up: syslib bytevectors accessors

12.17.5.2 16-bit setters and getters
....................................

About 16-bit words, we have to remember the following memory layouts:

                |            | lowest memory | highest memory
     endianness |    word    | location      | location
     -----------+------------+---------------+--------------
       little   |   #xHHLL   |     LL        |     HH
        big     |   #xHHLL   |     HH        |     LL

   For these operations: the argument BV is a bytevector object; the
argument FX-IDX is a non-negative fixnum representing an octet index in
the bytevector; FX-VAL is a fixnum representing a value to be stored in
a bytevector.

     *NOTE* For these operations: the index FX-IDX does *not* need to be
     aligned to a multiple of 2.

 -- Function: $bytevector-u16l-ref BV FX-IDX
 -- Function: $bytevector-u16l-set! BV FX-IDX FX-VAL
     Setter and getter for unsigned little-endian 16-bit words.

 -- Function: $bytevector-u16b-ref BV FX-IDX
 -- Function: $bytevector-u16b-set! BV FX-IDX FX-VAL
     Setter and getter for unsigned big-endian 16-bit words.

 -- Function: $bytevector-u16n-ref BV FX-IDX
 -- Function: $bytevector-u16n-set! BV FX-IDX FX-VAL
     Setter and getter for unsigned native-endian 16-bit words.

 -- Function: $bytevector-s16l-ref BV FX-IDX
 -- Function: $bytevector-s16l-set! BV FX-IDX FX-VAL
     Setter and getter for signed little-endian 16-bit words.

 -- Function: $bytevector-s16b-ref BV FX-IDX
 -- Function: $bytevector-s16b-set! BV FX-IDX FX-VAL
     Setter and getter for signed big-endian 16-bit words.

 -- Function: $bytevector-s16n-ref BV FX-IDX
 -- Function: $bytevector-s16n-set! BV FX-IDX FX-VAL
     Setter and getter for signed native-endian 16-bit words.

 -- Function: $bytevector-u16-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-u16-set! BV FX-IDX FX-VAL ENDIANNESS
     Setter and getter for unsigned 16-bit words.  ENDIANNESS must be a
     symbol among: 'big', 'little', 'native'.

 -- Function: $bytevector-s16-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-s16-set! BV FX-IDX FX-VAL ENDIANNESS
     Setter and getter for signed 16-bit words.  ENDIANNESS must be a
     symbol among: 'big', 'little', 'native'.


File: vicare-scheme.info,  Node: syslib bytevectors accessors 32-bit,  Next: syslib bytevectors accessors 64-bit,  Prev: syslib bytevectors accessors 16-bit,  Up: syslib bytevectors accessors

12.17.5.3 32-bit setters and getters
....................................

About 32-bit words, we have to remember the following memory layouts:

                               lowest memory ------------> highest memory
     endianness |    word    | 1st byte | 2nd byte | 3rd byte | 4th byte
     -----------+------------+----------+----------+----------+----------
       little   | #xAABBCCDD |   DD     |    CC    |    BB    |    AA
        big     | #xAABBCCDD |   AA     |    BB    |    CC    |    DD
     bit offset |            |    0     |     8    |    16    |    24

   For these operations: the argument BV is a bytevector object; the
argument FX-IDX is a non-negative fixnum representing an octet index in
the bytevector; EI-VAL is a fixnum or bignum representing a value to be
stored in a bytevector.

     *NOTE* For these operations: the index FX-IDX does *not* need to be
     aligned to a multiple of 4.

 -- Function: $bytevector-u32l-ref BV FX-IDX
 -- Function: $bytevector-u32l-set! BV FX-IDX EI-VAL
     Setter and getter for unsigned little-endian 32-bit words.

 -- Function: $bytevector-u32b-ref BV FX-IDX
 -- Function: $bytevector-u32b-set! BV FX-IDX EI-VAL
     Setter and getter for unsigned big-endian 32-bit words.

 -- Function: $bytevector-u32n-ref BV FX-IDX
 -- Function: $bytevector-u32n-set! BV FX-IDX EI-VAL
     Setter and getter for unsigned native-endian 32-bit words.

 -- Function: $bytevector-s32l-ref BV FX-IDX
 -- Function: $bytevector-s32l-set! BV FX-IDX EI-VAL
     Setter and getter for signed little-endian 32-bit words.

 -- Function: $bytevector-s32b-ref BV FX-IDX
 -- Function: $bytevector-s32b-set! BV FX-IDX EI-VAL
     Setter and getter for signed big-endian 32-bit words.

 -- Function: $bytevector-s32n-ref BV FX-IDX
 -- Function: $bytevector-s32n-set! BV FX-IDX EI-VAL
     Setter and getter for signed native-endian 32-bit words.

 -- Function: $bytevector-u32-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-u32-set! BV FX-IDX EI-VAL ENDIANNESS
     Setter and getter for unsigned 32-bit words.  ENDIANNESS must be a
     symbol among: 'big', 'little', 'native'.

 -- Function: $bytevector-s32-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-s32-set! BV FX-IDX EI-VAL ENDIANNESS
     Setter and getter for signed 32-bit words.  ENDIANNESS must be a
     symbol among: 'big', 'little', 'native'.


File: vicare-scheme.info,  Node: syslib bytevectors accessors 64-bit,  Next: syslib bytevectors accessors single,  Prev: syslib bytevectors accessors 32-bit,  Up: syslib bytevectors accessors

12.17.5.4 64-bit setters and getters
....................................

About 64-bit words, we have to remember the following memory layouts:

                                          lowest memory ------------> highest memory
     endianness |         word        | 1st | 2nd | 3rd | 4th | 5th | 6th | 7th | 8th
     -----------+---------------------+-----+-----+-----+-----+-----+-----+-----+-----
       little   | #xAABBCCDD EEFFGGHH | HH  | GG  | FF  | EE  | DD  | CC  | BB  | AA
        big     | #xAABBCCDD EEFFGGHH | AA  | BB  | CC  | DD  | EE  | FF  | GG  | HH
     bit offset |                     |  0  |  8  | 16  | 24  | 32  | 40  | 48  | 56

   For these operations: the argument BV is a bytevector object; the
argument FX-IDX is a non-negative fixnum representing an octet index in
the bytevector; EI-VAL is a fixnum or bignum representing a value to be
stored in a bytevector.

     *NOTE* For these operations: the index FX-IDX does *not* need to be
     aligned to a multiple of 8.

 -- Function: $bytevector-u64l-ref BV FX-IDX
 -- Function: $bytevector-u64l-set! BV FX-IDX EI-VAL
     Setter and getter for unsigned little-endian 64-bit words.

 -- Function: $bytevector-u64b-ref BV FX-IDX
 -- Function: $bytevector-u64b-set! BV FX-IDX EI-VAL
     Setter and getter for unsigned big-endian 64-bit words.

 -- Function: $bytevector-u64n-ref BV FX-IDX
 -- Function: $bytevector-u64n-set! BV FX-IDX EI-VAL
     Setter and getter for unsigned native-endian 64-bit words.

 -- Function: $bytevector-s64l-ref BV FX-IDX
 -- Function: $bytevector-s64l-set! BV FX-IDX EI-VAL
     Setter and getter for signed little-endian 64-bit words.

 -- Function: $bytevector-s64b-ref BV FX-IDX
 -- Function: $bytevector-s64b-set! BV FX-IDX EI-VAL
     Setter and getter for signed big-endian 64-bit words.

 -- Function: $bytevector-s64n-ref BV FX-IDX
 -- Function: $bytevector-s64n-set! BV FX-IDX EI-VAL
     Setter and getter for signed native-endian 64-bit words.

 -- Function: $bytevector-u64-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-u64-set! BV FX-IDX EI-VAL ENDIANNESS
     Setter and getter for unsigned 64-bit words.  ENDIANNESS must be a
     symbol among: 'big', 'little', 'native'.

 -- Function: $bytevector-s64-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-s64-set! BV FX-IDX EI-VAL ENDIANNESS
     Setter and getter for signed 64-bit words.  ENDIANNESS must be a
     symbol among: 'big', 'little', 'native'.


File: vicare-scheme.info,  Node: syslib bytevectors accessors single,  Next: syslib bytevectors accessors double,  Prev: syslib bytevectors accessors 64-bit,  Up: syslib bytevectors accessors

12.17.5.5 Single-precision IEEE flonum setters and getters
..........................................................

For these operations: the argument BV is a bytevector object; the
argument FX-IDX is a non-negative fixnum representing an octet index in
the bytevector; FL is a flonum representing a value to be stored in a
bytevector.

     *NOTE* For these operations: the index FX-IDX does *not* need to be
     aligned to a multiple of 4.

 -- Function: $bytevector-ieee-single-big-ref BV FX-IDX
 -- Function: $bytevector-ieee-single-big-set! BV FX-IDX FL
     Setter and getter for single-precision IEEE flonums under big
     endianness.

 -- Function: $bytevector-ieee-single-little-ref BV FX-IDX
 -- Function: $bytevector-ieee-single-little-set! BV FX-IDX FL
     Setter and getter for single-precision IEEE flonums under little
     endianness.

 -- Unsafe Operation: $bytevector-ieee-single-native-ref BV FX-IDX
 -- Unsafe Operation: $bytevector-ieee-single-native-set! BV FX-IDX FL
     Setter and getter for single-precision IEEE flonums under native
     endianness.

 -- Unsafe Operation: $bytevector-ieee-single-nonnative-ref BV FX-IDX
 -- Unsafe Operation: $bytevector-ieee-single-nonnative-set! BV FX-IDX
          FL
     Setter and getter for single-precision IEEE flonums under
     non-native endianness.

 -- Function: $bytevector-ieee-single-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-ieee-single-set! BV FX-IDX EI-VAL ENDIANNESS
     Setter and getter for single-precision IEEE flonums.  ENDIANNESS
     must be a symbol among: 'big', 'little', 'native'.


File: vicare-scheme.info,  Node: syslib bytevectors accessors double,  Prev: syslib bytevectors accessors single,  Up: syslib bytevectors accessors

12.17.5.6 Double-precision IEEE flonum setters and getters
..........................................................

For these operations: the argument BV is a bytevector object; the
argument FX-IDX is a non-negative fixnum representing an octet index in
the bytevector; FL is a flonum representing a value to be stored in a
bytevector.

     *NOTE* For these operations: the index FX-IDX does *not* need to be
     aligned to a multiple of 8.

 -- Function: $bytevector-ieee-double-big-ref BV FX-IDX
 -- Function: $bytevector-ieee-double-big-set! BV FX-IDX FL
     Setter and getter for double-precision IEEE flonums under big
     endianness.

 -- Function: $bytevector-ieee-double-little-ref BV FX-IDX
 -- Function: $bytevector-ieee-double-little-set! BV FX-IDX FL
     Setter and getter for double-precision IEEE flonums under little
     endianness.

 -- Unsafe Operation: $bytevector-ieee-double-native-ref BV FX-IDX
 -- Unsafe Operation: $bytevector-ieee-double-native-set! BV FX-IDX FL
     Setter and getter for double-precision IEEE flonums under native
     endianness.

 -- Unsafe Operation: $bytevector-ieee-double-nonnative-ref BV FX-IDX
 -- Unsafe Operation: $bytevector-ieee-double-nonnative-set! BV FX-IDX
          FL
     Setter and getter for double-precision IEEE flonums under
     non-native endianness.

 -- Function: $bytevector-ieee-double-ref BV FX-IDX ENDIANNESS
 -- Function: $bytevector-ieee-double-set! BV FX-IDX EI-VAL ENDIANNESS
     Setter and getter for double-precision IEEE flonums.  ENDIANNESS
     must be a symbol among: 'big', 'little', 'native'.


File: vicare-scheme.info,  Node: syslib bytevectors copying,  Next: syslib bytevectors concatenating,  Prev: syslib bytevectors accessors,  Up: syslib bytevectors

12.17.6 Copying
---------------

For these operations, the arguments have the following meaning:

SRC.BV
     The source bytevector.

SRC.START
     A non-negative fixnum representing the inclusive start index in the
     source bytevector SRC.BV.

SRC.END
     A non-negative fixnum representing the exclusive end index in the
     source bytevector SRC.BV.

DST.BV
     The destination bytevector.

DST.START
     A non-negative fixnum representing the inclusive start index in the
     destination bytevector DST.BV.

DST.END
     A non-negative fixnum representing the exclusive end index in the
     destination bytevector SRC.BV.

 -- Function: $bytevector-copy BV
     Build and return a copy of the bytevector BV.

 -- Function: $bytevector-copy! SRC.BV SRC.START DST.BV DST.START
          SRC.END
     Copy the bytes of SRC.BV from SRC.START inclusive to SRC.END
     exclusive, to DST.BV starting at DST.START inclusive.

 -- Function: $bytevector-copy!/count SRC.BV SRC.START DST.BV DST.START
          COUNT
     Copy COUNT bytes from SRC.BV starting at SRC.START inclusive to
     DST.BV starting at DST.START inclusive.

 -- Function: $bytevector-self-copy-forwards!/count BV SRC.START
          DST.START COUNT
     Copy COUNT bytes of BV from SRC.START inclusive to BV itself
     starting at DST.START inclusive.  The copy happens forwards, so it
     is suitable for the case:

          SRC.START > DST.START

 -- Function: $bytevector-self-copy-backwards!/count BV SRC.START
          DST.START COUNT
     Copy COUNT bytes of BV from SRC.START inclusive to BV itself
     starting at DST.START inclusive.  The copy happens backwards, so it
     is suitable for the case:

          SRC.START < DST.START


File: vicare-scheme.info,  Node: syslib bytevectors concatenating,  Next: syslib bytevectors encodings,  Prev: syslib bytevectors copying,  Up: syslib bytevectors

12.17.7 Concatenating
---------------------

 -- Function: $bytevector-total-length INIT-FX BVS
     Given the list of bytevectors BVS: compute the total length of the
     bytevectors, add it to the fixnum INIT-FX and return the result.
     If INIT-FX is zero: the returned value is the total length of the
     bytevectors in BVS.  The returned value may or may not be in the
     range of the maximum bytevector size: it may or may not be a
     fixnum.

 -- Function: $bytevector-concatenate TOTAL-LEN-FX BVS
     Concatenate the bytevectors in the list BVS, return the result.
     The resulting bytevector must have length represented by the
     non-negative fixnum TOTAL-LEN-FX.

 -- Function: $bytevector-reverse-and-concatenate TOTAL-LEN-FX BVS
     Reverse the list of bytevectors BVS and concatenate its items;
     return the result.  The resulting bytevector must have length
     represented by the non-negative fixnum TOTAL-LEN-FX.


File: vicare-scheme.info,  Node: syslib bytevectors encodings,  Prev: syslib bytevectors concatenating,  Up: syslib bytevectors

12.17.8 Encodings
-----------------

 -- Function: $octets-encoded-bytevector? BV
     Always return '#t'.

 -- Function: $ascii-encoded-bytevector? BV
     Return '#t' if BV can be interpreted as an ASCII encoded string,
     otherwise return '#f'.  An octet CHI is considered an ASCII code
     point if:

          (<= #x00 CHI #x7F)      => #t

 -- Function: $latin1-encoded-bytevector? BV
     Return '#t' if BV can be interpreted as a Latin-1 encoded string,
     otherwise return '#f'.  An octet CHI is considered a Latin1 code
     point if:

          (or (<= #x20 CHI #x7E)
              (<= #xA0 CHI #xFF))
          => #t

 -- Function: $uri-encode BV
 -- Function: $uri-decode BV
     Encode or decode a bytevector BV according to RFC 3986 URI percent
     encoding; return a bytevector.  All the octets are encoded except
     the ones having the following ASCII representation:

          ABCDEFGHIJKLMNOPQRSTUVWXYZ
          abcdefghijklmnopqrstuvwxyz
          0123456789
          -._~

 -- Function: $uri-normalise-encoding BV
     Given a bytevector BV encoded according to to RFC 3986 URI percent
     encoding: return an encoded and normalised bytevector, octets that
     are encoded but should not are decoded.

 -- Function: $uri-encoded-bytevector? BV
 -- Function: $percent-encoded-bytevector? BV
     Return '#t' if the argument is a correctly percent-encoded
     bytevector according to RFC 3986.

 -- Function: $base64->bytevector BV
 -- Function: $bytevector->base64 BV
     Convert to and from a Scheme bytevector containing octets and a
     Scheme bytevector containing the ASCII Base64 representation of the
     octets.  If an error occurs in the conversion: the return value is
     '#f'.


File: vicare-scheme.info,  Node: syslib strings,  Next: syslib ports,  Prev: syslib bytevectors,  Up: syslib

12.18 Low level string operations
=================================

The arguments STR to these operations must be references to strings, the
arguments FX must be fixnums in the appropriate range, the arguments CH
must be characters.  The following bindings are exported by the library
'(vicare system $strings)'.

Constructors
............

 -- Unsafe Operation: $make-string FX
     Allocate a new string capable of holding FX characters and return a
     reference to it.

 -- Unsafe Operation: $string CH ...
     Allocate a new string and initialise it with the given characters.

 -- Function: $string-copy STR
     Build and return a newly allocated string holding the same
     characters of STR.

 -- Function: $string-copy! SRC.STR SRC.START DST.STR DST.START SRC.END
     Copy the characters of SRC.STR from SRC.START inclusive to SRC.END
     exclusive, to DST.STR starting at DST.START inclusive.

 -- Function: $string-copy!/count SRC.STR SRC.START DST.STR DST.START
          COUNT
     Copy COUNT characters from SRC.STR starting at SRC.START inclusive
     to DST.STR starting at DST.START inclusive.

 -- Function: $string-self-copy-forwards!/count STR SRC.START DST.START
          COUNT
     Copy COUNT characters of STR from SRC.START inclusive to STR itself
     starting at DST.START inclusive.  The copy happens forwards, so it
     is suitable for the case 'SRC.START > DST.START'.

 -- Function: $string-self-copy-backwards!/count STR SRC.START DST.START
          COUNT
     Copy COUNT characters of STR from SRC.START inclusive to STR itself
     starting at DST.START inclusive.  The copy happens backwards, so it
     is suitable for the case 'SRC.START < DST.START'.

 -- Function: $substring STR START END
     Build and return a newly allocated string holding the range of
     character between START (inclusive) and END (exclusive).

 -- Function: $string-concatenate TOTAL-LEN STRS
     Concatenate the strings in the list STRS, return the result.  The
     resulting string must have length TOTAL-LEN.  Assume the arguments
     have been already validated.

 -- Function: $string-reverse-and-concatenate TOTAL-LEN STRS
     Reverse the list of strings STRS and concatenate its items; return
     the result.  The resulting string must have length TOTAL-LEN.
     Assume the arguments have been already validated.

Accessors and mutators
......................

 -- Unsafe Operation: $string-ref STR FX
     Return the character at offset FX in STR.

 -- Unsafe Operation: $string-set! STR FX CH
     Store CH at index FX of STR.

 -- Function: $string-fill! STR START END FILL
     Fill the positions in STR from START inclusive to END exclusive
     with FILL.

Inspection
..........

 -- Unsafe Operation: $string-length STR
     Return a fixnum representing the length of the operand.

 -- Function: $string-total-length INIT-LEN STRS
     Given the list of strings STRS: compute the total length of the
     strings, add it to INIT-LEN and return the result.  If INIT-LEN is
     zero: the returned value is the total length of the strings in
     STRS.  The returned value may or may not be in the range of the
     maximum string size.

 -- Unsafe Operations: $string-empty? STR
     Return '#t' if the string STR is empty, otherwise return '#f'.

Comparison
..........

 -- Unsafe Operation: $string= STR1 STR2
     Return '#t' if STR1 and STR2 represent the same string; otherwise
     return '#f'.

 -- Function: $string!=? STR1 STR2
     The arguments must be booleans.  Return '#t' if the arguments are
     different; otherwise return '#f'.

 -- Unsafe Operation: $string< STR1 STR2
 -- Unsafe Operation: $string> STR1 STR2
 -- Unsafe Operation: $string<= STR1 STR2
 -- Unsafe Operation: $string>= STR1 STR2
     Dyadic lexicographic comparison functions for strings.  Return '#t'
     if STR1 and STR2 compare as the name implies; otherwise return
     '#f'.

 -- Function: $string-max STR1 STR2
 -- Function: $string-min STR1 STR2
     Return the maximal or minimal string argument according to
     '$string<'.

Conversion function
...................

 -- Unsafe Operation: $fixnum->string FX BASE
     Return a string object representing FX in BASE.  BASE must be one
     among: 2, 8, 10, 16.

 -- Function: $string->latin1 STRING
 -- Function: $latin1->string BYTEVEVCTOR
     Convert to and from a Scheme string and a Scheme bytevector holding
     the Latin-1 encoding of the characters.  If a character in STRING
     is out of range: raise an exception; this validation is *not*
     removed when arguments validation is disabled.

 -- Function: $string->octets STRING
 -- Function: $octets->string BYTEVECTOR
     Convert to and from a Scheme string and a Scheme bytevector holding
     the raw octets encoding of the characters.  Octets are converted to
     characters with '$fixnum->char'; characters are converted to octets
     with '$char->fixnum'.  Raise an exception if the conversion is not
     possible; this validation is *not* removed when arguments
     validation is disabled.

 -- Function: $string->ascii STRING
 -- Function: $ascii->string BYTEVEVCTOR
     Convert to and from a Scheme string and a Scheme bytevector holding
     the ASCII encoding of the characters.  If a character in STRING is
     out of range: raise an exception; this validation is *not* removed
     when arguments validation is disabled.

 -- Function: $octets-encoded-string? STRING
     Return '#t' if STRING can be interpreted as an octets encoded
     string, otherwise return '#f'.  A character is considered
     octets-encoded if its integer representation CHI satisfies:

          (<= 0 CHI 255)      => #t

 -- Function: $ascii-encoded-string? STRING
     Return '#t' if STRING can be interpreted as an ASCII encoded
     string, otherwise return '#f'.  A character is considered an ASCII
     code point if its integer representation CHI satisfies:

          (<= #x00 CHI #x7F)      => #t

 -- Function: $latin1-encoded-string? STRING
     Return '#t' if STRING can be interpreted as a Latin1 encoded
     string, otherwise return '#f'.  A character in the string is
     considered a Latin1 code point if its integer representation CHI
     satisfies:

          (or (<= #x20 CHI #x7E)
              (<= #xA0 CHI #xFF))
          => #t

 -- Function: $string-base64->bytevector STRING
 -- Function: $bytevector->string-base64 BYTEVECTOR
     Convert to and from a Scheme string and a Scheme bytevector.  The
     input string contains the ASCII Base64 representation of the
     octets.  The output string contains the ASCII Base64 representation
     of octets.  If an error occurs in the conversion: an exception is
     raised.

 -- Function: $uri-encoded-string? STRING
 -- Function: $percent-encoded-string? STRING
     Return '#t' if the argument is correctly percent-encoded string
     according to RFC 3986.  This means every character in the string is
     associated to a character in the ASCII encoding and additionally
     the constraints of RFC 3986 are satisfied.

     If the characters in STRING are invalid: raise an exception; this
     validation is *not* removed when arguments validation is disabled.

Miscellaneous functions
.......................

 -- Unsafe Operation: $interned-strings
     Return a vector holding the currently interned strings.


File: vicare-scheme.info,  Node: syslib ports,  Next: syslib transcoders,  Prev: syslib strings,  Up: syslib

12.19 Low level port structures
===============================

The following bindings are exported by the library '(vicare system
$io)'.

 -- Function: port? OBJ
     Return true if OBJ is the reference to a port structure; return
     false otherwise.

 -- Unsafe Operation: $make-port ATTRS IDX SZ BUF TR ID READ WRITE GETP
          SETP CL COOKIE
     Allocate a new port structure, initialise its fields with the
     arguments, return a reference to it.

 -- Unsafe Operation: $port-index PORT
 -- Unsafe Operation: $port-size PORT
 -- Unsafe Operation: $port-buffer PORT
 -- Unsafe Operation: $port-transcoder PORT
 -- Unsafe Operation: $port-id PORT
 -- Unsafe Operation: $port-read! PORT
 -- Unsafe Operation: $port-write! PORT
 -- Unsafe Operation: $port-get-position PORT
 -- Unsafe Operation: $port-set-position! PORT
 -- Unsafe Operation: $port-close PORT
 -- Unsafe Operation: $port-cookie PORT
     Accessors for the fields of a port structure.

 -- Unsafe Operation: $port-attrs PORT
     Given a port value: return a fixnum representing the port
     attributes.

 -- Safe Operation: $port-tag PORT
     Extract from a port reference a fixnum representing the port
     attributes; if the argument is not a port reference the return
     value is zero.

 -- Unsafe Operation: $set-port-index! PORT NEW-INDEX
     Mutator for the buffer index field.

 -- Unsafe Operation: $set-port-size! PORT NEW-USED-SIZE
     Mutator for the buffer used size field.

 -- Unsafe Operation: $set-port-attrs! PORT NEW-ATTRS
     Mutator for the port attributes.


File: vicare-scheme.info,  Node: syslib transcoders,  Next: syslib pointers,  Prev: syslib ports,  Up: syslib

12.20 Low level transcoder operations
=====================================

The arguments TRAN to these operations must be transcoders, the
arguments FX must be fixnums in the appropriate range.  The following
bindings are exported by the library '(vicare system $transcoders)'.

 -- Unsafe Operation: $data->transcoder FX
     Encode FX as payload bits of a transcoder word and return the
     resulting transcoder.

 -- Unsafe Operation: $transcoder->data TRAN
     Extract the payload bits from a transcoder and return them as
     fixnum.

 -- Unsafe Operation: $transcoder= TRAN1 TRAN2
 -- Unsafe Operation: $transcoder!= TRAN1 TRAN2
 -- Unsafe Operation: $transcoder< TRAN1 TRAN2
 -- Unsafe Operation: $transcoder> TRAN1 TRAN2
 -- Unsafe Operation: $transcoder<= TRAN1 TRAN2
 -- Unsafe Operation: $transcoder>= TRAN1 TRAN2
     Compare the given transcoders and return '#t' or '#f'.

 -- Unsafe Operation: $transcoder-min TRAN1 TRAN2
 -- Unsafe Operation: $transcoder-max TRAN1 TRAN2
     Return the minimum or maximum transcoder among the arguments.


File: vicare-scheme.info,  Node: syslib pointers,  Next: syslib hashtables,  Prev: syslib transcoders,  Up: syslib

12.21 Low level pointer operations
==================================

In the following definitions the PTR arguments must be pointer objects.
The following bindings are exported by the library '(vicare system
$pointers)'.

Comparison
..........

 -- Unsafe Operation: $pointer= PTR1 PTR2
     Return '#t' if PTR1 and PTR2 are equal, else return '#f'.

 -- Function: $pointer!=? PTR1 PTR2
     The arguments must be pointers.  Return '#t' if the arguments are
     different; otherwise return '#f'.

 -- Unsafe Operation: $pointer< PTR1 PTR2
 -- Unsafe Operation: $pointer> PTR1 PTR2
 -- Unsafe Operation: $pointer<= PTR1 PTR2
 -- Unsafe Operation: $pointer>= PTR1 PTR2
     Dyadic lexicographic comparison functions for pointers.  Return
     '#t' if PTR1 and PTR2 compare as the name implies; otherwise return
     '#f'.

 -- Function: $pointer-max PTR1 PTR2
 -- Function: $pointer-min PTR1 PTR2
     Return the maximal or minimal pointer argument according to
     '$pointer<'.


File: vicare-scheme.info,  Node: syslib hashtables,  Next: syslib tcbuckets,  Prev: syslib pointers,  Up: syslib

12.22 Low level hashtable objects operations
============================================

The following bindings are exported by the library '(vicare system
$hashtables)'.

 -- Unsafe Operation: $string-hash STRING
 -- Unsafe Operation: $string-hash STRING MAX-LEN
     Return an integer hash value for STRING, based on its current
     contents.  This hash function is suitable for use with 'string=?'
     as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of characters to use to compute the hash value,
          starting from the beginning of STRING.  If the length of
          STRING is greater than MAX-LEN: only the first MAX-LEN
          characters are used.  If the length of STRING is less than or
          equal to MAX-LEN: all the bytes in STRING are used.

        * When MAX-LEN is '#f' or not used: if the length of STRING is
          greater than 64 characters, only the first 64 bytes are used
          to compute the hash.

        * When MAX-LEN is '#t': all the bytes in STRING are used.

     *NOTE* When the hash value is computed using a number of characters
     N less than the string length: applications *must not* assume that
     two strings having the first N characters equal will have the same
     hash value.

 -- Unsafe Operation: $string-ci-hash STRING
 -- Unsafe Operation: $string-ci-hash STRING MAX-LEN
     Return an integer hash value for STRING based on its current
     contents, ignoring case.  This hash function is suitable for use
     with 'string-ci=?' as an equivalence function.

     The optional argument MAX-LEN is used as in '$string-hash'.

 -- Unsafe Operation: $symbol-hash SYMBOL
     Return an integer hash value for SYMBOL.

 -- Unsafe Operation: $bytevector-hash BYTEVECTOR
 -- Unsafe Operation: $bytevector-hash BYTEVECTOR MAX-LEN
     Return an integer hash value for BYTEVECTOR, based on its current
     contents.  This hash function is suitable for use with
     'bytevector=?' as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of bytes to use to compute the hash value, starting
          from the beginning of BV.  If the length of BV is greater than
          MAX-LEN: only the first MAX-LEN bytes are used.  If the length
          of BV is less than or equal to MAX-LEN: all the bytes in BV
          are used.

        * When MAX-LEN is '#f' or not present: if the length of BV is
          greater than 256 bytes, only the first 256 bytes are used to
          compute the hash.

        * When MAX-LEN is '#t': all the bytes in BV are used.

     *NOTE* When the hash value is computed using a number of bytes N
     less than the bytevector length: applications *must not* assume
     that two bytevectors having the first N bytes equal will have the
     same hash value.

 -- Unsafe Operation: $vector-hash VEC
 -- Unsafe Operation: $vector-hash VEC MAX-LEN
     Return a non-negative fixnum representing the hash value for VEC,
     based on its current contents.  When creating hash tables using
     vectors as keys: this hash function is suitable for use with
     'vector=?' as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of items to use to compute the hash value, starting
          from the beginning of VEC.  If the length of VEC is greater
          than MAX-LEN: only the first MAX-LEN items are used.  If the
          length of VEC is less than or equal to MAX-LEN: all the items
          in VEC are used.

        * When MAX-LEN is '#f' or not present: if the length of VEC is
          greater than 3 items, only the first 3 items are used to
          compute the hash.

        * When MAX-LEN is '#t': all the items in VEC are used.

     *NOTE* When the hash value is computed using a number of items N
     less than the vector length: applications *must not* assume that
     two vectors having the first N items equal will have the same hash
     value.

 -- Unsafe Operation: $list-hash ELL
 -- Unsafe Operation: $list-hash ELL MAX-LEN
     Return a non-negative fixnum representing the hash value for ELL,
     based on its current contents.  When creating hash tables using
     lists as keys: this hash function is suitable for use with 'list=?'
     as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of items to use to compute the hash value, starting
          from the beginning of ELL.  If the length of ELL is greater
          than MAX-LEN: only the first MAX-LEN items are used.  If the
          length of ELL is less than or equal to MAX-LEN: all the items
          in ELL are used.

        * When MAX-LEN is '#f' or not present: if the length of ELL is
          greater than 3 items, only the first 3 items are used to
          compute the hash.

        * When MAX-LEN is '#t': all the items in ELL are used.

     *NOTE* When the hash value is computed using a number of items N
     less than the list length: applications *must not* assume that two
     lists having the first N items equal will have the same hash value.

 -- Unsafe Operation: $pair-hash PAIR
 -- Unsafe Operation: $ipair-hash IPAIR
     Hash function for pairs and immutable pairs.

 -- Unsafe Operation: $char-hash CH
 -- Unsafe Operation: $char-ci-hash CH
     Compute and return the hash value.

 -- Unsafe Operation: $fixnum-hash FX
     Compute and return the hash value.

 -- Unsafe Operation: $bignum-hash BN
     Compute and return the hash value.

 -- Unsafe Operation: $exact-integer-hash EI
     Compute and return the hash value.

 -- Unsafe Operation: $ratnum-hash RN
     Compute and return the hash value.

 -- Unsafe Operation: $flonum-hash FL
     Compute and return the hash value.

 -- Unsafe Operation: $cflonum-hash CFL
     Compute and return the hash value.

 -- Unsafe Operation: $compnum-hash CN
     Compute and return the hash value.

 -- Unsafe Operation: $transcoder-hash TRAN
     Compute and return the hash value.

 -- Unsafe Operation: $enum-set-hash ES
     Hash function for enumeration sets.

 -- Unsafe Operation: $pointer-hash PTR
     Return a fixnum representing the hash value of PTR.

 -- Unsafe Operation: $promise-hash PROM
     Hash function for promise objects.

 -- Unsafe Operation: $record-hash RECO
 -- Unsafe Operation: $struct-hash STRU
     Compute and return the hash value.

          *NOTE* The result returned by these hash functions depends on
          the values in the fields, so: it will change if the fields are
          mutated.

 -- Unsafe Operation: $hashtable-type-descriptor TABLE
 -- Unsafe Operation: $hashtable-type-descriptor-set! TABLE DES
     Setter and getter for the hashtable run-time type descriptor.  DES
     must be an instance of '<hashtable-type-descr>'.


File: vicare-scheme.info,  Node: syslib tcbuckets,  Next: syslib codes,  Prev: syslib hashtables,  Up: syslib

12.23 Low level tcbucket objects operations
===========================================

'<tcbuckets>' are objects used in the implementation of hash tables.
*note Components for hashtables: objects tcbuckets.  In the following
definitions: the BUCKET arguments must be tcbucket objects.  The
following bindings are exported by the library '(vicare system
$tcbucket)'.

 -- Unsafe Operation: $make-tcbucket TCONC KEY VAL NEXT
     Build and return a new '<tcbucket>' object.  See the documentation
     of the object for the meaning of the arguments.

 -- Unsafe Operation: $tcbucket-tconc BUCKET
 -- Unsafe Operation: $set-tcbucket-tconc! BUCKET TCONC
     Accessor and mutator for the 'tconc' field.

 -- Unsafe Operation: $tcbucket-key BUCKET
 -- Unsafe Operation: $set-tcbucket-key! BUCKET KEY
     Accessor and mutator for the 'key' field.

 -- Unsafe Operation: $tcbucket-val BUCKET
 -- Unsafe Operation: $set-tcbucket-val! BUCKET VAL
     Accessor and mutator for the 'val' field.

 -- Unsafe Operation: $tcbucket-next BUCKET
 -- Unsafe Operation: $set-tcbucket-next! BUCKET NEXT
     Accessor and mutator for the 'next' field.


File: vicare-scheme.info,  Node: syslib codes,  Next: syslib closures,  Prev: syslib tcbuckets,  Up: syslib

12.24 Low level code objects operations
=======================================

* Menu:

* syslib codes safe::           Safe code objects operations.
* syslib codes unsafe::         Unsafe code objects operations.


File: vicare-scheme.info,  Node: syslib codes safe,  Next: syslib codes unsafe,  Up: syslib codes

12.24.1 Safe code objects operations
------------------------------------

Code objects contain compiled binary code ready to be executed by the
host's processor.  *note Code objects: objects codes. for details on the
code object's internals.  In the following definitions: the CODE
arguments must be code objects.  The following bindings are exported by
the library '(vicare system code-objects)'.

 -- Function: make-code CODE-SIZE FREEVARS-NUM
     Build and return a new "empty" code object.  The argument CODE-SIZE
     is the number of bytes allocated in the data area of the object, to
     be filled later with machine code; it is a non-negative fixnum.
     The argument FREEVARS-NUM is the number of free variables
     referenced by the machine code; it is a non-negative fixnum.

 -- Function: code? OBJ
     Return '#t' if OBJ is a code object.

 -- Function: code-size CODE
     Return a non-negative fixnum representing the number of bytes
     allocated in the data area of the object.

 -- Function: code-freevars CODE
     Return a non-negative fixnum representing the number of free
     variables referenced by the machine code.

 -- Function: set-code-reloc-vector! CODE RELOC-VEC
 -- Function: code-reloc-vector CODE
     Setter and getter for the relocation vector.

 -- Function: code-set! CODE IDX OCTET
     Store the OCTET at index IDX in the data area of the CODE object.
     IDX must be a non-negative fixnum.  OCTET must be part of the
     machine code.

 -- Function: code-ref CODE IDX
     Return the octet at index IDX in the data area of the CODE object.

 -- Function: set-code-annotation! CODE ANN
     Set the code annotation.  Return unspecified values.

 -- Function: code->thunk CODE
     Return a closure object associated to the CODE object.

 -- Function: procedure-annotation PROC
     Return the procedure annotation of the closure object PROC.

 -- Function: code-reloc-vector->sexp CODE
     Extract the relocation vector from CODE and compose a symbolic
     expression representing its fields; return the symbolic expression.
     CODE must be a code object or a closure object or a vector object.


File: vicare-scheme.info,  Node: syslib codes unsafe,  Prev: syslib codes safe,  Up: syslib codes

12.24.2 Unsafe code objects operations
--------------------------------------

In the following definitions: the CODE arguments must be code objects.
The following bindings are exported by the library '(vicare system
$codes)'.

 -- Primitive Operation: $code-freevars CODE
     Return a fixnum representing the number of free variables
     referenced by CODE.

 -- Primitive Operation: $code-reloc-vector CODE
     Return the relocation vector of CODE.  The relocation vector is a
     Scheme vector, *note objects codes reloc::.

 -- Primitive Operation: $code-size CODE
     Return a fixnum representing the number of bytes used in the data
     area of CODE.

 -- Primitive Operation: $code-annotation CODE
     Return an object used as annotation for CODE.  The default value
     for the annotation is '#f'.

 -- Primitive Operation: $code->closure CODE
     Return a closure object wrapping CODE.

 -- Primitive Operation: $code-ref CODE INDEX
     Return the byte at INDEX in the data area of CODE.

 -- Primitive Operation: $code-set! CODE INDEX OCTET
     Store OCTET at INDEX in the data area of CODE.  Both INDEX and
     OCTET must be fixnums; OCTET must be in the range [0, 255].

 -- Primitive Operation: $set-code-annotation CODE OBJ
     Store OBJ in the annotation field of CODE.


File: vicare-scheme.info,  Node: syslib closures,  Next: syslib compar,  Prev: syslib codes,  Up: syslib

12.25 Low level closures operations
===================================

In the following definitions the CLOSURE arguments must be closure
objects.  The following bindings are exported by the library '(vicare
system $codes)'.

 -- Primitive Operation: $closure-code CLOSURE
     Return the code object wrapped by the CLOSURE.

 -- Primitive Operation: $cpref CLOSURE IDX
     Evaluate to the contents of the word at index IDX (a non-negative
     fixnum) in the array of free variables in the CLOSURE memory block.

     To know at run time how many free variables are associated to
     CLOSURE we have to inspect the associated code object.

Annotating closure objects
..........................

Annotated procedures exists for debugging purposes, they allow the
association of an arbitrary annotation object to a function.

     (import (rnrs)
       (vicare system $codes))

     (define (the-proc)
       123)

     (define the-annotated
       ($make-annotated-procedure 456 the-proc))

     (the-annotated)                         => 123
     ($annotated-procedure-annotation)       => 456

 -- Function: $make-annotated-procedure ANNOTATION CLO
     Build and return a new closure object wrapping the closure object
     CLO and just adding an ANNOTATION object to it.  When such
     annotated closure is applied: it applies CLO to the arguments.

     ANNOTATION can be any Scheme object.

 -- Function: $annotated-procedure-annotation CLO
     Given a closure object CLO being an annotated procedure created by
     '$make-annotated-procedure': return the annotation object.


File: vicare-scheme.info,  Node: syslib compar,  Prev: syslib closures,  Up: syslib

12.26 Comparison procedures
===========================

The library '(vicare system comparison-procedures)' defines comparison
procedures or the core object-types.  When applied to two values A and B
of the same type, a comparison procedure returns a fixnum:

'-1'
     If A is less than B.

'0'
     If A is equal to B.

'+1'
     If A is greater than B.

   The following syntactic binding are exported by the library '(vicare
system comparison-procedures)'.

 -- Function: make-comparison-procedure TYPE-PRED EQUAL-TO LESS-THAN
     Build and return a comparison procedure using the equality
     predicate EQUAL-TO and the "less than" predicate LESS-THAN.  The
     arguments of the comparison procedures are validated using the type
     predicate TYPE-PRED.

          (define compar-fx
            (make-comparison-procedure fixnum? fx=? fx<?))

          (compar-fx -1 +1)       => -1
          (compar-fx +1 +1)       =>  0
          (compar-fx +1 -1)       => +1

* Menu:

* syslib compar numerics::      Numeric comparison procedures.
* syslib compar textual::       Textual comparison procedures.
* syslib compar misc::          Miscellaneous comparison procedures.


File: vicare-scheme.info,  Node: syslib compar numerics,  Next: syslib compar textual,  Up: syslib compar

12.26.1 Numeric comparison procedures
-------------------------------------

The following syntactic binding are exported by the library '(vicare
system comparison-procedures)'.

 -- Function: compar-fixnum A B
     Comparison procedure for fixnums.

 -- Function: compar-bignum A B
     Comparison procedure for bignums.

 -- Function: compar-exact-integer A B
     Comparison procedure for exact integers (fixnums and bignums).

 -- Function: compar-ratnum A B
     Comparison procedure for ratnums.

 -- Function: compar-exact-real A B
     Comparison procedure for exact reals (fixnums, bignum, ratnums).

 -- Function: compar-flonum A B
     Comparison procedure for flonums.

 -- Function: compar-real A B
     Comparison procedure for reals (fixnums, bignums, ratnums,
     flonums).


File: vicare-scheme.info,  Node: syslib compar textual,  Next: syslib compar misc,  Prev: syslib compar numerics,  Up: syslib compar

12.26.2 Textual comparison procedures
-------------------------------------

The following syntactic binding are exported by the library '(vicare
system comparison-procedures)'.

 -- Function: compar-char A B
     Comparison procedure for characters.

 -- Function: compar-string A B
     Comparison procedure for strings.

 -- Function: compar-string-ci A B
     Comparison procedure for strings, using case-insensitive functions.

 -- Function: compar-symbol A B
     Comparison procedure for symbols.


File: vicare-scheme.info,  Node: syslib compar misc,  Prev: syslib compar textual,  Up: syslib compar

12.26.3 Miscellaneous comparison procedures
-------------------------------------------

The following syntactic binding are exported by the library '(vicare
system comparison-procedures)'.

 -- Function: compar-boolean A B
     Comparison procedure for booleans.  '#t' is considered greater than
     '#f'.

 -- Function: compar-true A B
 -- Function: compar-false A B
     Comparison procedure for booleans true and false.  The arguments
     must be, respectively, both '#t' or both '#f'; when the arguments
     are correct, the return value is always the fixnum zero.

 -- Function: compar-transcoder A B
     Comparison procedure for transcoders.  Comparison is performed on
     the internal representation as exact integers.

 -- Function: compar-pointer A B
     Comparison procedure for pointers.


File: vicare-scheme.info,  Node: objects,  Next: debug int,  Prev: syslib,  Up: Top

13 Built in Scheme objects
**************************

Built in Scheme objects are mostly implemented in the C language portion
of the source code, but many core operations are also reimplemented at
the Scheme level.  The overall definitions are in the C language file
'vicare.h' (for the public API) the C language file 'internals.h' (for
the private API) and the definition of many values is duplicated in the
Scheme language compiler 'ikarus.compiler.sls'.

* Menu:

* objects types::               Some basic type definitions.
* objects refs::                Builtin objects and tags.
* objects memory::              Memory allocation and collection.
* objects booleans::            Boolean objects.
* objects fixnums::             Fixnum objects.
* objects pairs::               Pair objects and lists.
* objects bytevectors::         Bytevector objects.
* objects vectors::             Vector objects.
* objects structs::             Struct objects.
* objects chars::               Character objects.
* objects strings::             String objects.
* objects symbols::             Symbol objects.
* objects bignums::             Bignum objects.
* objects integers::            Exact integer objects.
* objects ratnums::             Ratnum objects.
* objects flonums::             Flonum objects.
* objects compnums::            Compnum objects.
* objects cflonums::            Cflonum objects.
* objects ports::               Port objects.
* objects transcoders::         Transcoder objects.
* objects pointers::            Pointer objects.
* objects tcbuckets::           Components for hashtables.
* objects codes::               Code objects.
* objects closures::            Closure objects.
* objects continuations::       Continuation objects.
* objects misc::                Miscellaneous functions and
                                preprocessor macros.
* objects callbacks::           Notes on calling Scheme code from C.


File: vicare-scheme.info,  Node: objects types,  Next: objects refs,  Up: objects

13.1 Some basic type definitions
================================

 -- Typedef: iksword_t
     The type of signed integers matching a machine word size.  On
     32-bit platforms it is an alias for 'int32_t'.  On 64-bit platforms
     it is an alias for 'int64_t'.

 -- Typedef: ikuword_t
     The type of unsigned integers matching a machine word size.  On
     32-bit platforms it is an alias for 'uint32_t'.  On 64-bit
     platforms it is an alias for 'uint64_t'.

 -- Typedef: ik_int
     An alias for 'signed int'.

 -- Typedef: ik_long
     An alias for 'signed long'.

 -- Typedef: ik_llong
     An alias for 'signed long long'.

 -- Typedef: ik_uint
     An alias for 'unsigned int'.

 -- Typedef: ik_ulong
     An alias for 'unsigned long'.

 -- Typedef: ik_ullong
     An alias for 'unsigned long long'.


File: vicare-scheme.info,  Node: objects refs,  Next: objects memory,  Prev: objects types,  Up: objects

13.2 Built in object references
===============================

Values of type 'ikptr_t' at the C language level are the ones we move
around as arguments and return values at the Scheme level; they
represent machine words.  'ikptr_t' values have two major
interpretations:

*Immediate values*
     Objects that fit in a single machine word: special constants (like
     '#t' and '#f'), fixnums, characters and input/output port
     transcoders.

*Reference values*
     Objects allocated on the heap and subject to garbage collection;
     they are represented by tagged pointers: symbols, pairs, vectors,
     bytevectors, structures, ports, bignums, ratnums, flonums,
     compnums, cflonums, strings, closures, continuations, code objects,
     pointers.

immediate 'ikptr_t' values have two minor interpretations:

*Immediate special constants*
     These are '#t', '#f', nil, void, unbound, BWP.

*Immediate variable values*
     These are fixnums, characters and transcoders.

reference 'ikptr_t' values have two minor interpretations:

*Vector tagged references*
     Memory pointer values whose 3 least significant bits are set to the
     vector tag.  They reference multiword objects allocated on the
     heap: vectors, bignums, structures, flonums, ratnums, compnums,
     cflonums, continuations, code, ports, symbols, pointers.

*Specially tagged references*
     Pointer values whose 3 least significant bits are set to a
     type-specific tag.  They reference multiword objects allocated on
     the heap: pairs, bytevectors, closures, strings.

 -- Object Reference: ikptr_t
     An immediate built in object or a reference to a built in object;
     it is defined as follows:

        * On platforms having pointers 'void *' of size 32-bit: it is
          defined as alias for 'uint32_t'.

        * On platforms having pointers 'void *' of size 64-bit: it is
          defined as alias for 'uint64_t'.

        * On other platforms: it is defined as alias for 'unsigned long
          int'.  This should never happen.

 -- Preprocessor Macro: int IK_TAGOF (ikptr_t REF)
     Return an integer representing the 3 least significant bits of an
     'ikptr_t' value.

 -- Preprocessor Macro: ikptr_t IK_REF (ikptr_t VALUE_REF, ikuword_t
          BYTE_OFFSET)
     Getter and setter for machine words.  Interpret VALUE_REF as a
     pointer to an array of 'ikptr_t' values and locate the value at the
     zero-based BYTE_OFFSET.  A use of this macro can appear both as
     operand and as left-side of an assignment.

          ikptr_t         P, Q;

          Q = IK_REF(P, 2*wordsize); /* retrieve the 3rd word */
          IK_REF(P, 0) = 123L;       /* store a value in the 1st word */

     Both VALUE_REF and BYTE_OFFSET are first cast to 'long' values,
     then added and the sum is cast to 'ikptr_t *'.

     There are two categories of values for BYTE_OFFSET: offsets and
     displacements; both are usually precomputed at compile time and are
     predefined for the built in Scheme values.

     "Displacements"
          They are plain numbers of bytes to be added to an *untagged*
          pointer to obtain the memory address of a machine word.

     "Offsets"
          They are number of bytes from which a Scheme value's tag is
          subtracted: adding an offset to a *tagged* pointer removes the
          tag and computes the memory address of a machine word, in a
          single step.

     Given an *untagged* pointer to a vector, the fixnum representing
     the length of the vector can be obtained with:

          ikptr_t   p_vector = ...;
          ikptr_t   s_length = IK_REF(p_vector, disp_vector_length);

     predefined displacements have names prefixed with 'disp_'; given a
     *tagged* pointer to a vector, the fixnum representing the length of
     the vector can be obtained with:

          ikptr_t   s_vector = ...;
          ikptr_t   s_length = IK_REF(s_vector, off_vector_length);

     predefined offsets have names prefixed with 'off_'.  An offset can
     be computed from a displacement simply by subtracting the tag:

          off_vector_length = disp_vector_length - vector_tag

     this because we can build a tagged pointer from an untagged and
     aligned one with:

          s_vector = p_vector | vector_tag = p_vector + vector_tag

     and vice versa we can compute an untagged pointer from a tagged one
     with:

          p_vector = s_vector - vector_tag

     and so:

          s_vector + off_vector_length = p_vector + disp_vector_length

 -- Preprocessor Macro: ikptr_t * IK_PTR (ikptr_t VALUE_REF, ikuword_t
          BYTE_OFFSET)
     Like 'IK_REF()', but rather than returning the machine word at
     offset BYTE_OFFSET from VALUE_REF, return a pointer to it.  This is
     especially useful to build the second argument in a call to
     'ik_signal_dirt_in_page_of_pointer()'.

Immediate values
................

All the immediate values but fixnums have the 3 least significant bits
set to 1; to distinguish between immediate values and references we can
do:

     ikptr_t   X;

     if (IK_IS_FIXNUM(X) || (immediate_tag == IK_TAGOF(X)))
       it_is_immediate();
     else
       it_is_not();

where:

     immediate_tag = 7 = #b111

 -- Macro: IK_FALSE_OBJECT 0x2F
 -- Macro: IK_FALSE
 -- Macro: IK_TRUE_OBJECT 0x3F
 -- Macro: IK_TRUE
 -- Macro: IK_NULL_OBJECT 0x4F
 -- Macro: IK_NULL
 -- Macro: IK_EOF_OBJECT 0x5F
 -- Macro: IK_EOF
 -- Macro: IK_VOID_OBJECT 0x7F
 -- Macro: IK_VOID
     Special machine words of type 'ikptr_t' representing, respectively:
     '#f'; '#t'; nil, the empty list; EOF, the end of file; '#!void',
     the return value of functions returning no value.

 -- Macro: IK_UNBOUND_OBJECT 0x6F
 -- Macro: IK_UNBOUND
     Special machine word value stored in the 'value' and 'proc' fields
     of Scheme symbol memory blocks to signal that these fields are
     unset.

 -- Macro: IK_BWP_OBJECT 0x8F
 -- Macro: IK_BWP
     Special machine word value stored in locations that used to hold
     weak references to values which have been already garbage
     collected.  'BWP' stands for "broken weak pointer".

 -- Macro: IK_FORWARD_PTR ((ikptr_t)-1)
     When a Scheme object's memory block is moved by the garbage
     collector: the first word of the old memory block is overwritten
     with a special value, the "forward pointer", which is the symbol
     'IK_FORWARD_PTR'.

     Notice that when the garbage collector scans, word by word, memory
     that should contain the data area of a Scheme object: it interprets
     every machine word with all the bits set to '1' as
     'IK_FORWARD_PTR'.

     Newly allocated memory is initialised by Vicare to a sequence of
     'IK_FORWARD_PTR' words, which, most likely, will trigger an
     assertion violation if the garbage collector scans a machine word
     we have not explicitly initialised to something valid.  Whenever we
     reserve a portion of memory page, with aligned size, for a Scheme
     object we must initialise all its words to something valid.

     When we convert a requested size to an aligned size with
     'IK_ALIGN()': either zero or one machine word is allocated beyond
     the requested size.  When such additional machine word is
     allocated: we have to initialise it to something valid.  Usually
     the safe value to which we should initialise memory is the fixnum
     zero: a machine word with all the bits set to '0'.

   The variable values that fit in a single machine word are fixnums,
characters and port transcoders.  The last byte of these machine words
is tagged as follows:

        object      |  tag bits  | tag hex | mask bits
     ---------------+------------+---------+------------
     fixnums 32-bit | #b??????00 |   --    | #b00000011
     fixnums 64-bit | #b?????000 |   --    | #b00000111
     characters     | #b00001111 |  #x0F   | #b11111111
     transcoders    | #b01111111 |  #x7F   | #b11111111

to identify a fixnum we can do:

     ikptr_t   X;

     if (fx_tag == (X & fx_mask))
       it_is_a_fixnum();
     else
       it_is_not();

or just use the macro 'IK_IS_FIXNUM()'; similarly for for the other
immediate variable values.

   Notice that a 'NULL' pointer stored in a 'ikptr_t' with zero bits as
tag represents the fixnum zero; also, the zero tag bits for fixnums are
in such a number that: a tagged 'ikptr_t' fixnum can be interpreted as
the number of bytes needed to hold a number of machine words equal to
the number represented by the fixnum itself, that is the following holds
true:

     long    number_of_words = ...;

     number_of_words * wordsize == number_of_words << fx_shift;

where 'fx_shift' is the number of bits in the fixnum's tag.

Values allocated on the heap
............................

The values that do not fit into a single machine word are composed of a
reference machine word and an array of machine words on the heap; they
are: symbols, pairs, vectors, bytevectors, structures, ports, bignums,
ratnums, flonums, compnums, cflonums, strings, closures, continuations,
codes, pointers.

   The machine words used as reference have the 3 least significant bits
used as tag and the remaining most significant bits used to store a
pointer in memory; on 32-bit platforms the layout of such machine words
is:

      PPPPPPPP PPPPPPPP PPPPPPPP PPPPPTTT   P = bit of pointer
     |--------|--------|--------|--------|  T = bit of tag
       byte 3   byte 2   byte 1   byte 0

the following tags are used:

       object    | tag bits | tag hex | mask bits
     ------------+----------+---------+------------
     pairs       |   #b001  |   #x1   | #b00000111
     bytevectors |   #b010  |   #x2   | #b00000111
     closure     |   #b011  |   #x3   | #b00000111
     vectors     |   #b101  |   #x5   | #b00000111
     strings     |   #b110  |   #x6   | #b00000111

notice how *none* of the tags for reference words is '#b111', which is
reserved for immediate values; also notice how '#b100' must *not* be
used as tag, because on 32-bit platforms it would match the fixnums with
the least significant bit set to one.

   The vector tag is used to tag machine word references to multiple
object types: vectors, bignums, structures, flonums, ratnums, compnums,
cflonums, continuations, code, ports, symbols, pointers, system
continuations.  The first word in the memory block of these types has
the least significant bits set to a secondary tag.

   All the possible values for 3-bit tags in reference values are
already allocated; new object types can be added only by defining a new
secondary tag with references tagged as vector.

   While the API defines predicates to recognise values, to identify a
type-specific reference we can do:

     ikptr_t   X;

     if (pair_tag == (X & pair_mask))
       it_is_a_pair();
     else
       it_is_not();

similarly for the other types.  The vector tag acts as "primary tag"; a
"secondary tag" is stored in the least significant bits of the
referenced vector of words on the heap; to recognise such values we can
do:

     ikptr_t  X;

     if ((vector_tag    == (X & vector_mask)) &&
         (secondary_tag == (secondary_mask & IK_REF(X, -vector_tag))))
       it_is();
     else
       it_is_not();

where 'secondary_tag' and 'secondary_mask' are type-specific.  The
secondary tags and the associated masks are:

        object           |  tag bits   | tag hex | tag mask
                         |    76543210 |         |    76543210
     --------------------+-------------+---------+-------------
     vector              |  #b??????00 | fixnum  |    --
     bignum              |  #b????s011 |   #x03  | #b00000111
     structure           |  #b?????101 |   #x05  | #b00000111
     flonum              |  #b00010111 |   #x17  |    --
     ratnum              |  #b00100111 |   #x27  |    --
     compnum             |  #b00110111 |   #x37  |    --
     cflonum             |  #b01000111 |   #x47  |    --
     continuation        |  #b00011111 |   #x1F  |    --
     code                |  #b00101111 |   #x2F  |    --
     port                |  #b??111111 |   #x3F  | #b00111111
     symbol              |  #b01011111 |   #x5F  |    --
     pointer             | #b100000111 |  #x107  |    --
     system continuation | #b100011111 |  #x11F  |    --

notice how the port secondary tag has all the 6 least significant bits
set to 1: no other tag must have all such bits set to 1.  Secondary tags
for new types can be allocated by selecting the least significant byte
to '#x0F' and reserving a specific bit pattern in the most significant
bytes.

   The only tags having an associated mask are the ones of objects
storing additional informations in the first word of the heap vector:

*Vectors*
     The first word of a vector is a fixnum representing the number of
     elements.

*Bignums*
     The first word uses the 3 least significant bits as tag, the 4th
     bit representing the sign (0 for positive, 1 for negative) and the
     remaining bits representing the number of words in the bignum data
     area.

*Structures*
     The first word is tagged as vector, because the first word of a
     structure is itself a reference to a structure: the type
     descriptor.

*Ports*
     The most significant bits of the first word are used for port
     attributes.


File: vicare-scheme.info,  Node: objects memory,  Next: objects booleans,  Prev: objects refs,  Up: objects

13.3 Memory allocation and collection
=====================================

* Menu:

* objects memory pages::        System memory pages and Vicare
                                memory pages.
* objects memory segments::     Logic memory segments.
* objects memory pcb::          Interesting PCB fields.
* objects memory alloc::        Basic memory allocation functions.
* objects memory usage::        Writing correct C language code.


File: vicare-scheme.info,  Node: objects memory pages,  Next: objects memory segments,  Up: objects memory

13.3.1 System memory pages and Vicare memory pages
--------------------------------------------------

In this section we discuss some private C preprocessor symbols related
to memory allocation and garbage collection concepts.

   The preprocessor constant 'IK_MMAP_ALLOCATION_GRANULARITY' is
determined by the GNU Autotools's 'configure' script and defined in the
automatically generated header file 'config.h'.  The constants
'IK_PAGESIZE' and 'IK_PAGESHIFT' are hard-coded.

   The constant 'IK_MMAP_ALLOCATION_GRANULARITY' represents the memory
allocation granularity used by 'mmap()': no matter the number of bytes
we request to 'mmap()', it will always allocate the smallest multiple of
the granularity that can contain the requested bytes:

     |----------------------------| requested_size
     |-----------|-----------|-----------| allocated_size
      granularity granularity granularity

   On some platforms the allocation granularity equals the system page
size (example GNU+Linux), on other platforms it does not (example
Cygwin).  We assume the allocation granularity can be obtained on any
platform with:

     #include <unistd.h>
     long granularity = sysconf(_SC_PAGESIZE);

which should "officially" return the system page size, but in truth it
does not (see Cygwin's documentation).

   To mind its own business, Vicare defines a "page size" as the
preprocessor symbol 'IK_PAGESIZE', the number of bytes in Vicare's page
size is:

     4096 = 4 * 1024 = 4 * 2^10 = 2^12 = #x1000 = #b1000000000000

notice how many bits are set to zero in the binary representation of
4096:

     (number->string 4096 2) => #b1000000000000
     ;;                           2109876543210

the constant 4096 is used often in the code, so the preprocessor symbol
'IK_CHUNK_SIZE' is also defined to it.

   Vicare's page size is *not* defined to be equal to the system page
size, but:

   * Most likely the system page size and Vicare's page size are equal.

   * We assume that the system page size is equal to, or an exact
     multiple of, Vicare's page size.

   * We assume that 'mmap()' returns pointers such that: the pointer
     references the first byte of a system page, and so also the first
     byte of a Vicare page; the numeric address of the pointer is an
     exact multiple of 4096 (the 12 least significant bits are zero).

   It is natural to assign a zero-based index to each Vicare page:

        page     page     page     page     page     page
     |--------|--------|--------|--------|--------|--------|
      ^        ^        ^        ^        ^        ^
     #x0000   #x1000   #x2000   #x3000   #x4000   #x5000
     index 0  index 1  index 2  index 3  index 4  index 5

   The preprocessor symbol 'IK_PAGESHIFT' is the number of bits to
right-shift a tagged or untagged pointer to obtain the index of the page
it is in; it is the number for which:

     IK_PAGESIZE >> IK_PAGESHIFT = 1
     2^IK_PAGESHIFT = IK_PAGESIZE

if 'IK_PAGESIZE' is 4096, the value of 'IK_PAGESHIFT' is 12; so for the
example sizes 4000, 8000 and 10000 we have:

     0 * 4096 <=  4000 < 1 * 4096        4000 >> 12 = 0
     1 * 4096 <=  8000 < 2 * 4096        8000 >> 12 = 1
     2 * 4096 <= 10000 < 3 * 4096       10000 >> 12 = 2

all the tagged pointers hold the tag in the 3 least significant bits, so
right-shifting by 'IK_PAGESHIFT' removes the tag: right-shifting by
'IK_PAGESHIFT' works fine on both tagged and untagged pointers.

 -- C Preprocessor Macro: ikuword_t IK_PAGE_INDEX (ikptr_t X)
     Given the tagged or untagged pointer X: evaluate to the index of
     the memory page it is in; notice that the tag bits of a tagged
     pointer are not influent.

 -- C Preprocessor Macro: ikuword_t IK_PAGE_INDEX_RANGE (ikuword_t SIZE)
     Given a number of bytes SIZE: evaluate to the difference between
     two page indexes representing a region big enough to hold SIZE
     bytes.

 -- C Preprocessor Macro: ikptr_t IK_PAGE_POINTER_FROM_INDEX (ikuword_t
          IDX)
     Given a Vicare page index IDX: return an untagged pointer to the
     first word of the page.

 -- C Preprocessor Macro: ikuword_t IK_MMAP_ALLOCATION_SIZE (ikuword_t
          SIZE)
     Given a memory SIZE in bytes: compute the smallest number of bytes
     'mmap()' will allocate to hold it.

 -- C Preprocessor Macro: ikuword_t IK_MINIMUM_PAGES_NUMBER_FOR_SIZE
          (ikuword_t SIZE)
     Given a memory SIZE in bytes: compute the smallest number of pages
     of size 'IK_PAGESIZE' needed to hold it.

 -- C Preprocessor Macro: ikuword_t IK_MMAP_ALLOCATION_SIZE_FOR_PAGES
          (ikuword_t NPAGES)
     Given a number of Vicare pages: return the number of bytes 'mmap()'
     allocates to hold them.

 -- C Preprocessor Macro: ikuword_t IK_ALIGN_TO_NEXT_PAGE (ikuword_t X)
     Given a pointer or tagged pointer X: return an untagged pointer
     referencing the first byte in the page right after the one X
     belongs to.

             page     page     page
          |--------|--------|--------|
                         ^   ^
                         X   |
                            returned_value

 -- C Preprocessor Macro: ikuword_t IK_ALIGN_TO_PREV_PAGE (ikuword_t X)
     Given a pointer or tagged pointer X: return an untagged pointer
     referencing the first byte in the page X belongs to.

             page     page     page
          |--------|--------|--------|
                    ^    ^
                    |    X
           returned_value


File: vicare-scheme.info,  Node: objects memory segments,  Next: objects memory pcb,  Prev: objects memory pages,  Up: objects memory

13.3.2 Logic memory segments
----------------------------

Some memory for use by the Scheme program is allocated through 'mmap()'
in blocks called "allocated segments".  A segment's size is a fixed
constant which must be defined as an exact multiple of the memory
allocation granularity used by 'mmap()'; we define the preprocessor
macro 'IK_SEGMENT_SIZE' to be such constant.

   On Unix platforms we expect 'mmap()''s allocation granularity to be
4096; on Windows platforms, under Cygwin, we expect 'mmap()''s
allocation granularity to be '2^16 = 65536 = 16 * IK_PAGESIZE'.  So the
allocation granularity is not always equal to the system page size, and
not always equal to Vicare's page size.

   Remembering that we have defined the preprocessor constant
'IK_CHUNK_SIZE' to be 4096, and assuming:

     1 mebibyte = 1 MiB = 2^20 bytes = 1024 * 1024 bytes
                = 1048576 bytes

we want the segment size to be 4 MiB:

     4 MiB = 4 * 1024 * 1024 = 64 * 2^16 = 64 * 65536
           = 4096 * 1024 = 4096 * (4096 / 4) = IK_CHUNK_SIZE * 1024
           = 2^22 = 4194304 bytes
           = #x400000
           = #b10000000000000000000000

notice how many zero bits there are in the binary representation of 4
MiB:

     (number->string (* 4096 1024) 2)
     => #b10000000000000000000000
     ;;   21098765432109876543210

   Vicare distinguishes between "allocated segments" and "logic
segments":

   * We assume 'mmap()' returns pointers such that: the pointer
     references the first byte of a platform's system page; the numeric
     address of the pointer is an exact multiple of 4096 (the 12 least
     significant bits are zero).

   * We request 'mmap()' to allocate memory in sizes that are multiples
     of the segment size; this memory is composed of "allocated
     segments".

   * We define a "logic segment" as a region of memory whose size is
     equal to the segment size and whose starting address is an exact
     multiple of the segment size.  The segment size is 4 MiB so: a
     memory address referencing the first byte of a logic segment has
     the 22 least significant bits set to zero; for example: the memory
     starting at address 0 is part of the first logic segment.

so, typically, allocated segments of size 'IK_SEGMENT_SIZE' are
displaced from logic segments:

            alloc segment  alloc segment  alloc segment
     -----|--------------|--------------|--------------|----------

       logic segment  logic segment  logic segment  logic segment
     |--------------|--------------|--------------|--------------|

      page page page page page page page page page page page page
     |----|----|----|----|----|----|----|----|----|----|----|----|

logic segments are absolute portions of the memory seen by a running
system process.  It is natural to assign a zero-based index to each
logic segment:

       logic segment  logic segment  logic segment  logic segment
     |--------------|--------------|--------------|--------------|
      ^              ^              ^              ^
     #x000000       #x400000       #x800000       #xC00000
     index 0        index 1        index 2        index 3

   'IK_SEGMENT_SHIFT' is the number of bits to right-shift a pointer or
tagged pointer to obtain the index of the logic segment containing the
pointer itself; it is the number for which:

     IK_SEGMENT_SIZE >> IK_SEGMENT_SHIFT = 1
     2^IK_SEGMENT_SHIFT = IK_SEGMENT_SIZE

   When we want to determine the page index and logic segement index of
the pointer X:

       logic segment  logic segment  logic segment
     |--------------|--------------|--------------|
      page page page page page page page page page
     |----|----|----|----|----|----|----|----|----|
                            ^
                            X
     |----|----|----|----|----|----|----|----|----| page indexes
       P   P+1  P+2  P+3  P+4  P+5  P+6  P+7  P+7

     |--------------|--------------|--------------| segment indexes
            S             S+1            S+2

we do:

     X >> IK_PAGESHIFT     == IK_PAGE_INDEX(X)    == P+4
     X >> IK_SEGMENT_SHIFT == IK_SEGMENT_INDEX(X) == S+1

 -- C Preprocessor Macro: ikuword_t IK_SEGMENT_INDEX (ikuword_t X)
     Given a tagged or untagged pointer X: return the index of the logic
     segment it belongs to.


File: vicare-scheme.info,  Node: objects memory pcb,  Next: objects memory alloc,  Prev: objects memory segments,  Up: objects memory

13.3.3 Interesting PCB fields
-----------------------------

In this section we discuss some private fields of the C data structure
'ikpcb_t', the "Process Control Block", related to memory allocation and
garbage collection.

'ikptr_t memory_base'
'ikptr_t memory_end'
     Untagged pointers updated (if needed) after every memory mapped
     allocation to be lower and greater than all the memory used by
     Scheme programs.

                   Scheme used memory
               |.......................|
          |--------------------------------------| system memory
               ^                        ^
            memory_base             memory_end

     They are used for garbage collection purposes: every Vicare page
     between this range of pointers is described by a slot in the
     segments vector and the dirty vector.

     The pointers 'memory_base' and 'memory_end' always reference the
     first machine word in a logic memory segment (*note objects memory
     segments::).

'uint32_t * segment_vector_base'
'uint32_t * segment_vector'
     The segments vector contains a slot for every Vicare page in the
     region of memory delimited by the fields 'memory_base' and
     'memory_end'; it is used to register the destination use of every
     page (heap, stack, unused, etc.), along with the garbage collection
     generation the page belongs to.

     'segment_vector_base' references the first allocated slot; access
     to the vector with zero-based indexes is performed through
     'segment_vector'.

                               segment vector
          |.................|--------------------|.......| system memory
               ^             ^
            segment_vector  segment_vector_base

     The first slot referenced by 'segment_vector_base' has index
     different from zero; its index is computed with 'IK_PAGE_INDEX()':

          pcb->segment_vector[IK_PAGE_INDEX(memory_pointer)]

     to loop over all the slots we can do:

          ikuword_t  lo_idx = IK_PAGE_INDEX(pcb->memory_base);
          ikuword_t  hi_idx = IK_PAGE_INDEX(pcb->memory_end);
          ikuword_t  page_idx;

          for (page_idx = lo_idx; page_idx < hi_idx; ++page_idx) {
            pcb->segment_vector[page_idx];
          }

     Notice that the segments vector is *not* itself registered in the
     segments vector and dirty vector: if the segments vector falls
     inside the region delimited by 'memory_base' and 'memory_end', it
     is marked as unused and pure.

'uint32_t * dirty_vector_base'
'ikptr_t dirty_vector'
     The dirty vector contains a slot for every Vicare page in the
     region of memory delimited by the fields 'memory_base' and
     'memory_end'; it is used to keep track of pages that were mutated
     at runtime; it allows the garbage collector to do the right thing
     when a Scheme object in an old generation is mutated to reference a
     Scheme object in a new generation.

     When a Scheme object in a memory page is mutated at run-time: such
     page is said to be "dirty"; otherwise it is "pure".

     'dirty_vector_base' references the first allocated slot; access to
     the vector with zero-based indexes is performed through the field
     'dirty_vector' (which is also accessible from Scheme code).

                                 dirty vector
          |.................|--------------------|.......| system memory
               ^             ^
            dirty_vector    dirty_vector_base

     The first slot referenced by 'dirty_vector_base' has index
     different from zero; its index is computed with 'IK_PAGE_INDEX()':

          ((uint32_t *)(pcb->dirty_vector))[IK_PAGE_INDEX(memory_pointer)]

     to loop over all the slots we can do:

          ikuword_t  lo_idx = IK_PAGE_INDEX(pcb->memory_base);
          ikuword_t  hi_idx = IK_PAGE_INDEX(pcb->memory_end);
          ikuword_t  page_idx;

          for (page_idx = lo_idx; page_idx < hi_idx; ++page_idx) {
            ((uint32_t *)(pcb->dirty_vector))[page_idx];
          }

     Notice that the dirty vector is *not* itself registered in the
     segments vector and dirty vector: if the dirty vector falls inside
     the region delimited by 'memory_base' and 'memory_end', the pages
     it uses are marked as unused and pure.

   Scheme objects created by a Scheme program are allocated on the heap.
We can think of the Scheme heap as the union of the "nursery" and a set
of "generational pages".

   The nursery is a set of memory blocks in which new Scheme objects are
allocated; it is the generation '0'.  The nursery starts with a single
"hot" memory block in which new Scheme objects are allocated; whenever
the hot block is full:

   * If an "unsafe" allocation is requested and there is free room in
     the nursery's hot block: the Scheme object is allocated in the
     nursery's hot block.

     This is the case of: Scheme object allocation from C language code,
     through the C function 'ik_unsafe_alloc()'.

   * If an "unsafe" allocation is requested and there is no free room in
     the nursery's hot block:

       1. The current hot block is stored away in a linked list of
          "full" nursery segments.

       2. A new nursery segment is allocated and registered as empty hot
          block.

       3. The Scheme object is allocated in the nursery's hot block.

     This is the case of: Scheme object allocation from C language code,
     through the C function 'ik_unsafe_alloc()'.

   * If a "safe" allocation is requested and there is free room in the
     nursery's hot block: the Scheme object is allocated in the
     nursery's hot block.

     This is the case of: common Scheme object allocation from Scheme
     code; common Scheme object allocation from C language code, through
     the C function 'ik_safe_alloc()'.

   * If a "safe" allocation is requested and there is no free room in
     the nursery's hot block:

       1. A garbage collection is performed; all the objects are moved
          from the nursery (including all the old full segments) into
          the generational pages of generation 1.

       2. The current nursery's hot block is reused as empty hot block.

       3. The old full segments are released or cached for future page
          allocations.

       4. The Scheme object is allocated in the nursery's hot block.

     This is the case of: common Scheme object allocation from Scheme
     code; common Scheme object allocation from C language code, through
     the C function 'ik_safe_alloc()'.

   The generational pages are a set of Vicare pages, described by the
segments vector and dirty vector, in which objects are moved after they
survive a garbage collection; every generational page is tagged in the
segments vector with the index of the generation it belongs to.

   While nursery segments hold Scheme objects of any type, each
generational page holds objects of a single "category": pairs; symbols;
vectors, structs, records, ratnums, compnums, cflonums; code objects;
bytevectors, strings, flonums, bignums.

'ikptr_t heap_nursery_hot_block_base'
'ikuword_t heap_nursery_hot_block_size'
     Pointer and size in bytes of the current nursery's hot memory
     block; new Scheme objects are allocated here.  About the size of
     the hot block:

        * The hot block is initialised to a memory mapped block of size
          'IK_HEAPSIZE' bytes; this size is customisable (*note iklib
          runtime::).

        * When the current hot block is full and a call to
          'ik_unsafe_alloc()' is performed:

             - If the requested size, aligned, is less than
               'IK_HEAPSIZE' bytes: the hot block is set to a memory
               mapped block of size 'IK_HEAPSIZE' bytes.

             - If the requested size, aligned, is greater than
               'IK_HEAPSIZE' bytes: the hot block is set to a memory
               mapped block of size wide enough to hold the requested,
               aligned, size (with a couple of 'IK_PAGESIZE' more,
               rounded to the next page size).

'ikptr_t allocation_pointer'
     Pointer to the first word of available data in the nursery's hot
     memory block; the next Scheme object to be allocated will start
     there.

'ikptr_t allocation_redline'
     Pointer to a word towards the end of the heap hot memory block;
     when the allocation of a Scheme object crosses this pointer, the
     hot block is considered full.

'ikmemblock_t full_heap_nursery_segments'
     Pointer to the first node in a linked list of memory blocks that
     once were nursery's hot memory, and are now fully used; initialised
     to 'NULL' when building the PCB.


File: vicare-scheme.info,  Node: objects memory alloc,  Next: objects memory usage,  Prev: objects memory pcb,  Up: objects memory

13.3.4 Basic memory allocation functions
----------------------------------------

A memory allocation operation that is allowed to trigger a garbage
collection is performed as follows:

     ikpcb_t *  pcb             = ...;
     ikuword_t  number_of_bytes = ...;
     ikuword_t  aligned_size    = IK_ALIGN(number_of_bytes);
     ikptr_t    P = ik_safe_alloc(pcb, aligned_size);

while a memory allocation operation that is forbidden to trigger a
garbage collection is performed as follows:

     ikpcb_t *  pcb             = ...;
     ikuword_t  number_of_bytes = ...;
     ikuword_t  aligned_size    = IK_ALIGN(number_of_bytes);
     ikptr_t    P = ik_unsafe_alloc(pcb, aligned_size);

where 'P' is an untagged memory pointer and 'pcb' is a pointer to the
"Process Control Block" data structure.

   To add a tag, for example the 'vector_tag', to an untagged memory
pointer we can do:

     ikpcb_t *  pcb             = ...;
     ikuword_t  number_of_bytes = ...;
     ikuword_t  aligned_size    = IK_ALIGN(number_of_bytes);
     ikptr_t    S = ik_safe_alloc(pcb, aligned_size) | vector_tag;

   Objects subject to garbage collection are allocated on the Scheme
heap; a new Scheme object is allocated in the nursery's hot memory
block:

         allocated  allocated      allocated
         block      block          block
     ...|----------|--------------|--------|------...
         ^          ^              ^        ^
         |          |              |        |
       pointer    pointer        pointer   pointer to
                                           next block

every pointer must satisfy alignment constraints with the following
purposes:

  1. To make pointer indirection efficient for the underlying platform.

  2. To have pointer values with the 3 least significant bits set to
     zero, so that such bits can be used to hold an object's type tag.

  3. To allocate a data area for Scheme objects at least 2 machine words
     wide; this is required for garbage collection purposes: the 2 words
     are used by the garbage collector to register informations when a
     live Scheme object is gathered.

for these reasons we must always filter the requested size (number of
bytes) through the 'IK_ALIGN()' macro.

   The PCB always references a "pointer to the next free block" with
alignment constraints satisfied; if we filter the requested number of
bytes through 'IK_ALIGN()', we obtain a number of bytes which, added to
the pointer, gives a correctly aligned pointer:

     ikpcb_t   pcb             = ...;
     ikuword_t requested_size  = ...;
     uint8_t * allocated_block = (uint8_t *)pcb->allocation_pointer;
     ikuword_t aligned_size    = IK_ALIGN(requested_size);
     uint8_t * next_free_block = allocated_block + aligned_size;
     pcb->allocation_pointer   = (ikptr_t)next_free_block;

the scenario is as follows:

            requested size      wasted
       |.......................|..|
               aligned size
     --|--------------------------|--- nursery's hot block
        ^                          ^
        |                          |
     pointer to an              pointer to the
     allocated block            next block

if the aligned size is bigger than the requested size: the small chunk
of memory at the end of the allocated block is wasted.

 -- Function: ikpcb_t * ik_the_pcb (void)
     Return a pointer to the current process control block.  It is
     rarely needed: when calling a C function from Scheme a pointer to
     the PCB is always pushed on the C stack as last argument.

 -- Preprocessor Macro: ikuword_t IK_ALIGN (ikuword_t NUMBER_OF_BYTES)
     Convert NUMBER_OF_BYTES to the number of bytes requested to satisfy
     pointer alignment constraints.  The aligned size is always an exact
     multiple of the underlying platform's word size (32-bit or 64-bit);
     precisely: it is the smallest multiple of the wordsize which is
     greater than NUMBER_OF_BYTES and makes the pointer have the 3 least
     significant bits set to zero.

     This means that it is impossible to allocate less than 2 machine
     words.

 -- Function: ikptr_t ik_safe_alloc (ikpcb_t * PCB, ikuword_t
          ALIGNED_SIZE)
     Reserve a memory block on the Scheme heap's nursery hot block and
     return a reference to it as an *untagged* pointer.  PCB must
     reference the process control block, ALIGNED_SIZE must be the
     requested number of bytes filtered through 'IK_ALIGN()'.

     If not enough memory is available on the current hot block: a
     garbage collection is triggered; then allocation is tried again: if
     it still fails the process is terminated with exit status
     'EXIT_FAILURE'.

     The reserved memory is *not* initialised to safe values: its
     contents have to be considered invalid.  However, notice that the
     heap's nursery is *not* a garbage collection root; so if we leave
     some machine words uninitialised on the nursery, outside of Scheme
     objects: nothing bad happens, because the garbage collector never
     sees them.

 -- Function: ikptr_t ik_unsafe_alloc (ikpcb_t * PCB, ikuword_t
          ALIGNED_SIZE)
     Reserve a memory block on the Scheme heap's nursery hot block and
     return a reference to it as an *untagged* pointer.  PCB must
     reference the process control block, ALIGNED_SIZE must be the
     requested number of bytes filtered through 'IK_ALIGN()'.

     If not enough memory is available on the current hot block: such
     hot block is stored away in a linked list referenced by the PCB,
     and a new hot block is allocated; if such allocation fails: the
     process is terminated with exit status 'EXIT_FAILURE'.

     The reserved memory is *not* initialised to safe values: its
     contents have to be considered invalid.  However, notice that the
     heap's nursery is *not* a garbage collection root; so if we leave
     some machine words uninitialised on the nursery, outside of Scheme
     objects: nothing bad happens, because the garbage collector never
     sees them.

     We notice explicitly that this function *does not* trigger a
     garbage collection run, so, when using it, it is not needed to
     register C pointers as garbage collection roots.

 -- Preprocessor Macro: IK_ASS (ikptr_t LEFT, ikptr_t RIGHT)
     Perform a C language assignment enforcing the order of evaluation
     of the left-side and right-side expressions:

       1. Evaluate RIGHT.

       2. Evaluate LEFT.

       3. Store the result of RIGHT in the lvalue resulting from
          evaluating LEFT.

     After a use of this macro: if RIGHT is a reference to a
     non-immediate Scheme object, the function
     'ik_signal_dirt_in_page_of_pointer()' must be applied to the lvalue
     resulting from evaluating LEFT.  For example, when allocating a
     pair filled with non-immediate numbers:

          ikptr_t   s_pair = ika_pair_alloc(pcb);

          pcb->root0 = &s_pair;
          {
            IK_ASS(IK_CAR(s_pair), ika_integer_from_int(pcb, 1));
            IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));

            IK_ASS(IK_CDR(s_pair), ika_integer_from_int(pcb, 2));
            IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_pair));
          }
          pcb->root = NULL;

 -- Function: void ik_signal_dirt_in_page_of_pointer (ikpcb_t * PCB,
          ikptr_t POINTER)
     Register in the dirty vector that the memory page containing the
     location referenced by POINTER has been mutated.  This function
     must be called every time we mutate a pair, vector, structure,
     record, ratnum, cflonum, compnum, port, symbol slot by storing in
     it a reference to another non-immediate Scheme object that might be
     in a newer garbage collection generation.

     If we call this function when there is no need for it: nothing bad
     will happen; the garbage collector will just do some useless work,
     slowing down the collection time a bit.

 -- Preprocessor Macro: void IK_SIGNAL_DIRT (ikpcb_t * PCB, ikptr_t
          POINTER)
     Just a wrapper for 'ik_signal_dirt_in_page_of_pointer()'; it has a
     shorter name.


File: vicare-scheme.info,  Node: objects memory usage,  Prev: objects memory alloc,  Up: objects memory

13.3.5 Writing correct C language code
--------------------------------------

The garbage collector considers an object "in use" if at least one
reference to it is reachable from the roots of the garbage collection;
the roots of the garbage collection are:

   * Heap's dirty generational pages not collected in the current
     garbage collection run.

   * The Scheme stack.

   * The next continuation Scheme object.

   * The symbol table collecting interned symbols.

   * The 'root' fields of the PCB structure.

   Notice that the heap's nursery is *not* a garbage collector root; so
if we leave some machine words uninitialised on the nursery, outside of
Scheme objects: nothing bad happens, because the garbage collector never
sees them.  Upon allocation, there is no need to initialise the memory
segment used as nursery.

   If an 'ikptr_t' reference exists only in a CPU register or on the C
language stack, or on the C language heap out of segments allocated for
Scheme: the garbage collector will not see it.  This allows to avoid
scanning the full process' stack for references to values, but imposes
care when writing C language code.

   Whenever we call 'ik_safe_alloc()' or a function relying on it for
memory allocation: a garbage collection may run and Scheme objects may
be moved from their location in memory to another memory generational
page; this makes invalid all the pointers in the CPU registers, on the C
stack and the C heap.  Notice that this includes the arguments to C
functions called from Scheme through the macro 'foreign-call'.

   If an old Scheme object contains a reference to a new Scheme object:
we have to inform the garbage collector about this.  Whenever we
allocate a new Scheme object and store in one of its fields a reference
to a previously allocated Scheme object: we have to register this event
in the dirty vector.

   We must write C code with the following constraints:

   * Before a call to 'ik_safe_alloc()': we must make sure that all the
     Scheme objects we are using in C code are reachable by the garbage
     collector.  This is done by registering an object as garbage
     collector root through the 'root' fields of the PCB.

   * After a call to 'ik_safe_alloc()': we must reobtain all the
     pointers to the internals of the objects we are using.

   To help identification of C functions and macros allocating memory:
the ones calling 'ik_safe_alloc()' are prefixed with 'ika_' and 'IKA_';
the ones calling 'ik_unsafe_alloc()' are prefixed with 'iku_' and
'IKU_'.

   * Example of *correct* code: 's_one' is protected while allocating
     's_two':

          ikpcb_t * pcb = ik_the_pcb();
          ikptr_t   s_one, s_two;

          s_one = ika_bytevector_alloc(pcb, 10);
          pcb->root0 = &s_one;
          {
            s_two = ika_bytevector_alloc(pcb, 10); /* GOOD */
          }
          pcb->root0 = NULL;

     example of *wrong* code: after the second call to the allocation
     function the value in 's_one' may be invalid:

          ikpcb_t * pcb = ik_the_pcb();
          ikptr_t   s_one, s_two;

          s_one = ika_bytevector_alloc(pcb, 10);
          s_two = ika_bytevector_alloc(pcb, 10);
          /* do something with "s_one" and "s_two" */ /* WRONG */

   * Example of *correct* code: 's_one' is protected while allocating
     's_two' and after the second allocation the pointer to the data
     area of 's_one' is retrieved again:

          ikpcb_t * pcb = ik_the_pcb();
          ikptr_t   s_one;
          ikptr_t   s_two;
          char *    one;
          char *    two;

          s_one = ika_bytevector_alloc(pcb, 10);
          one   = IK_BYTEVECTOR_DATA_CHARP(s_one);
          /* do something with "one" */
          pcb->root0 = &s_one;
          {
            s_two = ika_bytevector_alloc(pcb, 10);
          }
          pcb->root0 = NULL;
          one   = IK_BYTEVECTOR_DATA_CHARP(s_one); /* GOOD */
          two   = IK_BYTEVECTOR_DATA_CHARP(s_two);
          /* do something with "one" and "two" */

     example of *wrong* code: after the second call to the allocation
     function the pointer 'one' to the data area of 's_one' may be
     invalid:

          ikpcb_t * pcb = ik_the_pcb();
          ikptr_t   s_one;
          ikptr_t   s_two;
          char *    one;
          char *    two;

          s_one = ika_bytevector_alloc(pcb, 10);
          one   = IK_BYTEVECTOR_DATA_CHARP(s_one);
          /* do something with "one" */
          pcb->root0 = &s_one;
          {
            s_two = ika_bytevector_alloc(pcb, 10);
          }
          pcb->root0 = NULL;
          two   = IK_BYTEVECTOR_DATA_CHARP(s_two);
          /* do something with "one" and "two" */ /* WRONG */

   Notice that, according to the C standard Section 6.5.16 "Assignment
operators": the order of evaluation of the operands is unspecified(1).
In the following code:

     IK_CAR(s_pair) = ika_bytevector_alloc(pcb, 8); /* WRONG */

the left-side expression may be evaluated before the right-side one,
resulting in the value referenced by 's_pair' to be invalid when the
memory assigment actually takes place; so we have to code:

     ikpcb_t * pcb    = ...;
     ikptr_t   s_pair = ...;
     ikptr_t   s_tmp;

     pcb->root0 = &s_pair;
     {
       s_tmp          = ika_bytevector_alloc(pcb, 8); /* GOOD */
       IK_CAR(s_pair) = s_tmp;
       IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));
     }
     pcb->root0 = NULL;

or:

     ikpcb_t * pcb    = ...;
     ikptr_t   s_pair = ...;
     ikptr_t   s_tmp;

     pcb->root0 = &s_pair;
     {
       IK_ASS(IK_CAR(s_pair), ika_bytevector_alloc(pcb, 8)); /* GOOD */
       IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));
     }
     pcb->root0 = NULL;

yes, it is a hard life.

   Let's consider the following snippet, which is *wrong*:

     ikpcb_t * pcb = ik_the_pcb();
     ikptr_t   s_one, s_two;

     s_one = IKA_PAIR_ALLOC(pcb); /* WRONG */
     pcb->root0 = &s_one;
     {
       s_two = IKA_PAIR_ALLOC(pcb);
     }
     pcb->root0 = NULL;

when the second pair is allocated, the first pair has car and cdr still
uninitialised (the macro 'IKA_PAIR_ALLOC()' does not initialise the pair
object): the content of these words is undefined; this may cause
undefined behaviour while the second allocation takes place and the
garbage collection tries to scan the first pair.  The *correct* code is:

     ikpcb_t * pcb = ik_the_pcb();
     ikptr_t   s_one, s_two;

     s_one = IKA_PAIR_ALLOC(pcb);
     IK_CAR(s_one) = IK_FALSE; /* GOOD */
     IK_CDR(s_one) = IK_FALSE; /* GOOD */
     pcb->root0 = &s_one;
     {
       s_two = IKA_PAIR_ALLOC(pcb);
     }
     pcb->root0 = NULL;

or:

     ikpcb_t * pcb = ik_the_pcb();
     ikptr_t   s_one, s_two;

     s_one = ika_pair_alloc(pcb); /* GOOD */
     pcb->root0 = &s_one;
     {
       s_two = IKA_PAIR_ALLOC(pcb);
     }
     pcb->root0 = NULL;

because 'ika_pair_alloc()' initialises the car and the cdr.

   ---------- Footnotes ----------

   (1) For an introduction to such problems see (URL last verified Jan
12, 2012):

             <http://en.wikipedia.org/wiki/Sequence_point>


File: vicare-scheme.info,  Node: objects booleans,  Next: objects fixnums,  Prev: objects memory,  Up: objects

13.4 Boolean objects
====================

 -- Preprocessor Macro: int IK_IS_BOOLEAN (ikptr_t OBJ)
     If OBJ is 'IK_FALSE' or 'IK_TRUE' return true, else return zero.

 -- Preprocessor Macro: int IK_BOOLEAN_TO_INT (ikptr_t OBJ)
     If OBJ is 'IK_FALSE' return '0', else return '1'.

 -- Preprocessor Macro: ikptr_t IK_BOOLEAN_FROM_INT (int VAL)
     If VAL is '0' return 'IK_FALSE', else return 'IK_TRUE'.


File: vicare-scheme.info,  Node: objects fixnums,  Next: objects pairs,  Prev: objects booleans,  Up: objects

13.5 Fixnum objects
===================

Fixnums are "small" exact integers which fit in a single machine word:

   * On 32-bit platforms the word size is 4 bytes, 30 bits are used for
     fixnum representation:

          (greatest-fixnum)       => +536870911
          (expt 2 29)             => +536870912
          (- (expt 2 29) 1)       => +536870911

          (least-fixnum)          => -536870912
          (- (expt 2 29))         => -536870912

     the representation of a fixnum is:

           30 bits fixnum representation
                |........................|00

                |-----|-----|-----|------+--|
                 byte3 byte2 byte1   byte0

     the two least significant bits are set to zero: this "tags" the
     machine words which embed fixnums.

   * On 64-bit platforms the word size is 8 bytes, 61 bits are used for
     fixnum representation:

          (greatest-fixnum)       => +1152921504606846975
          (expt 2 60)             => +1152921504606846976
          (- (expt 2 60) 1)       => +1152921504606846975

          (least-fixnum)          => -1152921504606846976
          (- (expt 2 60))         => -1152921504606846976

     the representation of a fixnum is:

                   61 bits fixnum representation
          |...............................................|000

          |-----|-----|-----|-----|-----|-----|-----|-----+---|
           byte7 byte6 byte5 byte4 byte3 byte2 byte1  byte0

     the three least significant bits are set to zero: this "tags" the
     machine words which embed fixnums.

   The fixnums tag is '00' on 32-bit platforms and '000' on 64-bit
platforms; given the symbols:

'fx_shift'
     Set to the number of bits in the tag: 2 on 32-bit platforms; 3 on
     64-bit platforms.

'fx_scale'
     Set to the number of bytes in a machine word.

let's consider a memory block whose size in bytes is an exact multiple
of a word size in bytes; the value representing the memory block length
is such that:

     length_in_bytes = number_of_words *  fx_scale
                     = number_of_words *  wordsize
                     = number_of_words << fx_shift

this allows us, for example, to take the fixnum representing the number
of items in a vector and, at the C language level, consider it directly
as size of the vector's data area in bytes.

Basic operations
................

Given an exact integer stored in a 'iksword_t' value with the right
amount of bits, we encode a fixnum as follows:

     iksword_t  the_value  = ...;
     ikptr_t    the_fixnum = (ikptr_t)(the_value << fx_shift);

and we decode it as follows:

     ikptr_t    the_fixnum = ...;
     iksword_t  the_value  = (iksword_t)(the_fixnum >> fx_shift);

to verify if a 'ikptr_t' is a fixnum we do:

     ikptr_t   the_fixnum = ...;

     if (fx_tag == ((iksword_t)the_fixnum & fx_mask))
       it_is_a_fixnum();
     else
       it_is_not();

it is better to use the convenience macros described below.

 -- Macro: fx_tag 0
     The fixnums tag.

 -- Macro: fx_shift
     The number of bits in the fixnums tag.  It is the amount of bits to
     left-shift a machine word to encode its value as fixnum.

 -- Macro: fx_mask
     Bit mask used to isolate the tag bits of a fixnum.

Convenience preprocessor macros
...............................

Examples:

     iksword_t  N = 123L;
     ikptr_t    S = IK_FIX(N);
     iksword_t  M = IK_UNFIX(S);

 -- Preprocessor Macro: ikptr_t IK_FIX (iksword_t NUM)
     Convert a small exact integer in the correct range for a fixnum,
     into a 'ikptr_t' value.  NUM is cast to 'iksword_t'.

 -- Preprocessor Macro: iksword_t IK_UNFIX (ikptr_t REF)
     Convert an 'ikptr_t' value holding a fixnum into a fixnum of type
     'iksword_t'.

 -- Preprocessor Macro: int IK_IS_FIXNUM (ikptr_t REF)
     Evaluate to true if REF is an 'ikptr_t' embedding a fixnum.  It
     just tests if the least significant bits in the tag are set to
     zero.


File: vicare-scheme.info,  Node: objects pairs,  Next: objects bytevectors,  Prev: objects fixnums,  Up: objects

13.6 Pair objects and lists
===========================

A pair is a fixed-length block of memory composed of two machine words;
the 3 least significant bits of an 'ikptr_t' reference to a pair are the
pair tag.

     |-------------------------|-------------| reference to pair
           heap pointer           pair tag

     |-------------------|-------------------| pair memory block
         word 0 = car        word 1 = cdr

   The empty list is not a pair: it is a special constant fitting in a
single 'ikptr_t' machine word, and it is defined by the preprocessor
symbol 'IK_NULL_OBJECT', shortly 'IK_NULL'.

Basic operations
................

Pairs are allocated as follows, leaving the car and cdr uninitialised:

     ikpcb_t *  pcb    = ik_the_pcb();
     ikptr_t    s_pair = IKA_PAIR_ALLOC(pcb);

the car and cdr of a pair are extracted as follows:

     ikptr_t   s_pair = ...;
     ikptr_t   s_car, s_cdr;

     s_car = IK_CAR(s_pair);
     s_cdr = IK_CDR(s_pair);

the car and cdr of a pair are set as follows:

     ikpcb_t * pcb    = ...;
     ikptr_t   s_pair = ...;
     ikptr_t   s_car  = ...;
     ikptr_t   s_cdr  = ...;

     IK_CAR(s_pair) = s_car;
     IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));

     IK_CDR(s_pair) = s_car;
     IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_pair));

 -- Preprocessor Symbol: pair_mask
 -- Preprocessor Symbol: pair_tag
 -- Preprocessor Symbol: pair_size
     'pair_mask' is the bit pattern used to isolate a pair tag from a
     reference 'ikptr_t'; 'pair_tag' is the tag of 'ikptr_t' values
     referencing a pair; 'pair_size' is the number of bytes in a pair
     memory block on the heap.

 -- Preprocessor Symbol: disp_car
 -- Preprocessor Symbol: disp_cdr
 -- Preprocessor Symbol: off_car
 -- Preprocessor Symbol: off_cdr
     'disp_car' and 'disp_cdr' are the offsets in bytes of the car and
     cdr from the beginning of a pair memory block; 'off_car' and
     'off_cdr' are integers to be added to a reference 'ikptr_t' tagged
     as pair to retrieve the car and the cdr from a pair memory block.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_PAIR (ikptr_t X)
     Evaluate to true if the machine word X is tagged as pair.

 -- Preprocessor Macro: ikptr_t IKA_PAIR_ALLOC (ikpcb_t * PCB)
     Allocate a new pair object using 'ik_safe_alloc()' and return a
     tagged reference to it.  The pair words are left *uninitialised*.

 -- Preprocessor Macro: ikptr_t IKU_PAIR_ALLOC (ikpcb_t * PCB)
     Allocate a new pair object using 'ik_unsafe_alloc()' and return a
     tagged reference to it.  The pair words are left *uninitialised*.

 -- Preprocessor Macro: ikptr_t IK_CAR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CDR (ikptr_t PAIR)
     Evaluate to the locations of the car and cdr of a pair; uses of
     these macros can appear both as operands and as left-side of
     assignments.

 -- Preprocessor Macro: ikptr_t IK_CAR_PTR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CDR_PTR (ikptr_t PAIR)
     Evaluate to the pointers to the memory locations holding the car
     and cdr of a pair.

 -- Preprocessor Macro: ikptr_t IK_CAAR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CDAR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CADR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CDDR (ikptr_t PAIR)
     Return, respectively: the car of the car, the cdr of the car, the
     car of the cdr, the cdr of the cdr.

 -- Preprocessor Macro: ikptr_t IK_CAAR_PTR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CDAR_PTR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CADR_PTR (ikptr_t PAIR)
 -- Preprocessor Macro: ikptr_t IK_CDDR_PTR (ikptr_t PAIR)
     Evaluate to the pointers to the memory locations hokding the caar,
     cdar, cadr and cddr of the pair.

Operations on pairs and lists
.............................

 -- Function: ikptr_t ika_pair_alloc (ikpcb_t * PCB)
 -- Function: ikptr_t iku_pair_alloc (ikpcb_t * PCB)
     Allocate and return a new pair object using, respectively,
     'ik_safe_alloc()' and 'ik_unsafe_alloc()' and return a tagged
     reference to it.  Both the car and cdr are initialised to
     'IK_VOID_OBJECT'.

     These functions *do not* call
     'ik_signal_dirt_in_page_of_pointer()'.

 -- Function: ikuword_t ik_list_length (ikptr_t LIST)
     Return the length of the proper list referenced by LIST.  Do not
     handle circular lists.  If the length exceeds 'LONG_MAX': terminate
     the process with 'ik_abort()'.

 -- Function: void ik_list_to_argv (ikptr_t LIST, char ** ARGV)
     Given a reference LIST to a proper list of bytevectors, fill ARGV
     with pointers to the data areas, setting the last element of ARGV
     to 'NULL'.  The array referenced by ARGV must be wide enough to
     hold all the pointers from LIST plus the terminating 'NULL'.

 -- Function: void ik_list_to_argv_and_argc (ikptr_t LIST, char ** ARGV,
          long * ARGC)
     Given a reference LIST to a proper list of bytevectors: fill ARGV
     with pointers to the data areas, setting the last element of ARGV
     to 'NULL'; fill ARGC with the lengths of the bytevectors.  The
     array referenced by ARGV must be wide enough to hold all the
     pointers from LIST plus the terminating 'NULL'; the array
     referenced by ARGC must be wide enough to hold all the lengths.

 -- Function: ikptr_t ika_list_from_argv (ikpcb_t * PCB, char ** ARGV)
     Given a pointer ARGV to a 'NULL'-terminated array of ASCIIZ strings
     build and return a list of bytevectors holding a copy of the ASCIIZ
     strings.  Make use of 'pcb->root8' and 'pcb->root9'.

     This function takes care of calling
     'ik_signal_dirt_in_page_of_pointer()' when appropriate.

 -- Function: ikptr_t ika_list_from_argv_and_argc (ikpcb_t * PCB, char
          ** ARGV, int ARGC)
     Given a pointer ARGV to an array of ASCIIZ strings holding ARGC
     pointers: build and return a list of bytevectors holding a copy of
     the ASCIIZ strings.  Make use of 'pcb->root8' and 'pcb->root9'.

     This function takes care of calling
     'ik_signal_dirt_in_page_of_pointer()' when appropriate.

Pairs and lists code examples
.............................

The suggested general way to allocate and initialise a pair is as
follows:

     ikpcb_t * pcb   = ...;
     ikptr_t   s_pair;

     s_pair = ika_pair_alloc(pcb);
     pcb->root0 = &s_pair;
     {
       IK_ASS(IK_CAR(s_pair), ...);
       IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));

       IK_ASS(IK_CDR(s_pair), ...);
       IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_pair));
     }
     pcb->root0 = NULL;

notice how we take care of allocating the new pair with a function that
initialises the component words and of registering the pair as garbage
collection root before calling the constructors for the car and cdr.

   If the component words do not need memory allocation, for example
because they are fixnums or already existing objects, we can use the
faster code:

     ikpcb_t * pcb    = ik_the_pcb();
     ikptr_t   s_pair = IKA_PAIR_ALLOC(pcb);

     IK_CAR(s_pair) = IK_FIX(123);
     IK_CDR(s_pair) = IK_FIX(456);

   Let's say we need to build a list of bytevectors from ASCIIZ strings
in the array 'argv' and there are 'argc' of them:

     ikpcb_t * pcb  = ik_the_pcb();
     char **   argv = ...;
     long      argc = ...;
     ikptr_t   s_list;

     if (argc) {
       ikptr_t  s_spine;
       long   i;

       s_list = s_spine = ika_pair_alloc(pcb);
       pcb->root0 = &s_list;
       pcb->root1 = &s_spine;
       {
         for (i=0; i<argc;) {
           IK_ASS(IK_CAR(s_spine),
                  ika_bytevector_from_cstring(pcb, argv[i]));
           IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_spine));
           if (++i < argc) {
             IK_ASS(IK_CDR(s_spine), ika_pair_alloc(pcb));
             IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_spine));
             s_spine = IK_CDR(s_spine);
           } else {
             IK_CDR(s_spine) = IK_NULL_OBJECT;
             break;
           }
         }
       }
       pcb->root1 = NULL;
       pcb->root0 = NULL;
     } else
       s_list = IK_NULL_OBJECT;

     /* make use of S_LIST */


File: vicare-scheme.info,  Node: objects bytevectors,  Next: objects vectors,  Prev: objects pairs,  Up: objects

13.7 Bytevector objects
=======================

Bytevectors are blocks of memory referenced by machine words tagged as
bytevectors.  The first word in the memory block is a fixnum
representing the number of bytes in the data area; a bytevector is
capable of holding at most a number of bytes equal to the return value
of 'greatest-fixnum'.

   When allocating a bytevector capable of holding N bytes, the actual
size of the allocated data area is N+1; the additional last byte is not
part of the data area and is perpetually set to zero.  All Vicare's
functions operating on bytevectors set to zero the byte right after the
last used one in the data area.  This last byte allows every bytevector
to be used as ASCIIZ string at the C language level.

   To allow for the same binary layout on both 32-bit and 64-bit
platforms, the data area starts 8 bytes after the beginning; on a 32-bit
platform the layout is:

       1st word   2nd word                       last byte
     |----------|----------|-------------------|-----------|
        length     unused        data area      set to zero

on a 64-bit platform the layout is:

            1st word                             last byte
     |---------------------|-------------------|-----------|
            length               data area      set to zero

Basic operations
................

Bytevector objects are fully allocated on the heap and subject to
garbage collection; to perform the allocation we compute the whole size
of the bytevector data area, add to it room for meta data and finally
compute the aligned block size:

     ikpcb_t * pcb        = ik_the_pcb();
     ikuword_t bv_len     = the_number_of_bytes;
     ikuword_t block_size = disp_bytevector_data + bv_len + 1;
     ikuword_t align_size = IK_ALIGN(block_size);
     ikptr_t   bv = ik_safe_alloc(pcb, align_size) | bytevector_tag;

   'ik_safe_alloc()' returns an 'ikptr_t' value representing the aligned
pointer, having the 3 least significant bits set to zero; we add to it
the bytevector tag (an integer value fitting in 3 bits) which allows to
recognise bytevectors among all the other built in objects.

   We have to explicitly store the bytevector length in the memory block
as a fixnum and set the last byte to zero, so usually a full allocation
looks like this:

     ikptr_t
     ika_bytevector_alloc (ikpcb_t * pcb, ikuword_t bv_len)
     {
       ikuword_t     align_size;
       ikptr_t       s_bv;
       char *        data;
       align_size = IK_ALIGN(disp_bytevector_data + bv_len + 1);
       s_bv       = ik_safe_alloc(pcb, align_size)
                    | bytevector_tag;
       IK_BYTEVECTOR_LENGTH_FX(s_bv) = IK_FIX(bv_len);
       data = IK_BYTEVECTOR_DATA_CHARP(s_bv);
       data[bv_len] = '\0';
       return s_bv;
     }

to acquire the number of bytes we do:

     ikptr_t    s_bv   = the_bytevector;
     ikuword_t  bv_len = IK_BYTEVECTOR_LENGTH(s_bv);

and to access the data area we do:

     ikptr_t    s_bv   = the_bytevector;
     uint8_t *  octets = IK_BYTEVECTOR_DATA_UINT8P(s_bv);

 -- Preprocessor Symbol: bytevector_tag
     An integer used to tag 'ikptr_t' references to bytevector memory
     blocks.

 -- Preprocessor Symbol: disp_bytevector_length
     Displacement of length.  The number of bytes to add to an untagged
     pointer to bytevector to get the pointer to the first byte in the
     machine word holding the bytevector length as fixnum.

 -- Preprocessor Symbol: disp_bytevector_data
     Displacement of data area.  The number of bytes to add to an
     untagged pointer to bytevector to get the pointer to the first byte
     in the data area.

 -- Preprocessor Symbol: off_bytevector_length
     An integer to add to a tagged 'ikptr_t' bytevector reference to
     retrieve the pointer to the first byte of the fixnum representing
     the bytevector length.

 -- Preprocessor Symbol: off_bytevector_data
     An integer to add to a tagged 'ikptr_t' bytevector reference to
     retrieve the pointer to the first byte of the data area.

     Notice that on both 32-bit and 64-bit platforms: the first byte of
     the data area is at the same byte offset from the first byte of the
     bytevector memory block.

Convenience preprocessor macros
...............................

 -- Function: Preprocessor Macro IK_IS_BYTEVECTOR (ikptr_t OBJ)
     Evaluate to true if OBJ is a bytevector.

 -- Preprocessor Macro: ikuword_t IK_BYTEVECTOR_LENGTH (ikptr_t BV)
     Return the number of bytes in the data area of BV.

 -- Preprocessor Macro: ikptr_t IK_BYTEVECTOR_LENGTH_FX (ikptr_t BV)
     Return a fixnum representing the number of bytes in the data area
     of BV.

 -- Preprocessor Macro: ikuword_t IK_BYTEVECTOR_DATA (ikptr_t BV)
     Return an integer representing the memory address of the first byte
     in the data area of BV.

 -- Preprocessor Macro: void * IK_BYTEVECTOR_DATA_VOIDP (ikptr_t BV)
 -- Preprocessor Macro: char * IK_BYTEVECTOR_DATA_CHARP (ikptr_t BV)
 -- Preprocessor Macro: uint8_t * IK_BYTEVECTOR_DATA_UINT8P (ikptr_t BV)
     Return a pointer referencing the first byte in the data area of BV.

Operations on bytevectors
.........................

 -- Function: ikptr_t ika_bytevector_alloc (ikpcb_t * PCB, ikuword_t
          REQUESTED_NUMBER_OF_BYTES)
     Allocate, initialise and return a new bytevector capable of holding
     the specified number of bytes.  The contents of the data area are
     unspecified.  The requested bytevector length *must* be in the
     range of fixnums.

 -- Function: ikptr_t ika_bytevector_from_cstring (ikpcb_t * PCB, const
          char * CSTR)
     Allocate, initialise and return a new bytevector and copy the
     contents of the ASCIIZ string referenced by CSTR in the data area.
     As special case: if CSTR is 'NULL', this function allocates and
     returns an empty bytevector.

     *NOTE* If the string length is greater than the maximum positive
     fixnum: the string is *silently truncated* to a length equal to the
     maximum positive fixnum.

 -- Function: ikptr_t ika_bytevector_from_cstring_len (ikpcb_t * PCB,
          const char * CSTR, size_t LEN)
     Allocate, initialise and return a new bytevector and copy the LEN
     bytes of the ASCII string referenced by CSTR in the data area.

     *NOTE* If the string length is greater than the maximum positive
     fixnum: the string is *silently truncated* to a length equal to the
     maximum positive fixnum.

 -- Function: ikptr_t ika_bytevector_from_memory_block (ikpcb_t * PCB,
          const void * MEMORY, size_t LENGTH)
     Allocate, initialise and return a new bytevector and copy in the
     data area LENGTH bytes from of the memory block referenced by
     MEMORY.

     *NOTE* If the memory block length is greater than the maximum
     positive fixnum: the block is *silently truncated* to a length
     equal to the maximum positive fixnum.

 -- Function: ikptr_t ika_bytevector_from_utf16z (ikpcb_t * PCB, const
          void * DATA);
     Build and return a new bytevector from a memory block referencing a
     UTF-16 string terminated with two consecutive zeros starting at
     even offset:

             char      char      char      char     0    0
          |----+----|----+----|----+----|----+----|----+----|
           byte byte byte byte byte byte byte byte byte byte

     If the the end of the string is not found before the byte index
     reaches the maximum fixnum: return the false object.

 -- Function: ikptr_t ikrt_bytevector_copy (ikptr_t DST, ikptr_t
          DST_START, ikptr_t SRC, ikptr_t SRC_START, ikptr_t COUNT)
     Copy COUNT bytes from bytevector SRC starting at offset SRC_START,
     to bytevector DST starting at offset DST_START; SRC_START,
     DST_START and COUNT must be non-negative fixnums.  Return
     unspecified values.


File: vicare-scheme.info,  Node: objects vectors,  Next: objects structs,  Prev: objects bytevectors,  Up: objects

13.8 Vector objects
===================

Vectors are variable length blocks of memory referenced by machine words
tagged as vectors.  The first machine word of a vector block contains a
fixnum representing the vector length; this means that the first word of
a vector is tagged as a fixnum.

     |------------------------|-------------| reference to vector
           heap pointer         vector tag

     |------------------------|-------------| vector first word
          number of words       fixnum tag

   After the length machine word comes the data area: an array of
machine words, one for each vector slot; slot indexes are zero-based.

           0   1   2   3   4   5   6   7
     |---|---|---|---|---|---|---|---|---| vector memory block
       ^ |...............................|
       |        slots = data area
     length
     fixnum

   A vector is capable of holding at most a number of values equal to
the return value of 'greatest-fixnum'.  The fixnum representing the
vector length, interpreted as raw signed integer, also represents the
number of bytes in the data area.

   A fixnum representing the index of slot N, interpreted as raw signed
integer, also represents the offset in bytes of the first byte of the
slot with respect the beginning of the data area.

Basic operations
................

Vector objects are allocated on the heap; to perform the allocation we
compute the whole size of the data area, add to it room for meta data
and finally compute the aligned block size:

     ikpcb_t *  pcb            = ik_the_pcb();
     ikuword_t  length         = the_number_of_items;
     ikuword_t  requested_size = wordsize * length;
     ikuword_t  block_size     = disp_vector_data + requested_size;
     ikuword_t  align_size     = IK_ALIGN(block_size);
     ikptr_t s_vec = ik_safe_alloc(pcb, align_size) | vector_tag;

'ik_safe_alloc()' returns an 'ikptr_t' value representing the aligned
pointer, having the 3 least significant bits set to zero; we add to it
the vector tag (an integer value fitting in 3 bits) which allows to
recognise vectors among all the other built in objects.

   We have to explicitly store the vector length in the memory block as
a fixnum, so usually a full allocation looks like this:

     ikptr_t
     ika_vector_alloc (ikpcb_t * pcb, ikuword_t number_of_items)
     {
       ikptr_t    s_len      = IK_FIX(number_of_items);
       ikuword_t  align_size = IK_ALIGN(disp_vector_data + s_len);
       ikptr_t s_vec = ik_safe_alloc(pcb, align_size) | vector_tag;
       IK_VECTOR_LENGTH_FX(s_vec) = s_len;
       return s_vec;
     }

notice how we exploit the fact that the fixnum representing the number
of elements, interpreted as raw integer, equals the number of bytes in
the data area needed to hold such elements.

   The allocation operations described above leaves the data area
uninitialised: its content is undefined.  This is bad if the garbage
collector processes the newly built vector before the elements are
initialised to a correct Scheme value.  The following function resets
the data area to a vector of zero fixnums:

     ikptr_t
     ikrt_vector_clean (ikptr_t s_vec)
     {
       ikptr_t	s_len = IK_VECTOR_LENGTH_FX(s_vec);
       memset(IK_VECTOR_DATA_VOIDP(s_vec), 0, s_len);
       return s_vec;
     }

   To fill a vector of 3 items with fixnums we should do:

     ikptr_t  s_vec = the_vector;
     IK_REF(s_vec, off_vector_data + 0 * wordsize) = IK_FIX(10);
     IK_REF(s_vec, off_vector_data + 1 * wordsize) = IK_FIX(20);
     IK_REF(s_vec, off_vector_data + 2 * wordsize) = IK_FIX(30);

or, shorter:

     ikptr_t  s_vec = the_vector;
     IK_ITEM(s_vec, 0) = IK_FIX(10);
     IK_ITEM(s_vec, 1) = IK_FIX(20);
     IK_ITEM(s_vec, 2) = IK_FIX(30);

in this case there is no need to call
'ik_signal_dirt_in_page_of_pointer()' because the values are fixnums
(which are immediate Scheme objects).  To fill the slots of a vector
with Scheme objects allocated on the heap we must do:

     ikpcb_t *  pcb   = ik_the_pcb();
     ikptr_t    s_vec = the_vector;

     pcb->root0 = &s_vec;
     {
       IK_ASS(IK_ITEM(s_vec, 0),
           ika_bytevector_from_cstring(pcb, "A"));
       IK_SIGNAL_DIRT(pcb, IK_ITEM_PTR(s_vec, 0));

       IK_ASS(IK_ITEM(s_vec, 1),
           ika_bytevector_from_cstring(pcb, "B"));
       IK_SIGNAL_DIRT(pcb, IK_ITEM_PTR(s_vec, 1));

       IK_ASS(IK_ITEM(s_vec, 2),
           ika_bytevector_from_cstring(pcb, "B"));
       IK_SIGNAL_DIRT(pcb, IK_ITEM_PTR(s_vec, 2));
     }
     pcb->root0 = NULL;

   To retrieve the item at index 2 we do:

     ikptr_t  s_vec  = the_vector;
     ikptr_t  s_item = IK_REF(s_vec, off_vector_data + 2 * wordsize);

or, shorter:

     ikptr_t  s_vec  = the_vector;
     ikptr_t  s_item = IK_ITEM(s_vec, 2);

   To retrieve the vector length:

     ikptr_t    s_vec  = the_vector;
     ikptr_t    s_len  = IK_REF(s_vec, off_vector_length);
     ikuword_t  length = IK_UNFIX(s_len);

or, shorter:

     ikptr_t    s_vec  = the_vector;
     ikptr_t    s_len  = IK_VECTOR_LENGTH_FX(s_len);
     ikuword_t  length = IK_UNFIX(s_len);

or, even shorter:

     ikptr_t    s_vec  = the_vector;
     ikuword_t  length = IK_VECTOR_LENGTH(s_len);

 -- Preprocessor Symbol: vector_tag
     An integer used to tag 'ikptr_t' references to vector memory
     blocks.

 -- Preprocessor Symbol: disp_vector_length
     Displacement of length.  The number of bytes to add to an untagged
     pointer to vector to get the pointer to the first byte in the word
     holding the vector length as fixnum.

 -- Preprocessor Symbol: disp_vector_data
     Displacement of data area.  The number of bytes to add to an
     untagged pointer to vector to get the pointer to the first byte in
     the data area.

 -- Preprocessor Symbol: off_vector_length
     An integer to add to a tagged 'ikptr_t' reference to retrieve the
     pointer to the first byte of the vector length as fixnum.

 -- Preprocessor Symbol: off_vector_data
     An integer to add to a tagged 'ikptr_t' vector reference to
     retrieve the pointer to the first byte of the data area.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_VECTOR (ikptr_t VEC)
     Evaluate to true if VEC is a reference to a vector object.  This
     predicate tests that VEC is tagged as vector reference and that the
     first machine word in the referenced memory block is a fixnum.

 -- Preprocessor Macro: ikptr_t IK_VECTOR_LENGTH_FX (ikptr_t VEC)
     Return a fixnum representing the number of items in the vector VEC.

 -- Preprocessor Macro: ikuword_t IK_VECTOR_LENGTH (ikptr_t VEC)
     Return an integer representing the number of items in the vector
     VEC.

 -- Preprocessor Macro: ikptr_t IK_ITEM (ikptr_t VEC, ikuword_t IDX)
     Evaluate to the item at index IDX in the vector VEC.  A use of this
     macro can appear both as operand and as left-side of an assignment;
     example:

          ikuword_t  idx   = the_index;
          ikptr_t    s_vec = the_vector;
          ikptr_t    fx;

          IK_ITEM(s_vec, idx) = IK_FIX(10);
          fx = IK_ITEM(s_vec, idx);

 -- Preprocessor Macro: ikptr_t * IK_ITEM_PTR (ikptr_t VEC, ikuword_t
          IDX)
     Return a pointer to the machine word holding the vector item at
     index IDX.  This is especially useful to build the second argument
     in a call to 'ik_signal_dirt_in_page_of_pointer()'.

Operations on vectors
.....................

 -- Function: ikptr_t ika_vector_alloc_no_init (ikpcb_t * PCB, ikuword_t
          NUMBER_OF_ITEMS)
 -- Function: ikptr_t iku_vector_alloc_no_init (ikpcb_t * PCB, ikuword_t
          NUMBER_OF_ITEMS)
     Allocate, initialise and return a new vector object capable of
     holding the specified number of items.  Leave the data area
     uninitialised.

     These functions *do not* call
     'ik_signal_dirt_in_page_of_pointer()'.

 -- Function: ikptr_t ika_vector_alloc_and_init (ikpcb_t * PCB,
          ikuword_t NUMBER_OF_ITEMS)
 -- Function: ikptr_t iku_vector_alloc_and_init (ikpcb_t * PCB,
          ikuword_t NUMBER_OF_ITEMS)
     Allocate, initialise and return a new vector object capable of
     holding the specified number of items.  Initialise the data area so
     that all the items are set to the fixnum zero.

     These functions *do not* call
     'ik_signal_dirt_in_page_of_pointer()'.

 -- Function: int ik_is_vector (ikptr_t VEC)
     Return true if VEC is a reference to a vector object.  This
     predicate tests that VEC is tagged as vector reference and that the
     first machine word in the referenced memory block is a fixnum.

 -- Function: ikptr_t ikrt_vector_clean (ikptr_t VEC)
     Clean the data area so that all the items are set to the fixnum
     zero.

 -- Function: ikptr_t ikrt_vector_copy (ikptr_t DST, ikptr_t DST_START,
          ikptr_t SRC, ikptr_t SRC_START, ikptr_t COUNT, ikpcb_t * PCB)
     Copy COUNT items from vector SRC starting at offset SRC_START, to
     vector DST starting at offset DST_START; SRC_START, DST_START and
     COUNT must be non-negative fixnums.  Return unspecified values.


File: vicare-scheme.info,  Node: objects structs,  Next: objects chars,  Prev: objects vectors,  Up: objects

13.9 Struct objects
===================

A data structure is a variable-length block of memory referenced by
machine words tagged as vectors; the first machine word of a structure
is a reference to its structure type descriptor (STD), which is itself a
data structure; the subsequent words, if any, are the fields of the
structure.  A block of memory is a data structure if and only if: a
reference to it is tagged as vector and its first word is tagged as
vector.

     |----------------|----------| reference to structure
       heap pointer    vector tag

     |----------------|----------| first word of structure
       heap pointer    vector tag    = reference to STD
                                     = reference to structure

   The whole memory block layout of a struct with 5 fields is as
follows:

     |-----|------|------|------|------|------|
       STD  field0 field1 field2 field3 field4

fields are indexed starting at zero.

   The type descriptor of the type descriptors is the return value of
'base-rtd' at the Scheme level and the structure referenced by the field
'base_rtd' in the process control block (PCB).  Such base type
descriptor is built at Vicare's startup.

   The graph of references for a structure and its type descriptor is as
follows:

          STD ref
         |-------|---------------| structure instance
             |
      ---<---
     |
     |    STD ref
      -->|-------|---------------| struct type descriptor
             |
      ---<---
     |
     |    STD ref
     +-->|-------|---------------| base struct type descriptor
     |       |
      ---<---

the struct-type descriptor of the base struct-type descriptor is the
base type descriptor itself.

   About R6RS records and their types:

   * A R6RS record instance is a struct instance whose first word
     references its R6RS record-type descriptor (RTD).

   * A R6RS record-type descriptor (RTD) is a struct instance of type
     '<rtd>'.  The type '<rtd>' is defined at the Scheme level.

   * A R6RS record-constructor descriptor (RCD) is a struct instance of
     type '<rcd>'.  The type '<rcd>' is defined at the Scheme level.

   The graph of references for a R6RS record and its type descriptor is
as follows:

          RTD ref
         |-------|---------------| R6RS record instance
             |
      ---<---
     |
     |    STD ref
      -->|-------|---------------| R6RS record-type descriptor
             |                      = struct instance of type <rtd>
      ---<---
     |
     |    STD ref
     +-->|-------|---------------| <rtd> struct-type descriptor
             |
      ---<---
     |
     |    STD ref
     +-->|-------|---------------| base struct-type descriptor
     |       |
      ---<---

   A struct-type descriptor (STD) is a fixed-length block of memory
composed of 6 machine words interpreted as follows:

  0. A reference to the base STD.

  1. A fixnum representing the number of machine words in the structure
     minus 1; this is the number of fields in the structure excluding
     the reference to the STD.  This value is 6 in the base STD.

  2. Scheme symbol representing the name of this structure type.

  3. Scheme list of symbols representing the names of fields in
     structures of this type.

  4. False or a reference to closure used to print to a Scheme port the
     structures of this type.  This is the "printer" function.

  5. Scheme symbol used as unique identifier for this type.

  6. False or closure object to be used as destructor for instances of
     this type (*note Finalisation of structures: syslib structs safe
     final.).

   Type descriptors are best defined at the Scheme level using the
functions from the library '(vicare system structs)' (*note
define-struct: syslib structs safe define.).  To instantiate a structure
at the C language level we should write a C function accepting the type
descriptor as argument, and have the Scheme code hand the descriptor to
it.  For example, at the Scheme level we do:

     (define-struct timeval
       (tv_sec tv_usec))

     (define (gettimeofday)
       (foreign-call "ikrt_posix_gettimeofday"
                     (struct-type-descriptor timeval)))

and at the C level we do:

     ikptr_t
     ikrt_posix_gettimeofday (ikptr_t s_rtd, ikpcb_t * pcb)
     {
       /* build and return an instance of "timeval" */
     }

Basic operations
................

Data structure objects are allocated on the heap; to perform the
allocation we compute the whole size of the structure:

     ikpcb_t *  pcb           = ik_the_pcb();
     ikuword_t  num_of_fields = ...;
     ikuword_t  block_size    = \
       disp_record_data + wordsize * num_of_fields;
     ikuword_t  align_size    = IK_ALIGN(block_size);
     ikptr_t s_stru = ik_safe_alloc(pcb, align_size) | record_tag;

'ik_safe_alloc()' returns an 'ikptr_t' value representing the aligned
pointer, having the 3 least significant bits set to zero; we add to it
the record tag (an integer value fitting in 3 bits) which allows to
recognise records among all the other built in objects.

   We have to explicitly store a reference to the STD in the first
machine word of the structure, so a full allocation looks like this:

     ikptr_t
     ika_struct_alloc_no_init (ikpcb_t * pcb, ikptr_t s_std)
     {
       ikptr_t    s_num_of_fields = IK_STD_LENGTH(s_std);
       ikuword_t  num_of_fields   = IK_UNFIX(s_num_of_fields);
       ikuword_t  align_size      = \
         IK_ALIGN(disp_record_data + num_of_fields * wordsize);
       ikptr_t    s_stru;
       pcb->root9 = &s_std;
       {
         s_ stru = ik_safe_alloc(pcb, align_size) | record_tag;
       }
       pcb->root9 = NULL;
       IK_STRUCT_STD(s_stru) = s_std;
       return s_stru;
     }

notice that we do not need to call 'ik_signal_dirt_in_page_of_pointer()'
for S_STRU because S_STD is an older object.

   The allocation operation described above leaves the data area
uninitialised: its content is undefined.  This is bad if the garbage
collector moves the newly built record before the elements are
initialised to a correct Scheme value.

   Structure fields are identified at the C level by a zero-based index;
to store a value in field 2 of a structure we do:

     ikptr_t  s_stru  = the_structure;
     ikptr_t  s_field = the_field;

     IK_REF(s_stru, off_record_data + 2 * wordsize) = the_field;
     IK_SIGNAL_DIRT(pcb, \
       IK_PTR(s_stru, off_record_data + 2 * wordsize));

or, shorter:

     ikptr_t  s_stru  = the_structure;
     ikptr_t  s_field = the_field;

     IK_FIELD(s_stru, 2) = the_field;
     IK_SIGNAL_DIRT(pcb, IK_FIELD_PTR(s_stru, 2));

and to retrieve a the value of field 2 we do:

     ikptr_t  s_stru  = the_structure;
     ikptr_t  s_field;

     s_field = IK_REF(s_stru, off_record_data + 2 * wordsize);

or, shorter:

     ikptr_t  s_stru  = the_structure;
     ikptr_t  s_field;

     s_field = IK_FIELD(s_stru, 2);

 -- Preprocessor Symbol: record_mask
 -- Preprocessor Symbol: record_tag
     Integer values used to tag and recognise 'ikptr_t' references to
     structures.  'record_mask' isolates the tag bits from an 'ikptr_t'
     and 'record_tag' represents the tag bits.  These values are the
     same used for vectors.

 -- Preprocessor Symbol: disp_record_rtd
     Displacement of the STD from the beginning of a structure block.
     The number of bytes to add to an untagged pointer to structure to
     get the pointer to the first byte in the word holding the STD.

 -- Preprocessor Symbol: disp_record_data
     Displacement of data area.  The number of bytes to add to an
     untagged pointer to structure to get the pointer to the first byte
     of the first field in the data area.

 -- Preprocessor Symbol: off_record_rtd
     An integer to add to a tagged 'ikptr_t' structure reference to
     retrieve the pointer to the first byte of the STD.

 -- Preprocessor Symbol: off_record_data
     An integer to add to a tagged 'ikptr_t' structure reference to
     retrieve the pointer to the first byte of the first field of the
     structure.

 -- Preprocessor Symbol: disp_rtd_rtd
     Displacement of the base STD from the beginning of an STD block.
     The number of bytes to add to an untagged pointer to STD to get the
     pointer to the first byte of the reference to STD.

 -- Preprocessor Symbol: disp_rtd_name
 -- Preprocessor Symbol: disp_rtd_length
 -- Preprocessor Symbol: disp_rtd_fields
 -- Preprocessor Symbol: disp_rtd_printer
 -- Preprocessor Symbol: disp_rtd_symbol
     Displacements of the fields of an STD.

 -- Preprocessor Symbol: rtd_size
     The total number of bytes in a memory block holding an STD.

 -- Preprocessor Symbol: off_rtd_rtd
 -- Preprocessor Symbol: off_rtd_name
 -- Preprocessor Symbol: off_rtd_length
 -- Preprocessor Symbol: off_rtd_fields
 -- Preprocessor Symbol: off_rtd_printer
 -- Preprocessor Symbol: off_rtd_symbol
     Integer to add to a tagged 'ikptr_t' STD reference to retrieve the
     pointer to the first byte of the fields.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_STRUCT (ikptr_t OBJ)
     Evaluate to true if OBJ is a reference to a structure; otherwise
     evaluate to false.

 -- Preprocessor Macro: ikptr_t IK_STD_STD (ikptr_t STD)
 -- Preprocessor Macro: ikptr_t IK_STD_NAME (ikptr_t STD)
 -- Preprocessor Macro: ikptr_t IK_STD_LENGTH (ikptr_t STD)
 -- Preprocessor Macro: ikptr_t IK_STD_FIELDS (ikptr_t STD)
 -- Preprocessor Macro: ikptr_t IK_STD_PRINTER (ikptr_t STD)
 -- Preprocessor Macro: ikptr_t IK_STD_SYMBOL (ikptr_t STD)
 -- Preprocessor Macro: ikptr_t IK_STD_DESTRUCTOR (ikptr_t STD)
     Evaluate to the location of the field in the struct-type descriptor
     STD; STD must be a tagged reference to a struct-type descriptor.  A
     use of this macro can appear both as operand and as left-side of an
     assignment.

 -- Preprocessor Macro: ikptr_t IK_STRUCT_STD (ikptr_t STRU)
 -- Preprocessor Macro: ikptr_t IK_STRUCT_RTD (ikptr_t STRU)
     Evaluate to the location of the struct-type descriptor field for
     the structure STRU; STRU must be a tagged reference to a struct
     object.  A use of this macro can appear both as operand and as
     left-side of an assignment.

          ikptr_t  s_stru = the_structure;
          ikptr_t  s_std;

          s_std = IK_STRUCT_STD(s_stru);
          IK_STRUCT_STD(s_stru) = s_std;

 -- Preprocessor Macro: ikptr_t * IK_STRUCT_STD_PTR (ikptr_t STRU)
 -- Preprocessor Macro: ikptr_t * IK_STRUCT_RTD_PTR (ikptr_t STRU)
     Evaluate to a pointer to the struct-type descriptor field for the
     structure STRU; STRU must be a tagged reference to a struct object.

     These macros are useful to build the second argument for a call to
     'ik_signal_dirt_in_page_of_pointer()'.

 -- Preprocessor Macro: ikptr_t IK_FIELD (ikptr_t STRU, ikuword_t IDX)
     Evaluate to the location of the field at zero-based index IDX for
     the structure STRU.  A use of this macro can appear both as operand
     and as left-side of an assignment.

          ikptr_t   s_stru = the_structure;
          ikptr_t   s_field;

          s_field = IK_FIELD(s_stru, 2);

          IK_FIELD(s_stru, 2) = s_field;
          IK_SIGNAL_DIRT(pcb, IK_FIELD_PTR(s_stru, 2));

 -- Preprocessor Macro: ikptr_t * IK_FIELD_PTR (STR, ikuword_t IDX)
     Evaluate to a pointer to the field at index IDX for the structure
     STRU; STRU must be a tagged reference to a struct object.

     This macro is useful to build the second argument for a call to
     'ik_signal_dirt_in_page_of_pointer()'.

 -- Preprocessor Macro: void * IK_STRUCT_FIELDS_VOIDP (ikptr_t STRU)
     Given a tagged pointer referencing a struct: return a pointer to
     the first machine word in the data area of the struct's memory
     block; this is a pointer to the location of the first struct field.

Operations on structs
.....................

 -- Function: ikptr_t ika_struct_alloc_no_init (ikpcb_t * PCB, ikptr_t
          STD)
     Allocate, initialise and return a new structure instance of type
     STD.  The first word of the allocated block is initialised with
     STD, the other words are left uninitialised.

     *NOTE* This function makes use of the field 'root9' of PCB.

 -- Function: ikptr_t ika_struct_alloc_and_init (ikpcb_t * PCB, ikptr_t
          STD)
     Allocate, initialise and return a new structure instance of type
     STD.  The first word of the allocated block is initialised with
     STD, the other words are initialised to the fixnum zero.

     *NOTE* This function makes use of the field 'root9' of PCB.

 -- Function: int ik_is_struct (ikptr_t R)
     Return true if R is a reference to a structure; otherwise return
     false.


File: vicare-scheme.info,  Node: objects chars,  Next: objects strings,  Prev: objects structs,  Up: objects

13.10 Character objects
=======================

A Scheme character has two representations:

   * As a standalone Scheme object, it is a machine word whose least
     significant bits are set to the character's tag and whose most
     significant bits are set to the character's Unicode code point.

   * When embedded in a Scheme string, it is a 32-bit value whose least
     significant bits are set to the character's tag and whose most
     significant bits are set to the character's Unicode code point.

the least significant 32 bits of the two representations are equal
(*note unicode::).

   Let's say that machine words are 32-bit values, which means the word
size is 4 bytes; then the representation of a character is:

     |    Unicode code point    | char tag

     |--------|--------|--------|--------|
       byte3    byte2    byte1    byte0

the least significant byte is set to '#x0F': this "tags" the machine
words which embed characters.  On 64-bit machines, the layout is:

             Unused              |Unicode code point  |char tag
     |...........................|....................|......|

     |------|------|------|------|------|------|------|------|
      byte7  byte6  byte5  byte4  byte3  byte2  byte1  byte0

   At the Scheme level: standalone characters are moved around as
'ikptr_t' values, but when characters are stored in a string the
'ikptr_t' value is converted to a 32-bit integer of type 'ikchar_t'.

Basic operations
................

Standalone characters are encoded into 'ikptr_t' values as follows:

     ikuword_t  unicode_code_point = the_code_point;
     ikptr_t    s_char;

     s_char = (unicode_code_point << char_shift) | char_tag;

decoded to 'ikuword_t' values as follows:

     ikptr_t    s_char = the_character;
     ikuword_t  unicode_code_point;

     unicode_code_point = s_char >> char_shift;

and identified as follows:

     ikptr_t   X = the_value;

     if (char_tag == (char_mask & X))
       it_is_a_character();
     else
       it_is_not();

   Characters from a Scheme string are decoded from 'ikchar_t' to
'ikuword_t' as follows:

     ikchar_t   ch = the_32bit_character;
     ikuword_t  unicode_code_point;

     unicode_code_point = s_char >> char_shift;

and encoded from 'ikuword_t' to 'ikchar_t' as follows:

     ikuword_t  unicode_code_point = the_code_point;
     ikchar_t   ch;

     ch = (ikchar_t)((unicode_code_point << char_shift) | char_tag);

 -- Type Definition: ikchar_t
     An alias for 'uint32_t' used to store a Unicode code point tagged
     as character.

 -- Preprocessor Symbol: char_mask
 -- Preprocessor Symbol: char_tag
     Integer values used to tag and recognise 'ikptr_t' values
     representing characters.  'char_mask' isolates the tag bits from an
     'ikptr_t' and 'char_tag' represents the tag bits.

 -- Preprocessor Symbol: char_shift
     Integer value representing the number of bits we must shift left to
     turn a C language 'long' into a machine word ready to be tagged as
     Scheme character.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_CHAR (ikptr_t X)
     Evaluate to true if X is a Scheme character.

 -- Preprocessor Macro: ikptr_t IK_CHAR_FROM_INTEGER (ikuword_t X)
 -- Preprocessor Macro: ikuword_t IK_CHAR_TO_INTEGER (ikptr_t X)
     Convert a Scheme character to and from an 'ikuword_t' value
     representing the Unicode code point.

 -- Preprocessor Macro: ikchar_t IK_CHAR32_FROM_INTEGER (ikuword_t X)
     Convert a 'ikuword_t' value representing the Unicode code point
     into a 32-bit integer representing a Scheme character to be stored
     into a string.

 -- Preprocessor Macro: uint32_t IK_CHAR32_TO_INTEGER (ikchar_t CH)
     Given a 32-bit value representing a Scheme character: untag it and
     return a 32-bit value representing the Unicode code point.

 -- Preprocessor Macro: ikuword_t IK_UNICODE_FROM_ASCII (char CH)
     Return an unsigned integer representing the Unicode code point
     corresponding to the given ASCII character.


File: vicare-scheme.info,  Node: objects strings,  Next: objects symbols,  Prev: objects chars,  Up: objects

13.11 String objects
====================

Strings are variable-length blocks of memory referenced by machine words
tagged as strings; strings are *not* stored in memory in UTF-32 format.
The first word in the memory block is a fixnum representing the number
of characters in the data area; a string is capable of holding at most a
number of characters equal to the return value of 'greatest-fixnum'.

     |------------------------|-------------| reference to string
           heap pointer         string tag

     |------------------------|-------------| string first word
          number of words       fixnum tag

   All the remaining space in the memory block is filled with 32-bit
unsigned integers whose least significant bits are set to the character
tag and whose most significant bits are set to the character's Unicode
code point:

      tag ch0 ch1 ch2 ch3 ch4 ch5 ch6 ch7
     |---|---|---|---|---|---|---|---|---| string memory block

   Character indexes are zero-based.

Basic operations
................

String objects are allocated on the heap; to perform the allocation we
compute the whole size of the data area, add to it room for meta data
and finally compute the aligned block size:

     ikpcb_t *  pcb            = ik_the_pcb();
     ikuword_t  length         = the_number_of_chars;
     ikuword_t  requested_size = sizeof(ikchar_t) * length;
     ikuword_t  block_size     = disp_string_data + requested_size;
     ikuword_t  align_size     = IK_ALIGN(block_size);
     ikptr_t    s_str = ik_safe_alloc(pcb, align_size) | string_tag;

'ik_safe_alloc()' returns an 'ikptr_t' value representing the aligned
pointer, having the 3 least significant bits set to zero; we add to it
the string tag (an integer value fitting in 3 bits) which allows to
recognise strings among all the other built in objects.

   We have to explicitly store the string length in the memory block as
a fixnum, so usually a full allocation looks like this:

     ikptr_t
     ika_string_alloc (ikpcb_t * pcb, ikuword_t number_of_chars)
     {
       ikuword_t align_size = IK_ALIGN(disp_string_data + \
         number_of_chars * sizeof(ikchar_t));
       ikptr_t   s_str = ik_safe_alloc(pcb, align_size) | string_tag;
       IK_STRING_LENGTH_FX(s_str) = IK_FIX(number_of_chars);
       return s_str;
     }

which will leave the characters not initialised: this is not a problem
from the garbage collector point of view.  Strings are allocated on the
Scheme heap's nursery, which is not a garbage collection root; this
means we can leave uninitialised the memory words allocated by
'ik_safe_alloc()' to round the block size to the aligned size.

   To fill a string of 3 chars with characters we should do:

     ikptr_t     s_str = the_string;
     ikchar_t *  ch    = IK_STRING_DATA_IKCHARP(s_str);

     ch[0] = IK_CHAR32_FROM_INTEGER(10);
     ch[1] = IK_CHAR32_FROM_INTEGER(20);
     ch[2] = IK_CHAR32_FROM_INTEGER(30);

to retrieve the character at index 2 we do:

     ikuword_t   index  = 2;
     ikptr_t     s_str  = the_string;
     ikchar_t *  ch     = IK_STRING_DATA_IKCHARP(s_str);
     ikptr_t     s_char = (ikptr_t)ch[index];

and to retrieve the string length:

     ikptr_t    s_str    = the_string;
     ikptr_t    s_length = IK_STRING_LENGTH_FX(s_str);
     ikuword_t  length   = IK_UNFIX(s_length);

or, shorter:

     ikptr_t    s_str  = the_string;
     ikuword_t  length = IK_STRING_LENGTH(s_str);

 -- Preprocessor Symbol: string_char_size
     Integer value representing the number of bytes in a Scheme
     character stored in a Scheme string.

 -- Preprocessor Symbol: string_mask
 -- Preprocessor Symbol: string_tag
     Integer values used to tag and recognise 'ikptr_t' values
     representing string references.  'string_mask' isolates the tag
     bits from an 'ikptr_t' and 'string_tag' represents the tag bits.

 -- Preprocessor Symbol: disp_string_length
     Displacement of length.  The number of bytes to add to an untagged
     pointer to string to get the pointer to the first byte in the word
     holding the string length as fixnum.

 -- Preprocessor Symbol: disp_string_data
     Displacement of data area.  The number of bytes to add to an
     untagged pointer to string to get the pointer to the first byte in
     the data area.

 -- Preprocessor Symbol: off_string_length
     An integer to add to a tagged 'ikptr_t' reference to retrieve the
     pointer to the first byte of the string length as fixnum.

 -- Preprocessor Symbol: off_string_data
     An integer to add to a tagged 'ikptr_t' string reference to
     retrieve the pointer to the first byte of the data area.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_STRING (ikptr_t OBJ)
     Return true if OBJ is a reference to a string object.

 -- Preprocessor Macro: ikptr_t IK_STRING_LENGTH_FX (ikptr_t STR)
     Return a fixnum representing the number of characters in the string
     STR.

 -- Preprocessor Macro: ikuword_t IK_STRING_LENGTH (ikptr_t STR)
     Return an integer representing the number of characters in the
     string STR.

 -- Preprocessor Macro: ikchar_t IK_CHAR32 (ikptr_t STR, ikuword_t IDX)
     Evaluate to the 32-bit character representation at index IDX in the
     string STR.  A use of this macro can appear both as operand and as
     left-side of an assignment; example:

          ikuword_t  idx   = the_index;
          ikptr_t    s_str = the_string;
          ikchar_t   ch;

          IK_CHAR32(s_str, idx) = IK_CHAR32_FROM_INTEGER(10);
          ch = IK_CHAR32(s_str, idx);

 -- Preprocessor Macro: void * IK_STRING_DATA_VOIDP (ikptr_t STR)
     Given a tagged reference to string object STR, return a pointer to
     the first byte in the data area.

 -- Preprocessor Macro: ikchar_t * IK_STRING_DATA_IKCHARP (ikptr_t STR)
     Given a tagged reference to string object STR, return a pointer to
     the first Scheme character in the data area.

Operations on strings
.....................

 -- Function: ikptr_t ika_string_alloc (ikpcb_t * PCB, ikuword_t
          NUMBER_OF_CHARS)
 -- Function: ikptr_t iku_string_alloc (ikpcb_t * PCB, ikuword_t
          NUMBER_OF_CHARS)
     Allocate, initialise and return a new string object capable of
     holding the specified number of chars.

 -- Function: ikptr_t ika_string_from_cstring (ikpcb_t * PCB, const char
          * CSTR)
 -- Function: ikptr_t iku_string_from_cstring (ikpcb_t * PCB, const char
          * CSTR)
     Allocate a new string object and fill it with the ASCII characters
     from the given ASCIIZ string.

 -- Function: ikptr_t iku_string_to_symbol (ikpcb_t * PCB, ikptr_t STR)
     Return a Scheme symbol object whose name is the Scheme string STR.
     This function is the same as 'iku_symbol_from_string()'.


File: vicare-scheme.info,  Node: objects symbols,  Next: objects bignums,  Prev: objects strings,  Up: objects

13.12 Symbol objects
====================

A symbol is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a symbol block is tagged
has symbol in its least significant bits and it has the most significant
bits set to zero.

     |------------------------|-------------| reference to symbol
           heap pointer         vector tag

     |------------------------|-------------| symbol first word
        all set to zero         symbol tag

   A symbol memory block is 6 words wide and contains immediate Scheme
objects or references to Scheme objects; each word is a slot and the
slots have names: 'string', 'ustring', 'value', 'proc', 'plist'.

* Menu:

* objects symbols values::      The 'value' and 'proc' slots.
* objects symbols ops::         Operations with the C language API.


File: vicare-scheme.info,  Node: objects symbols values,  Next: objects symbols ops,  Up: objects symbols

13.12.1 The 'value' and 'proc' slots
------------------------------------

The 'value' field has multiple purposes:

   * When the symbol is the unique identifier of a data structure type:
     the 'value' field holds a reference to the data struct-type
     descriptor.

   * When the symbol is the unique identifier of a R6RS record type: the
     'value' field holds a reference to the record-type descriptor.

   * Bindings defined at the top level of libraries, programs or
     standalone expressions to be evaluated by 'eval', have their
     current value stored in the 'value' slot of symbols, or, more
     precisely, of gensyms; such symbols are called "location gensyms"
     or "loc gensyms".

   * Bindings defined at the top level of libraries, programs or
     standalone expressions to be evaluated by 'eval', have a "label
     gensym" associated to them: a symbol whose 'value' slot holds a
     reference to the syntactic binding descriptor to be used by the
     expander.

   * And more.

   About the 'proc' slot: when a top level binding is never assigned (in
other words: it is immutable) and its value is a closure object, the
associated loc gensym holds its value in both the 'value' slot and the
'proc' slot.  Whenever binary code in a code object performs a call to a
non-assigned top level closure object, it does the following:

  1. From the relocation vector of the current code object: retrieve the
     loc gensym of the closure to call.

  2. From the loc gensym: extract the value of the 'proc' slot, which is
     meant to be a reference to the closure object.  This is done by
     accessing the gensym object with a low-level assembly instruction,
     *not necessarily* by using the primitive operation '$symbol-proc'.

  3. Actually call the closure object.

   Values stored in the 'value' slot of loc gensyms can be closure
objects or not; they can be called by binary code, but they need to be
validated as closure objects first.  Values stored in the 'proc' slot
can only be references to closure objects and they can be called by
binary code without being first validated.

Use in primitive function syntactic bindings
............................................

All the primitive functions implemented by code in Vicare's boot image
are accessible from libraries defined by the boot image; such primitive
functions have a loc gensym associated to them, in which both the
'value' and 'proc' slots hold a reference to the actual closure object.
The bindings of primitive functions are immutable.

Use in library top level syntactic bindings
...........................................

All the top level bindings defined by a 'library' form have a loc gensym
associated to them:

   * If a binding is never assigned in the source code of the library
     and its value is a closure object: both the 'value' and 'proc'
     slots of its loc gensym hold a reference to the actual closure
     object.

   * If a binding is assigned in the source code of the library: its
     value is stored in the 'value' slot of its loc gensym; the 'proc'
     slot of the loc gensym is set to the unbound object.

   * If a binding's value is not a closure object: its value is stored
     in the 'value' slot of its loc gensym; the 'proc' slot of the loc
     gensym is set to the unbound object.


File: vicare-scheme.info,  Node: objects symbols ops,  Prev: objects symbols values,  Up: objects symbols

13.12.2 Operations with the C language API
------------------------------------------

Symbol objects are allocated on the heap and must be interned, that is
registered in a global symbol table.

 -- Preprocessor Symbol: symbol_mask
 -- Preprocessor Symbol: symbol_tag
     Integer values used to tag and recognise the first word in symbol
     memory blocks.  'symbol_mask' isolates the tag bits from an
     'ikptr_t' and 'symbol_tag' represents the tag bits.

 -- Preprocessor Symbol: symbol_record_size
     Number of bytes needed to hold a symbol memory block.

 -- Preprocessor Symbol: disp_symbol_record_tag
 -- Preprocessor Symbol: disp_symbol_record_string
 -- Preprocessor Symbol: disp_symbol_record_ustring
 -- Preprocessor Symbol: disp_symbol_record_value
 -- Preprocessor Symbol: disp_symbol_record_proc
 -- Preprocessor Symbol: disp_symbol_record_plist
     Symbol field displacements.  The number of bytes to add to an
     untagged pointer to symbol to get the pointer to the first byte in
     the word holding the specified field.

 -- Preprocessor Symbol: off_symbol_record_tag
 -- Preprocessor Symbol: off_symbol_record_string
 -- Preprocessor Symbol: off_symbol_record_ustring
 -- Preprocessor Symbol: off_symbol_record_value
 -- Preprocessor Symbol: off_symbol_record_proc
 -- Preprocessor Symbol: off_symbol_record_plist
     Symbol field offsets.  The number of bytes to add to an tagged
     pointer to symbol to get the pointer to the first byte in the word
     holding the specified field.

Operations on symbols
.....................

 -- Function: int ik_is_symbol (ikptr_t OBJ)
     Return true if OBJ is a symbol.

 -- Function: ikptr_t iku_symbol_from_string (ikpcb_t * PCB, ikptr_t
          STR)
     Return a Scheme symbol object whose name is the Scheme string STR.
     This function is the same as 'iku_string_to_symbol()'.


File: vicare-scheme.info,  Node: objects bignums,  Next: objects integers,  Prev: objects symbols,  Up: objects

13.13 Bignum objects
====================

Bignums are multi-precision exact integers bigger than fixnums; they are
implemented using the 'mpn' API of GNU GMP, *Note Low-level Functions:
(gmp)Low-level Functions.

   Vicare only uses a bignum to represent an exact integer when the
value does not fit in a fixnum; it follows that the following ranges are
enforced:

     negative bignums < (least-fixnum) <= all fixnums

     all fixnums <= (greatest-fixnum) < positive bignums

and notice that:

   * The smallest positive bignum is '(+ 1 (greatest-fixnum))' which can
     also be computed as '(- (least-fixnum))'.

   * The greatest negative bignum is '(- (least-fixnum) 1)'.

   A bignum is a variable length memory block referenced by machine
words tagged as vectors.  The first machine word of a bignum block is
tagged has bignum in its least significant bits; then comes a sign bit,
zero if positive; the remaining most significant bits represent the
number of words in the memory block after the first one.

     |------------------------|-------------| reference to bignum
           heap pointer         vector tag

                          sign bit
     |----------------------|-|-------------| bignum first word
        number of words         bignum tag

   A pointer to the second machine word in a bignum memory block is the
pointer of type 'mp_limb_t' accepted by the 'mpn_' functions of GMP;
"limb", in GMP jargon, is a machine word holding a portion of
multi-precision number.  The layout of a bignum memory block is as
follows:

     |----|-----|-----|-----|-----| ...
      1st  limb0 limb1 limb2 limb3

where the first word '1st' is a header of meta informations encoded as
explained above and each limb is a machine word stored in *native*
endianness; the big number is the concatenation of limbs with 'limb0'
being the least significant one.  There is always at least one limb;
when a bignum is composed of a single limb, its value is always non-zero
and outside the range of fixnums.

Basic operations
................

To allocate a bignum we must know the number of required limbs:

     ikpcb_t *  pcb        = ik_the_pcb();
     ikuword_t  nlimbs     = the_number_of_limbs;
     ikuword_t  block_size = disp_bignum_data + nlimbs * wordsize;
     ikuword_t  align_size = IK_ALIGN(block_size);
     ikptr_t s_bn = ik_safe_alloc(pcb, align_size) | vector_tag;

we must explicitly build and encode the first word; the number of limbs
is encoded as follows:

     ikuword_t  nlimbs      = the_number_of_limbs;
     ikptr_t    meta_nlimbs = nlimbs << bignum_nlimbs_shift;

the sign bit is encoded as follows:

     ikuword_t  sign      = zero_if_positive_one_if_negative;
     ikptr_t    meta_sign = sign << bignum_sign_shift;

and the full first word is composed and stored as follows:

     ikptr_t  s_bn        = the_bignum;
     ikptr_t  meta_nlimbs = ...;
     ikptr_t  meta_sign   = ...;
     ikptr_t  s_fst       = meta_nlimbs | meta_sign | bignum_tag;

     IK_REF(s_bn, off_bignum_tag) = s_fst;

   To identify an object as bignum we do:

     ikptr_t  X = the_object;

     if ((vector_tag == IK_TAGOF(X)) &&
         (bignum_tag == (bignum_mask & IK_REF(X, off_bignum_tag))))
       it_is_a_bignum();
     else
       it_is_not();

to extract meta informations we must first extract the first word:

     ikptr_t    s_bn  = the_bignum;
     ikptr_t    s_fst = IK_REF(s_bn, off_bignum_tag);
     ikuword_t  nlimbs;
     ikuword_t  meta_sign;

     nlimbs    = ((ikuword_t)s_fst) >> bignum_nlimbs_shift;
     meta_sign = ((ikuword_t)s_fst) &  bignum_sign_mask;

if 'meta_sign' is zero the bignum is positive, else it is negative.

   To acquire a pointer to the data area we do:

     ikptr_t      s_bn = the_bignum;
     mp_limb_t *  data = IK_BIGNUM_DATA_LIMBP(s_bn);

to extract the N-th limb we do:

     ikptr_t    s_bn = the_bignum;
     ikuword_t  N    = the_index;
     mp_limb_t  limb = IK_LIMB(s_bn, N);

 -- Preprocessor Symbol: bignum_mask
 -- Preprocessor Symbol: bignum_tag
     'bignum_mask' is the bit pattern used to isolate a bignum tag from
     an 'ikptr_t' value; 'bignum_tag' is the tag of 'ikptr_t' values
     used as first words in bignum memory blocks.

 -- Preprocessor Symbol: bignum_sign_mask
     A bit pattern used to isolate the sign bit from the 'ikptr_t' value
     used as first word in bignum memory blocks.

 -- Preprocessor Symbol: bignum_sign_shift
     The number representing the bit left-shift offset of the sign bit
     in the 'ikptr_t' value used as first word in bignum memory blocks.

 -- Preprocessor Symbol: bignum_nlimbs_shift
     The number representing the bit left-shift offset of the number of
     limbs in the 'ikptr_t' value used as first word in bignum memory
     blocks.

 -- Preprocessor Symbol: disp_bignum_tag
     Offset in bytes of the first word in a bignum memory block from the
     beginning of the block.  It is zero.

 -- Preprocessor Symbol: disp_bignum_data
     Offset in bytes of the first byte in the data area of a bignum
     memory block from the beginning of the block.

 -- Preprocessor Symbol: off_bignum_tag
     Number to add to a tagged 'ikptr_t' reference to bignum to obtain a
     pointer to the first word in a bignum memory block.

 -- Preprocessor Symbol: off_bignum_data
     Number to add to a tagged 'ikptr_t' reference to bignum to obtain a
     pointer to the first byte in the data area of bignum memory block.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: ikuword_t IK_BIGNUM_ALLOC_SIZE (ikuword_t
          NLIMBS)
     Given a number of limbs: evaluate to the aligned size of the memory
     block needed to hold the bignum.

 -- Preprocessor Macro: ikptr_t IKA_BIGNUM_ALLOC (ikpcb_t * PCB,
          ikuword_t NLIMB)
     Given a number of limbs: allocate, using 'ik_safe_alloc()', the
     memory block needed to hold the bignum and return an untagged
     pointer to it.

 -- Preprocessor Macro: ikptr_t IK_COMPOSE_BIGNUM_FIRST_WORD (ikuword_t
          NLIMB, ikptr_t META_SIGN)
     Given a number of limbs and the encoded sign bit: evaluate to the
     first word of a bignum object.  It is equivalent to the following:

          ikptr_t  meta_nlimbs;
          ikptr_t  s_fst;

          meta_nlimbs = (NLIMBS << bignum_nlimbs_shift)
          s_fst       = meta_nlimbs | META_SIGN | bignum_tag;

 -- Preprocessor Macro: ikptr_t IK_POSITIVE_BIGNUM_FIRST_WORD (ikuword_t
          NLIMB)
 -- Preprocessor Macro: ikptr_t IK_NEGATIVE_BIGNUM_FIRST_WORD (ikuword_t
          NLIMB)
     Given a number of limbs evaluate to the corresponding first word of
     bignum representing a positive or negative number.

 -- Preprocessor Macro: ikptr_t IK_BIGNUM_FIRST (ikptr_t BN)
     Given a reference to bignum: evaluate to the location of the first
     word holding meta informations.  Can be used both as operand or
     left-side of assignment:

          ikptr_t  s_bn = the_bignum;
          ikptr_t  s_fst;

          s_fst = IK_BIGNUM_FIRST(s_bn);
          IK_BIGNUM_FIRST(s_bn) = s_fst;

 -- Preprocessor Macro: ikptr_t IK_LIMB (ikptr_t BN, ikuword_t N)
     Given a reference to bignum: evaluate to the location of the N-th
     limb in the data area.  Can be used both as operand or left-side of
     assignment:

          ikptr_t      s_bn = the_bignum;
          mp_limb_t  limb;

          limb = (mp_limb_t)IK_LIMB(s_bn);
          IK_LIMB(s_bn) = (ikptr_t)limb;

 -- Preprocessor Macro: mp_limb_t * IK_BIGNUM_DATA_LIMBP (ikptr_t BN)
 -- Preprocessor Macro: void * IK_BIGNUM_DATA_VOIDP (ikptr_t BN)
     Given a reference to bignum: evaluate to a pointer to the first
     byte in the data area, which is a pointer to the least significant
     limb.

 -- Preprocessor Macro: mp_limb_t IK_BIGNUM_FIRST_LIMB (ikptr_t BN)
     Given a reference to bignum: evaluate to the least significant limb
     in the data area.

 -- Preprocessor Macro: mp_limb_t IK_BIGNUM_LAST_LIMB (ikptr_t BN,
          ikuword_t NLIMBS)
     Given a reference to bignum and its number of limbs: evaluate to
     the most significant limb in the data area.

