This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: srfi cond-expand spec,  Next: srfi cond-expand vicare,  Prev: srfi cond-expand rationale,  Up: srfi cond-expand

2.1.4 Specifications
--------------------

Syntax:

     <command or definition>
         --> <command>
           | <definition>
           | <syntax definition>
           | (begin <command or definition>+)
           | <conditional expansion form>
     <conditional expansion form>
         --> (cond-expand <cond-expand clause>+)
           | (cond-expand <cond-expand clause>*
                          (else <command or definition>*))
     <cond-expand clause>
         --> (<feature requirement> <command or definition>*)
     <feature requirement>
         --> <feature identifier>
           | (and <feature requirement>*)
           | (or <feature requirement>*)
           | (not <feature requirement>)
     <feature identifier>
         --> a symbol which is the name or alias of a SRFI

   The 'cond-expand' form tests for the existence of features at
macro-expansion time.  It either expands into the body of one of its
clauses or signals an error during syntactic processing.  'cond-expand'
expands into the body of the first clause whose feature requirement is
currently satisfied (the else clause, if present, is selected if none of
the previous clauses is selected).

   A feature requirement has an obvious interpretation as a logical
formula, where the '<feature identifier>' variables have meaning TRUE if
the feature corresponding to the feature identifier, as specified in the
SRFI registry, is in effect at the location of the 'cond-expand' form,
and FALSE otherwise.  A feature requirement is satisfied if its formula
is true under this interpretation.

   Examples:

     (cond-expand
       ((and srfi-1 srfi-10)
        (write 1))
       ((or srfi-1 srfi-10)
        (write 2))
       (else))

     (cond-expand
       (command-line
        (define (program-name) (car (argv)))))

   The second example assumes that 'command-line' is an alias for some
feature which gives access to command line arguments.  Note that an
error will be signaled at macro-expansion time if this feature is not
present.


File: vicare-libs.info,  Node: srfi cond-expand vicare,  Prev: srfi cond-expand spec,  Up: srfi cond-expand

2.1.5 Features supported by Vicare
----------------------------------

The following symbolic expressions are recognised by 'cond-expand' as
Vicare available features:

'vicare'
     The Scheme implementation is Vicare.

'posix'
     The program is running under a POSIX system.

'linux'
'solaris'
'darwin'
'bsd'
'freebsd'
'openbsd'
'cygwin'
'gnu'
     The program is running under the named OS.

'srfi-enabled'
     The package was installed along with SRFI libraries.

'ffi-enabled'
     The package was built with Libffi bindings enabled.  This means the
     libraries in the hierarchy '(vicare ffi ---)' should be installed
     and functional.

'iconv-enabled'
     The package was built with Libiconv bindings enabled.  This means
     the libraries in the hierarchy '(vicare iconv ---)' should be
     installed and functional.

'posix-enabled'
     The package was built with POSIX features enabled.  This means the
     libraries in the hierarchy '(vicare posix ---)' should be installed
     and functional.

'glibc-enabled'
     The package was built with GNU C Library features enabled.  This
     means the libraries in the hierarchy '(vicare glibc ---)' should be
     installed and functional.

'linux-enabled'
     The package was built with Linux features enabled.  This means the
     libraries in the hierarchy '(vicare linux ---)' should be installed
     and functional.

'(srfi :0)'
'(srfi :0 cond-expand)'
'srfi-0'
'srfi-0-cond-expand'
     SRFI-0 is available.

'(srfi :1)'
'(srfi :1 lists)'
'srfi-1'
'srfi-1-lists'
     SRFI-1 is available.

'(srfi :2)'
'(srfi :2 and-let*)'
'srfi-2'
'srfi-2-and-let*'
     SRFI-2 is available.

'(srfi :6)'
'(srfi :6 basic-string-ports)'
'srfi-6'
'srfi-6-basic-string-ports'
     SRFI-6 is available.

'(srfi :8)'
'(srfi :8 receive)'
'srfi-8'
'srfi-8-receive'
     SRFI-8 is available.

'(srfi :9)'
'(srfi :9 records)'
'srfi-9'
'srfi-9-records'
     SRFI-9 is available.

'(srfi :11)'
'(srfi :11 let-values)'
'srfi-11'
'srfi-11-let-values'
     SRFI-11 is available.

'(srfi :13)'
'(srfi :13 strings)'
'srfi-13'
'srfi-13-strings'
     SRFI-13 is available.

'(srfi :14)'
'(srfi :14 char-sets)'
'srfi-14'
'srfi-14-char-sets'
     SRFI-14 is available.

'(srfi :16)'
'(srfi :16 case-lambda)'
'srfi-16'
'srfi-16-case-lambda'
     SRFI-16 is available.

'(srfi :19)'
'(srfi :19 time)'
'srfi-19'
'srfi-19-time'
     SRFI-19 is available.

'(srfi :23)'
'(srfi :23 error)'
'srfi-23'
'srfi-23-error'
     SRFI-23 is available.

'(srfi :25)'
'(srfi :25 multi-dimensional-arrays)'
'srfi-25'
'srfi-25-multi-dimensional-arrays'
     SRFI-25 is available.

'(srfi :26)'
'(srfi :26 cut)'
'srfi-26'
'srfi-26-cut'
     SRFI-26 is available.

'(srfi :27)'
'(srfi :27 random-bits)'
'srfi-27'
'srfi-27-random-bits'
     SRFI-27 is available.

     SRFI-29 is available.

'(srfi :31)'
'(srfi :31 rec)'
'srfi-31'
'srfi-31-rec'
     SRFI-31 is available.

'(srfi :37)'
'(srfi :37 args-fold)'
'srfi-37'
'srfi-37-args-fold'
     SRFI-37 is available.

'(srfi :38)'
'(srfi :38 with-shared-structure)'
'srfi-38'
'srfi-38-with-shared-structure'
     SRFI-38 is available.

'(srfi :39)'
'(srfi :39 parameters)'
'srfi-39'
'srfi-39-parameters'
     SRFI-39 is available.

'(srfi :41)'
'(srfi :41 streams)'
'srfi-41'
'srfi-41-streams'
     SRFI-41 is available.

'(srfi :42)'
'(srfi :42 eager-comprehensions)'
'srfi-42'
'srfi-42-eager-comprehensions'
     SRFI-42 is available.

'(srfi :43)'
'(srfi :43 vectors)'
'srfi-43'
'srfi-43-vectors'
     SRFI-43 is available.

'(srfi :45)'
'(srfi :45 lazy)'
'srfi-45'
'srfi-45-lazy'
     SRFI-45 is available.

'(srfi :48)'
'(srfi :48 intermediate-format-strings)'
'srfi-48'
'srfi-48-intermediate-format-strings'
     SRFI-48 is available.

'(srfi :61)'
'(srfi :61 cond)'
'srfi-61'
'srfi-61-cond'
     SRFI-61 is available.

'(srfi :64)'
'(srfi :64 testing)'
'srfi-64'
'srfi-64-testing'
     SRFI-64 is available.

'(srfi :67)'
'(srfi :67 compare-procedures)'
'srfi-67'
'srfi-67-compare-procedures'
     SRFI-67 is available.

'(srfi :69)'
'(srfi :69 basic-hash-tables)'
'srfi-69'
'srfi-69-basic-hash-tables'
     SRFI-69 is available.

'(srfi :78)'
'(srfi :78 lightweight-testing)'
'srfi-78'
'srfi-78-lightweight-testing'
     SRFI-78 is available.

'(srfi :98)'
'(srfi :98 os-environment-variables)'
'srfi-98'
'srfi-98-os-environment-variables'
     SRFI-98 is available.

'(srfi :99)'
'(srfi :99 records)'
'srfi-99'
'srfi-99-records'
     SRFI-99 is available.

'(srfi :101)'
'(srfi :101 random-access-lists)'
'srfi-101'
'srfi-101-random-access-lists'
     SRFI-101 is available.

'(srfi :106)'
'(srfi :106 socket)'
'srfi-106'
'srfi-106-socket'
     SRFI-106 is available.

'(srfi :111)'
'(srfi :111 boxes)'
'srfi-111'
'srfi-111-boxes'
     SRFI-111 is available.

'(srfi :112)'
'(srfi :112 environment-inquiry)'
'srfi-112'
'srfi-112-environment-inquiry'
     SRFI-112 is available.

'(srfi :113)'
'(srfi :113 sets-and-bags)'
'srfi-113'
'srfi-113-sets-and-bags'
     SRFI-113 is available.

'(srfi :114)'
'(srfi :114 comparators)'
'srfi-114'
'srfi-114-comparators'
     SRFI-114 is available.

'(srfi :115)'
'(srfi :115 regexps)'
'srfi-115'
'srfi-115-regexps'
     SRFI-115 is available.

'(srfi :116)'
'(srfi :116 ilists)'
'srfi-116'
'srfi-116-ilists'
     SRFI-116 is available.


File: vicare-libs.info,  Node: srfi list,  Next: srfi and-let-star,  Prev: srfi cond-expand,  Up: srfi

2.2 SRFI-1 list library
=======================

The library '(srfi :1)' is by Olin Shivers <shivers@ai.mit.edu> as the
reference implementation for SRFI-1; see:

             <http://srfi.schemers.org/srfi-1/srfi-1.html>

for more details.

* Menu:

* srfi list license::           List library document license.
* srfi list abstract::          Abstract.
* srfi list rationale::         Rationale.
* srfi list discussion::        Discussion.
* srfi list spec::              Specifications.
* srfi list ack::               Acknowledgements.
* srfi list references::        References.


File: vicare-libs.info,  Node: srfi list license,  Next: srfi list abstract,  Up: srfi list

2.2.1 List library document license
-----------------------------------

Certain portions of this document---the specific, marked segments of
text describing the R5RS procedures---were adapted with permission from
the R5RS report.

   All other text is copyright (C) 1998, 1999 Olin Shivers.  All Rights
Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi list abstract,  Next: srfi list rationale,  Prev: srfi list license,  Up: srfi list

2.2.2 Abstract
--------------

R5RS Scheme has an impoverished set of list-processing utilities, which
is a problem for authors of portable code.  This SRFI proposes a
coherent and comprehensive set of list-processing procedures; it is
accompanied by a reference implementation of the spec.  The reference
implementation is:

   * portable;

   * efficient;

   * completely open, public-domain source.


File: vicare-libs.info,  Node: srfi list rationale,  Next: srfi list discussion,  Prev: srfi list abstract,  Up: srfi list

2.2.3 Rationale
---------------

The set of basic list and pair operations provided by R4RS/R5RS Scheme
is far from satisfactory.  Because this set is so small and basic, most
implementations provide additional utilities, such as a list-filtering
function, or a "left fold" operator, and so forth.  But, of course, this
introduces incompatibilities---different Scheme implementations provide
different sets of procedures.

   I have designed a full-featured library of procedures for list
processing.  While putting this library together, I checked as many
Schemes as I could get my hands on.  (I have a fair amount of experience
with several of these already.)  I missed Chez (no on-line manual that I
can find) but I hit most of the other big, full-featured Schemes.  The
complete list of list-processing systems I checked is:

     R4RS/R5RS Scheme
     MIT Scheme
     Gambit
     RScheme
     MzScheme
     slib
     Common Lisp
     Bigloo
     guile
     T
     APL and the SML standard basis

   As a result, the library I am proposing is fairly rich.

   Following this initial design phase, this library went through
several months of discussion on the SRFI mailing lists, and was altered
in light of the ideas and suggestions put forth during this discussion.

   In parallel with designing this API, I have also written a reference
implementation.  I have placed this source on the Net with an
unencumbered, "open" copyright.  A few notes about the reference
implementation:

   * Although I got procedure names and specs from many Schemes, I wrote
     this code myself.  Thus, there are no entanglements.  Any Scheme
     implementor can pick this library up with no worries about
     copyright problems, both commercial and non-commercial systems.

   * The code is written for portability and should be trivial to port
     to any Scheme.  It has only four deviations from R4RS, clearly
     discussed in the comments:

        * use of an error procedure;

        * use of the R5RS values and a simple receive macro for
          producing and consuming multiple return values;

        * use of simple ':optional' and 'let-optionals' macros for
          optional argument parsing and defaulting;

        * use of a simple 'check-arg' procedure for argument checking.

   * It is written for clarity and well-commented.  The current source
     is 768 lines of source code and 826 lines of comments and white
     space.

   * It is written for efficiency.  Fast paths are provided for common
     cases.  Side-effecting procedures such as 'filter!' avoid
     unnecessary, redundant 'set-cdr!' calls which would thrash a
     generational garbage-collection's write barrier and the store
     buffers of fast processors.  Functions reuse longest common tails
     from input parameters to construct their results where possible.
     Constant-space iterations are used in preference to recursions;
     local recursions are used in preference to consing temporary
     intermediate data structures.

   This is not to say that the implementation can't be tuned up for a
specific Scheme implementation.  There are notes in comments addressing
ways implementors can tune the reference implementation for performance.

   In short, I've written the reference implementation to make it as
painless as possible for an implementor, or a regular programmer, to
adopt this library and get good results with it.


File: vicare-libs.info,  Node: srfi list discussion,  Next: srfi list spec,  Prev: srfi list rationale,  Up: srfi list

2.2.4 Discussion
----------------

* Menu:

* srfi list disc general::       General discussion.
* srfi list disc linear update:: "Linear update" procedures.
* srfi list disc improper::      Improper lists.
* srfi list disc errors::        Errors.
* srfi list disc not included::  Not included in this library.


File: vicare-libs.info,  Node: srfi list disc general,  Next: srfi list disc linear update,  Up: srfi list discussion

2.2.4.1 General discussion
..........................

A set of general criteria guided the design of this library.

   I don't require "destructive" (what I call "linear update")
procedures to alter and recycle cons cells from the argument lists.
They are allowed to, but not required to.  (And the reference
implementations I have written do recycle the argument lists.)

   List-filtering procedures such as 'filter' or 'delete' do not
disorder lists.  Elements appear in the answer list in the same order as
they appear in the argument list.  This constrains implementation, but
seems like a desirable feature, since in many uses of lists, order
matters.  (In particular, disordering an alist is definitely a bad
idea.)

   Contrariwise, although the reference implementations of the
list-filtering procedures share longest common tails between argument
and answer lists, it not is part of the spec.

   Because lists are an inherently sequential data structure (unlike,
say, vectors), list-inspection functions such as 'find', 'find-tail',
'for-each', any and every commit to a left-to-right traversal order of
their argument list.

   However, constructor functions, such as 'list-tabulate' and the
mapping procedures ('append-map', 'append-map!', 'map!',
'pair-for-each', 'filter-map', 'map-in-order'), do not specify the
dynamic order in which their procedural argument is applied to its
various values.

   Predicates return useful true values wherever possible.  Thus any
must return the true value produced by its predicate, and every returns
the final true value produced by applying its predicate argument to the
last element of its argument list.

   Functionality is provided both in pure and linear-update (potentially
destructive) forms wherever this makes sense.

   No special status accorded Scheme's built-in equality functions.  Any
functionality provided in terms of 'eq?', 'eqv?', 'equal?' is also
available using a client-provided equality function.

   Proper design counts for more than backwards compatibility, but I
have tried, ceteris paribus, to be as backwards-compatible as possible
with existing list-processing libraries, in order to facilitate porting
old code to run as a client of the procedures in this library.  Name
choices and semantics are, for the most part, in agreement with existing
practice in many current Scheme systems.  I have indicated some
incompatibilities in the following text.

   These procedures are not "sequence generic"---i.e.  procedures that
operate on either vectors and lists.  They are list-specific.  I prefer
to keep the library simple and focused.

   I have named these procedures without a qualifying initial 'list-'
lexeme, which is in keeping with the existing set of list-processing
utilities in Scheme.  I follow the general Scheme convention
('vector-length', 'string-ref') of placing the type-name before the
action when naming procedures---so we have 'list-copy' and
'pair-for-each' rather than the perhaps more fluid, but less consistent,
'copy-list' or 'for-each-pair'.

   I have generally followed a regular and consistent naming scheme,
composing procedure names from a set of basic lexemes.


File: vicare-libs.info,  Node: srfi list disc linear update,  Next: srfi list disc improper,  Prev: srfi list disc general,  Up: srfi list discussion

2.2.4.2 "Linear update" procedures
..................................

Many procedures in this library have "pure" and "linear update"
variants.  A "pure" procedure has no side-effects, and in particular
does not alter its arguments in any way.  A "linear update" procedure is
allowed, but not required, to side-effect its arguments in order to
construct its result.  "Linear update" procedures are typically given
names ending with an exclamation point.

   So, for example, '(append! list1 list2)' is allowed to construct its
result by simply using 'set-cdr!' to set the cdr of the last pair of
LIST1 to point to LIST2, and then returning LIST1 (unless LIST1 is the
empty list, in which case it would simply return LIST2).  However,
'append!' may also elect to perform a pure append operation, this is a
legal definition of append!:

     (define append! append)

   This is why we do not call these procedures "destructive", because
they aren't required to be destructive.  They are _potentially_
destructive.

   What this means is that you may only apply linear-update procedures
to values that you know are "dead", values that will never be used again
in your program.  This must be so, since you can't rely on the value
passed to a linear-update procedure after that procedure has been
called.  It might be unchanged; it might be altered.

   The "linear" in "linear update" doesn't mean "linear time" or "linear
space" or any sort of multiple-of-n kind of meaning.  It's a fancy term
that type theorists and pure functional programmers use to describe
systems where you are only allowed to have exactly one reference to each
variable.  This provides a guarantee that the value bound to a variable
is bound to no other variable.  So when you use a variable in a variable
reference, you "use it up".  Knowing that no one else has a pointer to
that value means the a system primitive is free to side-effect its
arguments to produce what is, observationally, a pure-functional result.

   In the context of this library, "linear update" means you, the
programmer, know there are no other live references to the value passed
to the procedure; after passing the value to one of these procedures,
the value of the old pointer is indeterminate.  Basically, you are
licensing the Scheme implementation to alter the data structure if it
feels like it; you have declared you don't care either way.

   You get no help from Scheme in checking that the values you claim are
"linear" really are.  So you better get it right.  Or play it safe and
use the non-'!' procedures; it doesn't do any good to compute quickly if
you get the wrong answer.

   Why go to all this trouble to define the notion of "linear update"
and use it in a procedure spec, instead of the more common notion of a
"destructive" operation?

   First, note that destructive list-processing procedures are almost
always used in a linear-update fashion.  This is in part required by the
special case of operating upon the empty list, which can't be
side-effected.  This means that destructive operators are not pure
side-effects, they have to return a result.

   Second, note that code written using linear-update operators can be
trivially ported to a pure, functional subset of Scheme by simply
providing pure implementations of the linear-update operators.

   Finally, requiring destructive side-effects ruins opportunities to
parallelise these operations, and the places where one has taken the
trouble to spell out destructive operations are usually exactly the code
one would want a parallelising compiler to parallelise: the
efficiency-critical kernels of the algorithm.

   Linear-update operations are easily parallelised.  Going with a
linear-update spec doesn't close off these valuable alternative
implementation techniques.  This list library is intended as a set of
low-level, basic operators, so we don't want to exclude these possible
implementations.

   The linear-update procedures in this library are:

     alist-delete!           append!
     append-map!             append-reverse!
     break!                  concatenate!
     delete!                 delete-duplicates!
     drop-right!             filter!
     lset-adjoin!            lset-diff+intersection!
     lset-difference!        lset-xor!
     lset-intersection!      lset-union!
     map!                    partition!
     remove!                 reverse!
     span!                   split-at!
     take!                   take-while!


File: vicare-libs.info,  Node: srfi list disc improper,  Next: srfi list disc errors,  Prev: srfi list disc linear update,  Up: srfi list discussion

2.2.4.3 Improper Lists
......................

Scheme does not properly have a list type, just as the C language does
not have a string type.  Rather, Scheme has a binary-tuple type, from
which one can build binary trees.  There is an interpretation of Scheme
values that allows one to treat these trees as lists.  Further
complications ensue from the fact that Scheme allows side-effects to
these tuples, raising the possibility of lists of unbounded length, and
trees of unbounded depth (that is, circular data structures).

   However, there is a simple view of the world of Scheme values that
considers every value to be a list of some sort.  That is, every value
is either:

   * a "proper list" (a finite, nil-terminated list) such as:

          (a b c)
          ()
          (32)

   * a "dotted list" (a finite, non-nil terminated list) such as:

          (a b c . d)
          (x . y)
          42
          george

   * or a "circular list" (an infinite, unterminated list).

   Note that the zero-length dotted lists are simply all the non-null,
non-pair values.

   This view is captured by the predicates 'proper-list?',
'dotted-list?', and 'circular-list?'.  This list library users should
note that dotted lists are not commonly used, and are considered by many
Scheme programmers to be an ugly artifact of Scheme's lack of a true
list type.  However, dotted lists do play a noticeable role in the
syntax of Scheme, in the "rest" parameters used by n-ary lambdas:

     (lambda (x y . rest) ...)

   Dotted lists are not fully supported by this list library.  Most
procedures are defined only on proper lists, that is: finite,
nil-terminated lists.  The procedures that will also handle circular or
dotted lists are specifically marked.  While this design decision
restricts the domain of possible arguments one can pass to these
procedures, it has the benefit of allowing the procedures to catch the
error cases where programmers inadvertently pass scalar values to a list
procedure by accident, e.g., by switching the arguments to a procedure
call.


File: vicare-libs.info,  Node: srfi list disc errors,  Next: srfi list disc not included,  Prev: srfi list disc improper,  Up: srfi list discussion

2.2.4.4 Errors
..............

Note that statements of the form "it is an error" merely mean "don't do
that".  They are no a guarantees that a conforming implementation will
"catch" such improper use by, for example, raising some kind of
exception.  Regrettably, R5RS Scheme requires no firmer guarantee even
for basic operators such as 'car' and 'cdr', so there's little point in
requiring these procedures to do more.  Here is the relevant section of
the R5RS:

     When speaking of an error situation, this report uses the phrase
     "an error is signalled" to indicate that implementations must
     detect and report the error.  If such wording does not appear in
     the discussion of an error, then implementations are not required
     to detect or report the error, though they are encouraged to do so.
     An error situation that implementations are not required to detect
     is usually referred to simply as "an error".

     For example, it is an error for a procedure to be passed an
     argument that the procedure is not explicitly specified to handle,
     even though such domain errors are seldom mentioned in this report.
     Implementations may extend a procedure's domain of definition to
     include such arguments.


File: vicare-libs.info,  Node: srfi list disc not included,  Prev: srfi list disc errors,  Up: srfi list discussion

2.2.4.5 Not included in this library
....................................

The following items are not in this library:

   * sort routines;

   * destructuring/pattern-matching macro;

   * tree-processing routines.

they should have their own SRFI specs.


File: vicare-libs.info,  Node: srfi list spec,  Next: srfi list ack,  Prev: srfi list discussion,  Up: srfi list

2.2.5 Specifications
--------------------

* Menu:

* srfi list spec intro::        Introduction.
* srfi list spec cons::         Constructors.
* srfi list spec pred::         Predicates.
* srfi list spec select::       Selectors.
* srfi list spec misc::         Miscellaneous: length, append,
                                concatenate, reverse, zip and
                                count.
* srfi list spec fold::         Fold, unfold and map.
* srfi list spec filter::       Filtering and partitioning.
* srfi list spec search::       Searching.
* srfi list spec delete::       Deletion.
* srfi list spec alist::        Association lists.
* srfi list spec set::          Set operations on lists.
* srfi list spec side::         Primitive side-effects.


File: vicare-libs.info,  Node: srfi list spec intro,  Next: srfi list spec cons,  Up: srfi list spec

2.2.5.1 Introduction
....................

In a Scheme system that has a module or package system, these procedures
should be contained in a module named 'list-lib'.  The templates given
below obey the following conventions for procedure formals:

'list'
     a proper (finite, nil-terminated) list;

'clist'
     a proper or circular list;

'flist'
     a finite (proper or dotted) list;

'pair'
     a pair;

'x, y, d, a'
     any value;

'object, value'
     any value;

'n, i'
     a natural number (an integer >= 0);

'proc'
     a procedure;

'pred'
     a procedure whose return value is treated as a boolean;

'='
     a boolean procedure taking two arguments.

   It is an error to pass a circular or dotted list to a procedure not
defined to accept such an argument.


File: vicare-libs.info,  Node: srfi list spec cons,  Next: srfi list spec pred,  Prev: srfi list spec intro,  Up: srfi list spec

2.2.5.2 Constructors
....................

 -- Function: cons A D
     R5RS The primitive constructor.  Return a newly allocated pair
     whose car is A and whose cdr is D.  The pair is guaranteed to be
     different (in the sense of 'eqv?') from every existing object.

          (cons 'a '())        => (a)
          (cons '(a) '(b c d)) => ((a) b c d)
          (cons "a" '(b c))    => ("a" b c)
          (cons 'a 3)          => (a . 3)
          (cons '(a b) 'c)     => ((a b) . c)

 -- Function: list OBJECT ...
     R5RS Return a newly allocated list of its arguments.

          (list 'a (+ 3 4) 'c) =>  (a 7 c)
          (list)               =>  ()

 -- Function: xcons D A
     Defined as '(lambda (d a) (cons a d))'.  Of utility only as a value
     to be conveniently passed to higher-order procedures.

          (xcons '(b c) 'a) => (a b c)

     The name stands for "eXchanged CONS".

 -- Function: cons* ELT1 ELT2 ...
     Like 'list', but the last argument provides the tail of the
     constructed list, returning:

          (cons elt1 (cons elt2 (cons ... eltn)))

     This function is called 'list*' in Common Lisp and about half of
     the Schemes that provide it, and 'cons*' in the other half.

          (cons* 1 2 3 4) => (1 2 3 . 4)
          (cons* 1) => 1

 -- Function: make-list N [FILL]
     Return an N-element list, whose elements are all the value FILL.
     If the fill argument is not given, the elements of the list may be
     arbitrary values.

          (make-list 4 'c) => (c c c c)

 -- Function: list-tabulate N INIT-PROC
     Return an N-element list.  Element I of the list, where '0 <= i <
     n', is produced by '(init-proc i)'.  No guarantee is made about the
     dynamic order in which INIT-PROC is applied to these indices.

          (list-tabulate 4 values) => (0 1 2 3)

 -- Function: list-copy FLIST
     Copy the spine of the argument.

 -- Function: circular-list ELT1 ELT2 ...
     Construct a circular list of the elements.

          (circular-list 'z 'q) => (z q z q z q ...)

 -- Function: iota COUNT [START STEP]
     Return a list containing the elements:

          (start start+step ... start+(count-1)*step)

     The START and STEP parameters default to '0' and '1', respectively.
     This procedure takes its name from the APL primitive.

          (iota 5) => (0 1 2 3 4)
          (iota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)


File: vicare-libs.info,  Node: srfi list spec pred,  Next: srfi list spec select,  Prev: srfi list spec cons,  Up: srfi list spec

2.2.5.3 Predicates
..................

Note: the predicates 'proper-list?', 'circular-list?', and
'dotted-list?' partition the entire universe of Scheme values.

 -- Function: proper-list? X
     Return true if, and only if, X is a proper list: a finite,
     nil-terminated list.  More carefully: The empty list is a proper
     list.  A pair whose cdr is a proper list is also a proper list:

          <proper-list> ::= ()                            (Empty proper list)
                        |   (cons <x> <proper-list>)      (Proper-list pair)

     Note that this definition rules out circular lists.  This function
     is required to detect this case and return false.

     Nil-terminated lists are called "proper" lists by R5RS and Common
     Lisp.  The opposite of proper is improper.

     R5RS binds this function to the variable 'list?'.

          (not (proper-list? x)) = (or (dotted-list? x) (circular-list? x))

 -- Function: circular-list? X
     True if X is a circular list.  A circular list is a value such that
     for every 'n >= 0', 'cdrn(x)' is a pair.

     Terminology: The opposite of circular is finite.

          (not (circular-list? x)) = (or (proper-list? x) (dotted-list? x))

 -- Function: dotted-list? X
     True if X is a finite, non-nil-terminated list.  That is, there
     exists an 'n >= 0' such that 'cdrn(x)' is neither a pair nor '()'.
     This includes non-pair, non-'()' values (e.g.  symbols, numbers),
     which are considered to be dotted lists of length 0.

          (not (dotted-list? x)) = (or (proper-list? x) (circular-list? x))

 -- Function: pair? OBJECT
     R5RS Return '#t' if object is a pair; otherwise '#f'.

          (pair? '(a . b)) =>  #t
          (pair? '(a b c)) =>  #t
          (pair? '())      =>  #f
          (pair? '#(a b))  =>  #f
          (pair? 7)        =>  #f
          (pair? 'a)       =>  #f

 -- Function: null? OBJECT
     R5RS Return '#t't if object is the empty list; otherwise '#f'.

 -- Function: null-list? list
     LIST is a proper or circular list.  This procedure returns true if
     the argument is the empty list '()', and '#f' otherwise.  It is an
     error to pass this procedure a value which is not a proper or
     circular list.  This procedure is recommended as the termination
     condition for list-processing procedures that are not defined on
     dotted lists.

 -- Function: not-pair? X
     Defined as: '(lambda (x) (not (pair? x)))'.  Provided as a
     procedure as it can be useful as the termination condition for
     list-processing procedures that wish to handle all finite lists,
     both proper and dotted.

 -- Function: list= ELT= LIST1 ...
     Determines list equality, given an element-equality procedure ELT=.
     Proper list AL equals proper list BL if they are of the same
     length, and their corresponding elements are equal, as determined
     by ELT=.  If the element-comparison procedure's first argument is
     from LISTI, then its second argument is from LISTI+1, i.e.  it is
     always called as '(elt= a b)' for A an element of list AL, and B an
     element of list BL.

     In the n-ary case, every LISTI is compared to LISTI+1 (as opposed,
     for example, to comparing LIST1 to every LISTI, for 'i>1').  If
     there are no list arguments at all, 'list=' simply returns true.

     It is an error to apply 'list=' to anything except proper lists.
     While implementations may choose to extend it to circular lists,
     note that it cannot reasonably be extended to dotted lists, as it
     provides no way to specify an equality procedure for comparing the
     list terminators.

     Note that the dynamic order in which the ELT= procedure is applied
     to pairs of elements is not specified.  For example, if 'list=' is
     applied to three lists, AL, BL, and CL, it may first completely
     compare AL to BL, then compare BL to CL, or it may compare the
     first elements of AL and BL, then the first elements of BL and CL,
     then the second elements of AL and BL, and so forth.

     The equality procedure must be consistent with 'eq?'.  That is, it
     must be the case that:

          (eq? x y) => (elt= x y)

     Note that this implies that two lists which are 'eq?' are always
     'list=', as well; implementations may exploit this fact to
     "short-cut" the element-by-element comparisons.

          (list= eq?) => #t       ; Trivial cases
          (list= eq? '(a)) => #t


File: vicare-libs.info,  Node: srfi list spec select,  Next: srfi list spec misc,  Prev: srfi list spec pred,  Up: srfi list spec

2.2.5.4 Selectors
.................

 -- Function: car PAIR
 -- Function: cdr PAIR
     R5RS These functions return the contents of the car and cdr field
     of their argument, respectively.  Note that it is an error to apply
     them to the empty list.

          (car '(a b c))     =>  a       | (cdr '(a b c))     =>  (b c)
          (car '((a) b c d)) =>  (a)     | (cdr '((a) b c d)) =>  (b c d)
          (car '(1 . 2))     =>  1       | (cdr '(1 . 2))     =>  2
          (car '())          =>  *error* | (cdr '())          =>  *error*

 -- Function: caar PAIR
 -- Function: cadr PAIR
 -- Function: c...r PAIR
 -- Function: cdddar PAIR
 -- Function: cddddr PAIR
     R5RS These procedures are compositions of 'car' and 'cdr', where
     for example 'caddr' could be defined by:

          (define caddr (lambda (x) (car (cdr (cdr x)))))

     Arbitrary compositions, up to four deep, are provided.  There are
     twenty-eight of these procedures in all.

 -- Function: list-ref CLIST I
     R5RS Return the I-th element of clist.  This is the same as the car
     of '(drop clist i)'.  It is an error if 'i >= n', where N is the
     length of clist.

          (list-ref '(a b c d) 2) => c

 -- Function: first pair -> object
 -- Function: second PAIR
 -- Function: third PAIR
 -- Function: fourth PAIR
 -- Function: fifth PAIR
 -- Function: sixth PAIR
 -- Function: seventh PAIR
 -- Function: eighth PAIR
 -- Function: ninth PAIR
 -- Function: tenth PAIR
     Synonyms for 'car', 'cadr', 'caddr', ...

          (third '(a b c d e)) => c

 -- Function: car+cdr PAIR
     The fundamental pair deconstructor:

          (lambda (p) (values (car p) (cdr p)))

     This can, of course, be implemented more efficiently by a compiler.

 -- Function: take X I
 -- Function: drop X I
     'take' returns the first I elements of list X.  'drop' returns all
     but the first I elements of list X.

          (take '(a b c d e)  2) => (a b)
          (drop '(a b c d e)  2) => (c d e)

     X may be any value: a proper, circular, or dotted list:

          (take '(1 2 3 . d) 2) => (1 2)
          (drop '(1 2 3 . d) 2) => (3 . d)
          (take '(1 2 3 . d) 3) => (1 2 3)
          (drop '(1 2 3 . d) 3) => d

     For a legal I, 'take' and 'drop' partition the list in a manner
     which can be inverted with append:

          (append (take x i) (drop x i)) = x

     'drop' is exactly equivalent to performing I 'cdr' operations on X;
     the returned value shares a common tail with X.

     If the argument is a list of non-zero length, 'take' is guaranteed
     to return a freshly-allocated list, even in the case where the
     entire list is taken, e.g.  '(take lis (length lis))'.

 -- Function: take-right FLIST I
 -- Function: drop-right FLIST I
     'take-right' returns the last I elements of FLIST.  'drop-right'
     returns all but the last I elements of FLIST.

          (take-right '(a b c d e) 2) => (d e)
          (drop-right '(a b c d e) 2) => (a b c)

     The returned list may share a common tail with the argument list.

     FLIST may be any finite list, either proper or dotted:

          (take-right '(1 2 3 . d) 2) => (2 3 . d)
          (drop-right '(1 2 3 . d) 2) => (1)
          (take-right '(1 2 3 . d) 0) => d
          (drop-right '(1 2 3 . d) 0) => (1 2 3)

     For a legal I, 'take-right' and DROP-RIGHT partition the list in a
     manner which can be inverted with append:

          (append (take flist i) (drop flist i)) = flist

     The return value of 'take-right' is guaranteed to share a common
     tail with FLIST.

     If the argument is a list of non-zero length, 'drop-right' is
     guaranteed to return a freshly-allocated list, even in the case
     where nothing is dropped, e.g.  '(drop-right lis 0)'.

 -- Function: take! X I
 -- Function: drop-right! FLIST I
     'take!' and 'drop-right!' are linear-update variants of 'take' and
     'drop-right': the procedure is allowed, but not required, to alter
     the argument list to produce the result.

     If X is circular, 'take!' may return a shorter-than-expected list:

          (take! (circular-list 1 3 5) 8) => (1 3)
          (take! (circular-list 1 3 5) 8) => (1 3 5 1 3 5 1 3)

 -- Function: split-at X I
 -- Function: split-at! X I
     'split-at' splits the list X at index I, returning a list of the
     first I elements, and the remaining tail.  It is equivalent to:

          (values (take x i) (drop x i))

     'split-at!' is the linear-update variant.  It is allowed, but not
     required, to alter the argument list to produce the result.

          (split-at '(a b c d e f g h) 3)
          => (a b c)
             (d e f g h)

 -- Function: last PAIR
 -- Function: last-pair PAIR
     'last' returns the last element of the non-empty, finite list PAIR.
     'last-pair' returns the last pair in the non-empty, finite list
     PAIR.

          (last '(a b c)) => c
          (last-pair '(a b c)) => (c)


File: vicare-libs.info,  Node: srfi list spec misc,  Next: srfi list spec fold,  Prev: srfi list spec select,  Up: srfi list spec

2.2.5.5 Miscellaneous: length, append, concatenate, reverse, zip and count
..........................................................................

 -- Function: length LIST
 -- Function: length+ CLIST
     Both 'length' and 'length+' return the length of the argument.  It
     is an error to pass a value to 'length' which is not a proper list
     (finite and nil-terminated).  In particular, this means an
     implementation may diverge or signal an error when 'length' is
     applied to a circular list.

     'length+', on the other hand, returns '#f' when applied to a
     circular list.

     The length of a proper list is a non-negative integer N such that
     'cdr' applied N times to the list produces the empty list.

 -- Function: append LIST1 ...
 -- Function: append! LIST1 ...
     R5RS 'append' returns a list consisting of the elements of LIST1
     followed by the elements of the other list parameters.

          (append '(x) '(y))        =>  (x y)
          (append '(a) '(b c d))    =>  (a b c d)
          (append '(a (b)) '((c)))  =>  (a (b) (c))

     The resulting list is always newly allocated, except that it shares
     structure with the final LISTI argument.  This last argument may be
     any value at all; an improper list results if it is not a proper
     list.  All other arguments must be proper lists.

          (append '(a b) '(c . d))  =>  (a b c . d)
          (append '() 'a)           =>  a
          (append '(x y))           =>  (x y)
          (append)                  =>  ()

     'append!' is the linear-update variant of 'append'; it is allowed,
     but not required, to alter cons cells in the argument lists to
     construct the result list.  The last argument is never altered; the
     result list shares structure with this parameter.

 -- Function: concatenate LIST-OF-LISTS
 -- Function: concatenate! LIST-OF-LISTS
     These functions append the elements of their argument together.
     That is, 'concatenate' returns:

          (apply append list-of-lists)

     or, equivalently:

          (reduce-right append '() list-of-lists)

     'concatenate!' is the linear-update variant, defined in terms of
     'append!' instead of 'append'.

     Note that some Scheme implementations do not support passing more
     than a certain number (e.g.  64) of arguments to an n-ary
     procedure.  In these implementations, the '(apply append ...)'
     idiom would fail when applied to long lists, but concatenate would
     continue to function properly.

     As with 'append' and 'append!', the last element of the input list
     may be any value at all.

 -- Function: reverse LIST
 -- Function: reverse! LIST
     R5RS 'reverse' returns a newly allocated list consisting of the
     elements of LIST in reverse order.

          (reverse '(a b c))              =>  (c b a)
          (reverse '(a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)

     'reverse!' is the linear-update variant of 'reverse'.  It is
     permitted, but not required, to alter the argument's cons cells to
     produce the reversed list.

 -- Function: append-reverse REV-HEAD TAIL
 -- Function: append-reverse! REV-HEAD TAIL
     'append-reverse' returns:

          (append (reverse rev-head) tail)

     It is provided because it is a common operation, a common
     list-processing style calls for this exact operation to transfer
     values accumulated in reverse order onto the front of another list,
     and because the implementation is significantly more efficient than
     the simple composition it replaces.

          But note that this pattern of iterative computation followed
          by a 'reverse' can frequently be rewritten as a recursion,
          dispensing with the 'reverse' and 'append-reverse' steps, and
          shifting temporary, intermediate storage from the heap to the
          stack, which is typically a win for reasons of cache locality
          and eager storage reclamation.

     'append-reverse!' is just the linear-update variant; it is allowed,
     but not required, to alter REV-HEAD's cons cells to construct the
     result.

 -- Function: zip CLIST1 CLIST2 ...
     Defined as:

          (lambda lists (apply map list lists))

     If 'zip' is passed N lists, it returns a list as long as the
     shortest of these lists, each element of which is an N-element list
     comprised of the corresponding elements from the parameter lists.

          (zip '(one two three)
               '(1 2 3)
               '(odd even odd even odd even odd even))
            => ((one 1 odd) (two 2 even) (three 3 odd))

          (zip '(1 2 3))
            => ((1) (2) (3))

     At least one of the argument lists must be finite:

          (zip '(3 1 4 1) (circular-list #f #t))
            => ((3 #f) (1 #t) (4 #f) (1 #t))

 -- Function: unzip1 LIST
 -- Function: unzip2 LIST
 -- Function: unzip3 LIST
 -- Function: unzip4 LIST
 -- Function: unzip5 LIST
     'unzip1' takes a list of lists, where every list must contain at
     least one element, and returns a list containing the initial
     element of each such list.  That is, it returns '(map car lists)'.

     'unzip2' takes a list of lists, where every list must contain at
     least two elements, and returns two values: a list of the first
     elements, and a list of the second elements.

     'unzip3' does the same for the first three elements of the lists,
     and so forth.

          (unzip2 '((1 one) (2 two) (3 three)))
            => (1 2 3)
               (one two three)

 -- Function: count PRED CLIST1 ...
     PRED is a procedure taking as many arguments as there are lists and
     returning a single value.  It is applied element-wise to the
     elements of the lists, and a count is tallied of the number of
     elements that produce a true value.  This count is returned.

     'count' is "iterative" in that it is guaranteed to apply PRED to
     the list elements in a left-to-right order.  The counting stops
     when the shortest list expires.

          (count even? '(3 1 4 1 5 9 2 5 6))                => 3
          (count <     '(1 2 4 8) '(2 4 6 8 10 12 14 16))   => 3

     At least one of the argument lists must be finite:

          (count < '(3 1 4 1) (circular-list 1 10)) => 2


File: vicare-libs.info,  Node: srfi list spec fold,  Next: srfi list spec filter,  Prev: srfi list spec misc,  Up: srfi list spec

2.2.5.6 Fold, unfold and map
............................

 -- Function: fold KONS KNIL CLIST1 CLIST2 ...
     The fundamental list iterator.  First, consider the single
     list-parameter case: if 'clist1 = (e1 e2 ... en)', then this
     procedure returns:

          (kons en ... (kons e2 (kons e1 knil)) ... )

     that is, it obeys the (tail) recursion:

          (fold kons knil lis) = (fold kons (kons (car lis) knil) (cdr lis))
          (fold kons knil '()) = knil

     Examples:

          (fold + 0 lis)			; Add up the elements of LIS.

          (fold cons '() lis)		; Reverse LIS.

          (fold cons tail rev-head)	; See APPEND-REVERSE.

          ;; How many symbols in LIS?
          (fold (lambda (x count) (if (symbol? x) (+ count 1) count))
                0
                lis)

          ;; Length of the longest string in LIS:
          (fold (lambda (s max-len) (max max-len (string-length s)))
                0
                lis)

     If N list arguments are provided, then the KONS function must take
     N+1 parameters: one element from each list, and the "seed" or fold
     state, which is initially KNIL.  The fold operation terminates when
     the shortest list runs out of values:

          (fold cons* '() '(a b c) '(1 2 3 4 5)) => (c 3 b 2 a 1)

     At least one of the list arguments must be finite.

 -- Function: fold-right KONS KNIL CLIST1 CLIST2 ...
     The fundamental list recursion operator.  First, consider the
     single list-parameter case.  If 'clist1 = (e1 e2 ... en)', then
     this procedure returns:

          (kons e1 (kons e2 ... (kons en knil)))

     that is, it obeys the recursion:

          (fold-right kons knil lis) = (kons (car lis) (fold-right kons knil (cdr lis)))
          (fold-right kons knil '()) = knil

     Examples:

          (fold-right cons '() lis)		; Copy LIS.

          ;; Filter the even numbers out of LIS.
          (fold-right (lambda (x l) (if (even? x) (cons x l) l)) '() lis))

     If N list arguments are provided, then the KONS function must take
     N+1 parameters: one element from each list, and the "seed" or fold
     state, which is initially KNIL.  The fold operation terminates when
     the shortest list runs out of values:

          (fold-right cons* '() '(a b c) '(1 2 3 4 5)) => (a 1 b 2 c 3)

     At least one of the list arguments must be finite.

 -- Function: pair-fold KONS KNIL CLIST1 CLIST2 ...
     Analogous to 'fold', but KONS is applied to successive sublists of
     the lists, rather than successive elements; that is, KONS is
     applied to the pairs making up the lists, giving this (tail)
     recursion:

          (pair-fold kons knil lis) = (let ((tail (cdr lis)))
                                        (pair-fold kons (kons lis knil) tail))
          (pair-fold kons knil '()) = knil

     For finite lists, the KONS function may reliably apply 'set-cdr!'
     to the pairs it is given without altering the sequence of
     execution.

     Example:

          ;;; Destructively reverse a list.
          (pair-fold (lambda (pair tail) (set-cdr! pair tail) pair) '() lis))

     At least one of the list arguments must be finite.

 -- Function: pair-fold-right KONS KNIL CLIST1 CLIST2 ...
     Holds the same relationship with 'fold-right' that 'pair-fold'
     holds with fold.  Obeys the recursion:

          (pair-fold-right kons knil lis) =
              (kons lis (pair-fold-right kons knil (cdr lis)))
          (pair-fold-right kons knil '()) = knil

     Example:

          (pair-fold-right cons '() '(a b c)) => ((a b c) (b c) (c))

     At least one of the list arguments must be finite.

 -- Function: reduce F RIDENTITY LIST
     'reduce' is a variant of 'fold'.  RIDENTITY should be a "right
     identity" of the procedure F; that is, for any value X acceptable
     to F:

          (f x ridentity) = x

     'reduce' has the following definition:

          if list = (), return ridentity;
          otherwise, return (fold f (car list) (cdr list)).

     in other words, we compute '(fold f ridentity list)'.

     Note that RIDENTITY is used only in the empty-list case.

     You typically use 'reduce' when applying F is expensive and you'd
     like to avoid the extra application incurred when fold applies F to
     the head of list and the identity value, redundantly producing the
     same value passed in to F.  For example, if F involves searching a
     file directory or performing a database query, this can be
     significant.

     In general, however, 'fold' is useful in many contexts where
     'reduce' is not (consider the examples given in the 'fold'
     definition: only one of the five folds uses a function with a right
     identity; the other four may not be performed with 'reduce').

     Note: MIT Scheme and Haskell flip F's arguments order for their
     'reduce' and 'fold' functions.

          ;; Take the max of a list of non-negative integers.
          (reduce max 0 nums) ; i.e., (apply max 0 nums)

 -- Function: reduce-right F RIDENTITY LIST
     'reduce-right' is the 'fold-right' variant of 'reduce'.  It obeys
     the following definition:

          (reduce-right f ridentity '()) = ridentity
          (reduce-right f ridentity '(e1)) = (f e1 ridentity) = e1
          (reduce-right f ridentity '(e1 e2 ...)) =
              (f e1 (reduce f ridentity (e2 ...)))

     in other words, we compute '(fold-right f ridentity list)'.

          ;; Append a bunch of lists together.
          ;; I.e., (apply append list-of-lists)
          (reduce-right append '() list-of-lists)

 -- Function: unfold P F G SEED [TAIL-GEN]
     'unfold' is best described by its basic recursion:

          (unfold p f g seed) =
              (if (p seed)
                  (tail-gen seed)
                (cons (f seed)
                      (unfold p f g (g seed))))

     P
          Determines when to stop unfolding.

     F
          Maps each seed value to the corresponding list element.

     G
          Maps each seed value to next seed value.

     SEED
          The "state" value for the unfold.

     TAIL-GEN
          Creates the tail of the list; defaults to '(lambda (x) '())'.

     In other words, we use G to generate a sequence of seed values:

          seed, g(seed), g2(seed), g3(seed), ...

     These seed values are mapped to list elements by F, producing the
     elements of the result list in a left-to-right order.  P says when
     to stop.

     'unfold' is the fundamental recursive list constructor, just as
     'fold-right' is the fundamental recursive list consumer.  While
     'unfold' may seem a bit abstract to novice functional programmers,
     it can be used in a number of ways:

          ;; List of squares: 1^2 ... 10^2
          (unfold (lambda (x) (> x 10))
                  (lambda (x) (* x x))
              lambda (x) (+ x 1))
              1)

          (unfold null-list? car cdr lis) ; Copy a proper list.

          ;; Read current input port into a list of values.
          (unfold eof-object? values (lambda (x) (read)) (read))

          ;; Copy a possibly non-proper list:
          (unfold not-pair? car cdr lis values)

          ;; Append HEAD onto TAIL:
          (unfold null-list? car cdr head (lambda (x) tail))

     Interested functional programmers may enjoy noting that
     'fold-right' and 'unfold' are in some sense inverses.  That is,
     given operations KNULL?, KAR, KDR, KONS, and KNIL satisfying:

          (kons (kar x) (kdr x)) = x and (knull? knil) = #t

     then:

          (fold-right kons knil (unfold knull? kar kdr x)) = x

     and:

          (unfold knull? kar kdr (fold-right kons knil x)) = x.

     This combinator sometimes is called an "anamorphism"; when an
     explicit TAIL-GEN procedure is supplied, it is called an
     "apomorphism".

 -- Function: unfold-right P F G SEED [TAIL]
     'unfold-right' constructs a list with the following loop:

          (let lp ([seed seed]
                   [lis tail])
            (if (p seed)
                lis
              (lp (g seed)
                  (cons (f seed) lis))))

     P
          Determines when to stop unfolding.

     F
          Maps each seed value to the corresponding list element.

     G
          Maps each seed value to next seed value.

     SEED
          The "state" value for the unfold.

     TAIL
          List terminator; defaults to ''()'.

     In other words, we use G to generate a sequence of seed values:

          seed, g(seed), g2(seed), g3(seed), ...

     these seed values are mapped to list elements by F, producing the
     elements of the result list in a right-to-left order.  P says when
     to stop.

     'unfold-right' is the fundamental iterative list constructor, just
     as 'fold' is the fundamental iterative list consumer.  While
     'unfold-right' may seem a bit abstract to novice functional
     programmers, it can be used in a number of ways:

          ;; List of squares: 1^2 ... 10^2
          (unfold-right zero?
                        (lambda (x) (* x x))
                        (lambda (x) (- x 1))
                        10)

          ;; Reverse a proper list.
          (unfold-right null-list? car cdr lis)

          ;; Read current input port into a list of values.
          (unfold-right eof-object? values (lambda (x) (read)) (read))

          ;; (append-reverse rev-head tail)
          (unfold-right null-list? car cdr rev-head tail)

     Interested functional programmers may enjoy noting that 'fold' and
     'unfold-right' are in some sense inverses.  That is, given
     operations KNULL?, KAR, KDR, KONS, and KNIL satisfying:

          (kons (kar x) (kdr x)) = x and (knull? knil) = #t

     then:

          (fold kons knil (unfold-right knull? kar kdr x)) = x

     and:

          (unfold-right knull? kar kdr (fold kons knil x)) = x.

     This combinator presumably has some pretentious mathematical name;
     interested readers are invited to communicate it to the author.

 -- Function: map PROC CLIST1 CLIST2 ...
     R5RS+ PROC is a procedure taking as many arguments as there are
     list arguments and returning a single value.  'map' applies PROC
     element-wise to the elements of the lists and returns a list of the
     results, in order.  The dynamic order in which PROC is applied to
     the elements of the lists is unspecified.

          (map cadr '((a b) (d e) (g h))) =>  (b e h)

          (map (lambda (n) (expt n n))
               '(1 2 3 4 5))
            =>  (1 4 27 256 3125)

          (map + '(1 2 3) '(4 5 6)) =>  (5 7 9)

          (let ([count 0])
            (map (lambda (ignored)
                   (set! count (+ count 1))
                   count)
                 '(a b)))
            =>  (1 2) or (2 1)

     This procedure is extended from its R5RS specification to allow the
     arguments to be of unequal length; it terminates when the shortest
     list runs out.

     At least one of the argument lists must be finite:

          (map + '(3 1 4 1) (circular-list 1 0)) => (4 1 5 1)

 -- Function: for-each PROC CLIST1 CLIST2 ...
     R5RS+ The arguments to 'for-each' are like the arguments to 'map',
     but 'for-each' calls PROC for its side effects rather than for its
     values.  Unlike 'map', 'for-each' is guaranteed to call PROC on the
     elements of the lists in order from the first element(s) to the
     last, and the value returned by 'for-each' is unspecified.

          (let ([v (make-vector 5)])
            (for-each (lambda (i)
                        (vector-set! v i (* i i)))
                      '(0 1 2 3 4))
            v)  =>  #(0 1 4 9 16)

     This procedure is extended from its R5RS specification to allow the
     arguments to be of unequal length; it terminates when the shortest
     list runs out.

     At least one of the argument lists must be finite.

 -- Function: append-map F CLIST1 CLIST2 ...
 -- Function: append-map! F CLIST1 CLIST2 ...
     Equivalent to:

          (apply append (map f clist1 clist2 ...))

     and:

          (apply append! (map f clist1 clist2 ...))

     Map F over the elements of the lists, just as in the 'map'
     function.  However, the results of the applications are appended
     together to make the final result.  'append-map' uses 'append' to
     append the results together; 'append-map!' uses 'append!'.

     The dynamic order in which the various applications of F are made
     is not specified.

     Example:

          (append-map! (lambda (x) (list x (- x))) '(1 3 8))
            => (1 -1 3 -3 8 -8)

     At least one of the list arguments must be finite.

 -- Function: map! F LIST1 CLIST2 ...
     Linear-update variant of 'map', 'map!' is allowed, but not
     required, to alter the cons cells of LIST1 to construct the result
     list.

     The dynamic order in which the various applications of F are made
     is not specified.  In the n-ary case, CLIST2, CLIST3, ...  must
     have at least as many elements as LIST1.

 -- Function: map-in-order F CLIST1 CLIST2 ...
     A variant of the 'map' procedure that guarantees to apply F across
     the elements of the LISTI arguments in a left-to-right order.  This
     is useful for mapping procedures that both have side effects and
     return useful values.

     At least one of the list arguments must be finite.

 -- Function: pair-for-each F CLIST1 CLIST2 ...
     Like 'for-each', but F is applied to successive sublists of the
     argument lists.  That is, F is applied to the cons cells of the
     lists, rather than the lists' elements.  These applications occur
     in left-to-right order.

     The F procedure may reliably apply 'set-cdr!' to the pairs it is
     given without altering the sequence of execution.

          (pair-for-each (lambda (pair) (display pair) (newline)) '(a b c)) ==>
              (a b c)
              (b c)
              (c)

     At least one of the list arguments must be finite.

 -- Function: filter-map F CLIST1 CLIST2 ...
     Like 'map', but only true values are saved.

          (filter-map (lambda (x)
                        (and (number? x) (* x x)))
                      '(a 1 b 3 c 7))
            => (1 9 49)

     The dynamic order in which the various applications of F are made
     is not specified.

     At least one of the list arguments must be finite.


File: vicare-libs.info,  Node: srfi list spec filter,  Next: srfi list spec search,  Prev: srfi list spec fold,  Up: srfi list spec

2.2.5.7 Filtering and partitioning
..................................

 -- Function: filter PRED LIST
 -- Function: filter! PRED LIST
     Return all the elements of LIST that satisfy predicate PRED.  The
     list is not disordered: elements that appear in the result list
     occur in the same order as they occur in LIST.  The returned list
     may share a common tail with LIST.  The dynamic order in which the
     various applications of PRED are made is not specified.

          (filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)

     'filter!' is the linear-update variant of 'filter'.  It is allowed,
     but not required, to alter the cons cells in LIST to construct the
     result lists.

 -- Function: partition PRED LIST
 -- Function: partition! PRED LIST
     Partition the elements of LIST with predicate PRED, and return two
     values: the list of in-elements and the list of out-elements.  The
     list is not disordered: elements occur in the result lists in the
     same order as they occur in LIST.  The dynamic order in which the
     various applications of PRED are made is not specified.  One of the
     returned lists may share a common tail with LIST.

          (partition symbol? '(one 2 3 four five 6))
            => (one four five)
               (2 3 6)

     'partition!' is the linear-update variant of 'partition'.  It is
     allowed, but not required, to alter the cons cells in LIST to
     construct the result lists.

 -- Function: remove PRED LIST
 -- Function: remove! PRED LIST
     Return LIST without the elements that satisfy predicate PRED:

          (lambda (pred list)
            (filter (lambda (x)
                      (not (pred x)))
                    list))

     The list is not disordered: elements that appear in the result list
     occur in the same order as they occur in LIST.  The returned list
     may share a common tail with LIST.  The dynamic order in which the
     various applications of pred are made is not specified.

          (remove even? '(0 7 8 8 43 -4)) => (7 43)

     'remove!' is the linear-update variant of 'remove'.  It is allowed,
     but not required, to alter the cons cells in LIST to construct the
     result lists.


File: vicare-libs.info,  Node: srfi list spec search,  Next: srfi list spec delete,  Prev: srfi list spec filter,  Up: srfi list spec

2.2.5.8 Searching
.................

The following procedures all search lists for a leftmost element
satisfying some criteria.  This means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list.  Here are the
general rules describing how these procedures work when applied to
different kinds of lists:

_proper lists_
     The standard, canonical behavior happens in this case.

_dotted lists_
     It is an error to pass these procedures a dotted list that does not
     contain an element satisfying the search criteria.  That is, it is
     an error if the procedure has to search all the way to the end of
     the dotted list.

     However, this SRFI does not specify anything at all about the
     behavior of these procedures when passed a dotted list containing
     an element satisfying the search criteria.  It may finish
     successfully, signal an error, or perform some third action.

     Different implementations may provide different functionality in
     this case; code which is compliant with this SRFI may not rely on
     any particular behavior.  Future SRFI's may refine SRFI-1 to define
     specific behavior in this case.

     In brief, SRFI-1 compliant code may not pass a dotted list argument
     to these procedures.

_circular lists_
     It is an error to pass these procedures a circular list that does
     not contain an element satisfying the search criteria.  Note that
     the procedure is not required to detect this case; it may simply
     diverge.  It is, however, acceptable to search a circular list if
     the search is successful; that is, if the list contains an element
     satisfying the search criteria.

   Here are some examples, using the 'find' and 'any' procedures as
canonical representatives:

     ;; Proper list -- success
     (find even? '(1 2 3))	=> 2
     (any  even? '(1 2 3))	=> #t

     ;; proper list -- failure
     (find even? '(1 7 3))	=> #f
     (any  even? '(1 7 3))	=> #f

     ;; Failure is error on a dotted list.
     (find even? '(1 3 . x))	=> error
     (any  even? '(1 3 . x))	=> error

     ;; The dotted list contains an element satisfying the search.
     ;; This case is not specified -- it could be success, an error,
     ;; or some third possibility.
     (find even? '(1 2 . x))	=> error/undefined
     (any  even? '(1 2 . x))	=> error/undefined ; success, error or other.

     ;; circular list -- success
     (find even? (circular-list 1 6 3)) => 6
     (any  even? (circular-list 1 6 3)) => #t

     ;; circular list -- failure is error. Procedure may diverge.
     (find even? (circular-list 1 3)) => error
     (any  even? (circular-list 1 3)) => error

 -- Function: find PRED CLIST
     Return the first element of CLIST that satisfies predicate PRED;
     return '#f' if no element does.

          (find even? '(3 1 4 1 5 9)) => 4

     Note that 'find' has an ambiguity in its lookup semantics: if
     'find' returns '#f', you cannot tell (in general) if it found a
     '#f' element that satisfied PRED, or if it did not find any element
     at all.  In many situations, this ambiguity cannot arise: either
     the list being searched is known not to contain any '#f' elements,
     or the list is guaranteed to have an element satisfying PRED.
     However, in cases where this ambiguity can arise, you should use
     'find-tail' instead of 'find', 'find-tail' has no such ambiguity:

          (cond [(find-tail pred lis) => (lambda (pair) ...)] ; Handle (CAR PAIR)
                [else ...]) ; Search failed.

 -- Function: find-tail PRED CLIST
     Return the first pair of CLIST whose car satisfies PRED.  If no
     pair does, return '#f'.

     'find-tail' can be viewed as a general-predicate variant of the
     'member' function.

     Examples:

          (find-tail even? '(3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
          (find-tail even? '(3 1 37 -5)) => #f

          ;; MEMBER X LIS:
          (find-tail (lambda (elt) (equal? x elt)) lis)

     In the circular-list case, this procedure "rotates" the list.

     'find-tail' is essentially 'drop-while', where the sense of the
     predicate is inverted: 'find-tail' searches until it finds an
     element satisfying the predicate; 'drop-while' searches until it
     finds an element that doesn't satisfy the predicate.

 -- Function: take-while PRED CLIST
 -- Function: take-while! PRED CLIST
     Return the longest initial prefix of CLIST whose elements all
     satisfy the predicate PRED.

     'take-while!' is the linear-update variant.  It is allowed, but not
     required, to alter the argument list to produce the result.

     Example:

          (take-while even? '(2 18 3 10 22 9)) => (2 18)

 -- Function: drop-while PRED CLIST
     Drops the longest initial prefix of CLIST whose elements all
     satisfy the predicate PRED, and returns the rest of the list.

     Example:

          (drop-while even? '(2 18 3 10 22 9)) => (3 10 22 9)

     The circular-list case may be viewed as "rotating" the list.

 -- Function: span PRED CLIST
 -- Function: span! PRED LIST
 -- Function: break PRED CLIST
 -- Function: break! PRED LIST
     'span' splits the list into the longest initial prefix whose
     elements all satisfy PRED, and the remaining tail.  'break' inverts
     the sense of the predicate: the tail commences with the first
     element of the input list that satisfies the predicate.

     In other words: 'span' finds the intial span of elements satisfying
     PRED, and 'break' breaks the list at the first element satisfying
     PRED.

     'span' is equivalent to:

          (values (take-while pred clist)
                  (drop-while pred clist))

     'span!' and 'break!' are the linear-update variants.  They are
     allowed, but not required, to alter the argument list to produce
     the result.

     Examples:

          (span even? '(2 18 3 10 22 9))
            => (2 18)
               (3 10 22 9)

          (break even? '(3 1 4 1 5 9))
            => (3 1)
               (4 1 5 9)

 -- Function: any PRED CLIST1 CLIST2 ...
     Apply the predicate across the lists, returning true if the
     predicate returns true on any application.

     If there are n list arguments CLIST1 ...  CLISTN, then PRED must be
     a procedure taking n arguments and returning a boolean result.

     'any' applies PRED to the first elements of the CLISTI parameters.
     If this application returns a true value, 'any' immediately returns
     that value.  Otherwise, it iterates, applying pred to the second
     elements of the CLISTI parameters, then the third, and so forth.
     The iteration stops when a true value is produced or one of the
     lists runs out of values; in the latter case, 'any' returns '#f'.
     The application of PRED to the last element of the lists is a tail
     call.

     Note the difference between 'find' and 'any': 'find' returns the
     element that satisfied the predicate; 'any' returns the true value
     that the predicate produced.

     Like 'every', 'any''s name does not end with a question mark: this
     is to indicate that it does not return a simple boolean ('#t' or
     '#f'), but a general value.

     Examples:

          (any integer? '(a 3 b 2.7))   => #t
          (any integer? '(a 3.1 b 2.7)) => #f
          (any < '(3 1 4 1 5)
                 '(2 7 1 8 2)) => #t

 -- Function: every PRED CLIST1 CLIST2 ...
     Apply the predicate across the lists, returning true if the
     predicate returns true on every application.

     If there are n list arguments CLIST1 ...  CLISTN, then PRED must be
     a procedure taking n arguments and returning a boolean result.

     'every' applies PRED to the first elements of the CLISTI
     parameters.  If this application returns '#f', 'every' immediately
     returns '#f'.  Otherwise, it iterates, applying PRED to the second
     elements of the CLISTI parameters, then the third, and so forth.
     The iteration stops when a '#f' value is produced or one of the
     lists runs out of values.  In the latter case, 'every' returns the
     true value produced by its final application of PRED.  The
     application of PRED to the last element of the lists is a tail
     call.

     If one of the CLISTI has no elements, 'every' simply returns '#t'.

     Like 'any', 'every''s name does not end with a question mark: this
     is to indicate that it does not return a simple boolean ('#t' or
     '#f'), but a general value.

 -- Function: list-index PRED CLIST1 CLIST2 ...
     Return the index of the leftmost element that satisfies PRED.

     If there are n list arguments, then PRED must be a function taking
     n arguments and returning a boolean result.

     'list-index' applies PRED to the first elements of the CLISTI
     parameters.  If this application returns true, 'list-index'
     immediately returns zero.  Otherwise, it iterates, applying PRED to
     the second elements of the CLISTI parameters, then the third, and
     so forth.  When it finds a tuple of list elements that cause PRED
     to return true, it stops and returns the zero-based index of that
     position in the lists.

     The iteration stops when one of the lists runs out of values; in
     this case, 'list-index' returns '#f'.

     Examples:

          (list-index even? '(3 1 4 1 5 9)) => 2
          (list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => 1
          (list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => #f

 -- Function: member X LIST [=]
 -- Function: memq X LIST
 -- Function: memv X LIST
     R5RS+ These procedures return the first sublist of LIST whose car
     is X, where the sublists of list are the non-empty lists returned
     by '(drop list i)' for I less than the length of LIST.  If X does
     not occur in LIST, then '#f' is returned.

     'memq' uses 'eq?' to compare X with the elements of LIST, while
     MEMV uses 'eqv?', and 'member' uses 'equal?'.

     Examples:

          (memq 'a '(a b c))          =>  (a b c)
          (memq 'b '(a b c))          =>  (b c)
          (memq 'a '(b c d))          =>  #f
          (memq (list 'a) '(b (a) c)) =>  #f
          (member (list 'a)
                  '(b (a) c))         =>  ((a) c)
          (memq 101 '(100 101 102))   =>  *unspecified*
          (memv 101 '(100 101 102))   =>  (101 102)

     'member' is extended from its R5RS definition to allow the client
     to pass in an optional equality procedure = used to compare keys.

     The comparison procedure is used to compare the elements EI of list
     to the key X in this way:

          (= x ei) ; list is (E1 ... En)

     that is, the first argument is always X, and the second argument is
     one of the list elements.  Thus one can reliably find the first
     element of list that is greater than five with '(member 5 list <)'.

     Note that fully general list searching may be performed with the
     'find-tail' and 'find' procedures:

          (find-tail even? list) ; Find the first elt with an even key.


File: vicare-libs.info,  Node: srfi list spec delete,  Next: srfi list spec alist,  Prev: srfi list spec search,  Up: srfi list spec

2.2.5.9 Deletion
................

 -- Function: delete X LIST [=]
 -- Function: delete! X LIST [=]
     Use the comparison procedure = (which defaults to 'equal?') to find
     all elements of list that are equal to X, and delete them from
     LIST.  The dynamic order in which the various applications of = are
     made is not specified.

     The list is not disordered: elements that appear in the result list
     occur in the same order as they occur in the argument list.  The
     result may share a common tail with the argument list.

     Note that fully general element deletion can be performed with the
     'remove' and 'remove!' procedures:

          ;; Delete all the even elements from LIS:
          (remove even? lis)

     The comparison procedure is used in this way: '(= x ei)'; that is,
     X is always the first argument, and a list element is always the
     second argument.  The comparison procedure will be used to compare
     each element of list exactly once; the order in which it is applied
     to the various EI is not specified.  Thus, one can reliably remove
     all the numbers greater than 5 from a list with '(delete 5 list
     <)'.

     'delete!' is the linear-update variant of 'delete'.  It is allowed,
     but not required, to alter the cons cells in its argument list to
     construct the result.

 -- Function: delete-duplicates LIST [=]
 -- Function: delete-duplicates! LIST [=]
     Remove duplicate elements from the list argument.  If there are
     multiple equal elements in LIST, the result list only contains the
     first or leftmost of these elements in the result.  The order of
     these surviving elements is the same as in the original list:
     'delete-duplicates' does not disorder the list (hence it is useful
     for "cleaning up" association lists).

     The = parameter is used to compare the elements of the list; it
     defaults to 'equal?'.  If X comes before Y in LIST, then the
     comparison is performed '(= x y)'.  The comparison procedure will
     be used to compare each pair of elements in list no more than once;
     the order in which it is applied to the various pairs is not
     specified.

     Implementations of 'delete-duplicates' are allowed to share common
     tails between argument and result lists; for example, if the list
     argument contains only unique elements, it may simply return
     exactly this list.

     Be aware that, in general, 'delete-duplicates' runs in time O(n2)
     for n-element lists.  Uniquifying long lists can be accomplished in
     O(n lg n) time by sorting the list to bring equal elements
     together, then using a linear-time algorithm to remove equal
     elements.  Alternatively, one can use algorithms based on
     element-marking, with linear-time results.

     'delete-duplicates!' is the linear-update variant of
     'delete-duplicates'; it is allowed, but not required, to alter the
     cons cells in its argument list to construct the result.

          (delete-duplicates '(a b a c a b c z)) => (a b c z)

          ;; Clean up an alist:
          (delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                             (lambda (x y)
                               (eq? (car x) (car y))))
            => ((a . 3) (b . 7) (c . 1))


File: vicare-libs.info,  Node: srfi list spec alist,  Next: srfi list spec set,  Prev: srfi list spec delete,  Up: srfi list spec

2.2.5.10 Association lists
..........................

An "association list" (or "alist") is a list of pairs.  The car of each
pair contains a key value, and the cdr contains the associated data
value.  They can be used to construct simple look-up tables in Scheme.
Note that association lists are probably inappropriate for
performance-critical use on large data; in these cases, hash tables or
some other alternative should be employed.

 -- Function: assoc KEY ALIST [=]
 -- Function: assq KEY ALIST
 -- Function: assv KEY ALIST
     R5RS+ ALIST must be an association list: a list of pairs.  These
     procedures find the first pair in ALIST whose car field is KEY, and
     returns that pair.  If no pair in ALIST has KEY as its car, then
     '#f' is returned.

     'assq' uses 'eq?' to compare KEY with the car fields of the pairs
     in ALIST, while 'assv' uses 'eqv?' and 'assoc' uses 'equal?'.

     Example:

          (define e '((a 1) (b 2) (c 3)))
          (assq 'a e)                            =>  (a 1)
          (assq 'b e)                            =>  (b 2)
          (assq 'd e)                            =>  #f
          (assq (list 'a) '(((a)) ((b)) ((c))))  =>  #f
          (assoc (list 'a) '(((a)) ((b)) ((c)))) =>  ((a))
          (assq 5 '((2 3) (5 7) (11 13)))    =>  *unspecified*
          (assv 5 '((2 3) (5 7) (11 13)))    =>  (5 7)

     'assoc' is extended from its R5RS definition to allow the client to
     pass in an optional equality procedure = used to compare keys.

     The comparison procedure is used to compare the elements EI of list
     to the key parameter in this way:

          (= key (car ei)) ; list is (E1 ... En)

     that is, the first argument is always KEY, and the second argument
     is one of the list elements.  Thus one can reliably find the first
     entry of ALIST whose KEY is greater than five with '(assoc 5 alist
     <)'.

     Note that fully general alist searching may be performed with the
     'find-tail' and 'find' procedures:

          ;; Look up the first association in alist with an even key:
          (find (lambda (a)
                  (even? (car a)))
                alist)

 -- Function: alist-cons KEY DATUM ALIST
     Defined as:

          (lambda (key datum alist)
            (cons (cons key datum) alist))

     Cons a new alist entry mapping KEY to DATUM onto ALIST.

 -- Function: alist-copy ALIST
     Make a fresh copy of ALIST.  This means copying each pair that
     forms an association as well as the spine of the list:

          (lambda (a)
            (map (lambda (elt)
                   (cons (car elt) (cdr elt)))
                 a))

 -- Function: alist-delete KEY ALIST [=]
 -- Function: alist-delete! KEY ALIST [=]
     Delete all associations from ALIST with the given KEY, using the
     key-comparison procedure =, which defaults to 'equal?'.  The
     dynamic order in which the various applications of = are made is
     not specified.

     Return values may share common tails with the ALIST argument.  The
     alist is not disordered: elements that appear in the result alist
     occur in the same order as they occur in ALIST.

     The comparison procedure is used to compare the element keys KI of
     ALIST's entries to the key parameter in this way: '(= key ki)'.
     Thus, one can reliably remove all entries of ALIST whose key is
     greater than five with '(alist-delete 5 alist <)'.

     'alist-delete!' is the linear-update variant of 'alist-delete'; it
     is allowed, but not required, to alter cons cells from the alist
     parameter to construct the result.


File: vicare-libs.info,  Node: srfi list spec set,  Next: srfi list spec side,  Prev: srfi list spec alist,  Up: srfi list spec

2.2.5.11 Set operations on lists
................................

These procedures implement operations on sets represented as lists of
elements.  They all take an = argument used to compare elements of
lists.  This equality procedure is required to be consistent with 'eq?'.
That is, it must be the case that:

     (eq? x y) => (= x y)

   Note that this implies, in turn, that two lists that are 'eq?' are
also set-equal by any legal comparison procedure.  This allows for
constant-time determination of set operations on 'eq?' lists.

   Be aware that these procedures typically run in time O(n * m) for n-
and m-element list arguments.  Performance-critical applications
operating upon large sets will probably wish to use other data
structures and algorithms.

 -- Function: lset<= = LIST1 ...
     Return true if, and only if, every LISTI is a subset of LISTI+1,
     using = for the element-equality procedure.  List AL is a subset of
     list BL if every element in AL is equal to some element of BL.
     When performing an element comparison, the = procedure's first
     argument is an element of AL, its second argument an element of BL.

     Examples:

          (lset<= eq? '(a) '(a b a) '(a b c c)) => #t

          (lset<= eq?) => #t             ; Trivial cases
          (lset<= eq? '(a)) => #t

 -- Function: lset= = LIST1 LIST2 ...
     Return true if, and only if, every LISTI is set-equal to LISTI+1,
     using = for the element-equality procedure.  "Set-equal" simply
     means that LISTI is a subset of LISTI+1, and LISTI+1 is a subset of
     LISTI.  The = procedure's first argument is an element of LISTI,
     its second argument is an element of LISTI+1.

     Examples:

          (lset= eq? '(b e a) '(a e b) '(e e b a)) => #t

          (lset= eq?) => #t               ; Trivial cases
          (lset= eq? '(a)) => #t

 -- Function: lset-adjoin = LIST ELT1 ...
     Add the ELTI elements not already in the LIST parameter to the
     result list.  The result shares a common tail with the LIST
     parameter.  The new elements are added to the front of the list,
     but no guarantees are made about their order.  The = parameter is
     an equality procedure used to determine if an elti is already a
     member of list.  Its first argument is an element of LIST, its
     second is one of the ELTI.

     The LIST parameter is always a suffix of the result; even if the
     list parameter contains repeated elements, these are not reduced.

     Example:

          (lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u)
            => (u o i a b c d c e)

 -- Function: lset-union = LIST1 ...
 -- Function: lset-union! = LIST1 ...
     Return the union of the lists, using = for the element-equality
     procedure.

     The union of lists AL and BL is constructed as follows:

       1. If AL is the empty list, the answer is BL (or a copy of BL).

       2. Otherwise, the result is initialised to be list AL (or a copy
          of AL).

       3. Proceed through the elements of list BL in a left-to-right
          order.  If B is such an element of BL, compare every element R
          of the current result list to B: '(= r b)'.  If all
          comparisons fail, B is consed onto the front of the result.

     However, there is no guarantee that = will be applied to every pair
     of arguments from AL and BL.  In particular, if AL is 'eq?' to BL,
     the operation may immediately terminate.

     In the n-ary case, the two-argument 'list-union' operation is
     simply folded across the argument lists.

     Examples:

          (lset-union eq? '(a b c d e) '(a e i o u))
            => (u o i a b c d e)

          ;; Repeated elements in LIST1 are preserved.
          (lset-union eq? '(a a c) '(x a x)) => (x a a c)

          ;; Trivial cases
          (lset-union eq?) => ()
          (lset-union eq? '(a b c)) => (a b c)

     'lset-union!' is the linear-update variant of 'lset-union'.  It is
     allowed, but not required, to use the cons cells in the first list
     parameter to construct its answer.  'lset-union!' is permitted to
     recycle cons cells from any of its list arguments.

 -- Function: lset-intersection = LIST1 LIST2 ...
 -- Function: lset-intersection! = LIST1 ...
     Return the intersection of the lists, using = for the
     element-equality procedure.

     The intersection of lists AL and BL is comprised of every element
     of AL that is = to some element of BL: '(= a b)', for A in AL, and
     B in BL.  Note this implies that an element which appears in BL and
     multiple times in list AL will also appear multiple times in the
     result.

     The order in which elements appear in the result is the same as
     they appear in LIST1; that is, 'lset-intersection' essentially
     filters LIST1, without disarranging element order.  The result may
     share a common tail with LIST1.

     In the n-ary case, the two-argument 'list-intersection' operation
     is simply folded across the argument lists.  However, the dynamic
     order in which the applications of = are made is not specified.
     The procedure may check an element of LIST1 for membership in every
     other list before proceeding to consider the next element of LIST1,
     or it may completely intersect LIST1 and LIST2 before proceeding to
     LIST3, or it may go about its work in some third order.

     Examples:

          (lset-intersection eq? '(a b c d e) '(a e i o u))
            => (a e)

          ;; Repeated elements in LIST1 are preserved.
          (lset-intersection eq? '(a x y a) '(x a x z))
            => '(a x a)

          (lset-intersection eq? '(a b c))        ; Trivial case
            => (a b c)

     'lset-intersection!' is the linear-update variant of
     'lset-intersection'.  It is allowed, but not required, to use the
     cons cells in the first list parameter to construct its answer.

 -- Function: lset-difference = LIST1 LIST2 ...
 -- Function: lset-difference! = LIST1 ...
     Return the difference of the lists, using = for the
     element-equality procedure: all the elements of LIST1 that are not
     = to any element from one of the other LISTI parameters.

     The = procedure's first argument is always an element of LIST1; its
     second is an element of one of the other LISTI.  Elements that are
     repeated multiple times in the LIST1 parameter will occur multiple
     times in the result.

     The order in which elements appear in the result is the same as
     they appear in LIST1; that is, 'lset-difference' essentially
     filters LIST1, without disarranging element order.  The result may
     share a common tail with LIST1.

     The dynamic order in which the applications of = are made is not
     specified.  The procedure may check an element of LIST1 for
     membership in every other list before proceeding to consider the
     next element of LIST1, or it may completely compute the difference
     of LIST1 and LIST2 before proceeding to LIST3, or it may go about
     its work in some third order.

          (lset-difference eq? '(a b c d e) '(a e i o u))
            => (b c d)

          (lset-difference eq? '(a b c))   ; Trivial case
            => (a b c)

     'lset-difference!' is the linear-update variant of
     'lset-difference'.  It is allowed, but not required, to use the
     cons cells in the first list parameter to construct its answer.

 -- Function: lset-xor = LIST1 ...
 -- Function: lset-xor! = LIST1 ...
     Return the exclusive-or of the sets, using = for the
     element-equality procedure.  If there are exactly two lists, this
     is all the elements that appear in exactly one of the two lists.
     The operation is associative, and thus extends to the n-ary case,
     in which the result is a list of the elements that appear in an odd
     number of the lists.  The result may share a common tail with any
     of the LISTI parameters.

     More precisely, for two lists AL and BL, AL xor BL is a list of:

        * every element A of AL such that there is no element B of BL
          such that '(= a b)', and

        * every element B of BL such that there is no element A of AL
          such that '(= b a)'.

     However, an implementation is allowed to assume that = is
     symmetric; that is, that '(= a b) => (= b a)'.

     This means, for example, that if a comparison '(= a b)' produces
     true for some A in AL and B in BL, both A and B may be removed from
     inclusion in the result.

     In the n-ary case, the binary-xor operation is simply folded across
     the lists.

     Examples:

          (lset-xor eq? '(a b c d e) '(a e i o u))
            => (d c b i o u)

          ;; Trivial cases.
          (lset-xor eq?) => ()
          (lset-xor eq? '(a b c d e)) => (a b c d e)

     'lset-xor!' is the linear-update variant of 'lset-xor'.  It is
     allowed, but not required, to use the cons cells in the first list
     parameter to construct its answer.

 -- Function: lset-diff+intersection = LIST1 LIST2 ...
 -- Function: lset-diff+intersection! = LIST1 LIST2 ...
     Return two values: the difference and the intersection of the
     lists.  It is equivalent to:

          (values (lset-difference = list1 list2 ...)
                  (lset-intersection = list1
                                       (lset-union = list2 ...)))

     but can be implemented more efficiently.

     The = procedure's first argument is an element of LIST1; its second
     is an element of one of the other LISTI.

     Either of the answer lists may share a common tail with LIST1.
     This operation essentially partitions LIST1.

     'lset-diff+intersection!' is the linear-update variant of
     'lset-diff+intersection'.  It is allowed, but not required, to use
     the cons cells in the first list parameter to construct its answer.


File: vicare-libs.info,  Node: srfi list spec side,  Prev: srfi list spec set,  Up: srfi list spec

2.2.5.12 Primitive side-effects
...............................

These two procedures are the primitive, R5RS side-effect operations on
pairs.

 -- Function: set-car! PAIR OBJECT
 -- Function: set-cdr! pair OBJECT
     R5RS These procedures store object in the car and cdr field of
     pair, respectively.  The returned value is unspecified.

          (define (f) (list 'not-a-constant-list))
          (define (g) '(constant-list))
          (set-car! (f) 3) =>  *unspecified*
          (set-car! (g) 3) =>  *error*


File: vicare-libs.info,  Node: srfi list ack,  Next: srfi list references,  Prev: srfi list spec,  Up: srfi list

2.2.6 Acknowledgements
----------------------

The design of this library benefited greatly from the feedback provided
during the SRFI discussion phase.  Among those contributing thoughtful
commentary and suggestions, both on the mailing list and by private
discussion, were Mike Ashley, Darius Bacon, Alan Bawden, Phil Bewig, Jim
Blandy, Dan Bornstein, Per Bothner, Anthony Carrico, Doug Currie, Kent
Dybvig, Sergei Egorov, Doug Evans, Marc Feeley, Matthias Felleisen, Will
Fitzgerald, Matthew Flatt, Dan Friedman, Lars Thomas Hansen, Brian
Harvey, Erik Hilsdale, Wolfgang Hukriede, Richard Kelsey, Donovan
Kolbly, Shriram Krishnamurthi, Dave Mason, Jussi Piitulainen, David
Pokorny, Duncan Smith, Mike Sperber, Maciej Stachowiak, Harvey J. Stein,
John David Stone, and Joerg F. Wittenberger.  I am grateful to them for
their assistance.

   I am also grateful the authors, implementors and documentors of all
the systems mentioned in the rationale.  Aubrey Jaffer and Kent Pitman
should be noted for their work in producing Web-accessible versions of
the R5RS and Common Lisp spec, which was a tremendous aid.

   This is not to imply that these individuals necessarily endorse the
final results, of course.


File: vicare-libs.info,  Node: srfi list references,  Prev: srfi list ack,  Up: srfi list

2.2.7 References
----------------

This document, in HTML:

             <http://srfi.schemers.org/srfi-1/srfi-1.html>

source code for the reference implementation:

        <http://srfi.schemers.org/srfi-1/srfi-1-reference.scm>

archive of SRFI-1 discussion-list email:

     <http://srfi.schemers.org/srfi-1/mail-archive/maillist.html>

SRFI web site:

                      <http://srfi.schemers.org/>

_Common Lisp: the Language_.  Guy L. Steele Jr.  (editor).  Digital
Press, Maynard, Mass., second edition 1990.  Available at:

        <http://www.elwood.com/alu/table/references.htm#cltl2>

_The Common Lisp "HyperSpec"_, produced by Kent Pitman, is essentially
the ANSI spec for Common Lisp:

         <http://www.harlequin.com/education/books/HyperSpec/>

   _Revised^5 report on the algorithmic language Scheme_.  R. Kelsey, W.
Clinger, J. Rees (editors).  Higher-Order and Symbolic Computation, Vol.
11, No.  1, September, 1998, and ACM SIGPLAN Notices, Vol.  33, No.  9,
October, 1998.  Available at

            <http://www.schemers.org/Documents/Standards/>


File: vicare-libs.info,  Node: srfi and-let-star,  Next: srfi string-ports,  Prev: srfi list,  Up: srfi

2.3 SRFI-2 'and-let*': an 'and' with local bindings, a guarded 'let*' special form.
===================================================================================

The library '(srfi :2)' is by Oleg Kiselyov as the reference
implementation for SRFI-2; see:

             <http://srfi.schemers.org/srfi-2/srfi-2.html>

for more details.

* Menu:

* srfi and-let-star license::   'and-let-star' document license.
* srfi and-let-star abstract::  Abstract.
* srfi and-let-star rationale:: Rationale.
* srfi and-let-star spec::      Specification.


File: vicare-libs.info,  Node: srfi and-let-star license,  Next: srfi and-let-star abstract,  Up: srfi and-let-star

2.3.1 And-let-star document license
-----------------------------------

Copyright (C) 1998 Oleg Kiselyov.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi and-let-star abstract,  Next: srfi and-let-star rationale,  Prev: srfi and-let-star license,  Up: srfi and-let-star

2.3.2 Abstract
--------------

Like an ordinary 'and', an 'and-let*' special form evaluates its
arguments (expressions) one after another in order, till the first one
that yields '#f'.  Unlike 'and', however, a non-'#f' result of one
expression can be bound to a fresh variable and used in the subsequent
expressions.  'and-let*' is a cross-breed between 'let*' and 'and'.


File: vicare-libs.info,  Node: srfi and-let-star rationale,  Next: srfi and-let-star spec,  Prev: srfi and-let-star abstract,  Up: srfi and-let-star

2.3.3 Rationale
---------------

In case of an ordinary 'and' formed of proper boolean expressions:

     (and e1 e2 ...)

expression E2, if it gets to be evaluated, knows that E1 has returned
non-'#f'.  Moreover, E2 knows exactly what the result of E1 was (true)
which E2 can use to its advantage.  If E1 however is an extended boolean
expression, E2 can no longer tell which particular non-'#f' value E1 has
returned.  Chances are it took a lot of work to evaluate E1, and the
produced result (a number, a vector, a string, etc) may be of value to
E2.  Alas, the 'and' form merely checks that the result is not an '#f',
and throws it away.  If E2 needs it, it has to compute that value anew.

   This proposed 'and-let*' special form lets constituent expressions
get hold of the results of already evaluated expressions, without
re-doing their work.

   'and-let*' can be thought of as a combination of 'let*' and 'and', or
a generalization of 'cond''s send operator, '=>'.  An 'and-let*' form
can also be considered a sequence of guarded expressions.

   In a regular program, forms may produce results, bind them to
variables and let other forms use these results.  'and-let*' differs in
that it checks to make sure that every produced result "makes sense"
(that is, not an '#f').  The first "failure" triggers the guard and
aborts the rest of the sequence (which presumably would not make any
sense to execute anyway).  Examples:

     (and-let* ([my-list     (compute-list)]
                [            (not (null? my-list))])
       (do-something my-list))

     (define (look-up key alist)
       (and-let* ([x (assq key alist)])
         (cdr x)))

     (or
       (and-let* ([c (read-char)]
                  [  (not (eof-object? c))])
         (string-set! some-str i c)
         (set! i (+ 1 i)))
       (begin
         (do-process-eof)))

     ;; A more realistic example
     ;; Parse the 'timestamp' ::= 'token1' 'token2'
     ;;   token1 ::= 'YY' 'MM' 'J'
     ;;   token2 ::= 'GG' 'gg' "/"
     (define (parse-full-timestamp token1 token2)
       (and-let* ([  (= 5 (string-length token1))]
                  [  (= 5 (string-length token2))]
                  [timestamp
                     (OS:string->time "%m/%d/%y %H:%M"
                       (string
                         (string-ref token1 2) (string-ref token1 3) #\/
                         (string-ref token1 0) (string-ref token1 1) #\/
                         (case (string-ref token1 4)
                           ((#\8 #\9) #\9) (else #\0))
                         (string-ref token1 4) #\space
                         (string-ref token2 0) (string-ref token2 1) #\:
                         (string-ref token2 2) (string-ref token2 3)))]
                  [  (positive? timestamp)])
                timestamp))

   'and-let*' is also similar to an "anaphoric 'and'" Lisp macro(1).
'and-let*' allows however more than one intermediate result, each of
which continues to be bound through the rest of the form.

   ---------- Footnotes ----------

   (1) Rob Warnock, comp.lang.scheme, 26 Feb 1998 09:06:43 GMT,
Message-ID: <6d3bb3$3804h@fido.asd.sgi.com>


File: vicare-libs.info,  Node: srfi and-let-star spec,  Prev: srfi and-let-star rationale,  Up: srfi and-let-star

2.3.4 Specification
-------------------

     AND-LET* (CLAWS) BODY

     CLAWS ::= '() | (cons CLAW CLAWS)
     CLAW  ::=  (VARIABLE EXPRESSION) | (EXPRESSION) |
                BOUND-VARIABLE

   * The 'CLAWS' are evaluated in the strict left-to-right order.

   * For each 'CLAW', the 'EXPRESSION' part is evaluated first (or
     'BOUND-VARIABLE' is looked up)

   * If the result is '#f', 'and-let*' immediately returns '#f'.

   * Otherwise, if the 'claw' is of the form '(VARIABLE EXPRESSION)' the
     'EXPRESSION''s value is bound to a freshly made 'VARIABLE'.

   * The 'VARIABLE' is available for the rest of the 'CLAWS', and the
     'BODY'.

   * As usual, all 'VARIABLE's must be unique (like in 'let*').

2.3.4.1 Formal (denotational) semantics
.......................................

     eval[ (AND-LET* (CLAW1 ...) BODY), env] =
        eval_claw[ CLAW1, env ] andalso
        eval[ (AND-LET* ( ...) BODY), ext_claw_env[CLAW1, env]]

     eval[ (AND-LET* (CLAW) ), env] = eval_claw[ CLAW, env ]
     eval[ (AND-LET* () FORM1 ...), env] = eval[ (BEGIN FORM1 ...), env ]
     eval[ (AND-LET* () ), env] = #t

     eval_claw[ BOUND-VARIABLE, env ] =
        eval[ BOUND-VARIABLE, env ]
     eval_claw[ (EXPRESSION), env ] =
        eval[ EXPRESSION, env ]
     eval_claw[ (VARIABLE EXPRESSION), env ] =
        eval[ EXPRESSION, env ]

     ext_claw_env[ BOUND-VARIABLE, env ] = env
     ext_claw_env[ (EXPRESSION), env ] =
        env-after-eval[ EXPRESSION, env ]
     ext_claw_env[ (VARIABLE EXPRESSION), env ] =
        extend-env[ env-after-eval[ EXPRESSION, env ],
                   VARIABLE boundto eval[ EXPRESSION, env ]]


File: vicare-libs.info,  Node: srfi string-ports,  Next: srfi receive,  Prev: srfi and-let-star,  Up: srfi

2.4 SRFI-6 basic string ports
=============================

The library '(srfi :6)' is by William D Clinger as the reference
implementation for SRFI-6; see:

             <http://srfi.schemers.org/srfi-6/srfi-6.html>

for more details.

* Menu:

* srfi string-ports license::   String-ports document license.
* srfi string-ports abstract::  Abstract.
* srfi string-ports rationale:: Rationale.
* srfi string-ports spec::      Specification.


File: vicare-libs.info,  Node: srfi string-ports license,  Next: srfi string-ports abstract,  Up: srfi string-ports

2.4.1 String-ports document license
-----------------------------------

Copyright (C) 1999 William D Clinger.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi string-ports abstract,  Next: srfi string-ports rationale,  Prev: srfi string-ports license,  Up: srfi string-ports

2.4.2 Abstract
--------------

Scheme's I/O primitives are extended by adding three new procedures that

   * create an input port from a string;

   * create an output port whose contents are accumulated in Scheme's
     working memory instead of an external file;

   * extract the accumulated contents of an in-memory output port and
     return them in the form of a string.


File: vicare-libs.info,  Node: srfi string-ports rationale,  Next: srfi string-ports spec,  Prev: srfi string-ports abstract,  Up: srfi string-ports

2.4.3 Rationale
---------------

Scheme's procedures for performing input and output from and to ports
become more useful when extended by string ports.  The interface
described here has been in use since 1986 or before, and is currently
supported by several of the major implementations.


File: vicare-libs.info,  Node: srfi string-ports spec,  Prev: srfi string-ports rationale,  Up: srfi string-ports

2.4.4 Specification
-------------------

This specification is taken from the MacScheme Reference Manual.

 -- Function: open-input-string STRING
     Take a string and return an input port that delivers characters
     from the string.  The port can be closed by 'close-input-port',
     though its storage will be reclaimed by the garbage collector if it
     becomes inaccessible.

     Example:

          (define p (open-input-string "(a . (b . c . ())) 34"))

          (input-port? p)                 =>  #t
          (read p)                        =>  (a b c)
          (read p)                        =>  34
          (eof-object? (peek-char p))     =>  #t

 -- Function: open-output-string
     Return an output port that will accumulate characters for retrieval
     by 'get-output-string'.  The port can be closed by the procedure
     'close-output-port', though its storage will be reclaimed by the
     garbage collector if it becomes inaccessible.

          (let ([q (open-output-string)]
                [x '(a b c)])
            (write (car x) q)
            (write (cdr x) q)
            (get-output-string q))
            =>  "a(b c)"

 -- Function: get-output-string OUTPUT-PORT
     Given an output port created by 'open-output-string', return a
     string consisting of the characters that have been output to the
     port so far.


File: vicare-libs.info,  Node: srfi receive,  Next: srfi records,  Prev: srfi string-ports,  Up: srfi

2.5 SRFI-8 'receive': Binding to multiple values
================================================

The library '(srfi :8)' is by John David Stone (Department of
Mathematics and Computer Science, Grinnell College, Grinnell, Iowa
50112, <stone@cs.grinnell.edu>) as the reference implementation for
SRFI-8; see:

             <http://srfi.schemers.org/srfi-8/srfi-8.html>

for more details.

* Menu:

* srfi receive license::        Receive document license.
* srfi receive abstract::       Abstract.
* srfi receive rationale::      Rationale.
* srfi receive spec::           Specification.


File: vicare-libs.info,  Node: srfi receive license,  Next: srfi receive abstract,  Up: srfi receive

2.5.1 Receive document license
------------------------------

Copyright (C) 1999 John David Stone.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi receive abstract,  Next: srfi receive rationale,  Prev: srfi receive license,  Up: srfi receive

2.5.2 Abstract
--------------

The only mechanism that R5RS provides for binding identifiers to the
values of a multiple-valued expression is the primitive
'call-with-values'.  This SRFI proposes a more concise, more readable
syntax for creating such bindings.


File: vicare-libs.info,  Node: srfi receive rationale,  Next: srfi receive spec,  Prev: srfi receive abstract,  Up: srfi receive

2.5.3 Rationale
---------------

Although R5RS supports multiple-valued expressions, it provides only the
essential procedures 'values' and 'call-with-values'.  It is evident
that the authors expected Scheme programmers to define other constructs
in terms of these, abstracting common patterns of use.

   One such pattern consists in binding an identifier to each of the
values of a multiple-valued expression and then evaluating an expression
in the scope of the bindings.  As an instance of this pattern, consider
the following excerpt from a quicksort procedure:

     (call-with-values
       [lambda ()
         (partition (precedes pivot) others)]
       [lambda (fore aft)
         (append (qsort fore) (cons pivot (qsort aft)))])

   Here 'partition' is a multiple-valued procedure that takes two
arguments, a predicate and a list, and returns two lists, one comprising
the list elements that satisfy the predicate, the other those that do
not.  The purpose of the expression shown is to partition the list
OTHERS, sort each of the sublists, and recombine the results into a
sorted list.

   For our purposes, the important step is the binding of the
identifiers fore and aft to the values returned by 'partition'.
Expressing the construction and use of these bindings with the
'call-by-values' primitive is cumbersome: One must explicitly embed the
expression that provides the values for the bindings in a parameterless
procedure, and one must explicitly embed the expression to be evaluated
in the scope of those bindings in another procedure, writing as its
parameters the identifiers that are to be bound to the values received.

   These embeddings are boilerplate, exposing the underlying binding
mechanism but not revealing anything relevant to the particular program
in which it occurs.  So the use of a syntactic abstraction that exposes
only the interesting parts (the identifiers to be bound, the
multiple-valued expression that supplies the values, and the body of the
receiving procedure) makes the code more concise and more readable:

     (receive (fore aft)
         [partition (precedes pivot) others]
       [append (qsort fore)
               (cons pivot (qsort aft))])

   The advantages are similar to those of a 'let'-expression over a
procedure call with a 'lambda'-expression as its operator.  In both
cases, cleanly separating a "header" in which the bindings are
established from a "body" in which they are used makes it easier to
follow the code.


File: vicare-libs.info,  Node: srfi receive spec,  Prev: srfi receive rationale,  Up: srfi receive

2.5.4 Specification
-------------------

 -- Syntax: receive FORMALS EXPRESSION BODY
     FORMALS, EXPRESSION, and BODY are as described in R5RS.
     Specifically, FORMALS can have any of three forms:

     '(variable1 ... variablen)'
          The environment in which the 'receive'-expression is evaluated
          is extended by binding VARIABLE1, ..., VARIABLEN to fresh
          locations.  The EXPRESSION is evaluated, and its values are
          stored into those locations (it is an error if EXPRESSION does
          not have exactly N values).

     'variable'
          The environment in which the 'receive'-expression is evaluated
          is extended by binding VARIABLE to a fresh location.  The
          EXPRESSION is evaluated, its values are converted into a newly
          allocated list, and the list is stored in the location bound
          to VARIABLE.

     '(variable1 ... variablen . variablen+1)'
          The environment in which the 'receive'-expression is evaluated
          is extended by binding VARIABLE1, ..., VARIABLEN+1 to fresh
          locations.  The EXPRESSION is evaluated.  Its first N values
          are stored into the locations bound to VARIABLE1, ...,
          VARIABLEN.  Any remaining values are converted into a newly
          allocated list, which is stored into the location bound to
          VARIABLEN+1 (it is an error if EXPRESSION does not have at
          least N values.

     In any case, the expressions in BODY are evaluated sequentially in
     the extended environment.  The results of the last expression in
     the body are the values of the RECEIVE-expression.


File: vicare-libs.info,  Node: srfi records,  Next: srfi let-values,  Prev: srfi receive,  Up: srfi

2.6 SRFI-9 defining record types
================================

The library '(srfi :9)' is by Richard Kelsey as the reference
implementation for SRFI-9; see:

             <http://srfi.schemers.org/srfi-9/srfi-9.html>

for more details.

* Menu:

* srfi records license::        Records document license.
* srfi records abstract::       Abstract.
* srfi records rationale::      Rationale.
* srfi records spec::           Specification.


File: vicare-libs.info,  Node: srfi records license,  Next: srfi records abstract,  Up: srfi records

2.6.1 Records document license
------------------------------

Copyright (C) 1999 Richard Kelsey.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi records abstract,  Next: srfi records rationale,  Prev: srfi records license,  Up: srfi records

2.6.2 Abstract
--------------

This SRFI describes syntax for creating new data types, called record
types.  A predicate, a constructor, and field accessors and modifiers
are defined for each record type.  Each new record type is distinct from
all existing types, including other record types and Scheme's predefined
types.


File: vicare-libs.info,  Node: srfi records rationale,  Next: srfi records spec,  Prev: srfi records abstract,  Up: srfi records

2.6.3 Rationale
---------------

Many Scheme implementations provide means for creating new types,
usually called either records or structures.  The 'DEFINE-RECORD-TYPE'
syntax described here is a slight simplification of one written for
Scheme 48 by Jonathan Rees.  Unlike many record-defining macros or
special forms, it does not create any new identifiers.  Instead, the
names of the record type, predicate, constructor, and so on are all
listed explicitly in the source.  This has the following advantages:

   * It can be defined using a simple 'syntax-rules' macro in Scheme
     implementations that provide a procedural interface for creating
     record types.

   * It does not restrict users to a particular naming convention.

   * Tools like grep and GNU Emacs's tag facility will see the defining
     occurance of each identifier.


File: vicare-libs.info,  Node: srfi records spec,  Prev: srfi records rationale,  Up: srfi records

2.6.4 Specification
-------------------

The syntax of a record-type definition is:

     <command or definition>
       -> <record type definition>           ; addition to 8.1.6 in R5RS

     <record type definition>
       -> (define-record-type <type name>
            (<constructor name> <field tag> ...)
            <predicate name>
            <field spec> ...)

     <field spec> -> (<field tag> <accessor name>)
                  -> (<field tag> <accessor name> <modifier name>)

     <field tag> -> <identifier>
     <... name>  -> <identifier>

   'define-record-type' is generative: each use creates a new record
type that is distinct from all existing types, including other record
types and Scheme's predefined types.  Record-type definitions may only
occur at top-level (there are two possible semantics for "internal"
record-type definitions, generative and nongenerative, and no consensus
as to which is better).

   An instance of 'define-record-type' is equivalent to the following
definitions:

   * '<type name>' is bound to a representation of the record type
     itself.  Operations on record types, such as defining print
     methods, reflection, etc.  are left to other SRFIs.

   * '<constructor name>' is bound to a procedure that takes as many
     arguments as there are '<field tag>'s in the '(<constructor name>
     ...)' subform and returns a new '<type name>' record.  Fields whose
     tags are listed with '<constructor name>' have the corresponding
     argument as their initial value.  The initial values of all other
     fields are unspecified.

   * '<predicate name>' is a predicate that returns '#t' when given a
     value returned by '<constructor name>' and '#f' for everything
     else.

   * Each '<accessor name>' is a procedure that takes a record of type
     '<type name>' and returns the current value of the corresponding
     field.  It is an error to pass an accessor a value which is not a
     record of the appropriate type.

   * Each '<modifier name>' is a procedure that takes a record of type
     '<type name>' and a value which becomes the new value of the
     corresponding field; an unspecified value is returned.  It is an
     error to pass a modifier a first argument which is not a record of
     the appropriate type.

   Records are disjoint from the types listed in Section 4.2 of R5RS.

   'set!'-ing the value of any of these identifiers has no effect on the
behavior of any of their original values.

   The following:

     (define-record-type :pare
       (kons x y)
       pare?
       (x kar set-kar!)
       (y kdr))

defines KONS to be a constructor, KAR and KDR to be accessors, SET-KAR!
to be a modifier, and PARE? to be a predicate for ':pare's.

   Example:

     (pare? (kons 1 2))        => #t
     (pare? (cons 1 2))        => #f
     (kar (kons 1 2))          => 1
     (kdr (kons 1 2))          => 2
     (let ([k (kons 1 2)])
       (set-kar! k 3)
       (kar k))                => 3


File: vicare-libs.info,  Node: srfi let-values,  Next: srfi strings,  Prev: srfi records,  Up: srfi

2.7 SRFI-11 syntax for receiving multiple values
================================================

The library '(srfi :11)' is by Lars T Hansen as the reference
implementation for SRFI-11; see:

            <http://srfi.schemers.org/srfi-11/srfi-11.html>

for more details.

* Menu:

* srfi let-values license::     Let-Values document license.
* srfi let-values abstract::    Abstract.
* srfi let-values rationale::   Rationale.
* srfi let-values spec::        Specification.


File: vicare-libs.info,  Node: srfi let-values license,  Next: srfi let-values abstract,  Up: srfi let-values

2.7.1 Let-Values document license
---------------------------------

Copyright (C) 1999 Lars T Hansen.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi let-values abstract,  Next: srfi let-values rationale,  Prev: srfi let-values license,  Up: srfi let-values

2.7.2 Abstract
--------------

This SRFI introduces syntactic forms 'let-values' and 'let*-values' that
bind the values of expressions that return multiple values.


File: vicare-libs.info,  Node: srfi let-values rationale,  Next: srfi let-values spec,  Prev: srfi let-values abstract,  Up: srfi let-values

2.7.3 Rationale
---------------

'let-values' and 'let*-values' reduce the clutter of the
'call-with-values' notation for receiving multiple values.


File: vicare-libs.info,  Node: srfi let-values spec,  Prev: srfi let-values rationale,  Up: srfi let-values

2.7.4 Specification
-------------------

 -- Syntax: let-values ((FORMALS EXPRESSION) ...) BODY
     Each FORMALS should be a formal arguments list as for a 'lambda'
     expression (cf section 4.1.4 of the R5RS).

     The EXPRESSIONs are evaluated in the current environment, the
     variables of the FORMALS are bound to fresh locations, the return
     values of the EXPRESSIONs are stored in the variables, the BODY is
     evaluated in the extended environment, and the values of the last
     expression of BODY are returned.  The BODY is a 'tail-body' (cf
     section 3.5 of the R5RS).

     The matching of each FORMALS to values is as for the matching of
     FORMALS to arguments in a 'lambda' expression, and it is an error
     for an EXPRESSION to return a number of values that does not match
     its corresponding FORMALS.

     Examples:

          (let-values ([(a b . c) (values 1 2 3 4)])
            (list a b c))
          => (1 2 (3 4))

          (let ([a 'a]
                [b 'b]
                [x 'x]
                [y 'y])
            (let-values ([(a b) (values x y)]
                         [(x y) (values a b)])
              (list a b x y)))
          => (x y a b)

 -- Syntax: let*-values ((FORMALS EXPRESSION) ...) BODY
     Each FORMALS should be a formal arguments list as for a 'lambda'
     expression (cf section 4.1.4 of the R5RS).

     'let*-values' is similar to 'let-values', but the bindings are
     performed sequentially from left to right, and the region of a
     binding indicated by '(formals expression)' is that part of the
     'let*-values' expression to the right of the binding.  Thus the
     second binding is done in an environment in which the first binding
     is visible, and so on.

     Example:

          (let ([a 'a]
                [b 'b]
                [x 'x]
                [y 'y])
            (let*-values ([(a b) (values x y)]
                          [(x y) (values a b)])
              (list a b x y)))
          => (x y x y)


File: vicare-libs.info,  Node: srfi strings,  Next: srfi char-sets,  Prev: srfi let-values,  Up: srfi

2.8 SRFI-13 string library
==========================

The library '(srfi :13)' is by Olin Shivers as the reference
implementation for SRFI-13; see:

            <http://srfi.schemers.org/srfi-13/srfi-13.html>

for more details.

* Menu:

* srfi strings license::        Strings document license.
* srfi strings ratio::          Rationale.
* srfi strings spec::           Specification.
* srfi strings ack::            Acknowledgments.
* srfi strings references::     References.


File: vicare-libs.info,  Node: srfi strings license,  Next: srfi strings ratio,  Up: srfi strings

2.8.1 Strings document license
------------------------------

Certain portions of this document, the specific, marked segments of text
describing the R5RS procedures, were adapted with permission from the
R5RS report.

   All other text is copyright (C) 1998, 1999, 2000 Olin Shivers.  All
Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi strings ratio,  Next: srfi strings spec,  Prev: srfi strings license,  Up: srfi strings

2.8.2 Rationale
---------------

This SRFI defines a rich set of operations for manipulating strings;
these are frequently useful for scripting and other text-manipulation
applications.  The library's design was influenced by the string
libraries found in MIT Scheme, Gambit, RScheme, MzScheme, slib, Common
Lisp, Bigloo, guile, Chez, APL, Java, and the SML standard basis.

   All procedures involving character comparison are available in both
case-sensitive and case-insensitive forms.

   All functionality is available in substring and full-string forms.

* Menu:

* srfi strings ratio code-point::  Strings are code-point sequences.
* srfi strings ratio i18n::        Internationalisation and
                                   super-ASCII character types.
* srfi strings ratio naming::      Naming conventions.
* srfi strings ratio shared::      Shared storage.
* srfi strings ratio r5rs::        R4RS/R5RS procedures.
* srfi strings ratio extra::       Extra-SRFI recommendations.


File: vicare-libs.info,  Node: srfi strings ratio code-point,  Next: srfi strings ratio i18n,  Up: srfi strings ratio

2.8.2.1 Strings are code-point sequences
........................................

This SRFI considers strings simply to be a sequence of "code points" or
character encodings.  Operations such as comparison or reversal are
always done code point by code point.  See the comments below on
super-ASCII character types for implications that follow.

   It's entirely possible that a legal string might not be a sensible
"text" sequence.  For example, consider a string comprised entirely of
zero-width Unicode accent characters with no preceding base character to
modify; this is a legal string, albeit one that does not make a great
deal of sense when interpreted as a sequence of natural-language text.
The routines in this SRFI do not handle these "text" concerns; they
restrict themselves to the underlying view of strings as merely a
sequence of "code points".

   This SRFI defines string operations that are locale-independent and
context-independent.  While it is certainly important to have a
locale-sensitive comparison or collation procedure when processing text,
it is also important to have a suite of operations that are reliably
invariant for basic string processing; otherwise, a change of locale
could cause data structures such as hash tables, b-trees, symbol tables,
directories of filenames, etc.  to become corrupted.

   Locale-sensitive and context-sensitive text operations, such as
collation, are explicitly deferred to a subsequent, companion "text"
SRFI.


File: vicare-libs.info,  Node: srfi strings ratio i18n,  Next: srfi strings ratio naming,  Prev: srfi strings ratio code-point,  Up: srfi strings ratio

2.8.2.2 Internationalisation and super-ASCII character types
............................................................

The major issue confronting this SRFI is the existence of super-ASCII
character encodings, such as eight-bit Latin-1 or 16-bit and 32-bit
Unicode.  It is a design goal of this SRFI for the API to be portable
across string implementations based on at least these three standard
encodings.  Unfortunately, this places strong limitations on the API
design.  Here are some relevant issues.  Be warned that life in a
super-ASCII world is significantly more complex; there are no easy
answers for many of these issues.

Case mapping and case-folding
.............................

Upper-casing and lower-casing characters is complex in super-ASCII
encodings.

   * Some characters case-map to more than one character.  For example,
     the Latin-1 German 'eszet' character upper-cases to 'SS'.

        - This means that the R5RS function 'char-upcase' is not
          well-defined, since it is defined to produce a (single)
          character result.

        - It means that an in-place 'string-upcase!' procedure cannot be
          reliably defined, since the original string may not be long
          enough to contain the result; an N-character string might
          upcase to a 2N-character result.

        - It means that case-insensitive string-matching or searching is
          quite tricky.  For example, an N-character string S might
          match a 2N-character string S'.

   * Some characters case-map in different ways depending upon their
     surrounding context.  For example, the Unicode Greek capital sigma
     character downcases differently depending upon whether or not it is
     the final character in a word.  Again, this spells trouble for the
     simple R5RS char-downcase function.

   * Unicode defines three cases: lowercase, uppercase and titlecase.
     The distinction between uppercase and titlecase arises in the
     presence of Unicode's compound characters.  For example, Unicode
     has a single character representing the compound pair 'dz'.
     Uppercasing the 'dz' character produces the compound character
     'DZ', while titlecasing (or, as Americans say, capitalizing) it
     produces compound character 'Dz'.

   * Turkish actually has different case-mappings from other languages.

   The Unicode Consortium's web site:

                       <http://www.unicode.org/>

has detailed discussions of the issues.  See in particular technical
report 21 on case mappings:

            <http://www.unicode.org/unicode/reports/tr21/>

   SRFI-13 makes no attempt to deal with these issues; it uses a simple
one-to-ont locale-independent and context-independent case-mapping,
specifically Unicode's one-to-one case-mappings given in:

        <ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt>

   The format of this file is explained in:

        <ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html>

   Note that this means that German 'eszet' upper-cases to itself, not
'SS'.

   Case-mapping and case-folding operations in SRFI-13 are
locale-independent so that shifting locales won't wreck hash tables,
b-trees, symbol tables, etc.

String equality and string normalisation
........................................

Comparing strings for equality is complicated because in some cases
Unicode actually provides multiple encodings for the "same" character,
and because what we usually think of as a "character" can be represented
in Unicode as a sequence of several code-points.  For example, consider
the letter 'e' with an acute accent.  There is a single Unicode
character for this.  However, Unicode also allows one to represent this
with a two-character sequence: the 'e' character followed by a
zero-width acute-accent character.  As another example, Unicode provides
some Asian characters in "narrow" and "full" widths.

   There are multiple ways we might want to compare strings for
equality.  In (roughly) decreasing order of precision:

   * we might want a precise comparison of the actual encoding, so that
     '<e-acute>' would not compare equal to '<e, acute>';

   * we might want a "normalised" comparison, where these two sequences
     would compare equal;

   * we might want an even more-permissive normalisation, where
     visually-distinct properties of "the same" character would be
     ignored; for example, we might want narrow/full-width versions of
     the same Asian character to compare equal;

   * we might want comparisons that are insensitive to accents and
     diacritical marks;

   * we might want comparisons that are case-insensitive;

   * we might want comparisons that are insensitive to several of the
     above properties;

   * we might want ways to "normalise" strings into various canonical
     forms.

   This library does not address these complexities.  SRFI-13 string
equality is simply based upon comparing the encoding values used for the
characters.  Accent-insensitive and other types of comparison are not
provided; only a simple form of case-insensitive comparison is provided,
which uses the one-to-one case mappings specified by Unicode in:

        <ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt>

   These are adequate for "program" or "systems" use of strings (e.g.
to manipulate program identifiers and operating-system filenames).

String inequality
.................

Above and beyond the issues arising in string-equality, when we attempt
to order strings there are even further considerations.

   * French orders accents with right-to-left significance; the reverse
     of the significance of the characters.

   * Case-insensitive ordering is not well defined by simple code-point
     considerations, even for simple ASCII: there are punctuation
     characters between the ASCII's upper-case range of letters and its
     lower-case range (left-bracket, backslash, right-bracket, caret,
     underbar and backquote).  Does left-bracket compare less-than or
     greater-than 'a' in a case-insensitive comparison?

   * The German 'eszet' character should sort as if it were the pair of
     letters 'ss'.

   Unicode defines a complex set of machinery for ordering or
"collating" strings, which involves mapping each string to a multi-byte
sort key, and then doing simple lexicographic sorting with these keys.
These rules can be overlaid by additional domain-specific or
language-specific rules.  Again, this SRFI does not address these
issues.  SRFI-13 string ordering is strictly based upon a
character-by-character comparison of the values used for representing
the string.


File: vicare-libs.info,  Node: srfi strings ratio naming,  Next: srfi strings ratio shared,  Prev: srfi strings ratio i18n,  Up: srfi strings ratio

2.8.2.3 Naming conventions
..........................

This library contains a large number of procedures, but they follow a
consistent naming scheme, and are consistent with the conventions
developed in SRFI-1.  The names are composed of smaller lexemes in a
regular way that exposes the structure and relationships between the
procedures.  This should help the programmer to recall or reconstitute
the name of the particular procedure that he needs when writing his own
code.  In particular:

   * Procedures whose names end in '-ci' are case-insensitive variants.

   * Procedures whose names end in '!' are side-effecting variants.
     What values these procedures return is usually not specified.

   * The order of common parameters is consistent across the different
     procedures.

   * Left/right/both directionality: procedures that have left/right
     directional variants use the following convention:

     Direction       Suffix
     -------------------------
     left-to-right   'none'
     right-to-left   '-right'
     both            '-both'

     This is a general convention that was established in SRFI-1.  The
     value of a convention is proportional to the extent of its use.


File: vicare-libs.info,  Node: srfi strings ratio shared,  Next: srfi strings ratio r5rs,  Prev: srfi strings ratio naming,  Up: srfi strings ratio

2.8.2.4 Shared storage
......................

Some Scheme implementations, e.g.  Guile and T, provide ways to
construct substrings that share storage with other strings.  This
facility is called "shared-text substrings".  Shared-text substrings can
be used to eliminate the allocation and copying time and space required
to produce substrings, which can be a tremendous savings for some
applications, reducing a linear-time operation to constant time.
Additionally, some algorithms rely on the sharing property of these
substrings: the application assumes that if the underlying storage is
mutated, then all strings sharing that storage will show the change.
However, shared-text substrings are not a common feature; most Scheme
implementations do not provide them.

   SRFI-13 takes a middle ground with respect to shared-text substrings.
In particular, a Scheme implementation does not need to have shared-text
substrings in order to implement this SRFI.

   There is an additional form of storage sharing enabled by some
SRFI-13 procedures, even without the benefit of shared-text substrings.
In some cases, some SRFI-13 routines are allowed to return as a result
one of the strings that was passed in as a parameter.  For example, when
constructing a substring with the 'substring/shared' procedure, if the
requested substring is the entire string, the procedure is permitted
simply to return the original value.  That is:

     (eq? s (substring/shared s 0 (string-length s)))
     => #t or #f

whereas the R5RS 'substring' function is required to allocate a fresh
copy:

     (eq? s (substring s 0 (string-length s)))
     => #f

   In keeping with SRFI-13's general approach to sharing, compliant
implementations are allowed, but not required, to provide this kind of
sharing.  Hence, procedures may not rely upon sharing in these cases.

   Most procedures that permit results to share storage with inputs have
equivalent procedures that require allocating fresh storage for results.
If an application wishes to be sure a new, fresh string is allocated,
then these "pure" procedures should be used.

Fresh copy guaranteed        Sharing permitted
-----------------------------------------------------------------
'string-copy'                'substring/shared'
'string-copy'                'string-take' 'string-take-right'
'string-copy'                'string-drop' 'string-drop-right'
'string-concatenate'         'string-concatenate/shared'
'string-append'              'string-append/shared'
'string-concatenate-reverse' 'string-concatenate-reverse/shared'
                             'string-pad string-pad-right'
                             'string-trim string-trim-right'
                             'string-trim-both'
                             'string-filter string-delete'

   On the other hand, the functionality is present to allow one to write
efficient code without shared-text substrings.  You can write efficient
code that works by passing around start/end ranges indexing into a
string instead of simply building a shared-text substring.  The API
would be much simpler without this consideration; if we had cheap
shared-text substrings, all the start/end index parameters would vanish.
However, since SRFI-13 does not require implementations to provide
shared-text substrings, the extended API is provided.


File: vicare-libs.info,  Node: srfi strings ratio r5rs,  Next: srfi strings ratio extra,  Prev: srfi strings ratio shared,  Up: srfi strings ratio

2.8.2.5 R4RS/R5RS procedures
............................

The R4RS and R5RS reports define 22 string procedures.  The SRFI-13
package includes 8 of these exactly as defined, 3 in an extended,
backwards-compatible way, and drops the remaining 11 (whose
functionality is available via other bindings).

   The 8 procedures provided exactly as documented in the reports are:

     string?         make-string     string
     string-length   string-ref      string-set!
     string-append   list->string

   The 11 functions not included are:

     string=?        string-ci=?     string<?
     string-ci<?     string>?        string-ci>?
     string<=?       string-ci<=?    string>=?
     string-ci>=?    substring

the SRFI-13 package provides alternate bindings and extended
functionality.

   Additionally, the three extended procedures are:

     string-fill! s char [start end] -> unspecified
     string->list s [start end] -> char-list
     string-copy  s [start end] -> string

they are uniformly extended to take optional start/end parameters
specifying substring ranges.


File: vicare-libs.info,  Node: srfi strings ratio extra,  Prev: srfi strings ratio r5rs,  Up: srfi strings ratio

2.8.2.6 Extra-SRFI recommendations
..................................

This SRFI recommends the following:

   * A SRFI be defined for shared-text substrings, allowing programs to
     be written that actually rely on the shared-storage properties of
     these data structures.

   * A SRFI be defined for manipulating Unicode text: various
     normalisation operations, collation, searching, etc.  Collation
     operations might be parameterised by a "collation" structure
     representing collation rules for a particular locale or language.

     Alternatively, a data structure specifying collation rules could be
     activated with dynamic scope by special procedures, possibly
     overridden by allowing collation rules to be optional arguments to
     procedures that need to order strings, e.g.

          (with-locale* denmark-locale
            (lambda ()
              (f x)
              (g 42)))

          (with-locale taiwan-locale
            (f x)
            (h denmark-locale)
            (g 42))

          (set-locale! denmark-locale)

   * A SRFI be defined for manipulating characters that is portable
     across at least ASCII, Latin-1 and Unicode.

        - For backwards-compatibility, 'char-upcase' and 'char-downcase'
          should be defined to use the one-to-one locale-insensitive and
          context-insensitive case mappings given by Unicode's
          'UnicodeData.txt' table.

        - Numeric codes for standard functions that map between
          characters and integers should be required to use the
          Unicode/Latin-1/ASCII mapping.  This allows programmers to
          write portable code.

        - 'char-titlecase' be added to 'char-upcase' and
          'char-downcase'.

        - 'char-titlecase?' be added to 'char-upcase?' and
          'char-downcase?'.

        - Title/up/down-case functions be added to the
          character-processing suite which allow 1->n case maps by
          returning immutable, possibly-multi-character strings instead
          of single characters.  These case mappings need not be
          locale-sensitive or context-sensitive.

   These recommendations are not a part of the SRFI-13 spec.  Note also
that requiring a Unicode/Latin-1/ASCII interface to integer/char mapping
functions does not imply anything about the actual underlying encodings
of characters.


File: vicare-libs.info,  Node: srfi strings spec,  Next: srfi strings ack,  Prev: srfi strings ratio,  Up: srfi strings

2.8.3 Specification
-------------------

* Menu:

High level procedures

* srfi strings spec intro::     Introduction.
* srfi strings spec pred::      Predicates.
* srfi strings spec cons::      Constructors.
* srfi strings spec list::      List and string conversion.
* srfi strings spec select::    Selection.
* srfi strings spec modify::    Modification.
* srfi strings spec compar::    Comparison.
* srfi strings spec prefix::    Prefixes and suffixes.
* srfi strings spec search::    Searching.
* srfi strings spec case-map::  Alphabetic case mapping.
* srfi strings spec append::    Reverse and append.
* srfi strings spec fold::      Fold, unfold and map.
* srfi strings spec replicate:: Replicate and rotate.
* srfi strings spec misc::      Intertion, parsing, filtering
                                and deleting.


File: vicare-libs.info,  Node: srfi strings spec intro,  Next: srfi strings spec pred,  Up: srfi strings spec

2.8.3.1 Introduction
....................

In the procedure specifications of this SRFI the following conventions
for arguments requirement are used:

STR
     The argument is a string.

CHAR
     The argument is a character.

START
END
     Half-open string indices specifying a substring within a string
     argumen; when optional, they default to '0' and the length of the
     string, respectively.  When specified, it must be the case that:

          0 <= START <= END <= (string-length STR)

     for the corresponding parameter STR.  They typically restrict a
     procedure's action to the indicated substring.

PRED
     A unary character predicate procedure, returning a true/false value
     when applied to a character.

CHAR/CHAR-SET/PRED
     A value used to select/search for a character in a string:

        * If it is a character: it is used in an equality test.

        * If it is a character set: it is used as a membership test.

        * If it is a procedure: it is applied to the characters as a
          test predicate.

I
     The argument is an exact non-negative integer specifying an index
     into a string.

LEN
NCHARS
     Exact non-negative integers specifying a length of a string or some
     number of characters.

OBJ
     The argument may be any value at all.

   Passing values to procedures with these parameters that do not
satisfy these types is an error.

   An argument followed by '...' means zero-or-more elements; so the
procedure with the signature:

     sum-squares x ...

takes zero or more arguments (X ...), while the procedure with
signature:

     spell-check doc dict1 dict2 ...

takes two required parameters (DOC and DICT1) and zero or more optional
parameters (DICT2 ...).

   If a procedure is said to return "unspecified", this means that
nothing at all is said about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g.  as the value of an expression appearing as a
non-terminal subform of a begin expression.  Note that in R5RS, this
restricts such a procedure to returning a single value; non-R5RS systems
may not even provide this restriction.

   Unless explicitly stated, for all the functions: case-insensitive
comparison is done by case-folding characters with the operation

     (char-downcase (char-upcase c))

where the two case-mapping operations are assumed to be one-to-one,
locale-insensitive and context-insensitive, and compatible with the
one-to-one case mappings specified by Unicode's 'UnicodeData.txt' table:

        <ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt>

   Comparison is simply done on individual code-points of the string.


File: vicare-libs.info,  Node: srfi strings spec pred,  Next: srfi strings spec cons,  Prev: srfi strings spec intro,  Up: srfi strings spec

2.8.3.2 Predicates
..................

 -- Function: string? OBJ
     Return '#t' if OBJ is a string, otherwise return '#f'.

 -- Function: string-null? STR
     Return '#t' if STR is the empty string, otherwise return '#f'.

 -- Function: string-every CHAR/CHAR-SET/PRED STR
 -- Function: string-every CHAR/CHAR-SET/PRED STR START
 -- Function: string-every CHAR/CHAR-SET/PRED STR START END
     Check to see if the given criteria is true of every character in
     STR, proceeding from left (index START) to right (index END).

     If CHAR/CHAR-SET/PRED is a character, it is tested for equality
     with the elements of STR.

     If CHAR/CHAR-SET/PRED is a character set, the elements of STR are
     tested for membership in the set.

     If CHAR/CHAR-SET/PRED is a predicate procedure, it is applied to
     the elements of STR.  The predicate is "witness-generating": if
     'string-every' returns true, the returned true value is the one
     produced by the final application of the predicate to 'str[end]'.
     If 'string-every' is applied to an empty sequence of characters, it
     simply returns '#t'.

     If 'string-every' applies the predicate to the final element of the
     selected sequence (i.e.  's[end-1]'), that final application is a
     tail call.

     The names of this procedure does not end with a question mark; this
     is to indicate that, in the predicate case, they do not return a
     simple boolean ('#t' or '#f'), but a general value.

 -- Function: string-any CHAR/CHAR-SET/PRED STR
 -- Function: string-any CHAR/CHAR-SET/PRED STR START
 -- Function: string-any CHAR/CHAR-SET/PRED STR START END
     Check to see if the given criteria is true of every/any character
     in STR, proceeding from left (index START) to right (index END).

     If CHAR/CHAR-SET/PRED is a character, it is tested for equality
     with the elements of STR.

     If CHAR/CHAR-SET/PRED is a character set, the elements of STR are
     tested for membership in the set.

     If CHAR/CHAR-SET/PRED is a predicate procedure, it is applied to
     the elements of STR.  The predicate is "witness-generating": if
     'string-any' returns true, the returned true value is the one
     produced by the application of the predicate.

     If 'string-any' applies the predicate to the final element of the
     selected sequence (i.e.  's[end-1]'), that final application is a
     tail call.

     The name of this procedures does not end with a question mark; this
     is to indicate that, in the predicate case, they do not return a
     simple boolean ('#t' or '#f'), but a general value.


File: vicare-libs.info,  Node: srfi strings spec cons,  Next: srfi strings spec list,  Prev: srfi strings spec pred,  Up: srfi strings spec

2.8.3.3 Constructors
....................

 -- Function: make-string LEN
 -- Function: make-string LEN CHAR
     Return a newly allocated string of length LEN.  If CHAR is given,
     then all elements of the string are initialized to CHAR, otherwise
     the contents of the string are unspecified.

 -- Function: string CHAR ...
     Return a newly allocated string composed of the argument
     characters.

 -- Function: string-tabulate PROC LEN
     PROC is an integer-to-char procedure.  Construct a string of size
     LEN by applying PROC to each index to produce the corresponding
     string element.  The order in which PROC is applied to the indices
     is not specified.


File: vicare-libs.info,  Node: srfi strings spec list,  Next: srfi strings spec select,  Prev: srfi strings spec cons,  Up: srfi strings spec

2.8.3.4 List and string conversion
..................................

 -- Function: string->list STR
 -- Function: string->list STR START
 -- Function: string->list STR START END
 -- Function: list->string CHAR-LIST
     'string->list' returns a newly allocated list of the characters
     that make up the given string.  'list->string' returns a newly
     allocated string formed from the characters in the list CHAR-LIST,
     which must be a list of characters.  'string->list' and
     'list->string' are inverses so far as 'equal?' is concerned.

 -- Function: reverse-list->string CHAR-LIST
     An efficient implementation of '(compose list->string reverse)':

          (reverse-list->string '(#\a #\B #\c))
          => "cBa"

     This is a common idiom in the epilog of string-processing loops
     that accumulate an answer in a reverse-order list.  See also
     'string-concatenate-reverse' for the "chunked" variant.

 -- Function: string-join STRING-LIST
 -- Function: string-join STRING-LIST DELIMITER
 -- Function: string-join STRING-LIST DELIMITER GRAMMAR
     This procedure is a simple unparser: it pastes strings together
     using the DELIMITER string.

     The GRAMMAR argument is a symbol that determines how the delimiter
     is used, and defaults to 'infix'.  Supported values for GRAMMAR
     are:

     'infix'
          Means an infix or separator grammar: insert the delimiter
          between list elements.  An empty list will produce an empty
          string; note, however, that parsing an empty string with an
          infix or separator grammar is ambiguous: is it an empty list,
          or a list of one element, the empty string?

     'strict-infix'
          Means the same as 'infix', but will raise an error if given an
          empty list.

     'suffix'
          Means a suffix or terminator grammar: insert the delimiter
          after every list element.  This grammar has no ambiguities.

     'prefix'
          Means a prefix grammar: insert the delimiter before every list
          element.  This grammar has no ambiguities.

     The delimiter is the string used to delimit elements; it defaults
     to a single space.

     Examples:

          (string-join '("foo" "bar" "baz") ":")
          => "foo:bar:baz"

          (string-join '("foo" "bar" "baz") ":" 'suffix)
          => "foo:bar:baz:"

          ;; Infix grammar is ambiguous wrt empty list vs. empty string,
          (string-join '()   ":") => ""
          (string-join '("") ":") => ""

          ;; but suffix & prefix grammars are not.
          (string-join '()   ":" 'suffix) => ""
          (string-join '("") ":" 'suffix) => ":"


File: vicare-libs.info,  Node: srfi strings spec select,  Next: srfi strings spec modify,  Prev: srfi strings spec list,  Up: srfi strings spec

2.8.3.5 Selection
.................

 -- Function: string-length STR
     Return the number of characters in the string STR.

 -- Function: string-ref STR I
     Return character 's[i]' using zero-origin indexing.  I must be a
     valid index of STR.

 -- Function: string-copy STR
 -- Function: string-copy STR START
 -- Function: string-copy STR START END
 -- Function: substring/shared STR START
 -- Function: substring/shared STR START END
     'substring/shared' returns a string whose contents are the
     characters of STR beginning with index START (inclusive) and ending
     with index END (exclusive).  It differs from the R5RS 'substring'
     in two ways:

        * The END parameter is optional, not required.

        * 'substring/shared' may return a value that shares memory with
          STR or is 'eq?' to STR.

     'string-copy' is extended from its R5RS definition by the addition
     of its optional START/END parameters.  In contrast to
     'substring/shared', it is guaranteed to produce a freshly-allocated
     string.

     Use 'string-copy' when you want to indicate explicitly in your code
     that you wish to allocate new storage; use 'substring/shared' when
     you don't care if you get a fresh copy or share storage with the
     original string.

     Examples:

          (string-copy "Beta substitution")
          => "Beta substitution"

          (string-copy "Beta substitution" 1 10)
          => "eta subst"

          (string-copy "Beta substitution" 5)
          => "substitution"

 -- Function: string-copy! DST.STR DST.START SRC.STR
 -- Function: string-copy! DST.STR DST.START SRC.STR SRC.START
 -- Function: string-copy! DST.STR DST.START SRC.STR SRC.START SRC.END
     Copy the sequence of characters from index range from SRC.START
     included and SRC.END excluded in the string SRC.STR to the string
     DST.STR, beginning at index DST.START.  The characters are copied
     left-to-right or right-to-left as needed; the copy is guaranteed to
     work, even if DST.STR and SRC.STR are the same string.

     It is an error if the copy operation runs off the end of the target
     string, e.g.

          (string-copy! (string-copy "Microsoft") 0
                        "Regional Microsoft Operating Companies")
          error-> not enough room in destination string

 -- Function: string-take STR NCHARS
 -- Function: string-drop STR NCHARS
 -- Function: string-take-right STR NCHARS
 -- Function: string-drop-right STR NCHARS
     'string-take' returns the first NCHARS of STR.

     'string-drop' returns all but the first NCHARS of STR.

     'string-take-right' returns the last NCHARS of STR.

     'string-drop-right' returns all but the last NCHARS of STR.

     If these procedures produce the entire string, they may return
     either STR or a copy of STR; in some implementations, proper
     substrings may share memory with STR.

     Examples:

          (string-take "Pete Szilagyi" 6) => "Pete S"
          (string-drop "Pete Szilagyi" 6) => "zilagyi"

          (string-take-right "Beta rules" 5) => "rules"
          (string-drop-right "Beta rules" 5) => "Beta "

     It is an error to take or drop more characters than are in the
     string:

          (string-take "foo" 37) => error

 -- Function: string-pad STR LEN
 -- Function: string-pad STR LEN CHAR
 -- Function: string-pad STR LEN CHAR START
 -- Function: string-pad STR LEN CHAR START END
 -- Function: string-pad-right STR LEN
 -- Function: string-pad-right STR LEN CHAR
 -- Function: string-pad-right STR LEN CHAR START
 -- Function: string-pad-right STR LEN CHAR START END
     Build a string of length LEN comprised of STR padded on the left
     (right) by as many occurrences of the character CHAR as needed.  If
     STR has more than len chars, it is truncated on the left (right) to
     length LEN.  CHAR defaults to '#\space'.

     If 'LEN <= (END - START)', the returned value is allowed to share
     storage with STR, or be exactly STR if 'LEN = (END - START)'.

     Examples:

          (string-pad     "325" 5) => "  325"
          (string-pad   "71325" 5) => "71325"
          (string-pad "8871325" 5) => "71325"

 -- Function: string-trim STR
 -- Function: string-trim STR CHAR/CHAR-SET/PRED
 -- Function: string-trim STR CHAR/CHAR-SET/PRED START
 -- Function: string-trim STR CHAR/CHAR-SET/PRED START END
 -- Function: string-trim-right STR
 -- Function: string-trim-right STR CHAR/CHAR-SET/PRED
 -- Function: string-trim-right STR CHAR/CHAR-SET/PRED START
 -- Function: string-trim-right STR CHAR/CHAR-SET/PRED START END
 -- Function: string-trim-both STR
 -- Function: string-trim-both STR CHAR/CHAR-SET/PRED
 -- Function: string-trim-both STR CHAR/CHAR-SET/PRED START
 -- Function: string-trim-both STR CHAR/CHAR-SET/PRED START END
     Trim STR by skipping over all characters on the left/on the
     right/on both sides that satisfy the second parameter
     CHAR/CHAR-SET/PRED:

        * if it is a character CHAR, characters equal to CHAR are
          trimmed;

        * if it is a char set CHAR-SET, characters contained in CHAR-SET
          are trimmed;

        * if it is a predicate PRED, it is a test predicate that is
          applied to the characters in STR; a character causing it to
          return true is skipped.

     CHAR/CHAR-SET/PRED defaults to the character set
     'char-set:whitespace' defined in SRFI-14.

     If no trimming occurs, these functions may return either STR or a
     copy of STR; in some implementations, proper substrings may share
     memory with STR.

     Example:

          (string-trim-both "  The outlook wasn't brilliant,  \n\r")
          => "The outlook wasn't brilliant,"


File: vicare-libs.info,  Node: srfi strings spec modify,  Next: srfi strings spec compar,  Prev: srfi strings spec select,  Up: srfi strings spec

2.8.3.6 Modification
....................

 -- Function: string-set! STR I CHAR
     I must be a valid index of STR.  Store CHAR in element I of STR.

          *NOTE* Constant string literals appearing in code are to be
          considered immutable; mutating them leads to undefined
          results.

 -- Function: string-fill! STR CHAR
 -- Function: string-fill! STR CHAR START
 -- Function: string-fill! STR CHAR START END
     Store CHAR in every selected element of STR.


File: vicare-libs.info,  Node: srfi strings spec compar,  Next: srfi strings spec prefix,  Prev: srfi strings spec modify,  Up: srfi strings spec

2.8.3.7 Comparison
..................

 -- Function: string-compare STR1 STR2 PROC< PROC= PROC>
 -- Function: string-compare STR1 STR2 PROC< PROC= PROC> START1
 -- Function: string-compare STR1 STR2 PROC< PROC= PROC> START1 END1
 -- Function: string-compare STR1 STR2 PROC< PROC= PROC> START1 END1
          START2
 -- Function: string-compare STR1 STR2 PROC< PROC= PROC> START1 END1
          START2 END2
     Apply PROC<, PROC=, or PROC> to the mismatch index, depending upon
     whether STR1 is less than, equal to, or greater than STR2.  The
     "mismatch index" is the largest index I such that for every '0 <= j
     < i', 's1[j] = s2[j]'; that is, I is the first position that
     doesn't match.

     The optional START/END indices restrict the comparison to the
     indicated substrings of STR1 and STR2.  The mismatch index is
     always an index into STR1; in the case of PROC=, it is always END1;
     we observe the protocol in this redundant case for uniformity.

          (string-compare "The cat in the hat" "abcdefgh"
                          values values values
                          4 6         ; Select "ca"
                          2 4)        ; & "cd"
          => 5    ; Index of S1's "a"

     True text collation is not handled by this SRFI.

 -- Function: string-compare-ci STR1 STR2 PROC< PROC= PROC>
 -- Function: string-compare-ci STR1 STR2 PROC< PROC= PROC> START1
 -- Function: string-compare-ci STR1 STR2 PROC< PROC= PROC> START1 END1
 -- Function: string-compare-ci STR1 STR2 PROC< PROC= PROC> START1 END1
          START2
 -- Function: string-compare-ci STR1 STR2 PROC< PROC= PROC> START1 END1
          START2 END2
     Case-insensitive variant of 'string-compare'.

   The following procedures are the lexicographic extensions to strings
of the corresponding orderings on characters.  For example, 'string<' is
the lexicographic ordering on strings induced by the ordering 'char<?'
on characters.  If two strings differ in length but are the same up to
the length of the shorter string, the shorter string is considered to be
lexicographically less than the longer string.

   The optional START/END indices restrict the comparison to the
indicated substrings of STR1 and STR2.

   True text collation is not handled by this SRFI.

 -- Function: string= STR1 STR2
 -- Function: string= STR1 STR2 START1
 -- Function: string= STR1 STR2 START1 END1
 -- Function: string= STR1 STR2 START1 END1 START2
 -- Function: string= STR1 STR2 START1 END1 START2 END2
     Lexicographic ordering on strings induced by the ordering 'char=?'
     on characters.

 -- Function: string<> STR1 STR2
 -- Function: string<> STR1 STR2 START1
 -- Function: string<> STR1 STR2 START1 END1
 -- Function: string<> STR1 STR2 START1 END1 START2
 -- Function: string<> STR1 STR2 START1 END1 START2 END2
     Lexicographic ordering on strings induced by the negation of the
     ordering 'char=?' on characters.

 -- Function: string< STR1 STR2
 -- Function: string< STR1 STR2 START1
 -- Function: string< STR1 STR2 START1 END1
 -- Function: string< STR1 STR2 START1 END1 START2
 -- Function: string< STR1 STR2 START1 END1 START2 END2
     Lexicographic ordering on strings induced by the ordering 'char<?'
     on characters.

 -- Function: string> STR1 STR2
 -- Function: string> STR1 STR2 START1
 -- Function: string> STR1 STR2 START1 END1
 -- Function: string> STR1 STR2 START1 END1 START2
 -- Function: string> STR1 STR2 START1 END1 START2 END2
     Lexicographic ordering on strings induced by the ordering 'char>?'
     on characters.

 -- Function: string<= STR1 STR2
 -- Function: string<= STR1 STR2 START1
 -- Function: string<= STR1 STR2 START1 END1
 -- Function: string<= STR1 STR2 START1 END1 START2
 -- Function: string<= STR1 STR2 START1 END1 START2 END2
     Lexicographic ordering on strings induced by the ordering 'char<=?'
     on characters.

 -- Function: string>= STR1 STR2
 -- Function: string>= STR1 STR2 START1
 -- Function: string>= STR1 STR2 START1 END1
 -- Function: string>= STR1 STR2 START1 END1 START2
 -- Function: string>= STR1 STR2 START1 END1 START2 END2
     Lexicographic ordering on strings induced by the ordering 'char>=?'
     on characters.

 -- Function: string-ci= STR1 STR2
 -- Function: string-ci= STR1 STR2 START1
 -- Function: string-ci= STR1 STR2 START1 END1
 -- Function: string-ci= STR1 STR2 START1 END1 START2
 -- Function: string-ci= STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant of 'string='.

 -- Function: string-ci<> STR1 STR2
 -- Function: string-ci<> STR1 STR2 START1
 -- Function: string-ci<> STR1 STR2 START1 END1
 -- Function: string-ci<> STR1 STR2 START1 END1 START2
 -- Function: string-ci<> STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant of 'string<>'.

 -- Function: string-ci< STR1 STR2
 -- Function: string-ci< STR1 STR2 START1
 -- Function: string-ci< STR1 STR2 START1 END1
 -- Function: string-ci< STR1 STR2 START1 END1 START2
 -- Function: string-ci< STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant of 'string<'.

 -- Function: string-ci> STR1 STR2
 -- Function: string-ci> STR1 STR2 START1
 -- Function: string-ci> STR1 STR2 START1 END1
 -- Function: string-ci> STR1 STR2 START1 END1 START2
 -- Function: string-ci> STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant of 'string>'.

 -- Function: string-ci<= STR1 STR2
 -- Function: string-ci<= STR1 STR2 START1
 -- Function: string-ci<= STR1 STR2 START1 END1
 -- Function: string-ci<= STR1 STR2 START1 END1 START2
 -- Function: string-ci<= STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant of 'string<='.

 -- Function: string-ci>= STR1 STR2
 -- Function: string-ci>= STR1 STR2 START1
 -- Function: string-ci>= STR1 STR2 START1 END1
 -- Function: string-ci>= STR1 STR2 START1 END1 START2
 -- Function: string-ci>= STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant of 'string>='.

 -- Function: string-hash STR
 -- Function: string-hash STR BOUND
 -- Function: string-hash STR BOUND START
 -- Function: string-hash STR BOUND START END
 -- Function: string-hash-ci STR
 -- Function: string-hash-ci STR BOUND
 -- Function: string-hash-ci STR BOUND START
 -- Function: string-hash-ci STR BOUND START END
     Compute a hash value for the string STR and return it as a fixnum.
     BOUND is a non-negative exact integer specifying the range of the
     hash function.  A positive value restricts the return value to the
     range between '0' included and BOUND excluded.

     If BOUND is either zero or not given, it defaults to
     '(greatest-fixnum)'.

     The optional START/END indices restrict the hash operation to the
     indicated substring of STR.

     'string-hash-ci' is the case-insensitive variant.

     Invariants:

          (<= 0 (string-hash s b) (- b 1)) ; When B > 0.

          (string=    s1 s2)
          => (= (string-hash s1 b)    (string-hash s2 b))

          (string-ci= s1 s2)
          => (= (string-hash-ci s1 b) (string-hash-ci s2 b))


File: vicare-libs.info,  Node: srfi strings spec prefix,  Next: srfi strings spec search,  Prev: srfi strings spec compar,  Up: srfi strings spec

2.8.3.8 Prefixes and suffixes
.............................

 -- Function: string-prefix-length STR1 STR2
 -- Function: string-prefix-length STR1 STR2 START1
 -- Function: string-prefix-length STR1 STR2 START1 END1
 -- Function: string-prefix-length STR1 STR2 START1 END1 START2
 -- Function: string-prefix-length STR1 STR2 START1 END1 START2 END2
     Return the length of the longest common prefix of the two selected
     substrings strings.  This is equivalent to the "mismatch index" for
     the strings (modulo the START index offsets).

 -- Function: string-prefix-length-ci STR1 STR2
 -- Function: string-prefix-length-ci STR1 STR2 START1
 -- Function: string-prefix-length-ci STR1 STR2 START1 END1
 -- Function: string-prefix-length-ci STR1 STR2 START1 END1 START2
 -- Function: string-prefix-length-ci STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant.

 -- Function: string-suffix-length STR1 STR2
 -- Function: string-suffix-length STR1 STR2 START1
 -- Function: string-suffix-length STR1 STR2 START1 END1
 -- Function: string-suffix-length STR1 STR2 START1 END1 START2
 -- Function: string-suffix-length STR1 STR2 START1 END1 START2 END2
     Return the length of the longest common suffix of the two selected
     substrings strings.

 -- Function: string-suffix-length-ci STR1 STR2
 -- Function: string-suffix-length-ci STR1 STR2 START1
 -- Function: string-suffix-length-ci STR1 STR2 START1 END1
 -- Function: string-suffix-length-ci STR1 STR2 START1 END1 START2
 -- Function: string-suffix-length-ci STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant.

 -- Function: string-prefix? STR1 STR2
 -- Function: string-prefix? STR1 STR2 START1
 -- Function: string-prefix? STR1 STR2 START1 END1
 -- Function: string-prefix? STR1 STR2 START1 END1 START2
 -- Function: string-prefix? STR1 STR2 START1 END1 START2 END2
     Return '#t' if the selected substring of STR1 is a prefix of the
     selected substring of STR2; otherwise return '#f'.

 -- Function: string-prefix-ci? STR1 STR2
 -- Function: string-prefix-ci? STR1 STR2 START1
 -- Function: string-prefix-ci? STR1 STR2 START1 END1
 -- Function: string-prefix-ci? STR1 STR2 START1 END1 START2
 -- Function: string-prefix-ci? STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant.

 -- Function: string-suffix? STR1 STR2
 -- Function: string-suffix? STR1 STR2 START1
 -- Function: string-suffix? STR1 STR2 START1 END1
 -- Function: string-suffix? STR1 STR2 START1 END1 START2
 -- Function: string-suffix? STR1 STR2 START1 END1 START2 END2
     Return '#t' if the selected substring of STR1 is a suffix of the
     selected substring of STR2; otherwise return '#f'.

 -- Function: string-suffix-ci? STR1 STR2
 -- Function: string-suffix-ci? STR1 STR2 START1
 -- Function: string-suffix-ci? STR1 STR2 START1 END1
 -- Function: string-suffix-ci? STR1 STR2 START1 END1 START2
 -- Function: string-suffix-ci? STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant.


File: vicare-libs.info,  Node: srfi strings spec search,  Next: srfi strings spec case-map,  Prev: srfi strings spec prefix,  Up: srfi strings spec

2.8.3.9 Searching
.................

The following functions scan a string for the first character which:

   * Equals the argument CHAR/CHAR-SET/PRED if it is a character.

   * Is in the argument CHAR/CHAR-SET/PRED if it is a character set.

   * Satisfies the argument CHAR/CHAR-SET/PRED if it is a predicate
     procedure.

   The START and END arguments specify the beginning and end indices of
the search; the search includes the START index, but not the END index.
Be careful of "fencepost" considerations: when searching right-to-left,
the first index considered is END-1, whereas when searching
left-to-right, the first index considered is START.

   That is, the START/END indices describe a same half-open interval
'[START, END)' in these procedures that they do in all the other SRFI-13
procedures.

 -- Function: string-index STR CHAR/CHAR-SET/PRED
 -- Function: string-index STR CHAR/CHAR-SET/PRED START
 -- Function: string-index STR CHAR/CHAR-SET/PRED START END
     Search through the string from the left, returning the index of the
     first occurrence of a character matching the criterion; if no match
     is found: return '#f'.

 -- Function: string-index-right STR CHAR/CHAR-SET/PRED
 -- Function: string-index-right STR CHAR/CHAR-SET/PRED START
 -- Function: string-index-right STR CHAR/CHAR-SET/PRED START END
     Search through the string from the right, returning the index of
     the first occurrence of a character matching the criterion; if no
     match is found: return '#f'.

 -- Function: string-skip STR CHAR/CHAR-SET/PRED
 -- Function: string-skip STR CHAR/CHAR-SET/PRED START
 -- Function: string-skip STR CHAR/CHAR-SET/PRED START END
     Search the string from the left, returning the index of the first
     char that does *not* satisfy the criterion; if no match is found:
     return '#f'.

     E.g., to skip over initial whitespace, say:

          (cond ((string-skip s char-set:whitespace) =>
                 (lambda (i) ...)) ;s[i] is not whitespace
                ...)

 -- Function: string-skip-right STR CHAR/CHAR-SET/PRED
 -- Function: string-skip-right STR CHAR/CHAR-SET/PRED START
 -- Function: string-skip-right STR CHAR/CHAR-SET/PRED START END
     Search the string from the right, returning the index of the first
     char that does *not* satisfy the criterion; if no match is found:
     return '#f'.

 -- Function: string-count STR CHAR/CHAR-SET/PRED
 -- Function: string-count STR CHAR/CHAR-SET/PRED START
 -- Function: string-count STR CHAR/CHAR-SET/PRED START END
     Return a count of the number of characters in STR that satisfy the
     CHAR/CHAR-SET/PRED argument.  If this argument is a procedure, it
     is applied to the character as a predicate; if it is a character
     set, the character is tested for membership; if it is a character,
     it is used in an equality test.

 -- Function: string-contains STR1 STR2
 -- Function: string-contains STR1 STR2 START1
 -- Function: string-contains STR1 STR2 START1 END1
 -- Function: string-contains STR1 STR2 START1 END1 START2
 -- Function: string-contains STR1 STR2 START1 END1 START2 END2
     Return true if the string STR1 contains string STR2; otherwise
     return '#f'.  Return the index in STR1 where STR2 occurs as a
     substring.  The optional START/END indices restrict the operation
     to the indicated substrings.

     The returned index is in the range '[START1, END1)'.  A successful
     match must lie entirely in the '[START1, END1)' range of STR1.

     Example:

          ;; Searches "a geek"
          (string-contains "eek -- what a geek." "ee" 12 18)
          => 15

 -- Function: string-contains-ci STR1 STR2
 -- Function: string-contains-ci STR1 STR2 START1
 -- Function: string-contains-ci STR1 STR2 START1 END1
 -- Function: string-contains-ci STR1 STR2 START1 END1 START2
 -- Function: string-contains-ci STR1 STR2 START1 END1 START2 END2
     Case-insensitive variant.


File: vicare-libs.info,  Node: srfi strings spec case-map,  Next: srfi strings spec append,  Prev: srfi strings spec search,  Up: srfi strings spec

2.8.3.10 Alphabetic case mapping
................................

 -- Function: string-titlecase STR
 -- Function: string-titlecase STR START
 -- Function: string-titlecase STR START END
     For every character 'ch' in the selected range of STR, if 'ch' is
     preceded by a cased character, it is downcased; otherwise it is
     titlecased.  Return the result string and does *not* alter the STR
     argument.

     Examples:

          (string-titlecase "--capitalize tHIS sentence.")
          => "--Capitalize This Sentence."

          (string-titlecase "see Spot run. see Nix run.")
          => "See Spot Run. See Nix Run."

          (string-titlecase "3com makes routers.")
          => "3Com Makes Routers."

     Note that if a START index is specified, then the character
     preceding 'STR[START]' has no effect on the titlecase decision for
     character 'STR[START]':

          (string-titlecase "greasy fried chicken" 2)
          => "Easy Fried Chicken"

     Titlecase and cased information must be compatible with the Unicode
     specification.

 -- Function: string-titlecase! STR
 -- Function: string-titlecase! STR START
 -- Function: string-titlecase! STR START END
     In-place side-effecting variant.

 -- Function: string-upcase STR
 -- Function: string-upcase STR START
 -- Function: string-upcase STR START END
     Raise the case of the selected alphabetic characters in the string.
     Return the result string and does *not* alter the STR argument.

 -- Function: string-upcase! STR
 -- Function: string-upcase! STR START
 -- Function: string-upcase! STR START END
     In-place side-effecting variant.

 -- Function: string-downcase STR
 -- Function: string-downcase STR START
 -- Function: string-downcase STR START END
     Lower the case of the selected alphabetic characters in the string.
     Return the result string and does *not* alter the STR argument.

 -- Function: string-downcase! STR
 -- Function: string-downcase! STR START
 -- Function: string-downcase! STR START END
     In-place side-effecting variant.


File: vicare-libs.info,  Node: srfi strings spec append,  Next: srfi strings spec fold,  Prev: srfi strings spec case-map,  Up: srfi strings spec

2.8.3.11 Reverse and append
...........................

 -- Function: string-reverse STR
 -- Function: string-reverse STR START
 -- Function: string-reverse STR START END
     Reverse the string; return the result string and does *not* alter
     its STR argument.

     Examples:

          (string-reverse "Able was I ere I saw elba.")
          => ".able was I ere I saw elbA"

          ;;; In-place rotate-left, the Bell Labs way:
          (lambda (s i)
            (let ([i (modulo i (string-length s))])
              (string-reverse! s 0 i)
              (string-reverse! s i)
              (string-reverse! s)))

          *Unicode note* Reversing a string simply reverses the sequence
          of code-points it contains.  So a zero-width accent character
          a coming after a base character B in string STR would come out
          before B in the reversed result.

 -- Function: string-reverse! STR
 -- Function: string-reverse! STR START
 -- Function: string-reverse! STR START END
     In-place side-effecting variant.

 -- Function: string-append STR ...
     Return a newly allocated string whose characters form the
     concatenation of the given strings.

 -- Function: string-concatenate STRING-LIST
     Append the elements of STRING-LIST together into a single string.
     Guaranteed to return a freshly allocated string.

     Note that the '(apply string-append string-list)' idiom is not
     robust for long lists of strings, as some Scheme implementations
     limit the number of arguments that may be passed to an n-ary
     procedure.

 -- Function: string-concatenate/shared STRING-LIST
 -- Function: string-append/shared STR ...
     These two procedures are variants of 'string-concatenate' and
     'string-append' that are permitted to return results that share
     storage with their parameters.  In particular, if
     'string-append/shared' is applied to just one argument, it may
     return exactly that argument, whereas 'string-append' is required
     to allocate a fresh string.

 -- Function: string-concatenate-reverse STRING-LIST
 -- Function: string-concatenate-reverse STRING-LIST FINAL-STRING
 -- Function: string-concatenate-reverse STRING-LIST FINAL-STRING END
     With no optional arguments, this function is equivalent to:

          (string-concatenate (reverse STRING-LIST))

     If the optional argument FINAL-STRING is specified, it is consed
     onto the beginning of STRING-LIST before performing the
     'list-reverse' and 'string-concatenate' operations.

     If the optional argument END is given, only the first end
     characters of FINAL-STRING are added to the string list, thus
     producing:

          (string-concatenate
            (reverse (cons (substring/shared FINAL-STRING 0 END)
                           STRING-LIST)))

     Example:

          (string-concatenate-reverse '(" must be" "Hello, I")
                                      " going.XXXX"
                                      7)
          => "Hello, I must be going."

     This procedure is useful in the construction of procedures that
     accumulate character data into lists of string buffers, and wish to
     convert the accumulated data into a single string when done.

          *Unicode note* Reversing a string simply reverses the sequence
          of code-points it contains.  So a zero-width accent character
          'ac' coming after a base character 'bc' in string STR would
          come out before 'bc' in the reversed result.

 -- Function: string-concatenate-reverse/shared STRING-LIST
 -- Function: string-concatenate-reverse/shared STRING-LIST FINAL-STRING
 -- Function: string-concatenate-reverse/shared STRING-LIST FINAL-STRING
          END
     Variant which is permitted to return results that share storage
     with its arguments.


File: vicare-libs.info,  Node: srfi strings spec fold,  Next: srfi strings spec replicate,  Prev: srfi strings spec append,  Up: srfi strings spec

2.8.3.12 Fold, unfold and map
.............................

 -- Function: string-map PROC STR
 -- Function: string-map PROC STR START
 -- Function: string-map PROC STR START END
     PROC is a char-to-char procedure and it is mapped over the selected
     substring of STR; return the result string and does not alter its
     STR parameter.

          *NOTE* The order in which PROC is applied to the elements of
          STR is not specified.

 -- Function: string-map! PROC STR
 -- Function: string-map! PROC STR START
 -- Function: string-map! PROC STR START END
     In-place side-effecting variant.

 -- Function: string-for-each PROC STR
 -- Function: string-for-each PROC STR START
 -- Function: string-for-each PROC STR START END
     Apply PROC to each character in STR from start to end in increasing
     order.  Return unspecified values.

 -- Function: string-for-each-index PROC STR
 -- Function: string-for-each-index PROC STR START
 -- Function: string-for-each-index PROC STR START END
     Apply PROC to each index of the selected substring of STR, in
     increasing order from start to end.  This is simply a method of
     looping over a string that is guaranteed to be safe and correct.
     Example:

          (let* ((len (string-length s))
                 (ans (make-string len)))
            (string-for-each-index
              (lambda (i)
                (string-set! ans (- len i) (string-ref s i)))
              s)
            ans)

 -- Function: string-fold KONS KNIL STR
 -- Function: string-fold KONS KNIL STR START
 -- Function: string-fold KONS KNIL STR START END
 -- Function: string-fold-right KONS KNIL STR
 -- Function: string-fold-right KONS KNIL STR START
 -- Function: string-fold-right KONS KNIL STR START END
     These are the fundamental iterators for strings.

     The left-fold operator maps the KONS procedure across the string
     from left to right:

          (... (kons s[2] (kons s[1] (kons s[0] knil))))

     in other words, 'string-fold' obeys the (tail) recursion:

          (string-fold kons knil s start end)
          == (string-fold kons (kons s[start] knil) start+1 end)

     The right-fold operator maps the KONS procedure across the string
     from right to left:

          (kons s[0]
                (... (kons s[end-3]
                           (kons s[end-2]
                                 (kons s[end-1] knil)))))

     obeying the (tail) recursion:

          (string-fold-right kons knil s start end)
          == (string-fold-right kons (kons s[end-1] knil) start end-1)

     Examples:

          ;;; Convert a string to a list of chars.
          (string-fold-right cons '() s)

          ;;; Count the number of lower-case characters in a string.
          (string-fold (lambda (c count)
                         (if (char-lower-case? c)
                             (+ count 1)
                           count))
                        0
                        s)

          ;;; Double every backslash character in S.
          (let* ((ans-len (string-fold (lambda (c sum)
                                         (+ sum (if (char=? c #\\)
                                                    2
                                                  1)))
                                       0 s))
                 (ans     (make-string ans-len)))
            (string-fold (lambda (c i)
                           (let ((i (if (char=? c #\\)
                                        (begin
                                          (string-set! ans i #\\)
                                          (+ i 1))
                                      i)))
                              (string-set! ans i c)
                              (+ i 1)))
                         0 s)
            ans)

     The right-fold combinator is sometimes called a "catamorphism".

 -- Function: string-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
 -- Function: string-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STR
 -- Function: string-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STR MAKE-FINAL
     This is a fundamental constructor for strings.

     MAKE-SEED
          Is used to generate a series of "seed" values from the initial
          seed:

               FIRST-SEED
               (MAKE-SEED FIRST-SEED)      => seed2
               (MAKE-SEED seed2)           => seed3
               (MAKE-SEED seed3)           => seed4
               ...

     STOP?
          Tells us when to stop; when it returns true when applied to
          one of the seed values.

     SEED->CHAR
          Maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in a
          left-to-right order.

     BASE-STRING
          Is the optional initial/leftmost portion of the constructed
          string; it defaults to the empty string.

     MAKE-FINAL
          Is applied to the terminal seed value (on which STOP? returns
          true) to produce the final/rightmost portion of the
          constructed string.  It defaults to:

               (lambda (x) "")

     More precisely, the following (simple, inefficient) definitions
     hold:

          ;;; Iterative
          (define (string-unfold stop? seed->char make-seed
                                 first-seed base-str make-final)
            (let loop ((seed first-seed)
                       (ans  base-str))
              (if (stop? seed)
                  (string-append ans (make-final seed))
                (loop (make-seed seed)
                      (string-append ans (string (seed->char seed)))))))

          ;;; Recursive
          (define (string-unfold stop? seed->char make-seed
                                 first-seed base-str make-final)
            (string-append
               base-str
               (let recur ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (string-append (string (seed->char seed))
                                  (recur  (make-seed  seed)))))))

     'string-unfold' is a fairly powerful string constructor; we can use
     it to convert a list to a string, read a port into a string,
     reverse a string, copy a string, and so forth.  Examples:

          (port->string p)
          == (string-unfold eof-object? values
                       (lambda (x) (read-char p))
                       (read-char p))

          (list->string lis)
          == (string-unfold null? car cdr lis)

          (string-tabulate f size)
          == (string-unfold
                       (lambda (i) (= i size))
                       f add1 0)

     to map SEED->CHAR over a list LIS, producing a string:

          (string-unfold null? (compose f car) cdr lis)

     Interested functional programmers may enjoy noting that
     'string-fold-right' and 'string-unfold' are in some sense inverses.
     That is, given operations KNULL?, KAR, KDR, KONS, and KNIL
     satisfying:

          (kons (kar x) (kdr x))  == x
          (knull? knil)           == #t

     then:

          (string-fold-right kons knil
             (string-unfold knull? kar kdr x))
          == x

     and:

          (string-unfold knull? kar kdr
             (string-fold-right kons knil s))
          == s

     The final string constructed does not share storage with either
     BASE-STR or the value produced by MAKE-FINAL.

     This combinator sometimes is called an "anamorphism".

 -- Function: string-unfold-right STOP? SEED->CHAR MAKE-SEED FIRST-SEED
 -- Function: string-unfold-right STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STR
 -- Function: string-unfold-right STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-STR MAKE-FINAL
     This is a fundamental constructor for strings.

     MAKE-SEED
          Is used to generate a series of "seed" values from the initial
          FIRST-SEED:

               FIRST-SEED
               (MAKE-SEED FIRST-SEED)      => seed2
               (MAKE-SEED seed2)           => seed3
               (MAKE-SEED seed3)           => seed4
               ...

     STOP?
          Tells us when to stop; when it returns true when applied to
          one of these seed values.

     SEED->CHAR
          Maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in a
          right-to-left order.

     BASE-STR
          Is the optional initial/rightmost portion of the constructed
          string; it defaults to the empty string.

     MAKE-FINAL
          Is applied to the terminal seed value (on which STOP? returns
          true) to produce the final/leftmost portion of the constructed
          string.  It defaults to:

               (lambda (x) "")

     More precisely, the following (simple, inefficient) definitions
     hold:

          ;;; Iterative
          (define (string-unfold-right stop? seed->char make-seed
                                       first-seed base-str make-final)
            (let loop ((seed first-seed)
                       (ans  base-str))
              (if (stop? seed)
                  (string-append (make-final seed) ans)
                (loop (make-seed seed)
                      (string-append (string (seed->char seed)) ans)))))

          ;;; Recursive
          (define (string-unfold-right stop? seed->char make-seed
                                       first-seed base-str make-final)
            (string-append
               (let recur ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (string-append (recur  (make-seed  seed))
                                  (string (seed->char seed)))))
               base-str))

     Interested functional programmers may enjoy noting that
     'string-fold' and 'string-unfold-right' are in some sense inverses.
     That is, given operations KNULL?, KAR, KDR, KONS, and KNIL
     satisfying:

          (kons (kar x) (kdr x))  == x
          (knull? knil)           == #t

     then:

          (string-fold kons knil
            (string-unfold-right knull? kar kdr x))
          == x

     and:

          (string-unfold-right knull? kar kdr
            (string-fold kons knil s))
          == s

     The final string constructed does not share storage with either
     BASE-STR or the value produced by 'make-final'.


File: vicare-libs.info,  Node: srfi strings spec replicate,  Next: srfi strings spec misc,  Prev: srfi strings spec fold,  Up: srfi strings spec

2.8.3.13 Replicate and rotate
.............................

 -- Function: xsubstring STR FROM
 -- Function: xsubstring STR FROM TO
 -- Function: xsubstring STR FROM TO START
 -- Function: xsubstring STR FROM TO START END
     This is the "extended substring" procedure that implements
     replicated copying of a substring of some string.

     STR is a string; START and END are optional arguments that
     demarcate a substring of STR, defaulting to '0' and the length of
     STR (i.e.  the whole string).

     This function replicates the selected substring "up and down" index
     space, in both the positive and negative directions.  For example,
     if:

          STR   = "abcdefg"
          START = 3
          END   = 6

     then we have the conceptual bidirectionally-infinite string:

          ...  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  ...
          ... -9 -8 -7 -6 -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 +6 +7 +8 +9  ...

     that is 'defg' repeated in both directions.

     'xsubstring' returns the substring of this string beginning at
     index FROM, and ending at TO which defaults to 'FROM + (END -
     START)'.

     We can use 'xsubstring' to perform a variety of tasks:

        * To rotate a string left:

               (xsubstring "abcdef" 2)         => "cdefab"

        * To rotate a string right:

               (xsubstring "abcdef" -2)        => "efabcd"

        * To replicate a string:

               (xsubstring "abc" 0 7)          => "abcabca"

     Note that:

        * The FROM/TO indices give a half-open range; the characters
          from index FROM up to, but not including, index TO.

        * The FROM/TO indices are not in terms of the index space for
          string STR.  They are in terms of the replicated index space
          of the substring defined by STR, START, and END.

     It is an error if 'START = END'; although this is allowed by
     special dispensation when 'from = to'.

 -- Function: string-xcopy! DST.STR DST.START SRC.STR SRC.FROM
 -- Function: string-xcopy! DST.STR DST.START SRC.STR SRC.FROM SRC.TO
 -- Function: string-xcopy! DST.STR DST.START SRC.STR SRC.FROM SRC.TO
          SRC.START
 -- Function: string-xcopy! DST.STR DST.START SRC.STR SRC.FROM SRC.TO
          SRC.START SRC.END
     Exactly the same as 'xsubstring', but the extracted text is written
     into the string DST.STR starting at index DST.START.  This
     operation is not defined if '(eq? DST.STR SRC.STR)' or these two
     arguments share storage; we cannot copy a string on top of itself.


File: vicare-libs.info,  Node: srfi strings spec misc,  Prev: srfi strings spec replicate,  Up: srfi strings spec

2.8.3.14 Intertion, parsing, filtering and deleting
...................................................

 -- Function: string-replace STR1 STR2 START1 END1
 -- Function: string-replace STR1 STR2 START1 END1 START2
 -- Function: string-replace STR1 STR2 START1 END1 START2 END2
     Return:

          (string-append (substring/shared s1 0 start1)
                         (substring/shared s2 start2 end2)
                         (substring/shared s1 end1 (string-length s1)))

     That is, the segment of characters in STR1 from START1 to END1 is
     replaced by the segment of characters in STR2 from START2 to END2.
     If 'START1 = END1', this simply splices the STR2 characters into
     STR1 at the specified index.

     Examples:

          (string-replace "The TCL programmer endured daily ridicule."
                          "another miserable perl drone" 4 7 8 22)
          => "The miserable perl programmer endured daily ridicule."

          (string-replace "It's easy to code it up in Scheme."
                          "lots of fun" 5 9)
          => "It's lots of fun to code it up in Scheme."

          (define (string-insert s i t)
            (string-replace s t i i))

          (string-insert "It's easy to code it up in Scheme." 5 "really ")
          => "It's really easy to code it up in Scheme."

 -- Function: string-tokenize STR
 -- Function: string-tokenize STR TOKEN-SET
 -- Function: string-tokenize STR TOKEN-SET START
 -- Function: string-tokenize STR TOKEN-SET START END
     Split the string STR into a list of substrings, where each
     substring is a maximal non-empty contiguous sequence of characters
     from the character set TOKEN-SET.

        * TOKEN-SET defaults to 'char-set:graphic' (see SRFI-14 for more
          on character sets and 'char-set:graphic').

        * If START or END indices are provided, they restrict
          'string-tokenize' to operating on the indicated substring of
          STR.

     This function provides a minimal parsing facility for simple
     applications.  More sophisticated parsers that handle quoting and
     backslash effects can easily be constructed using
     regular-expression systems; be careful not to use 'string-tokenize'
     in contexts where more serious parsing is needed.

          (string-tokenize "Help make programs run, run, RUN!")
          => ("Help" "make" "programs" "run," "run," "RUN!")

 -- Function: string-filter CHAR/CHAR-SET/PRED STR
 -- Function: string-filter CHAR/CHAR-SET/PRED STR START
 -- Function: string-filter CHAR/CHAR-SET/PRED STR START END
 -- Function: string-delete CHAR/CHAR-SET/PRED STR
 -- Function: string-delete CHAR/CHAR-SET/PRED STR START
 -- Function: string-delete CHAR/CHAR-SET/PRED STR START END
     Filter the string STR, retaining only those characters that
     satisfy/do not satisfy the CHAR/CHAR-SET/PRED argument.  If this
     argument is a procedure, it is applied to the character as a
     predicate; if it is a char-set, the character is tested for
     membership; if it is a character, it is used in an equality test.

     If the string is unaltered by the filtering operation, these
     functions may return either STR or a copy of STR.


File: vicare-libs.info,  Node: srfi strings ack,  Next: srfi strings references,  Prev: srfi strings spec,  Up: srfi strings

2.8.4 Acknowledgments
---------------------

The design of this library benefited greatly from the feedback provided
during the SRFI discussion phase.  Among those contributing thoughtful
commentary and suggestions, both on the mailing list and by private
discussion, were Paolo Amoroso, Lars Arvestad, Alan Bawden, Jim Bender,
Dan Bornstein, Per Bothner, Will Clinger, Brian Denheyer, Mikael
Djurfeldt, Kent Dybvig, Sergei Egorov, Marc Feeley, Matthias Felleisen,
Will Fitzgerald, Matthew Flatt, Arthur A. Gleckler, Ben Goetter, Sven
Hartrumpf, Erik Hilsdale, Richard Kelsey, Oleg Kiselyov, Bengt Kleberg,
Donovan Kolbly, Bruce Korb, Shriram Krishnamurthi, Bruce Lewis, Tom
Lord, Brad Lucier, Dave Mason, David Rush, Klaus Schilling, Jonathan
Sobel, Mike Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald Welsh,
and Mike Wilson.  I am grateful to them for their assistance.

   I am also grateful the authors, implementors and documentors of all
the systems mentioned in the introduction.  Aubrey Jaffer and Kent
Pitman should be noted for their work in producing Web-accessible
versions of the R5RS and Common Lisp spec, which was a tremendous aid.

   This is not to imply that these individuals necessarily endorse the
final results, of course.

   During this document's long development period, great patience was
exhibited by Mike Sperber, who is the editor for the SRFI, and by
Hillary Sullivan, who is not.


File: vicare-libs.info,  Node: srfi strings references,  Prev: srfi strings ack,  Up: srfi strings

2.8.5 References
----------------

_Case mappings_.  Unicode Technical Report 21.

            <http://www.unicode.org/unicode/reports/tr21/>

_Common Lisp: the Language_.  Guy L. Steele Jr.  (editor).  Digital
Press, Maynard, Mass., second edition 1990.  Available at:

        <http://www.elwood.com/alu/table/references.htm#cltl2>

_The Common Lisp "HyperSpec"_, produced by Kent Pitman, is essentially
the ANSI spec for Common Lisp:

         <http://www.harlequin.com/education/books/HyperSpec/>

The following URLs provide documentation on relevant Java classes.

     http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html
     http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html
     http://java.sun.com/products/jdk/1.2/docs/api/java/lang/StringBuffer.html
     http://java.sun.com/products/jdk/1.2/docs/api/java/text/Collator.html
     http://java.sun.com/products/jdk/1.2/docs/api/java/text/package-summary.html

MIT-Scheme:

            <http://www.swiss.ai.mit.edu/projects/scheme/>

_Revised^5 report on the algorithmic language Scheme_.  R. Kelsey, W.
Clinger, J. Rees (editors).  Higher-Order and Symbolic Computation, Vol.
11, No.  1, September, 1998; and ACM SIGPLAN Notices, Vol.  33, No.  9,
October, 1998.  Available at:

            <http://www.schemers.org/Documents/Standards/>

The SRFI web site.

                      <http://srfi.schemers.org/>

SRFI-14: Character-set library.  The SRFI-14 char-set library defines a
character-set data type, which is used by some procedures in this
library.

                  <http://srfi.schemers.org/srfi-14/>

The Unicode site:

                       <http://www.unicode.org/>

The Unicode character database.

     ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
     ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html


File: vicare-libs.info,  Node: srfi char-sets,  Next: srfi case-lambda,  Prev: srfi strings,  Up: srfi

2.9 SRFI-14 character sets
==========================

The library '(srfi :14)' is by Olin Shivers as the reference
implementation for SRFI-14; see:

            <http://srfi.schemers.org/srfi-14/srfi-14.html>

for more details.

* Menu:

* srfi char-sets abstract::     Abstract.
* srfi char-sets rationale::    Rationale.
* srfi char-sets spec::         Specification.
* srfi char-sets ack::          Acknowledgements.
* srfi char-sets license::      Copyright.


File: vicare-libs.info,  Node: srfi char-sets abstract,  Next: srfi char-sets rationale,  Up: srfi char-sets

2.9.1 Abstract
--------------

The ability to efficiently represent and manipulate sets of characters
is an unglamorous but very useful capability for text-processing code;
one that tends to pop up in the definitions of other libraries.  Hence
it is useful to specify a general substrate for this functionality
early.  This SRFI defines a general library that provides this
functionality.


File: vicare-libs.info,  Node: srfi char-sets rationale,  Next: srfi char-sets spec,  Prev: srfi char-sets abstract,  Up: srfi char-sets

2.9.2 Rationale
---------------

The ability to efficiently manipulate sets of characters is quite useful
for text-processing code.  Encapsulating this functionality in a
general, efficiently implemented library can assist all such code.  This
library defines a new data structure to represent these sets, called a
'char-set'.  The 'char-set' type is distinct from all other types.

   The procedures of this SRFI, by default, are "pure functional", they
do not alter their parameters.  However, this SRFI defines a set of
"linear-update" procedures which have a hybrid
pure-functional/side-effecting semantics: they are allowed, but not
required, to side-effect one of their parameters in order to construct
their result.  An implementation may legally implement these procedures
as pure, side-effect-free functions, or it may implement them using side
effects, depending upon the details of what is the most efficient or
simple to implement in terms of the underlying representation.

   The linear-update routines all have names ending with '!'.

   Clients of these procedures may not rely upon these procedures
working by side effect.  For example, this is not guaranteed to work:

     (let* ((cs1 (char-set #\a #\b #\c))      ; cs1 = {a,b,c}.
            (cs2 (char-set-adjoin! cs1 #\d))) ; Add d to {a,b,c}.
       cs1) ; Could be either {a,b,c} or {a,b,c,d}.

   However, this is well-defined:

     (let ((cs (char-set #\a #\b #\c)))
       (char-set-adjoin! cs #\d)) ; Add d to {a,b,c}.

   So clients of these procedures write in a functional style, but must
additionally be sure that, when the procedure is called, there are no
other live pointers to the potentially-modified character set (hence the
term "linear update").

   There are two benefits to this convention:

   * Implementations are free to provide the most efficient possible
     implementation, either functional or side-effecting.

   * Programmers may nonetheless continue to assume that character sets
     are purely functional data structures: they may be reliably shared
     without needing to be copied, uniquified, and so forth.

   Note that pure functional representations are the right thing for
ASCII or Latin-1 based Scheme implementations, since a 'char-set' can be
represented in an ASCII Scheme with 4 32-bit words.  Pure set-algebra
operations on such a representation are very fast and efficient.
Programmers who code using linear-update operations are guaranteed the
system will provide the best implementation across multiple platforms.

   In practice, these procedures are most useful for efficiently
constructing character sets in a side-effecting manner, in some limited
local context, before passing the character set outside the local
construction scope to be used in a functional manner.

   Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions; there's
no linear type checker or run-time mechanism for detecting violations.


File: vicare-libs.info,  Node: srfi char-sets spec,  Next: srfi char-sets ack,  Prev: srfi char-sets rationale,  Up: srfi char-sets

2.9.3 Specification
-------------------

* Menu:

* srfi char-sets spec conv::    Conventions.
* srfi char-sets spec general:: General procedures.
* srfi char-sets spec iter::    Iterating over character sets.
* srfi char-sets spec create::  Creating character sets.
* srfi char-sets spec query::   Querying character sets.
* srfi char-sets spec algebra:: Character set algebra.
* srfi char-sets spec std::     Standard character sets.


File: vicare-libs.info,  Node: srfi char-sets spec conv,  Next: srfi char-sets spec general,  Up: srfi char-sets spec

2.9.3.1 Conventions
...................

In the following procedure specifications a convention to indicate the
type of arguments is used:

CS
     Is a character set.

S
     Is a string.

CHAR
     Is a character.

CHAR-LIST
     Is a list of characters.

PRED
     Is a unary character predicate procedure, returning a true/false
     value when applied to a character.

OBJ
     May be any value at all.

   Passing values to procedures with these parameters that do not
satisfy these types is an error.

   Unless otherwise noted in the specification of a procedure,
procedures always return character sets that are distinct (from the
point of view of the linear-update operations) from the parameter
character sets.  For example, 'char-set-adjoin' is guaranteed to provide
a fresh character set, even if it is not given any character parameters.


File: vicare-libs.info,  Node: srfi char-sets spec general,  Next: srfi char-sets spec iter,  Prev: srfi char-sets spec conv,  Up: srfi char-sets spec

2.9.3.2 General procedures
..........................

 -- Function: char-set? OBJ
     Return '#t' if OBJ is a character set, else return '#f'.

 -- Function: char-set= CS ...
     Return '#t' if all the arguments are character sets and all are
     equal, else return '#f'.  When called with no arguments: return
     '#t'; when called with one argument: return '#t'.

 -- Function: char-set<= CS ...
     Return '#t' if every character set CSI is a subset of character set
     CSI+1, else return '#f'.  When called with zero or one argument:
     return '#t'.

 -- Function: char-set-hash CS
 -- Function: char-set-hash CS BOUND
     Compute a hash value for the character set CS.  The optional
     argument BOUND is a non-negative exact integer specifying the range
     of the hash function; a positive value restricts the return value
     to the range '[0, BOUND)'.

     If bound is either zero or not given: the implementation may use an
     implementation-specific default value, chosen to be as large as is
     efficiently practical.  For instance, the default range might be
     chosen for a given implementation to map all strings into the range
     of integers that can be represented with a single machine word.

     Invariant:

          (char-set= cs1 cs2) => (= (char-set-hash cs1 b)
                                    (char-set-hash cs2 b))


File: vicare-libs.info,  Node: srfi char-sets spec iter,  Next: srfi char-sets spec create,  Prev: srfi char-sets spec general,  Up: srfi char-sets spec

2.9.3.3 Iterating over character sets
.....................................

 -- Function: char-set-cursor CS
 -- Function: char-set-ref CS CURSOR
 -- Function: char-set-cursor-next CS CURSOR
 -- Function: end-of-char-set? CURSOR
     Cursors are a low-level facility for iterating over the characters
     in a set; a cursor is a value that indexes a character in a char
     set.

     'char-set-cursor' returns a new cursor object associated to the
     character set CS.  There can be multiple cursors associated to the
     same character set.

     'char-set-ref' returns a character object representing the set
     element currently indexed by a cursor.

     'char-set-cursor-next' increments a cursor index and returns a new
     cursor indexing the next character in the set; in this way, code
     can step through every character in a char set.

     Stepping a cursor "past the end" of a char set produces a cursor
     that answers true to 'end-of-char-set?'.  It is an error to pass
     such a cursor to 'char-set-ref' or to 'char-set-cursor-next'.

     A cursor value may not be used in conjunction with a different
     character set; if it is passed to 'char-set-ref' or
     'char-set-cursor-next' with a character set other than the one used
     to create it, the results and effects are undefined.

     Cursor values are not necessarily distinct from other types: they
     may be integers, linked lists, records, procedures or other values.

     Note that these primitives are necessary to export an iteration
     facility for char sets to loop macros.

     Example:

          (define cs (char-set #\G #\a #\T #\e #\c #\h))

          ;; Collect elts of CS into a list.
          (let lp ((cur (char-set-cursor cs)) (ans '()))
            (if (end-of-char-set? cur) ans
                (lp (char-set-cursor-next cs cur)
                    (cons (char-set-ref cs cur) ans))))
            => (#\G #\T #\a #\c #\e #\h)

          ;; Equivalently, using a list unfold (from SRFI 1):
          (unfold-right end-of-char-set?
                       (curry char-set-ref cs)
                (curry char-set-cursor-next cs)
                (char-set-cursor cs))
            => (#\G #\T #\a #\c #\e #\h)

 -- Function: char-set-fold KONS KNIL CS -> object
     This is the fundamental iterator for character sets.  Apply the
     function KONS across the character set CS using initial state value
     KNIL.

     If CS is the empty set: the return value is KNIL.

     Otherwise some element C of CS is chosen; let CS1 be the remaining,
     unchosen characters, the procedure returns:

          (char-set-fold KONS (KONS C KNIL) CS1)

     Examples:

          ;; CHAR-SET-MEMBERS
          (lambda (cs) (char-set-fold cons '() cs))

          ;; CHAR-SET-SIZE
          (lambda (cs) (char-set-fold (lambda (c i) (+ i 1)) 0 cs))

          ;; How many vowels in the char set?
          (lambda (cs)
            (char-set-fold (lambda (c i) (if (vowel? c) (+ i 1) i))
                           0 cs))

 -- Function: char-set-unfold F P G SEED
 -- Function: char-set-unfold F P G SEED BASE-CS
 -- Function: char-set-unfold! F P G SEED BASE-CS
     This is a fundamental constructor for character sets.

     G is used to generate a series of "seed" values from the initial
     SEED:

          SEED
          (G SEED)
          (G2 SEED)
          (G3 SEED)
          ...

     P tells us when to stop: when it returns true when applied to one
     of these seed values.

     F maps each seed value to a character.  These characters are added
     to the base character set BASE-CS to form the result; BASE-CS
     defaults to the empty set.

     'char-set-unfold!' adds the characters to BASE-CS in a
     linear-update; it is allowed, but not required, to side-effect and
     use BASE-CS's storage to construct the result.

     More precisely, the following definitions hold, ignoring the
     optional-argument issues:

          (define (char-set-unfold p f g seed base-cs)
            (char-set-unfold! p f g seed (char-set-copy base-cs)))

          (define (char-set-unfold! p f g seed base-cs)
            (let lp ((seed seed)
                     (cs   base-cs))
              (if (p seed)
                  cs
                (lp (g seed)
                    (char-set-adjoin! cs (f seed))))))

     note that the actual implementation may be more efficient.

     Examples:

          (port->char-set p)
          == (char-set-unfold eof-object? values
                                    (lambda (x) (read-char p))
                                    (read-char p))

          (list->char-set lis)
          == (char-set-unfold null? car cdr lis)

 -- Function: char-set-for-each PROC CS
     Apply the procedure PROC to each character in the character set CS;
     return unspecified values.  The order in which PROC is applied to
     the characters in the set is unspecified, and may even change from
     one procedure application to another.

 -- Function: char-set-map PROC CS
     PROC is a character-to-character procedure; apply it to all the
     characters in CS, and collect the results into a new character set,
     return such new character set.

     Example:

          (char-set-map char-downcase cs)


File: vicare-libs.info,  Node: srfi char-sets spec create,  Next: srfi char-sets spec query,  Prev: srfi char-sets spec iter,  Up: srfi char-sets spec

2.9.3.4 Creating character sets
...............................

 -- Function: char-set-copy CS
     Return a copy of the character set CS; "copy" means that if either
     the input argument or the result value of this procedure is passed
     to one of the linear-update procedures described below, the other
     character set is guaranteed not to be altered.

 -- Function: char-set CHAR ...
     Return a character set containing the given characters.

 -- Function: list->char-set CHAR-LIST
 -- Function: list->char-set CHAR-LIST BASE-CS
 -- Function: list->char-set! CHAR-LIST BASE-CS
     Return a character set containing the characters in the list of
     characters CHAR-LIST.

     If the character set BASE-CS is provided, the characters from
     CHAR-LIST are added to it.  'list->char-set!' is allowed, but not
     required, to side-effect and reuse the storage in BASE-CS;
     'list->char-set' produces a fresh character set.

 -- Function: string->char-set S
 -- Function: string->char-set S BASE-CS
 -- Function: string->char-set! S BASE-CS
     Return a character set containing the characters in the string S.

     If the character set BASE-CS is provided, the characters from S are
     added to it.  'string->char-set!' is allowed, but not required, to
     side-effect and reuse the storage in BASE-CS; 'string->char-set'
     produces a fresh character set.

 -- Function: char-set-filter PRED CS
 -- Function: char-set-filter PRED CS BASE-CS
 -- Function: char-set-filter! PRED CS BASE-CS
     Return a character set containing every character C in CS such that
     '(PRED C)' returns true.

     If the character set BASE-CS is provided: the characters specified
     by PRED are added to it.  'char-set-filter!' is allowed, but not
     required, to side-effect and reuse the storage in BASE-CS;
     'char-set-filter' produces a fresh character set.

          An implementation may not save away a reference to PRED and
          invoke it after 'char-set-filter' or 'char-set-filter!'
          returns; that is, "lazy," on-demand implementations are not
          allowed, as pred may have external dependencies on mutable
          data or have other side-effects.

 -- Function: ucs-range->char-set LOWER UPPER
 -- Function: ucs-range->char-set LOWER UPPER ERROR?
 -- Function: ucs-range->char-set LOWER UPPER ERROR? BASE-CS
 -- Function: ucs-range->char-set! LOWER UPPER ERROR? BASE-CS
     The arguments LOWER and UPPER are exact non-negative integers such
     that 'LOWER <= UPPER'.

     Return a character set containing every character whose ISO/IEC
     10646 UCS-4 code lies in the half-open range '[LOWER, UPPER)'.

     If the requested range includes unassigned UCS values, these are
     silently ignored (the current UCS specification has "holes" in the
     space of assigned codes).

     If the requested range includes "private" or "user space" codes,
     these are handled in an implementation-specific manner; however, a
     UCS- or Unicode-based Scheme implementation should pass them
     through transparently.

     If any code from the requested range specifies a valid, assigned
     UCS character that has no corresponding representative in the
     implementation's character type, then (1) an error is raised if
     ERROR? is true, and (2) the code is ignored if ERROR? is false (the
     default).

     If character set BASE-CS is provided, the characters specified by
     the range are added to it.  'ucs-range->char-set!' is allowed, but
     not required, to side-effect and reuse the storage in BASE-CS;
     'ucs-range->char-set' produces a fresh character set.

 -- Function: ->char-set X
     Coerces X into a 'char-set'.  X may be a string, character or
     'char-set'.  A string is converted to the set of its constituent
     characters; a character is converted to a singleton set; a
     'char-set' is returned as-is.  This procedure is intended for use
     by other procedures that want to provide user-friendly,
     wide-spectrum interfaces to their clients.


File: vicare-libs.info,  Node: srfi char-sets spec query,  Next: srfi char-sets spec algebra,  Prev: srfi char-sets spec create,  Up: srfi char-sets spec

2.9.3.5 Querying character sets
...............................

 -- Function: char-set-size CS
     Return the number of elements in character set CS.

 -- Function: char-set-count PRED CS
     Apply PRED to the chars of character set CS, and return the number
     of chars that caused the predicate to return true.

 -- Function: char-set->list CS
     Return a list of the members of character set CS.  The order in
     which the characters appear in the list is not defined, and may be
     different from one call to another.

 -- Function: char-set->string CS
     Return a string containing the members of character set CS.  The
     order in which the characters appear in the string is not defined,
     and may be different from one call to another.

 -- Function: char-set-contains? CS CHAR
     Test CHAR for membership in character set CS.  Return a boolean.

 -- Function: char-set-every PRED CS
 -- Function: char-set-any PRED CS
     'char-set-every' procedure returns true if predicate PRED returns
     true of every character in the CS.

     'char-set-any' applies PRED to every character in CS, and returns
     the first true value it finds; if no character produces a true
     value, it returns '#f'.

     The order in which these procedures sequence through the elements
     of CS is not specified.

     Note that if we need to determine the actual character on which a
     predicate returns true: we use 'char-set-any' and arrange for the
     predicate to return the character parameter as its true value:

          (char-set-any (lambda (c)
                          (and (char-upper-case? c) c))
                        cs)


File: vicare-libs.info,  Node: srfi char-sets spec algebra,  Next: srfi char-sets spec std,  Prev: srfi char-sets spec query,  Up: srfi char-sets spec

2.9.3.6 Character set algebra
.............................

 -- Function: char-set-adjoin CS CHAR ...
 -- Function: char-set-delete CS CHAR ...
     Add/delete the CHAR characters to/from character set CS.

 -- Function: char-set-adjoin! CS CHAR ...
 -- Function: char-set-delete! CS CHAR ...
     Linear-update variants.  These procedures are allowed, but not
     required, to side-effect their first parameter.

 -- Function: char-set-complement CS
 -- Function: char-set-union CS ...
 -- Function: char-set-intersection CS ...
 -- Function: char-set-difference CS0 CS ...
 -- Function: char-set-xor CS ...
 -- Function: char-set-diff+intersection CS0 CS ...
     These procedures implement set complement, union, intersection,
     difference, and exclusive OR for character sets.  The union,
     intersection and xor operations are n-ary.  The difference function
     is also n-ary, associates to the left (that is, it computes the
     difference between its first argument and the union of all the
     other arguments), and requires at least one argument.

          (char-set-difference (char-set #\a)
                               (char-set #\b))
          => (char-set #\a)

     Boundary cases:

          (char-set-union)                => char-set:empty
          (char-set-intersection)         => char-set:full
          (char-set-xor)                  => char-set:empty
          (char-set-difference cs)        => cs

     'char-set-diff+intersection' returns two values: the difference and
     the intersection of the arguments; it partitions its first
     argument.  It is almost equivalent to:

          (values (char-set-difference cs1 cs2 ...)
                  (char-set-intersection cs1 (char-set-union cs2 ...)))

     but can be implemented more efficiently; when called with one
     argument: the first return value is a copy of the argument itself,
     the second return value is the empty set.

 -- Function: char-set-complement! CS
 -- Function: char-set-union! CS0 CS ...
 -- Function: char-set-intersection! CS0 CS ...
 -- Function: char-set-difference! CS0 CS ...
 -- Function: char-set-xor! CS0 CS ...
 -- Function: char-set-diff+intersection! CS0 CS1 CS ...
     These are linear-update variants of the set-algebra functions.
     They are allowed, but not required, to side-effect their first
     (required) argument.

     'char-set-diff+intersection!' is allowed to side-effect both of its
     two required arguments.


File: vicare-libs.info,  Node: srfi char-sets spec std,  Prev: srfi char-sets spec algebra,  Up: srfi char-sets spec

2.9.3.7 Standard character sets
...............................

Several character sets are predefined for convenience:

'char-set:lower-case'
     Lower-case letters.

'char-set:upper-case'
     Upper-case letters.

'char-set:title-case'
     Title-case letters.

'char-set:letter'
     Letters.

'char-set:digit'
     Digits.

'char-set:letter+digit'
     Letters and digits.

'char-set:graphic'
     Printing characters except spaces.

'char-set:printing'
     Printing characters including spaces.

'char-set:whitespace'
     Whitespace characters.

'char-set:iso-control'
     The ISO control characters.

'char-set:punctuation'
     Punctuation characters.

'char-set:symbol'
     Symbol characters.

'char-set:hex-digit'
     A hexadecimal digit: 0-9, A-F, a-f.

'char-set:blank'
     Blank characters, horizontal whitespace.

'char-set:ascii'
     All characters in the ASCII set.

'char-set:empty'
     Empty set.

'char-set:full'
     All characters.

   Note that there may be characters in 'char-set:letter' that are
neither upper or lower case.  A "graphic character" is one that would
put ink on your page.


File: vicare-libs.info,  Node: srfi char-sets ack,  Next: srfi char-sets license,  Prev: srfi char-sets spec,  Up: srfi char-sets

2.9.4 Acknowledgements
----------------------

The design of this library benefited greatly from the feedback provided
during the SRFI discussion phase.  Among those contributing thoughtful
commentary and suggestions, both on the mailing list and by private
discussion, were Paolo Amoroso, Lars Arvestad, Alan Bawden, Jim Bender,
Dan Bornstein, Per Bothner, Will Clinger, Brian Denheyer, Kent Dybvig,
Sergei Egorov, Marc Feeley, Matthias Felleisen, Will Fitzgerald, Matthew
Flatt, Arthur A. Gleckler, Ben Goetter, Sven Hartrumpf, Erik Hilsdale,
Shiro Kawai, Richard Kelsey, Oleg Kiselyov, Bengt Kleberg, Donovan
Kolbly, Bruce Korb, Shriram Krishnamurthi, Bruce Lewis, Tom Lord, Brad
Lucier, Dave Mason, David Rush, Klaus Schilling, Jonathan Sobel, Mike
Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald Welsh, and Mike
Wilson.  I am grateful to them for their assistance.

   I am also grateful the authors, implementors and documentors of all
the systems mentioned in the introduction.  Aubrey Jaffer should be
noted for his work in producing Web-accessible versions of the R5RS
spec, which was a tremendous aid.

   This is not to imply that these individuals necessarily endorse the
final results, of course.

   During this document's long development period, great patience was
exhibited by Mike Sperber, who is the editor for the SRFI, and by
Hillary Sullivan, who is not.


File: vicare-libs.info,  Node: srfi char-sets license,  Prev: srfi char-sets ack,  Up: srfi char-sets

2.9.5 Copyright
---------------

Certain portions of this document (the specific, marked segments of text
describing the R5RS procedures) were adapted with permission from the
R5RS report.

   All other text is copyright (C) Olin Shivers (1998, 1999, 2000).  All
Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi case-lambda,  Next: srfi time,  Prev: srfi char-sets,  Up: srfi

2.10 SRFI-16 syntax for procedures of variable arity
====================================================

The library '(srfi :16)' is by Lars T Hansen as the reference
implementation for SRFI-16; see:

            <http://srfi.schemers.org/srfi-16/srfi-16.html>

for more details.

* Menu:

* srfi case-lambda license::        Case-Lambda document license.
* srfi case-lambda abstract::       Abstract.
* srfi case-lambda rationale::      Rationale.
* srfi case-lambda spec::           Specification.


File: vicare-libs.info,  Node: srfi case-lambda license,  Next: srfi case-lambda abstract,  Up: srfi case-lambda

2.10.1 Case-lambda document license
-----------------------------------

Copyright (C) 1999 Lars T Hansen.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi case-lambda abstract,  Next: srfi case-lambda rationale,  Prev: srfi case-lambda license,  Up: srfi case-lambda

2.10.2 Abstract
---------------

'case-lambda', a syntax for procedures with a variable number of
arguments, is introduced.


File: vicare-libs.info,  Node: srfi case-lambda rationale,  Next: srfi case-lambda spec,  Prev: srfi case-lambda abstract,  Up: srfi case-lambda

2.10.3 Rationale
----------------

'case-lambda' reduces the clutter of procedures that execute different
code depending on the number of arguments they were passed; it is a
pattern-matching mechanism that matches on the number of arguments.
'case-lambda' is available in some Scheme systems.

   While 'case-lambda' can be implemented as a macro using only
facilities available in R5RS Scheme, it admits considerable
implementation-specific optimization.


File: vicare-libs.info,  Node: srfi case-lambda spec,  Prev: srfi case-lambda rationale,  Up: srfi case-lambda

2.10.4 Specification
--------------------

 -- Syntax: case-lambda CLAUSE ...
     Eeach CLAUSE has the format '(formals body)', were FORMALS is a
     formal arguments list as for 'lambda' (cf section 4.1.4 of the
     R5RS).  Each BODY is a 'tail-body' (cf section 3.5 of the R5RS).

     A 'case-lambda' expression evaluates to a procedure that accepts a
     variable number of arguments and is lexically scoped in the same
     manner as procedures resulting from 'lambda' expressions.

     When the procedure is called with some arguments V1, ..., VK, then
     the first clause for which the arguments agree with FORMALS is
     selected, where agreement is specified as for the FORMALS of a
     LAMBDA expression.

     The variables of FORMALS are bound to fresh locations, the values
     V1, ..., VK are stored in those locations, the BODY is evaluated in
     the extended environment, and the results of BODY are returned as
     the results of the procedure call.

     It is an error for the arguments not to agree with the FORMALS of
     any CLAUSE.

     Error:

          (define plus
            (case-lambda
              [()         0]
              [(x)        x]
              [(x y)      (+ x y)]
              [(x y z)    (+ (+ x y) z)]
              [args       (apply + args)]))

          (plus)                     => 0
          (plus 1)                   => 1
          (plus 1 2 3)               => 6

          ((case-lambda
             [(a)         a]
             [(a b)       (* a b)])
           1 2 3)                    => error


File: vicare-libs.info,  Node: srfi time,  Next: srfi error-reporting,  Prev: srfi case-lambda,  Up: srfi

2.11 SRFI-19 time data types and procedures
===========================================

The library '(srfi :19)' is by Will Fitzgerald as the reference
implementation for SRFI-19; see:

            <http://srfi.schemers.org/srfi-19/srfi-19.html>

for more details.

* Menu:

* srfi time license::        Time document license.
* srfi time abstract::       Abstract.
* srfi time spec::           Specification.
* srfi time ack::            Acknowledgements.


File: vicare-libs.info,  Node: srfi time license,  Next: srfi time abstract,  Up: srfi time

2.11.1 Time document license
----------------------------

Copyright (C) 2000 Neodesic Corporation.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi time abstract,  Next: srfi time spec,  Prev: srfi time license,  Up: srfi time

2.11.2 Abstract
---------------

Points in time are represented as the number of seconds (with nanosecond
precision) since "the epoch", a zero point in time.  Several standard
variants are defined, including UTC (Universal Coordinated Time), TAI
(international atomic time), and monotonic time.  A point in time can
also be represented as a Julian Day or Modified Julian Day number.

   Time durations, including time spent in a process or thread, are
defined.  Conversion routines are provided.  The procedure
'current-time' queries the current time in a specified variant, with a
system-dependent resolution.  Procedures for time arithmetic and time
comparisons are also provided.

   A date is a representation of a point in time in the Gregorian
calendar, a 24 hour clock (with nanosecond precision) and a time zone
offset from UTC.  Procedures for converting between time and dates are
provided, as well as for reading and writing string representations of
dates.


File: vicare-libs.info,  Node: srfi time spec,  Next: srfi time ack,  Prev: srfi time abstract,  Up: srfi time

2.11.3 Specification
--------------------

* Menu:

* srfi time spec intro::          Introduction.
* srfi time spec const::          Constants.
* srfi time spec current::        Current time and clock resolution.
* srfi time spec time::           Time object.
* srfi time spec date::           Date object.
* srfi time spec conversion::     Time/Date/Julian Day/Modified
                                  Julian Day Converters.
* srfi time spec string::         Date to string/string to date
                                  converters.


File: vicare-libs.info,  Node: srfi time spec intro,  Next: srfi time spec const,  Up: srfi time spec

2.11.3.1 Introduction
.....................

A 'time' object, which is distinct from all existing types, defines a
point in time or a time duration in some standard time system.  The
standard time systems are:

   * Universal Coordinated Time (UTC),

   * International Atomic Time (TAI),

   * monotonic time (a monotonically increasing point in time equal to
     TAI),

   * CPU time in current thread (not implemented by Vicare),

   * CPU time in current process (not implemented by Vicare),

   * time duration.

   Implementations are required to implement UTC, monotonic time, CPU
time in current process, and time duration.  Implementations are allowed
to create extensions (for example, amount of time spent in garbage
collection).

   A 'time' object consists of three components:

_Time type_
     A symbol representing the time system representation used.  The
     constants 'time-tai', 'time-utc', 'time-monotonic', 'time-thread',
     'time-process', and 'time-duration' must be provided for these
     symbols.  Implementations should provide constants for time type
     extensions.

_Second_
     An integer representing the number of whole seconds from "the
     epoch".

_Nanosecond_
     An integer of the number of nanoseconds in the fractional portion.
     Although a time object has nanosecond precision, clocks may have a
     lower resolution.

   A 'date' object, which is distinct from all existing types,
represents a point in time as represented by the Gregorian calendar as
well as by a time zone.  'date' objects are immutable.  A 'date' object
consists of the following components:

_Nanosecond_
     An integer between 0 and 999,999,999, inclusive.

_Second_
     An integer 0 and 60, inclusive, (60 represents a leap second).

_Minute_
     An integer between 0 and 59, inclusive.

_Hour_
     An integer between 0 and 23, inclusive.

_Day_
     An integer between 0 and 31, inclusive, the upper limit depending
     on the month and year of the point in time.

_Month_
     An integer between 1 and 12, inclusive; in which 1 means January, 2
     February, and so on.

_Year_
     An integer representing the year.

_Time zone_
     A integer the number of seconds east of GMT for this timezone.

   A "Julian Day" represents a point in time as a real number of days
since -4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC).

   A "Modified Julian Day" represents a point in time as a real number
of days since 1858-11-17T00:00:00Z (November 17, 1858 at midnight, UTC).


File: vicare-libs.info,  Node: srfi time spec const,  Next: srfi time spec current,  Prev: srfi time spec intro,  Up: srfi time spec

2.11.3.2 Constants
..................

The following constants are required:

 -- Constant: time-duration
     Symbol representing 'time' duration.

 -- Constant: time-monotonic
     Symbol representing monotonic time.

 -- Constant: time-process
     Symbol representing time spent in current process.

 -- Constant: time-tai
     Symbol representing TAI time.

 -- Constant: time-thread
     Symbol representing time spent in current thread.

 -- Constant: time-utc
     Symbol representing UTC time.


File: vicare-libs.info,  Node: srfi time spec current,  Next: srfi time spec time,  Prev: srfi time spec const,  Up: srfi time spec

2.11.3.3 Current time and clock resolution
..........................................

The following procedures are required.

 -- Function: current-date
 -- Function: current-date TZ-OFFSET
     Return a 'date' corresponding to the current UTC time.

     TZ-OFFSET must be an exact integer representing the time zone
     offset in number of seconds; when not given it defaults to the
     local time zone.

 -- Function: current-julian-day
     Current Julian Day.

 -- Function: current-modified-julian-day
     Current Modified Julian Day.

 -- Function: current-time
 -- Function: current-time TIME-TYPE
     Current time, of type TIME-TYPE system, which defaults to
     'time-utc'.

 -- Function: time-resolution
 -- Function: time-resolution TIME-TYPE
     Return an exact integer representing the clock resolution, in
     nanoseconds, of the system clock of type type TIME-TYPE system,
     which defaults to 'time-utc'.


File: vicare-libs.info,  Node: srfi time spec time,  Next: srfi time spec date,  Prev: srfi time spec current,  Up: srfi time spec

2.11.3.4 Time object
....................

Time object and accessors
.........................

The following procedures are required:

 -- Function: make-time TIME-TYPE NANOSECOND SECOND
     Return a new 'time' object.

 -- Function: time? OBJ
     Return '#t' if OBJ is a 'time' object; otherwise return '#f'.

 -- Function: time-type TIME
     Return the _Time type_ symbol of TIME.  *note srfi time spec
     intro:: for details.

 -- Function: time-nanosecond TIME
     Return the _Nanosecond_ component of TIME.

 -- Function: time-second TIME
     Return the _Second_ component of TIME.

 -- Function: set-time-type! TIME TIME-TYPE
     Set the _Time type_ component of TIME to TIME-TYPE, which must be
     one of the time type symbols.  *note srfi time spec intro:: for
     details.

          *NOTE* This changes the semantics of the time object.  To
          convert a time to another system of representation, use one of
          the conversion procedures.

 -- Function: set-time-nanosecond! TIME INTEGER
     Set the _Nanosecond_ component of TIME to INTEGER.

 -- Function: set-time-second! time integer
     Set the _Second_ component of TIME to INTEGER.

 -- Function: copy-time TIME
     Create a new 'time' object, with the same _Time type_,
     _nanosecond_, and _Second_ as TIME.

Time object comparison procedures
.................................

All of the time comparison procedures require the time objects to be of
the same type.  It is an error to use these procedures on time objects
of different types.  For the point-in-time measurements (e.g.
'time-tai' and 'time-utc'), the semantics are described in plain text.
For durations (e.g.  'time-duration', 'time-cpu') the semantics are
described in parentheses.

   The following procedures are required.

 -- Function: time<=? TIME1 TIME2
     Return '#t' if TIME1 is before or at (less than or equal to) TIME2,
     '#f' otherwise.

 -- Function: time<? TIME1 TIME2
     Return '#t' if TIME1 is before (less than) TIME2, '#f' otherwise.

 -- Function: time=? TIME1 TIME2
     Return '#t' if TIME1 at (equal) TIME2, '#f' otherwise.

 -- Function: time>=? TIME1 TIME2
     Return '#t' if TIME1 is at or after (greater than or equal to)
     TIME2, '#f' otherwise.

 -- Function: time>? TIME1 TIME2
     Return '#t' if TIME1 is after (greater than) TIME2, '#f' otherwise.

Time object arithmetic procedures
.................................

The following procedures are required.

 -- Function: time-difference TIME1 TIME2
     Return a new 'time' object of type 'time-duration' representing the
     time duration between TIME1 and TIME2.  It is an error if TIME1 and
     TIME2 are of different time types.

 -- Function: time-difference! TIME1 TIME2
     Compute the time duration between TIME1 and TIME2; mutate TIME1 to
     represent the computed time as a 'time-duration' object.  It is an
     error if TIME1 and TIME2 are of different time types.

 -- Function: add-duration TIME DURATION
     Return a new 'time' object, of type equal to the type of TIME1,
     representing the result of adding DURATION to TIME.  DURATION must
     be a 'time' object of type 'time-duration'.

 -- Function: add-duration! TIME DURATION
     Mutate TIME to represent the result of adding DURATION to TIME.
     DURATION must be a 'time' object of type 'time-duration'.

 -- Function: subtract-duration TIME DURATION
     Return a new 'time' object, of the same type of TIME, representing
     the result of subtracting DURATION from TIME.  DURATION must be a
     'time' object of type 'time-duration'.

 -- Function: subtract-duration! TIME DURATION
     Mutate TIME to represent the result of subtracting DURATION from
     TIME.  DURATION must be a 'time' object of type 'time-duration'.


File: vicare-libs.info,  Node: srfi time spec date,  Next: srfi time spec conversion,  Prev: srfi time spec time,  Up: srfi time spec

2.11.3.5 Date object and accessors
..................................

Date objects are immutable once created.  The following procedures are
required.

 -- Function: make-date NANOSECOND SECOND MINUTE HOUR DAY MONTH YEAR
          ZONE-OFFSET
     Create a date object.

 -- Function: date? OBJECT
     Return '#t' if OBJECT is a 'date' object; otherwise return '#f'.

 -- Function: date-nanosecond DATE
     Return the _Nanosecond_ component of DATE.

 -- Function: date-second DATE
     Return the _Second_ component of DATE.

 -- Function: date-minute DATE
     Return the _Minute_ component of DATE.

 -- Function: date-hour DATE
     Return the _Hour_ component of DATE.

 -- Function: date-day DATE
     Return the 'date' component of DATE.

 -- Function: date-month DATE
     Return the _Month_ component of DATE.

 -- Function: date-year DATE
     Return the _Year_ component of DATE.

 -- Function: date-zone-offset DATE
     Return the _Time zone_ component of DATE.

 -- Function: date-year-day DATE
     Return the ordinal day of the year of this date.  January 1 is 1,
     etc.

 -- Function: date-week-day DATE
     Return the day of the week of this date, where Sunday=0, Monday=1,
     etc.

 -- Function: date-week-number date day-of-week-starting-week
     Return the ordinal week of the year which holds this date, ignoring
     a first partial week.  DAY-OF-WEEK-STARTING-WEEK is the integer
     corresponding to the day of the week which is to be considered the
     first day of the week (Sunday=0, Monday=1, etc.).


File: vicare-libs.info,  Node: srfi time spec conversion,  Next: srfi time spec string,  Prev: srfi time spec date,  Up: srfi time spec

2.11.3.6 Time/Date/Julian Day/Modified Julian Day Converters
............................................................

From 'date' to Julian Day
.........................

 -- Function: date->julian-day DATE
     Convert date to _Julian Day_.

 -- Function: date->modified-julian-day DATE
     Convert date to _Modified Julian Day_.

From 'date' to 'time'
.....................

 -- Function: date->time-monotonic DATE
     Convert date to monotonic time.

 -- Function: date->time-tai DATE
     Convert date to TAI time.

 -- Function: date->time-utc DATE
     Convert date to UTC time.

From Julian Day to 'date'
.........................

 -- Function: julian-day->date JD
 -- Function: julian-day->date JD TZ-OFFSET
     Convert a _Julian Day_ to a date, using a time zone offset, which
     defaults to the local time zone.

 -- Function: julian-day->time-monotonic JD
     Convert a _Julian Day_ to monotonic time.

 -- Function: julian-day->time-tai JD
     Convert a _Julian Day_ to TAI time.

 -- Function: julian-day->time-utc JD
     Convert a _Julian Day_ to UTC time.

From Modified Julian Day to 'date'
..................................

 -- Function: modified-julian-day->date MJD
 -- Function: modified-julian-day->date MJD TZ-OFFSET
     Convert a _Modified Julian Day_ to adate, using a time zone offset,
     which defaults to the local time zone.

From Modified Julian Day to 'time'
..................................

 -- Function: modified-julian-day->time-monotonic MJD
     Convert _Modified Julian Day_ to monotonic time.

 -- Function: modified-julian-day->time-tai MJD
     Convert a _Modified Julian Day_ to TAI time.

 -- Function: modified-julian-day->time-utc MJD
     Convert _Modified Julian Day_ to UTC time.

From monotonic 'time' to anything
.................................

 -- Function: time-monotonic->date TIME
 -- Function: time-monotonic->date TIME TZ-OFFSET
     Convert monotonic time to date, using time zone offset, which
     defaults to the local time zone.

 -- Function: time-monotonic->julian-day TIME
     Convert monotonic time to _Julian Day_.

 -- Function: time-monotonic->modified-julian-day TIME
     Convert monotonic time to _Modified Julian Day_.

 -- Function: time-monotonic->time-tai TIME
     Convert monotonic time to TAI time.

 -- Function: time-monotonic->time-tai! TIME
     Convert monotonic time to TAI time.  The TIME structure may be
     reused.

 -- Function: time-monotonic->time-utc TIME
     Convert monotonic time to UTC time.

 -- Function: time-monotonic->time-utc! TIME
     Convert monotonic time to UTC time.  The TIME structure may be
     reused.

From TAI 'time' to anything
...........................

 -- Function: time-tai->date TIME
 -- Function: time-tai->date TIME TZ-OFFSET
     Convert TAI time to date, using time zone offset, which defaults to
     the local time zone.

 -- Function: time-tai->julian-day TIME
     Convert TAI time to _Julian Day_.

 -- Function: time-tai->modified-julian-day TIME
     Convert TAI time to _Modified Julian Day_.

 -- Function: time-tai->time-monotonic TIME
     Convert TAI time to monotonic time.

 -- Function: time-tai->time-monotonic! TIME
     Convert TAI time to monotonic time.  The TIME structure may be
     reused.

 -- Function: time-tai->time-utc TIME
     Convert TAI time to monotonic time.

 -- Function: time-tai->time-utc! TIME
     Convert TAI time to monotonic time.  The TIME structure may be
     reused.

From UTC 'time' to anything
...........................

 -- Function: time-utc->date TIME-UTC
 -- Function: time-utc->date TIME-UTC TZ-OFFSET
     Convert UTC time to date, using time zone offset, which defaults to
     the local time zone.

 -- Function: time-utc->julian-day TIME
     Convert UTC time to _Julian Day_.

 -- Function: time-utc->modified-julian-day TIME
     Convert UTC time to _Modified Julian Day_.

 -- Function: time-utc->time-monotonic TIME
     Convert UTC time to monotonic time.

 -- Function: time-utc->time-monotonic! TIME
     Convert UTC time to monotonic time.  The TIME structure may be
     reused.

 -- Function: time-utc->time-tai TIME
     Convert UTC time to TAI time.

 -- Function: time-utc->time-tai! TIME
     Convert UTC time to TAI time.  The TIME structure may be reused.


File: vicare-libs.info,  Node: srfi time spec string,  Prev: srfi time spec conversion,  Up: srfi time spec

2.11.3.7 Date to string/string to date converters
.................................................

The following procedures provide conversion to and from strings.  They
are required.  The specification below describes a "locale"; the
specification of locales is beyond this SRFI.

 -- Function: date->string DATE
 -- Function: date->string DATE FORMAT-STRING
     Converts a date to a string, using the format string.  The format
     string is copied as is; except escape characters (indicated by the
     tilde) are replaced with specific conversions.  The following table
     lists the required conversion specifiers; implementations are free
     to extend this list.

     Escape Char   Conversion
     -------------------------------------------------------------------
     ~~            a literal ~
     ~a            locale's abbreviated weekday name (Sun...Sat)
     ~A            locale's full weekday name (Sunday...Saturday)
     ~b            locale's abbreviate month name (Jan...Dec)
     ~B            locale's full month day (January...December)
     ~c            locale's date and time (e.g., "Fri Jul 14
                   20:28:42-0400 2000")
     ~d            day of month, zero padded (01...31)
     ~D            date (mm/dd/yy)
     ~e            day of month, blank padded ( 1...31)
     ~f            seconds+fractional seconds, using locale's decimal
                   separator (e.g.  5.2).
     ~h            same as ~b
     ~H            hour, zero padded, 24-hour clock (00...23)
     ~I            hour, zero padded, 12-hour clock (01...12)
     ~j            day of year, zero padded
     ~k            hour, blank padded, 24-hour clock (00...23)
     ~l            hour, blank padded, 12-hour clock (01...12)
     ~m            month, zero padded (01...12)
     ~M            minute, zero padded (00...59)
     ~n            new line
     ~N            nanosecond, zero padded
     ~p            locale's AM or PM
     ~r            time, 12 hour clock, same as "~I:~M:~S ~p"
     ~s            number of full seconds since "the epoch" (in UTC)
     ~S            second, zero padded (00...60)
     ~t            horizontal tab
     ~T            time, 24 hour clock, same as "~H:~M:~S"
     ~U            week number of year with Sunday as first day of
                   week (00...53)
     ~V            week number of year with Monday as first day of
                   week (01...52)
     ~w            day of week (0...6)
     ~W            week number of year with Monday as first day of
                   week (01...52)
     ~x            week number of year with Monday as first day of
                   week (00...53)
     ~X            locale's date representation, for example:
                   "07/31/00"
     ~y            last two digits of year (00...99)
     ~Y            year
     ~z            time zone in RFC-822 style
     ~Z            symbol time zone (not-implemented)
     ~1            ISO-8601 year-month-day format
     ~2            ISO-8601 hour-minute-second-timezone format
     ~3            ISO-8601 hour-minute-second format
     ~4            ISO-8601
                   year-month-day-hour-minute-second-timezone format
     ~5            ISO-8601 year-month-day-hour-minute-second format

 -- Function: string->date INPUT-STRING TEMPLATE-STRING
     Convert an input string to a date, using the template string.  The
     input string must match the template string as is; except escape
     characters (preceded by a the tilde) indicate special converters
     which (1) move to the next character in the input string fulfilling
     a criterion; (2) read a value, and (3) act on this value in some
     way.  The table below lists the required converters;
     implementations are free to extend this list.

     Escape   Skip to            Read                         Contract
     -------------------------------------------------------------------------
     ~~       any                read literal ~               nothing
     ~a       char-alphabetic?   abbreviated weekday in       nothing
                                 locale
     ~A       char-alphabetic?   full weekday in locale       nothing
     ~b       char-alphabetic?   abbreviated month name in    nothing
                                 locale
     ~B       char-alphabetic?   full month name in locale    nothing
     ~d       char-numeric?      day of month                 date-day
     ~e       any                day of month, blank padded   date-day
     ~h       char-alphabetic?   same as ~b                   nothing
     ~H       char-numeric?      hour                         date-hour
     ~k       any                hour, blank padded           date-hour
     ~m       char-numeric?      month                        date-month
     ~M       char-numeric?      minute                       date-minute
     ~S       char-numeric?      second                       date-second
     ~y       any                2-digit year                 date-year
                                                              within 50
                                                              years
     ~Y       char-numeric?      year                         date-year
     ~z       any                time zone                    date-zone-offset


File: vicare-libs.info,  Node: srfi time ack,  Prev: srfi time spec,  Up: srfi time

2.11.4 Acknowledgements
-----------------------

Claus Toendering's Frequently Asked Questions about calendars was a very
useful resource.  The implementation of Julian Day, Modified Julian Day,
and Year Day comes from his FAQ.  Markus Kuhn has a useful description
of the ISO Standard 8601 for Date/Time notation.  The W3 Consortium also
has a useful Note.

   Mike Sperber, Marc Feely, Dave Mason, and "Prfnoff" all made useful
comments on previous versions of this draft.  Thanks to Shriram
Krishnamurthi for his editing help.

   The 'date->string' procedure uses a format string, based on GNU C's
'date()' procedure, as well as Scsh's 'format-date' procedure.


File: vicare-libs.info,  Node: srfi error-reporting,  Next: srfi marray,  Prev: srfi time,  Up: srfi

2.12 SRFI-23 error reporting mechanism
======================================

The library '(srfi :23)' is by Stephan Houben as the reference
implementation for SRFI-23; see:

            <http://srfi.schemers.org/srfi-23/srfi-23.html>

for more details.

* Menu:

* srfi error-reporting license::   Error-reporting document
                                   license.
* srfi error-reporting abstract::  Abstract.
* srfi error-reporting rationale:: Rationale.
* srfi error-reporting spec::      Specification.


File: vicare-libs.info,  Node: srfi error-reporting license,  Next: srfi error-reporting abstract,  Up: srfi error-reporting

2.12.1 Error-reporting document license
---------------------------------------

Copyright (C) 2001 Stephan Houben <stephanh@win.tue.nl>.  All Rights
Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi error-reporting abstract,  Next: srfi error-reporting rationale,  Prev: srfi error-reporting license,  Up: srfi error-reporting

2.12.2 Abstract
---------------

A mechanism is proposed to allow Scheme code to report errors and abort
execution.  The proposed mechanism is already implemented in several
Scheme systems and can be implemented, albeit imperfectly, in any R5RS
conforming Scheme.


File: vicare-libs.info,  Node: srfi error-reporting rationale,  Next: srfi error-reporting spec,  Prev: srfi error-reporting abstract,  Up: srfi error-reporting

2.12.3 Rationale
----------------

R5RS Scheme requires certain operations to signal an error when they
fail.  "Signalling an error" means that implementations must detect and
report the error.  Moreover, R5RS encourages, but not requires,
implementations to signal an error in many more circumstances.

   However, there is no direct way for the Scheme application programmer
to report an error that occured in his or her own application.  This
means that Scheme procedures created by applications or libraries are in
this respect not on equal footing with procedures provided by the Scheme
system.

   Many Scheme systems already provide a mechanism that allows
application code to report an error.  At least the following
implementations support such a mechanism: Bigloo, Guile, MIT Scheme, PLT
Scheme, RScheme, Scsh, SCM, all implementations supported by Slib.  Of
these implementations, the following have an error mechanism compatible
with this SRFI: Guile, MIT Scheme, PLT Scheme, RScheme, Scsh.  The
implementation in Slib has a different name than the one proposed in
this SRFI.

   To summarise, many implementations already have the error reporting
mechanism described in this SRFI and others are easily made compatible
with this SRFI.  This shows that the proposed mechanism is considered
useful and that it is easy to implement in most major implementations.


File: vicare-libs.info,  Node: srfi error-reporting spec,  Prev: srfi error-reporting rationale,  Up: srfi error-reporting

2.12.4 Specification
--------------------

 -- Function: error REASON [ARG1 [ARG2 ...]])
     The argument REASON should be a string.  The procedure error will
     signal an error, as described in R5RS, and it will report the
     message REASON and the objects ARG1, ARG2, ...

     What exactly constitutes "signalling" and "reporting" is not
     prescribed, because of the large variation in Scheme systems.  So
     it is left to the implementor to do something reasonable.  To that
     end, a few examples of possible behaviour are given.

       1. Display REASON and ARG1...  on the screen and terminate the
          Scheme program.  This might be suitable for a Scheme system
          implemented as a batch compiler.

       2. Display REASON and ARG1...  on the screen and go back to the
          read-evaluate-print loop.  This might be suitable for an
          interactive implementation.

       3. In the case of a multi-threaded system: terminate the current
          thread, but do not terminate the other threads.  Possibly make
          the arguments to error available to other threads in some way.
          See the 'thread-join!' mechanism in SRFI-18 on how this could
          be done.

       4. Package REASON and ARG1...  up into an error object and pass
          this error object to an exception handler.  The default
          exception handler then might do something as described in
          points 1 to 3.

       5. In the case of a Scheme system that runs completely unattended
          and that has no way to notify a human, the only reasonable
          course of action might be to do nothing at all.  However, this
          should be considered a last resort.  Clearly, if all
          implementors would choose this strategy, this SRFI would not
          be very useful.

     An implementation might report more information than just REASON
     and ARG1...  For instance, it might report the procedure name in
     which the error occured or even print a stack trace.  However, this
     will require additional support in the Scheme implementation.

Why error is a procedure
........................

It is conceivable to allow error to be a special form, such as a macro,
rather than a procedure.  This might make providing information such as
the source code location easier.  This possibility has been considered,
but rejected, for two reasons.

  1. Since error accepts a variable number of arguments, it could
     occasionally be useful to use apply to call error.  However, this
     is not possible if error was allowed to be a special form.

  2. Since error is currently a procedure in all Scheme implementations
     mentioned above, it doesn't seem all that worthwhile to allow it to
     be a special form.


File: vicare-libs.info,  Node: srfi marray,  Next: srfi shared structures,  Prev: srfi error-reporting,  Up: srfi

2.13 SRFI-25 multidimensional array
===================================

The library '(srfi :25)' is by Jussi Piitulainen as the reference
implementation for SRFI-25; see:

            <http://srfi.schemers.org/srfi-25/srfi-25.html>

for more details.

* Menu:

* srfi marray abstract::        Abstract.
* srfi marray rationale::       Rationale.
* srfi marray spec::            Specification.
* srfi marray ack::             Acknowledgements.
* srfi marray copyright::       Copyright.


File: vicare-libs.info,  Node: srfi marray abstract,  Next: srfi marray rationale,  Up: srfi marray

2.13.1 Abstract
---------------

A core set of procedures for creating and manipulating heterogeneous
multidimensional arrays is proposed.  The design is consistent with the
rest of Scheme and independent of other container data types.  It
provides easy sharing of parts of an array as other arrays without
copying, encouraging a declarative style of programming.

   The specification is based on an original contribution by Alan Bawden
in 1993.


File: vicare-libs.info,  Node: srfi marray rationale,  Next: srfi marray spec,  Prev: srfi marray abstract,  Up: srfi marray

2.13.2 Rationale
----------------

The proposed arrays encourage a natural declarative programming style.
They allow sharing of most any rectangular part of an array through an
affine index mapping, without copying.  But imperative style is equally
natural.

   The design is consistent with the two indexed data structures of
Scheme: vectors and strings.  The design makes arrays a self-contained
type.  These statements are illustrated in the following paragraphs.

   First, in the one-dimensional case, the arguments of the following
relevant calls match exactly.

     (vector-set! v k o)
     (string-set! s k c)
     (array-set! a k o)

   Likewise, 'make-array' matches 'make-vector' and 'make-string'.  An
analogue to 'vector', 'string' and 'list' is provided, alleviating the
lack of an external representation.  Index bounds are specified as for
'substring', lower bound included and upper bound excluded.

   Array shapes are specified as arrays.  These can be made with a
special procedure 'shape' that does not have a shape argument.  An array
does not retain a dependence to the shape array.  For example, mutation
of a shape array is allowed.

   Index mappings return multiple values as multiple values.

   Array dimensions can begin at any index.  In particular, the choice
between '0' and '1' is left to the user.  (Shapes and index objects are
zero based, though.)

   The ability to pack an index sequence in a vector is useful for
implementing higher level operations.  (The ability to pack it in a
one-dimensional array lets one use, say, a row of a matrix as an index.)

   It is not required that vectors not be arrays.  It is not required
that they be, either.


File: vicare-libs.info,  Node: srfi marray spec,  Next: srfi marray ack,  Prev: srfi marray rationale,  Up: srfi marray

2.13.3 Specification
--------------------

Arrays are heterogeneous data structures whose elements are indexed by
integer sequences of fixed length.  The length of a valid index sequence
is the "rank" or the number of "dimensions" of an array.  The "shape" of
an array consists of bounds for each index.

   The lower bound B and the upper bound E of a dimension are exact
integers with '(<= B E)'.

   A valid index along the dimension is an exact integer K that
satisfies both '(<= B K)' and '(< K E)'.  The length of the array along
the dimension is the difference '(- E B)'.  The "size" of an array is
the product of the lengths of its dimensions.

   A shape is specified as an even number of exact integers.  These are
alternately the lower and upper bounds for the dimensions of an array.

   The following ten procedures should be implemented.

 -- Function: array? OBJ
     Return '#t' if OBJ is an array, otherwise return '#f'.

 -- Function: make-array SHAPE
 -- Function: make-array SHAPE OBJ
     Return a newly allocated array whose shape is given by SHAPE.  If
     OBJ is provided, then each element is initialized to it.  Otherwise
     the initial contents of each element is unspecified.  The array
     does not retain a dependence to SHAPE.

 -- Function: shape BOUND ...
     Return a shape.  The sequence BOUND ... must consist of an even
     number of exact integers that are pairwise not decreasing.  Each
     pair gives the lower and upper bound of a dimension.  If the shape
     is used to specify the dimensions of an array and BOUND ... is the
     sequence B0 E0 ... BK EK ... of N pairs of bounds, then a valid
     index to the array is any sequence J0 ... JK ... of N exact
     integers where each JK satisfies '(<= BK JK)' and '(< JK EK)'.

     The shape of a D-dimensional array is a D * 2 array where the
     element at K = 0 contains the lower bound for an index along
     dimension K and the element at K = 1 contains the corresponding
     upper bound, where K satisfies '(<= 0 K)' and '(< K D)'.

 -- Function: array SHAPE OBJ ...
     Return a new array whose shape is given by SHAPE and the initial
     contents of the elements are OBJ ... in row major order.  The array
     does not retain a dependence to SHAPE.

 -- Function: array-rank ARRAY
     Return the number of dimensions of ARRAY.

          (array-rank (make-array (shape 1 2 3 4)))
          => 2

 -- Function: array-start ARRAY K
     Return the lower bound for the index along dimension K.

 -- Function: array-end ARRAY K
     Return the upper bound for the index along dimension K.

 -- Function: array-ref ARRAY K ...
 -- Function: array-ref ARRAY INDEX
     Return the contents of the element of ARRAY at index K ....  The
     sequence K ... must be a valid index to ARRAY.  In the second form,
     INDEX must be either a vector or a 0-based 1-dimensional array
     containing K ....

          (array-ref (array (shape 0 2 0 3)
                            'uno 'dos 'tres
                            'cuatro 'cinco 'seis)
                     1 0)
          => cuatro

          (let ((a (array (shape 4 7 1 2) 3 1 4)))
            (list (array-ref a 4 1)
                  (array-ref a (vector 5 1))
                  (array-ref a (array (shape 0 2) 6 1))))
          => (3 1 4)

 -- Function: array-set! ARRAY K ... OBJ
 -- Function: array-set! ARRAY INDEX OBJ
     Store OBJ in the element of ARRAY at index K ....  Return an
     unspecified value.  The sequence K ... must be a valid index to
     ARRAY.  In the second form, INDEX must be either a vector or a
     0-based 1-dimensional array containing K ....

          (let ((a (make-array (shape 4 5 4 5 4 5))))
            (array-set! a 4 4 4 'huuhkaja)
            (array-ref  a 4 4 4))
          => huuhkaja

 -- Function: share-array ARRAY SHAPE PROC
     Return a new array of shape SHAPE that shares elements of ARRAY
     through PROC.  The procedure PROC must implement an affine function
     that returns indices of ARRAY when given indices of the array
     returned by 'share-array'.  The array does not retain a dependence
     to SHAPE.

          (define i_4
            (let* ((i (make-array (shape 0 4 0 4) 0))
                   (d (share-array i (shape 0 4)
                                   (lambda (k)
                                     (values k k)))))
              (do ((k 0 (+ k 1)))
                   ((= k 4)
                    i)
                (array-set! d k 1))))

          *NOTE* The affinity requirement for PROC means that each value
          must be a sum of multiples of the arguments passed to PROC,
          plus a constant.

          *IMPLEMENTATION NOTE* Arrays have to maintain an internal
          index mapping from indices K1 ... KD to a single index into a
          backing vector; the composition of this mapping and PROC can
          be recognised as:

               (+ n0 (* n1 K1) ... (* nd KD))

          by setting each index in turn to 1 and others to 0, and all to
          0 for the constant term; the composition can then be compiled
          away, together with any complexity that the user introduced in
          their procedure.

   This document does not specify any external representation for
arrays.  This document does not specify when arrays are 'equal?'.
(Indeed, R5RS 'equal?' will do the wrong thing.)


File: vicare-libs.info,  Node: srfi marray ack,  Next: srfi marray copyright,  Prev: srfi marray spec,  Up: srfi marray

2.13.4 Acknowledgements
-----------------------

The original concept comes from a message to the Usenet newsgroup
<comp.lang.scheme> by Alan Bawden in 1993.  A variant of that
implementation by Richard Kelsey in the Scheme 48 system was also an
influence.  Apart from the origins, the main design goal has been
consistency with the core types of Scheme.

   Alan Bawden and Mark K. Gardner gave useful comments at an earlier
attempt to make this specification public.  (There was at least one
other.  Notes have gone missing.)  SRFI feedback led to improved
wording, hidden shapes, and two kinds of index objects.

   The exact title of the proposal comes from a message
(http://zurich.ai.mit.edu/pipermail/rrrs-authors/1998-May/002349.html)
titled "a process that might work" by William D. Clinger to the
'rrrs-authors' mailing list in 1998.  That appears to be a part of the
past of the SRFI (http://srfi.schemers.org/) process.


File: vicare-libs.info,  Node: srfi marray copyright,  Prev: srfi marray ack,  Up: srfi marray

2.13.5 Copyright
----------------

Copyright (C) 2001 Jussi Piitulainen.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi shared structures,  Next: srfi specialize-procedures,  Prev: srfi marray,  Up: srfi

2.14 SRFI-38 representation for data with shared structure
==========================================================

The library '(srfi :38)' was written by Ray Dillinger as the reference
implementation for SRFI-38; see:

            <http://srfi.schemers.org/srfi-38/srfi-38.html>

for more details.

* Menu:

* srfi shared structures license::      Original document license.
* srfi shared structures abstract::     Abstract.
* srfi shared structures rationale::    Rationale.
* srfi shared structures spec::         Specification.


File: vicare-libs.info,  Node: srfi shared structures license,  Next: srfi shared structures abstract,  Up: srfi shared structures

2.14.1 Original document license
--------------------------------

Copyright (C) 2003 Ray Dillinger.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi shared structures abstract,  Next: srfi shared structures rationale,  Prev: srfi shared structures license,  Up: srfi shared structures

2.14.2 Abstract
---------------

This SRFI proposes 'write-with-shared-structure' and
'read-with-shared-structure', procedures for writing and reading
external representations of data containing shared structure.  These
procedures implement a proposed standard external notation for data
containing shared structure.

   This SRFI permits but does not require replacing the standard 'write'
and 'read' functions.  These functions may be implemented without the
overhead in time and space required to detect and specify shared
structure.

   An implementation conforms to this SRFI if it provides procedures
named 'write-with-shared-structure' and 'read-with-shared-structure',
which produce and read the same notation as produced by the reference
implementation.  It may also provide 'read/ss' and 'write/ss',
equivalent functions with shorter names.


File: vicare-libs.info,  Node: srfi shared structures rationale,  Next: srfi shared structures spec,  Prev: srfi shared structures abstract,  Up: srfi shared structures

2.14.3 Rationale
----------------

R5RS scheme and IEEE scheme provide the procedure 'write', which prints
machine-readable representations of lists and other objects.  However,
the printed representation does not preserve information about what
parts of the structure are shared, and in the case of self-referential
objects the behavior of 'write' itself is undefined; it is permitted to
go into an infinite loop or invoke the dreaded curse of the nasal
demons.

   For example, it is possible to have a list within which two or more
members are the same string (in the sense of 'eq?'), but when the list
is written, there is not sufficient information in the representation to
recover the 'eq?' relationship.  When the list is read back in, there
will be two or more copies of the string which are 'eqv?' but not 'eq?'.

   As an example of the second problem, the results of evaluating:

     (begin (define a (cons 'val1 'val2))
            (set-cdr! a a)
            (write a))

are undefined; in R5RS parlance, calling 'write' on such a structure "is
an error", but not one that is necessarily signalled.  The routine is
permitted to print a nonstandard notation such as the one proposed in
this standard or a different one, fail silently, signal an error, go
into an infinite loop, or make demons fly out of your nose.  Some of
these results are unacceptable in some cases.  This SRFI hopes to
provide a standard way of dealing with this problem by providing a
method of writing data which is guaranteed to be well-behaved and
predictable even on data containing shared structures.

   The extended functionality described below in the implementation of
'write-with-shared-structure' is already present in the 'write' function
of several major scheme implementations (PLT, SISC, Chez, Bigloo, MIT
scheme, and possibly others).


File: vicare-libs.info,  Node: srfi shared structures spec,  Prev: srfi shared structures rationale,  Up: srfi shared structures

2.14.4 Specification
--------------------

Formal Grammar of the New External Representation
.................................................

This SRFI creates an alternative external representation for data
written and read under 'write/ss' and 'read/ss'.  It is identical to the
grammar for external representation for data written and read under
'write' and 'read' given in section 7 of R5RS, except that the single
production:

     <datum> --> <simple datum> | <compound datum>

   Is replaced by the following five productions.

     <datum> --> <defining datum> | <nondefining datum> | <defined datum>

     <defining datum> -->  #<indexnum>=<nondefining datum>

     <defined datum> --> #<indexnum>#

     <nondefining datum> --> <simple datum> | <compound datum>

     <indexnum> --> <digit 10>+

New Procedures
..............

 -- Procedure: write-with-shared-structure OBJ
 -- Procedure: write-with-shared-structure OBJ PORT
 -- Procedure: write-with-shared-structure OBJ PORT OPTARG
     Writes a written representation of OBJ to the given PORT.  Strings
     that appear in the written representation are enclosed in
     doublequotes, and within those strings backslash and doublequote
     characters are escaped by backslashes.  Character objects are
     written using the '#\' notation.

     Objects which denote locations rather than values (cons cells,
     vectors, and non-zero-length strings in R5RS scheme; also mutable
     objects, records, or containers if provided by the implementation),
     if they appear at more than one point in the data being written,
     must be preceded by '#N=' the first time they are written and
     replaced by '#N#' all subsequent times they are written, where N is
     a natural number used to identify that particular object.

     If objects which denote locations occur only once in the structure,
     then 'write-with-shared-structure' must produce the same external
     representation for those objects as 'write'.

     'write-with-shared-structure' must terminate in finite time when
     writing finite data.  'write-with-shared-structure' must produce a
     finite representation when writing finite data.

     'write-with-shared-structure' returns an unspecified value.

     The PORT argument may be omitted, in which case it defaults to the
     value returned by 'current-output-port'.

     The OPTARG argument may also be omitted.  If present, its effects
     on the output and return value are unspecified but
     'write-with-shared-structure' must still write a representation
     that can be read by 'read-with-shared-structure'.  Some
     implementations may wish to use OPTARG to specify formatting
     conventions, numeric radixes, or return values.  The reference
     implementation ignores optarg.

     For example, the code:

          (begin (define a (cons 'val1 'val2))
                 (set-cdr! a a)
                 (write-with-shared-structure a))

     should produce the output '#1=(val1 . #1#)'.  This shows a cons
     cell whose cdr contains itself.

 -- Procedure: read-with-shared-structure
 -- Procedure: read-with-shared-structure PORT
     'read-with-shared-structure' converts the external representations
     of Scheme objects produced by 'write-with-shared-structure' into
     scheme objects.  That is, it is a parser for the nonterminal
     '<datum>' in the augmented external representation grammar defined
     above.

     'read-with-shared-structure' returns the next object parsable from
     the given input port, updating port to point to the first character
     past the end of the external representation of the object.

     If an end-of-file is encountered in the input before any characters
     are found that can begin an object, then an end-of-file object is
     returned.  The port remains open, and further attempts to read it
     (by 'read-with-shared-structure' or 'read') will also return an
     end-of-file object.  If an end-of-file is encountered after the
     beginning of an object's external representation, but the external
     representation is incomplete and therefore not parsable, an error
     is signalled.

     The PORT argument may be omitted, in which case it defaults to the
     value returned by 'current-input-port'.  It is an error to read
     from a closed port.


File: vicare-libs.info,  Node: srfi specialize-procedures,  Next: srfi random,  Prev: srfi shared structures,  Up: srfi

2.15 SRFI-26 Notation for specializing parameters without currying
==================================================================

The library '(srfi :26)' is by Sebastian Egner as the reference
implementation for SRFI-26; see:

            <http://srfi.schemers.org/srfi-26/srfi-26.html>

for more details.

* Menu:

* srfi specialize-procedures license::    Original document license.
* srfi specialize-procedures abstract::   Abstract.
* srfi specialize-procedures rationale::  Rationale.
* srfi specialize-procedures spec::       Specification.
* srfi specialize-procedures design::     Rationale design.
* srfi specialize-procedures ack::        Acknowledgements.


File: vicare-libs.info,  Node: srfi specialize-procedures license,  Next: srfi specialize-procedures abstract,  Up: srfi specialize-procedures

2.15.1 Original document license
--------------------------------

Copyright (C) 2002 Sebastian Egner.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi specialize-procedures abstract,  Next: srfi specialize-procedures rationale,  Prev: srfi specialize-procedures license,  Up: srfi specialize-procedures

2.15.2 Abstract
---------------

When programming in functional style, it is frequently necessary to
specialize some of the parameters of a multi-parameter procedure.  For
example, from the binary operation 'cons' one might want to obtain the
unary operation '(lambda (x) (cons 1 x))'.  This specialization of
parameters is also known as "partial application", "operator section" or
"projection".

   The mechanism proposed here allows to write this sort of
specialization in a simple and compact way.  The mechanism is best
explained by a few examples:

     (cut cons (+ a 1) <>)   = (lambda (x2) (cons (+ a 1) x2))
     (cut list 1 <> 3 <> 5)  = (lambda (x2 x4) (list 1 x2 3 x4 5))
     (cut list)              = (lambda () (list))
     (cut list 1 <> 3 <...>) = (lambda (x2 . xs) (apply list 1 x2 3 xs))
     (cut <> a b)            = (lambda (f) (f a b))

   As you see, the macro 'cut' specializes some of the parameters of its
first argument.  The parameters that are to show up as formal variables
of the result are indicated by the symbol '<>', pronouced as "slot".  In
addition, the symbol '<...>', pronounced as "rest-slot", matches all
residual arguments of a variable argument procedure.  As you can see
from the last example above, the first argument can also be a slot, as
one should expect in Scheme.

   In addition to 'cut', there is a variant called 'cute' (a mnemonic
for "'cut' with evaluated non-slots") which evaluates the non-slot
expressions at the time the procedure is specialized, not at the time
the specialized procedure is called.  For example:

     (cute cons (+ a 1) <>) = (let ([a1 (+ a 1)])
                                (lambda (x2)
                                  (cons a1 x2)))

   As you see from comparing this example with the first example above,
the 'cute'-variant will evaluate '(+ a 1)' once, while the 'cut'-variant
will evaluate it during every invocation of the resulting procedure.

   The mechanism proposed in this SRFI allows specializing any subset of
the variables of a procedure.  The result can be of fixed arity or of
variable arity.  The mechanism does not allow permutation, omission,
duplication or any other processing of the arguments; for this it is
necessary to write to use a different mechanism such as 'lambda'.


File: vicare-libs.info,  Node: srfi specialize-procedures rationale,  Next: srfi specialize-procedures spec,  Prev: srfi specialize-procedures abstract,  Up: srfi specialize-procedures

2.15.3 Rationale
----------------

A particularly elegant way to deal with specialization is known as
currying (Schoenfinkel 1924, Curry 1958).  The idea of currying is to
reduce multi-argument functions to single-argument functions by
regarding an N-ary function as a unary function mapping its first
argument into an (N-1)-ary function (which is curried in turn).  This
point of view, apart from its theoretical elegance, allows an extremely
compact notation for specializing the first argument of a function.  In
the first example, one could simply write '(cons 1)'.

   Yet, Scheme is not a curried language--the number of arguments passed
to a procedure must match the number of its parameters at all times.
This allows zero-arity and variable-arity procedures but in order to
specialize parameters one usually has to write down a lambda-expression
and invent some irrelevant identifiers for its formal variables (X in
the examples in the Abstract).  For this reason, the mechanism proposed
in this SRFI provides a simple and compact notation for specializing any
subset of the parameters of a procedure.

   Note: _The mechanism proposed here is not currying!_

   The purpose of the mechanism proposed here is to make the benefits of
currying available within the programming language Scheme.  There are
two primary benefits of currying in practice: Higher-order types are
substantially simplified and there is a simple notation for specializing
parameters.  The type aspect is irrelevant as Scheme has latent typing.
The specialization aspect is largly covered with this SRFI.

   Here are a few more examples for illustration:

     (map (cut * 2 <>) '(1 2 3 4))
     (map (cut vector-set! x <> 0) indices)
     (for-each (cut write <> port) exprs)
     (map (cut <> x y z) (list min max))
     (for-each (cut <>) thunks)


File: vicare-libs.info,  Node: srfi specialize-procedures spec,  Next: srfi specialize-procedures design,  Prev: srfi specialize-procedures rationale,  Up: srfi specialize-procedures

2.15.4 Specification
--------------------

The formal syntax of a specialized expression, in the style of the
Revised^5 Report on the Algorithmic Language Scheme:

     <cut-expression> -->  (cut  <slot-or-expr> <slot-or-expr>*)
                         | (cut  <slot-or-expr> <slot-or-expr>* <...>)
                         | (cute <slot-or-expr> <slot-or-expr>*)
                         | (cute <slot-or-expr> <slot-or-expr>* <...>)

     <slot-or-expr>   -->  <>              ; a "slot"
                         | <expression>    ; a "non-slot expression"

   The macro 'cut' transforms a '<cut-expression>' into a '<lambda
expression>' with as many formal variables as there are slots in the
list '<slot-or-expr>*'.  The body of the resulting '<lambda expression>'
calls the first '<slot-or-expr>' with arguments from '<slot-or-expr>*'
in the order they appear.

   In case there is a rest-slot symbol, the resulting procedure is also
of variable arity, and the body calls the first '<slot-or-expr>' with
all arguments provided to the actual call of the specialized procedure.

   The macro 'cute' is similar to the macro 'cut', except that it first
binds new variables to the result of evaluating the non-slot expressions
(in an unspecific order) and then substituting the variables for the
non-slot expressions.  In effect, 'cut' evaluates non-slot expressions
at the time the resulting procedure is called, whereas 'cute' evaluates
the non-slot expressions at the time the procedure is constructed.


File: vicare-libs.info,  Node: srfi specialize-procedures design,  Next: srfi specialize-procedures ack,  Prev: srfi specialize-procedures spec,  Up: srfi specialize-procedures

2.15.5 Rationale design
-----------------------

Why not real currying/uncurrying?
.................................

It is possible in Scheme to implement a macro turning a multi-argument
procedure into a nesting of single-argument procedures and back.  These
operations are usually called "curry" and "uncurry" in other programming
languages.

   Yet, Scheme remains an inherently uncurried language and is not
prepared to deal with curried procedures in a convenient way.  Hence, a
"by the book" implementation of currying would only be useful if you
apply it in the sequence "curry, specialize some arguments, and uncurry
again", which is exactly the purpose of the macro 'cut' specified in
this document.  The primary relevance of currying/uncurrying in Scheme
is to teach concepts of combinatory logic.

Why not a more general mechanism, also allowing permutation omission and duplication of arguments?
..................................................................................................

The reason is that I, the author of this SRFI, consider more general
mechanisms too dangerous to mix them with the mechanism proposed here.
In particular, as soon as parameters are being rearranged it is usually
necessary to be aware of the meaning of the parameters; unnamed
variables can be quite harmful then.  The mechanism proposed here is
designed to prevent this.

   Please refer to the discussion threads "OK, how about...," (Alan
Bawden), "is that useful?"  (Walter C. Pelissero), and "l, the ultimate
curry that is not curry" (Al Petrofsky).

Why are the macro called 'cut'/'cute' and not [enter your favourite here]?
..........................................................................

Well, the original name proposed for this SRFI was 'curry' which
immediately stirred some emotions as it does not what is commonly known
as currying.  Some alternatives have been discussed, such as:

     section         specialise      specialize,
     partial-apply   partial-call    partial-lambda,
     _j              _i              $
     &               srfi-26         foobar
     xyz             schoenfinkelize curry-which-isnt-curry
     tandoori

and it has also been suggested to pick a five letter symbol uniformly at
random and fix this as a name.  To be fair, not all of these name have
been put forward as serious proposals, some of them were merely to
illustrate a point in the discussion.  In addition, I have played with
the game of the name quite a bit and considered other candidates not
listed here.

   Despite the fact that the discussion list only represents a highly
biased random sample of people's opinion (motivation to post a message
is higher if you disagree, for example) it told me that the SRFI could
potentially benefit from a different name; however impractical it may be
to go for unanimous popularity.

   The name 'cut' refers to "operator section", as the concept is often
called in other programming languages, but I tend to remember it as the
acronym for "Curry Upon This".  ;-) The names for the evaluating version
of 'cut' that have been proposed were 'cut!', 'cutlet', 'cut*', and
'cute'.

Is it possible to implement the SRFI without macros?
....................................................

Not really.  As Stephan Houben has pointed out during the discussion
(refer to "Implementing it as a procedure") it is possible to implement
the 'cute'-mechanism as a procedure.  Refer also to Al Petrofsky's
posting "Problems with _curry_'s formal specification" for details.

   However, the procedural implementation comes with a slight
performance penalty and it is not possible the implement the
'cut'-mechanism as a procedure, too.

   As both are needed, we rely on macros to implement the SRFI.  Why is
there another symbol for the rest-slot when 'lambda'-expressions use the
dotted notation for variable length argument lists?  There are two
reasons.  The first one is the existence of a procedural implementation
of a related mechanism (refer to the previous paragraph).  For a
procedure, however, it is not possible to have dotted notation.  The
second reason is the way the hygienic macro mechanism in R5RS is defined
to deal with dotted notation, as Felix Winkelmann has pointed out.
Refer to the discussion threads "Improper lists in macros [WAS: none]".

Why is it impossible to specify when a non-slot is evaluate individually per non-slot?
......................................................................................

'cut' evaluates all non-slots at the time the specialized procedure is
called and 'cute' evaluates all non-slots at the time the procedure is
being specialized.  These are only the two extremes and it is possible
to define a syntax that allows to choose per non-slot.  However, I am
convinced that the benefit of the greater flexibility is not worth the
risk of confusion.  If a piece of code really depends on the
distinction, it might be better to make this explicit through 'let' and
'lambda'.

Why is '(cut if <> 0 1)' etc. illegal?
......................................

It is specified that a '<slot-or-expr>' must be either the slot symbol
or an '<expression>' in the sense of R5RS, Section 7.1.3.  As if is no
'<expression>', the above case is illegal.  The reason why 'cut' and
'cute' are restricted in this sense is the difficulty of defining the
meaning of such generalized expressions.  Please refer to the discussion
archive for details.


File: vicare-libs.info,  Node: srfi specialize-procedures ack,  Prev: srfi specialize-procedures design,  Up: srfi specialize-procedures

2.15.6 Acknowledgements
-----------------------

An important part of this SRFI is based on the contribution of other
people, mostly through the discussion archive.  In particular, the
semantics and the design rationale have been greatly improved in the
course of the discussion.  I would like to thank all who have
contributed.


File: vicare-libs.info,  Node: srfi random,  Next: srfi basic-format,  Prev: srfi specialize-procedures,  Up: srfi

2.16 SRFI-27 sources of random bits
===================================

The library '(srfi :27)' is by Sebastian Egner as the reference
implementation for SRFI-27; see:

            <http://srfi.schemers.org/srfi-27/srfi-27.html>

for more details.

* Menu:

* srfi random license::         Random document license.
* srfi random abstract::        Abstract.
* srfi random rationale::       Rationale.
* srfi random spec::            Specification.
* srfi random design::          Design rationale.
* srfi random usage::           Recommended usage patterns.
* srfi random ack::             Acknowledgements.
* srfi random references::      References.

