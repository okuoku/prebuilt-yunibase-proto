This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: srfi compare-procedures copyright,  Next: srfi compare-procedures abstract,  Up: srfi compare-procedures

2.28.1 Copyright
----------------

Copyright (C) 2005 Sebastian Egner and Jens Axel Soegaard.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi compare-procedures abstract,  Next: srfi compare-procedures intro,  Prev: srfi compare-procedures copyright,  Up: srfi compare-procedures

2.28.2 Abstract and rationale
-----------------------------

This SRFI can be seen as an extension of the standard procedures '=',
'<', 'char<?' etc.  of R5RS--or even as a replacement.  The primary
design aspect in this SRFI is the separation of representing a total
order and using it.  For representing the order, we have chosen for
truly 3-way comparisons.  For using it we provide an extensive set of
operations, each of which accepts a procedure used for comparison.
Since these compare procedures are often optional, comparing built in
types is as convenient as R5RS, sometimes more convenient: For example,
testing if the integer index I lies in the integer range {0, ..., N - 1}
can be written as:

     (<=/<? 0 I N)

implicitly invoking 'default-compare'.

   As soon as new total orders are required, the infrastructure provided
by this SRFI is far more convenient and often even more efficient than
building each total order from scratch.

   Moreover, in case Scheme users and implementors find this mechanism
useful and adopt it, the benefit of having a uniform interface to total
orders to be used in data structures will manifest itself.  Most
concretely, a new sorting procedure in the spirit of this SRFI would
have the interface:

     (my-sort [ COMPARE ] XS)

using 'default-compare' if the optional compare was not provided.  Then
'my-sort' could be defined using the entire infrastructure of this SRFI:
Efficient 2- and 3-way branching, testing for chains and pairwise
inequality, min/max, and general order statistics.


File: vicare-libs.info,  Node: srfi compare-procedures intro,  Next: srfi compare-procedures conv,  Prev: srfi compare-procedures abstract,  Up: srfi compare-procedures

2.28.3 Introduction
-------------------

This SRFI defines a mechanism for comparing Scheme values with respect
to a total order (aka linear order) [1].  The mechanism provides
operations for:

  1. Comparing objects of the built in types.

  2. Using a total order in situations that arise in programs.

  3. Facilitating the definition of a new total order.

   In the following, these aspects will briefly be illustrated.

   Traditionally, a total order is represented in Scheme by an order
predicate, like '<' or 'char<?'.  For the purpose of this SRFI, however,
a total order is represented by a Scheme-procedure comparing its two
arguments and returning either '-1', '0', or '+1' depending on whether
the first argument is considered smaller, equal, or greater than the
second argument respectively.  Examples of such compare procedures
include:

     (lambda (x y) (sign (- x y)))

for comparing real numbers, but also:

     (lambda (x y) 0)

comparing anything.  For most built in types specified in the Revised5
Report on the Algorithmic Language Scheme (R5RS, [3]) compare procedures
are specified in Sections of this SRFI.  An axiomatic definition of
"compare procedure" is given in another section.

   The primary reason for using 3-valued compare procedures instead of
(2-valued) order predicates is efficiency: When comparison is
computationally expensive, it is wasteful if two predicates are
evaluated where a single 3-valued comparison would suffice.  This point
is discussed in greater detail in a section.

   But dealing directly with 3-valued comparisons in the application
program is inconvenient and obscures intention: For testing x < y one
would have to write:

     (eqv? (compare x y) -1)

   For this reason, an operation '<?' is supplied which allows to phrase
the same test as:

     (<?  compare x y)

   This is an example of mapping the three possible outcomes of a
comparison into the two boolean values '{#f, #t}'.  Since '<?' takes the
total order as an explicit parameter, a comfortably large arsenal of
tests can be made available for each and every total order.  This
deviates from the approach of R5RS, in which there are only five
operations ('=', '<', '>', '<=', '>=')--and for each total order
('real'/'number', 'char', 'char-ci', 'string', 'string-ci') a complete
set of these five operation is provided.

   But still, using '<?' would be inconvenient if the compare procedure
would have to be supplied explicitly every time.  For this reason, the
parameter compare is often made optional in this SRFI--and the procedure
'default-compare' is used whenever no compare procedure is passed
explicitly.  'default-compare' defines some resonable total order on the
built in types of R5RS.

   For the third aspect of this SRFI, defining compare procedures,
special control structures (macros) are provided.  These control
structures can be used in the definition of a (potentially recursive)
compare procedure.  This is best explained by an extended example.

Example
.......

Assume there is a type length representing physical length.  The type
has an accessor procedure meters returning the length in meters (a real
number).  A compare procedure for lengths can then be defined in terms
of 'real-compare' as:

     (define (length-compare length1 length2)
       (real-compare (meters length1) (meters length2)))

   Now,

     (<? length-compare x y)

tests if length X is shorter than length Y.  Also,

     (<=/<? length-compare a x b)

tests if length X lies between length A (inclusive) and length B
(exclusive).  The expression:

     (min-compare length-compare x y z)

is a shortest of the lengths X, Y, and Z.  Likewise,

     (chain<? length-compare x1 x2 x3 x4)

tests if the lengths X1, X2, X3, X4 are strictly increasing, and so on.

   Furthermore, assume there is another type box representing a physical
box.  The type has procedures width, height, and depth accessing the
dimension (each giving a length).  A compare procedure for boxes,
comparing first by width then by height and then by depth, can be
defined using the control structure 'refine-compare' as:

     (define (box-compare box1 box2)
       (refine-compare
         (length-compare (width  box1) (width  box2))
         (length-compare (height box1) (height box2))
         (length-compare (depth  box1) (depth  box2))))

   This time,

     (<? box-compare b1 b2)

tests if box B1 is smaller than box B2--in the sense of the order
defined.  Of course, all the other tests, minimum, maximum etc.  are
available, too.

   As a final complication, assume that there is also a type 'bowl' with
accessors 'radius' (a length) and 'open?' (a boolean).  Bowls are to be
compared first by whether they are open or closed, and then by radius.
However, bowls and boxes also need to be compared to each other, ordered
such that a bowl is considered "smaller" than a box.  (There are
type-test predicates 'box?' and 'bowl?').  Using the control structure
'select-compare' this can be expressed as:

     (define (container-compare c1 c2)
       (select-compare c1 c2
         (bowl? (boolean-compare (open?  c1) (open?  c2))
                (length-compare  (radius c1) (radius c2)))
         (box?  (box-compare c1 c2))
         (else "neither bowls nor boxes" c1 c2)))

   This is an example of "hierarchical extension" of compare procedures.
Also note the implicit use of 'refine-compare' in the 'bowl?' case.

   The preceeding example illustrates the main functionality of this
SRFI.


File: vicare-libs.info,  Node: srfi compare-procedures conv,  Next: srfi compare-procedures spec,  Prev: srfi compare-procedures intro,  Up: srfi compare-procedures

2.28.4 Terminology and conventions.
-----------------------------------

A "compare procedure" is a Scheme-procedure of two arguments returning
an exact integer in {-1, 0, +1} such that the valid input values are
ordered according to some total order.  A compare procedure, together
with a set of Scheme values to which it is applicable, represents a
compare function.

   A comparison is either an expression applying a compare procedure to
two values, or the result of such an expression.

   Each operation (macro or procedure) processing the value of a
comparison checks if the value is indeed an exact integer in the set
{-1, 0, +1}.  If this is not the case, an error is signalled.

   Compare procedures expecting certain types of argument should raise
an error in case the arguments are not of this type.  For most compare
procedures specified in this SRFI, this behavior is required.  A compare
procedure compare can be used for type-checking value X by evaluating
'(compare X X)', in case that is desired.  This is useful in procedures
like 'chain<?' which guarantee to check each argument unconditionally.


File: vicare-libs.info,  Node: srfi compare-procedures spec,  Next: srfi compare-procedures design,  Prev: srfi compare-procedures conv,  Up: srfi compare-procedures

2.28.5 Specification
--------------------

* Menu:

* srfi compare-procedures spec atom::   Comparing atoms.
* srfi compare-procedures spec seq::    Comparing lists and vectors.
* srfi compare-procedures spec pair::   Comparing pairs and
                                        improper lists.
* srfi compare-procedures spec def::    The default compare
                                        procedure.
* srfi compare-procedures spec const::  Constructing compare
                                        procedures.
* srfi compare-procedures spec using::  Using compare procedures.


File: vicare-libs.info,  Node: srfi compare-procedures spec atom,  Next: srfi compare-procedures spec seq,  Up: srfi compare-procedures spec

2.28.5.1 Comparing atoms
........................

In this section, compare procedures for most of the atomic types of R5RS
are defined: Booleans, characters, strings, symbols, and numbers.

   As a general naming convention, a procedure named

     TYPE-compare-ORDER

compares two object of the type TYPE with respect to a total order for
which ORDER is a mnemonic hint (e.g.  '-ci' for case-insensitive).  Of
course, '-ORDER' may be absent if there is just one order or the order
is obvious.  It is an error if a compare procedure accepting objects of
a certain type is called with one or two arguments not of that type.

 -- Function: boolean-compare BOOL1 BOOL2
     Compare two booleans, ordered by '#f < #t'.

          *NOTE* A non-'#f' value is not interpreted as a "true value,"
          but rather an error will be signalled.

 -- Function: char-compare CHAR1 CHAR2
 -- Function: char-compare-ci CHAR1 CHAR2
     Compare characters as 'char<=?' and 'char-ci<=?' respectively.  The
     suffix '-ci' means "case insensitive."

 -- Function: string-compare STRING1 STRING2
 -- Function: string-compare-ci STRING1 STRING2
     Compare strings as 'string<=' and 'string-ci<=?'.  The suffix '-ci'
     means "case insensitive."

          *NOTE* 'string-compare' could be defined as:

               (define (string-compare string1 string2)
                 (vector-compare-as-list char-compare
                                         string1 string2
                                         string-length string-ref))

 -- Function: symbol-compare SYMBOL1 SYMBOL2
     Compare symbols as 'string<=' on the names returned by
     'symbol->string'.

 -- Function: integer-compare X Y
 -- Function: rational-compare X Y
 -- Function: real-compare X Y
 -- Function: complex-compare X Y
 -- Function: number-compare X Y
     Compare two numbers.  It is an error if an argument is not of the
     type specified by the name of the procedure.

     Complex numbers are ordered lexicographically on pairs '(re, im)'.
     For objects representing real numbers 'sign(x - y)' is computed.
     The ordering for values satisfying 'real?' or 'complex?' but not
     representing a real or complex number should be consistent with
     procedures '=' and '<' of R5RS, and apart from that it is
     unspecified.

     Numerical compare procedures are compatible with the R5RS numerical
     tower in the following sense: If S is a subtype of the numerical
     type T and X, Y can be represented both in S and in T, then
     'compare-S' and 'compare-T' compute the same result.

          *NOTE* Floating point formats usually include several symbolic
          values not simply representing rational numbers.  For example,
          the IEEE 754 standard defines '-0', '-Inf', '+Inf', and 'NaN'
          ("not a number") for continuing a calculation in the presence
          of error conditions.  The behavior of the numerical comparison
          operation is unspecified in case an argument is one of the
          special symbols.

          *WARNING* The propagation of inexactness can lead to
          surprises.  In a Scheme system propagating inexactness in
          complex numbers (such as PLT, version 208):

               (complex-compare (make-rectangular (/ 1 3)  1.)
                                (make-rectangular (/ 1 3) -1))
               => -1

          At first glance, one might expect the first complex number to
          be larger, because the numbers are equal on their real parts
          and the first imaginary part ('1.') is larger than the second
          ('-1').

          Closer inspection reveals that the decimal dot causes the
          first real part to be made inexact upon construction of the
          complex number, and since:

               (exact->inexact (/ 1 3))

          is less than '(/ 1 3)' in the underlying floating point format
          used, the real parts decide the comparison of the complex
          numbers.


File: vicare-libs.info,  Node: srfi compare-procedures spec seq,  Next: srfi compare-procedures spec pair,  Prev: srfi compare-procedures spec atom,  Up: srfi compare-procedures spec

2.28.5.2 Comparing lists and vectors
....................................

In this section compare procedures are defined for Scheme lists and
vectors--and for objects that can be accessed like lists or like
vectors.

   An object X can be accessed like a vector if there are procedures
size and ref such that '(size X)' is a non-negative integer N indicating
the number of elements, and '(ref X I)' is the I-th element of X for I
\in {0, ..., N - 1}.  The default vector access procedures are
'vector-length' and 'vector-ref'.

   An object X can be accessed like a (proper) list if there are
procedures 'empty?', 'head', and 'tail' such that:

'(empty? X)'
     Is a boolean indicating that there are no elements in X.

'(head X)'
     Is the first element of X.

'(tail X)'
     Is an object representing the residual elements of X.

   The default list access procedures are 'null?', 'car', and 'cdr'.

   Independent of the way the elements are accessed, the natural
ordering of vectors and lists differs:

   * Sequences are compared as vectors if shorter sequences are smaller
     than longer sequences, and sequences of the same size are compared
     lexicographically.

   * Sequences are compared as lists if the empty sequence is smallest,
     and two non-empty sequences are compared by their first elements,
     and only if the first elements are equal the residual sequences are
     compared, recursively.

 -- Function: vector-compare X Y
 -- Function: vector-compare COMPARE X Y
 -- Function: vector-compare COMPARE X Y SIZE REF
 -- Function: vector-compare-as-list X Y
 -- Function: vector-compare-as-list COMPARE X Y
 -- Function: vector-compare-as-list COMPARE X Y SIZE REF
 -- Function: list-compare X Y
 -- Function: list-compare COMPARE X Y
 -- Function: list-compare COMPARE X Y EMPTY? HEAD TAIL
 -- Function: list-compare-as-vector X Y
 -- Function: list-compare-as-vector COMPARE X Y
 -- Function: list-compare-as-vector COMPARE X Y EMPTY? HEAD TAIL
     Compare two sequences X and Y, using COMPARE for comparing
     elements.  The result is an exact integer in '{-1, 0, +1}'.  If
     COMPARE is not supplied, 'default-compare' is used.

     The procedure named 'ACCESS-compare-as-ORDER' accesses the objects
     like ACCESS and compares them with respect to the order given by
     ORDER.  The names 'TYPE-compare' are abbreviations for
     'TYPE-compare-as-TYPE'.

     Examples:

          (list-compare           '(2) '(1 2))    =>  1
          (list-compare-as-vector '(2) '(1 2))    => -1
          (vector-compare         '#(2) '#(1 2))  => -1
          (vector-compare-as-list '#(2) '#(1 2))  =>  1


File: vicare-libs.info,  Node: srfi compare-procedures spec pair,  Next: srfi compare-procedures spec def,  Prev: srfi compare-procedures spec seq,  Up: srfi compare-procedures spec

2.28.5.3 Comparing pairs and improper lists
...........................................

In this section, compare procedures for Scheme pairs and (possibly)
improper lists are defined.

 -- Function: pair-compare-car COMPARE
 -- Function: pair-compare-cdr COMPARE
     Construct a compare procedure on pairs which only uses the car
     (only the cdr, respectively), and ignores the other.  One could
     define:

          (define (pair-compare-car compare)
             (lambda (x y)
               (compare (car x) (car y))))

          *RATIONALE* 'pair-compare-car' can be used to turn a search
          data structure (e.g.  a heap) into a dictionary: Store '(key .
          value)' pairs and compare them using the compare procedure:

               (pair-compare-car compare-key)

 -- Function: pair-compare COMPARE-CAR COMPARE-CDR PAIR1 PAIR2
 -- Function: pair-compare OBJ1 OBJ2
 -- Function: pair-compare COMPARE OBJ1 OBJ2
     Compare two pairs, or (possibly improper) lists.

     The 4-ary form compares two pairs PAIR1, PAIR2 by comparing their
     cars using 'compare-car', and if the cars are equal the cdrs are
     compared using 'compare-cdr'.

     The 3-ary form compares two objects by type using the ordering of
     types:

          NULL < PAIR < NEITHER-NULL-NOR-PAIR

     Two objects of type NEITHER-NULL-NOR-PAIR are compared using
     COMPARE.  Two pairs are compared by using compare on the cars, and
     if the cars are equal by recursing on the cdrs.

     The 2-ary form uses 'default-compare' for COMPARE.

          (pair-compare '() 'foo)      => -1
          (pair-compare '() '(1 . 2))) => -1
          (pair-compare '(1 . 2) 'foo) => -1
          (pair-compare 3 4)           => -1


File: vicare-libs.info,  Node: srfi compare-procedures spec def,  Next: srfi compare-procedures spec const,  Prev: srfi compare-procedures spec pair,  Up: srfi compare-procedures spec

2.28.5.4 The default compare procedure
......................................

It is convenient to have a compare procedure readily available for
comparing most built in types.

 -- Function: default-compare OBJ1 OBJ2
     Compare its arguments by type using the ordering:

          NULL < PAIR < BOOLEAN < CHAR <
               < STRING < SYMBOL < NUMBER < VECTOR < OTHER

     Two objects of the same type type are compared as 'TYPE-compare'
     would, if there is such a procedure.  The type NULL consists of the
     empty list '()'.  The effect of comparing two other objects or of
     comparing cyclic structures (made from lists or vectors) is
     unspecified.  (Implementations are encouraged to add comparisons
     for other built in types, e.g.  records, regexps, etc.)

          *RATIONALE* 'default-compare' refines 'pair-compare' by
          splitting NEITHER-NULL-NOR-PAIR.

          *NOTE* 'default-compare' could be defined as follows (mind the
          order of the cases!):

               (define (default-compare x y)
                 (select-compare x y
                   (null?    0)
                   (pair?    (default-compare (car x) (car y))
                             (default-compare (cdr x) (cdr y)))
                   (boolean? (boolean-compare x y))
                   (char?    (char-compare    x y))
                   (string?  (string-compare  x y))
                   (symbol?  (symbol-compare  x y))
                   (number?  (number-compare  x y))
                   (vector?  (vector-compare default-compare x y))
                   (else (error "unrecognized types" x y))))


File: vicare-libs.info,  Node: srfi compare-procedures spec const,  Next: srfi compare-procedures spec using,  Prev: srfi compare-procedures spec def,  Up: srfi compare-procedures spec

2.28.5.5 Constructing compare procedures
........................................

An important goal of this SRFI is to provide a mechanism for defining
new compare procedures as conveniently as possible.  The syntactic
extensions defined in this section are the primary utilities for doing
so.

 -- Syntax: refine-compare ?C1 ...
     Syntax.  The ?C1 are expressions.

     Semantics: The arguments ?C1 ...  are evaluated from left to right
     until a non-zero value is found (which then is the value) or until
     there are no more arguments to evaluate (in which case the value is
     0).  It is allowed that there are no arguments at all.

          *NOTE* This macro is the preferred way to define a compare
          procedure as a refinement.  Example:

               (define (compare-rectangle r s)
                 (refine-compare
                   (compare-length (width  r) (width  s))
                   (compare-length (height r) (height s))))

 -- Syntax: select-compare ?X1 ?X2 ?CLAUSE1 ...
     Syntax.  Each ?CLAUSE, with the possible exception of the last, is
     of the form:

          (?TYPE? ?C1 ...)

     where ?TYPE? is an expression evaluating to a predicate procedure,
     and ?C are expressions evaluating to an exact integer in '{-1, 0,
     +1}'.  The last ?CLAUSE may be an "else clause", which has the
     form:

          (else ?C1 ...)

     Semantics: 'select-compare' is a conditional for defining
     hierarchical extensions and refinements of compare procedures.  It
     compares the values of ?X1 and ?X2 by trying the type tests in
     order, and applies an implict 'refine-compare' on the consequences
     upon a match.

     In more detail, evaluation proceeds as follows:

       1. First ?X1 and ?X2 are evaluated in unspecified order,
          resulting in values X1 and X2, respectively.  Then the clauses
          are evaluated one by one, from left to right.

       2. For clause:

               (?TYPE? ?C1 ...)

          first ?TYPE? is evaluated resulting in a predicate procedure
          TYPE? and then the expressions '(TYPE? X1)' and '(TYPE? X2)'
          are evaluated and interpreted as booleans.

       3. If both booleans are true then the overall value is:

               (refine-compare ?C1 ...)

       4. If only the first is true the result is '-1', if only the
          second is true the result is '+1', and if neither is true the
          next clause is considered.

       5. An else clause is treated as if both tests where true.

       6. If there are no clauses left, the result is '0'.

     'select-compare' evaluates ?X1 and ?X2 exactly once, even in the
     absence of any clauses.  Moreover, each ?TYPE? is evaluated at most
     once and the resulting procedure ?TYPE? is called at most twice.

          *NOTE* An example of 'select-compare' is the definition of
          'default-compare' given above.

 -- Syntax: cond-compare ?CLAUSE1 ...
     Syntax.  Each ?CLAUSE, with the possible exception of the last, is
     of the form:

          ((?T1 ?T2) ?C1 ...)

     where ?T1 and ?T2 are expressions evaluating to booleans, and ?C
     are expressions evaluating to an exact integer in '{-1, 0, +1}'.
     The last ?CLAUSE may be an "else clause", which has the form:

          (else ?C1 ...)

     Semantics: 'cond-compare' is another conditional for defining
     hierarchical extensions and refinements of compare procedures.

     Evaluation proceeds as follows:

       1. The clauses are evaluated one by one, from left to right.

       2. For clause:

               ((?T1 ?T2) ?C1 ...)

          first ?T1 and ?T2 are evaluated and the results are
          interpreted as boolean values.

       3. If both booleans are true then the overall value is:

               (refine-compare ?C1 ...)

       4. If only the first is true the result is '-1', if only the
          second is true the result is '+1', and if neither is true the
          next clause is considered.

       5. An else clause is treated as if both booleans where true.

       6. If there are no clauses left (or there are no clauses to begin
          with), the result is '0'.

     'cond-compare' evaluates each expression at most once.

          *RATIONALE* 'cond-compare' and 'select-compare' only differ in
          the way the type tests are specified.  Both ways are
          equivalent, and each way is sometimes more convenient than the
          other.


File: vicare-libs.info,  Node: srfi compare-procedures spec using,  Prev: srfi compare-procedures spec const,  Up: srfi compare-procedures spec

2.28.5.6 Using compare procedures
.................................

The facilities defined in this section provide a mechanism for using a
compare procedure (passed as a parameter) in the different situations
arising in applications.

 -- Syntax: if3 ?C ?LESS ?EQUAL ?GREATER
     Syntax: ?C, ?LESS, ?EQUAL, and ?GREATER are expressions.

     Semantics: 'if3' is the 3-way conditional for comparisons.  First
     ?C is evaluated, resulting in value C.  The value C must be an
     exact integer in '{-1, 0, +1}', otherwise an error is signalled.

        * If 'C = -1' then the value of the 'if3'-expression is obtained
          by evaluating ?LESS.

        * If 'C = 0' then ?EQUAL is evaluated.

        * If 'C = 1' then ?GREATER is evaluated.

          *NOTE* As an example, the following procedure inserts X into
          the sorted list S, possibly replacing the first equivalent
          element.

               (define (insert compare x s)
                 (if (null? s)
                     (list x)
                   (if3 (compare x (car s))
                        (cons x s)
                        (cons x (cdr s)) ; replace
                        (cons (car s) (insert compare x (cdr s))))))

          *RATIONALE* 'if3' is the preferred way of branching on the
          result of a comparison in case all three branches are
          different.

 -- Syntax: if=? ?C ?CONSEQUENT
 -- Syntax: if=? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if<? ?C ?CONSEQUENT
 -- Syntax: if<? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if>? ?C ?CONSEQUENT
 -- Syntax: if>? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if<=? ?C ?CONSEQUENT
 -- Syntax: if<=? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if>=? ?C ?CONSEQUENT
 -- Syntax: if>=? ?C ?CONSEQUENT ?ALTERNATE
 -- Syntax: if-not=? ?C ?CONSEQUENT
 -- Syntax: if-not=? ?C ?CONSEQUENT ?ALTERNATE
     Syntax: ?C, ?CONSEQUENT, and ?ALTERNATE are expressions.  If
     ?ALTERNATE is not provided, '(if #f #f)' is used.

     Semantics: These six macros are 2-way conditionals for comparisons.
     First ?C is evaluated, resulting in value C.  The value C must be
     an exact integer in '{-1, 0, +1}', otherwise an error is signalled.
     Then, depending on the value of C and the name of the macro, either
     ?CONSEQUENT or ?ALTERNATE is evaluated, and the resulting value is
     the value of the conditional expression.

     The branch is chosen according to the following table:

                  ?CONSEQUENT      ?ALTERNATE
                                   
     -----------------------------------------------
     'if=?'       C = 0            C \in {-1, 1}
                                   
     'if<?'       C = -1           C \in {0, 1}
                                   
     'if>?'       C = 1            C \in {-1, 0}
                                   
     'if<=?'      C \in {-1, 0}    C = 1
                                   
     'if>=?'      C \in {0, 1}     C = -1
                                   
     'if-not=?'   C \in {-1, 1}    C = 0

          *NOTE* The macros 'if<=?' etc.  are the preferred way of 2-way
          branching based on the result of a comparison.

 -- Function: =?
 -- Function: =? COMPARE
 -- Function: =? X Y
 -- Function: =? COMPARE X Y
 -- Function: <?
 -- Function: <? COMPARE
 -- Function: <? X Y
 -- Function: <? COMPARE X Y
 -- Function: >?
 -- Function: >? COMPARE
 -- Function: >? X Y
 -- Function: >? COMPARE X Y
 -- Function: <=?
 -- Function: <=? COMPARE
 -- Function: <=? X Y
 -- Function: <=? COMPARE X Y
 -- Function: >=?
 -- Function: >=? COMPARE
 -- Function: >=? X Y
 -- Function: >=? COMPARE X Y
 -- Function: not=?
 -- Function: not=? COMPARE
 -- Function: not=? X Y
 -- Function: not=? COMPARE X Y
     If the values X and Y are given, test if X and Y are in the
     relation specified by the name of the procedure REL?, with respect
     to compare procedure COMPARE; otherwise construct a predicate
     procedure.

     In the forms:

          (REL? X Y)
          (REL? COMPARE X Y)

     the result is a boolean (either '#t' or '#f') depending on
     '(compare X Y)' and the test REL? as specified for 'if<?' etc.  If
     COMPARE is not supplied, 'default-compare' is used.

     In the form:

          (rel?)
          (rel? COMPARE)

     the predicate procedure:

          (lambda (x y) (REL? COMPARE x y))

     is constructed.  Again, if COMPARE is not supplied,
     'default-compare' is used.

     A few examples for illustration:

          (>? "laugh" "LOUD")                     => #t
          (<? string-compare-ci "laugh" "LOUD")   => #t

          (define char<=? (<=? char-compare))

          (sort-by-less '(1 a "b") (<?))          => ("b" a 1)
          (sort-by-less '(1 a "b") (>?))          => (1 a "b")

          *WARNING* A common mistake is writing '(<=? x y z)' where
          '(<=/<=? x y z)' is meant; this will most likely manifest
          itself at the time the expression '(x y z)' is evaluated.

 -- Function: </<?
 -- Function: </<? COMPARE
 -- Function: </<? X Y Z
 -- Function: </<? COMPARE X Y Z
 -- Function: </<=?
 -- Function: </<=? COMPARE
 -- Function: </<=? X Y Y
 -- Function: </<=? COMPARE X Y Y
 -- Function: <=/<?
 -- Function: <=/<? COMPARE
 -- Function: <=/<? X Y Y
 -- Function: <=/<? COMPARE X Y Y
 -- Function: <=/<=?
 -- Function: <=/<=? COMPARE
 -- Function: <=/<=? X Y Y
 -- Function: <=/<=? COMPARE X Y Y
 -- Function: >/>?
 -- Function: >/>? COMPARE
 -- Function: >/>? X Y Y
 -- Function: >/>? COMPARE X Y Y
 -- Function: >/>=?
 -- Function: >/>=? COMPARE
 -- Function: >/>=? X Y Y
 -- Function: >/>=? COMPARE X Y Y
 -- Function: >=/>?
 -- Function: >=/>? COMPARE
 -- Function: >=/>? X Y Y
 -- Function: >=/>? COMPARE X Y Y
 -- Function: >=/>=?
 -- Function: >=/>=? COMPARE
 -- Function: >=/>=? X Y Y
 -- Function: >=/>=? COMPARE X Y Y
     Test if X, Y, and Z form a chain with the two relations specified
     by the name of the procedure REL1/REL2?, with respect to the
     compare procedure COMPARE.

     If COMPARE is not provided, 'default-compare' is used.  If X, Y, Z
     are not provided, a predicate procedure of three arguments is
     constructed.  The order in which the values are compared is
     unspecified, but each value is compared at least once.

          *NOTE* '(<=/<? real-compare 0 X 1)' tests if X is a real
          number in the half open interval [0, 1).

 -- Function: chain=? COMPARE X ...
 -- Function: chain<? COMPARE X ...
 -- Function: chain>? COMPARE X ...
 -- Function: chain<=? COMPARE X ...
 -- Function: chain>=? COMPARE X ...
     Test if the values X ...  (zero or more values) form a chain with
     respect to the relation specified by the name of the procedure, and
     with respect to the compare procedure compare.  The result is a
     boolean (either '#t' or '#f').  The order in which the values are
     compared is unspecified, but each value is compared at least once
     (even if there is just one).

     A sequence of values X1, ..., XN forms a chain with respect to the
     relation REL? if:

          (REL? COMPARE XI XJ)

     for all 1 < I < J < N.  In particular, this is the case for n \in
     {0, 1}.

     Since the relations '=' , '<', '>', '<=', and '>=' are transitive,
     it is sufficient to test:

          (REL? COMPARE XI XI+1)

     for 1 < I < N.

          *NOTE* The reason every XI participates in at least one
          comparison is type-checking: After testing if the values form
          a chain, these value may be assumed to be of the type
          comparable by compare--and this holds irrespectively of the
          number of values, or whether they form a chain.

 -- Function: pairwise-not=? COMPARE X ...
     Test if the values X ...  (zero or more values) are pairwise
     unequal with respect to the compare procedure COMPARE.  The result
     is a boolean (either '#t' or '#f').  The order in which the values
     are compared is unspecified, but each value is compared at least
     once (even if there is just one).

     The values X1, ..., XN are pairwise unequal if:

          (not=? COMPARE XI XJ)

     for all i \not\in j.  In particular, this is the case for n \in {0,
     1}.

     Since COMPARE defines a total ordering on the values, the property
     can be checked in time O(n \log n), and implementations are
     required to do this.  (For example by first sorting and then
     comparing adjacent elements).

 -- Function: (min-compare COMPARE X1 X ...
 -- Function: (max-compare COMPARE X1 X ...
     A minimum or maximum of the values X1, X, ... (one or more values)
     with respect to the compare procedure COMPARE.

     The result is the first value that is minimal (maximal,
     respectively).  The order in which the values are compared is
     unspecified, but each value is compared at least once (even if
     there is just one value).

 -- Function: kth-largest COMPARE K X0 X ...
     The K-th largest element of values X0, X ... (one or more values)
     with respect to the compare procedure COMPARE.

     More precisely:

          (kth-largest COMPARE K X0 ... XN-1)

     returns the '(modulo k n)'-th element of the unique sequence
     obtained by stably sorting '(x0 ... xn-1)'.  (Recall that a sorting
     algorithm is stable if it does not permute items with equal key,
     i.e.  equivalent w.r.t.  COMPARE).

     The argument K is an exact integer, and n > 1.  The order in which
     the values XI are compared is unspecified, but each value is
     compared at least once (even if there is just one value).

          *Note* The 0-th largest element is the minimum, the (-1)-st
          largest element is the maximum.  The median is the (n-1)/2-th
          largest element if n is odd, and the average of the (n/2-1)-st
          and n/2-th largest elements if n is even.

 -- Function: compare-by< LT-PRED
 -- Function: compare-by< LT-PRED X Y
 -- Function: compare-by> GT-PRED
 -- Function: compare-by> GT-PRED X Y
 -- Function: compare-by<= LE-PRED
 -- Function: compare-by<= LE-PRED X Y
 -- Function: compare-by>= GE-PRED
 -- Function: compare-by>= GE-PRED X Y
 -- Function: compare-by=/< EQ-PRED LT-PRED
 -- Function: compare-by=/< EQ-PRED LT-PRED X Y
 -- Function: compare-by=/> EQ-PRED GT-PRED
 -- Function: compare-by=/> EQ-PRED GT-PRED X Y
     If optional arguments X and Y are present then these are compared
     with respect to the total order defined by the predicate(s) given;
     the result is in '{-1, 0, +1}'.  If X and Y are not present then a
     procedure comparing its two arguments using the predicate(s) given
     is constructed and returned.

     The predicate procedures mean the following: '(LT-PRED X Y)' tests
     if 'X < Y', LE-PRED tests for '<=', GT-PRED for '>', GE-PRED for
     '>=', and EQ-PRED tests if X and Y are equivalent.  The result
     returned by a predicate procedure is interpreted as a Scheme truth
     value (i.e.  '#f' is false and non-'#f' is true).

     The purpose of the procedures 'compare-byPREDICATE(S)' is to define
     a compare procedure from an order predicate, and possibly an
     additional equivalence predicate.  If an equivalence predicate
     EQ-PRED is given, it is called before the order predicate because
     the equivalence may be coarser than the total ordering, and it may
     also be cheaper.

          *NOTE* 'char-compare' could be defined in terms of 'char<=?'
          as:

               (define char-compare (compare-by<= char<=?))

 -- Function: debug-compare COMPARE
     Construct a compare procedure equivalent to COMPARE but with
     debugging code wrapped around the calls to COMPARE.  The debugging
     code signals an error if it detects a violation of the axioms of a
     compare function.  For this it is assumed that COMPARE has no
     side-effects.

     More specifically, '(debug-compare COMPARE)' evaluates to a compare
     procedure COMPARE1 which checks reflexivity, antisymmetry, and
     transitivity of COMPARE based on the arguments on which COMPARE1 is
     called.

     The procedure COMPARE1 checks reflexivity on any value passed to
     COMPARE, antisymmetry on any pair of values on which COMPARE is
     called, and transitivity on triples where two of the arguments are
     from the current call to COMPARE1 and the third is a pseudo-random
     selection from the two arguments of the previous call to COMPARE1.

          *RATIONALE* The test coverage is partial and determined
          pseudo-randomly, but the execution time of COMPARE1 is only a
          constant factor larger than the execution time of COMPARE.


File: vicare-libs.info,  Node: srfi compare-procedures design,  Next: srfi compare-procedures related,  Prev: srfi compare-procedures spec,  Up: srfi compare-procedures

2.28.6 Design rationale
-----------------------

In this section we present our reasoning behind the design decisions
made for this SRFI.  We would like to be explicit on this because we
believe that design is not about the outcome of decisions but about the
alternatives considered.  The section is organized as a Q&A list.

Order predicates (2-way) or 3-way comparisons?
..............................................

It is mathematical tradition to specify a total order in terms of a
"less or equal" ('<=') relation.  This usually carries over to
programming languages in the form of a '<=' predicate procedure.

   However, there are inherently three possible relations between two
elements x and y with respect to a total order: x < y, x = y, and x > y.
(With respect to a partial order there is a fourth: x and y are
uncomparable.)  This implies that any mechanism based on 2-valued
operations (be it <, or (= , <), or other) has cases in which two
expressions must be evaluated in order to determine the relation between
two elements.

   In practice, this is a problem if a comparison is computationally
expensive.  Examples of this are implicitly defined orders in which the
order of elements depends on their relative position in some
enumeration.  (Think of comparing graphs by isomorphism type.)  In this
case, each order predicate is as expensive as a compare
procedure--implying that a proper 3-way branch could be twice as fast as
cascaded 2-way branches.  Hence, there is a potentially considerable
loss in performance, and it is purely due to the interface for
comparisons.

   The primary disadvantage of bare 3-way comparisons is that they are
less convenient, both in use and in their definition.  Luckily, this
problem can be solved quite satisfactorily using the syntactic (macro)
and procedural abstractions of Scheme.

How to represent the three cases?
.................................

We have considered the following alternatives for representing the three
possible results of a comparison:

  1. the exact integers '-1', '0', and '+1' (used in this SRFI),

  2. the sign of an exact immediate integer,

  3. the sign of any Scheme number satisfying 'real?',

  4. three different symbols (e.g.  '<', '=', and '>'),

  5. an enumeration type consisting of three elements, and

  6. a built in type with self-evaluating special constants (e.g.  '#<',
     '#=', and '#>').

   The representation acts as an internal interface between programs
comparing objects and programs using these comparisons.

   The advantage of using only three values is that the representation
of each case is uniquely defined.  In particular, this enables the use
of case instead of if, and it ensures portability.  Portability of
numbers is problematic in R5RS due to underspecification and
inexactness.

   The advantage of using a non-unique (numerical) representation is
that the result of a computation can sometimes immediately be used in a
branch, much like the "non-'#f' means true"-convention.  However, with
the operations defined this advantage hardly matters.  Moreover, the
"non-'#f' means true"-convention is a major cause of unexpected program
behavior itself.

   The advantage of using '{-1, 0, +1}' over using three symbols is that
the integers support additional operations, for example they can
directly be used in index computations.  A particularly useful operation
is '(* sign (compare x y))' which inverts the order relation depending
on sign (either '-1' or '+1').  In addition, the integers are
unique--once it is known that comparisons result in integers it is
obvious which integers.  A minor consideration is that Scheme systems
usually treat small integers as unboxed values, and that integers are
self-evaluating literals.

   The advantage of using three symbols is that they can be chosen to be
more descriptive.  For example, it is more instructive to see
'(symbol-compare 'foo 'bar)' result in ''greater' than in '1'.
Unfortunately, there is no obvious choice of name for the three symbols.
Amoung the choices that make sense are ''less', ''equal', ''greater', or
''lt', ''eq', ''gt', or ''<', ''=', ''>'.  A disadvantage of using
symbols for the three cases is that Scheme symbols are ordered, too, and
this ordering may differ from the desired ordered for the three cases.

   Some Scheme implementations provide a mechanism for defining
enumeration types.  For example 'define-enumerated-type' of Scheme 48
can be used to define a type comparison consisting of three objects, say
'lt', 'eq', 'gt'.  The enumeration can also (directly) be defined on top
of SRFI-9 (Defining Record Types) [10] by defining three new record
types, each of which having a single instance.  We regard this approach
as preferable over three symbols because comparison results have their
own type, and a sufficiently advanced compiler could use this
information to eliminate redundant type-checks.

   One step further in this direction is the following design
alternative we have considered: Due to the fundamental nature of the
type comparison for programming, it would be worthwhile integrating it
into the core language of Scheme.  This could take the following form:
There are three self-evaluating constants, e.g.  written '#<' '#=' '#>',
and these are the only instances of the type comparison.  The type
supports two operations: 'comparison?' and 'comparison-compare'.
Furthermore, 'eq?', 'eqv?', and 'equal?' need to understand the
comparison values.  In other words, comparison is designed after
boolean.  It is unclear, however, which problem this tight integration
of comparisons into the language is solving.

   Given this situation, we have chosen for '{-1, 0, +1}', while
providing facilities for using this conveniently--in particular it is
hardly ever necessary to deal with the integers directly.

How to order complex numbers?
.............................

Mathematically, no total order of the complex numbers exists which is
compatible with the algebraic or topological structure.  Nevertheless,
it is useful for programming purposes to have some total order of
complex numbers readily available.

   Several total orders on the complex numbers are at least compatible
with the natural ordering of real numbers.  The least surprising of
these is lexicographic on '(re, im)'.

How to order special floating point symbols?
............................................

Floating point formats often do not only represent rational numbers but
extend this set by special symbols, for example '+Inf', '-Inf', 'NaN'
("Not a number"), and '-0'.  How should these symbols be ordered with
respect to the ordinary numerical values and with respect to each other?
(Refer to the discussion archive starting with 'msg00010'.)

   Let us briefly recall the purpose of the special symbols.  The
general rationale for introducing special symbols into a floating point
format is for numerical calculations to continue in the presence of
data-dependent errors, while still retaining some meaningful information
about the result.

   * The symbols '+Inf' and '-Inf' indicate that the calculation has
     produced a value exceeding the representable range.

   * The special symbol '-0', indicates that a calculation has produced
     a value of unrepresentable small magnitude, but retains the
     information that the underflow approached zero from the negative
     side (otherwise it would be '+0').  This sign information is useful
     in the presence of branch-cuts.

   * Finally, 'NaN' indicates that the information about the value has
     been lost entirely (example: '-Inf + Inf') 'NaN' avoids raising an
     exception and allows carrying on with other parts of the
     calculation.  It should be noted that several 'NaN's can exist.
     For example in the IEEE 754 standard many bit patterns represent
     'NaN' (whatever the interpretation).

   As '+Inf' and '-Inf' are designed to represent extremal numbers,
their ordering with respect to real numbers is obvious.  For signed
zeros, the ordering is also obvious.  However, the notion of two zeros
(or even three: '-0', '0', and '+0') is incompatible with the arithmetic
structure of the real numbers.  Hence, in most situations all zeros
should be treated as equal, even though this can destroy information
about results.  But the alternative design may also make sense in
certain situations where the full information carried in a floating
point object is to be retained.

   For 'NaN' (or even several 'NaN's) the situation is even more
ambiguous because there is not even a natural order relation of 'NaN'
with the other possible floating point values.  One design alternative
is to raise an error if 'NaN' is to participate in a comparison; the
reasoning being "if the control flow depends on a NaN you are in trouble
anyway".  An alternative is to define some order by force; the reasoning
being "if an object satisfies real?  then it can be compared with
real-compare."  Neither approach is obviously better than the other.

   Given this situation, we have decided to leave the effect of using a
special floating point value in 'real-compare' unspecified, in line with
the approach of R5RS.  This approach might change once Scheme itself is
more explicit about floating point representations and numerical
computation.

How to define 'default-compare'?
................................

The purpose of 'default-compare' is providing some well-defined way of
comparing two arbitrary Scheme values.  This can be used in all
situations in which the user is unwilling to define a compare procedure
explicitly, for example because the actual details of the total order do
not really matter.

   As an example, consider the task of dealing with sets of sets of
integers.  In this case, one could simply use sorted lists without
repetition for representing lists and 'default-compare' already provides
a total order.

   However, there are limits as to how 'default-compare' can be defined.
For example, 'default-compare' cannot easily be based on a hash code
derived from the pointer representing an object due to the close
dependency with the garbage collection mechanism.  Also, we believe it
to be more useful to applications if 'default-compare' is based on type
and structure.

   Unfortunately, this imposes limits on what can be compared using
'default-compare' because it is very desireable to have a portable
reference implementation.  In particular, portable ways of dealing with
circular structures are overly costly.

   Naturally, the question arises how the types should be ordered.  For
this question it is useful to understand that 'boolean-compare' and
'pair-compare' both already define a total order for all values (at
least in priciple).  Hence, 'default-compare' could refine one of them,
but unfortunately not both at the same time (unless '#f' and '()' are
minimum and maximum of the order, respectively).  Since 'pair-compare'
is more frequently used than 'boolean-compare' we base default-compare
on 'pair-compare'.  The other portably comparable types are ordered by
increasing complexity, which clearly is an arbitrary choice.

What is the "lexicographic order"?
..................................

The lexicographic order is a general way of defining an ordering for
sequences from an ordering of elements:

   In the lexicographic order, the empty sequence is the smallest
sequence of all, and two non-empty sequences are first compared by their
first element and only if these are equal the residual sequences are
compared, recursively.

   The lexicographic order has its name from its use in a lexicon: For
example, 'FUN < FUNLOVING < JOLLY'.

What is the "natural order" of lists and vectors?
.................................................

By "natural order" of an abstract data type we mean a total order that
is defined to match the basic operations operations supported by the
data type.

   The basic access operations with constant execution time for Scheme
lists are 'null?', 'car', and 'cdr'.  These are exactly the operations
needed for comparing two sequences lexicographically.

   The constant time access operations for Scheme vectors are
'vector-length' (size) and 'vector-ref' (ref).  Using these operations,
the fundamental ordering of vectors is first comparing by size, and only
if the sizes are equal, by comparing the elements lexicographically.

Why are vectors not ordered lexicographically?
..............................................

In this SRFI, lists and strings are ordered lexicographically ('LEX') by
default, e.g.  '"12" < "2"'.  The default order of vectors is first by
length and then lexicographically ('LENGTH-LEX'), e.g.  '#(2) < #(1 2)'.
Alternatively, vectors could be ordered purely lexicographically, too.
In the extreme, lists, strings, and vectors could even be ordered
lexicographically as sequences without distinguishing the concrete
representation, implying '"12" = (#\1 #\2) = #(#\1 #\2)'.

   The choice affects 'vector-compare', 'default-compare', and the way
orders are interpreted conceptually.  Moreover, this SRFI introduces the
terminology "ordered as lists" and "ordered as vectors" to refer to the
two fundamental ways of lifting an order to sequences (LEX and
LENGTH-LEX). The choice also has implications for any other SRFI
introducing container data types (e.g.  66 and 74), in case the author
wishes to specify default compare procedures compatible with this SRFI.

   Summarizing the discussion, there seem to be three major arguments:

  1. Conceptually vectors and lists are representations of sequences,
     and if there is only one ordering for them it should be LEX.

  2. LENGTH-LEX is more fundamental and efficient for types supporting a
     constant-time "size" operation.

  3. Conceptually strings are "vectors of characters" and strings are
     conventionally ordered LEX by default, so vectors should be ordered
     LEX as well in order to minimize the potential for confusion.

   (Please refer to the discussion archive for details, in particular
'msg00054'.)

   We consider 2.  the most important due to its mathematical nature,
followed by 1.  because it simplifies the design.  While this
controversial, we think that it is preferable to introduce different
orders for different data types, and not derive every order from a
single one for sequences.  Finally, we consider 3.  a weak argument
because the default ordering of strings is motivated primarily
historically for ordering written words of (small alphabet) natural
languages.

   Concerning other vector-like data types, such as those introduced by
SRFI-66 and SRFI-74, we recommend to define a default ordering which
appears most natural for the type.  These can conveniently be named
'TYPE-as-ORDERING'.  In cases where the order is of minor importance, we
recommend to be compatible with this SRFI.

Why so few higher-order constructions?
......................................

An alternative for the control structures (macros) 'refine-compare',
'select-compare', and 'cond-compare' is a set of higher-order procedures
for constructing compare procedures.

   We have chosen for control structures instead of higher-order
procedures for simplicity.  This becomes particularly evident when a
recursive compare procedure, e.g.  'default-compare', is to be defined.
Using 'select-compare' it is possible to define 'default-compare' simply
as a procedure calling itself in some branches.  In the higher-order
approach, the procedure under construction must also be able to call
itself, with arguments that are application specific.  Expressing this
with a flexible higher-order procedure is much more indirect.

Why the operations '<?', '<=?' etc.?
....................................

Programs need both 2-way branching and 3-way branching.  For 3-way
branching, the conditional 'if3' is provided.

   For 2-way branching, the set '{-1, 0, +1}' of results of a comparison
is mapped onto the set '{#f, #t}'.  There are eight functions from a
3-set into a 2-set; all six non-constant functions are provided as '=?',
'<?', etc.

   The five monotonic functions can be generalized to chains of values.
In order to make the compare procedure parameter optional in the
ordinary comparisons, separate operations ('chain<?', 'chain<=?', etc.)
are defined for chains.  For the sixth operation ('not=?') the
generalization to pairwise unequality is defined as 'pairwise-not=?'.
This operation can be implemented efficiently because the compare
procedure also defines a total order.

   As chains of length three are still frequently tested in programs
(think of a range check 0 < i < n), and often two different relations
are combined, there are special operations for chains of length three
('</<?', '</<=?', etc.)

   For convenience, the compare procedure argument is made optional as
often as possible.  Unfortunately, this opens up a possibility for
mistake: Writing '(<=? x y z)' where '(<=/<=? x y z)' is meant.
Fortunately, the mistake will likely manifest itself at the time '(x y
z)' is evaluated.

Why are '<?' etc. procedures, not macros?
.........................................

The procedures '<?', '</<?', 'chain<?' etc.  could also have been
specified as macros.  This would have the advantage that they could make
full use of "short evaluation": A chain of comparisons stops as soon as
one of the comparisons has failed; all remaining argument expressions
and comparisons need not be evaluated.  This is potentially more
efficient.

   The advantage of procedures, on the other hand, is that in Scheme
they are "first class citizens," meaning that they can be passed as
arguments and returned from higher-order procedures.

   Taking this approach one step further, one can even require the
compare procedures to check the types of all arguments, even if the
result of the comparison is already known.  This is what Section 6.2.5
of R5RS calls "transitive" behavior of the predicates '=', '<', etc.
For example, '(< 0 x y)' first tests if X is positive, and only if this
is the case '(< x y)' is tested.  But even if X is not positive it is
checked that Y is indeed a real--otherwise an error is raised.  In
"short evaluation," on the contrary, if X is not positive, Y can be an
arbitrary Scheme value.

   Clearly, "transitive" tests have an overhead, namely that they need
to execute potentially redundant type checks.  Even worse, as types are
only known to the compare procedure the only way to check the type of a
value is to compare it, maybe with itself (which should result in '0' by
definition of a compare procedure).

   The advantage of "transitive" comparisons is the automatic insertion
of a type assertion.  For example, after '(chain<? integer-compare x y
z)' has been evaluated, no matter the result, it is known that X, Y, and
Z are integers.  We consider this advantage sufficiently important to
pay the price.

Why 'compare-by<' etc.?
.......................

It is often easier to define an order predicate, and possibly a separate
equivalence relation, than it is to define a compare procedure.  For
this case, 'compare<' etc.  provide a convenient and robust way of
constructing the associated compare procedure.

   As has been learned from writing the reference implementation,
despite the fact that each of these procedures is just a few lines of
trivial code, they miraculously attract bugs.

How do I define a compare function from just an equivalence?
............................................................

You better don't.

   A compare function defines a total order on equivalence classes, and
vice versa.  Hence, a compare procedure compare can be used to test
equivalence: '(=? compare x y)'.

   In reverse, one could be tempted to define a "compare function" c
from just an equivalence relation '~' as c(x, y) = 0 if x ~ y and c(x,
y) = 1 otherwise.  However, c is not antisymmetric (unless all objects
are equivalent, i.e.  c(x,y) = 0 for all x, y) and hence it is not a
compare function.  In fact, there is no way at all of avoiding a total
order on the equivalence classes.

   This is also reflected in the fact that there are efficient
(log-time) search data structures based on a total order, but we know of
no efficient (sublinear worst-case) data structures based solely on an
equivalence relation.  The following program takes time and space O(h),
where h is the number of equivalence classes in use:

     (define (equal->compare equal)
       (let ((reps '()) (length-reps 0))
         (define (index x)
           (let loop ((i (- length-reps 1)) (rs reps))
             (if (null? rs)
                 (let ((i length-reps))
                   (set! reps (cons x reps))
                   (set! length-reps (+ length-reps 1))
                   i)
                 (if (equal x (car rs))
                     i
                     (loop (- i 1) (cdr rs))))))
         (lambda (x y)
           (integer-compare (index x) (index y)))))

   If EQUAL is an equivalence predicate (i.e.  it is reflexive,
symmetric, and transitive) then '(equal->compare EQUAL)' is a compare
procedure for the objects comparable by EQUAL.  The total order defined
is unspecified (as it depends on call sequence).

   Note that the equivalence predicate equal could be defined by using a
union-find data structure.  But keep in mind that the equivalence
relation represented by equal must not change while '(equal->compare
EQUAL)' is in use-so the union-find data structure must be unite
classes.

How do I switch from R5RS to this SRFI?
.......................................

As it happens, the specification of this SRFI is fully compatible with
the 25 order predicates found in R5RS.  The easiest way of switching is
by defining the R5RS operations in terms of this SRFI.

   Alternatively, each expression involving a reference to an R5RS order
predicate can be transformed into an equivalent expression using the
facilities of this SRFI.  Be reminded though that this requires an
understanding of the context of the expression in question, in
particular variable bindings, macro definitions, and the use of eval.

   However, if the meaning of an expression may be altered, it is often
possible to increase type safety or simplicity.  Consider for example
the following potential replacements of '(and (<= 0 i) (< i n))':

     (and (<=? real-compare 0 i) (<? real-compare i n))
     (<=/<? real-compare 0 i n)    ; always compares n
     (<=/<? integer-compare 0 i n) ; only integer i, n
     (<=/<? 0 i n)                 ; uses default-compare

   Only the first alternative is equivalent to the original expression,
but the other alternatives might be useful, too, depending on the goal.

Why be so tight with types?
...........................

Most procedures and macros in this SRFI are required to signal an error
if an argument is not according to the type specified, in particular
comparison values must be exact integer in '{-1, 0, +1}' at all times.
Alternatively, we could have specified that procedures and macros accept
values as general as makes sense.

   We believe that being tight on types at this fundamental level of a
language pays off quickly.  In particular, this will simplify debugging.
Moreover, static analysis of a program will recognize more variables of
a known type, which allows for more unboxed values and tighter compiled
code.  (Clearly, at the time of this writing this is speculative.)

Is there a performance penalty for this SRFI?
.............................................

Yes and no.

   The focus of the reference implementation is correctness and
portability; performance will very likely suffer due to the overhead of
internal procedure calls and type-checking.

   But as the word "SRFI" suggests, this document is a "request for
implementation," meaning we would love to see this SRFI being
implemented efficiently by the implementation experts of particular
Scheme systems.  In practice, this means that most of the operations
defined here, if not all, are supported natively.

   In this case, there is no performance penalty for using the
mechanisms of this SRFI--using this SRFI might even be faster due to
explicit 3-way branching and better typing.

Why are there optional leading arguments?
.........................................

Some operations have an optional first argument.  This is in contrast to
common practice in Scheme to put optional arguments after mandatory
arguments.

   The leading optional argument is always the argument compare,
representing the total order to be used.  If it is missing
'default-compare' is used.

   In the cases where we have chosen to make compare optional it is for
the sake of brevity, e.g.  in '(<? x y)' instead of enforcing '(<?
default-compare x y)'.  Although an option introduces potential for
confusion (e.g.  '(<? x y z)' vs.  '(</<? x y z)'), we consider it an
important feature for interactive use and convenient programming (e.g.
in '(do ((i 0 (+ i 1))) ((=? i n)))').

   Given our decision for optional compare, the question arises how to
pass the option.  In the absence of other widely accepted mechanisms for
options, we can only vary the length of the argument list.  For
historical reasons--before 'case-lambda' of SRFI-16--optional arguments
are passed at the end of the argument list for simplified parsing.  On
the other hand, '(<? compare x y)' is more consistent with the rest of
the SRFI than '(<? x y compare)'.

   Unfortunately, any particular choice here is a compromise, and it is
also controversial.  (Please refer to the discussion archive for
details, in particular 'msg00051'.)  We have chosen for notational
convenience in the common case (optional compare) and for consistency
within this SRFI (leading optional argument).

Why 'chain<?' etc. and not a predicate parameter?
.................................................

This SRFI specifies the five chain predicates 'chain=?', 'chain<?',
'chain>?', 'chain<=?', and 'chain>=?'.  An alterative is to define a
single chain predicate that has the ordering as a parameter.  (Refer to
the discussion archive starting with 'msg00012'.)

   The reason we have chosen for five chain predicates is that we use
compare procedures to represent orders, not predicate procedures.  There
are five possible order relations predicates for which a chain test
makes sense.  (The sixth, 'not=?', is not not transitive and hence
requires pairwise testing.)  The five chain tests are clearly defined
and can be implemented efficiently, their main overhead being the call
to the compare procedure.

Why not more higher-order procedures?
.....................................

In this SRFI 'min-compare' accepts a compare procedure as a first
mandatory argument, applying the minimum operation to the list of all
other arguments.  An alternative is to have 'min-compare' accept only
the compare procedure (possibly optional) and returing a procedure
computing the minimum of all its arguments (with respect to the compare
procedure.)  In a similar fashion other operations can specified as
higher-order procedures.

   We have avoided higher-order procedures in this SRFI for simplicity
and efficiency.  As said repeatedly, compare procedures are the main
vehicle to transport total orders from the code site definine an order
to the code site using an order.  Moreover, most operations made
available through this SRFI appear rather infrequently in programs, so
either way there is little to be gained.  Finally, dealing with
higher-order procedures often involves writing more parentheses and the
more simple-minded Scheme systems will create many short-lived closures.

Why do '<?' etc. have so many options?
......................................

The procedures '=?', '<?' etc.  accept an optional compare procedure but
also two optional arguments to compare.  This could be made simpler by
not specifying some of the cases, or by specifying different procedures
for the different functions.

   The operations '<?' etc.  are the primary mechanism for using compare
procedures.  As such they should be versatile and concise.

   Our original design had two mandatory arguments for objects to
compare and an optional argument for the compare procedure, i.e.  it
provides a parametric comparison '(<? compare x y)' of two objects.
Amir Livne Bar-On then raised the issue of having better support for a
higher-order style of programming, i.e.  '((<? compare) x y)'.  (Refer
to 'msg00012'.)

   However, in Scheme the higher-order style is less convenient than it
is in curried programming languages like Haskell or ML. In practice this
manifests itself as follows: The most basic and frequent case of
comparing atomic objects with respect to the default ordering would read
'((<=?) x y)', which is just two parentheses short of optimal.

   Fortunately, Dave Mason proposed a syntax for resolving the apparent
alternative parametric test vs.  higher order style.  (Refer to
'msg00014'.)  By combining both functionalities into a single procedure,
the user can choose the style at any moment.


File: vicare-libs.info,  Node: srfi compare-procedures related,  Next: srfi compare-procedures refs,  Prev: srfi compare-procedures design,  Up: srfi compare-procedures

2.28.7 Related work
-------------------

The use of compare procedures is not new; defining control structures
('if3', 'select-compare' etc.)  for dealing with them efficiently,
however, seems to be new (at least we have not seen it before).

   Total ordering in R5RS is represented by typed order predicates, such
as '<=', 'char<=?' etc.  Although a "less or equal"-predicate is
sufficient to define a total order, R5RS defines a complete set of
compare predicates (that is '=' , '<', '>', '<', and <) for the sake of
convenience and readability.  There are 25 procedures related to total
orders in R5RS.

   The traditional approach in Scheme to equivalence ("Are two values
treated as equal?")  is the fixed set of predicates 'eq?', 'eqv?', and
'equal?'.  Historically, this approach was motivated by the desire to
compare only pointers and avoid structural recursion.  This SRFI
provides the generalization to arbitrary equivalence relations, provided
the equivalence classes are totally ordered.

   The Ruby programming language [4] provides a method '<=>' which is a
compare procedure in the sense of this SRFI.  By (re-)defining this
method a total order can be defined for the instances of a class, when
compared against other objects.  All 2-way comparisons are based on
'<=>', but in Ruby essentially every method can be overloaded.

   In the Haskell 98 programming language [6] order predicates and
compare functions coexist.  The type Ordering [6, Sect 6.1.8] is an
enumeration of the three symbolic constants 'LT', 'EQ', 'GT'.  The type
class 'Ord' [6, Sect 6.3.2] asserts the presence of a total order for a
type, provided the type class 'Eq' [6, Sect 6.3.1] also asserts the
presence of an equivalence.  Since the default definition of the method
compare is in terms of the methods '==' and '<=', and vice versa, it can
be chosen easily how to provide the total order without affecting its
pattern of use.

   The C function 'strcmp()' [7] of the 'string.h'-library acts as a
compare procedure in the sense of this SRFI, although it is specified to
return an integer of which only the sign matters.  Python [5] has a
built in function 'cmp' which is a compare procedure in the sense of
this SRFI.

   In SRFI-32 (Sort libraries) [13] the total orders used for sorting
are represented by a "less than" procedure.  The discussion archive [13]
contains a short discussion thread on the use of 3-value comparisons
under the aspect whether they can be used to improve the sorting
algorithm itself.

   In the 'Galore.plt' library of data structures for PLT Scheme, total
orders are represented by the signature definition '(define-signature
order^ (elm= elm< elm<=))'.


File: vicare-libs.info,  Node: srfi compare-procedures refs,  Prev: srfi compare-procedures related,  Up: srfi compare-procedures

2.28.8 References
-----------------

   * [1] E. Weisstein: Totally Ordered Set, Mathworld at Wolfram
     Research.  TotallyOrderedSet.html

   * [2] E. Weisstein: Equivalence Relation, Mathworld at Wolfram
     Research.  mathworld.wolfram.com/EquivalenceRelation.html

   * [3] R. Kelsey, W. Clinger, J. Rees (eds.): Revised5 Report on the
     Algorithmic Language Scheme, Higher-Order and Symbolic Computation,
     Vol.  11, No.  1, August, 1998.

             <www.schemers.org/Documents/Standards/R5RS/>

   * [4] Y. Matsumoto: Programming Ruby.  The Pragmatic Programmer's
     Guide.

               <www.ruby-doc.org/docs/ProgrammingRuby/>

   * [5] G. van Rossum, F. L. Drake, Jr., (ed.): Python Library
     Reference.  Release 2.4 of 30 November 2004.  Section 2.1 "built-in
     functions".  Python Software Foundation.

                 <http://docs.python.org/lib/lib.html>

   * [6] S. Peyton Jones (ed.): Haskell 98 Language and Libraries The
     Revised Report, December 2002.

                 <http://www.haskell.org/definition/>

   * [7] ANSI-C ISO/IEC 9899:1999, published 1 December.

        <http://www.open-std.org/jtc1/sc22/wg14/www/standards>

   * [8] J. A. Soegaard: Data Structures Galore for PLT Scheme.

<http://planet.plt-scheme.org:80/207.1/docs/soegaard/galore.plt/1/1/doc.txt>

   * [9] L. T. Hansen: SRFI-16 Syntax for procedures of variable arity.

                  <http://srfi.schemers.org/srfi-16/>

   * [10] R. Kelsey: SRFI-9 Defining record types.

                  <http://srfi.schemers.org/srfi-9/>

   * [11] S. Houben: SRFI-23 Error reporting mechanism.

                  <http://srfi.schemers.org/srfi-23/>

   * [12] S. Egner: SRFI-27 Sources of random bits.

                  <http://srfi.schemers.org/srfi-27/>

   * [13] O. Shivers: SRFI-32 Sort libraries.  Section "Ordering,
     comparison functions & stability" and mail-archive
     'msg000{23,24,33}.html'.  SRFI has been withdrawn July 17, 2003.

                  <http://srfi.schemers.org/srfi-32/>

   * [14] S. Egner: SRFI-42 Eager comprehensions.

                  <http://srfi.schemers.org/srfi-42/>

   * [15] PLT Scheme.

                     <http://www.plt-scheme.org/>

   * [16] R. Kelsey, J. Rees: Scheme48, version 1.1.

                           <http://s48.org/>

   * [17] Chicken, version 1.70.

               <www.call-with-current-continuation.org.>


File: vicare-libs.info,  Node: srfi hash-tables,  Next: srfi lightweight-testing,  Prev: srfi compare-procedures,  Up: srfi

2.29 SRFI-69 basic hash tables
==============================

The library '(srfi :69)' is by Andreas Rottmann as the reference
implementation for SRFI-39 by Panu Kalliokoski; see:

            <http://srfi.schemers.org/srfi-69/srfi-69.html>

for more details.

* Menu:

* srfi hash-tables abstract::   Abstract.
* srfi hash-tables issues::     Issues.
* srfi hash-tables rationale::  Rationale.
* srfi hash-tables spec::       Specification.
* srfi hash-tables copyright::  Copyright.


File: vicare-libs.info,  Node: srfi hash-tables abstract,  Next: srfi hash-tables issues,  Up: srfi hash-tables

2.29.1 Abstract
---------------

This SRFI defines basic hash tables.  Hash tables are widely recognised
as a fundamental data structure for a wide variety of applications.  A
hash table is a data structure that:

  1. Provides a mapping from some set of keys to some set of values
     associated to those keys.

  2. Has no intrinsic order for the (key, value) associations it
     contains.

  3. Supports in-place modification as the primary means of setting the
     contents of a hash table.

  4. Provides key lookup and destructive update in amortised constant
     time, provided that a good hash function is used.

   This SRFI aims to accomplish these goals:

  1. To provide a consistent, generic and widely applicable API for hash
     tables.

  2. To improve code portability by providing a standard hash table
     facility with guaranteed behaviour.

  3. To help the programmer by defining utility routines that account
     for the most common situations of using hash tables.


File: vicare-libs.info,  Node: srfi hash-tables issues,  Next: srfi hash-tables rationale,  Prev: srfi hash-tables abstract,  Up: srfi hash-tables

2.29.2 Issues
-------------

There is no single best way to make hash tables.  The tables presented
in this SRFI aim at being both conceptually simple and usable for a wide
variety of applications.  Even though a portable implementation is
provided, Scheme implementations can speed things up considerably by
e.g.  providing an internal hash function for symbols.  Moreover, almost
every Scheme implementation already has some kind of low-level hash
table functionality, because that's the natural way to implement the
global environment, and specifically, to provide support for
'string->symbol'.  There might be some benefit in integration between
implementation-specific environment data types and the hash table API
presented here; however, these issues are left open.

   This SRFI does not conform to the interface of maps presented in
SRFI-44.  Following SRFI-44 would seriously cripple the interface of
hash tables.  The naming of the operations for maps in SRFI-44 goes
against common use and is unnatural.  However, this SRFI has been
written so that it does not prevent a SRFI-44 API to hash tables.  An
implementation supporting both SRFI-44 and this SRFI is encouraged to
provide a SRFI-44 interface to hash tables in addition to the one
presented here.


File: vicare-libs.info,  Node: srfi hash-tables rationale,  Next: srfi hash-tables spec,  Prev: srfi hash-tables issues,  Up: srfi hash-tables

2.29.3 Rationale
----------------

Hash tables are widely recognised as a fundamental data structure for
many kinds of computational tasks.  Thus far, there is no existing
standard for Scheme hash tables; however, almost every non-minimal
Scheme implementation provides some kind of hash table functionality.

   Alas, although somewhat similar, these hash table APIs have many
differences: some trivial, like the naming of certain functions; some
complex, like revealing different aspects of the internal implementation
to the user; some coarse, like requiring keys to be of some specific
type(s); some subtle, like requiring the user to guess the size of the
hash table in advance to get optimal performance.  As a result, the
existing hash table facilities cannot be used to write portable
programs.

   The primary aim of this SRFI is to establish a standard API for hash
tables so that portable programs can be written that make efficient use
of common hash table functionality.  The SRFI resolves discrepancies
that exist between the various hash table API's with respect to naming
and semantics of hash table operations.  A lot of effort has been put
into making the the API consistent, simple and generic.  The SRFI also
defines some of the most common utility routines that would otherwise
need to be written and rewritten for various applications.

   Incorporating this SRFI as a standard feature in Scheme
implementations makes it possible to write efficient and portable
programs that use hash tables.


File: vicare-libs.info,  Node: srfi hash-tables spec,  Next: srfi hash-tables copyright,  Prev: srfi hash-tables rationale,  Up: srfi hash-tables

2.29.4 Specification
--------------------

* Menu:

* srfi hash-tables spec names::    Names defined in this SRFI.
* srfi hash-tables spec type::     Type constructors and predicate.
* srfi hash-tables spec queries::  Reflective queries.
* srfi hash-tables spec single::   Dealing with single elements.
* srfi hash-tables spec whole::    Dealing with the whole contents.
* srfi hash-tables spec hashing::  Hashing.


File: vicare-libs.info,  Node: srfi hash-tables spec names,  Next: srfi hash-tables spec type,  Up: srfi hash-tables spec

2.29.4.1 Names defined in this SRFI
...................................

Names defined in this SRFI:

*Type constructors and predicate*
          make-hash-table         hash-table?
          alist->hash-table

*Reflective queries*
          hash-table-equivalence-function
          hash-table-hash-function

*Dealing with single elements*
          hash-table-ref          hash-table-ref/default
          hash-table-set!         hash-table-delete!
          hash-table-exists?      hash-table-update!
          hash-table-update!/default

*Dealing with the whole contents*
          hash-table-size         hash-table-keys
          hash-table-values       hash-table-walk
          hash-table-fold         hash-table->alist
          hash-table-copy         hash-table-merge!

*Hashing*
          hash                    hash-by-identity
          string-hash             string-ci-hash

   An implementation that does not provide:

     hash-table-ref          hash-table-set!
     hash-table-delete!      hash-table-update!
     hash-table-exists?      hash-table-size

in amortised constant time (when a good hash function is used), or fails
to provide good hash function definitions for:

     hash                    string-hash
     string-ci-hash          hash-by-identity

does not conform to this SRFI.

   Hash table implementations are allowed to rely on the fact that the
hash value of a key in hash table does not change.  In most cases,
modifying a key in-place after it has been inserted into the hash table
will violate this constraint and thus leads to unspecified behaviour.


File: vicare-libs.info,  Node: srfi hash-tables spec type,  Next: srfi hash-tables spec queries,  Prev: srfi hash-tables spec names,  Up: srfi hash-tables spec

2.29.4.2 Type constructors and predicate
........................................

 -- Function: make-hash-table
 -- Function: make-hash-table EQUAL?
 -- Function: make-hash-table EQUAL? HASH
 -- Function: make-hash-table EQUAL? HASH ARG ...
     Create a new hash table with no associations.  EQUAL? is a
     predicate that should accept two keys and return a boolean telling
     whether they denote the same key value; it defaults to 'equal?'.

     HASH is a hash function, and defaults to an appropriate hash
     function for the given 'equal?' predicate (*note srfi hash-tables
     spec hashing::).  However, an acceptable default is not guaranteed
     to be given for any equivalence predicate coarser than 'equal?',
     except for 'string-ci=?'.(1)  The function hash must be acceptable
     for 'equal?', so if we use coarser equivalence than 'equal?' other
     than 'string-ci=?', we must always provide the function HASH
     ourself.

     Implementations are allowed to use the rest ARGs for
     implementation-specific extensions.  Be warned, though, that using
     these extensions will make our program less portable.

 -- Function: hash-table? OBJ
     A predicate to test whether a given object OBJ is a hash table;
     return a boolean.  The hash table type should be disjoint from all
     other types, if possible.

 -- Function: alist->hash-table ALIST
 -- Function: alist->hash-table ALIST EQUAL?
 -- Function: alist->hash-table ALIST EQUAL? HASH
 -- Function: alist->hash-table ALIST EQUAL? HASH ARG ...
     Take an "association list" ALIST and create a hash table HASH-TABLE
     which maps the car of every element in ALIST to the cdr of
     corresponding elements in ALIST.

     EQUAL?, HASH, and ARGs are interpreted as in 'make-hash-table'.  If
     some key occurs multiple times in ALIST, the value in the first
     association will take precedence over later ones.  (Note: the
     choice of using cdr (instead of cadr) for values tries to strike
     balance between the two approaches: using cadr would render this
     procedure unusable for cdr alists, but not vice versa.)

     The rest ARGs are passed to 'make-hash-table' and can thus be used
     for implementation-specific extensions.

   ---------- Footnotes ----------

   (1) An equivalence predicate C1 is coarser than a equivalence
predicate C2 iff there exist values X and Y such that '(and (C1 X Y)
(not (C2 X Y)))'.


File: vicare-libs.info,  Node: srfi hash-tables spec queries,  Next: srfi hash-tables spec single,  Prev: srfi hash-tables spec type,  Up: srfi hash-tables spec

2.29.4.3 Reflective queries
...........................

 -- Function: hash-table-equivalence-function HASH-TABLE
     Return the equivalence predicate used for keys of HASH-TABLE.

 -- Function: hash-table-hash-function HASH-TABLE
     Return the hash function used for keys of HASH-TABLE.


File: vicare-libs.info,  Node: srfi hash-tables spec single,  Next: srfi hash-tables spec whole,  Prev: srfi hash-tables spec queries,  Up: srfi hash-tables spec

2.29.4.4 Dealing with single elements
.....................................

 -- Function: hash-table-ref HASH-TABLE KEY
 -- Function: hash-table-ref HASH-TABLE KEY THUNK
     This procedure returns the value associated to KEY in HASH-TABLE.
     If no value is associated to KEY and THUNK is given, it is called
     with no arguments and its value is returned; if THUNK is not given,
     an error is signalled.

     Given a good hash function, this operation should have an
     (amortised) complexity of O(1) with respect to the number of
     associations in HASH-TABLE.

          *NOTE* This rules out implementation by association lists or
          fixed-length hash tables.

 -- Function: hash-table-ref/default HASH-TABLE KEY DEFAULT
     Evaluate to the same value as:

          (hash-table-ref HASH-TABLE KEY (lambda () DEFAULT))

     Given a good hash function, this operation should have an
     (amortised) complexity of O(1) with respect to the number of
     associations in hash-table.

          *NOTE* This rules out implementation by association lists or
          fixed-length hash tables.

 -- Function: hash-table-set! HASH-TABLE KEY VALUE
     Set the value associated to KEY in HASH-TABLE.  The previous
     association (if any) is removed.

     Given a good hash function, this operation should have an
     (amortised) complexity of O(1) with respect to the number of
     associations in hash-table.

          *NOTE* This rules out implementation by association lists or
          fixed-length hash tables.

 -- Function: hash-table-delete! HASH-TABLE KEY
     Remove any association to key in HASH-TABLE.  It is not an error if
     no association for that key exists; in this case, nothing is done.

     Given a good hash function, this operation should have an
     (amortised) complexity of O(1) with respect to the number of
     associations in hash-table.

          *NOTE* This rules out implementation by association lists or
          fixed-length hash tables.

 -- Function: hash-table-exists? HASH-TABLE KEY
     Tell whether there is any association to KEY in HASH-TABLE; return
     a boolean.

     Given a good hash function, this operation should have an
     (amortised) complexity of O(1) with respect to the number of
     associations in hash-table.

          *NOTE* This rules out implementation by association lists or
          fixed-length hash tables.

 -- Function: hash-table-update! HASH-TABLE KEY FUNCTION
 -- Function: hash-table-update! HASH-TABLE KEY FUNCTION THUNK
     Semantically equivalent to, but may be implemented more efficiently
     than, the following code:

          (hash-table-set! HASH-TABLE KEY
            (FUNCTION (hash-table-ref HASH-TABLE KEY THUNK)))

 -- Function: hash-table-update!/default HASH-TABLE KEY FUNCTION DEFAULT
     Behave as if it evaluates to:

          (hash-table-update! HASH-TABLE KEY FUNCTION
            (lambda () DEFAULT))


File: vicare-libs.info,  Node: srfi hash-tables spec whole,  Next: srfi hash-tables spec hashing,  Prev: srfi hash-tables spec single,  Up: srfi hash-tables spec

2.29.4.5 Dealing with the whole contents
........................................

 -- Function: hash-table-size HASH-TABLE
     Return an exact integer representing the number of associations in
     HASH-TABLE.  This operation must have a complexity of O(1) with
     respect to the number of associations in HASH-TABLE.

 -- Function: hash-table-keys HASH-TABLE
     Return a list of keys in HASH-TABLE.  The order of the keys is
     unspecified.

 -- Function: hash-table-values HASH-TABLE
     Return a list of values in HASH-TABLE.  The order of the values is
     unspecified, and is not guaranteed to match the order of keys in
     the result of 'hash-table-keys'.

 -- Function: hash-table-walk HASH-TABLE PROC
     PROC should be a function taking two arguments, a key and a value.
     This procedure calls proc for each association in HASH-TABLE,
     giving the key of the association as key and the value of the
     association as value.  The results of PROC are discarded.  The
     order in which proc is called for the different associations is
     unspecified.

          *NOTE* In some implementations, there is a procedure called
          'hash-table-map' which does the same as this procedure.
          However, in other implementations, 'hash-table-map' does
          something else.  In no implementation that I know of,
          'hash-table-map' does a real functorial map that lifts an
          ordinary function to the domain of hash tables.  Because of
          these reasons, 'hash-table-map' is left outside this SRFI.

 -- Function: hash-table-fold HASH-TABLE F INIT-VALUE
     Call F for every association in HASH-TABLE with three arguments:

       1. The key of the association key.

       2. The value of the association value.

       3. An "accumulated value", VAL.

     VAL is INIT-VALUE for the first invocation of F, and, for
     subsequent invocations of F, the return value of the previous
     invocation of F.  The value FINAL-VALUE returned by
     'hash-table-fold' is the return value of the last invocation of F.
     The order in which F is called for different associations is
     unspecified.

 -- Function: hash-table->alist HASH-TABLE
     Return an association list such that the car of each element in
     alist is a key in HASH-TABLE and the corresponding cdr of each
     element in alist is the value associated to the key in HASH-TABLE.
     The order of the elements is unspecified.

     The following should always produce a hash table with the same
     mappings as a hash table H:

          (alist->hash-table (hash-table->alist H)
                             (hash-table-equivalence-function H)
                             (hash-table-hash-function H))

 -- Function: hash-table-copy HASH-TABLE
     Return a new hash table with the same equivalence predicate, hash
     function and mappings as in HASH-TABLE.

 -- Function: hash-table-merge! HASH-TABLE1 HASH-TABLE2
     Add all mappings in HASH-TABLE2 into HASH-TABLE1 and return the
     resulting hash table.  This function may modify HASH-TABLE1
     destructively.


File: vicare-libs.info,  Node: srfi hash-tables spec hashing,  Prev: srfi hash-tables spec whole,  Up: srfi hash-tables spec

2.29.4.6 Hashing
................

Hashing means the act of taking some value and producing a number from
the value.  A hash function is a function that does this.  Every
equivalence predicate E has a set of acceptable hash functions for that
predicate; a hash funtion hash is acceptable iff:

     (E obj1 obj2) == (= (hash obj1) (hash obj2))

   A hash function H is good for a equivalence predicate E if it
distributes the result numbers (hash values) for non-equal objects (by
E) as uniformly as possible over the numeric range of hash values,
especially in the case when some (non-equal) objects resemble each other
by e.g.  having common subsequences.  This definition is vague but
should be enough to assert that e.g.  a constant function is not a good
hash function.

   When the definition of 'make-hash-table' above talks about an
"appropriate" hashing function for E, it means a hashing function that
gives decent performance (for the hashing operation) while being both
acceptable and good for E.  This definition, too, is intentionally
vague.

 -- Function: hash OBJECT
 -- Function: hash OBJECT BOUND
     Produce a hash value for object in the range '[0, BOUND)'.  If
     BOUND is not given, the implementation is free to choose any bound,
     given that the default bound is greater than the size of any
     imaginable hash table in a normal application.  (This is so that
     the implementation may choose some very big value in fixnum range
     for the default bound.)  This hash function is acceptable for
     'equal?'.

 -- Function: string-hash STRING
 -- Function: string-hash STRING BOUND
     The same as 'hash', except that the argument string must be a
     string.

 -- Function: string-ci-hash STRING
 -- Function: string-ci-hash STRING BOUND
     The same as 'string-hash', except that the case of characters in
     string does not affect the hash value produced.

 -- Function: hash-by-identity OBJECT
 -- Function: hash-by-identity OBJECT BOUND
     The same as 'hash', except that this function is only guaranteed to
     be acceptable for 'eq?'.  The reason for providing this function is
     that it might be implemented significantly more efficiently than
     'hash'.  Implementations are encouraged to provide this function as
     a builtin.


File: vicare-libs.info,  Node: srfi hash-tables copyright,  Prev: srfi hash-tables spec,  Up: srfi hash-tables

2.29.5 Copyright
----------------

Copyright (C) Panu Kalliokoski (2005).  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi lightweight-testing,  Next: srfi environment-variables,  Prev: srfi hash-tables,  Up: srfi

2.30 SRFI-78 lightweight testing
================================

The library '(srfi :78)' are written by Sebastian Egner as the reference
implementation for SRFI-78; see:

            <http://srfi.schemers.org/srfi-78/srfi-78.html>

for more details.

* Menu:

* srfi lightweight-testing license::    Original document license.
* srfi lightweight-testing abstract::   Abstract.
* srfi lightweight-testing rationale::  Rationale.
* srfi lightweight-testing spec::       Specification.
* srfi lightweight-testing references:: References.


File: vicare-libs.info,  Node: srfi lightweight-testing license,  Next: srfi lightweight-testing abstract,  Up: srfi lightweight-testing

2.30.1 Original document license
--------------------------------

Copyright (C) 2005-2006 Sebastian Egner.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi lightweight-testing abstract,  Next: srfi lightweight-testing rationale,  Prev: srfi lightweight-testing license,  Up: srfi lightweight-testing

2.30.2 Abstract
---------------

A simple mechanism is defined for testing Scheme programs.  As a most
primitive example, the expression:

     (check (+ 1 1) => 3)

evaluates the expression '(+ 1 1)' and compares the result with the
expected result '3' provided after the syntactic keyword '=>'.  Then the
outcome of this comparison is reported in human-readable form by
printing a message of the form:

     (+ 1 1) => 2 ; *** failed ***
     ; expected result: 3

   Moreover, the outcome of any executed check is recorded in a global
state counting the number of correct and failed checks and storing the
first failed check.  At the end of a file, or at any other point, the
user can print a summary using 'check-report'.

   In addition to the simple test above, it is also possible to execute
a parametric sequence of checks.  Syntactically, this takes the form of
an eager comprehension in the sense of SRFI-42.  For example:

     (check-ec (:range e 100)
               (:let x (expt 2.0 e))
       (= (+ x 1) x) => #f (e x))

   This statement runs the variable e through '{0..99}' and for each
binding defines X as '(expt 2.0 e)'.  Then it is checked if '(+ x 1)' is
equal to X, and it is expected that this is not the case (i.e.  expected
value is '#f').  The trailing '(e x)' tells the reporting mechanism to
print the values of both E and X in case of a failed check.  The output
could look like this:

     (let ((e 53) (x 9007199254740992.0)) (= (+ x 1) x)) => #t ; *** failed ***
     ; expected result: #f

   The specification of bindings to report, '(e x)' in the example, is
optional but very informative.  Other features of this SRFI are:

   * a way to specify a different equality predicate (default is
     'equal?');

   * controlling the amount of reporting being printed;

   * switching off the execution and reporting of checks entriely;

   * retrieving a boolean if all checks have been executed and passed.


File: vicare-libs.info,  Node: srfi lightweight-testing rationale,  Next: srfi lightweight-testing spec,  Prev: srfi lightweight-testing abstract,  Up: srfi lightweight-testing

2.30.3 Rationale
----------------

The mechanism defined in this SRFI should be available in every Scheme
system because it has already proven useful for interactive
development---of SRFIs.

   Although it is extremely straightforward, the origin of the
particular mechanism described here is the 'examples.scm' file
accompanying the reference implementation of SRFI-42.  The same
mechanism has been reimplemented for the reference implementation of
SRFI-67, and a simplified version is yet again found in the reference
implementation of SRFI-77.

   The mechanism in this SRFI does not replace more sophisticated
approaches to unit testing, like SRFI-64 or SchemeUnit.  These systems
provide more control of the testing, separate the definition of a test,
its execution, and its reports, and provide several other features.

   Neil Van Dyke's Testeez library is very close in spirit to this SRFI.
In Testeez, tests are disabled by (re-)defining a macro.  The advantage
of this method is that the code for the test cases can be removed
entirely, and hence even the dependency on the Testeez library.  This
SRFI on the other hand, uses a Scheme conditional '(cond, if)' to
prevent execution of the testing code.  This method is more dynamic but
retains dead testing code, unless a compiler and a module system are
used to apply constant folding and dead code elimination.  The only
major addition in SRFI over Testeez is the comprehension for formulating
parametric tests.

   Design considerations for this SRFI include the following:

   * Reporting is human-readable and as specific as possible, i.e.  not
     just "assertion failed" but the expression with actual and expected
     value, and if possibly the relevant part of the bindings
     environment.

   * An effort is made to print closed Scheme expressions, i.e.
     expressions that can directly be copy/pasted into a REPL for
     further analysis (e.g.  the let expression in the abstract).

   * By default the checks report both correct and failed checks.
     However, it is possible to reduce the output, or even to switch off
     the execution of checks.  It has turned out useful to be able to
     run only some subset checks for the features currently under
     development.  This can be done by changing the reporting mode
     between differnt sections.

   * The global state (correct/failed count) is not made available to
     the user program.  This reduces the dependencies between different
     checks because it is not possible to use the state.

   * Ocassionally, it is useful to check that a certain expression does
     not yield an ordinary result but raises an error.  However, R5RS
     does not specify the mechanism by which this occurs (e.g.  raising
     exception, breaking into a REPL, aborting the program, etc.).  For
     this reason, this SRFI is restricted to the case that the checked
     expressions evaluate normally.

   * Though usually I am very much in favor of strictly prefix syntax,
     for this SRFI I make an exception because the infix '=>' syntax is
     widely used and intuitive.


File: vicare-libs.info,  Node: srfi lightweight-testing spec,  Next: srfi lightweight-testing references,  Prev: srfi lightweight-testing rationale,  Up: srfi lightweight-testing

2.30.4 Specification
--------------------

 -- Syntax: check EXPR (=> EQUAL) EXPECTED
 -- Syntax: check EXPR => EXPECTED
     Evaluate EXPR and compare the value to the value of EXPECTED using
     the predicate EQUAL, which is 'equal?' when omitted.  Then a report
     is printed according to the current mode setting (see below) and
     the outcome is recorded in a global state to be used in
     'check-report'.

     The precise order of evaluation is that first EQUAL and EXPECTED
     are evaluated (in unspecified order) and then EXPR is evaluated.
     Example: '(check (+ 1 1) => 2)'.

 -- Syntax: check-ec QUALIFIER* EXPR (=> EQUAL) EXPECTED (ARGUMENT*))
 -- Syntax: check-ec QUALIFIER* EXPR => EXPECTED (ARGUMENT*)
 -- Syntax: check-ec QUALIFIER* EXPR (=> EQUAL) EXPECTED
 -- Syntax: check-ec QUALIFIER* EXPR => EXPECTED
     An eager comprehension for executing a parametric sequence of
     checks.

     Enumerate the sequence of bindings specified by QUALIFIER*.  For
     each binding evaluate EQUAL and EXPECTED in unspecified order.
     Then evaluate EXPR and compare the value obtained to the value of
     EXPECTED using the value of EQUAL as predicate, which is 'equal?'
     when omitted.

     The comprehension stops after the first failed check, if there is
     any.  Then a report is printed according to the current mode
     setting (see below) and the outcome is recorded in a global state
     to be used in 'check-report'.  The entire 'check-ec' counts as a
     single check.

     In case the check fails ARGUMENT* is used for constructing an
     informative message with the argument values.  Use ARGUMENT* to
     list the relevant free variables of EXPR (see examples) that you
     want to have printed.

     A QUALIFIER is any qualifier of an eager comprehension as specified
     in SRFI-42.

     Examples:

          (check-ec (: e 100)
                    (positive? (expt 2 e))
                    => #t (e)) ; fails on fixnums

          (check-ec (: e 100)
                    (:let x (expt 2.0 e))
                    (= (+ x 1) x)
                    => #f (x)) ; fails

          (check-ec (: x 10)
                    (: y 10)
                    (: z 10)
                    (* x (+ y z))
                    => (+ (* x y) (* x z))
                       (x y z)) ; passes with 10^3 cases checked

 -- Function: check-report
     Print a summary and the first failed check, if there is any,
     depending on the current mode settings.

 -- Function: check-set-mode! MODE
     Set the current mode to MODE, which must be a symbol among: 'off',
     'summary', 'report-failed', 'report'; the default is 'report'.
     Note that you can change the mode at any time, and that 'check',
     'check-ec' and 'check-report' use the current value.

     The mode symbols have the following meaning:

     'off'
          do not execute any of the checks;

     'summary'
          print only summary in 'check-report' and nothing else;

     'report-failed'
          report failed checks when they happen, and in summary;

     'report'
          report every example executed.

 -- Function: check-reset!
     Reset the global state (counters of correct/failed examples) to the
     state immediately after loading the module for the first time, i.e.
     no checks have been executed.

 -- Function: check-passed? EXPECTED-TOTAL-COUNT
     Return '#t' if there were no failed checks and EXPECTED-TOTAL-COUNT
     correct checks, '#f' otherwise.

     Rationale: This procedure can be used in automatized tests by
     terminating a test program with the statement:

          (exit (if (check-passed? n) 0 1))


File: vicare-libs.info,  Node: srfi lightweight-testing references,  Prev: srfi lightweight-testing spec,  Up: srfi lightweight-testing

2.30.5 References
-----------------

_SRFI-64: a Scheme API for test suites_.  Per Bothner.  January, 2005.

                  <http://srfi.schemers.org/srfi-64>

_SchemeUnit_.  Noel Welsh.  February, 2003.

          <http://schematics.sourceforge.net/schemeunit.html>

_Testeez, Lightweight Unit Test Mechanism for Scheme_.  Neil Van Dyke.
May, 2005.

                 <http://www.neilvandyke.org/testeez>

_Revised^5 Report on the Algorithmic Language Scheme_.

          <http://www.schemers.org/Documents/Standards/R5RS/>

_SRFI-42: eager comprehensions_.  Sebastian Egner.

                  <http://srfi.schemers.org/srfi-42>


File: vicare-libs.info,  Node: srfi environment-variables,  Next: srfi err5rs records,  Prev: srfi lightweight-testing,  Up: srfi

2.31 SRFI-98 environment variables
==================================

The library '(srfi :98)' is by Taro Minowa (Higepon) as the reference
implementation for SRFI-98; see:

            <http://srfi.schemers.org/srfi-98/srfi-98.html>

for more details.

* Menu:

* srfi environment-variables license::    Original document license.
* srfi environment-variables abstract::   Abstract.
* srfi environment-variables rationale::  Rationale.
* srfi environment-variables spec::       Specification.
* srfi environment-variables issues::     Issues.
* srfi environment-variables ack::        Acknowledgements.


File: vicare-libs.info,  Node: srfi environment-variables license,  Next: srfi environment-variables abstract,  Up: srfi environment-variables

2.31.1 Original document license
--------------------------------

Copyright (C) 2008 Taro Minowa (Higepon).  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi environment-variables abstract,  Next: srfi environment-variables rationale,  Prev: srfi environment-variables license,  Up: srfi environment-variables

2.31.2 Abstract
---------------

This SRFI specifies the procedure 'get-environment-variable', which gets
the value of the specified environment variable, and the procedure
'get-environment-variables', which gets an association list of all
environment-variables.


File: vicare-libs.info,  Node: srfi environment-variables rationale,  Next: srfi environment-variables spec,  Prev: srfi environment-variables abstract,  Up: srfi environment-variables

2.31.3 Rationale
----------------

Most operating systems provide a mechanism for passing auxiliary
parameters implicitly to child processes.  Usually, this mechanism is
called "the environment", and is conceptually a map from string names to
string values.  The string names are called environment variables.

   Some applications rely on environment variables to modify their
behavior according to local settings.  Also, various established
protocols rely on environment variables as a form of interprocess
communication.  For example, most implementations of the common gateway
interface (CGI) use environment variables to pass Meta-Variables from
the server to the script.  Environment variables are also required by
SRFI-96 SLIB Prerequisites.  Providing a means to access environment
variables is therefore indispensable for writing practical programs in
Scheme.

   Most widely-used Scheme implementations provide a function for
getting the value of a specified environment variable.  The name for
this function is usually getenv, but varies (see below).  Some
implementations also provide a way to get all the environment variables,
but others do not.

   This SRFI specifies a uniform interface for accessing environment
variables.  That should make it easier to write portable programs that
need access to their environment.  For example, a CGI program may
portably obtain the values of the Meta-Variables 'QUERY_STRING',
'CONTENT_LENGTH' and 'REQUEST_METHOD' as in the following examples:

     (get-environment-variable "QUERY_STRING") => "foo=bar&huga=hige"
     (get-environment-variable "CONTENT_LENGTH") => "512"
     (get-environment-variable "REQUEST_METHOD") => "post"


File: vicare-libs.info,  Node: srfi environment-variables spec,  Next: srfi environment-variables issues,  Prev: srfi environment-variables rationale,  Up: srfi environment-variables

2.31.4 Specification
--------------------

The following two procedures belong to the R6RS library named
'(system)'.  This is a provisional library name until the naming rules
for R6RS SRFI libraries are specified.

 -- Procedure: get-environment-variable NAME
     Return the value of the named environment variable as a string, or
     '#f' if the named environment variable is not found.  The name
     argument is expected to be a string.  'get-environment-variable'
     may use locale-setting information to encode the name and decode
     the value of the environment variable.  If
     'get-environment-variable' can't decode the value,
     'get-environment-variable' may raise an exception.

          (get-environment-variable "PATH")
          => "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin"

 -- Procedure: get-environment-variables
     Return names and values of all the environment variables as an
     alist.  The same decoding considerations as for
     'get-environment-variable' apply.

          (get-environment-variables)
          => (("PATH" . "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin")
              ("USERNAME" . "taro"))


File: vicare-libs.info,  Node: srfi environment-variables issues,  Next: srfi environment-variables ack,  Prev: srfi environment-variables spec,  Up: srfi environment-variables

2.31.5 Issues
-------------

'get-environment-variable' is expected to return a "Scheme string".

   Unfortunately, many current platforms, including POSIX-like ones, do
not require environment variables to be interpretable as sequences of
characters.  In particular, environment variables can be used to name
files, and filenames on the system can amount to 'NULL'-terminated byte
vectors, which, if the Scheme program were to collect uninterpreted and
pass to, say, the open call, would work just fine, but which might not
represent a string in the particular encoding the program expects.

   While in principle it may be desirable to provide a mechanism for
accessing environment variables raw, this SRFI specifies a "string"
return type because that best represents the consensus of existing
implementations, and captures the semantically desirable behavior in the
common case that the byte sequence is interpretable as a string.


File: vicare-libs.info,  Node: srfi environment-variables ack,  Prev: srfi environment-variables issues,  Up: srfi environment-variables

2.31.6 Acknowledgements
-----------------------

Thanks to Shiro Kawai, Alexey Radul, jmuk, Kokosabu, leque and all the
members of the '#Lisp_Scheme' IRC channel on Freenode.


File: vicare-libs.info,  Node: srfi err5rs records,  Next: srfi ralists,  Prev: srfi environment-variables,  Up: srfi

2.32 SRFI-99 ERR5RS records
===========================

The library '(srfi :99)' is by y Taro Minowa (Higepon) as the reference
implementation for SRFI-99; see:

            <http://srfi.schemers.org/srfi-99/srfi-99.html>

for more details.

* Menu:

* srfi err5rs records abstract::        Abstract.
* srfi err5rs records rationale::       Rationale.
* srfi err5rs records spec::            Specification.
* srfi err5rs records examples::        Examples.
* srfi err5rs records ack::             Acknowledgements.
* srfi err5rs records copyright::       Copyright.


File: vicare-libs.info,  Node: srfi err5rs records abstract,  Next: srfi err5rs records rationale,  Up: srfi err5rs records

2.32.1 Abstract
---------------

Many Scheme programmers have considered records to be one of the most
important features missing from the R5RS.  The R6RS proposed a record
system, but its design has been widely criticized and it was not
intended for use in R5RS programs anyway.

   This SRFI proposes a better record system for use in R5RS, ERR5RS,
and R6RS programs.  The syntactic layer of this SRFI's record system is
an extension of SRFI-9.  The procedural and inspection layers of this
SRFI's record system are perfectly compatible with its syntactic layer.
This entire SRFI is compatible with the procedural and inspection layers
of the R6RS record system, but offers several worthwhile improvements
over the R6RS system.


File: vicare-libs.info,  Node: srfi err5rs records rationale,  Next: srfi err5rs records spec,  Prev: srfi err5rs records abstract,  Up: srfi err5rs records

2.32.2 Rationale
----------------

In most programming languages, records (aka structures or classes) are
important because they can package component values of different types
into a single object.

   Scheme's vectors and procedures provided that capability already, but
records remained important for two reasons:

   * Records make it easier to index components by their names.

   * Records can introduce new types in the sense that all previous type
     predicates return false for instances of the new record type, while
     the new predicate associated with the new record type returns true
     only for instances of the new record type.

   For many programmers, records were the most important new feature of
the R6RS, but the specific record systems that were proposed by the R6RS
have been widely criticized.  Over 30% of those who voted against
ratification mentioned the record systems as one of their reasons.

   The ERR5RS record system described by this SRFI provides a simpler
and fully portable alternative to the R6RS record system.  The ERR5RS
record system consists of:

   * a syntactic layer, which is fully compatible with SRFI-9 but
     extends SRFI-9 with inheritance and with more succinct syntax for
     common use cases;

   * a procedural layer, which is simpler and easier to use than the
     procedural layer of R6RS records but remains fully compatible with
     the R6RS procedural layer;

   * an inspection layer, which is simpler and easier to use than the
     inspection layer of R6RS records but remains fully compatible with
     the R6RS inspection layer.

   The ERR5RS record system does not mandate support for the
non-generative, sealed, and/or opaque features of the R6RS record
system.  Implementations of this SRFI may extend the ERR5RS record
system to support those features, however, and this SRFI recommends an
API to implementations that support those features.  With those
extensions, the ERR5RS record system has the same expressive power as
the R6RS record system.  Hence the record system described by this SRFI
can serve as either or both of the following:

   * an efficient and relatively simple foundation for implementing the
     R6RS record system;

   * a simpler and fully portable alternative to the R6RS record system.

   The following subsections develop the rationale for this SRFI by
considering:

   * the history of records in Scheme before the R6RS;

   * R6RS records;

   * the design rationale for ERR5RS records.

2.32.2.1 Records before R6RS
............................

The importance of adding records to Scheme has been recognized for more
than twenty years.  The basic idea behind the SRFI-9 and R6RS record
systems was outlined by Norman Adams on 8 July 1987, following similar
ideas that had been implemented in T and MIT CScheme.  Jonathan Rees
posted a revision of Adams's proposal on 26 May 1988.  Pavel Curtis
proposed an extension of Rees's proposal on 18 August 1989, noting that
it had been approved by consensus at the first meeting of BASH (Bay Area
Scheme Hackers?).  The 'rrrs-authors' archive includes several responses
to these proposals that are worth reading.

   The Rees/Curtis proposal was revived in 1992.  When the RnRS authors
met on 25 June 1992 in Palo Alto, they felt that this proposal needed
more discussion.  Kent Dybvig objected to the proposal on several
grounds, including the provision of inspection facilities, the inability
to define immutable records, and the use of procedures instead of
special forms.  Although 9 authors favored adoption of the records
proposal, 11 opposed it.

   The topic of records was revived again on 23 April 1996 by Bruce
Duba, Matthew Flatt, and Shriram Krishnamurthi.  Alan Bawden and Richard
Kelsey observed that the Duba/Flatt/Krishnamurthi proposal was
essentially the same as Pavel Curtis's, which Kelsey reposted.  Kent
Dybvig objected once again, on the same three grounds.  He also argued
that procedural interfaces are difficult to compile efficiently, and
that this inefficiency would create portability problems.

   In reality, however, procedural interfaces add no inefficiency.  It
is now agreed that syntactic interfaces offer no advantages for
generative records.  Even for non-generative records, the claimed
inefficiency consists of a single load instruction, which optimizing
compilers can eliminate -- along with the entire runtime check that
includes the load instruction -- for all but the first of a sequence of
operations that access the same record.  (That optimization is a
straightforward extension of the optimization that eliminates the pair
check when computing the cdr of a list whose car has already been
computed.)  Furthermore, it turns out that even the occasional load
instruction is no harder to remove using a procedural interface than
when using a syntactic interface.  In R6RS library chapter 6, therefore,
both of the statements that claim an advantage in efficiency for the
syntactic layer have no basis in fact.  (These two statements appear in
the next-to-last paragraph before section 6.1, and in the note that
follows the specification of 'parent-rtd'.)

   On 24 April 1996, Bill Rozas suggested the idea of having two
separate APIs, one procedural and one syntactic, for the same record
facility.  Two days later, Dybvig proposed a compromise along those
lines that incorporated several artificial restrictions, which were
apparently motivated by concerns about the alleged extra load
instruction.  Dybvig and Rozas continued to develop this proposal, and
presented a summary of it following the 1998 Scheme Workshop.  I have
been unable to locate a written or online copy of this proposal.

   SRFI-9, submitted by Richard Kelsey in July 1999, is a syntactic API
in the tradition of the Rees, Curtis, and Duba/Flatt/Krishnamurthi
proposals.

   Single inheritance was added by Larceny in 1998, and by Chez Scheme
in 1999.

   SRFI 57, submitted by Andre van Tonder in September 2004, features
label polymorphism, which can be considered a form of structural
subtyping and multiple inheritance.

2.32.2.2 R6RS Records
.....................

The R6RS proposes a three-layer single inheritance system, with
syntactic, procedural, and inspection layers.

R6RS Records: procedural layer
..............................

The R6RS procedural layer generally requires at least three separate
definitions for each level of inheritance: the record-type descriptor,
at least one record-constructor descriptor, and an actual constructor
(if instances of the record-type are to be created).

   The (unratified) R6RS rationale describes the constructor-descriptor
mechanism as "an infrastructure for creating specialized constructors,
rather than just creating default constructors that accept the initial
values of all the fields as arguments.  This infrastructure achieves
full generality while leaving each level of an inheritance hierarchy in
control over its own fields and allowing child record definitions to be
abstracted away from the actual number and contents of parent fields."
Neither the (ratified) R6RS library document nor the (unratified) R6RS
rationale consider the fact that the constructor-descriptor mechanism
adds unnecessary complexity to what is by far the most common case:
record definitions that do not require specialized constructors.
Neither document considers the fact that the benefits of the
constructor-descriptor mechanism are small even when specialized
constructors are needed, as in the first example below.

   The R6RS library specification of records says that a record type is
"specified by a record-type descriptor, which is an object that
specifies the fields of the record and various other properties that all
records of that type share."  Since the record-type descriptor is an
object, it can be the value of a variable that is exported by a library.
As discussed below, however, the R6RS syntactic layer uses a different
notion of record type that may be neither object nor syntax.

R6RS records: syntactic layer
.............................

The R6RS syntactic layer consists of a 'define-record-type' syntax that
is incompatible with the syntaxes of the same name defined by SRFI-9 and
SRFI-99 (this SRFI).

   According to R6RS library section 6.2, an R6RS 'define-record-type'
form binds the record name "to an expand-time or run-time representation
of the record type [that] can be used as parent name in syntactic
record-type definitions that extend this definition.  It can also be
used as a handle to gain access to the underlying record-type descriptor
and constructor descriptor".

   Note that portable code cannot assume the record name is bound to a
record-type descriptor.  Portable code can only assume that the record
name is bound to "an expand-time or run-time representation", whose
semantics is not otherwise explained by the R6RS and R6RS library
documents.  In particular, it is far from obvious that portable code can
export the record name from a library; libraries can export names that
are bound to objects or to syntax, but the R6RS does not require the
denotation of a record name to be either of those things.

   The mysterious entity to which a record name is bound can be used as
a handle to recover a record-type descriptor or constructor descriptor
by using the 'record-type-descriptor' or 'record-constructor-descriptor'
syntaxes, respectively.  The recovered record-type descriptor and
constructor descriptor may be exported from a library, and that is
apparently the only portable way for a library to export an R6RS record
type that was defined using the R6RS syntactic layer.

   The recovered record-type descriptor and constructor descriptor also
provide a way for the procedural layer to define new record types that
inherit from record types defined by the syntactic layer.  Similarly, it
is possible for the syntactic layer to use a 'parent-rtd' clause to
define new record types that inherit from record types defined by the
procedural layer.

   The two notions of record type that are used by the procedural and
syntactic layers are not interchangeable, however.  In either direction,
defining a new record type that inherits from some previously defined
record type requires the programmer to know whether the previously
defined record type was defined using the procedural or the syntactic
layer.  If the procedural and syntactic layers of the R6RS were fully
compatible, then changing a record type definition from procedural to
syntactic (or vice versa) would be transparent to clients.  As the R6RS
record facility is defined, however, that minor change will break all
code that inherits from the record type.

   R6RS library chapter 6 attempts to excuse that incompatibility, and
the interoperability and maintenance problems that result from it, on
the basis of efficiency.  Recall, however, that the claimed efficiency
of the R6RS syntactic layer is illusory.  In reality, the R6RS design
offers no advantages over a simpler and more orthogonal design (such as
the one specified by this SRFI) in which the syntactic and procedural
layers both use the same notion of record type.

   The problems described above were known and had been documented
before the R6RS documents were put to a vote, but the R6RS documents
were ratified anyway.  At this point, the best that can be done is to
use the SRFI process to specify a better record facility, and to warn
programmers of the problems they will encounter if they use the record
facilities described within the R6RS library document.

2.32.2.3 Design Rationale for ERR5RS Records
............................................

The ERR5RS syntactic layer described by this SRFI is based upon the
Rees/Curtis/Duba/Flatt/Krishnamurthi/Kelsey/SRFI-9 tradition, changing
only a few details to improve interoperability with records defined by
the ERR5RS and R6RS procedural layers.

   The 'define-record-type' syntax specified by this SRFI is compatible
with and extends SRFI-9, which is one of the more widely accepted SRFIs.
The extensions include single inheritance and (optional) implicit
naming, along with succinct abbreviations for specifying whether a field
is immutable or mutable.

   The procedural layer specified by this SRFI is fully compatible with
its 'define-record-type' syntax.  Both the procedural and syntactic
layers can define new record types that inherit from previously defined
record types without requiring programmers to know which layer was used
to define the parent type.

   In implementations of the R6RS, a SRFI-99 record type coincides with
the R6RS notion of a record-type descriptor.  Portable libraries can
safely export SRFI-99 record types even if they were defined using the
syntactic layer of SRFI-99.

   In procedure names, SRFI-99 uses 'rtd' as an abbreviation for
record-type descriptor.  This naming convention prevents name clashes
between SRFI-99 and the R6RS procedural and inspection layers, which
makes it easier for R6RS programs to import SRFI-99 libraries.  R6RS
programs must take care when importing the R6RS syntactic layer,
however, because that library's exports conflict with both SRFI-9 and
with SRFI-99.

   When implemented properly, SRFI-99 records will be just as efficient
as R6RS records.  SRFI-99 is simpler than R6RS records, both in
specification and in implementation.  SRFI-99 is strictly less powerful
than the R6RS records facility because SRFI-99 does not require
implementations to provide sealed, opaque, or non-generative records.
On the other hand, SRFI-99 describes three optional extensions (the
SEALED, OPAQUE, and UID arguments to 'make-rtd') that would give SRFI-99
the same power as R6RS records.  With those three extensions, SRFI-99
would become a simple and efficient foundation for implementing R6RS
records.

   The record system described by this SRFI has been implemented in
Larceny.  It is the primary record system used by Larceny's
implementation of the R6RS, including the '(rnrs records syntactic (6))'
library.  Larceny demonstrates both the efficiency of ERR5RS records and
the ease of interoperability between SRFI-9, ERR5RS, and the procedural
and inspection layers of R6RS records.

2.32.2.4 Issues
...............

   * ERR5RS records support single inheritance.

   * ERR5RS records do not support the non-generative feature of R6RS
     records.  (To show how SRFI-99 could be extended to provide all
     useful features of R6RS records, SRFI-99 describes an optional
     extension for non-generativity, and the reference implementation
     shows how that extension is implemented in Larceny, but that
     extension is not part of SRFI-99's API.)

   * ERR5RS records do not support the optional "sealed" feature of R6RS
     records.  (To show how SRFI-99 could be extended to provide all
     useful features of R6RS records, SRFI-99 describes an optional
     extension for sealed records, and the reference implementation
     shows how that extension is implemented in Larceny, but that
     extension is not part of SRFI-99's API.)

   * ERR5RS records do not support the optional "opaque" feature of R6RS
     records.  (To show how SRFI-99 could be extended to provide all
     useful features of R6RS records, SRFI-99 describes an optional
     extension for opaque records, and the reference implementation
     shows how that extension is implemented in Larceny, but that
     extension is not part of SRFI-99's API.)

   * ERR5RS records do not support the record-constructor descriptors of
     R6RS records.  (Even so, ERR5RS records are compatible with the
     'make-record-constructor-descriptor' procedure of the R6RS.
     Larceny, for example, allows that procedure to be used with ERR5RS
     record type descriptors.)

   * ERR5RS records support the per-field mutable/immutable feature of
     R6RS records.

   * The 'define-record-type' syntax provides succinct defaults for both
     immutable and mutable fields.  An identifier-only field spec
     implies immutability.  When enclosed within parentheses, a single
     identifier implies mutability.

   * ERR5RS records are partitioned into a procedural layer, an
     inspection layer, and a syntactic layer.  (The primary reason for
     separating the procedural layer from the inspection layer is to
     simplify comparisons with R6RS records.)

   * The 'make-rtd' procedure accepts a vector of field specifiers
     instead of a list of field specifiers.  (This is carried over from
     the corresponding procedure of the R6RS procedural layer.)


File: vicare-libs.info,  Node: srfi err5rs records spec,  Next: srfi err5rs records examples,  Prev: srfi err5rs records rationale,  Up: srfi err5rs records

2.32.3 Specification
--------------------

All implementations of SRFI-99 must provide the following libraries:

'(srfi :99)'
     Alias for '(srfi :99 records)'.

'(srfi :99 records)'
     Composite of the next three.

'(srfi :99 records procedural)'
'(srfi :99 records inspection)'
'(srfi :99 records syntactic)'
     One library for each layer.

   Implementations of ERR5RS should provide the following aliases as
well:

'(err5rs records)'
     Alias for '(srfi :99 records)'.

'(err5rs records procedural)'
     Alias for '(srfi :99 records procedural)'.

'(err5rs records inspection)'
     Alias for '(srfi :99 records inspection)'.

'(err5rs records syntactic)'
     Alias for '(srfi :99 records syntactic)'.

   The specification also describes how Scheme's standard equivalence
predicates behave with respect to records, and shows how some R6RS
examples can be translated to use the ERR5RS libraries instead.

   When the following specification says that a procedure is said to be
equivalent to some R6RS procedure, the equivalence holds only when all
arguments have the properties required of them by the R6RS
specification.  Neither ERR5RS nor this SRFI mandate the R6RS exception
semantics for programs that violate the specification.

* Menu:

* srfi err5rs records spec proc::       Procedural layer.
* srfi err5rs records spec insp::       Inspection Layer.
* srfi err5rs records spec synt::       Syntactic Layer.
* srfi err5rs records spec iden::       Record Identity.


File: vicare-libs.info,  Node: srfi err5rs records spec proc,  Next: srfi err5rs records spec insp,  Up: srfi err5rs records spec

2.32.3.1 Procedural layer
.........................

The '(srfi :99 records procedural)' library exports the following
procedures.

 -- Function: make-rtd NAME FIELDSPECS
 -- Function: make-rtd NAME FIELDSPECS PARENT
     NAME is a symbol, which matters only to the 'rtd-name' procedure of
     the inspection layer.  FIELDSPECS is a vector of field specifiers,
     where each field specifier is one of:

        * a symbol naming the (mutable) field;

        * a list of the form '(mutable NAME)', where NAME is a symbol
          naming the mutable field;

        * a list of the form '(immutable NAME)', where name is a symbol
          naming the immutable field.

     The optional PARENT is an rtd or '#f'.  It is an error for any of
     the symbols in FIELDSPECS to name more than one of the fields
     specified by FIELDSPECS, but the field names in FIELDSPECS may
     shadow field names in the parent record-type.

     Implementations may wish to extend this procedure to support the
     non-generative, sealed, and/or opaque features of the R6RS.  The
     recommended way to support those features is to allow any
     combination of the following arguments to follow the optional
     parent argument:

        * The symbol 'sealed' means the new rtd cannot be used as the
          parent of other rtds.

        * The symbol 'opaque' means the 'record?' predicate will not
          recognize instances of the new rtd.

        * The symbol 'uid', following by another symbol ID, means the
          new rtd is non-generative with uid ID.  The semantics of this
          extension is the same as described by the R6RS.

     The recommendation above is not binding on implementations of SRFI
     99.  There are other ways to realize sealed, opaque, or
     non-generative rtds.

     Returns an R6RS-compatible record-type descriptor.  Could be
     defined (without the recommended error checking, and without the
     extensions described above) in terms of the R6RS procedural layer
     by:

          (define (make-rtd name fieldspecs . rest)
            (make-record-type-descriptor
             name
             (if (null? rest) #f (car rest))
             #f #f #f
             (vector-map (lambda (fieldspec)
                           (if (symbol? fieldspec)
                               (list 'mutable fieldspec)
                               fieldspec))
                         fieldspecs)))

 -- Function: rtd? OBJ
     Equivalent to the 'record-type-descriptor?' procedure of the R6RS.

 -- Function: rtd-constructor RTD
 -- Function: rtd-constructor RTD FIELDSPECS
     RTD is a record-type descriptor, and FIELDSPECS is an optional
     vector of symbols.

     If no FIELDSPECS argument is supplied, then 'rtd-constructor'
     returns a procedure that expects one argument for each field of the
     record-type described by RTD and returns an instance of that
     record-type with its fields initialized to the corresponding
     arguments.  Arguments that correspond to the fields of the
     record-type's parent (if any) come first.

     If FIELDSPECS is supplied, then 'rtd-constructor' returns a
     procedure that expects one argument for each element of FIELDSPECS
     and returns an instance of the record-type described by RTD with
     the named fields initialized to the corresponding arguments.

     It is an error if some symbol occurs more than once in FIELDSPECS.
     Fields of a derived record-type shadow fields of the same name in
     its parent; the FIELDSPECS argument cannot be used to initialize a
     shadowed field.

          *NOTE* The optional second argument was proposed by Pavel
          Curtis, and interoperates well with SRFI-9.

     Could be defined in terms of the R6RS procedural layer and ERR5RS
     inspection layer by:

          (define (rtd-constructor rtd . rest)
            ; Computes permutation and allocates permutation buffer
            ; when the constructor is created, not when the constructor
            ; is called.  More error checking is recommended.
            (define (make-constructor fieldspecs allnames maker)
              (let* ((k (length fieldspecs))
                     (n (length allnames))
                     (buffer (make-vector n (unspecified)))
                     (reverse-all-names (reverse allnames)))

                (define (position fieldname)
                  (let ((names (memq fieldname reverse-all-names)))
                    (assert names)
                    (- (length names) 1)))

                (let ((indexes (map position fieldspecs)))
                  ; The following can be made quite efficient by
                  ; hand-coding it in some lower-level language,
                  ; e.g. Larceny's mal.  Even case-lambda would
                  ; be good enough in most systems.
                  (lambda args
                    (assert (= (length args) k))
                    (for-each (lambda (arg posn)
                                (vector-set! buffer posn arg))
                              args indexes)
                    (apply maker (vector->list buffer))))))
            (if (null? rest)
                (record-constructor
                 (make-record-constructor-descriptor rtd #f #f))
                (begin (assert (null? (cdr rest)))
                       (make-constructor
                        (vector->list (car rest))
                        (vector->list (rtd-all-field-names rtd))
                        (record-constructor
                         (make-record-constructor-descriptor rtd #f #f))))))

 -- Function: rtd-predicate RTD
     Equivalent to the record-predicate procedure of the R6RS.

 -- Function: rtd-accessor RTD FIELD
     FIELD is a symbol that names a field of the record-type described
     by the record-type descriptor RTD.  Return a unary procedure that
     accepts instances of RTD (or any record-type that inherits from
     RTD) and returns the current value of the named field.

     Fields in derived record-types shadow fields of the same name in a
     parent record-type.

 -- Function: rtd-mutator RTD FIELD
     FIELD is a symbol that names a field of the record-type described
     by the record-type descriptor RTD.  Return a binary procedure that
     accepts instances of RTD (or any record-type that inherits from
     RTD) and a new value to be stored into the named field, performs
     that side effect, and returns an unspecified value.

     Fields in derived record-types shadow fields of the same name in a
     parent record-type.


File: vicare-libs.info,  Node: srfi err5rs records spec insp,  Next: srfi err5rs records spec synt,  Prev: srfi err5rs records spec proc,  Up: srfi err5rs records spec

2.32.3.2 Inspection Layer
.........................

The '(srfi :99 records inspection)' library exports the following
procedures.

 -- Function: record? OBJ
     Equivalent to its R6RS namesake.

 -- Function: record-rtd RECORD
     Equivalent to its R6RS namesake.

 -- Function: rtd-name RTD
     Equivalent to the 'record-type-name' procedure of the R6RS.

 -- Function: rtd-parent RTD
     Equivalent to the 'record-type-parent' procedure of the R6RS.

 -- Function: rtd-field-names RTD
     Equivalent to the 'record-type-field-names' procedure of the R6RS.
     (That is, it returns a vector of the symbols that name the fields
     of the record-type represented by RTD, excluding the fields of
     parent record-types.)

 -- Function: rtd-all-field-names RTD
     Return a vector of the symbols that name the fields of the
     record-type represented by RTD, including the fields of its parent
     record-types, if any.  The fields of parent record-types come
     before the fields of its children, with each subsequence in the
     same order as in the vectors that would be returned by calling
     'rtd-field-names' on RTD and on all its ancestral record-type
     descriptors.

     Could be defined by:

          (define (rtd-all-field-names rtd)
            (define (loop rtd othernames)
              (let ((parent (rtd-parent rtd))
                    (names (append (vector->list
                                    (rtd-field-names rtd))
                                   othernames)))
                (if parent
                    (loop parent names)
                    (list->vector names))))
            (loop rtd '()))

 -- Function: rtd-field-mutable? RTD FIELD
     RTD is a record-type descriptor, and field is a symbol naming a
     field of the record-type described by RTD.  Return '#t' if the
     named field is mutable; otherwise returns '#f'.


File: vicare-libs.info,  Node: srfi err5rs records spec synt,  Next: srfi err5rs records spec iden,  Prev: srfi err5rs records spec insp,  Up: srfi err5rs records spec

2.32.3.3 Syntactic Layer
........................

The syntactic layer consists of SRFI-9 extended with single inheritance
and (optional) implicit naming.

   All ERR5RS record-type definitions are generative, but ERR5RS drops
the SRFI-9 restriction to top level, mainly because the R6RS allows
generative definitions wherever a definition may appear.

   The '(srfi :99 records syntactic)' library exports the
'define-record-type' syntax specified below.

   The syntax of an ERR5RS record-type definition is:

     <definition>
       -> <record type definition>     ; addition to 7.1.6 in R5RS

     <record type definition>
       -> (define-record-type <type spec>
            <constructor spec>
            <predicate spec>
            <field spec> ...)

     <type spec>  -> <type name>
                  -> (<type name> <parent>)

     <constructor spec>
                  -> #f
                  -> #t
                  -> <constructor name>
                  -> (<constructor name> <field name> ...)

     <predicate spec>
                  -> #f
                  -> #t
                  -> <predicate name>

     <field spec> -> <field name>
                  -> (<field name>)
                  -> (<field name> <accessor name>)
                  -> (<field name> <accessor name> <mutator name>)

     <parent>           -> <expression>

     <type name>        -> <identifier>
     <constructor name> -> <identifier>
     <predicate name>   -> <identifier>
     <accessor name>    -> <identifier>
     <mutator name>     -> <identifier>
     <field name>       -> <identifier>

   The semantics of a record type definition is the same as in SRFI-9:
the record type definition macro-expands into a cluster of definitions
that:

   * define the '<type name>' as the record-type descriptor for the new
     record-type;

   * defines a constructor for instances of the new record-type (unless
     the constructor spec is '#f');

   * defines a predicate that recognizes instances of the new
     record-type and its subtypes (unless the predicate spec is '#f');

   * defines an accessor for each field name;

   * defines a mutator for each mutable field name.

   An ERR5RS record type definition extends SRFI-9 with the following
additional options:

   * If a '<parent>' expression is specified, then it must evaluate to
     an rtd that serves as the parent record-type for the record-type
     being defined.

   * If '#f' is specified for the constructor or predicate, then no
     constructor or predicate procedure is defined.  (This is useful
     when the record-type being defined will be used as an abstract base
     class.)

   * If '#t' is specified for the constructor or predicate, then the
     name of the constructor is the type name prefixed by 'make-', and
     the name of the predicate is the type name followed by a question
     mark ('?').

   * If the constructor name is specified as #t or as an identifier,
     then the constructor's arguments correspond to the fields of the
     parent (if any) followed by the new fields added by this
     record-type definition.

   * If a field spec consists of a single identifier, then:

        - the field is immutable;

        - the name of its accessor is the type name followed by a hyphen
          ('-') followed by the field name.

   * If a field spec consists of a list of one identifier, then:

        - the field is mutable;

        - the name of its accessor is the type name followed by a hyphen
          ('-') followed by the field name;

        - the name of its mutator is the type name followed by a hyphen
          ('-') followed by the field name followed by '-set!'.


File: vicare-libs.info,  Node: srfi err5rs records spec iden,  Prev: srfi err5rs records spec synt,  Up: srfi err5rs records spec

2.32.3.4 Record Identity
........................

Two ERR5RS records with fields are 'eqv?' if and only if they were
created by the same (dynamic) call to some record constructor.  Two
ERR5RS records are 'eq?' if and only if they are 'eqv?'.

   Two ERR5RS records for which the 'record?' predicate returns true are
'equal?' if and only if they are 'eqv?'.  This SRFI does not specify the
semantics of 'equal?' on opaque records, which are not required by this
SRFI.  (The R6RS requires 'equal?' and 'eqv?' to behave the same on all
records, unless the records happen to be opaque records that represent
pairs, vectors, strings, or bytevectors.)

     Historical note: Pavel Curtis proposed that 'equal?' behave the
     same as 'eqv?'.

   A 'define-record-type' form macro-expands into code that calls
'make-rtd each' time the expanded record-type definition is executed.
Two ERR5RS record-type descriptors are 'eqv?' if and only if they were
created by the same (dynamic) call to 'make-rtd'.


File: vicare-libs.info,  Node: srfi err5rs records examples,  Next: srfi err5rs records ack,  Prev: srfi err5rs records spec,  Up: srfi err5rs records

2.32.4 Examples
---------------

R6RS library section 6.3 includes two extended examples that provide a
nice comparison of the R6RS and ERR5RS record systems, especially since
these two examples were designed to highlight the use of R6RS
record-constructor descriptors in combination with inheritance.

Example 1
.........

Using ERR5RS records, the first example becomes:

     (define rtd1
       (make-rtd 'rtd1 '#((immutable x1) (immutable x2))))

     (define rtd2
       (make-rtd 'rtd2 '#((immutable x3) (immutable x4)) rtd1))

     (define rtd3
       (make-rtd 'rtd3 '#((immutable x5) (immutable x6)) rtd2))

     (define protocol1
       (lambda (p)
         (lambda (a b c)
           (p (+ a b) (+ b c)))))

     (define protocol2
       (lambda (n)
         (lambda (a b c d e f)
           (let ((p (n a b c)))
             (p (+ d e) (+ e f))))))

     (define protocol3
       (lambda (n)
         (lambda (a b c d e f g h i)
           (let ((p (n a b c d e f)))
             (p (+ g h) (+ h i))))))

     (define make-rtd1
       (protocol1 (rtd-constructor rtd1)))

     (define make-rtd2
       (let ((maker2 (rtd-constructor rtd2)))
         (protocol2
          (protocol1
           (lambda (x1 x2)
             (lambda (x3 x4)
               (maker2 x1 x2 x3 x4)))))))

     (define make-rtd3
       (let ((maker3 (rtd-constructor rtd3)))
         (protocol3
          (protocol2
           (protocol1
            (lambda (x1 x2)
              (lambda (x3 x4)
                (lambda (x5 x6)
                  (maker3 x1 x2 x3 x4 x5 x6)))))))))

     (make-rtd3 1 2 3 4 5 6 7 8 9)

     ; evaluates to a record whose fields contain
     ; 3 5 9 11 15 17

   The purpose of the R6RS record-constructor descriptors is to automate
the idiom shown in the definitions of 'make-rtd1', 'make-rtd2', and
'make-rtd3' above, and to provide an alternative to procedural
abstraction when eliminating the duplication of code seen in
'make-point/abs' and 'make-cpoint/abs' below.

Example 2
.........

The second example illustrates the shadowing of fields in a parent
record-type by fields in a derived record-type.  Using ERR5RS records,
the second example becomes:

     (define :point
       (make-rtd 'point '#((mutable x) (mutable y))))

     (define make-point (rtd-constructor :point))

     (define point? (rtd-predicate :point))
     (define point-x (rtd-accessor :point 'x))
     (define point-y (rtd-accessor :point 'y))
     (define point-x-set! (rtd-mutator :point 'x))
     (define point-y-set! (rtd-mutator :point 'y))

     (define p1 (make-point 1 2))
     (point? p1)                     => #t
     (point-x p1)                    => 1
     (point-y p1)                    => 2
     (point-x-set! p1 5)
     (point-x p1)                    => 5

     (define :point2
       (make-rtd 'point2 '#((mutable x) (mutable y)) :point))

     (define make-point2
       (rtd-constructor :point2))
     (define point2? (rtd-predicate :point2))
     (define point2-xx (rtd-accessor :point2 'x))
     (define point2-yy (rtd-accessor :point2 'y))

     (define p2 (make-point2 1 2 3 4))
     (point? p2)                     => #t
     (point-x p2)                    => 1
     (point-y p2)                    => 2
     (point2-xx p2)                  => 3
     (point2-yy p2)                  => 4

     (define make-point/abs
       (let ((maker (rtd-constructor :point)))
         (lambda (x y)
           (maker (abs x) (abs y)))))

     (point-x (make-point/abs -1 -2)) => 1
     (point-y (make-point/abs -1 -2)) => 2

     (define :cpoint
       (make-rtd 'cpoint '#((mutable rgb)) :point))

     (define make-cpoint
       (let ((maker (rtd-constructor :cpoint)))
         (lambda (x y c)
           (maker x y (color->rgb c)))))

     (define make-cpoint/abs
       (let ((maker (rtd-constructor :cpoint)))
         (lambda (x y c)
           (maker (abs x) (abs y) (color->rgb c)))))

     (define cpoint-rgb
       (rtd-accessor :cpoint 'rgb))

     (define (color->rgb c)
       (cons 'rgb c))

     (cpoint-rgb (make-cpoint -1 -3 'red))   => (rgb . red)
     (point-x (make-cpoint -1 -3 'red))      => -1
     (point-x (make-cpoint/abs -1 -3 'red))  => 1


File: vicare-libs.info,  Node: srfi err5rs records ack,  Next: srfi err5rs records copyright,  Prev: srfi err5rs records examples,  Up: srfi err5rs records

2.32.5 Acknowledgements
-----------------------

I am grateful to David Rush and Andre van Tonder for their comments and
criticisms, to all those mentioned by name in the Rationale, and to all
who participated in the archived discussion of this SRFI.  The reference
implementation is adapted from Larceny v0.97.


File: vicare-libs.info,  Node: srfi err5rs records copyright,  Prev: srfi err5rs records ack,  Up: srfi err5rs records

2.32.6 Copyright
----------------

Copyright (C) William D Clinger 2008.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
REMEMBER, THERE IS NO SCHEME UNDERGROUND. IN NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi ralists,  Next: srfi basic-socket,  Prev: srfi err5rs records,  Up: srfi

2.33 SRFI-101 random-access lists
=================================

The library '(srfi :101)' is by David Van Horn as the reference
implementation for SRFI-101; see:

           <http://srfi.schemers.org/srfi-101/srfi-101.html>

for more details.  Notice that the library '(srfi :101)' does *not*
export the 'equal?' function described in this specification; rather
such function is exported by '(srfi :101 random-access-lists equal)',
along with a version of 'eqv?'.

* Menu:

* srfi ralists abstract::       Abstract.
* srfi ralists issues::         Issues.
* srfi ralists rationale::      Rationale.
* srfi ralists spec::           Specification.
* srfi ralists refs::           References.
* srfi ralists ack::            Acknowledgements.
* srfi ralists copyright::      Copyright.


File: vicare-libs.info,  Node: srfi ralists abstract,  Next: srfi ralists issues,  Up: srfi ralists

2.33.1 Abstract
---------------

Random-access lists [1] are a purely functional data structure for
representing lists of values.  A random-access list may act as a drop in
replacement for the usual linear-access pair and list data structures
('pair?', 'cons', 'car', 'cdr'), which additionally supports fast
index-based addressing and updating ('list-ref', 'list-set').  The
impact is a whole class of purely-functional algorithms expressed in
terms of index-based list addressing become feasible compared with their
linear-access list counterparts.

   This document proposes a library API for purely functional
random-access lists consistent with the R6RS [2] base library and list
utility standard library [3].


File: vicare-libs.info,  Node: srfi ralists issues,  Next: srfi ralists rationale,  Prev: srfi ralists abstract,  Up: srfi ralists

2.33.2 Issues
-------------

Procedure names have been chosen to be consistent with R6RS, even though
in some cases such as 'list-ref' and 'list-tail' the choice seems poor
since they include the prefix 'list-' even though they do not operate on
lists, but chains of pairs, i.e.  lists and improper lists, and
arbitrary objects, respectively.  Although the names have remained the
same, the descriptions have been corrected (e.g.  using PAIR or OBJ
instead of LIST for parameter names).  Should the names be changed as
well?

   To what extent should standard Scheme procedures and syntax that
consume or construct lists be included in this proposal?  For example,
should all of the '(rnrs base)' library that deals with lists be
included?  By my count this would mean adding: 'lambda', 'apply',
'vector->list', 'list->vector', 'string->list', and 'list->string'.  I
am inclined to add these.  Should all of the '(rnrs lists)' library be
included?  These procedures are easily defined in terms of what's given
here, and no performance advantage is gained by implementing them "under
the hood" using the data structures in the reference implementation.  I
am inclined not to include them.

   Should a 'car+cdr' procedure be added?

   Should the current syntax and procedures sub-libraries be included?


File: vicare-libs.info,  Node: srfi ralists rationale,  Next: srfi ralists spec,  Prev: srfi ralists issues,  Up: srfi ralists

2.33.3 Rationale
----------------

Functional programming and list hacking go together like peanut butter
and jelly, eval and apply, syntax and semantics, or cursing and
recursing.  But the traditional approach to implementing pairs and lists
results in index-based access ('list-ref') requiring time proportional
the index being accessed.  Moreover, indexed-based functional update
('list-set') becomes so inefficient as to be nearly unspeakable.
Instead, programmers revert the imperatives of the state; they use a
stateful data structure and imperative algorithms.

   This SRFI intends to improve the situation by offering an alternative
implementation strategy based on Okasaki's purely functional
random-access lists [1].  Random-access pairs and lists can be used as a
replacement for traditional, linear-access pairs and lists with no
asymptotic loss of efficiency.  In other words, the typical list and
pair operations such as 'cons', 'car', and 'cdr', all operate in O(1)
time as usual.  However, random-access lists additionally support
index-based access and functional update operations that are
asymptotically cheaper; O(\log(n)) for random-access lists versus O(n)
for linear-access lists, where n is the length of the list being access
or updated.  As such, many purely functional index-based list algorithms
become feasible by using a random-access list representation for pairs
and lists.

   The requirements of this SRFI have been designed in such a way as to
admit portable library implementations of this feature, such as the
reference implementation, while at the same time admit more radical
implementations that embrace random-access pairs as the fundamental pair
representation.


File: vicare-libs.info,  Node: srfi ralists spec,  Next: srfi ralists refs,  Prev: srfi ralists rationale,  Up: srfi ralists

2.33.4 Specification
--------------------

* Menu:

* srfi ralists spec random::    Random-access pairs and lists.
* srfi ralists spec repre::     Representation conversion.
* srfi ralists spec requir::    Implementation requirements.


File: vicare-libs.info,  Node: srfi ralists spec random,  Next: srfi ralists spec repre,  Up: srfi ralists spec

2.33.4.1 Random-access pairs and lists
......................................

A random-access pair (or just pair) is a compound structure with two
fields called the car and the cdr fields (consistent with the historical
naming of pair fields in Scheme).  Pairs are created by the procedure
'cons'.  The car and cdr fields are accessed by the procedures 'car' and
'cdr'.

   Pairs are used primarily to represents lists.  A list can be defined
recursively as either the empty list or a pair whose cdr is a list.
More precisely, the set of lists is defined as the smallest set X such
that

   * The empty list is in X.

   * If LIST is in X, then any pair whose cdr field contains LIST is
     also in X.

   The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list.  The length of a list is the
number of elements, which is the same as the number of pairs.

   The empty list is a special object of its own type.  It is not a
pair.  It has no elements and its length is zero.

     *NOTE* The above definitions imply that all lists have finite
     length and are terminated by the empty list.

   A chain of pairs is defined recursively as either a non-pair object
or a pair whose cdr is a chain of pairs (Note: _every value_ is a chain
of pairs).  A chain of pairs ending in the empty list is a list.  A
chain of pairs not ending in the empty list is called an improper list.
Note that an improper list is not a list.  Whether a given pair is a
list depends upon what is stored in the cdr field.

   The external representation of pairs is not specified by this SRFI,
however the examples below do use the typical notation for writing pair
and list values.

   Random-access pairs and lists are specified to be fully functional,
or, to use the term from the academic literature, fully persistent [1].
Full persistence means that all operations on random-access lists,
notably including 'cons', 'list-ref', 'list-set', and 'list-ref/update',
are specified

  1. not to mutate any of their arguments; perforce

  2. to be safe to execute concurrently on shared arguments; and

  3. to suffer no degradation of performance as a consequence of the
     history of operations carried out to produce their arguments
     (except as it is reflected in the lengths of those arguments); but
     permitted

  4. to produce results that share structure with their arguments.

   It is usually taken for granted that standard Scheme lists have these
properties.  This SRFI explicitly specifies that random-access lists
share them.

 -- Syntax: quote ?DATUM
     Syntax: ?DATUM should be a syntactic datum.

     Semantics: '(quote ?DATUM)' evaluates to the datum value
     represented by ?DATUM (see section 4.3 of R6RS).  This notation is
     used to include constants.

     When the datum value represented by ?DATUM contains pair structure,
     quote produces random-access pairs.

          (quote a)               => a
          (quote #(a b c))        => #(a b c)
          (quote (+ 1 2))         => (+ 1 2)

     As noted in section 4.3.5 of R6RS, '(quote ?DATUM)' may be
     abbreviated as ''?DATUM':

          '"abc"                  => "abc"
          '145932                 => 145932
          'a                      => a
          '#(a b c)               => #(a b c)
          '()                     => ()
          '(+ 1 2)                => (+ 1 2)
          '(quote a)              => (quote a)
          ''a                     => (quote a)

     As noted in section 5.10 of R6RS, constants are immutable.

          *NOTE* Different constants that are the value of quote
          expression may share the same locations.

 -- Function: equal? OBJ1 OBJ2
     The 'equal?' predicate returns '#t' if and only if the (possibly
     infinite) unfoldings of its arguments into regular trees are equal
     as ordered trees.

     The 'equal?' predicate treats pairs and vectors as nodes with
     outgoing edges, uses 'string=?' to compare strings, uses
     'bytevector=?' to compare bytevectors, and uses 'eqv?' to compare
     other nodes.

          (equal? 'a 'a)                  => #t

          (equal? '(a) '(a))              => #t

          (equal? '(a (b) c)
                  '(a (b) c))             => #t

          (equal? "abc" "abc")            => #t

          (equal? 2 2)                    => #t

          (equal? (make-vector 5 'a)
                  (make-vector 5 'a))     => #t

          (equal? '#vu8(1 2 3 4 5)
                  (u8-list->bytevector
                   '(1 2 3 4 5))          => #t

          (equal? (lambda (x) x)
                  (lambda (y) y))         => unspecified

          (let* ((x (list 'a))
                 (y (list 'a))
                 (z (list x y)))
            (list (equal? z (list y x))
                  (equal? z (list x x)))) => (#t #t)

 -- Function: pair? OBJ
     Return '#t' if OBJ is a pair, and otherwise returns '#f'.  This
     operation must take O(1) time.

          (pair? '(a . b))                => #t
          (pair? '(a b c))                => #t
          (pair? '())                     => #f
          (pair? '#(a b))                 => #f

 -- Function: cons OBJ1 OBJ2
     Return a newly allocated pair whose car is OBJ1 and whose cdr is
     OBJ2.  The pair is guaranteed to be different (in the sense of
     'eqv?') from every existing object.  This operation must take O(1)
     time.

          (cons 'a '())                   =>  (a)
          (cons '(a) '(b c d))            =>  ((a) b c d)
          (cons "a" '(b c))               =>  ("a" b c)
          (cons 'a 3)                     =>  (a . 3)
          (cons '(a b) 'c)                =>  ((a b) . c)

 -- Function: car PAIR
     Return the contents of the car field of PAIR.  This operation must
     take O(1) time.

          (car '(a b c))                  =>  a
          (car '((a) b c d))              =>  (a)
          (car '(1 . 2))                  =>  1
          (car '())                       error-> &assertion exception

 -- Function: cdr PAIR
     Return the contents of the cdr field of pair.  This operation must
     take O(1) time.

          (cdr '((a) b c d))              =>  (b c d)
          (cdr '(1 . 2))                  =>  2
          (cdr '())                       error-> &assertion exception

 -- Function: caar PAIR
 -- Function: cadr PAIR
 -- Function: ...
 -- Function: cdddar PAIR
 -- Function: cddddr PAIR
     These procedures are compositions of car and cdr, where for example
     'caddr' could be defined by:

          (define caddr
            (lambda (x)
              (car (cdr (cdr x)))))

     Arbitrary compositions, up to four deep, are provided.  There are
     twenty-eight of these procedures in all.  These operations must
     take O(1) time.

 -- Function: null? OBJ
     Return '#t' if OBJ is the empty list, '#f' otherwise.  This
     procedure is equivalent to the 'null?' procedure of the R6RS base
     library.

 -- Function: list? OBJ
     Return '#t' if OBJ is a list, '#f' otherwise.  By definition, all
     lists are chains of pairs that have finite length and are
     terminated by the empty list.  This operation must take time
     bounded by O(\log(n)), where n is the number of pairs in the chain
     forming the potential list.

          (list? '(a b c))                =>  #t
          (list? '())                     =>  #t
          (list? '(a . b))                =>  #f

 -- Function: list OBJ ...
     Return a newly allocated list of its arguments.  This operation
     must take time bounded by O(n), where n is the number of arguments
     to list.

          (list 'a (+ 3 4) 'c)            =>  (a 7 c)
          (list)                          =>  ()

 -- Function: make-list K
 -- Function: make-list K OBJ
     Return a newly allocated list of K elements.  If a second argument
     is given, then each element is initialized to OBJ.  Otherwise the
     initial contents of each element is unspecified.  This operation
     must take time and space bounded by O(\log(k)).

          (make-list 5 0)                 =>  (0 0 0 0 0)

 -- Function: length LIST
     Return the length of LIST.  This operation must take time bounded
     by O(\log(n)), where n is the length of the list.

          (length '(a b c))               =>  3
          (length '(a (b) (c)))           =>  3
          (length '())                    =>  0

 -- Function: length<=? OBJ K
     Return true if OBJ is a chain of at least K pairs and '#f'
     otherwise.  This operation must take time bounded by
     O(\log(\min(k,n))), where n is the length of the chain of pairs.

          (length<=? 'not-a-list 0)       =>  #t
          (length<=? '(a . b) 0)          =>  #t
          (length<=? '(a . b) 1)          =>  #t
          (length<=? '(a . b) 2)          =>  #f

 -- Function: append LIST ... OBJ
     Return a chain of pairs consisting of the elements of the first
     LIST followed by the elements of the other lists, with OBJ as the
     cdr of the final pair.  An improper list results if OBJ is not a
     list.  This operation must take time bounded by O(\log(n)), where n
     is the total number of elements in the given lists.

          (append '(x) '(y))              =>  (x y)
          (append '(a) '(b c d))          =>  (a b c d)
          (append '(a (b)) '((c)))        =>  (a (b) (c))
          (append '(a b) '(c . d))        =>  (a b c . d)
          (append '() 'a)                 =>  a

 -- Function: reverse LIST
     Return a newly allocated list consisting of the element of LIST in
     reverse order.  This operation must take time bounded by O(n) where
     n is the length of the list.

          (reverse '(a b c))               =>  (c b a)
          (reverse '(a (b c) 'd '(e (f)))) =>  ((e (f)) d (b c) a)

 -- Function: list-tail OBJ K
     OBJ should be a chain of pairs with a count of at least K.  The
     'list-tail' procedure returns the object obtained by omitting the
     first K elements in OBJ.  This operation must take time bounded by
     O(\log(\min(k,n))), where n is the length of the chain of pairs.

          (list-tail '(a b c d) 0)        =>  (a b c d)
          (list-tail '(a b c d) 2)        =>  (c d)
          (list-tail 'not-a-list 0)       =>  not-a-list

          *Implementation responsibilities:* The implementation must
          check that OBJ is a chain of pairs whose count is at least K.

 -- Function: list-ref PAIR K
     PAIR must be a chain of pairs whose count is at least k + 1.  The
     'list-ref' procedure returns the K-th element of PAIR.  This
     operation must take time bounded by O(\min(k,\log(n))), where n is
     the length of the chain of pairs.

          (list-ref '(a b c d) 2)         =>  c

          *Implementation responsibilities:* The implementation must
          check that PAIR is a chain of pairs whose count is at least k
          + 1.

 -- Function: list-set PAIR K OBJ
     PAIR must be a chain of pairs whose count is at least k + 1.  The
     'list-set' procedure returns the chain of pairs obtained by
     replacing the K-th element with OBJ.  This operation must take time
     bounded by O(\min(k,\log(n))), where n is the length of the chain
     of pairs.

          (list-set '(a b c d) 2 'x)      =>  (a b x d)

          *Implementation responsibilities:* The implementation must
          check that PAIR is a chain of pairs whose count is at least k
          + 1.

 -- Function: list-ref/update PAIR K PROC
     Return the same results as:

          (values (list-ref PAIR K)
                  (list-set PAIR K (PROC (list-ref PAIR K))))

     but it may be implemented more efficiently.

          (list-ref/update '(7 8 9 10) 2 -)
          =>  9 (7 8 -9 10)

 -- Function: map PROC LIST1 LIST2 ...
     The lists should all have the same length.  PROC should accept as
     many arguments as there are lists and return a single value.

     The 'map' procedure applies PROC element-wise to the elements of
     the lists and returns a list of the results, in order.  PROC is
     always called in the same dynamic environment as 'map' itself.  The
     order in which PROC is applied to the elements of the lists is
     unspecified.

          (map cadr '((a b) (d e) (g h)))
          =>  (b e h)

          (map (lambda (n)
                 (expt n n))
            '(1 2 3 4 5))
          =>  (1 4 27 256 3125)

          (map + '(1 2 3) (4 5 6))
          =>  (5 7 9)

          (let ((count 0))
            (map (lambda (ignored)
                   (set! count (+ count 1))
                   count)
              '(a b)))
          =>  (1 2) or (2 1)

          *Implementation responsibilities:* The implementation should
          check that the lists all have the same length.  The
          implementation must check the restrictions on PROC to the
          extent performed by applying it as described.  An
          implementation may check whether PROC is an appropriate
          argument before applying it.

 -- Function: for-each PROC LIST1 LIST2 ...
     The lists should all have the same length.  PROC should accept as
     many arguments as there are lists.

     The 'for-each' procedure applies PROC element-wise to the elements
     of the lists for its side effects, in order from the first element
     to the last.  PROC is always called in the same dynamic environment
     as 'for-each' itself.  The return values of 'for-each' are
     unspecified.

          (let ((v (make-vector 5)))
            (for-each (lambda (i)
                        (vector-set! v i (* i i)))
              '(0 1 2 3 4))
            v)
          =>  #(0 1 4 9 16)

          (for-each (lambda (x) x) '(1 2 3 4))
          =>  unspecified

          (for-each even? '())
          =>  unspecified

          *Implementation responsibilities:* The implementation should
          check that the lists all have the same length.  The
          implementation must check the restrictions on PROC to the
          extent performed by applying it as described.  An
          implementation may check whether PROC is an appropriate
          argument before applying it.

          *NOTE* Implementations of 'for-each' may or may not tail-call
          PROC on the last element.


File: vicare-libs.info,  Node: srfi ralists spec repre,  Next: srfi ralists spec requir,  Prev: srfi ralists spec random,  Up: srfi ralists spec

2.33.4.2 Representation conversion
..................................

 -- Function: random-access-list->linear-access-list RA-LIST
 -- Function: linear-access-list->random-access-list LA-LIST
     These procedures convert between (potentially) distinct
     representations of lists.  To avoid confusion, parameters named
     RA-LIST range over lists represented with random-access lists, i.e.
     objects satisfying the 'list?' predicate described above, while
     parameters named LA-LIST range over lists represented with the more
     traditional linear-access lists, i.e.  objects satisfying the
     'list?' predicate of R6RS.  In systems that represent all lists as
     random-access lists, these conversions may simply be list identity
     procedures.


File: vicare-libs.info,  Node: srfi ralists spec requir,  Prev: srfi ralists spec repre,  Up: srfi ralists spec

2.33.4.3 Implementation requirements
....................................

Random-access pairs must be disjoint from all other base types with the
possible exception of (linear-access) pairs.

   The external representation of random-access pairs is unspecified.
The behavior of 'equal?' when given a random-access pair and a
sequential-access pair is unspecified in implementations with disjoint
representations.

   The behavior of 'eq?' and 'eqv?' on random-access pairs must be the
same as that for pairs, vectors, or records.  Namely, two random-access
pair objects are 'eq?' if and only if they are 'eqv?', and they are
'eqv?' if and only if they refer to the same location in the store.

   All argument checking for each operation must be done within the time
bounds given for that operation.

   Implementations are encouraged, but not required, to support
random-access pairs and lists as their primary pair and list
representation.  In such an implementation, the external representation
of random-access pairs and list should be as described in section 4.3.2
(Pairs and lists) of R6RS, the behavior of equivalence predicates on
random-access pairs should be as described in section 11.5 (Equivalence
predicates) of R6RS, and so on.  In short, all pairs should be
random-access pairs.

   Implementations supporting SRFI Libraries [4] and SRFI-101 must
provide the following libraries:

     (srfi :101)                                 ; Composite libraries
     (srfi :101 random-access-lists)

     (srfi :101 random-access-lists procedures)  ; Procedures only
     (srfi :101 random-access-lists syntax)      ; Syntax only


File: vicare-libs.info,  Node: srfi ralists refs,  Next: srfi ralists ack,  Prev: srfi ralists spec,  Up: srfi ralists

2.33.5 References
-----------------

  1. "Purely Functional Random-Access Lists".  Chris Okasaki, Functional
     Programming Languages and Computer Architecture, June 1995, pages
     86-95.
     <http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#fpca95>.

  2. "Revised^6 Report on the Algorithmic Language Scheme".  Michael
     Sperber, et al.  (Editors).  <http://www.r6rs.org/>

  3. "Revised^6 Report on the Algorithmic Language Scheme, Standard
     Libraries".  Michael Sperber, et al.  (Editors).
     <http://www.r6rs.org/>

  4. "SRFI-97: SRFI Libraries".  David Van Horn.
     <http://srfi.schemers.org/srfi-97/>

  5. "PLaneT: Purely Functional Random-Access Lists".  David Van Horn.
     <http://planet.plt-scheme.org/display.ss?package=ralist.plt&owner=dvanhorn>


File: vicare-libs.info,  Node: srfi ralists ack,  Next: srfi ralists copyright,  Prev: srfi ralists refs,  Up: srfi ralists

2.33.6 Acknowledgements
-----------------------

I am grateful to the members of the Northeastern University Programming
Research Laboratory and PLT (and their intersection) for discussions
during the pre-draft development of this SRFI and the library that
preceded it.  We are all indebted to Okasaki for his elegant solution to
this problem.  Much of the specification is adapted from text intended
to belong to the Scheme community; I thank the editors and authors of
the RnRS series collectively for their efforts.  I am grateful to
Donovan Kolbly for serving as SRFI editor and to Taylor R Campbell,
Robert Bruce Findler, Aubrey Jaffer, Shiro Kawai, and Alexey Radul for
discussion during the draft period.  I thank William D Clinger, Robert
Bruce Findler, and Abdulaziz Ghuloum for help writing the
implementations of quote specific to Larceny, Ikarus, and PLT,
respectively.  Support was provided by the National Science Foundation
under Grant #0937060 to the Computing Research Association for the
CIFellow Project.


File: vicare-libs.info,  Node: srfi ralists copyright,  Prev: srfi ralists ack,  Up: srfi ralists

2.33.7 Copyright
----------------

Copyright (C) David Van Horn 2009.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
REMEMBER, THERE IS NO SCHEME UNDERGROUND. IN NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi basic-socket,  Next: srfi boxes,  Prev: srfi ralists,  Up: srfi

2.34 SRFI-106 basic socket interface
====================================

The library '(srfi :106)' is by Takashi Kato as the reference
implementation for SRFI-106; see:

           <http://srfi.schemers.org/srfi-106/srfi-106.html>

for more details.

* Menu:

* srfi basic-socket abstract::  Abstract.
* srfi basic-socket rationale:: Rationale.
* srfi basic-socket spec::      Specification.
* srfi basic-socket examples::  Examples.
* srfi basic-socket refs::      References.
* srfi basic-socket copyright:: Copyright.


File: vicare-libs.info,  Node: srfi basic-socket abstract,  Next: srfi basic-socket rationale,  Up: srfi basic-socket

2.34.1 Abstract
---------------

This document specifies basic socket interfaces.


File: vicare-libs.info,  Node: srfi basic-socket rationale,  Next: srfi basic-socket spec,  Prev: srfi basic-socket abstract,  Up: srfi basic-socket

2.34.2 Rationale
----------------

Many Scheme implementations have their own socket APIs however there are
no portable way to write socket programs.  Therefore programmers need to
provide implementation dependent layers for their programs.

   This document specifies high and middle range of socket interfaces
which are commonly used for socket programming.  It should make it
easier to write portable programs that need to send or receive data from
their socket.


File: vicare-libs.info,  Node: srfi basic-socket spec,  Next: srfi basic-socket examples,  Prev: srfi basic-socket rationale,  Up: srfi basic-socket

2.34.3 Specification
--------------------

* Menu:

* srfi basic-socket spec intro::        Introduction.
* srfi basic-socket spec cons::         Constructors and predicates.
* srfi basic-socket spec ops::          Socket operations.
* srfi basic-socket spec port::         Port conversion.
* srfi basic-socket spec control::      Control features.
* srfi basic-socket spec flag::         Flag operations.
* srfi basic-socket spec const::        Constants.


File: vicare-libs.info,  Node: srfi basic-socket spec intro,  Next: srfi basic-socket spec cons,  Up: srfi basic-socket spec

2.34.3.1 Introduction
.....................

All procedures defined in this SRFI may raise an error when the
procedure fails because of a connection problem or other socket related
problems.  This document does not specify which condition should be
raised.

   Names defined in this document:

*Constructors and predicates*
          make-client-socket              make-server-socket
          socket?

*Socket operations*
          socket-accept
          socket-send                     socket-recv
          socket-shutdown                 socket-close

*Port conversion*
          socket-input-port
          socket-output-port

*Control feature*
          call-with-socket

*Flag operations*
          address-family                  address-info
          socket-domain                   ip-protocol
          message-type                    shutdown-method
          socket-merge-flags              socket-purge-flags

*Constant values*
          *af-unspec*             *af-inet*               *af-inet6*
          *sock-stream            *sock-dgram*
          *ai-canonname*          *ai-numerichost*
          *ai-v4mapped*           *ai-all*                *ai-addrconfig*
          *ipproto-ip*            *ipproto-tcp*           *ipproto-udp*
          *msg-peek*              *msg-oob*               *msg-waitall*
          *shut-rd*               *shut-wr*               *shut-rdwr*

   The procedure description uses following notation:

SOCKET
     A socket object.

BV
     A bytevector.

OBJ
     Any value.


File: vicare-libs.info,  Node: srfi basic-socket spec cons,  Next: srfi basic-socket spec ops,  Prev: srfi basic-socket spec intro,  Up: srfi basic-socket spec

2.34.3.2 Constructors and predicates
....................................

The following bindings are exported by the libraries '(srfi :106)' and
'(srfi :106 socket)'.

 -- Function: make-client-socket NODE SERVICE
 -- Function: make-client-socket NODE SERVICE AI-FAMILY
 -- Function: make-client-socket NODE SERVICE AI-FAMILY AI-SOCKTYPE
 -- Function: make-client-socket NODE SERVICE AI-FAMILY AI-SOCKTYPE
          AI-FLAGS
 -- Function: make-client-socket NODE SERVICE AI-FAMILY AI-SOCKTYPE
          AI-FLAGS AI-PROTOCOL
     Return a client socket connected to an Internet address.

     The Internet address is identified by NODE and SERVICE.  NODE and
     SERVICE must be strings.  Example values for NODE: '"localhost"',
     '127.0.0.1'.  Example values for SERVICE: '"http"', '"80"'.

     The optional arguments may specify the created socket's behaviour.
     If the optional arguments are omitted, then the following value
     should be used as default:

     AI-FAMILY
          Defaults to: '*af-inet*'.

     AI-SOCKTYPE
          Defaults to: '*sock-stream*'.

     AI-FLAGS
          Defaults to: '(socket-merge-flags *ai-v4mapped*
          *ai-addrconfig*)'.

     AI-PROTOCOL
          Defaults to: '*ipproto-ip*'.

     The returned socket may not be closed automatically so it is the
     users' responsibility to close it explicitly.

          *For Vicare:* whenever the returned socket object is garbage
          collected, the function 'socket-close' is automatically
          applied to it.

 -- Function: make-server-socket SERVICE
 -- Function: make-server-socket SERVICE AI-FAMILY
 -- Function: make-server-socket SERVICE AI-FAMILY AI-SOCKTYPE
 -- Function: make-server-socket SERVICE AI-FAMILY AI-SOCKTYPE
          AI-PROTOCOL
     Return a server socket waiting for connection.

     The NODE argument is the same as the one of 'make-client-socket'.
     The optional arguments may specify the created socket's behaviour.
     If the optional arguments are omitted, then the following value
     should be used as default:

     AI-FAMILY
          Defaults to: '*af-inet*'.

     AI-SOCKTYPE
          Defaults to: '*sock-stream*'.

     AI-PROTOCOL
          Defaults to: '*ipproto-ip*'.

     The returned socket may not be closed automatically so it is the
     users' responsibility to close it explicitly.

          *For Vicare:* whenever the returned socket object is garbage
          collected, the function 'socket-close' is automatically
          applied to it.

 -- Function: socket? OBJ
     Return '#t' if OBJ is a socket object, '#f' otherwise.


File: vicare-libs.info,  Node: srfi basic-socket spec ops,  Next: srfi basic-socket spec port,  Prev: srfi basic-socket spec cons,  Up: srfi basic-socket spec

2.34.3.3 Socket operations
..........................

The following bindings are exported by the libraries '(srfi :106)' and
'(srfi :106 socket)'.

 -- Function: socket-accept SOCKET
     Wait for an incoming connection request, and return a fresh
     connected client socket.

 -- Function: socket-send SOCKET BV
 -- Function: socket-send SOCKET BV FLAGS
     Send a binary data block to a socket and return the sent data size.

     FLAGS may specify the procedure's behaviour.  If FLAGS is omitted:
     the default value must be the result of evaluating the form:

          (message-type none)

 -- Function: socket-recv SOCKET SIZE
 -- Function: socket-recv SOCKET SIZE FLAGS
     Receive a binary data block from a socket.  If a zero-length
     bytevector is returned: it means the peer connection is closed.

     FLAGS may specify the procedure's behaviour.  If FLAGS is omitted,
     the default value must be the result of evaluating the form:

          (message-type none)

 -- Function: socket-shutdown SOCKET HOW
     Shutdown a socket.  HOW must be one of the following constants:
     '*shut-rd*', '*shut-wr*', '*shut-rdwr*'.

 -- Function: socket-close SOCKET
     Close a socket.  The procedure should not shutdown the given
     socket: to shutdown a socket 'socket-shutdown' should be called
     explicitly.

          *For Vicare:* it is safe to apply multiple times this function
          to the same SOCKET object; the first time the socket is
          closed, subsequent times nothing happens.  This function is
          automatically applied to every socket object returned by
          'make-client-socket' and 'make-server-socket' whenever such
          objects are garbage collected.

 -- Function: socket-descriptor SOCKET
     This function is a Vicare extension.  Return an exact integer
     representing the underlying socket descriptor; such integer can be
     used as argument to every POSIX function accepting socket
     descriptors.


File: vicare-libs.info,  Node: srfi basic-socket spec port,  Next: srfi basic-socket spec control,  Prev: srfi basic-socket spec ops,  Up: srfi basic-socket spec

2.34.3.4 Port conversion
........................

The following bindings are exported by the libraries '(srfi :106)' and
'(srfi :106 socket)'.

 -- Function: socket-input-port SOCKET
 -- Function: socket-output-port SOCKET
     Return a fresh binary input or output port associated with a
     SOCKET, respectively.  Whenever the returned port is closed: the
     associated socket must *not* be closed along.

          *For Vicare:* it is fine to use 'transcoded-port' from '(rnrs
          io ports (6))' to put a textual port on top of the returned
          binary ports.  Example:

               (import (vicare)
                 (prefix (srfi :106) srfi.))

               (with-compensations
                 (define socket
                   (compensate
                       (srfi.make-client-socket "reddit.com" "http")
                     (with
                      (srfi.socket-shutdown socket
                        (srfi.shutdown-method read write))
                      (srfi.socket-close socket))))

                 (define in-port
                   (compensate
                       (transcoded-port (srfi.socket-input-port socket)
                                        (native-transcoder))
                     (with
                      (close-port in-port))))

                 (define ou-port
                   (compensate
                       (transcoded-port (srfi.socket-output-port socket)
                                        (native-transcoder))
                     (with
                      (close-port ou-port))))

                 ---)

          It is also fine to use the returned ports as PORT argument to
          the functions 'select-port', 'select-port-readable?',
          'select-port-writable?', 'select-port-exceptional?'.


File: vicare-libs.info,  Node: srfi basic-socket spec control,  Next: srfi basic-socket spec flag,  Prev: srfi basic-socket spec port,  Up: srfi basic-socket spec

2.34.3.5 Control features
.........................

The following bindings are exported by the libraries '(srfi :106)' and
'(srfi :106 socket)'.

 -- Function: call-with-socket SOCKET PROC
     Call a given procedure with a given socket as an argument.  If PROC
     returns: 'call-with-socket' returns the result of PROC and SOCKET
     is automatically closed.  If PROC does not return: then SOCKET is
     not closed automatically.


File: vicare-libs.info,  Node: srfi basic-socket spec flag,  Next: srfi basic-socket spec const,  Prev: srfi basic-socket spec control,  Up: srfi basic-socket spec

2.34.3.6 Flag operations
........................

The following bindings must be implemented as macros: 'address-family',
'address-info', 'socket-domain', 'ip-protocol', 'message-type' and
'shutdown-method'.

   The following bindings are exported by the libraries '(srfi :106)'
and '(srfi :106 socket)'.

 -- Syntax: address-family ?NAME
     Return a proper address family from the given ?NAME.
     Implementations must support at least following names and must have
     the described behaviour.

     'inet'
          Returns '*af-inet*'.

     'inet6'
          Returns '*af-inet6*'.

     'unspec'
          Returns '*af-unspec*'.

     Implementations may support more names such as 'unix' or 'local' or
     other names.

 -- Syntax: address-info ?NAME ...
     Return merged address info flags from given ?NAME.  Implementations
     must support at least following names and must have the described
     behaviour.

     'canoname'
     'canonname'
          Returns '*ai-canonname*'.

     'numerichost'
          Returns '*ai-numerichost*'.

     'v4mapped'
          Returns '*ai-v4mapped*'.

     'all'
          Returns '*ai-all*'.

     'addrconfig'
          Returns '*ai-addrconfig*'.

     Implementations may support more names.

 -- Syntax: socket-domain ?NAME
     Return socket domain flags from the given ?NAME.  Implementations
     must support at least following names and must have the described
     behaviour.

     'stream'
          Returns '*sock-stream*'.

     'datagram'
          Returns '*sock-dgram*'.

     Implementations may support more names.

 -- Syntax: ip-protocol ?NAME
     Return ip-protocol flag from given ?NAME.  Implementations must
     support at least following names and must have the described
     behaviour.

     'ip'
          Returns '*ipproto-ip*'.

     'tcp'
          Returns '*ipproto-tcp*'.

     'udp'
          Returns '*ipproto-udp*'.

     Implementations may support more names.

 -- Syntax: message-type ?NAME ...
     Return message type flag from given NAME.  The flag can be used
     both by 'socket-recv' and 'socket-send'.  Implementations must
     support at least following names and must have the described
     behaviour.

     'none'
          Returns no flag.

     'peek'
          Returns '*msg-peek*'.

     'oob'
          Returns '*msg-oob*'.

     'wait-all'
          Returns '*msg-waitall*'.

     Implementations may support more names.

 -- Syntax: shutdown-method ?NAME ...
     Return shutdown method flags from given ?NAMES.  Implementations
     must support at least following names and must have the described
     behaviour.

     'read'
          Returns '*shut-rd*'.

     'write'
          Returns '*shut-wr*'.

     If 'shutdown-method' is given both 'read' and 'write', then it must
     return '*shut-rdwr*'.

 -- Syntax: socket-merge-flags ?FLAGS ...
     Merge given ?FLAGS and returns a new flag.

 -- Syntax: socket-purge-flags ?BASE-FLAG ?FLAG ...
     Remove ?FLAG from ?BASE-FLAG if it exists and return a new flag.


File: vicare-libs.info,  Node: srfi basic-socket spec const,  Prev: srfi basic-socket spec flag,  Up: srfi basic-socket spec

2.34.3.7 Constants
..................

Implementations must support following constant variables.  All constant
variable must be consistent with POSIX's[1] definition.  The following
bindings are exported by the libraries '(srfi :106)' and '(srfi :106
socket)'.

Address family
..............

'*af-inet*'
     Internet domain sockets for use with IPv4 addresses.  This must
     behave the same as POSIX's 'AF_INET'.

'*af-inet6*'
     Internet domain sockets for use with IPv6 addresses.  This must
     behave the same as POSIX's 'AF_INET6'.

'*af-unspec*'
     Unspecified.  This must behave the same as POSIX's 'AF_UNSPEC'.

Socket domain
.............

'*sock-stream*'
     Byte-stream socket.  This must behave the same as POSIX's
     'SOCK_STREAM'.

'*sock-dgram*'
     Datagram socket.  This must behave the same as POSIX's
     'SOCK_DGRAM'.

Address info
............

'*ai-canonname*'
     This must behave the same as POSIX's 'AI_CANONNAME'.

'*ai-numerichost*'
     This must behave the same as POSIX's 'AI_NUMERICHOST'.

'*ai-v4mapped*'
     This must behave the same as POSIX's 'AI_V4MAPPED'.

'*ai-all*'
     This must behave the same as POSIX's 'AI_ALL'.

'*ai-addrconfig*'
     This must behave the same as POSIX's 'AI_ADDRCONFIG'.

IP protocol
...........

'*ipproto-ip*'
     Internet protocol.  This must behave the same as POSIX's
     'IPPROTO_IP'.

'*ipproto-tcp*'
     Transmission control protocol.  This must behave the same as
     POSIX's 'IPPROTO_TCP'.

'*ipproto-udp*'
     User datagram protocol.  This must behave the same as POSIX's
     'IPPROTO_UDP'.

Message type
............

'*msg-peek*'
     For 'socket-recv'.  Peeks at an incoming message.  The data is
     treated as unread and the next 'socket-recv' shall still return
     this data.  This must behave the same as POSIX's 'MSG_PEEK'.

'*msg-oob*'
     For both 'socket-recv' and 'socket-send'.  Requests/sends
     out-of-band data.  This must behave the same as POSIX's 'MSG_OOB'.

'*msg-waitall*'
     For 'socket-recv'.  On sockets created with '*sock-stream*' flag,
     this requests the procedure block until the full amount of data ban
     be returned.  This must behave the same as POSIX's 'MSG_WAITALL'.

Shutdown method
...............

'*shut-rd*'
     Disables further receive operation.  This must behave the same as
     POSIX's 'SHUT_RD'.

'*shut-wr*'
     Disables further send operations.  This must behave the same as
     POSIX's 'SHUT_WR'.

'*shut-rdwr*'
     Disables further send and receive operations.  This must behave the
     same as POSIX's 'SHUT_RDWR'.


File: vicare-libs.info,  Node: srfi basic-socket examples,  Next: srfi basic-socket refs,  Prev: srfi basic-socket spec,  Up: srfi basic-socket

2.34.4 Examples
---------------

Simple echo server:

     (import (vicare)
       (prefix (srfi :106 socket)
               srfi.))

     (define (server-run master-socket)
       ;;Handle the first pending connection.  If an
       ;;exception is raised ignore it.
       (guard (E (else
                  (debug-print (condition-message E))))
         (srfi.call-with-socket
             (srfi.socket-accept master-socket)
           (lambda (server-socket)
             (with-compensations
               (define in
                 (compensate
                     (transcoded-port
                      (srfi.socket-input-port  server-socket)
                      (native-transcoder))
                   (with
                    (close-port in))))
               (define ou
                 (compensate
                     (transcoded-port
                      (srfi.socket-output-port server-socket)
                      (native-transcoder))
                   (with
                    (close-port ou))))
               (push-compensation
                (srfi.socket-shutdown server-socket)
                (srfi.socket-close    server-socket))
               (let loop ((line (read-line in)))
                 (unless (eof-object? line)
                   (put-string ou (string-append line "\r\n"))
                   (flush-output-port ou)
                   (loop (read-line in))))))))
       ;;Handle next pending connection.
       (server-run master-socket))

     (define echo-master-socket
       (srfi.make-server-socket "8080"))

     (server-run echo-master-socket)

   Simple echo client:

     (import (rnrs)
       (prefix (srfi :106 socket)
               srfi.))

     (define client-socket
       (srfi.make-client-socket "localhost" "8080"
         (srfi.address-family inet)
         (srfi.socket-domain stream)
         (srfi.address-info v4mapped addrconfig)
         (srfi.ip-protocol ip)))

     (srfi.socket-send client-socket (string->utf8 "hello\r\n"))
     (display (utf8->string
               (srfi.socket-recv client-socket
                                 (string-length "hello\r\n"))))
     (flush-output-port (current-output-port))
     (srfi.socket-shutdown client-socket
                           (srfi.shutdown-method read write))
     (srfi.socket-close client-socket)


File: vicare-libs.info,  Node: srfi basic-socket refs,  Next: srfi basic-socket copyright,  Prev: srfi basic-socket examples,  Up: srfi basic-socket

2.34.5 References
-----------------

[1] The Open Group Base Specifications Issue 7:

     <http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html>


File: vicare-libs.info,  Node: srfi basic-socket copyright,  Prev: srfi basic-socket refs,  Up: srfi basic-socket

2.34.6 Copyright
----------------

Copyright (C) Takashi Kato (2012) <ktakashi@ymail.com>.
All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi boxes,  Next: srfi env-inquiry,  Prev: srfi basic-socket,  Up: srfi

2.35 SRFI-111 boxes
===================

The library '(srfi :111)' is by John Cowan as the reference
implementation for SRFI-111; see:

           <http://srfi.schemers.org/srfi-111/srfi-111.html>

for more details.

* Menu:

* srfi boxes abstract::         Abstract.
* srfi boxes rationale::        Rationale.
* srfi boxes spec::             Specification.
* srfi boxes copyright::        Copyright.


File: vicare-libs.info,  Node: srfi boxes abstract,  Next: srfi boxes rationale,  Up: srfi boxes

2.35.1 Abstract
---------------

Boxes are objects with a single mutable state.  Several Schemes have
them, sometimes called _cells_.  A constructor, predicate, accessor, and
mutator are provided.


File: vicare-libs.info,  Node: srfi boxes rationale,  Next: srfi boxes spec,  Prev: srfi boxes abstract,  Up: srfi boxes

2.35.2 Rationale
----------------

A box is a container for an object of any Scheme type, including another
box.  It is like a single-element vector, or half of a pair, or a direct
representation of state.  Boxes are normally used as minimal mutable
storage, and can inject a controlled amount of mutability into an
otherwise immutable data structure (or one that is conventionally
treated as immutable).  They can be used to implement call-by-reference
semantics by passing a boxed value to a procedure and expecting the
procedure to mutate the box before returning.

   Some Scheme systems use boxes to implement 'set!'.  In this
transformation, known as _assignment conversion_, all variables that are
actually mutated are initialized to boxes, and all 'set!' syntax forms
become calls on 'set-box!'.  Naturally, all ordinary references to those
variables must become calls on 'unbox'.  By reducing all variable
mutation to data-structure mutation in this way, such Scheme systems are
free to maintain variables in multiple hardware locations, such as the
stack and the heap or registers and the stack, without worrying about
exactly when and where they are mutated.

   Boxes are also useful for providing an extra level of indirection,
allowing more than one body of code or data structure to share a
reference, or pointer, to an object.  In this way, if any procedure
mutates the box in any of the data structures, all procedures will
immediately "see" the new value in all data structures containing it.

   Racket and Chicken provide _immutable boxes_, which look like boxes
to 'box?' and 'unbox' but which cannot be mutated.  They are not
considered useful enough to be part of this SRFI.  If they are provided
nevertheless, the recommended constructor name is 'immutable-box'.

   The features specified in the autoboxing section of specification are
based on those specified by RnRS for promises, which are analogous to
immutable boxes except that their value is specified by code instead of
data.


File: vicare-libs.info,  Node: srfi boxes spec,  Next: srfi boxes copyright,  Prev: srfi boxes rationale,  Up: srfi boxes

2.35.3 Specification
--------------------

The following procedures implement the box type (which is disjoint from
all other Scheme types), and are exported by the libraries '(srfi :111)'
and '(srfi :111 boxes)'.

 -- Function: box OBJ
     Constructor.  Return a newly allocated box initialized to OBJ.

 -- Function: box? OBJ
     Predicate.  Return '#t' if OBJ is a box, and '#f' otherwise.

 -- Function: unbox BOX/OBJ
     Accessor.  Return the current value of BOX/OBJ.

          *For Vicare:* if BOX/OBJ is not a box object, no error is
          raised and the return value is BOX/OBJ itself.

 -- Function: set-box! BOX NEW-OBJ
     Mutator.  Change BOX to hold NEW-OBJ.

   The behavior of boxes with the equivalence predicates 'eq?', 'eqv?',
and 'equal?' is the same as if they were implemented with records.  That
is, two boxes are both 'eq?' and 'eqv?' if, and only if, they are the
product of the same call to 'box' and not otherwise, and while they must
be 'equal?' if they are 'eqv?', the converse is
implementation-dependent.

     *For Vicare:* two boxes produced by distinct call to 'box' and
     holding the same object are 'equal?' but not 'eqv?'.

Autoboxing (optional)
.....................

The following provisions of this SRFI are optional:

   * A procedure, whether system-provided or user-written, that expects
     a box as an argument but receives a non-box may, if appropriate,
     allocate a box itself that holds the value, thus providing
     autoboxing.

   * A procedure that accepts arguments only of specified types (such as
     '+') but receives a box instead may, if appropriate, unbox the box.
     Procedures that accept arguments of any type (such as 'cons') must
     not unbox their arguments.

   * Calling 'unbox' on a non-box may simply return the non-box.


File: vicare-libs.info,  Node: srfi boxes copyright,  Prev: srfi boxes spec,  Up: srfi boxes

2.35.4 Copyright
----------------

Copyright (C) John Cowan 2013.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi env-inquiry,  Next: srfi sets-and-bags,  Prev: srfi boxes,  Up: srfi

2.36 SRFI-112 environment inquiry
=================================

The library '(srfi :112)' is by John Cowan as implementation for
SRFI-112; see:

           <http://srfi.schemers.org/srfi-112/srfi-112.html>

for more details.

* Menu:

* srfi env-inquiry abstract::   Abstract.
* srfi env-inquiry rationale::  Rationale.
* srfi env-inquiry spec::       Specification.
* srfi env-inquiry impl::       Implementation.
* srfi env-inquiry copyright::  Copyright.


File: vicare-libs.info,  Node: srfi env-inquiry abstract,  Next: srfi env-inquiry rationale,  Up: srfi env-inquiry

2.36.1 Abstract
---------------

This is a proposal for environment inquiry, providing human-readable
information at run time about the hardware and software configuration on
which a Scheme program is being executed.  They are mostly based on
Common Lisp, with additions from the Posix 'uname()' system call.


File: vicare-libs.info,  Node: srfi env-inquiry rationale,  Next: srfi env-inquiry spec,  Prev: srfi env-inquiry abstract,  Up: srfi env-inquiry

2.36.2 Rationale
----------------

The feature symbols of the R7RS-small 'cond-expand' syntax provide the
ability to conditionally compile code based on particular properties of
an implementation that it sees fit to publish.  The 'features'
procedure, which returns the list of feature symbols of the
implementation, provides run-time access to the same set of properties.
Assuming that Rhinoceros Scheme provides the feature symbol 'rhinoceros'
but not 'diplodocus' and Diplodocus Scheme does the opposite, programs
can portably ask "Is this Rhinoceros Scheme or Diplodocus Scheme?"  and
behave differently at run time based on the answer.  Similarly, a
program can ask "Does this implementation have exact complex numbers?"
by checking for the presence of the 'exact-complex' feature symbol in
the result of calling 'features'.

   However, a program using just the 'features' procedure cannot report
to its user "I am executing on X Scheme" for every value of X, because
it does not know which symbol in the feature list represents the
implementation name, nor does it have a comprehensive list of
implementation names.  Similarly, there are other properties that the
feature list may allow testing for but not reporting on, such as the
underlying OS and the CPU architecture.  For the sake of logging and
debugging, it is necessary or at least extremely useful to provide a
standard way for Scheme applications, as well as Scheme users at the
REPL, to report these things.  In the Common Lisp world, bugs are often
reported in a REPL transcript beginning with a call to
'lisp-implementation-version'.


File: vicare-libs.info,  Node: srfi env-inquiry spec,  Next: srfi env-inquiry impl,  Prev: srfi env-inquiry rationale,  Up: srfi env-inquiry

2.36.3 Specification
--------------------

The following procedures take no arguments and return either a string,
or '#f' if the implementation cannot provide an appropriate and relevant
result.  It is an error to mutate the returned string.  The procedures
in this proposal are in the '(srfi 112)' library (or '(srfi :112)' on
R6RS).

     *For Vicare*: the bindings documented here are exported by the
     libraries '(srfi :112)' and '(srfi :112 environment-inquiry)' and
     also by the boot image, *note Environment inquiry:
     (vicare-scheme)iklib env-inquiry.

   Because users are expected to use the values of these procedures for
reporting rather than testing, no attempt is made to standardize the
string values they return.

   Procedures are provided rather than strings against the possibility
that a Scheme process might migrate from machine to machine.  This need
not happen only in a distributed environment; consider, for example,
dumping a core image file containing a compiler and then shipping it to
another site.

   POSIX and Common Lisp equivalents or near-equivalents are provided.
On Windows, some of this information is available using the
'GetSystemInfo()' and 'GetComputerName()' APIs.

 -- Function: implementation-name
     Return the name of the Scheme implementation.  This procedure
     corresponds roughly to Common Lisp's 'lisp-implementation-type'
     function.

 -- Function: implementation-version
     Return the version of the Scheme implementation.  This procedure
     corresponds roughly to Common Lisp's 'lisp-implementation-version'
     function.

 -- Function: cpu-architecture
     Return the CPU architecture, real or virtual, on which this
     implementation is executing.  This procedure corresponds roughly to
     Common Lisp's 'machine-type' function.  On POSIX systems, the
     result may be derived from the 'machine' field of the 'utsname'
     structure.

 -- Function: machine-name
     Return a name for the particular machine on which the
     implementation is running.  Possible values are the DNS or WINS
     host name, the DNS full name, an IP address in string form
     associated with the system, or a MAC address in string form
     associated with the system.  This procedure corresponds roughly to
     Common Lisp's 'machine-instance' function.  On POSIX systems, the
     result may be derived from the 'nodename' field of the 'utsname'
     structure.

 -- Function: os-name
     Return a name for the operating system, platform, or equivalent on
     which the implementation is running.  This procedure corresponds
     roughly to Common Lisp's 'software-type' function.  On POSIX
     systems, the result may be derived from the 'sysname' field of the
     'utsname' structure.

 -- Function: os-version
     Return the version of the operating system, platform, or equivalent
     on which the implementation is running.  This procedure corresponds
     roughly to Common Lisp's 'software-version' function.  On POSIX
     systems, the result may be derived from the 'release' and/or
     'version' fields of the 'utsname' structure.

   *NOTE* Analogues to the Common Lisp 'machine-version',
'short-site-name', and 'long-site-name' are not provided.  They are
inconsistently implemented and of doubtful utility.


File: vicare-libs.info,  Node: srfi env-inquiry impl,  Next: srfi env-inquiry copyright,  Prev: srfi env-inquiry spec,  Up: srfi env-inquiry

2.36.4 Implementation
---------------------

The implementation of this SRFI is inherently system-dependent.  The
version shown below is for an imaginary Scheme implementation, and is in
R5RS style.  Trivial wrappers will convert it to an R6RS or R7RS
library.

   Some of the information can be derived from the 'uname()' system
call, which is provided by the POSIX standard.  (Some of the same
information is available on Win32 using 'GetSystemInfo()' and
'GetComputerNameA()'.)

   The exact Scheme interface to 'uname()' is highly system-dependent.

   * In Chicken, the 'system-information' procedure returns a list of
     five strings representing the five components of the POSIX
     'utsname' structure.

   * In Gauche, the same procedure is called 'sys-uname'.

   * In Guile and Sizzle, it is called 'uname', and returns a vector
     rather than a list; Sizzle places it in the module '(core posix)'.

   * In Scheme48, there are five separate procedures in the 'posix'
     structure named 'os-name', 'os-node-name', 'os-release-name',
     'os-version-name', and 'machine-name'.

   * In scsh, the 'uname' procedure returns a record whose fields have
     the same names as the Scheme48 procedures; their accessors are
     named 'uname:os-name', etc.

   The version below uses the Guile convention.

     (define (implementation-name)
       "Fantastic Scheme")

     (define (implementation-version)
       "1.0")

     (define (cpu-architecture)
       (vector-ref (uname) 4)) ; POSIX machine field

     (define (machine-name)
       (vector-ref (uname) 1)) ; POSIX nodename field

     (define (os-name)
       (vector-ref (uname) 0)) ; POSIX sysname field

     (define (os-version)
       (string-append
         (vector-ref (uname) 2)   ; POSIX version field
         " "
         (vector-ref (uname) 3))) ; POSIX release field


File: vicare-libs.info,  Node: srfi env-inquiry copyright,  Prev: srfi env-inquiry impl,  Up: srfi env-inquiry

2.36.5 Copyright
----------------

Copyright (C) John Cowan 2013.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi sets-and-bags,  Next: srfi comparators,  Prev: srfi env-inquiry,  Up: srfi

2.37 SRFI-113 sets and bags
===========================

The libraries '(srfi :113)' and '(srfi :113 sets-and-bags)' are by John
Cowan as the reference implementation for SRFI-113; see:

           <http://srfi.schemers.org/srfi-113/srfi-113.html>

for more details.  Sets and bags (also known as multisets) are unordered
collections that can contain any Scheme object.  Elements in sets and
bags are compared using the facilities of SRFI-114 (*note SRFI-114
comparators: srfi comparators.).

* Menu:

* srfi sets-and-bags intro::      Introduction.
* srfi sets-and-bags constr::     Constructors.
* srfi sets-and-bags preds::      Predicates.
* srfi sets-and-bags access::     Accessors.
* srfi sets-and-bags update::     Updaters.
* srfi sets-and-bags whole::      The whole set.
* srfi sets-and-bags map::        Mapping and folding.
* srfi sets-and-bags copy::       Copying and conversion.
* srfi sets-and-bags subsets::    Subsets.
* srfi sets-and-bags theory::     Set theory operations.
* srfi sets-and-bags bag::        Bag-only procedures.
* srfi sets-and-bags compar::     Comparators.
* srfi sets-and-bags copyright::  Copyright.


File: vicare-libs.info,  Node: srfi sets-and-bags intro,  Next: srfi sets-and-bags constr,  Up: srfi sets-and-bags

2.37.1 Introduction
-------------------

Sets and bags are mutually disjoint types; they are also disjoint from
other types of Scheme objects.

   * Sets enforce the constraint that no two elements can be the same in
     the sense of the set's associated equality predicate.

   * Bags are like sets, but can contain the same object more than once.
     However, if two elements that are the same in the sense of the
     equality predicate, but not in the sense of 'eqv?', are both
     included, it is not guaranteed that they will remain distinct when
     retrieved from the bag: if two elements in a bag are the same in
     the sense of the bag's comparator, the implementation may in fact
     store just one of them.

   The procedures for creating and manipulating bags are the same as
those for sets, except that 'set' is replaced by 'bag' in their names,
and that adjoining an element to a bag is effective even if the bag
already contains the element.

Constraints
...........

The API defined by '(srfi :113)' imposes usage constraints:

   * It is an error for any procedure to be invoked on sets or bags with
     distinct comparators (in the sense of 'eq?').

   * It is an error to mutate any object while it is contained in a set
     or bag.

   * It is an error to add an object to a set or bag which does not
     satisfy the type test predicate of the comparator.

   * It is an error to add or remove an object from a set or a bag while
     iterating over it.

Linear update
.............

The procedures of this SRFI, by default, are "pure functional": they do
not alter their parameters.  However, this SRFI also defines
"linear-update" procedures, all of whose names end in '!'.  They have
hybrid pure-functional/side-effecting semantics: they are allowed, but
not required, to side-effect one of their parameters in order to
construct their result.  An implementation may legally implement these
procedures as pure, side-effect-free functions, or it may implement them
using side effects, depending upon the details of what is the most
efficient or simple to implement in terms of the underlying
representation.

   It is an error to rely upon these procedures working by side effect.
For example, this is not guaranteed to work:

     (let* ((set1 (set 'a 'b 'c))           ; set1 = {a,b,c}.
            (set2 (set-adjoin! set1 'd)))   ; Add d to {a,b,c}.
       set1) ; Could be either {a,b,c} or {a,b,c,d}.

   However, this is well-defined:

     (let ((set1 (set 'a 'b 'c)))
       (set-adjoin! set1 'd)) ; Add d to {a,b,c}.

   So clients of these procedures write in a functional style, but must
additionally be sure that, when the procedure is called, there are no
other live pointers to the potentially-modified character set (hence the
term "linear update").

   There are two benefits to this convention:

   * Implementations are free to provide the most efficient possible
     implementation, either functional or side-effecting.

   * Programmers may nonetheless continue to assume that sets are purely
     functional data structures: they may be reliably shared without
     needing to be copied, uniquified, and so forth.

   In practice, these procedures are most useful for efficiently
constructing sets and bags in a side-effecting manner, in some limited
local context, before passing the character set outside the local
construction scope to be used in a functional manner.

   Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions: there's
no linear type checker or run-time mechanism for detecting violations.

   Note that if an implementation uses no side effects at all, it is
allowed to return existing sets and bags rather than newly allocated
ones, even where this SRFI explicitly says otherwise.

Comparator restrictions
.......................

Implementations of this SRFI are allowed to place restrictions on the
comparators that the procedures accept.  In particular, an
implementation may require comparators to provide a comparison
procedure.  Alternatively, an implementation may require comparators to
provide a hash function, unless the equality predicate of the comparator
is 'eq?', 'eqv?', 'equal?', 'string=?', or 'string-ci=?'.
Implementations must not require the provision of both a comparison
procedure and a hash function.


File: vicare-libs.info,  Node: srfi sets-and-bags constr,  Next: srfi sets-and-bags preds,  Prev: srfi sets-and-bags intro,  Up: srfi sets-and-bags

2.37.2 Constructors
-------------------

 -- Function: set COMPARATOR ELEMENT ...
 -- Function: bag COMPARATOR ELEMENT ...
     Return a newly allocated empty set.  COMPARATOR is a SRFI-114
     comparator, which is used to control and distinguish the elements
     of the set.  The ELEMENTs are used to initialize the set.

          (import (vicare) (srfi :113) (srfi :114))

          (define S
            (set fixnum-comparator 1 2 3))
          (values (set-contains? S 1)
                  (set-contains? S 2)
                  (set-contains? S 3)
                  (set-size S))
          => #t #t #t 3

          (define B
            (bag fixnum-comparator 1 2 3 2))
          (values (bag-contains? B 1)
                  (bag-contains? B 2)
                  (bag-contains? B 3)
                  (bag-size B))
          => #t #t #t 4

 -- Function: set-unfold COMPARATOR STOP? MAPPER SUCCESSOR SEED
 -- Function: bag-unfold COMPARATOR STOP? MAPPER SUCCESSOR SEED
     Create a newly allocated set as if by 'set' or 'bag' using
     COMPARATOR.  If the result of applying the predicate STOP? to SEED
     is true, return the set.  Otherwise, apply the procedure MAPPER to
     SEED.  The value that MAPPER returns is added to the set.  Then get
     a new seed by applying the procedure SUCCESSOR to SEED, and repeat
     this algorithm.

          (import (vicare) (srfi :113) (srfi :114))

          (define (stop? seed)
            (fx>? seed 3))

          (define (mapper seed)
            (number->string seed))

          (define (successor seed)
            (fxadd1 seed))

          (define S
            (set-unfold string-comparator stop? mapper successor 1))

          (values (set-contains? S "1")
                  (set-contains? S "2")
                  (set-contains? S "3")
                  (set-size S)))
          => #t #t #t 3

          (define B
            (bag-unfold string-comparator stop? mapper successor 1))

          (values (bag-contains? B "1")
                  (bag-contains? B "2")
                  (bag-contains? B "3")
                  (bag-size B)))
          => #t #t #t 3


File: vicare-libs.info,  Node: srfi sets-and-bags preds,  Next: srfi sets-and-bags access,  Prev: srfi sets-and-bags constr,  Up: srfi sets-and-bags

2.37.3 Predicates
-----------------

 -- Function: set? OBJ
 -- Function: bag? OBJ
     Return '#t' if OBJ is a set or bag; return '#f' otherwise.

 -- Function: set-contains? SET ELEMENT
 -- Function: bag-contains? BAG ELEMENT
     Return '#t' if ELEMENT is a member of SET or BAG and '#f'
     otherwise.

 -- Function: set-empty? SET
 -- Function: bag-empty? BAG
     Return '#t' if SET or BAG has no elements and '#f' otherwise.

 -- Function: set-disjoint? SET1 SET2
 -- Function: bag-disjoint? BAG1 BAG2
     Return '#t' if SET1 and SET2, or BAG1 and BAG2, have no elements in
     common; return '#f' otherwise.


File: vicare-libs.info,  Node: srfi sets-and-bags access,  Next: srfi sets-and-bags update,  Prev: srfi sets-and-bags preds,  Up: srfi sets-and-bags

2.37.4 Accessors
----------------

 -- Function: set-member SET ELEMENT DEFAULT
 -- Function: bag-member BAG ELEMENT DEFAULT
     Return the element of SET or BAG that is equal, in the sense of the
     comparator's equality predicate, to ELEMENT.  If ELEMENT is not a
     member of SET or BAG: return DEFAULT.

 -- Function: set-element-comparator SET
 -- Function: bag-element-comparator BAG
     Return the comparator used to compare the elements of SET or BAG.


File: vicare-libs.info,  Node: srfi sets-and-bags update,  Next: srfi sets-and-bags whole,  Prev: srfi sets-and-bags access,  Up: srfi sets-and-bags

2.37.5 Updaters
---------------

 -- Function: set-adjoin SET ELEMENT ...
     Return a newly allocated set that uses the same comparator as SET
     and contains all the values of SET, and in addition each ELEMENT
     unless it is already equal (in the sense of the comparator) to one
     of the existing or newly added members.

     It is an error to add an ELEMENT for which the type test procedure
     of the comparator does not return '#t'.

          (import (vicare) (srfi :113) (srfi :114))

          (internal-body
            (define S
              (set fixnum-comparator 1 2 3))
            (define S^
              (set-adjoin S 4))
            (list-sort fx<? (set->list S^)))
          => (1 2 3 4)

          (internal-body
            (define S
              (set fixnum-comparator 1 2 3))
            (define S^
              (set-adjoin S 2))
            (list-sort fx<? (set->list S^)))
          => (1 2 3)

 -- Function: bag-adjoin BAG ELEMENT ...
     Return a newly allocated bag that uses the same comparator as BAG
     and contains all the values of BAG, and in addition each ELEMENT.

     It is an error to add an ELEMENT for which the type test procedure
     of the comparator does not return '#t'.

          (import (vicare) (srfi :113) (srfi :114))

          (internal-body
            (define B
              (bag fixnum-comparator 1 2 3))
            (define B^
              (bag-adjoin B 4))
            (list-sort fx<? (bag->list B^)))
          => (1 2 3 4)

          (internal-body
            (define B
              (bag fixnum-comparator 1 2 3))
            (define B^
              (bag-adjoin B 2))
            (list-sort fx<? (bag->list B^)))
          => (1 2 2 3)

 -- Function: set-adjoin! SET ELEMENT ...
 -- Function: bag-adjoin! BAG ELEMENT ...
     Like 'set-adjoin' and 'bag-adjoin' but they are permitted to mutate
     and return SET/BAG rather than allocating a new set.

          (import (vicare) (srfi :113) (srfi :114))

          (internal-body
            (define S
              (set fixnum-comparator 1 2 3))
            (set-adjoin! S 4)
            (list-sort fx<? (set->list S)))
          => (1 2 3 4)

          (internal-body
            (define S
              (set fixnum-comparator 1 2 3))
            (set-adjoin! S 2)
            (list-sort fx<? (set->list S)))
          => (1 2 3)

          (internal-body
            (define B
              (bag fixnum-comparator 1 2 3))
            (bag-adjoin! B 4)
            (list-sort fx<? (bag->list B)))
          => (1 2 3 4)

          (internal-body
            (define B
              (bag fixnum-comparator 1 2 3))
            (bag-adjoin! B 2)
            (list-sort fx<? (bag->list B)))
          => (1 2 2 3)

 -- Function: set-replace SET ELEMENT
     Return a newly allocated set that uses the same comparator as SET
     and contains all the values of SET except that: if ELEMENT is equal
     (in the sense of SET's comparator) to an existing member of SET,
     then that member is omitted and replaced by ELEMENT.  If there is
     no such member in SET, then SET is returned unchanged.

 -- Function: bag-replace BAG ELEMENT
     Return a newly allocated bag that uses the same comparator as BAG
     and contains all the values of BAG except that: if ELEMENT is equal
     (in the sense of BAG's comparator) to an existing member of BAG,
     then that member is omitted and replaced by ELEMENT.  If there is
     no such member in BAG, then BAG is returned unchanged.

          (import (vicare) (srfi :113) (srfi :114))

          (define B  (bag real-comparator 1 2 2 3))
          (define B^ (bag-replace B 2.0))
          (list-sort < (bag->list B^)))
          => (1 2.0 2.0 3)

 -- Function: set-replace! SET ELEMENT
 -- Function: bag-replace! BAG ELEMENT
     Like 'set-replace' and 'bag-replace' but they are permitted to
     mutate and return SET or BAG rather than allocating a new set or
     bag.

 -- Function: set-delete SET ELEMENT ...
     Return a newly allocated set containing all the values of SET
     except for any that are equal (in the sense of SET's comparator) to
     one or more of the ELEMENTs.  Any ELEMENT that is not equal to some
     member of SET is ignored.

 -- Function: bag-delete BAG ELEMENT ...
     Return a newly allocated bag containing all the values of BAG
     except for any that are equal (in the sense of BAG's comparator) to
     one or more of the ELEMENTs.  Any ELEMENT that is not equal to some
     member of BAG is ignored.

          (import (vicare) (srfi :113) (srfi :114))

          (internal-body
            (define B  (bag fixnum-comparator 1 2 2 3))
            (define B^ (bag-delete B 2))
            (list-sort < (bag->list B^)))
          => (1 2 3)

          (internal-body
            (define B  (bag real-comparator 1 2 2 3))
            (define B^ (bag-delete B 2.0))
            (list-sort < (bag->list B^)))
          => (1 2 3)

 -- Function: set-delete! SET ELEMENT ...
 -- Function: bag-delete! BAG ELEMENT ...
     Like 'set-delete' and 'bag-delete' but they are permitted to mutate
     and return SET and BAG rather than allocating a new set or bag.

 -- Function: set-delete-all SET ELEMENT-LIST
 -- Function: bag-delete-all BAG ELEMENT-LIST
 -- Function: set-delete-all! SET ELEMENT-LIST
 -- Function: bag-delete-all! BAG ELEMENT-LIST
     Like 'set-delete', 'bag-delete', 'set-delete!' and 'bag-delete!'
     but accept a single argument which is a list of elements to be
     deleted.

 -- Function: set-search! SET ELEMENT FAILURE SUCCESS
 -- Function: bag-search! BAG ELEMENT FAILURE SUCCESS
     The SET or BAG is searched for ELEMENT.

        * If ELEMENT is *not* found: the procedure FAILURE is
          tail-called with two continuation arguments, INSERT and
          IGNORE, and it is expected to tail-call one of them.

        * If ELEMENT *is* found: the procedure SUCCESS is tail-called
          with the matching element of SET and two continuations, UPDATE
          and REMOVE, and it is expected to tail-call one of them.

     The effects of the continuations are as follows (where OBJ is any
     Scheme object):

        * Invoking '(INSERT OBJ)' causes ELEMENT to be inserted into SET
          or BAG.

        * Invoking '(IGNORE OBJ)' causes SET or BAG to remain unchanged.

        * Invoking '(UPDATE NEW-ELEMENT OBJ)' causes NEW-ELEMENT to be
          inserted into SET or BAG in place of ELEMENT.

        * Invoking '(REMOVE OBJ)' causes the matching element of SET or
          BAG to be removed from it.

     In all cases, two values are returned: the possibly updated SET or
     BAG and OBJ.

          (import (vicare) (srfi :113) (srfi :114))

          ;;success and update
          (internal-body
            (define S  (set real-comparator 1 2 3))
            (receive (S^ obj)
                (set-search! S 2.0
                             ;;failure proc
                             (lambda (insert ignore)
                               (error #f "wrong"))
                             ;;success proc
                             (lambda (true-element update remove)
                               (update 9 'flag)))
              (list-sort < (set->list S^))        => (1 3 9)
              obj))                               => flag

          ;;success and remove
          (internal-body
            (define S  (set real-comparator 1 2 3))
            (receive (S^ obj)
                (set-search! S 2.0
                             ;;failure proc
                             (lambda (insert ignore)
                               (error #f "wrong"))
                             ;;success proc
                             (lambda (true-element update remove)
                               (remove 'flag)))
              (list-sort < (set->list S^))        => (1 3)
              obj))                               => flag

          ;;failure and ignore
          (internal-body
            (define S  (set real-comparator 1 2 3))
            (receive (S^ obj)
                (set-search! S 99
                             ;;failure proc
                             (lambda (insert ignore)
                               (ignore 'flag))
                             ;;success proc
                             (lambda (true-element update remove)
                               (error #f "wrong")))
              (list-sort < (set->list S^))        => (1 2 3)
              obj))                               => flag

          ;;failure and insert
          (internal-body
            (define S  (set real-comparator 1 2 3))
            (receive (S^ obj)
                (set-search! S 99
                             ;;failure proc
                             (lambda (insert ignore)
                               (insert 'flag))
                             ;;success proc
                             (lambda (true-element update remove)
                               (error #f "wrong")))
              (list-sort < (set->list S^))        => (1 2 3 99)
              obj))                               => flag


File: vicare-libs.info,  Node: srfi sets-and-bags whole,  Next: srfi sets-and-bags map,  Prev: srfi sets-and-bags update,  Up: srfi sets-and-bags

2.37.6 The whole set
--------------------

 -- Function: set-size SET
 -- Function: beg-size BAG
     Return the number of elements in SET or BAG as an exact integer.

 -- Function: set-find PREDICATE SET
 -- Function: set-find PREDICATE SET FAILURE
 -- Function: bag-find PREDICATE BAG
 -- Function: bag-find PREDICATE BAG FAILURE
     Return an arbitrarily chosen element of SET or BAG that satisfies
     PREDICATE, or the result of invoking FAILURE with no arguments if
     there is none.

     As Vicare extension: when FAILURE is missing, it defaults to
     'sentinel'.

 -- Function: set-count PREDICATE SET
 -- Function: bag-count PREDICATE BAG
     Return an an exact integer representing the number of elements of
     SET or BAG that satisfy PREDICATE.

 -- Function: set-any? PREDICATE SET
 -- Function: bag-any? PREDICATE BAG
     Return '#t' if at least one element of SET or BAG satisfies
     PREDICATE; otherwise return '#f'.  If the set or bag is empty: the
     return value is '#f'.

          *NOTE* This differs from the SRFI-1 analogue because it does
          not return an element of the set.

 -- Function: set-every? PREDICATE SET
 -- Function: bag-every? PREDICATE BAG
     Return '#t' if every element of SET or BAG satisfies PREDICATE;
     otherwise return '#f'.  If the set or bag is empty: the return
     value is '#t'.

          *NOTE* This differs from the SRFI-1 analogue because it does
          not return an element of the set.


File: vicare-libs.info,  Node: srfi sets-and-bags map,  Next: srfi sets-and-bags copy,  Prev: srfi sets-and-bags whole,  Up: srfi sets-and-bags

2.37.7 Mapping and folding
--------------------------

 -- Function: set-map COMPARATOR PROC SET
     Apply PROC to each element of SET in arbitrary order and return a
     newly allocated set, created as if by '(set COMPARATOR)', which
     contains the results of the applications.  For example:

          (set-map string-ci-comparator
                   symbol->string
                   (set eq-comparator 'foo 'bar 'baz))
          == (set string-ci-comparator "foo" "bar" "baz")

     Note that, when PROC defines a mapping that is not 1:1, some of the
     mapped objects may be equivalent in the sense of comparator's
     equality predicate, and in this case duplicate elements are omitted
     as in the set constructor.  For example:

          (set-map integer-comparator
                   (lambda (x)
                     (quotient x 2))
                   (set integer-comparator 1 2 3 4 5))
          == (set integer-comparator 0 1 2)

     If the elements are the same in the sense of 'eqv?', it is
     unpredictable which one will be preserved in the result.

 -- Function: bag-map COMPARATOR PROC BAG
     Apply PROC to each element of BAG in arbitrary order and return a
     newly allocated bag, created as if by '(bag COMPARATOR)', which
     contains the results of the applications.  For example:

          (bag-map string-ci-comparator
                   symbol->string
                   (bag eq-comparator 'foo 'bar 'baz))
          == (bag string-ci-comparator "foo" "bar" "baz")

          (list-sort <
            (bag->list
              (bag-map integer-comparator
                       (lambda (x)
                         (quotient x 2))
                       (bag integer-comparator 1 2 3 4 5))))
          => (0 1 1 2 2)

 -- Function: set-for-each PROC SET
 -- Function: bag-for-each PROC BAG
     Apply PROC to SET or BAG in arbitrary order, discarding the
     returned values.  Return unspecified results.

 -- Function: set-fold PROC NIL SET
 -- Function: bag-fold PROC NIL BAG
     Invoke PROC on each member of SET or BAG in arbitrary order,
     passing the result of the previous invocation as a second argument.
     For the first invocation, NIL is used as the second argument.
     Return the result of the last invocation, or NIL if there was no
     invocation.

          (import (vicare) (srfi :113) (srfi :114))

          (list-sort <
            (set-fold (lambda (elm nil)
                        (cons elm nil))
                        '()
                        (set fixnum-comparator 1 2 3)))
          => (1 2 3)

          (list-sort <
            (bag-fold (lambda (elm nil)
                        (cons elm nil))
                      '()
                      (bag fixnum-comparator 1 2 2 3)))
          => (1 2 2 3)

 -- Function: set-filter PREDICATE SET
 -- Function: bag-filter PREDICATE BAG
     Return a newly allocated set or bag with the same comparator as SET
     or BAG, containing just the elements of SET or BAG that satisfy
     PREDICATE.

 -- Function: set-filter! PREDICATE SET
 -- Function: bag-filter! PREDICATE BAG
     Like 'set-filter' and 'bag-filter' but they are permitted to mutate
     and return SET or BAG rather than allocating a new set or bag.

 -- Function: set-remove PREDICATE SET
 -- Function: bag-remove PREDICATE BAG
     Return a newly allocated set or bag with the same comparator as SET
     or BAG, containing just the elements that do *not* satisfy
     PREDICATE.

 -- Function: set-remove! PREDICATE SET
 -- Function: bag-remove! PREDICATE BAG
     Like 'set-remove' and 'bag-remove' but they are permitted to mutate
     and return SET or BAG rather than allocating a new set or bag.

 -- Function: set-partition PREDICATE SET
 -- Function: bag-partition PREDICATE BAG
     Return two values:

       1. A newly allocated set or bag, with the same comparator as SET
          or BAG, that contains just the elements that *do* satisfy
          PREDICATE.

       2. A newly allocated set or bag, with the same comparator as SET
          or BAG, that contains just the elements that *do not* satisfy
          PREDICATE.

     Usage example:

          (import (vicare) (srfi :113) (srfi :114))

          (receive (in out)
              (set-partition (lambda (elm)
                               (<= 2 elm))
                             (set fixnum-comparator 1 2 2 3))
            (values (set->list in  #t)
                    (set->list out #t)))
          => (2 3) (1)

          (receive (in out)
              (bag-partition (lambda (elm)
                               (<= 2 elm))
                             (bag fixnum-comparator 1 2 2 3))
            (values (bag->list in  #t)
                    (bag->list out #t)))
          => (2 2 3) (1)

 -- Function: set-partition! PREDICATE SET
 -- Function: bag-partition! PREDICATE BAG
     Like 'set-partition' and 'bag-partition' but they are permitted to
     mutate and return SET or BAG rather than allocating a new set or
     bag.


File: vicare-libs.info,  Node: srfi sets-and-bags copy,  Next: srfi sets-and-bags subsets,  Prev: srfi sets-and-bags map,  Up: srfi sets-and-bags

2.37.8 Copying and conversion
-----------------------------

 -- Function: set-copy SET
 -- Function: bag-copy BAG
     Return a newly allocated set or bag containing the elements of SET
     or BAG and using the same comparator.

 -- Function: set->list SET
 -- Function: bag->list BAG
 -- Function: set->list SET COMPAR
 -- Function: bag->list BAG COMPAR
     Return a newly allocated list containing the members of SET or BAG
     in unspecified order.

     As Vicare extension, if the optional argument COMPAR is present:

        * If it is the boolean '#f': the function behaves as if COMPAR
          is not present.

        * If it is the boolean '#t': the resulting list is sorted using
          the standard 'list-sort' and the comparison procedure from the
          SET or BAG comparator, so that the lesser elements come first.

        * If it is a procedure: the resulting list is sorted using the
          standard 'list-sort' and COMPAR as comparison predicate.

     Usage examples:

          (import (vicare) (srfi :113) (srfi :114))

          (list-sort < (set->list (set fixnum-comparator 1 2 3)))
          => (1 2 3)

          (set->list (set fixnum-comparator 1 2 3) #t)
          => (1 2 3)

          (set->list (set fixnum-comparator 1 2 3) fx<?)
          => (1 2 3)

          (set->list (set fixnum-comparator 1 2 3) fx>?)
          => (3 2 1)

          ;;;

          (list-sort < (bag->list (bag fixnum-comparator 1 2 2 3)))
          => (1 2 2 3)

          (bag->list (bag fixnum-comparator 1 2 2 3) #t)
          => (1 2 2 3)

          (bag->list (bag fixnum-comparator 1 2 2 3) fx<?)
          => (1 2 2 3)

          (bag->list (bag fixnum-comparator 1 2 2 3) fx>?)
          => (3 2 2 1)

 -- Function: list->set COMPARATOR LIST
 -- Function: list->bag COMPARATOR LIST
     Return a newly allocated set or bag, created as if by 'set' or
     'bag' using COMPARATOR, that contains the elements of LIST.  When
     building a set: duplicate elements (in the sense of the equality
     predicate) are omitted.

 -- Function: list->set! SET LIST
 -- Function: list->bag! BAG LIST
     Return a set or bag that contains the elements of both SET or BAG
     and LIST, using the comparator of SET or BAG.  The functions are
     permitted to mutate SET or BAG and return it.  When building a set:
     duplicate elements (in the sense of the equality predicate) are
     omitted.


File: vicare-libs.info,  Node: srfi sets-and-bags subsets,  Next: srfi sets-and-bags theory,  Prev: srfi sets-and-bags copy,  Up: srfi sets-and-bags

2.37.9 Subsets
--------------

     *NOTE* The following three predicates do not obey the trichotomy
     law and therefore do not constitute a total order on sets.

 -- Function: set=? SET0 SET ...
 -- Function: bag=? BAG0 BAG ...
     Return '#t' if each SET or BAG contains the same elements.

          (import (vicare) (srfi :113) (srfi :114))

          (bag=? (bag fixnum-comparator 1 2 2 3)
                 (bag fixnum-comparator 1 2 2 3))
          => #t

          (bag=? (bag fixnum-comparator 1 2 3)
                 (bag fixnum-comparator 1 2 2 3))
          => #f

 -- Function: set<? SET0 SET ...
 -- Function: bag<? BAG0 BAG ...
     Return '#t' if each SET or BAG, other than the last, is a proper
     subset of the following SET or BAG; return '#f' otherwise.

          (import (vicare) (srfi :113) (srfi :114))

          (bag<? (bag fixnum-comparator 1 2 3)
                 (bag fixnum-comparator 1 2 2 3))
          => #t

          (bag<? (bag fixnum-comparator 1 2 2 3)
                 (bag fixnum-comparator 1 2 3))
          => #f

 -- Function: set>? SET0 SET ...
 -- Function: bag>? BAG0 BAG ...
     Return '#t' if each SET or BAG, other than the last, is a proper
     superset of the following SET or BAG; return '#f' otherwise.

          (import (vicare) (srfi :113) (srfi :114))

          (bag>? (bag fixnum-comparator 1 2 3)
                 (bag fixnum-comparator 1 2 2 3))
          => #f

          (bag>? (bag fixnum-comparator 1 2 2 3)
                 (bag fixnum-comparator 1 2 3))
          => #t

 -- Function: set<=? SET0 SET ...
 -- Function: bag<=? BAG0 BAG ...
     Return '#t' if each SET or BAG, other than the last, is a subset of
     the following SET or BAG; return '#f' otherwise.

          (import (vicare) (srfi :113) (srfi :114))

          (bag<=? (bag fixnum-comparator 1 2 3)
                  (bag fixnum-comparator 1 2 2 3))
          => #t

          (bag<=? (bag fixnum-comparator 1 2 2 3)
                  (bag fixnum-comparator 1 2 3))
          => #f

 -- Function: set>=? SET0 SET ...
 -- Function: bag>=? BAG0 BAG ...
     Return '#t' if each SET or BAG, other than the last, is a superset
     of the following SET or BAG; return '#f' otherwise.

          (import (vicare) (srfi :113) (srfi :114))

          (bag>=? (bag fixnum-comparator 1 2 3)
                  (bag fixnum-comparator 1 2 2 3))
          => #f

          (bag>=? (bag fixnum-comparator 1 2 2 3)
                  (bag fixnum-comparator 1 2 3))
          => #t


File: vicare-libs.info,  Node: srfi sets-and-bags theory,  Next: srfi sets-and-bags bag,  Prev: srfi sets-and-bags subsets,  Up: srfi sets-and-bags

2.37.10 Set theory operations
-----------------------------

 -- Function: set-union SET0 SET ...
 -- Function: set-intersection SET0 SET ...
 -- Function: set-difference SET0 SET ...
 -- Function: set-xor SET1 SET2
     Return a newly allocated set that is the union, intersection,
     asymmetric difference, or symmetric difference of the SET
     arguments.

     Asymmetric difference is extended to more than two sets by taking
     the difference between the first set and the union of the others.
     Symmetric difference is not extended beyond two sets.  Elements in
     the result set are drawn from the first set in which they appear.

          (import (vicare) (srfi :113) (srfi :114))

          (let* ((S1 (set fixnum-comparator 1 2))
                 (S2 (set fixnum-comparator 2 3))
                 (S  (set-difference S1 S2)))
            (set->list S #t))
          => (1)

 -- Function: set-union! SET0 SET ...
 -- Function: set-intersection! SET0 SET ...
 -- Function: set-difference! SET0 SET ...
 -- Function: set-xor! SET1 SET2
     Like 'set-union!', 'set-intersection!', 'set-difference!',
     'set-xor!' but they are allowed to mutate SET0 and return it.

 -- Function: bag-union BAG0 BAG ...
 -- Function: bag-intersection BAG0 BAG ...
 -- Function: bag-difference BAG0 BAG ...
 -- Function: bag-xor BAG1 BAG2
     Return a newly allocated bag that is the union, intersection,
     asymmetric difference, or symmetric difference of the BAG
     arguments.

     Asymmetric difference is extended to more than two bags by taking
     the difference between the first bag and the union of the others.
     Symmetric difference is not extended beyond two bags.  Elements in
     the result bag are drawn from the first bag in which they appear.

     The procedures behave as follows when both bags contain elements
     that are equal in the sense of the bags' comparator:

     'bag-union'
          The number of equal elements in the result is the largest
          number of equal elements in any of the original bags.

     'bag-intersection'
          The number of equal elements in the result is the smallest
          number of equal elements in any of the original bags.

     'bag-difference'
          The number of equal elements in the result is the number of
          equal elements in the first bag, minus the number of elements
          in the other bags (but not less than zero).

     'bag-xor'
          The number of equal elements in the result is the absolute
          value of the difference between the number of equal elements
          in the first and second bags.

 -- Function: bag-union! BAG0 BAG ...
 -- Function: bag-intersection! BAG0 BAG ...
 -- Function: bag-difference! BAG0 BAG ...
 -- Function: bag-xor! BAG1 BAG2
     Like 'bag-union!', 'bag-intersection!', 'bag-difference!',
     'bag-xor!' but they are allowed to mutate BAG0 and return it.


File: vicare-libs.info,  Node: srfi sets-and-bags bag,  Next: srfi sets-and-bags compar,  Prev: srfi sets-and-bags theory,  Up: srfi sets-and-bags

2.37.11 Bag-only procedures
---------------------------

 -- Function: bag-sum BAG0 BAG ...
     Return a newly allocated bag containing all the unique elements in
     all the BAG arguments, such that the count of each unique element
     in the result is equal to the sum of the counts of that element in
     the arguments.  It differs from 'bag-union' by treating identical
     elements as potentially distinct rather than attempting to match
     them up.
          (import (vicare) (srfi :113) (srfi :114))

          (let* ((B1 (bag fixnum-comparator 1 2))
                 (B2 (bag fixnum-comparator 2 3))
                 (B3 (bag fixnum-comparator 3 4))
                 (B  (bag-sum B1 B2 B3)))
            (bag->list B #t))
          => (1 2 2 3 3 4)

 -- Function: bag-sum! BAG0 BAG ...
     Like 'bag-sum' but it is permitted to mutate and return BAG0 rather
     than allocating a new set.

 -- Function: bag-product N BAG
     Return a newly allocated bag containing all the unique elements in
     BAG, where the count of each unique element in the bag is equal to
     the count of that element in BAG multiplied by N.

          (import (vicare) (srfi :113) (srfi :114))

          (let* ((B1 (bag fixnum-comparator 1 2))
                 (B  (bag-product 0 B1)))
            (bag->list B #t))
          => ()

          (let* ((B1 (bag fixnum-comparator))
                 (B  (bag-product 2 B1)))
            (bag->list B #t))
          => ()

          (let* ((B1 (bag fixnum-comparator 1 2))
                 (B  (bag-product 3 B1)))
            (bag->list B #t))
          => (1 1 1 2 2 2)

 -- Function: bag-product! N BAG
     Like 'bag-product' but it is permitted to mutate and return BAG
     rather than allocating a new set.

 -- Function: bag-unique-size BAG
     Return the number of unique elements of BAG.

 -- Function: bag-element-count BAG ELEMENT
     Return an exact integer representing the number of times that
     ELEMENT appears in BAG.

 -- Function: bag-for-each-unique PROC BAG
     Apply PROC to each unique element of BAG in arbitrary order,
     passing the element and the number of times it occurs in BAG, and
     discarding the returned values.  Return an unspecified result.

 -- Function: bag-fold-unique PROC NIL BAG
     Invoke PROC on each unique element of BAG in arbitrary order,
     passing the number of occurrences as a second argument and the
     result of the previous invocation as a third argument.  For the
     first invocation: NIL is used as the third argument.  Return the
     result of the last invocation.

          (import (vicare) (srfi :113) (srfi :114))

          (let ((B (bag fixnum-comparator)))
            (bag-fold-unique (lambda (elm count knil)
                               (cons (list elm count) knil))
              '()
              B))
          => '()

          (let ((B (bag fixnum-comparator 1 2 3)))
            (bag-fold-unique (lambda (elm count knil)
                               (cons (list elm count) knil))
              '()
              B))
          => ((1 1) (2 1) (3 1))

 -- Function: bag-increment! BAG ELEMENT COUNT
 -- Function: bag-decrement! BAG ELEMENT COUNT
     Linear update procedures that return a bag with the same elements
     as BAG, but with the element count of ELEMENT in bag increased or
     decreased by the exact integer COUNT (but not less than zero).

 -- Function: bag->set BAG
     Return a newly allocated set containing the unique elements (in the
     sense of the equality predicate) of BAG.

 -- Function: set->bag SET
     Return a newly allocated bag containing the elements of SET.

 -- Function: set->bag! BAG SET
     return a bag containing the elements of both BAG and SET.  In all
     cases, the comparator of the result is the same as the comparator
     of the argument or arguments.

 -- Function: bag->alist BAG
 -- Function: bag->alist BAG COMPAR
     Return a newly allocated alist whose keys are the unique elements
     of BAG and whose values are the number of occurrences of each
     element.

     As Vicare extension, if the optional argument COMPAR is present:

        * If it is the boolean '#f': the function behaves as if COMPAR
          is not present.

        * If it is the boolean '#t': the resulting alist is sorted using
          the standard 'list-sort' and the comparison procedure from the
          SET or BAG comparator, so that the pairs with lesser cars come
          first.

        * If it is a procedure: the resulting list is sorted using the
          standard 'list-sort' and COMPAR as comparison predicate, so
          that the pairs with lesser cars come first.

     Usage examples:

          (import (vicare) (srfi :113) (srfi :114))

          (let ((B (bag fixnum-comparator 1 2 3)))
            (bag->alist B #t))
          => ((1 . 1) (2 . 1) (3 . 1))

          (let ((B (bag fixnum-comparator 1 1 2 2 3 3)))
            (bag->alist B fx<?))
          => ((1 . 2) (2 . 2) (3 . 2))

 -- Function: alist->bag COMPARATOR ALIST
     Return a newly allocated bag based on COMPARATOR, where the keys of
     ALIST specify the elements and the corresponding values of ALIST
     specify how many times they occur.

          (import (vicare) (srfi :113) (srfi :114))

          (let ((B (alist->bag fixnum-comparator '())))
            (bag->alist B))
          => ()

          (let ((B (alist->bag fixnum-comparator
                     '((1 . 1) (2 . 1) (3 . 1)))))
            (bag->alist B #t))
          => ((1 . 1) (2 . 1) (3 . 1))

          (let ((B (alist->bag fixnum-comparator
                     '((1 . 2) (2 . 2) (3 . 2)))))
            (bag->alist B fx<?))
          => ((1 . 2) (2 . 2) (3 . 2))


File: vicare-libs.info,  Node: srfi sets-and-bags compar,  Next: srfi sets-and-bags copyright,  Prev: srfi sets-and-bags bag,  Up: srfi sets-and-bags

2.37.12 Comparators
-------------------

 -- Function: set-comparator
 -- Function: bag-comparator
     Comparators used to compare sets or bags, and allow sets of sets,
     bags of sets, etc.  These comparators do not provide comparison
     procedures, as there is no ordering between sets or bags.  It is an
     error to compare sets or bags with different element comparators.

          (import (vicare) (srfi :113) (srfi :114))

          (let ((S1 (set fixnum-comparator 1 2 3))
                (S2 (set fixnum-comparator 1 2 3)))
            (comparator-equal? set-comparator S1 S2))
          => #t

          (let ((S1 (set fixnum-comparator 1 2 3))
                (S2 (set fixnum-comparator 1 2 3 4)))
            (comparator-equal? set-comparator S1 S2))
          => #f

          (let ((S (set fixnum-comparator 1 2 3)))
            (non-negative-exact-integer?
              (comparator-hash set-comparator S)))
          => #t

          ;;;

          (let ((B1 (bag fixnum-comparator 1 2 3))
                (B2 (bag fixnum-comparator 1 2 3)))
            (comparator-equal? bag-comparator B1 B2))
          => #t

          (let ((B1 (bag fixnum-comparator 1 2 3))
                (B2 (bag fixnum-comparator 1 2 3 4)))
            (comparator-equal? bag-comparator B1 B2))
          => #f

          (let ((B (bag fixnum-comparator 1 2 3)))
            (non-negative-exact-integer?
              (comparator-hash bag-comparator B)))
          => #t


File: vicare-libs.info,  Node: srfi sets-and-bags copyright,  Prev: srfi sets-and-bags compar,  Up: srfi sets-and-bags

2.37.13 Copyright
-----------------

Copyright (C) John Cowan 2013.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi comparators,  Next: srfi regexps,  Prev: srfi sets-and-bags,  Up: srfi

2.38 SRFI-114 comparators
=========================

The libraries '(srfi :114)' and '(srfi :114 comparators)' are derived
from the reference implementation of SRFI-114 by John Cowan; see:

           <http://srfi.schemers.org/srfi-114/srfi-114.html>

for more details.  '(srfi :114)' and '(srfi :114 comparators)' export
the same bindings.

* Menu:

* srfi comparators abstract::     Abstract.
* srfi comparators rationale::    Rationale.
* srfi comparators definitions::  Definitions.
* srfi comparators limitations::  Limitations.
* srfi comparators predicates::   Predicates.
* srfi comparators standard::     Standard comparators.
* srfi comparators default::      The default comparator.
* srfi comparators constructors:: Comparator constructors.
* srfi comparators wrapped::      Wrapped equality predicates.
* srfi comparators accessors::    Accessors.
* srfi comparators applicators::  Primitive applicators.
* srfi comparators compar proc::  Comparison procedure constructors.
* srfi comparators syntax::       Comparison syntax.
* srfi comparators compar pred::  Comparison predicates and predicate
                                  constructors.
* srfi comparators ternary::      Interval comparison predicates.
* srfi comparators minmax::       Min/max comparison procedures.
* srfi comparators misc::         Miscellaneous procedures.
* srfi comparators conditions::   Condition object types.
* srfi comparators copyright::    Copyright.


File: vicare-libs.info,  Node: srfi comparators abstract,  Next: srfi comparators rationale,  Up: srfi comparators

2.38.1 Abstract
---------------

This proposal is a rewrite of SRFI-67, Compare Procedures, extending it
from procedures that represent a total order to procedure bundles that
represent one or more of a total order, an equality predicate, and a
hash function.  By packaging these procedures together, along with a
type test predicate, they can be treated as a single item for use in the
implementation of data structures.


File: vicare-libs.info,  Node: srfi comparators rationale,  Next: srfi comparators definitions,  Prev: srfi comparators abstract,  Up: srfi comparators

2.38.2 Rationale
----------------

The four procedures above have complex dependencies on one another, and
it is inconvenient to have to pass them all to other procedures that
might or might not make use of all of them.  For example, a set
implementation naturally requires only an equality predicate, but if it
is implemented using a hash table, an appropriate hash function is also
required if the implementation does not provide one; alternatively, if
it is implemented using a tree, a comparison procedure is required.  By
passing a comparator rather than a bare equality predicate, the set
implementation can make use of whatever procedures are available and
useful to it.

   This SRFI could not have been written without the work of Sebastian
Egner and Jens Axel Soegaard on SRFI-67; much of the credit for this
SRFI is due to them, but none of the blame.  In addition, many of the
design decisions of this SRFI are copied from SRFI-67's design
rationale.


File: vicare-libs.info,  Node: srfi comparators definitions,  Next: srfi comparators limitations,  Prev: srfi comparators rationale,  Up: srfi comparators

2.38.3 Definitions
------------------

A comparator is an object of a disjoint type.  It is a bundle of
procedures that are useful for comparing two objects either for equality
or for ordering.  There are four procedures in the bundle:

*Type test predicate*
     It returns '#t' if its argument has the correct type to be passed
     as an argument to the other three procedures, and '#f' otherwise.

*Equality predicate*
     It returns '#t' if the two objects are the same in the sense of the
     comparator, and '#f' otherwise.  It is the programmer's
     responsibility to ensure that it is reflexive, symmetric,
     transitive, and can handle any arguments that satisfy the type test
     predicate.

*Comparison procedure*
     It returns '-1', '0', or '+1' if the first object precedes the
     second, is equal to the second, or follows the second,
     respectively, in a total order defined by the comparator.  It is
     the programmer's responsibility to ensure that it is reflexive,
     weakly antisymmetric, transitive, can handle any arguments that
     satisfy the type test predicate, and returns '0' if and only if the
     equality predicate returns '#t'.  Comparison procedures are
     compatible with the _compare procedures_ of SRFI-67; see SRFI-67
     for the rationale for adopting this return convention.

*Hash function*
     It takes one argument, and returns an exact non-negative integer.
     It is the programmer's responsibility to ensure that it can handle
     any argument that satisfies the type test predicate, and that it
     returns the same value on two objects if the equality predicate
     says they are the same (but not necessarily the converse).

   It is also the programmer's responsibility to ensure that all four
procedures provide the same result whenever they are applied to the same
object(s) (in the sense of 'eqv?'), unless the object(s) have been
mutated since the last invocation.  In particular, they must not depend
in any way on memory addresses in implementations where the garbage
collector can move objects in memory.


File: vicare-libs.info,  Node: srfi comparators limitations,  Next: srfi comparators predicates,  Prev: srfi comparators definitions,  Up: srfi comparators

2.38.4 Limitations
------------------

The comparator objects defined in this SRFI are not applicable to
circular structures or to NaNs or objects containing them.  Attempts to
pass any such objects to any procedure defined here, or to any procedure
that is part of a comparator defined here, is an error except as
otherwise noted.


File: vicare-libs.info,  Node: srfi comparators predicates,  Next: srfi comparators standard,  Prev: srfi comparators limitations,  Up: srfi comparators

2.38.5 Predicates
-----------------

 -- Function: comparator? OBJ
     Return '#t' if OBJ is a comparator; return '#f' otherwise.

 -- Function: comparator-comparison-procedure? COMPARATOR
     Return '#t' if COMPARATOR has a supplied comparison procedure;
     return '#f' otherwise.

 -- Function: comparator-hash-function? COMPARATOR
     Return '#t' if COMPARATOR has a supplied hash function; return '#f'
     otherwise.


File: vicare-libs.info,  Node: srfi comparators standard,  Next: srfi comparators default,  Prev: srfi comparators predicates,  Up: srfi comparators

2.38.6 Standard comparators
---------------------------

The following comparators are analogous to the standard compare
procedures of SRFI-67.  They all provide appropriate hash functions as
well.

 -- Constant: boolean-comparator
     Compare booleans using the total order '#f < #t'.

          (import (vicare) (srfi :114))

          (define C boolean-comparator)

          (comparator-test-type C #f)     => #t
          (comparator-test-type C #t)     => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C #f)    => #t
          (comparator-check-type C #t)    => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C #f #f)     => #t
          (comparator-equal? C #f #t)     => #f

          (comparator-compare C #f #f)    => 0
          (comparator-compare C #f #t)    => -1
          (comparator-compare C #t #f)    => +1

 -- Constant: char-comparator
     Compare characters using the total order implied by 'char<?'.  On
     R6RS and R7RS systems, this is Unicode code point order.

          (import (vicare) (srfi :114))

          (define C char-comparator)

          (comparator-test-type C #\a)    => #t
          (comparator-test-type C #\b)    => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C #\a)   => #t
          (comparator-check-type C #\b)   => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C #\a #\a)   => #t
          (comparator-equal? C #\a #\b)   => #f

          (comparator-compare C #\a #\a)  => 0
          (comparator-compare C #\a #\b)  => -1
          (comparator-compare C #\b #\a)  => +1

          (comparator-hash C #\a)         => 97
          (comparator-hash C #\b)         => 98

 -- Constant: char-ci-comparator
     Compare characters using the total order implied by 'char-ci<?'.
     On R6RS and R7RS systems, this is Unicode code point order after
     the characters have been folded to lower case.

          (import (vicare) (srfi :114))

          (define C char-ci-comparator)

          (comparator-test-type C #\A)    => #t
          (comparator-test-type C #\b)    => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C #\A)   => #t
          (comparator-check-type C #\b)   => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C #\A #\A)   => #t
          (comparator-equal? C #\A #\b)   => #f

          (comparator-compare C #\A #\A)  => 0
          (comparator-compare C #\A #\b)  => -1
          (comparator-compare C #\b #\A)  => +1

          (comparator-hash C #\A)         => 97
          (comparator-hash C #\b)         => 98

 -- Constant: string-comparator
     Compare strings using the total order implied by 'string<?'.  Note
     that this order is implementation-dependent.

          (import (vicare) (srfi :114))

          (define C string-comparator)

          (comparator-test-type C "a")    => #t
          (comparator-test-type C "b")    => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C "a")   => #t
          (comparator-check-type C "b")   => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C "a" "a")   => #t
          (comparator-equal? C "a" "b")   => #f

          (comparator-compare C "a" "a")  => 0
          (comparator-compare C "a" "b")  => -1
          (comparator-compare C "b" "a")  => +1

          (comparator-hash C "a")         => 1798195
          (comparator-hash C "b")         => 36222037

 -- Constant: string-ci-comparator
     Compare strings using the total order implied by 'string-ci<?'.
     Note that this order is implementation-dependent.

          (import (vicare) (srfi :114))

          (define C string-ci-comparator)

          (comparator-test-type C "A")    => #t
          (comparator-test-type C "b")    => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C "A")   => #t
          (comparator-check-type C "b")   => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C "A" "A")   => #t
          (comparator-equal? C "A" "b")   => #f

          (comparator-compare C "A" "A")  => 0
          (comparator-compare C "A" "b")  => -1
          (comparator-compare C "b" "A")  => +1

          (comparator-hash C "A")         => 1798195
          (comparator-hash C "b")         => 36222037

 -- Constant: symbol-comparator
     Compare symbols using the total order implied by applying
     'symbol->string' to the symbols and comparing them using the total
     order implied by 'string<?'.  It is not a requirement that the hash
     function of 'symbol-comparator' be consistent with the hash
     function of 'string-comparator'.

          (import (vicare) (srfi :114))

          (define C string-comparator)

          (comparator-test-type C 'a)     => #t
          (comparator-test-type C 'b)     => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C 'a)    => #t
          (comparator-check-type C 'b)    => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C 'a 'a)     => #t
          (comparator-equal? C 'a 'b)     => #f

          (comparator-compare C 'a 'a)    => 0
          (comparator-compare C 'a 'b)    => -1
          (comparator-compare C 'b 'a)    => +1

          (comparator-hash C 'a)          => 1798195
          (comparator-hash C 'b)          => 36222037

 -- Constant: fixnum-comparator
 -- Constant: exact-integer-comparator
 -- Constant: integer-comparator
 -- Constant: rational-comparator
 -- Constant: real-comparator
 -- Constant: complex-comparator
 -- Constant: number-comparator
     These comparators compare fixnums, exact integers, integers,
     rational numbers, real numbers, complex numbers, and any numbers
     using the total order implied by '<'.

     They must be compatible with the R5RS numerical tower in the
     following sense: if 'S' is a subtype of the numerical type 'T' and
     the two objects are members of 'S', then the equality predicate and
     comparison procedures (but not necessarily the hash function) of
     'S-comparator' and 'T-comparator' compute the same results on those
     objects.

     Since non-real numbers cannot be compared with '<', the following
     least-surprising ordering is defined: if the real parts are '<' or
     '>', so are the numbers; otherwise, the numbers are ordered by
     their imaginary parts.  This can still produce surprising results
     if one real part is exact and the other is inexact.

     'fixnum-comparator' is a Vicare extension.

          (import (vicare) (srfi :114))

          (define C exact-integer-comparator)

          (comparator-test-type C 1)      => #t
          (comparator-test-type C 2)      => #t
          (comparator-test-type C 123)    => #f

          (comparator-check-type C 1)     => #t
          (comparator-check-type C 2)     => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C 1 1)       => #t
          (comparator-equal? C 1 2)       => #f

          (comparator-compare C 1 1)      => 0
          (comparator-compare C 1 2)      => -1
          (comparator-compare C 2 1)      => +1

          (comparator-hash C 1)           => 1
          (comparator-hash C 2)           => 2

 -- Constant: pair-comparator
     Compare pairs using 'default-comparator' on their cars.  If the
     cars are not equal, that value is returned.  If they are equal,
     'default-comparator' is used on their cdrs and that value is
     returned.

          (import (vicare) (srfi :114))

          (define C pair-comparator)

          (comparator-test-type C '(1 . 2))       => #t
          (comparator-test-type C '(3 . 4))       => #t
          (comparator-test-type C 123)            => #f

          (comparator-check-type C '(1 . 2))      => #t
          (comparator-check-type C '(3 . 4))      => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C '(1 . 2) '(1 . 2)) => #t
          (comparator-equal? C '(1 . 2) '(3 . 4)) => #f

          (comparator-compare C '(1 . 2) '(1 . 2)) => 0
          (comparator-compare C '(1 . 2) '(3 . 4)) => -1
          (comparator-compare C '(3 . 4) '(1 . 2)) => +1

          (comparator-hash C '(1 . 2))            => 3
          (comparator-hash C '(3 . 4))            => 7

 -- Constant: list-comparator
     Compare lists lexicographically, as follows:

        * The empty list compares equal to itself.

        * The empty list compares less than any non-empty list.

        * Two non-empty lists are compared by comparing their cars.  If
          the cars are not equal when compared using
          'default-comparator' , then the result is the result of that
          comparison.  Otherwise, the cdrs are compared using
          'list-comparator'.

          (import (vicare) (srfi :114))

          (define C list-comparator)

          (comparator-test-type C '(1 2))         => #t
          (comparator-test-type C '(3 4))         => #t
          (comparator-test-type C 123)            => #f

          (comparator-check-type C '(1 2))        => #t
          (comparator-check-type C '(3 4))        => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C '(1 2) '(1 2))     => #t
          (comparator-equal? C '(1 2) '(3 4))     => #f

          (comparator-compare C '(1 2) '(1 2))    => 0
          (comparator-compare C '(1 2) '(3 4))    => -1
          (comparator-compare C '(3 4) '(1 2))    => +1

          (comparator-hash C '(1 2))              => 617064
          (comparator-hash C '(3 4))              => 617132

 -- Constant: vector-comparator
 -- Constant: bytevector-comparator
     Compare vectors and bytevectors by comparing their lengths.  A
     shorter argument is always less than a longer one.  If the lengths
     are equal, then each element is compared in turn using
     'default-comparator' until a pair of unequal elements is found, in
     which case the result is the result of that comparison.  If all
     elements are equal, the arguments are equal.

          *NOTE* Vicare supports bytevectors, other Scheme
          implementations might not support them.  If the implementation
          does not support bytevectors, 'bytevector-comparator' has a
          type testing procedure that always returns '#f'.

          (import (vicare) (srfi :114))

          (define C vector-comparator)

          (comparator-test-type C '#(1 2))        => #t
          (comparator-test-type C '#(3 4))        => #t
          (comparator-test-type C 123)            => #f

          (comparator-check-type C '#(1 2))       => #t
          (comparator-check-type C '#(3 4))       => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)   #t)
              (else                       #f)))
          => #t

          (comparator-equal? C '#(1 2) '#(1 2))   => #t
          (comparator-equal? C '#(1 2) '#(3 4))   => #f

          (comparator-compare C '#(1 2) '#(1 2))  => 0
          (comparator-compare C '#(1 2) '#(3 4))  => -1
          (comparator-compare C '#(3 4) '#(1 2))  => +1

          (comparator-hash C '#(1 2))             => 177575
          (comparator-hash C '#(3 4))             => 177577


File: vicare-libs.info,  Node: srfi comparators default,  Next: srfi comparators constructors,  Prev: srfi comparators standard,  Up: srfi comparators

2.38.7 The default comparator
-----------------------------

 -- Function: default-comparator
     This is a comparator that accepts any two Scheme values (with the
     exceptions listed in the "Limitations" section, *note srfi
     comparators limitations::) and orders them in some
     implementation-defined way, subject to the following conditions:

        * The following ordering between types must hold:

            1. the empty list precedes pairs, with proper lists
               preceding improper lists,

            2. which precede booleans,

            3. which precede characters,

            4. which precede strings,

            5. which precede symbols,

            6. which precede numbers,

            7. which precede vectors,

            8. which precede bytevectors,

            9. which precede the '(void)' object (this is a Vicare
               extension),

            10. which precede the '(eof-object)' object (this is a
               Vicare extension),

            11. which precede the '(would-block-object)' object (this is
               a Vicare extension),

            12. which precede the Vicare struct objects and R6RS record
               objects (this is a Vicare extension),

            13. which precede all other objects.

          this ordering is compatible with SRFI-67.

        * When applied to pairs, booleans, characters, strings, symbols,
          numbers, vectors, or bytevectors, its behaviour must be the
          same as 'pair-comparator', 'boolean-comparator',
          'character-comparator', 'string-comparator',
          'symbol-comparator', 'number-comparator', 'vector-comparator',
          and 'bytevector-comparator' respectively.  The same should be
          true when applied to an object or objects of a type for which
          a standard comparator is defined elsewhere.

        * Given disjoint types 'A' and 'B', one of three conditions must
          hold:

             - All objects of type 'A' compare less than all objects of
               type 'B'.

             - All objects of type 'A' compare greater than all objects
               of type 'B'.

             - All objects of either type 'A' or type 'B' compare equal
               to each other.  This is not permitted for any of the
               standard types mentioned above.

 -- Function: comparator-register-default! COMPARATOR
     Register a new COMPARATOR for use by the default comparator.

     Extent the default comparator to understand objects that satisfy
     the type test of the registered COMPARATOR, and to apply it when
     comparing two objects that satisfy that type test.  Such objects
     are said to belong to the "registered types", whereas all the
     objects other than the ones supported by default belong to the
     "unregistered types".  When dealing with objects of unregistered
     types, the default comparator makes them compare equal and hash to
     '0', a safe but fairly useless default.

     The effect of comparing two objects of different registered types
     is only partly predictable, as it depends on the order in which
     'comparator-register-default!' is called.  However, the normal
     guarantees of the default comparator still apply.  In addition,
     every object of a registered type compares less than all objects of
     unregistered types.

   Here is an example of registering comparators for Vicare structs and
R6RS records (notice that 'struct-hash' and 'record-hash' are very poor
hash functions):

     (import (vicare)
       (srfi :114))

     (define C default-comparator)

     (define-struct a-struct
       (a b c))

     (define-record-type a-record
       (fields a b c))

     (define (a-struct-comparison a b)
       (cond ((struct=? a b)
              0)
             ((< (a-struct-a a)
                 (a-struct-a b))
              -1)
             (else +1)))

     (define (a-record-comparison a b)
       (cond ((record=? a b)
              0)
             ((< (a-record-a a)
                 (a-record-a b))
              -1)
             (else +1)))

     (define a-struct-comparator
       (make-comparator a-struct?
                        struct=?
                        a-struct-comparison
                        struct-hash))

     (define a-record-comparator
       (make-comparator a-record?
                        record=?
                        a-record-comparison
                        record-hash))

     (comparator-register-default! a-struct-comparator)
     (comparator-register-default! a-record-comparator)

     ;;; type test

     (comparator-test-type C (make-a-struct 1 2 3))  => #t
     (comparator-test-type C (make-a-record 1 2 3))  => #t

     ;;; type check

     (comparator-check-type C (make-a-struct 1 2 3)) => #t
     (comparator-check-type C (make-a-record 1 2 3)) => #t

     ;;; equality

     (let ((P (make-a-struct 1 2 3))
           (Q (make-a-struct 1 2 3))
           (R (make-a-struct 1 2 9)))
       (comparator-equal? C P P)     => #t
       (comparator-equal? C P Q)     => #t
       (comparator-equal? C P R))    => #f

     (let ((P (make-a-record 1 2 3))
           (Q (make-a-record 1 2 3))
           (R (make-a-record 1 2 9)))
       (comparator-equal? C P P)     => #t
       (comparator-equal? C P Q)     => #t
       (comparator-equal? C P R))    => #f

     ;;; comparison

     (let ((P (make-a-struct +1 2 3))
           (Q (make-a-struct -1 2 3))
           (R (make-a-struct +2 2 9)))
       (comparator-compare C P P)   => 0
       (comparator-compare C P Q)   => +1
       (comparator-compare C P R))  => -1

     (let ((P (make-a-record +1 2 3))
           (Q (make-a-record -1 2 3))
           (R (make-a-record +2 2 9)))
       (comparator-compare C P P)   => 0
       (comparator-compare C P Q)   => +1
       (comparator-compare C P R))  => -1

     ;;; hash function

     (comparator-hash C (make-a-struct 1 2 3))
     => 1

     (comparator-hash C (make-a-record 1 2 3))
     => 1


File: vicare-libs.info,  Node: srfi comparators constructors,  Next: srfi comparators wrapped,  Prev: srfi comparators default,  Up: srfi comparators

2.38.8 Comparator constructors
------------------------------

Most of the following comparator constructors are close analogues of the
standard compare procedures of SRFI-67.  They all provide appropriate
hash functions as well.  Note that comparator constructors are allowed
to cache their results: they need not return a newly allocated object,
since comparators are purely functional.

* Menu:

* srfi comparators constructors general::  General comparators.
* srfi comparators constructors real::     Inexact real comparators.
* srfi comparators constructors pair::     Pair comparators.
* srfi comparators constructors list::     List comparators.
* srfi comparators constructors vector::   Vector comparators.
* srfi comparators constructors bytevec::  Bytevector comparators.
* srfi comparators constructors select::   Selecting comparators.
* srfi comparators constructors refine::   Refining comparators.
* srfi comparators constructors reverse::  Reverse comparators.
* srfi comparators constructors debug::    Debug comparators.


File: vicare-libs.info,  Node: srfi comparators constructors general,  Next: srfi comparators constructors real,  Up: srfi comparators constructors

2.38.8.1 General comparators
............................

 -- Function: make-comparator TYPE-TEST EQUALITY COMPARE HASH
     Return a comparator which bundles the TYPE-TEST, EQUALITY, COMPARE,
     and HASH procedures provided.  As a convenience, the following
     additional values are accepted:

        * If TYPE-TEST is '#t': a TYPE-TEST procedure that accepts any
          arguments is provided.

        * If EQUALITY is '#t': an EQUALITY predicate is provided that
          returns '#t' if and only if COMPARE returns '0'.

        * If COMPARE or HASH is '#f', a procedure is provided that
          signals an error on application.  The predicates
          'comparator-comparison-procedure?' and/or
          'comparator-hash-function?', respectively, will return '#f' in
          these cases.


File: vicare-libs.info,  Node: srfi comparators constructors real,  Next: srfi comparators constructors pair,  Prev: srfi comparators constructors general,  Up: srfi comparators constructors

2.38.8.2 Inexact real comparators
.................................

 -- Function: make-inexact-real-comparator EPSILON ROUNDING NAN-HANDLING
     Return a comparator that compares inexact real numbers including
     NaNs as follows: if after rounding to the nearest EPSILON they are
     the same, they compare equal; otherwise they compare as specified
     by '<'.

     The direction of rounding is specified by the ROUNDING argument,
     which is either a procedure accepting two arguments (the number and
     EPSILON), or else one of the symbols 'floor', 'ceiling',
     'truncate', or 'round'.

     The value of EPSILON is used by the generated comparator only if
     ROUNDING is a procedure: it is ignored if ROUNDING is a symbol.
     When EPSILON is not '#f' and ROUNDING is a symbol: this function
     raises a *continuable* exception with compound condition object of
     types: '&inexact-real-comparator-with-unused-epsilon', '&who',
     '&message', '&irritants'.

     The argument NAN-HANDLING specifies how to compare NaN arguments to
     non-NaN arguments.

        * If it is a procedure: the procedure is invoked on the other
          argument if either argument is a NaN.

        * If it is the symbol 'min': NaN values precede all other
          values.

        * If it is the symbol 'max': NaN values follow all other values.

        * If it is the symbol 'error': an error is signalled if a NaN
          value is compared by raising a non-continuable exception with
          compound condition object of types: '&who', '&message',
          '&irritants', '&comparator-nan-comparison-error'.

        * If both arguments are NaNs: they always compare as equal.

   Here is an example of comparator using the 'round' rounding mode and
the 'error' policy to compare '+nan.0':

     #!vicare
     (import (vicare) (srfi :114))

     (define-constant C
       (make-inexact-real-comparator #f 'round 'error))

     ;; type test
     (comparator-test-type C 1.2)    => #t
     (comparator-test-type C "ciao") => #f
     (comparator-test-type C 1+2i)   => #f

     ;; type check
     (comparator-check-type C 1.2)   => #t
     (try
         (comparator-check-type C (void))
       (catch E
         ((&comparator-type-error)
          #t)
         (else #f)))
     => #t

     ;; comparison
     (comparator-compare C 1.2 1.2)          =>  0
     (comparator-compare C 1.0 2.0)          => -1
     (comparator-compare C 2.0 1.0)          => +1

     (comparator-compare C +inf.0 +inf.0)    => 0
     (comparator-compare C -inf.0 -inf.0)    => 0
     (comparator-compare C -inf.0 +inf.0)    => -1
     (comparator-compare C +inf.0 -inf.0)    => +1

     (comparator-compare C +nan.0 +nan.0)    => 0
     (try
         (comparator-compare C +nan.0 1.0)
       (catch E
         ((&comparator-nan-comparison-error)
          #t)
         (else E)))
     => #t
     (try
         (comparator-compare C 1.0 +nan.0)
       (catch E
         ((&comparator-nan-comparison-error)
          #t)
         (else E)))
     => #t

     ;; comparison with rounding
     (comparator-compare C 1.04 1.0) => 0
     (comparator-compare C 0.96 1.0) => 0

     ;; hash
     (= (comparator-hash C 1.0) (comparator-hash C 1.04))      => #t
     (= (comparator-hash C 1.0) (comparator-hash C 0.96))      => #t
     (non-negative-exact-integer? (comparator-hash C +inf.0))  => #t
     (non-negative-exact-integer? (comparator-hash C -inf.0))  => #t
     (non-negative-exact-integer? (comparator-hash C +nan.0))  => #t

   Here is an example of comparator that rounds to the nearest 0.1 and
uses the 'min' policy to compare '+nan.0':

     #!vicare
     (import (vicare) (srfi :114))

     (define* (round-to-epsilon {R flonum?} {epsilon flonum?})
       (infix round(R / epsilon) * epsilon))

     (define-constant C
       (make-inexact-real-comparator 0.1 round-to-epsilon 'min))

     ;; rounding to
     (round-to-epsilon 1.0   0.1)    => 1.0
     (round-to-epsilon 1.05  0.1)    => 1.0
     (round-to-epsilon 0.951 0.1)    => 1.0
     (round-to-epsilon 0.949 0.1)    => 0.9

     ;; type test
     (comparator-test-type C 1.2)    => #t
     (comparator-test-type C +inf.0) => #t
     (comparator-test-type C -inf.0) => #t
     (comparator-test-type C -nan.0) => #t
     (comparator-test-type C "ciao") => #f
     (comparator-test-type C 1+2i)   => #f

     ;; type check
     (comparator-check-type C 1.2)   => #t
     (try
         (comparator-check-type C (void))
       (catch E
         ((&comparator-type-error)
          #t)
         (else E)))
     => #t

     ;; comparison
     (comparator-compare C 1.2 1.2)          => 0
     (comparator-compare C 1.0 2.0)          => -1
     (comparator-compare C 2.0 1.0)          => +1

     (comparator-compare C +inf.0 +inf.0)    => 0
     (comparator-compare C -inf.0 -inf.0)    => 0
     (comparator-compare C -inf.0 +inf.0)    => -1
     (comparator-compare C +inf.0 -inf.0)    => +1

     (comparator-compare C +nan.0 +nan.0)    => 0
     (comparator-compare C +nan.0 1.0)       => -1
     (comparator-compare C 1.0 +nan.0)       => +1

     ;; comparison with rounding
     (comparator-compare C 1.04  1.0)        => 0
     (comparator-compare C 0.96  1.0)        => 0
     (comparator-compare C 0.951 1.0)        => 0
     (comparator-compare C 0.949 1.0)        => -1
     (comparator-compare C 0.949 0.9)        => 0

     ;; hash
     (= (comparator-hash C 1.0)  (comparator-hash C 1.04))     => #t
     (= (comparator-hash C 1.0)  (comparator-hash C 0.96))     => #t
     (= (comparator-hash C 1.0)  (comparator-hash C 0.951))    => #t
     (= (comparator-hash C 1.04) (comparator-hash C 0.951))    => #t
     (non-negative-exact-integer? (comparator-hash C +inf.0))  => #t
     (non-negative-exact-integer? (comparator-hash C -inf.0))  => #t
     (non-negative-exact-integer? (comparator-hash C +nan.0))  => #t

   Here is an example of comparator using the 'max' policy to compare
'+nan.0':

     #!vicare
     (import (vicare) (srfi :114))

     (define-constant C
       (make-inexact-real-comparator #f 'round 'max))

     (comparator-compare C +nan.0 +nan.0)    => 0
     (comparator-compare C +nan.0 1.0)       => +1
     (comparator-compare C 1.0 +nan.0)       => -1

   Here is an example of comparator using a procedure as policy to
compare '+nan.0':

     #!vicare
     (import (vicare) (srfi :114))

     (define (nan-comparison other-R)
       ;;NaN is equal to any number.
       ;;
       0)

     (define-constant C
       (make-inexact-real-comparator #f 'round nan-comparison))

     (comparator-compare C +nan.0 +nan.0)    => 0
     (comparator-compare C +nan.0 +1.0)      => 0
     (comparator-compare C +1.0   +nan.0)    => 0


File: vicare-libs.info,  Node: srfi comparators constructors pair,  Next: srfi comparators constructors list,  Prev: srfi comparators constructors real,  Up: srfi comparators constructors

2.38.8.3 Pair comparators
.........................

 -- Function: make-pair-comparator CAR-COMPARATOR CDR-COMPARATOR
     Return a comparator that compares pairs first on their cars using
     CAR-COMPARATOR.  If the cars are equal: it compares the cdrs using
     CDR-COMPARATOR.  The hash function makes use of both the car and
     the cdr.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant C
            (make-pair-comparator exact-integer-comparator
                                  real-comparator))

          ;; type test
          (comparator-test-type C '(1 . 2.0))     => #t
          (comparator-test-type C '(1 . 2.0))     => #t
          (comparator-test-type C '())            => #f
          (comparator-test-type C '(1 . 2+1i))    => #f
          (comparator-test-type C "ciao")         => #f

          ;; type check
          (comparator-check-type C '(1 . 2.0))    => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)
               #t)
              (else E)))
          => #t

          ;; comparison
          (comparator-compare C '(1 . 2.0) '(1 . 2.0))   => 0
          (comparator-compare C '(1 . 2.0) '(1 . 3))     => -1
          (comparator-compare C '(1 . 3)   '(1 . 2.0))   => +1

          ;; hash
          (non-negative-exact-integer?
             (comparator-hash C '(1 . 2.0)))      => #t

 -- Function: make-car-comparator COMPARATOR
     Return a comparator that compares pairs on their cars alone using
     COMPARATOR.  The hash function makes use of the car only.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant C
            (make-car-comparator exact-integer-comparator))

          ;; type test
          (comparator-test-type C '(1 . 2.0))     => #t
          (comparator-test-type C '(1 . 2.0))     => #t
          (comparator-test-type C '(1 . 2+1i))    => #t
          (comparator-test-type C '(2.0 . 1))     => #f
          (comparator-test-type C '())            => #f
          (comparator-test-type C "ciao")         => #f

          ;; type check
          (comparator-check-type C '(1 . 2.0))    => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)
               #t)
              (else E)))
          => #t

          ;; comparison
          (comparator-compare C '(1 . 2) '(1 . 3))        => 0
          (comparator-compare C '(1 . 2) '(2 . 3))        => -1
          (comparator-compare C '(2 . 2) '(1 . 2))        => +1

          ;; hash
          (non-negative-exact-integer?
             (comparator-hash C '(1 . 2.0)))      => #t

 -- Function: make-cdr-comparator COMPARATOR
     Return a comparator that compares pairs on their cdrs alone using
     COMPARATOR.  The hash function makes use of the cdr only.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant C
            (make-cdr-comparator exact-integer-comparator))

          ;; type test
          (comparator-test-type C '(2.0 . 1))     => #t
          (comparator-test-type C '(2.0 . 1))     => #t
          (comparator-test-type C '(2+1i . 1))    => #t
          (comparator-test-type C '(1 . 2.0))     => #t
          (comparator-test-type C '())            => #f
          (comparator-test-type C "ciao")         => #f

          ;; type check
          (comparator-check-type C '(2.0 . 1))    => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)
               #t)
              (else E)))
          => #t

          ;; comparison
          (comparator-compare C '(2 . 1) '(3 . 1))        => 0
          (comparator-compare C '(2 . 1) '(3 . 2))        => -1
          (comparator-compare C '(2 . 2) '(2 . 1))        => +1

          ;; hash
          (non-negative-exact-integer?
             (comparator-hash C '(2.0 . 1)))      => #t


File: vicare-libs.info,  Node: srfi comparators constructors list,  Next: srfi comparators constructors vector,  Prev: srfi comparators constructors pair,  Up: srfi comparators constructors

2.38.8.4 List comparators
.........................

 -- Function: make-list-comparator ELEMENT-COMPARATOR
     Build and return a comparator object behaving like
     'list-comparator' but using ELEMENT-COMPARATOR rather than
     'default-comparator'.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant C
            (make-list-comparator exact-integer-comparator))

          ;; type test
          (comparator-test-type C '())            => #t
          (comparator-test-type C '(1 2))         => #t
          (comparator-test-type C '(1 2 . 3))     => #f
          (comparator-test-type C '(1 2.0))       => #f
          (comparator-test-type C "ciao")         => #f
          (comparator-test-type C '(1+2i))        => #f

          ;; type check
          (comparator-check-type C '(1 2))        => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)
               #t)
              (else E)))
          => #t

          ;; comparison
          (comparator-compare C '(1 2) '(1 2))   => 0)
          (comparator-compare C '(1 2) '(1 3))   => -1
          (comparator-compare C '(1 3) '(1 2))   => +1

          (comparator-compare C '()    '())      => 0
          (comparator-compare C '()    '(1 2))   => -1
          (comparator-compare C '(1 2) '())      => +1

          ;; hash
          (non-negative-exact-integer?
            (comparator-hash C '()))    => #t
          (non-negative-exact-integer?
            (comparator-hash C '(1 2))) => #t

 -- Function: make-listwise-comparator TYPE-TEST ELEMENT-COMPARATOR
          EMPTY? HEAD TAIL
     Return a comparator which compares two objects that satisfy
     TYPE-TEST as if they were lists, using the EMPTY? procedure to
     determine if an object is empty, and the HEAD and TAIL procedures
     to access particular elements.

 -- Function: make-improper-list-comparator ELEMENT-COMPARATOR
     Return a comparator that compares arbitrary objects as follows: the
     empty list precedes all pairs, which precede all other objects.
     Pairs are compared as if with:

          (make-pair-comparator ELEMENT-COMPARATOR ELEMENT-COMPARATOR)

     All other objects are compared using ELEMENT-COMPARATOR.

     Notice that ELEMENT-COMPARATOR is used only to compare elements and
     compute the hash value elements; it is *not* used to validate the
     type of elements.

          #!vicare
          (import (vicare) (srfi :114))

          (module (C)

            (define element-compare
              (let ((compare (comparator-comparison-procedure
                                exact-integer-comparator)))
                (lambda (A B)
                  (if (pair? A)
                      (begin
                        (assert (pair? B))
                        (let ((rv (compare (car A) (car B))))
                          (if (zero? rv)
                              (comparator-compare C (cdr A) (cdr B))
                            rv)))
                    (compare A B)))))

            (define-constant E
              (make-comparator #t #t
                 element-compare
                 (comparator-hash-function default-comparator)))

            (define-constant C
              (make-improper-list-comparator E))

            #| end of module |# )

          ;; type test
          (comparator-test-type C '())            => #t
          (comparator-test-type C '(1 2))         => #t
          (comparator-test-type C '(1 2 . 3))     => #t
          (comparator-test-type C '(1 2.0))       => #t
          (comparator-test-type C "ciao")         => #t
          (comparator-test-type C '(1+2i))        => #t

          ;; type check
          (comparator-check-type C '(1 2))        => #t
          (comparator-check-type C (void))        => #t

          ;; comparison
          (comparator-compare C '(1 2) '(1 2))    => 0
          (comparator-compare C '(1 2) '(1 3))    => -1
          (comparator-compare C '(1 3) '(1 2))    => +1

          (comparator-compare C '()    '())       => 0
          (comparator-compare C '()    '(1 2))    => -1
          (comparator-compare C '(1 2) '())       => +1

          (comparator-compare C '(1 2 . 3) '(1 2 . 3))    => 0
          (comparator-compare C '(1 2 . 3) '(1 2 . 4))    => -1
          (comparator-compare C '(1 2 . 4) '(1 2 . 3))    => +1

          (comparator-compare C '(1 2 9 . 3) '(1 2 9 . 3)) => 0
          (comparator-compare C '(1 2 9 . 3) '(1 2 9 . 4)) => -1
          (comparator-compare C '(1 2 9 . 4) '(1 2 9 . 3)) => +1

          ;; hash
          (non-negative-exact-integer? (comparator-hash C '()))        => #t
          (non-negative-exact-integer? (comparator-hash C '(1 2)))     => #t
          (non-negative-exact-integer? (comparator-hash C '(1 2 . 3))) => #t
          (non-negative-exact-integer? (comparator-hash C "ciao"))     => #t

