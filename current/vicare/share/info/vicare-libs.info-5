This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: srfi comparators constructors vector,  Next: srfi comparators constructors bytevec,  Prev: srfi comparators constructors list,  Up: srfi comparators constructors

2.38.8.5 Vector comparators
...........................

 -- Function: make-vector-comparator ELEMENT-COMPARATOR
     Build and return a comparator object behaving like
     'vector-comparator' but using ELEMENT-COMPARATOR rather than
     'default-comparator'.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant C
            (make-vector-comparator exact-integer-comparator))

          ;; type test
          (comparator-test-type C '#())           => #t
          (comparator-test-type C '#(1 2))        => #t
          (comparator-test-type C '#(1 2.0))      => #f
          (comparator-test-type C "ciao")         => #f
          (comparator-test-type C '#(1+2i)        => #f

          ;; type check
          (comparator-check-type C '#(1 2))       => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)
               #t)
              (else E)))
          => #t

          ;; comparison
          (comparator-compare C '#(1 2) '#(1 2))  => 0
          (comparator-compare C '#(1 2) '#(1 3))  => -1
          (comparator-compare C '#(1 3) '#(1 2))  => +1

          (comparator-compare C '#()    '#())     => 0
          (comparator-compare C '#()    '#(1 2))  => -1
          (comparator-compare C '#(1 2) '#())     => +1

          ;; hash
          (non-negative-exact-integer?
            (comparator-hash C '#())))    => #t
          (non-negative-exact-integer?
            (comparator-hash C '#(1 2)))  => #t

 -- Function: make-vectorwise-comparator TYPE-TEST ELEMENT-COMPARATOR
          LENGTH REF
     Return a comparator which compares two objects that satisfy
     TYPE-TEST as if they were vectors, using the LENGTH procedure to
     determine the length of the object, and the REF procedure to access
     a particular element.


File: vicare-libs.info,  Node: srfi comparators constructors bytevec,  Next: srfi comparators constructors select,  Prev: srfi comparators constructors vector,  Up: srfi comparators constructors

2.38.8.6 Bytevector comparators
...............................

 -- Function: make-bytevector-comparator ELEMENT-COMPARATOR
     Build and return a comparator object behaving like
     'bytevector-comparator' but using ELEMENT-COMPARATOR rather than
     'default-comparator'.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant E
            (make-comparator (lambda (element)
                               (or (= 1 element)
                                   (zero? element)))
                             fx=?
                             (lambda (a b)
                               (cond ((fx=? a b)   0)
                                     ((fx<? a b)  -1)
                                     (else        +1)))
                             fixnum-hash))

          (define-constant C
            (make-bytevector-comparator E))

          ;; type test
          (comparator-test-type C '#vu8())        => #t
          (comparator-test-type C '#vu8(1 0))     => #t
          (comparator-test-type C '#vu8(1 2))     => #f
          (comparator-test-type C "ciao")         => #f

          ;; type check
          (comparator-check-type C '#vu8(1 0))    => #t
          (try
              (comparator-check-type C (void))
            (catch E
              ((&comparator-type-error)
               #t)
              (else E)))
          => #t

          ;; comparison
          (comparator-compare C '#vu8(1 0) '#vu8(1 0))   => 0
          (comparator-compare C '#vu8(1 0) '#vu8(1 1))   => -1
          (comparator-compare C '#vu8(1 1) '#vu8(1 0))   => +1

          (comparator-compare C '#vu8()    '#vu8())      => 0
          (comparator-compare C '#vu8()    '#vu8(1 0))   => -1
          (comparator-compare C '#vu8(1 0) '#vu8())      => +1

          ;; hash
          (non-negative-exact-integer?
            (comparator-hash C '#vu8()))    => #t
          (non-negative-exact-integer?
            (comparator-hash C '#vu8(1 0))) => #t


File: vicare-libs.info,  Node: srfi comparators constructors select,  Next: srfi comparators constructors refine,  Prev: srfi comparators constructors bytevec,  Up: srfi comparators constructors

2.38.8.7 Selecting comparators
..............................

 -- Function: make-selecting-comparator COMPARATOR0 COMPARATOR ...
     Return a comparator whose procedures make use of the COMPARATOR
     arguments as follows:

        * The type test predicate passes its argument to the type test
          predicates of the COMPARATORs in the sequence given.  If any
          of them returns '#t': so does the type test predicate;
          otherwise, it returns '#f'.

        * The arguments of the equality, compare, and hash functions are
          passed to the type test predicate of each comparator in
          sequence.  The first comparator whose type test predicate is
          satisfied on all the arguments is used when comparing those
          arguments.  All other comparators are ignored.  If no type
          test predicate is satisfied, an error is signalled.

     This procedure is analogous to the expression types
     'select-compare' and 'cond-compare' from SRFI-67.

          #!vicare
          (import (vicare) (srfi :114))

          (define-constant C
            (make-selecting-comparator boolean-comparator
                                       exact-integer-comparator
                                       string-comparator))

          ;; type test
          (let ((test-type (comparator-type-test-procedure C)))
            (test-type #t)        => #t
            (test-type #f)        => #t
            (test-type 1)         => #t
            (test-type "ciao")    => #t
            (test-type '(1 . 2))  => #f
            (test-type 2.0)       => #f
            (test-type 1+2i))     => #f

          ;; type check
          (let ((check-type (comparator-check-type-procedure C)))
            (check-type #t)       => #t
            (check-type #f)       => #t
            (check-type 1)        => #t
            (check-type "ciao")   => #t
            (try
                (comparator-check-type C (void))
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E))))       => #t

          ;; comparison
          (let ((compare (comparator-comparison-procedure C)))
            (compare #t #t)       => 0
            (compare #t #f)       => +1
            (compare #f #t)       => -1

            (compare 1 1)         => 0
            (compare 2 1)         => +1
            (compare 1 2)         => -1

            (compare "1" "1")     => 0
            (compare "2" "1")     => +1
            (compare "1" "2")     => -1

            (try
                (compare #t 1)
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E)))        => #t

            (try
                (compare #t "ciao")
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E)))        => #t

            (try
                (compare 1 "ciao")
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E))))       => #t

          ;; hash
          (let ((hash (comparator-hash-function C)))
            (non-negative-exact-integer? (hash #t))       => #t
            (non-negative-exact-integer? (hash #f))       => #t
            (non-negative-exact-integer? (hash 1))        => #t
            (non-negative-exact-integer? (hash "ciao"))   => #t

            (try
                (hash 1+2i)
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E))))       => #t


File: vicare-libs.info,  Node: srfi comparators constructors refine,  Next: srfi comparators constructors reverse,  Prev: srfi comparators constructors select,  Up: srfi comparators constructors

2.38.8.8 Refining comparators
.............................

 -- Function: make-refining-comparator COMPARATOR0 COMPARATOR ...
     Return a comparator that makes use of the COMPARATORs in the same
     way as 'make-selecting-comparator', except that its procedures can
     look past the first comparator whose type test predicate is
     satisfied.

     If the comparison procedure of the first comparator returns zero:
     the next comparator whose type test predicate is satisfied is
     tried, then the next and so on, until one returns a non-zero value.
     If there are no more such comparators, then the comparison
     procedure returns zero.

     The equality predicate is defined in the same way.  If no type test
     predicate is satisfied, an error is signalled.

     The hash function of the result returns a value computed using the
     last comparator in the given list for which the type test procedure
     returns true.

          According to the SRFI: the hash function of the result returns
          a value which depends, in an implementation-defined way, on
          the results of invoking the hash functions of the comparators
          whose type test predicates are satisfied on its argument.  In
          particular, it may depend solely on the first or last such
          hash function.  If no type test predicate is satisfied, an
          error is signalled.

     This procedure is analogous to the expression type 'refine-compare'
     from SRFI-67.

          #!vicare
          (import (vicare) (srfi :114))

          (define* (round-to-epsilon {R flonum?} {epsilon flonum?})
            (infix round(R / epsilon) * epsilon))

          (define-constant C
            (make-refining-comparator
             (make-inexact-real-comparator 0.1   round-to-epsilon 'error)
             (make-inexact-real-comparator 0.01  round-to-epsilon 'error)
             (make-inexact-real-comparator 0.001 round-to-epsilon 'error)))

          ;; type test
          (let ((test-type (comparator-type-test-procedure C)))
            (test-type 1.1)       => #t
            (test-type 1)         => #f
            (test-type "ciao"))   => #f

          ;; type check
          (let ((check-type (comparator-check-type-procedure C)))
            (check-type 1.1)      => #t
            (try
                (comparator-check-type C 1)
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E))))       => #t

          ;; comparison
          (let ((compare (comparator-comparison-procedure C)))
            (compare 1. 1.)       => 0
            (compare 2. 1.)       => +1
            (compare 1. 2.)       => -1

            ;;Equal according to the first comparator,
            ;;different according to the second.
            (compare 1.00 1.05)   => -1
            (compare 1.05 1.00)   => +1

            ;;Equal according to the first and second
            ;;comparators, different according to the
            ;;third.
            (compare 1.0   1.005) => -1
            (compare 1.005 1.0)   => +1

            ;;Equal according to the first, second and
            ;;third comparators.
            (compare 1.0 1.0005)  => 0
            (compare 1.0005 1.0)  => 0

            (try
                (compare 1 "ciao")
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E))))       => #t

          ;; hash
          (let ((hash (comparator-hash-function C)))
            (non-negative-exact-integer? (hash 1.2))      => #t

            (try
                (hash 1+2i)
              (catch E
                ((&comparator-type-error)
                 #t)
                (else E))))       => #t


File: vicare-libs.info,  Node: srfi comparators constructors reverse,  Next: srfi comparators constructors debug,  Prev: srfi comparators constructors refine,  Up: srfi comparators constructors

2.38.8.9 Reverse comparators
............................

 -- Function: make-reverse-comparator COMPARATOR
     Return a comparator that behaves like COMPARATOR, except that the
     compare procedure returns '+1', '0', and '-1' instead of '-1', '0',
     and '+1' respectively.  This allows ordering in reverse.

   Here a usage example:

     #!vicare
     (import (vicare) (srfi :114))

     (define-constant C
       (make-reverse-comparator exact-integer-comparator))

     ;; type test
     (let ((test-type (comparator-test-type-procedure C)))
       (test-type 1)         => #t
       (test-type '())       => #f
       (test-type "ciao"))   => #f

     ;; type check
     (let ((check-type (comparator-check-type-procedure C)))
       (check-type 1)        => #t
       (try
           (check-type (void))
         (catch E
           ((&comparator-type-error)
            #t)
           (else E))))       => #t

     ;; comparison
     (let ((compare (comparator-comparison-procedure C)))
       (compare 1 1)         => 0
       (compare 1 2)         => +1
       (compare 2 1)         => -1)

     ;; hash
     (let ((hash (comparator-hash-function C)))
       (non-negative-exact-integer? (hash 1)))       => #t


File: vicare-libs.info,  Node: srfi comparators constructors debug,  Prev: srfi comparators constructors reverse,  Up: srfi comparators constructors

2.38.8.10 Debug comparators
...........................

 -- Function: make-debug-comparator COMPARATOR
     Return a comparator that behaves exactly like COMPARATOR, except
     that whenever any of its procedures are invoked, it verifies all
     the programmer responsibilities (except stability), and an error is
     signalled if any of them are violated.  Because it requires three
     arguments, transitivity is not tested on the first call to a debug
     comparator; it is tested on all future calls using an arbitrarily
     chosen argument from the previous invocation.  Note that this may
     cause unexpected storage leaks.


File: vicare-libs.info,  Node: srfi comparators wrapped,  Next: srfi comparators accessors,  Prev: srfi comparators constructors,  Up: srfi comparators

2.38.9 Wrapped equality predicates
----------------------------------

 -- Function: eq-comparator
 -- Function: eqv-comparator
 -- Function: equal-comparator
     The equality predicates of these comparators are 'eq?', 'eqv?', and
     'equal?' respectively.

     Comparison is *not* supported by these comparators: when their
     comparison procedures are applied to any objects: an exception is
     raised with condition object of type
     '&unsupported-comparator-operation-error'.

     These comparators accept circular structures and '+nan.0' values.


File: vicare-libs.info,  Node: srfi comparators accessors,  Next: srfi comparators applicators,  Prev: srfi comparators wrapped,  Up: srfi comparators

2.38.10 Accessors
-----------------

 -- Function: comparator-type-test-procedure COMPARATOR
 -- Function: comparator-test-type-procedure COMPARATOR
     Return the type test predicate of COMPARATOR.

 -- Function: comparator-check-type-procedure COMPARATOR
 -- Function: comparator-type-check-procedure COMPARATOR
     Return the type check procedure of COMPARATOR.  The returned
     procedure can be called with one or two arguments:

        * When called with one argument OBJ: it invokes the type test
          predicate of COMPARATOR on OBJ and returns '#t' if it returns
          '#t'; otherwise it signals an error.

        * When called with two arguments OBJ and WHO: it invokes the
          type test predicate of COMPARATOR on OBJ and returns '#t' if
          it returns '#t'; otherwise it signals an error.  The optional
          argument WHO must be compatible with the argument of
          'make-who-condition' and it is used to raise a descriptive
          exception when OBJ does not match the comparator.

          *NOTE* This procedure is a Vicare extension.

 -- Function: comparator-equality-predicate COMPARATOR
     Return the equality predicate of COMPARATOR.

 -- Function: comparator-comparison-procedure COMPARATOR
     Return the comparison procedure of COMPARATOR.

 -- Function: comparator-hash-function COMPARATOR
     Return the hash function of COMPARATOR.


File: vicare-libs.info,  Node: srfi comparators applicators,  Next: srfi comparators compar proc,  Prev: srfi comparators accessors,  Up: srfi comparators

2.38.11 Primitive applicators
-----------------------------

 -- Function: comparator-test-type COMPARATOR OBJ
     Invoke the type test predicate of COMPARATOR on OBJ and return what
     it returns.

 -- Function: comparator-check-type COMPARATOR OBJ
 -- Function: comparator-check-type COMPARATOR OBJ WHO
     Invoke the type test predicate of COMPARATOR on OBJ and return '#t'
     if it returns '#t'; otherwise signal an error.

     As a Vicare extension: the optional argument WHO must be compatible
     with the argument of 'make-who-condition' and it is used to raise a
     descriptive exception when OBJ does not match the comparator.

 -- Function: comparator-equal? COMPARATOR OBJ1 OBJ2
     Invoke the equality predicate of COMPARATOR on OBJ1 and OBJ2 and
     return what it returns.

 -- Function: comparator-compare COMPARATOR OBJ1 OBJ2
     Invoke the comparison procedure of COMPARATOR on OBJ1 and OBJ2 and
     return what it returns.

 -- Function: comparator-hash COMPARATOR OBJ
     Invoke the hash function of COMPARATOR on OBJ and return what it
     returns.


File: vicare-libs.info,  Node: srfi comparators compar proc,  Next: srfi comparators syntax,  Prev: srfi comparators applicators,  Up: srfi comparators

2.38.12 Comparison procedure constructors
-----------------------------------------

 -- Function: make-comparison< LT-PRED
 -- Function: make-comparison> GT-PRED
 -- Function: make-comparison<= LE-PRED
 -- Function: make-comparison>= GE-PRED
 -- Function: make-comparison=/< EQ-PRED LT-PRED
 -- Function: make-comparison=/> EQ-PRED GT-PRED
     These procedures return a comparison procedure, given a less-than
     predicate, a greater-than predicate, a less-than-or-equal-to
     predicate, a greater-than-or-equal-to predicate, or the combination
     of an equality predicate and either a less-than or a greater-than
     predicate.

     They are the same as the corresponding SRFI-67 'compare-by'
     procedures.  Note that they do not accept comparand arguments.

   Usage examples:

     #!vicare
     (import (vicare) (srfi :114))

     (let ((compare (make-comparison< fx<?)))
       (compare 1 1)        => 0
       (compare 1 2)        => -1
       (compare 2 1))       => +1

     (let ((compare (make-comparison> fx>?)))
       (compare 1 1)        => 0
       (compare 1 2)        => -1
       (compare 2 1))       => +1

     (let ((compare (make-comparison<= fx<=?)))
       (compare 1 1)        => 0
       (compare 1 2)        => -1
       (compare 2 1))       => +1

     (let ((compare (make-comparison>= fx>=?)))
       (compare 1 1)        => 0
       (compare 1 2)        => -1
       (compare 2 1))       => +1

     (let ((compare (make-comparison=/< fx=? fx<?)))
       (compare 1 1)        => 0
       (compare 1 2)        => -1
       (compare 2 1))       => +1

     (let ((compare (make-comparison=/> fx=? fx>?)))
       (compare 1 1)        => 0
       (compare 1 2)        => -1
       (compare 2 1))       => +1


File: vicare-libs.info,  Node: srfi comparators syntax,  Next: srfi comparators compar pred,  Prev: srfi comparators compar proc,  Up: srfi comparators

2.38.13 Comparison syntax
-------------------------

The following expression types allow the convenient use of comparison
procedures.  They come directly from SRFI-67.

 -- Syntax: if3 ?EXPR ?LESS ?EQUAL ?GREATER
     The expression ?EXPR is evaluated; it will typically, but not
     necessarily, be a call on a comparison procedure.

        * If the result is '-1': ?LESS is evaluated and its values are
          returned.

        * If the result is '0': ?EQUAL is evaluated and its values are
          returned.

        * If the result is '+1': ?GREATER is evaluated and its values
          are returned.

        * Otherwise an error is signalled.

     Usage examples:

          #!vicare
          (import (vicare) (srfi :114))

          (if3 (compare 1 1) 'less 'equal 'greater)       => equal
          (if3 (compare 1 2) 'less 'equal 'greater)       => less
          (if3 (compare 2 1) 'less 'equal 'greater)       => greater

 -- Syntax: if=? ?EXPR ?CONSEQUENT
 -- Syntax: if=? ?EXPR ?CONSEQUENT ?ALTERNATE
 -- Syntax: if<? ?EXPR ?CONSEQUENT
 -- Syntax: if<? ?EXPR ?CONSEQUENT ?ALTERNATE
 -- Syntax: if>? ?EXPR ?CONSEQUENT
 -- Syntax: if>? ?EXPR ?CONSEQUENT ?ALTERNATE
 -- Syntax: if<=? ?EXPR ?CONSEQUENT
 -- Syntax: if<=? ?EXPR ?CONSEQUENT ?ALTERNATE
 -- Syntax: if>=? ?EXPR ?CONSEQUENT
 -- Syntax: if>=? ?EXPR ?CONSEQUENT ?ALTERNATE
 -- Syntax: if-not=? ?EXPR ?CONSEQUENT
 -- Syntax: if-not=? ?EXPR ?CONSEQUENT ?ALTERNATE
     The expression ?EXPR is evaluated; it will typically, but not
     necessarily, be a call on a comparison procedure.

        * It is an error if the return value of ?EXPR is not '-1', '0',
          or '+1'.

        * If the return value *is* consistent with the specified
          relation: ?CONSEQUENT is evaluated and its values are
          returned.

        * If the return value *it not* consistent with the specified
          relation:

               If ?ALTERNATE is present: it is evaluated and its values
               are returned.

             - If ?ALTERNATE is absent: an unspecified value is
               returned.

     Usage examples:

          #!vicare
          (import (vicare) (srfi :114))

          (if=? (compare 1 1) #t #f)      => #t
          (if=? (compare 1 2) #t #f)      => #f
          (if=? (compare 2 1) #t #f)      => #f

          (if=? (compare 1 1) #t)         => #t
          (if=? (compare 1 2) #t)         => #<void>
          (if=? (compare 2 1) #t)         => #<void>

          ;;;

          (if-not=? (compare 1 1) #f #t)  => #t
          (if-not=? (compare 1 2) #f #t)  => #f
          (if-not=? (compare 2 1) #f #t)  => #f

          (if-not=? (compare 1 1) #t)     => #<void>
          (if-not=? (compare 1 2) #t)     => #t
          (if-not=? (compare 2 1) #t)     => #t

          ;;;

          (if<? (compare 1 1) #t #f)      => #f
          (if<? (compare 1 2) #t #f)      => #t
          (if<? (compare 2 1) #t #f)      => #f

          (if<? (compare 1 1) #t)         => #<void>
          (if<? (compare 1 2) #t)         => #t
          (if<? (compare 2 1) #t)         => #<void>

          ;;;

          (if>? (compare 1 1) #t #f)      => #f
          (if>? (compare 1 2) #t #f)      => #f
          (if>? (compare 2 1) #t #f)      => #t

          (if>? (compare 1 1) #t)         => #<void>
          (if>? (compare 1 2) #t)         => #<void>
          (if>? (compare 2 1) #t)         => #t

          ;;;

          (if<=? (compare 1 1) #t #f)     => #t
          (if<=? (compare 1 2) #t #f)     => #t
          (if<=? (compare 2 1) #t #f)     => #f

          (if<=? (compare 1 1) #t)        => #t
          (if<=? (compare 1 2) #t)        => #t
          (if<=? (compare 2 1) #t)        => #<void>

          ;;;

          (if>=? (compare 1 1) #t #f)     => #t
          (if>=? (compare 1 2) #t #f)     => #f
          (if>=? (compare 2 1) #t #f)     => #t

          (if>=? (compare 1 1) #t)        => #t
          (if>=? (compare 1 2) #t)        => #<void>
          (if>=? (compare 2 1) #t)        => #t


File: vicare-libs.info,  Node: srfi comparators compar pred,  Next: srfi comparators ternary,  Prev: srfi comparators syntax,  Up: srfi comparators

2.38.14 Comparison predicates and predicate constructors
--------------------------------------------------------

 -- Function: =? COMPARATOR OBJ1 OBJ2 OBJ3 ...
 -- Function: <? COMPARATOR OBJ1 OBJ2 OBJ3 ...
 -- Function: >? COMPARATOR OBJ1 OBJ2 OBJ3 ...
 -- Function: <=? COMPARATOR OBJ1 OBJ2 OBJ3 ...
 -- Function: >=? COMPARATOR OBJ1 OBJ2 OBJ3 ...
     These procedures are analogous to the number, character, and string
     comparison predicates of Scheme.  They allow the convenient use of
     comparators in situations where the expression types are not
     usable.  They are also analogous to the similarly named procedures
     of SRFI-67, but handle arbitrary numbers of arguments, which in
     SRFI-67 requires the use of the variants whose names begin with
     'chain'.

     These procedures apply the comparison procedure of COMPARATOR to
     the objects as follows: if the specified relation returns '#t' for
     all OBJJ and OBJK where 1 <= j < k <= N and N is the number of
     objects, then the procedures return '#t'; otherwise return '#f'.

     The order in which the values are compared is unspecified.  Because
     the relations are transitive, it suffices to compare each object
     with its successor.

     Usage examples:

          (import (vicare) (srfi :114))

          (define-constant C fixnum-comparator)

          ;;;

          (=? C 1 1)      => #t
          (=? C 1 2)      => #f
          (=? C 2 1)      => #f

          (=? C 1 1 1)    => #t
          (=? C 1 2 3)    => #f
          (=? C 2 1 3)    => #f
          (=? C 3 2 1)    => #f
          (=? C 1 3 2)    => #f

          ;;;

          (<? C 1 1)      => #f
          (<? C 1 2)      => #t
          (<? C 2 1)      => #f

          (<? C 1 1 1)    => #f
          (<? C 1 2 3)    => #t
          (<? C 2 1 3)    => #f
          (<? C 3 2 1)    => #f
          (<? C 1 3 2)    => #f

          ;;;

          (>? C 1 1)      => #f
          (>? C 1 2)      => #f
          (>? C 2 1)      => #t

          (>? C 1 1 1)    => #f
          (>? C 3 2 1)    => #t
          (>? C 1 2 3)    => #f
          (>? C 2 1 3)    => #f
          (>? C 1 3 2)    => #f

          ;;;

          (<=? C 1 1)     => #t
          (<=? C 1 2)     => #t
          (<=? C 2 1)     => #f

          (<=? C 1 1 1)   => #t
          (<=? C 1 2 3)   => #t
          (<=? C 2 1 3)   => #f
          (<=? C 3 2 1)   => #f
          (<=? C 1 3 2)   => #f

          ;;;

          (>=? C 1 1)     => #t
          (>=? C 1 2)     => #f
          (>=? C 2 1)     => #t

          (>=? C 1 1 1)   => #t
          (>=? C 3 2 1)   => #t
          (>=? C 1 2 3)   => #f
          (>=? C 2 1 3)   => #f
          (>=? C 1 3 2)   => #f

 -- Function: make= COMPARATOR
 -- Function: make< COMPARATOR
 -- Function: make> COMPARATOR
 -- Function: make<= COMPARATOR
 -- Function: make>= COMPARATOR
     These procedures return predicates which, when applied to two or
     more arguments, return '#t' if comparing the arguments using the
     equality or comparison procedures of COMPARATOR shows that the
     objects bear the specified relation to one another.  Such
     predicates can be used in contexts that do not understand or expect
     comparators.

     Usage examples:

          (import (vicare) (srfi :114))

          (define-constant C fixnum-comparator)

          ;;;

          (let ((fun=? (make= C)))
            (fun=? 1 1)           => #t
            (fun=? 1 2)           => #f
            (fun=? 2 1)           => #f

            (fun=? 1 1 1)         => #t
            (fun=? 1 2 3)         => #f
            (fun=? 2 1 3)         => #f
            (fun=? 3 2 1)         => #f
            (fun=? 1 3 2))        => #f

          ;;;

          (let ((fun<? (make< C)))
            (fun<? 1 1)           => #f
            (fun<? 1 2)           => #t
            (fun<? 2 1)           => #f

            (fun<? 1 1 1)         => #f
            (fun<? 1 2 3)         => #t
            (fun<? 2 1 3)         => #f
            (fun<? 3 2 1)         => #f
            (fun<? 1 3 2))        => #f

          ;;;

          (let ((fun>? (make> C)))
            (fun>? 1 1)           => #f
            (fun>? 1 2)           => #f
            (fun>? 2 1)           => #t

            (fun>? 1 1 1)         => #f
            (fun>? 3 2 1)         => #t
            (fun>? 1 2 3)         => #f
            (fun>? 2 1 3)         => #f
            (fun>? 1 3 2))        => #f

          ;;;

          (let ((fun<=? (make<= C)))
            (fun<=? 1 1)          => #t
            (fun<=? 1 2)          => #t
            (fun<=? 2 1)          => #f

            (fun<=? 1 1 1)        => #t
            (fun<=? 1 2 3)        => #t
            (fun<=? 2 1 3)        => #f
            (fun<=? 3 2 1)        => #f
            (fun<=? 1 3 2))       => #f

          ;;;

          (let ((fun>=? (make>= C)))
            (fun>=? 1 1)          => #t
            (fun>=? 1 2)          => #f
            (fun>=? 2 1)          => #t

            (fun>=? 1 1 1)        => #t
            (fun>=? 3 2 1)        => #t
            (fun>=? 1 2 3)        => #f
            (fun>=? 2 1 3)        => #f
            (fun>=? 1 3 2))       => #f


File: vicare-libs.info,  Node: srfi comparators ternary,  Next: srfi comparators minmax,  Prev: srfi comparators compar pred,  Up: srfi comparators

2.38.15 Interval (ternary) comparison predicates
------------------------------------------------

These procedures return '#t' or '#f' depending on whether an object is
contained in an open, closed, or half-open interval.  All comparisons
are done in the sense of COMPARATOR, which is 'default-comparator' if
omitted.

 -- Function: in-open-interval? OBJ1 OBJ2 OBJ3
 -- Function: in-open-interval? COMPARATOR OBJ1 OBJ2 OBJ3
     Return '#t' if OBJ1 is less than OBJ2, which is less than OBJ3;
     otherwise return '#f'.

     Usage examples:

          (import (vicare) (srfi :114))

          (define-constant C fixnum-comparator)

          (in-open-interval? 1 2 3)       => #t
          (in-open-interval? 1 1 3)       => #f
          (in-open-interval? 1 3 3)       => #f

          (in-open-interval? 1 0 3)       => #f
          (in-open-interval? 1 0 3)       => #f
          (in-open-interval? 1 0 3)       => #f

          (in-open-interval? 1 9 3)       => #f
          (in-open-interval? 1 9 3)       => #f
          (in-open-interval? 1 9 3)       => #f

          (in-open-interval? C 1 2 3)     => #t
          (in-open-interval? C 1 1 3)     => #f
          (in-open-interval? C 1 3 3)     => #f

          (in-open-interval? C 1 0 3)     => #f
          (in-open-interval? C 1 0 3)     => #f
          (in-open-interval? C 1 0 3)     => #f

          (in-open-interval? C 1 9 3)     => #f
          (in-open-interval? C 1 9 3)     => #f
          (in-open-interval? C 1 9 3)     => #f

 -- Function: in-closed-interval? OBJ1 OBJ2 OBJ3
 -- Function: in-closed-interval? COMPARATOR OBJ1 OBJ2 OBJ3
     Return '#t' if OBJ1 is less than or equal to OBJ2, which is less
     than or equal to OBJ3; otherwise return '#f'.

     Usage examples:

          (import (vicare) (srfi :114))

          (define-constant C fixnum-comparator)

          (in-closed-interval? 1 2 3)     => #t
          (in-closed-interval? 1 1 3)     => #t
          (in-closed-interval? 1 3 3)     => #t

          (in-closed-interval? 1 0 3)     => #f
          (in-closed-interval? 1 0 3)     => #f
          (in-closed-interval? 1 0 3)     => #f

          (in-closed-interval? 1 9 3)     => #f
          (in-closed-interval? 1 9 3)     => #f
          (in-closed-interval? 1 9 3)     => #f

          (in-closed-interval? C 1 2 3)   => #t
          (in-closed-interval? C 1 1 3)   => #t
          (in-closed-interval? C 1 3 3)   => #t

          (in-closed-interval? C 1 0 3)   => #f
          (in-closed-interval? C 1 0 3)   => #f
          (in-closed-interval? C 1 0 3)   => #f

          (in-closed-interval? C 1 9 3)   => #f
          (in-closed-interval? C 1 9 3)   => #f
          (in-closed-interval? C 1 9 3)   => #f

 -- Function: in-open-closed-interval? OBJ1 OBJ2 OBJ3
 -- Function: in-open-closed-interval? COMPARATOR OBJ1 OBJ2 OBJ3
     Return '#t' if OBJ1 is less than OBJ2, which is less than or equal
     to OBJ3; otherwise return '#f'.

     Usage examples:

          (import (vicare) (srfi :114))

          (define-constant C fixnum-comparator)

          (in-open-closed-interval? 1 2 3)        => #t
          (in-open-closed-interval? 1 1 3)        => #f
          (in-open-closed-interval? 1 3 3)        => #t

          (in-open-closed-interval? 1 0 3)        => #f
          (in-open-closed-interval? 1 0 3)        => #f
          (in-open-closed-interval? 1 0 3)        => #f

          (in-open-closed-interval? 1 9 3)        => #f
          (in-open-closed-interval? 1 9 3)        => #f
          (in-open-closed-interval? 1 9 3)        => #f

          (in-open-closed-interval? C 1 2 3)      => #t
          (in-open-closed-interval? C 1 1 3)      => #f
          (in-open-closed-interval? C 1 3 3)      => #t

          (in-open-closed-interval? C 1 0 3)      => #f
          (in-open-closed-interval? C 1 0 3)      => #f
          (in-open-closed-interval? C 1 0 3)      => #f

          (in-open-closed-interval? C 1 9 3)      => #f
          (in-open-closed-interval? C 1 9 3)      => #f
          (in-open-closed-interval? C 1 9 3)      => #f

 -- Function: in-closed-open-interval? OBJ1 OBJ2 OBJ3
 -- Function: in-closed-open-interval? COMPARATOR OBJ1 OBJ2 OBJ3
     Return '#t' if OBJ1 is less than or equal to OBJ2, which is less
     than OBJ3; otherwise return '#f'.

     Usage examples:

          (import (vicare) (srfi :114))

          (define-constant C fixnum-comparator)

          (in-closed-open-interval? 1 2 3)        => #t
          (in-closed-open-interval? 1 1 3)        => #t
          (in-closed-open-interval? 1 3 3)        => #f

          (in-closed-open-interval? 1 0 3)        => #f
          (in-closed-open-interval? 1 0 3)        => #f
          (in-closed-open-interval? 1 0 3)        => #f

          (in-closed-open-interval? 1 9 3)        => #f
          (in-closed-open-interval? 1 9 3)        => #f
          (in-closed-open-interval? 1 9 3)        => #f

          (in-closed-open-interval? C 1 2 3)      => #t
          (in-closed-open-interval? C 1 1 3)      => #t
          (in-closed-open-interval? C 1 3 3)      => #f

          (in-closed-open-interval? C 1 0 3)      => #f
          (in-closed-open-interval? C 1 0 3)      => #f
          (in-closed-open-interval? C 1 0 3)      => #f

          (in-closed-open-interval? C 1 9 3)      => #f
          (in-closed-open-interval? C 1 9 3)      => #f
          (in-closed-open-interval? C 1 9 3)      => #f


File: vicare-libs.info,  Node: srfi comparators minmax,  Next: srfi comparators misc,  Prev: srfi comparators ternary,  Up: srfi comparators

2.38.16 Min/max comparison procedures
-------------------------------------

 -- Function: comparator-min COMPARATOR OBJ0 OBJ1 ...
 -- Function: comparator-max COMPARATOR OBJ0 OBJ1 ...
     Analogous to 'min' and 'max'.  Apply the comparison procedure of
     COMPARATOR to the arguments to find and return a minimal (or
     maximal) object.  The order in which the values are compared is
     unspecified.

          *NOTE* The SRFI-67 procedures 'pairwise-not=?' and
          'kth-largest' involve sorting their arguments, and are not
          provided by this proposal in order to avoid an otherwise
          unnecessary implementation dependency.  They are easily
          provided by a sorting package that makes use of comparators.

     Usage examples:

          (import (vicare) (srfi :114))

          (comparator-min C 0)           => 0
          (comparator-min C 0 0)         => 0
          (comparator-min C 0 1)         => 0
          (comparator-min C 1 0)         => 0
          (comparator-min C 0 1 2)       => 0


File: vicare-libs.info,  Node: srfi comparators misc,  Next: srfi comparators conditions,  Prev: srfi comparators minmax,  Up: srfi comparators

2.38.17 Miscellaneous procedures
--------------------------------

 -- Function: make-comparator-hashtable COMPARATOR
     Build and return a new hashtable using the equality predicate and
     hash function from COMPARATOR.

          *NOTE* This is a Vicare extension.


File: vicare-libs.info,  Node: srfi comparators conditions,  Next: srfi comparators copyright,  Prev: srfi comparators misc,  Up: srfi comparators

2.38.18 Condition object types
------------------------------

As Vicare extension the following condition objects are defined.

Comparator error
................

 -- Condition Object Type: &comparator-error
     Used to signal an error while using a comparator's facilities.  It
     is derived from '&error'.

 -- Function: make-comparator-error COMPAR OBJ
     Build and return a new condition object of type
     '&comparator-error'.

 -- Function: comparator-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&comparator-error'; otherwise return '#f'.

Unsupported operation error
...........................

 -- Condition Object Type: &unsupported-comparator-operation-error
     Used to signal an attempt to use an unsupported operation.  It is
     derived from '&comparator-ertor'.

     It has the following fields:

     'comparator'
          The comparator that does not support the operation.

 -- Function: make-unsupported-comparator-operation-error COMPARATOR
     Build and return a new condition object of type
     '&unsupported-comparator-operation-error'.

 -- Function: unsupported-comparator-operation-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&unsupported-comparator-operation-error'; otherwise return '#f'.

 -- Function: unsupported-comparator-operation-error.comparator CND
     Accessor for the field of condition objects of type
     '&unsupported-comparator-operation-error'.

 -- Function: raise-unsupported-comparator-operation-error WHO MESSAGE
          COMPARATOR IRRITANT ...
     Raise a non-continuable exception with compound condition object of
     types: '&who', '&message',
     '&unsupported-comparator-operation-error', '&irritants'.

Comparator type error
.....................

 -- Condition Object Type: &comparator-type-error
     Used to signal an attempt to use the facilities of a comparator
     with an object that does not satisfy the comparator's type
     predicate.  It is derived from '&comparator-error'.  It has two
     fields:

     'comparator'
          The comparator object.

     'objects'
          List of objects with which the comparator was used.

 -- Function: make-comparator-type-error COMPAR OBJ
     Build and return a new condition object of type
     '&comparator-type-error'.

 -- Function: comparator-type-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&comparator-type-error'; otherwise return '#f'.

 -- Condition Object Accessor: comparator-type-error.comparator COND
 -- Condition Object Accessor: comparator-type-error.objects COND
     Accessors for the fields of condition objects of type
     '&comparator-type-error'.

 -- Function: raise-comparator-type-error WHO MESSAGE COMPARATOR OBJECT
          ...
     Raise a non-continuable exception with compound condition object of
     types: '&who', '&message', '&comparator-type-error', '&irritants'.

 -- Function: raise-comparator-argument-type-error WHO MESSAGE
          COMPARATOR OBJECT ...
     Raise a non-continuable exception with compound condition object of
     types: '&who', '&message', '&comparator-type-error', '&irritants',
     '&procedure-argument-violation'.

Not-a-number comparison error
.............................

 -- Condition Object Type: &comparator-nan-comparison-error
     Used to signal an invalid comparison in which one of the operands
     is '+nan.0'.  It is derived from '&comparator-error'.

     It has the following fields:

     'comparator'
          The comparator object that was used for the comparison.

 -- Function: make-comparator-nan-comparison-error-condition COMPARATOR
     Build and return a new condition object of type
     '&comparator-nan-comparison-error'.

 -- Function: condition-comparator-nan-comparison-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&comparator-nan-comparison-error'; otherwise return '#f'.

 -- Function: comparator-nan-comparison-error.comparator CND
     Accessor for the field of condition objects of type
     '&comparator-nan-comparison-error'.

 -- Function: raise-comparator-nan-comparison-error WHO MESSAGE
          COMPARATOR
     Raise a non-continuable exception with compound condition object of
     types: '&who', '&message', '&irritants',
     '&comparator-nan-comparison-error'.

Comparator error
................

 -- Condition Object Type: &inexact-real-comparator-with-ignored-epsilon
     Used to signal that a non-false EPSILON argument was used with a
     symbolic ROUNDING argument in the call to
     'make-inexact-real-comparator': in this case EPSILON is ignored.

     It has the following fields:

     'epsilon'
          The EPSILON argument.

     'rounding'
          The ROUNDING argument.  A symbol among: 'floor', 'ceiling',
          'truncate', 'round'.

 -- Function:
          make-inexact-real-comparator-with-ignored-epsilon-condition
          EPSILON ROUNDING
     Build and return a condition object of type
     '&inexact-real-comparator-with-ignored-epsilon'.  It is derived
     from '&warning'.

 -- Function: condition-inexact-real-comparator-with-ignored-epsilon?
          OBJ
     Return '#t' if OBJ is a condition object of type
     '&inexact-real-comparator-with-ignored-epsilon'; otherwise return
     '#f'.

 -- Function: inexact-real-comparator-with-ignored-epsilon.epsilon CND
 -- Function: inexact-real-comparator-with-ignored-epsilon.rounding CND
     Field accessors for condition object of type
     '&inexact-real-comparator-with-ignored-epsilon'.

Debug comparator error
......................

 -- Condition Object Type: &comparator-debug-error
     Used to signal errors raised by comparators returned by
     'make-debug-comparator'.  It is derived from '&comparator-error'.

     It has the following fields:

     'debug-comparator'
          The debug comparator that raised the error.

     'comparator'
          The comparator that violated the requirements.

 -- Function: make-comparator-debug-error DEBUG-COMPARATOR COMPARATOR
     Build and return a new condition object of type
     '&comparator-debug-error'.

 -- Function: comparator-debug-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&comparator-debug-error'; otherwise return '#f'.

 -- Function: comparator-debug-error.debug-comparator CND
 -- Function: comparator-debug-error.comparator CND
     Accessors for the fields of '&comparator-debug-error'.

 -- Function: raise-comparator-debug-error WHO MESSAGE DEBUG-COMPARATOR
          COMPARATOR IRRITANT ...
     Raise a non-continuable exception with compound condition object of
     types: '&who', '&message', '&comparator-debug-error', '&irritants'.


File: vicare-libs.info,  Node: srfi comparators copyright,  Prev: srfi comparators conditions,  Up: srfi comparators

2.38.19 Copyright
-----------------

Copyright (C) John Cowan 2013.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi regexps,  Next: srfi ilists,  Prev: srfi comparators,  Up: srfi

2.39 SRFI-115 regular expressions
=================================

The library '(srfi :115)' is by Alex Shinn as reference implementation
for SRFI-115; see:

           <http://srfi.schemers.org/srfi-115/srfi-115.html>

for more details.

* Menu:

* srfi regexps license::        Original document license.
* srfi regexps abstract::       Abstract.
* srfi regexps rationale::      Rationale.
* srfi regexps conventions::    Types and naming conventions.
* srfi regexps compatibility::  Compatibility levels and features.
* srfi regexps procs::          Library procedures and syntax.
* srfi regexps syntax::         SRE syntax.
* srfi regexps vicare::         About the Vicare implementation.
* srfi regexps references::     References.


File: vicare-libs.info,  Node: srfi regexps license,  Next: srfi regexps abstract,  Up: srfi regexps

2.39.1 Original document license
--------------------------------

Copyright (C) Alex Shinn 2014.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi regexps abstract,  Next: srfi regexps rationale,  Prev: srfi regexps license,  Up: srfi regexps

2.39.2 Abstract
---------------

This SRFI provides a library for matching strings with regular
expressions described using the SRE "Scheme Regular Expression" notation
first introduced by SCSH, and extended heavily by IrRegex.


File: vicare-libs.info,  Node: srfi regexps rationale,  Next: srfi regexps conventions,  Prev: srfi regexps abstract,  Up: srfi regexps

2.39.3 Rationale
----------------

Regular expressions, coming from a long history of formal language
theory, are today the lingua franca of simple string matching.  A
regular expression is an expression describing a regular language, the
simplest level in the Chomsky hierarchy.  They have the nice property
that they can match in linear time, whereas parsers for the next level
in the hierarchy require cubic time.  This combined with their
conciseness led them to be a popular choice for searching in editors,
tools and search interfaces.  Other tools may be better suited to
specific purposes, but it is assumed any modern language will provide
regular expression support.

   SREs were first introduced in SCSH as an S-expression based
alternative to the more common string based description.  This format
offers many advantages, including being easier to read and write
(notably with structured editors), easier to compose (with no escaping
issues), and faster and simpler to compile.  An efficient reference
implementation of this SRFI can be written in under 1000 lines of code,
whereas in IrRegex the full PCRE parser alone requires over 500 lines.


File: vicare-libs.info,  Node: srfi regexps conventions,  Next: srfi regexps compatibility,  Prev: srfi regexps rationale,  Up: srfi regexps

2.39.4 Types and naming conventions
-----------------------------------

We introduce two new types, 'regexp' and 'regexp-match', which are
disjoint from all other types.  We also introduce the concept of an
"SRE", which is not a disjoint type but is a Scheme object following the
specification described below.

   SRFI-14 defines the 'char-set' type, which can be used as part of an
SRE.

   In the prototypes below the following naming conventions imply type
restrictions:

CHAR-SET
     A SRFI-14 character set.

CSET-SRE
     An SRE which corresponds to matching a single character out of a
     set of characters.

END
     An exact, non-negative integer, defaulting to the '(string-length
     str)'.

FINISH
     A procedure '(lambda (i regexp-match str obj) ...)'.

OBJ
     Any object.

KNIL
     Any object.

KONS
     A procedure '(lambda (i regexp-match str obj) ...)'.

RE
     An SRE or pre-compiled regexp object.

REGEXP-MATCH
     A 'regexp-match' object from a successful match.

SRE
     An SRE as described below.

START
     An exact, non-negative integer, defaulting to '0'.

STR
     A string.

SUBST
     A symbolic expression describing a substitution template.

X-OR-FALSE
     Either an object of type 'X' or the '#f' value.


File: vicare-libs.info,  Node: srfi regexps compatibility,  Next: srfi regexps procs,  Prev: srfi regexps conventions,  Up: srfi regexps

2.39.5 Compatibility levels and features
----------------------------------------

We specify a thorough, though not exhaustive, syntax with many
extensions popular in modern regular expression libraries such as PCRE.
This is because it is assumed in many cases said libraries will be used
as the underlying implementation, the features will be desirable, and if
left unspecified people will provide their own, often incompatible,
extensions.

   On the other hand it is acknowledged that not all implementations
will be able to support all extensions.  Some are difficult to implement
for DFA implementations, and some, like 'backref', are prohibitively
expensive for any implementation.  Furthermore, even if an
implementation has Unicode support, its regexp library may not.

   To resolve these differences we divide the syntax into a minimal core
which all implementations are required to support, and additional
extensions.  In R7RS or other implementations which support SRFI-0
'cond-expand' with library level features, the availability can be
tested with the following 'cond-expand' features:

'regexp-non-greedy'
     The non-greedy repetition patterns '??', '*?', and '**?' are
     supported.

'regexp-look-around'
     The '[neg-]look-ahead' and '[neg-]look-behind' zero-width
     assertions are supported.

'regexp-backrefs'
     The 'backref' pattern is supported.

'regexp-unicode'
     Regexp character sets support Unicode.

   The first three simply refer to support for certain SRE patterns.

   'regexp-unicode' indicates support for Unicode contexts.  Toggling
between Unicode and ASCII can be done with the 'w/unicode' and 'w/ascii'
patterns.  In a Unicode context, the named character sets have their
full Unicode definition as described below and grapheme boundaries are
"extended grapheme clusters" as defined in UAX #29 (Unicode Text
Segmentation).  Implementations which provide this feature may still
support non-Unicode characters.


File: vicare-libs.info,  Node: srfi regexps procs,  Next: srfi regexps syntax,  Prev: srfi regexps compatibility,  Up: srfi regexps

2.39.6 Library procedures and syntax
------------------------------------

 -- Function: REGEXP regexp RE
     Compiles a regexp if given an object whose structure matches the
     SRE syntax.  This may be written as a literal or partial literal
     with quote or quasiquote, or may be generated entirely
     programmatically.  Return RE unmodified if it is already a regexp.
     Raise an error if RE is neither a regexp nor a valid representation
     of an SRE.

     Mutating RE may invalidate the resulting regexp, causing
     unspecified results if subsequently used for matching.

 -- Syntax: REGEXP rx SRE ...
     Macro shorthand for '(regexp `(: sre ...))'.  May be able to
     perform some or all computation at compile time if SRE is not
     unquoted.

          *NOTE* Because of this equivalence with the procedural
          constructor 'regexp', the semantics of unquote differs from
          the original SCSH implementation in that unquoted expressions
          can expand into any object matching the SRE syntax, but not a
          compiled regexp object.  Further, 'unquote' and
          'unquote-splicing' both expand all matches.

          *RATIONALE* Providing a procedural interface provides for
          greater flexibility, and without loss of potential
          compile-time optimizations by preserving the syntactic
          shorthand.  The alternative is to rely on 'eval' to
          dynamically generate regular expressions.  However regexps in
          many cases come from untrusted sources, such as search
          parameters to a server, or from serialized sources such as
          config files or command-line arguments.  Moreover many
          applications may want to keep many thousands of regexps in
          memory at once.  Given the relatively heavy cost and
          insecurity of 'eval', and the frequency with which SREs are
          read and written as text, we prefer the procedural interface.

 -- Function: SRE regexp->sre RE
     Return an SRE corresponding to the given regexp RE.  The SRE will
     be equivalent to (will match the same strings) but not necessarily
     'equal?' to the SRE originally used to compile RE.  Mutating the
     result may invalidate RE, causing unspecified results if
     subsequently used for matching.

 -- Function: SRE char-set->sre CHAR-SET
     Return an SRE corresponding to the given SRFI-14 character set.
     The resulting SRE expands the character set into notation which
     does not make use of embedded SRFI-14 character sets, and so is
     suitable for writing portably.

 -- Function: BOOLEAN valid-sre? OBJ
     Return true if, and only if, OBJ can be safely passed to 'regexp'.

 -- Function: BOOLEAN regexp? OBJ
     Return true if, and only if, OBJ is a regexp.

 -- Function: REGEXP-MATCH-OR-FALSE regexp-matches RE STR
 -- Function: REGEXP-MATCH-OR-FALSE regexp-matches RE STR START
 -- Function: REGEXP-MATCH-OR-FALSE regexp-matches RE STR START END
     Return a 'regexp-match' object if RE successfully matches the
     entire string STR from START (inclusive) to END (exclusive), or
     '#f' is the match fails.  The 'regexp-match' object will contain
     information needed to extract any submatches.

 -- Function: BOOLEAN regexp-matches? RE STR
 -- Function: BOOLEAN regexp-matches? RE STR START
 -- Function: BOOLEAN regexp-matches? RE STR START END
     Return '#t' if RE matches STR as in 'regexp-matches', or '#f'
     otherwise.  May be faster than 'regexp-matches' since it doesn't
     need to return submatch data.

 -- Function: REGEXP-MATCH-OR-FALSE regexp-search RE STR
 -- Function: REGEXP-MATCH-OR-FALSE regexp-search RE STR START
 -- Function: REGEXP-MATCH-OR-FALSE regexp-search RE STR START END
     Return a 'regexp-match' object if RE successfully matches a
     substring of STR between START (inclusive) and END (exclusive), or
     '#f' if the match fails.  The 'regexp-match' object will contain
     information needed to extract any submatches.

 -- Function: OBJ regexp-fold RE KONS KNIL STR
 -- Function: OBJ regexp-fold RE KONS KNIL STR FINISH
 -- Function: OBJ regexp-fold RE KONS KNIL STR FINISH START
 -- Function: OBJ regexp-fold RE KONS KNIL STR FINISH START END
     The fundamental regexp matching iterator.  Repeatedly search STR
     for the regexp RE so long as a match can be found.  On each
     successful match, applies:

          (KONS I REGEXP-MATCH STR ACC)

     where I is the index since the last match (beginning with START),
     REGEXP-MATCH is the resulting match, and ACC is the result of the
     previous KONS application, beginning with KNIL.  When no more
     matches can be found, calls FINISH with the same arguments, except
     that REGEXP-MATCH is '#f'.

     By default finish just returns acc.

          (regexp-fold 'word
             (lambda (i m str acc)
               (let ((s (regexp-match-submatch m 0)))
                (cond ((assoc s acc)
                       => (lambda (x) (set-cdr! x (+ 1 (cdr x))) acc))
                      (else `((,s . 1) ,@acc)))))
             '()
             "to be or not to be")
          => (("not" . 1) ("or" . 1) ("be" . 2) ("to" . 2))

 -- Function: LIST regexp-extract RE STR
 -- Function: LIST regexp-extract RE STR START
 -- Function: LIST regexp-extract RE STR START END
     Extract all the non-empty substrings of STR which match RE between
     START and END as a list of strings.

          (regexp-extract '(+ numeric) "192.168.0.1")
          => ("192" "168" "0" "1")

 -- Function: LIST regexp-split RE STR
 -- Function: LIST regexp-split RE STR START
 -- Function: LIST regexp-split RE STR START END
     Split STR into a list of strings separated by matches of RE.

          (regexp-split '(+ space) " fee fi  fo\tfum\n")
          => ("fee" "fi" "fo" "fum")

 -- Function: LIST regexp-partition RE STR
 -- Function: LIST regexp-partition RE STR START END
 -- Function: LIST regexp-partition RE STR START
     Partition STR into a list of non-empty strings matching RE,
     interspersed with the unmatched portions of the string STR.  The
     first and every odd element is an unmatched substring, which will
     be the empty string if RE matches at the beginning of the string or
     end of the previous match.  The second and every even element will
     be a substring matching RE.  If the final match ends at the end of
     the string, no trailing empty string will be included.  Thus, in
     the degenerate case where STR is the empty string, the result is
     '("")'.

          (regexp-partition '(+ (or space punct)) "")
          => ("")

          (regexp-partition '(+ (or space punct)) "Hello, world!\n")
          => ("Hello" ", " "world" "!\n")

          (regexp-partition '(+ (or space punct)) "Dnde Ests?")
          => ("" "" "Dnde" " " "Ests" "?")

 -- Function: STRING regexp-replace RE STR SUBST
 -- Function: STRING regexp-replace RE STR SUBST START
 -- Function: STRING regexp-replace RE STR SUBST START END
 -- Function: STRING regexp-replace RE STR SUBST START END COUNT
     Return a new string replacing the COUNTth match of RE in STR with
     the SUBST, where the zero-indexed COUNT defaults to zero (i.e.  the
     first match).  If there are not count matches, return the selected
     substring unmodified.

     SUBST can be a string, an integer or symbol indicating the contents
     of a numbered or named submatch of RE, 'pre' for the substring to
     the left of the match, or 'post' for the substring to the right of
     the match.

     The optional parameters START and END restrict both the matching
     and the substitution, to the given indices, such that the result is
     equivalent to omitting these parameters and replacing on
     '(substring STR START END)'.  As a convenience, a value of '#f' for
     END is equivalent to '(string-length STR)'.

          (regexp-replace '(+ space) "one two three" "_")
          => "one_two three"

          (regexp-replace '(+ space) "one two three" "_" 0 #f 0)
          => "one_two three"

          (regexp-replace '(+ space) "one two three" "_" 0 #f 1)
          => "one two_three"

          (regexp-replace '(+ space) "one two three" "_" 0 #f 2)
          => "one two three"

 -- Function: STRING regexp-replace-all RE STR SUBST
 -- Function: STRING regexp-replace-all RE STR SUBST START
 -- Function: STRING regexp-replace-all RE STR SUBST START END
     Equivalent to 'regexp-replace', but replaces all occurrences of RE
     in STR.

          (regexp-replace-all '(+ space) "one two three" "_")
          => "one_two_three"

 -- Function: BOOLEAN regexp-match? OBJ
     Return true if, and only if, OBJ is a successful match from
     'regexp-matches' or 'regexp-search'.

          (regexp-match? (regexp-matches "x" "x"))  => #t
          (regexp-match? (regexp-matches "x" "y"))  => #f

 -- Function: INTEGER regexp-match-count REGEXP-MATCH
     Return the number of submatches of 'regexp-match', regardless of
     whether they matched or not.  Do not include the implicit zero full
     match in the count.

          (regexp-match-count (regexp-matches "x" "x"))       => 0
          (regexp-match-count (regexp-matches '($ "x") "x"))  => 1

 -- Function: STRING-OR-FALSE regexp-match-submatch REGEXP-MATCH FIELD
     Return the substring matched in REGEXP-MATCH corresponding to
     FIELD, either an integer or a symbol for a named submatch.  Index
     '0' refers to the entire match, index '1' to the first
     lexicographic submatch, and so on.  If there are multiple
     submatches with the same name, the first which matched is returned.
     If passed an integer outside the range of matches, or a symbol
     which does not correspond to a named submatch of the pattern, an
     error is raised.  If the corresponding submatch did not match,
     return '#f'.

     The result of extracting a submatch after the original matched
     string has been mutated is unspecified.

          (regexp-match-submatch (regexp-search 'word "**foo**") 0)
          => "foo"

          (regexp-match-submatch
            (regexp-search '(: "*" ($ word) "*") "**foo**") 0)
          => "*foo*"

          (regexp-match-submatch
            (regexp-search '(: "*" ($ word) "*") "**foo**") 1)
          => "foo"

 -- Function: INTEGER-OR-FALSE regexp-match-submatch-start REGEXP-MATCH
          FIELD
     Return the start index in REGEXP-MATCH corresponding to FIELD, as
     in 'regexp-match-submatch'.

          (regexp-match-submatch-start
            (regexp-search 'word "**foo**") 0)
          => 2

          (regexp-match-submatch-start
            (regexp-search '(: "*" ($ word) "*") "**foo**") 0)
          => 1

          (regexp-match-submatch-start
            (regexp-search '(: "*" ($ word) "*") "**foo**") 1)
          => 2

 -- Function: INTEGER-OR-FALSE regexp-match-submatch-end REGEXP-MATCH
          FIELD
     Return the end index in REGEXP-MATCH corresponding to FIELD, as in
     'regexp-match-submatch'.

          (regexp-match-submatch-end
            (regexp-search 'word "**foo**") 0)
          => 5

          (regexp-match-submatch-end
            (regexp-search '(: "*" ($ word) "*") "**foo**") 0)
          => 6

          (regexp-match-submatch-end
            (regexp-search '(: "*" ($ word) "*") "**foo**") 1)
          => 5

 -- Function: LIST regexp-match->list REGEXP-MATCH
     Return a list of all submatches in REGEXP-MATCH as string or '#f',
     beginning with the entire match '0'.

          (regexp-match->list
            (regexp-search '(: ($ word) (+ (or space punct)) ($ word))
                           "cats & dogs"))
          => ("cats & dogs" "cats" "dogs")


File: vicare-libs.info,  Node: srfi regexps syntax,  Next: srfi regexps vicare,  Prev: srfi regexps procs,  Up: srfi regexps

2.39.7 SRE Syntax
-----------------

* Menu:

* srfi regexps syntax summary::         Summary of SRE syntax.
* srfi regexps syntax basic::           Basic patterns.
* srfi regexps syntax repeating::       Repeating patterns.
* srfi regexps syntax submatch::        Submatch patterns.
* srfi regexps syntax charsets::        Character sets.
* srfi regexps syntax named::           Named character sets.
* srfi regexps syntax boundary::        Boundary assertions.
* srfi regexps syntax nongreed::        Non-greedy patterns.
* srfi regexps syntax look::            Look around patterns.


File: vicare-libs.info,  Node: srfi regexps syntax summary,  Next: srfi regexps syntax basic,  Up: srfi regexps syntax

2.39.7.1 Summary of SRE syntax
..............................

The grammar for SREs is summarized below.  Note that an SRE is a
first-class object consisting of nested lists of strings, chars,
'char-set's, symbols and numbers.  Where the syntax is described as
'(foo bar)', this can be constructed equivalently as '(quote (foo bar))'
or '(list 'foo 'bar)', etc.  The following sections explain the
semantics in greater detail.

     <sre> ::=
      | <string>                    ; A literal string match.
      | <cset-sre>                  ; A character set match.
      | (* <sre> ...)               ; 0 or more matches.
      | (zero-or-more <sre> ...)
      | (+ <sre> ...)               ; 1 or more matches.
      | (one-or-more <sre> ...)
      | (? <sre> ...)               ; 0 or 1 matches.
      | (optional <sre> ...)
      | (= <n> <sre> ...)           ; <n> matches.
      | (exactly <n> <sre> ...)
      | (>= <n> <sre> ...)          ; <n> or more matches.
      | (at-least <n> <sre> ...)
      | (** <n> <m> <sre> ...)      ; <n> to <m> matches.
      | (repeated <n> <m> <sre> ...)

      | (|  <sre> ...)              ; Alternation.
      | (or <sre> ...)

      | (:   <sre> ...)             ; Sequence.
      | (seq <sre> ...)
      | ($ <sre> ...)               ; Numbered submatch.
      | (submatch <sre> ...)
      | (-> <name> <sre> ...)               ;  Named submatch.  <name> is
      | (submatch-named <name> <sre> ...)   ;  a symbol.

      | (w/case   <sre> ...)        ; Introduce a case-sensitive context.
      | (w/nocase <sre> ...)        ; Introduce a case-insensitive context.

      | (w/unicode   <sre> ...)     ; Introduce a unicode context.
      | (w/ascii <sre> ...)         ; Introduce an ascii context.

      | (w/nocapture <sre> ...)     ; Ignore all enclosed submatches.

      | bos                         ; Beginning of string.
      | eos                         ; End of string.

      | bol                         ; Beginning of line.
      | eol                         ; End of line.

      | bog                         ; Beginning of grapheme cluster.
      | eog                         ; End of grapheme cluster.
      | grapheme                    ; A single grapheme cluster.

      | bow                         ; Beginning of word.
      | eow                         ; End of word.
      | nwb                         ; A non-word boundary.
      | (word <sre> ...)            ; An SRE wrapped in word boundaries.
      | (word+ <cset-sre> ...)      ; A single word restricted to a cset.
      | word                        ; A single word.

      | (?? <sre> ...)              ; A non-greedy pattern, 0 or 1 match.
      | (non-greedy-optional <sre> ...)
      | (*? <sre> ...)              ; Non-greedy 0 or more matches.
      | (non-greedy-zero-or-more <sre> ...)
      | (**? <m> <n> <sre> ...)     ; Non-greedy <m> to <n> matches.
      | (non-greedy-repeated <sre> ...)
      | (look-ahead <sre> ...)      ; Zero-width look-ahead assertion.
      | (look-behind <sre> ...)     ; Zero-width look-behind assertion.
      | (neg-look-ahead <sre> ...)  ; Zero-width negative look-ahead assertion.
      | (neg-look-behind <sre> ...) ; Zero-width negative look-behind assertion.

      | (backref <n-or-name>)       ; Match a previous submatch.

   The grammar for 'cset-sre' is as follows.

     <cset-sre> ::=
      | <char>                      ; literal char
      | "<char>"                    ; string of one char
      | <char-set>                  ; embedded SRFI 14 char set
      | (<string>)                  ; literal char set
      | (char-set <string>)
      | (/ <range-spec> ...)        ; ranges
      | (char-range <range-spec> ...)
      | (or <cset-sre> ...)         ; union
      | (and <cset-sre> ...)        ; intersection
      | (- <cset-sre> ...)          ; difference
      | (- <difference> ...)
      | (~ <cset-sre> ...)          ; complement of union
      | (complement <cset-sre> ...)
      | (w/case <cset-sre> ...)     ; case and unicode toggling
      | (w/nocase <cset-sre> ...)
      | (w/ascii <cset-sre> ...)
      | (w/unicode <cset-sre> ...)
      | any | nonl | ascii | lower-case | lower
      | upper-case | upper | title-case | title
      | alphabetic | alpha | alphanumeric | alphanum | alnum
      | numeric | num | punctuation | punct | symbol
      | graphic | graph | whitespace | white | space
      | printing | print | control | cntrl | hex-digit | xdigit

     <range-spec> ::= <string> | <char>


File: vicare-libs.info,  Node: srfi regexps syntax basic,  Next: srfi regexps syntax repeating,  Prev: srfi regexps syntax summary,  Up: srfi regexps syntax

2.39.7.2 Basic patterns
.......................

'<string>'
     A literal string.

          (regexp-search "needle" "hayneedlehay") => #<regexp-match>
          (regexp-search "needle" "haynEEdlehay") => #f

'(seq sre ...)'
'(: sre ...)'
     Sequencing.  Matches if each of sre matches adjacently in order.

          (regexp-search '(: "one" space "two" space "three")
                         "one two three")
          => #<regexp-match>

'(or sre ...)'
'(|\|| sre ...)'
     Alternation.  Matches if any of sre match.

          (regexp-search '(or "eeney" "meeney" "miney") "meeney")
          => #<regexp-match>
          (regexp-search '(or "eeney" "meeney" "miney") "moe")
          => #f

          *NOTE* The syntax '|\||' is *not* supported by Vicare.

'(w/nocase sre ...)'
     Enclosed sres are case-insensitive.  In a Unicode context character
     and string literals match with the default simple Unicode
     case-insensitive matching.  Implementations may, but are not
     required to, handle variable length case conversions, such as
     '#\x00DF' matching the two characters 'SS'.

     Character sets match if any character in the set matches
     case-insensitively to the input.  Conceptually each CSET-SRE is
     expanded to contain all case variants for all of its characters.
     In a compound CSET-SRE the expansion is applied at the terminals
     consisting of characters, strings, embedded SRFI-14 'char-set's,
     and named character sets.  For simple unions this would be
     equivalent to computing the full union first and then expanding
     case variants, but the semantics can differ when differences and
     intersections are applied.  For example:

          (w/nocase (~ ("Aab")))

     is equivalent to:

          (~ ("AaBb"))

     for which 'B' is clearly not a member.  However if you were to
     compute '(~ ("Aab"))' first then you would have a 'char-set'
     containing 'B', and after expanding case variants both 'B' and 'b'
     would be members.

     In an ASCII context only the 52 ASCII letters '(/ "a-zA-Z")' match
     case-insensitively to each other.

     In a Unicode context the only named CSET-SRE which are affected by
     'w/nocase' are upper and lower.  Note that the case insensitive
     versions of these are not equivalent to letter as there are
     characters with the letter property but no case.

          (regexp-search "needle" "haynEEdlehay")
          => #f
          (regexp-search '(w/nocase "needle") "haynEEdlehay")
          => #<regexp-match>

          (regexp-search '(~ ("Aab")) "B") => #<regexp-match>
          (regexp-search '(~ ("Aab")) "b") => #f
          (regexp-search '(w/nocase (~ ("Aab"))) "B") => #f
          (regexp-search '(w/nocase (~ ("Aab"))) "b") => #f
          (regexp-search '(~ (w/nocase ("Aab"))) "B") => #f
          (regexp-search '(~ (w/nocase ("Aab"))) "b") => #f

'(w/case sre ...)'
     Enclosed sres are case-sensitive.  This is the default, and
     overrides any enclosing 'w/nocase' setting.

          (regexp-search '(w/nocase "SMALL" (w/case "BIG"))
                         "smallBIGsmall")
          => #<regexp-match>

          (regexp-search '(w/nocase (~ (w/case ("Aab")))) "b")
          => #f

'(w/ascii sre ...)'
     Enclosed sres are interpreted in an ASCII context.  In practice
     many regular expressions are used for simple parsing and only ASCII
     characters are relevant.  Switching to ASCII mode can improve
     performance in some implementations.

          (regexp-search '(w/ascii bos (* alpha) eos) "English")
          => #<regexp-match>

'(w/unicode sre ...)'
     Enclosed sres are interpreted in a Unicode context; character sets
     with both an ASCII and Unicode definition take the latter.  Has no
     effect if the 'regexp-unicode' feature is not provided.  This is
     the default.

          (regexp-search '(w/unicode bos (* letter) eos) "English")
          => #<regexp-match>

'(w/nocapture sre ...)'
     Disables capturing for all submatches ('$', 'submatch', '->' and
     'submatch-named') in the enclosed sres.  The resulting SRE matches
     exactly the same strings, but without any associated submatch info.
     Useful for utility SREs which you want to incorporate without
     affecting your submatch positions.

          (let ((number '($ (+ digit))))
            (cdr
             (regexp-match->list
              (regexp-search `(: ,number "-" ,number "-" ,number)
                             "555-867-5309")))
            => ("555" "867" "5309")

            (cdr
             (regexp-match->list
              (regexp-search `(: ,number "-" (w/nocapture ,number) "-" ,number)
                             "555-867-5309"))))
            => ("555" "5309")


File: vicare-libs.info,  Node: srfi regexps syntax repeating,  Next: srfi regexps syntax submatch,  Prev: srfi regexps syntax basic,  Up: srfi regexps syntax

2.39.7.3 Repeating patterns
...........................

'(optional sre ...)'
'(? sre ...)'
     An optional pattern; matches 1 or 0 times.

          (regexp-search '(: "match" (? "es") "!") "matches!")
          => #<regexp-match>

          (regexp-search '(: "match" (? "es") "!") "match!")
          => #<regexp-match>

          (regexp-search '(: "match" (? "es") "!") "matche!")
          => #f

'(zero-or-more sre ...)'
'(* sre ...)'
     Kleene star; matches 0 or more times.

          (regexp-search '(: "<" (* (~ #\>)) ">") "<html>")
          => #<regexp-match>

          (regexp-search '(: "<" (* (~ #\>)) ">") "<>")
          => #<regexp-match>

          (regexp-search '(: "<" (* (~ #\>)) ">") "<html")
          => #f

'(one-or-more sre ...)'
'(+ sre ...)'
     1 or more matches.  Like '*' but requires at least a single match.

          (regexp-search '(: "<" (+ (~ #\>)) ">") "<html>")
          => #<regexp-match>

          (regexp-search '(: "<" (+ (~ #\>)) ">") "<a>")
          => #<regexp-match>

          (regexp-search '(: "<" (+ (~ #\>)) ">") "<>")
          => #f

'(at-least n sre ...)'
'(>= n sre ...)'
     More generally, N or more matches.

          (regexp-search '(: "<" (>= 3 (~ #\>)) ">") "<table>")
          => #<regexp-match>

          (regexp-search '(: "<" (>= 3 (~ #\>)) ">") "<pre>")
          => #<regexp-match>

          (regexp-search '(: "<" (>= 3 (~ #\>)) ">") "<tr>")
          => #f

'(exactly n sre ...)'
'(= n sre ...)'
     Exactly N matches.

          (regexp-search '(: "<" (= 4 (~ #\>)) ">") "<html>")
          => #<regexp-match>

          (regexp-search '(: "<" (= 4 (~ #\>)) ">") "<table>")
          => #f

'(repeated from to sre ...)'
'(** from to sre ...)'
     The most general form, from N to M matches, inclusive.

          (regexp-search '(: (= 3 (** 1 3 numeric) ".") (** 1 3 numeric))
                         "192.168.1.10")
          => #<regexp-match>

          (regexp-search '(: (= 3 (** 1 3 numeric) ".") (** 1 3 numeric))
                         "192.0168.1.10")
          => #f


File: vicare-libs.info,  Node: srfi regexps syntax submatch,  Next: srfi regexps syntax charsets,  Prev: srfi regexps syntax repeating,  Up: srfi regexps syntax

2.39.7.4 Submatch Patterns
..........................

'(submatch sre ...)'
'($ sre ...)'
     A numbered submatch.  The contents matching the pattern will be
     available in the resulting 'regexp-match'.

'(submatch-named name sre ...)'
'(-> name sre ...)'
     A named submatch.  Behaves just like 'submatch', but the field may
     also be referred to by name.

'(backref n-or-name)'
     Optional: match a previously matched submatch.  The feature
     'regexp-backrefs' will be provided if this pattern is supported.
     Back-references are expensive, and can trivially be shown to be
     NP-hard, so one should avoid their use even in implementations
     which support them.


File: vicare-libs.info,  Node: srfi regexps syntax charsets,  Next: srfi regexps syntax named,  Prev: srfi regexps syntax submatch,  Up: srfi regexps syntax

2.39.7.5 Character sets
.......................

A character set pattern matches a single character.

'<char>'
     A singleton char set.

          (regexp-matches '(* #\-) "---")  => #<regexp-match>
          (regexp-matches '(* #\-) "-_-")  => #f

'"<char>"'
     A singleton char set written as a string of length one rather than
     a character.  Equivalent to its interpretation as a literal string
     match, but included to clarify it can be composed in CSET-SREs.

'<char-set>'
     A SRFI-14 character set, which matches any character in the set.
     Note that currently there is no portable written representation of
     SRFI-14 character sets, which means that this pattern is typically
     generated programmatically, such as with a quasiquoted expression.

          (regexp-partition `(+ ,char-set:vowels) "vowels")
          => ("v" "o" "w" "e" "ls")

          *RATIONALE* Many useful character sets are likely to be
          available as SRFI-14 'char-set's, so it is desirable to reuse
          them in regular expressions.  Since many Unicode character
          sets are extremely large, converting back and forth between an
          internal and external representation can be expensive, so the
          option of direct embedding is necessary.  When a readable
          external representation is needed, 'char-set->sre' can be
          used.

'(char-set <string>)'
'(<string>)'
     The set of chars as formed by SRFI-14:

          (string->char-set <string>)

     Note that 'char-set's contain code points, not grapheme clusters,
     so any combining characters in '<string>' will be inserted
     separately from any preceding base characters by
     'string->char-set'.

          (regexp-matches '(* ("aeiou")) "oui")       => #<regexp-match>
          (regexp-matches '(* ("aeiou")) "ouais")     => #f
          (regexp-matches '(* ("e\x0301")) "e\x0301") => #<regexp-match>
          (regexp-matches '("e\x0301") "e\x0301")     => #f
          (regexp-matches '("e\x0301") "e")           => #<regexp-match>
          (regexp-matches '("e\x0301") "\x0301")      => #<regexp-match>
          (regexp-matches '("e\x0301") "\x00E9")      => #f

'(char-range <range-spec> ...)'
'(/ <range-spec> ...)'
     Ranged char set.  The '<range-spec>' is a list of strings and
     characters.  These are flattened and grouped into pairs of
     characters, and all ranges formed by the pairs are included in the
     char set.

          (regexp-matches '(* (/ "AZ09")) "R2D2")  => #<regexp-match>
          (regexp-matches '(* (/ "AZ09")) "C-3PO") => #f

'(or <cset-sre> ...)'
'(|\|| <cset-sre> ...)'
     Char set union.  The single vertical bar form is provided for
     consistency and compatibility with SCSH, although it needs to be
     escaped in R7RS.

          *NOTE* The syntax '|\||' is *not* supported by Vicare.

'(complement <cset-sre> ...)'
'(~ <cset-sre> ...)'
     Char set complement (i.e.  '[^...]' in PCRE notation).  '(~ x)' is
     equivalent to '(- any x)', thus in an ASCII context the complement
     is always ASCII.

'(difference <cset-sre> ...)'
'(- <cset-sre> ...)'
     Char set difference.

          (regexp-matches '(* (- (/ "az") ("aeiou"))) "xyzzy")
          => #<regexp-match>

          (regexp-matches '(* (- (/ "az") ("aeiou"))) "vowels")
          => #f

'(and <cset-sre> ...)'
'(& <cset-sre> ...)'
     Char set intersection.

          (regexp-matches '(* (& (/ "az") (~ ("aeiou")))) "xyzzy")
          => #<regexp-match>

          (regexp-matches '(* (& (/ "az") (~ ("aeiou")))) "vowels")
           => #f


File: vicare-libs.info,  Node: srfi regexps syntax named,  Next: srfi regexps syntax boundary,  Prev: srfi regexps syntax charsets,  Up: srfi regexps syntax

2.39.7.6 Named character sets
.............................

'any'
     Match any character.  Equivalent to 'ascii' in an ASCII context.

'nonl'
     Match any character other than '#\return' or '#\newline'.

'ascii'
     Match any ASCII character [0, 127].

'lower-case'
'lower'
     Matches any character for which 'char-lower-case?' returns true.
     In a Unicode context this corresponds to the 'Lowercase' ('Ll' +
     'Other_Lowercase') property.  In an ASCII context corresponds to
     '(/ "az")'.

'upper-case'
'upper'
     Matches any character for which 'char-upper-case?' returns true.
     In a Unicode context this corresponds to the 'Uppercase' ('Lu' +
     'Other_Uppercase') property.  In an ASCII context corresponds to
     '(/ "AZ")'.

'title-case'
'title'
     Matches any character with the Unicode 'Titlecase' ('Lt') property.
     This property only exists for the sake of ligature characters, of
     which only 31 exist at time of writing.  In an ASCII context this
     is empty.

'alphabetic'
'alpha'
     Matches any character for which 'char-alphabetic?' returns true.
     In a Unicode context this corresponds to the 'Alphabetic' ('L' +
     'Nl' + 'Other_Alphabetic') property.  In an ASCII context
     corresponds to '(w/nocase (/ "az"))'.

'numeric'
'num'
     Matches any character for which 'char-numeric?' returns true.  In a
     Unicode context this corresponds to the 'Numeric_Digit' ('Nd')
     property.  In an ASCII context corresponds to '(/ "09")'.

'alphanumeric'
'alphanum'
'alnum'
     Matches any character which is either a letter or number.
     Equivalent to '(or alphabetic numeric)'.

'punctuation'
'punct'
     Matches any punctuation character.  In a Unicode context this
     corresponds to the 'Punctuation' ('P') property.  In an ASCII
     context this corresponds to '"!\"#%&'()*,-./:;?@[\]_{}"'.

'symbol'
     Matches any symbol character.  In a Unicode context this
     corresponds to the 'Symbol' property ('Sm', 'Sc', 'Sk', or 'So').
     In an ASCII context this corresponds to '"$+<=>^`|~"'.

'graphic'
'graph'
     Matches any graphic character.  Equivalent to '(or alphanumeric
     punctuation symbol)'.

'whitespace'
'white'
'space'
     Matches any whitespace character.  In a Unicode context this
     corresponds to the 'Separator' property ('Zs', 'Zl' or 'Zp').  In
     an ASCII context this corresponds to space, tab, line feed, form
     feed, and carriage return.

'printing'
'print'
     Matches any printing character.  Equivalent to '(or graphic
     whitespace)'.

'control'
'cntrl'
     Matches any control or other character.  In a Unicode context this
     corresponds to the 'Other' property ('Cc', 'Cf', 'Co', 'Cs' or
     'Cn').  In an ASCII context this corresponds to:

          `(/ ,(integer->char 0) ,(integer-char 31))

'hex-digit'
'xdigit'
     Matches any valid digit in hexadecimal notation.  Always
     ASCII-only.  Equivalent to:

          (w/ascii (w/nocase (or numeric "abcdef")))


File: vicare-libs.info,  Node: srfi regexps syntax boundary,  Next: srfi regexps syntax nongreed,  Prev: srfi regexps syntax named,  Up: srfi regexps syntax

2.39.7.7 Boundary assertions
............................

'bos'
'eos'
     Matches at the beginning/end of string without consuming any
     characters (a zero-width assertion).  If the search was initiated
     with START/END parameters, these are considered the end points,
     rather than the full string.

'bol'
'eol'
     Matches at the beginning/end of a line without consuming any
     characters (a zero-width assertion).  A line is a possibly empty
     sequence of characters followed by an end of line sequence as
     understood by the R7RS 'read-line' procedure, specifically any of a
     linefeed character, carriage return character, or a carriage return
     followed by a linefeed character.  The string is assumed to contain
     end of line sequences before the start and after the end of the
     string, even if the search was made on a substring and the actual
     surrounding characters differ.

'bow'
'eow'
     Matches at the beginning/end of a word without consuming any
     characters (a zero-width assertion).  A word is a contiguous
     sequence of characters that are either alphanumeric or the
     underscore character, i.e.  (or alphanumeric '_'), with the
     definition of alphanumeric depending on the Unicode or ASCII
     context.  The string is assumed to contain non-word characters
     immediately before the start and after the end, even if the search
     was made on a substring and word constituent characters appear
     immediately before the beginning or after the end.

          (regexp-search '(: bow "foo") "foo")    => #<regexp-match>
          (regexp-search '(: bow "foo") "")       => #<regexp-match>
          (regexp-search '(: bow "foo") "snafoo") => #f
          (regexp-search '(: "foo" eow) "foo")    => #<regexp-match>
          (regexp-search '(: "foo" eow) "foo!")   => #<regexp-match>
          (regexp-search '(: "foo" eow) "foobar") => #f

'nwb'
     Matches a non-word-boundary (i.e.  '\B' in PCRE). Equivalent to
     '(neg-look-ahead (or bow eow))'.

'(word sre ...)'
     Anchors a sequence to word boundaries.  Equivalent to '(: bow sre
     ... eow)'.

'(word+ cset-sre ...)'
     Matches a single word composed of characters in the intersection of
     the given CSET-SRE and the word constituent characters.  Equivalent
     to:

          (word (+ (and (or alphanumeric "_") (or cset-sre ...))))

'word'
     A shorthand for '(word+ any)'.

'bog'
'eog'
     Matches at the beginning/end of a single extended grapheme cluster
     without consuming any characters (a zero-width assertion).
     Grapheme cluster boundaries are defined in Unicode TR29.  The
     string is assumed to contain non-combining code-points immediately
     before the start and after the end.  These always succeed in an
     ASCII context.

'grapheme'
     Matches a single grapheme cluster (i.e.  '\X' in PCRE). This is
     what the end-user typically thinks of as a single character,
     comprised of a base non-combining code-point followed by zero or
     more combining marks.  In an ASCII context this is equivalent to
     any.

     Assuming 'char-set:mark' contains all characters with the 'Extend'
     or 'SpacingMark' properties defined in TR29, and
     'char-set:control', 'char-set:regional-indicator' and
     'char-set:hangul-*' are defined similarly, then the following SRE
     can be used with 'regexp-extract' to define grapheme:

          `(or (: (* ,char-set:hangul-l) (+ ,char-set:hangul-v)
                  (* ,char-set:hangul-t))
               (: (* ,char-set:hangul-l) ,char-set:hangul-v
                  (* ,char-set:hangul-v) (* ,char-set:hangul-t))
               (: (* ,char-set:hangul-l) ,char-set:hangul-lvt
                  (* ,char-set:hangul-t))
               (+ ,char-set:hangul-l)
               (+ ,char-set:hangul-t)
               (+ ,char-set:regional-indicator)
               (: "\r\n")
               (: (~ control ("\r\n"))
                  (+ ,char-set:mark))
               control)


File: vicare-libs.info,  Node: srfi regexps syntax nongreed,  Next: srfi regexps syntax look,  Prev: srfi regexps syntax boundary,  Up: srfi regexps syntax

2.39.7.8 Non-greedy patterns
............................

The following patterns are only supported if the feature
'regexp-non-greedy' is provided.

'(non-greedy-optional sre ...)'
'(?? sre ...)'
     Non-greedy pattern, matches 0 or 1 times, preferring the shorter
     match.

'(non-greedy-zero-or-more< sre ...)'
'(*? sre ...)'
     Non-greedy Kleene star, matches 0 or more times, preferring the
     shorter match.

'(non-greedy-repeated m n sre ...)'
'(**? m n sre ...)'
     Non-greedy Kleene star, matches M to N times, preferring the
     shorter match.


File: vicare-libs.info,  Node: srfi regexps syntax look,  Prev: srfi regexps syntax nongreed,  Up: srfi regexps syntax

2.39.7.9 Look around patterns
.............................

The following patterns are only supported if the feature
'regexp-look-around' is provided.

'(look-ahead sre ...)'
     Zero-width look-ahead assertion.  Asserts the sequence matches from
     the current position, without advancing the position.

          (regexp-matches '(: "regular" (look-ahead " expression")
                              " expression")
                          "regular expression")
          => #<regexp-match>

          (regexp-matches '(: "regular" (look-ahead " ") "expression")
                              "regular expression")
          => #f

'(look-behind sre ...)'
     Zero-width look-behind assertion.  Asserts the sequence matches
     behind the current position, without advancing the position.  It is
     an error if the sequence does not have a fixed length.

'(neg-look-ahead sre ...)'
     Zero-width negative look-ahead assertion.

'(neg-look-behind sre ...)'
     Zero-width negative look-behind assertion.


File: vicare-libs.info,  Node: srfi regexps vicare,  Next: srfi regexps references,  Prev: srfi regexps syntax,  Up: srfi regexps

2.39.8 About the Vicare implementation
--------------------------------------

The SRFI-115 implementation distributed with Vicare is derived from the
library '(chibi regexp)' distributed with Chibi Scheme
(https://github.com/ashinn/chibi-scheme), by Alex Shinn.  It has the
following limitations:

   * The syntax '|\||' is *not* supported.  So '(|\|| sre ...)' cannot
     be used as alias for '(or sre ...)'; '(|\|| cset-sre ...)' cannot
     be used as alias for '(or cset-sre ...)'.

   * Non-greedy patterns are not implemented.

   * Look-around patterns are not implemented.


File: vicare-libs.info,  Node: srfi regexps references,  Prev: srfi regexps vicare,  Up: srfi regexps

2.39.9 References
-----------------

[R7RS] Alex Shinn, John Cowan, Arthur Gleckler, "Revised7 Report on the
Algorithmic Language Scheme".
<http://trac.sacrideo.us/wg/raw-attachment/wiki/WikiStart/r7rs.pdf>.

   [SCSH] Olin Shivers, "A Scheme Shell".  Massachusetts Institute of
Technology Cambridge, MA, USA, 1994.
<http://www.scsh.net/docu/scsh-paper/scsh-paper.html>.

   [IrRegex] Alex Shinn, "IrRegex - IrRegular Expressions".
<http://synthcode.com/scheme/irregex/>.

   [TR18] Mark Davis, Andy Heninger, "UTR #18: Unicode Regular
Expressions".  <http://www.unicode.org/reports/tr18/>.

   [UAX29] Mark Davis, "UAX #29: Unicode Text Segmentation".
<http://www.unicode.org/reports/tr29/>.

   [SRFI 0] Marc Feeley, "Feature-based conditional expansion
construct".  <http://srfi.schemers.org/srfi-0/srfi-0.html>.

   [SRFI 14] Olin Shivers, "Character-set Library".
<http://srfi.schemers.org/srfi-14/srfi-14.html>.

   [ImplementingRegexps] Russ Cox, "Implementing Regular Expressions".
<http://swtch.com/~rsc/regexp/>.

   [Tcl] Russ Cox, Henry Spencer's Tcl Regex Library.
<http://compilers.iecc.com/comparch/article/07-10-026>

   [Gauche] Shiro Kawai, Gauche Scheme - Regular Expressions.
<http://practical-scheme.net/gauche/man/?p=Regular+expressions>.

   [Perl6] Damian Conway, Perl6 Exegesis 5 - Regular Expressions.
<http://www.perl.com/pub/a/2002/08/22/exegesis5.html>.

   [PCRE] Philip Hazel, PCRE - Perl Compatible Regular Expressions.
<http://www.pcre.org/>


File: vicare-libs.info,  Node: srfi ilists,  Prev: srfi regexps,  Up: srfi

2.40 SRFI-116 immutable lists
=============================

The library '(srfi :116)' is by John Cowan as reference implementation
for SRFI-116; see:

           <http://srfi.schemers.org/srfi-116/srfi-116.html>

for more details.  The comparators API is exported by the library '(srfi
:116 comparators)'.

* Menu:

* srfi ilists license::         Original document license.
* srfi ilists abstract::        Abstract.
* srfi ilists rationale::       Rationale.
* srfi ilists discussion::      Discussion.
* srfi ilists quotation::       Quotation.
* srfi ilists procs::           Procedures.
* srfi ilists ack::             Acknowledgements.
* srfi ilists references::      References.


File: vicare-libs.info,  Node: srfi ilists license,  Next: srfi ilists abstract,  Up: srfi ilists

2.40.1 Original document license
--------------------------------

Copyright (C) John Cowan 2014.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi ilists abstract,  Next: srfi ilists rationale,  Prev: srfi ilists license,  Up: srfi ilists

2.40.2 Abstract
---------------

Scheme currently does not provide immutable pairs corresponding to its
existing mutable pairs, although most uses of pairs do not exploit their
mutability.  The Racket system takes the radical approach of making
Scheme's pairs immutable, and providing a minimal library of mutable
pairs with procedures named 'mpair?', 'mcons', 'mcar', 'mcdr',
'set-mcar!', 'set-mcdr!'.  This SRFI takes the opposite approach of
leaving Scheme's pairs unchanged and providing a full set of routines
for creating and dealing with immutable pairs.  The sample
implementation is portable (to systems with SRFI-9) and efficient.


File: vicare-libs.info,  Node: srfi ilists rationale,  Next: srfi ilists discussion,  Prev: srfi ilists abstract,  Up: srfi ilists

2.40.3 Rationale
----------------

The first question about this library is why it should exist at all.
Why not simply eliminate mutability from Scheme's ordinary pairs and use
a version of SRFI-1 that treats the linear-update procedures (with '!')
as identical to their functional counterparts, as Racket does?  The main
answer is that this approach breaks R5RS and R6RS-small.  All the data
structures in these versions of Scheme are inherently mutable, and
portable code is allowed to depend on that property.

   R6RS segregates 'set-car!' and 'set-cdr!' into a separate library,
thus allowing implementations to provide immutable Scheme pairs if this
library is not (transitively) imported into a program, and mutable ones
if it is.  However, it is not possible to write portable R6RS programs
that differentiate between mutable and immutable pairs, for example by
using immutable pairs most of the time and mutable pairs where
necessary.

   Because of the Liskov Substitution Principle, it is not possible to
treat mutable pairs as either a subtype or a supertype of mutable ones;
they must be distinct, and if operations are to apply to both, they can
do so only by ad hoc polymorphism of the kind that Scheme traditionally
avoids for several reasons, including clarity, efficiency, and
flexibility.  This proposal, therefore, treats mutable and immutable
pairs separately, while allowing easy conversion from one to the other.

   Rather than attempting to design this library from scratch, I have
chosen the conservative option of modifying SRFI-1.  Consequently, most
of the rationale given in that document applies to this one as well.  I
have made the following changes:

   * Removed all linear-update procedures ending in '!'.

   * Removed all references to circular lists (there will be a future
     SRFI for immutable bidirectional cycles).

   * Removed the O(n^2) lists-as-sets procedures (there will be a future
     SRFI supporting O(log n) immutable sets).

   * Inserted an 'i' at a judicious place in each identifier, usually at
     the beginning.  However, because "icons" means something else in
     both ordinary English and computer jargon, the basic constructor
     and its immediate relatives are named 'ipair', 'xipair' and
     'ipair*' instead.

   * Added procedures for conversion between ordinary and immutable
     pairs, lists, and trees.

   * Added an analogue of 'apply' for applying a procedure to an
     immutable list of arguments.

   * Added SRFI-114 comparators for immutable pairs, lists, and dotted
     lists.

     *NOTE* In the prose, immutable pairs and lists are known as
     _ipairs_ and _ilists_ throughout.


File: vicare-libs.info,  Node: srfi ilists discussion,  Next: srfi ilists quotation,  Prev: srfi ilists rationale,  Up: srfi ilists

2.40.4 Discussion
-----------------

A set of general criteria guided the design of the SRFI-1 library that
underlies this library.  They are reproduced here.

   List-filtering procedures such as 'ifilter' or 'idelete' do not
disorder lists.  Elements appear in the answer list in the same order as
they appear in the argument list.  This constrains implementation, but
seems like a desirable feature, since in many uses of lists, order
matters.  (In particular, disordering an association list is definitely
a bad idea.)

   Contrariwise, although the sample implementations of the
list-filtering procedures share longest common tails between argument
and answer lists, it is not part of the spec.

   Because ilists are an inherently sequential data structure (unlike,
say, vectors), inspection procedures such as 'ifind', 'ifind-tail',
'ifor-each', 'iany' and 'ievery' commit to a left-to-right traversal
order of their argument list.

   However, constructors, such as 'ilist-tabulate' and the mapping
procedures ('iappend-map', 'ipair-for-each', 'ifilter-map',
'imap-in-order'), do not specify the dynamic order in which their
procedural argument is applied to its various values.

   Predicates return useful true values wherever possible.  Thus 'iany'
must return the true value produced by its predicate, and 'ievery'
returns the final true value produced by applying its predicate argument
to the last element of its argument list.

   No special status is accorded Scheme's built-in equality predicate.
Any functionality provided in terms of 'eq?', 'eqv?', 'equal?' is also
available using a client-provided equality predicate.

   These procedures are not generic as between ordinary pairs/lists and
immutable pairs/lists; they are specific to immutable lists.  Like Olin,
I prefer to keep the library simple and focused.  However, there are a
few conversions between mutable and immutable lists provided.

Improper Lists
..............

Scheme does not properly have a list type, just as C does not have a
string type.  Rather, Scheme has a binary-tuple type, from which one can
build binary trees.  There is an interpretation of Scheme values that
allows one to treat these trees as lists.  The same interpretation is
applied to immutable pairs.

   Because the empty list, written as '()', is already immutable, it is
shared between mutable and immutable lists as the termination marker.
It is the only Scheme object that is both a mutable list and an
immutable list.

   Users should note that dotted lists, whether mutable or immutable,
are not commonly used, and are considered by many Scheme programmers to
be an ugly artifact of Scheme's lack of a true list type.  Dotted ilists
are not fully supported by this SRFI.  Most procedures are defined only
on proper ilists that is, '()'-terminated ilists.  The procedures that
will also handle dotted ilists are specifically marked.  While this
design decision restricts the domain of possible arguments one can pass
to these procedures, it has the benefit of allowing the procedures to
catch the error cases where programmers inadvertently pass scalar values
to an ilist procedure by accident, e.g., by switching the arguments to a
procedure call.


File: vicare-libs.info,  Node: srfi ilists quotation,  Next: srfi ilists procs,  Prev: srfi ilists discussion,  Up: srfi ilists

2.40.5 Quotation
----------------

The various Scheme standards permit, but do not require, Scheme
implementations to treat quoted pairs and lists as immutable.  Thus
whereas the expression '(set-car! (list 1 2 3) 10)' evaluates to the
list '(10 2 3)', the expression '(set-car! '(1 2 3) 10)' is not portable
and in fact an error.

   This SRFI recommends that implementations that provide both this SRFI
and immutable quotations should cause quotations to return the same
immutable pairs that this SRFI describes.  This means that the standard
Scheme pair and list operations, as well as libraries like SRFI-1 which
are built on them, should accept both mutable and immutable pairs: thus
'(car (ilist 1 2))' should evaluate to '1'.

   This SRFI further recommends that 'read' should return mutable pairs
and lists when reading list structure.  No recommendation is made about
the behavior of 'write', 'display', and similar output procedures on
immutable lists.

 -- Syntax: iq ?DATUM ...
     To make life easier for Scheme programmers, given that many
     implementations do not provide immutable quotation, the syntax
     keyword 'iq' is provided as part of this SRFI.

     It is analogous to 'quote', but takes an arbitrary number of
     literals and constructing an ilist from them, with any pairs in the
     literals converted to ipairs.  It is useful for providing constant
     ipair-based objects.

          (iq)            == '()
          (iq 1)          == (ilist '1)
          (iq (1))        == (ilist (ilist '1))
          (iq 1 . 2)      == (ipair '1 '2)
          (iq 1 2)        == (ilist '1 '2)
          (iq 1 2 3)      == (ilist '1 '2 '3)

          (iq (1) 2 3)    == (ilist (ilist '1) '2 '3)
          (iq 1 (2) 3)    == (ilist '1 (ilist '2) '3)
          (iq 1 2 (3))    == (ilist '1 '2 (ilist '3))

          (iq (1 2) 3)    == (ilist (ilist '1 '2) '3)
          (iq 1 (2 3))    == (ilist '1 (ilist '2 '3))

          (iq (x y) z)    == (ilist (ilist 'x 'y) 'z)
          (iq x (y z))    == (ilist 'x (ilist 'y 'z))

     Note that pairs within literal vectors or other
     implementation-dependent literals will not be converted:

          (iq #(1 2))     == (ilist '#(1 2))
          (iq #(1 (2)))   == (ilist '#(1 (2)))

     see how the second example contains an implementation-dependent
     list '(2)' rather than an ilist object.

     Unfortunately, there is no ilist analogue of ''' to abbreviate the
     notation, so we save keystrokes by using 'iq' (rather than
     'iquote') and omitting the top-level parentheses.

          (define L
            (iq 1 2 3))

          (icar L)        => 1
          (icadr L)       => 2
          (icaddr L)      => 3

          (define P
            (iq 1 . 2))

          (icar P)        => 1
          (icdr P)        => 2

Quotation and quasiquotation
............................

As Vicare extension, the library '(srfi :116 quotations)' exports the
following keyword syntactic bindings.

 -- Syntax: iquote ?DATUM
     Similar to the R6RS syntax 'quote': take a single datum and expand
     to an expression in which all the pairs are transformed into
     immutable pairs.

          (iquote)                error-> no match
          (iquote 1 2)            error-> no match

          (iquote 1)              == 1
          (iquote (1))            == (ilist 1)
          (iquote (1 . 2))        == (ipair 1 2)
          (iquote (1 2))          == (ilist 1 2)
          (iquote (1 2 3))        == (ilist 1 2 3)

          (iquote ((1) 2 3))      == (ilist (ilist 1) 2 3)
          (iquote (1 (2) 3))      == (ilist 1 (ilist 2) 3)
          (iquote (1 2 (3)))      == (ilist 1 2 (ilist 3))

          (iquote ((1 2) 3))      == (ilist (ilist 1 2) 3)
          (iquote (1 (2 3)))      == (ilist 1 (ilist 2 3))

          (iquote ((x y) z))      == (ilist (ilist 'x 'y) 'z)
          (iquote (x (y z)))      == (ilist 'x (ilist 'y 'z))

          ;; vector templates
          (iquote #(1 2))         == '#(1 2))
          (iquote #(1 (2)))       == (vector 1 (ilist 2)))
          (iquote (#(1 2)))       == (ilist '#(1 2)))

          (iquote #(1 (2 #(3 4) 5)))
          == (vector 1 (ilist 2 (vector 3 4) 5)))

          (iquote #(x (y #(s u) z)))
          == (vector 'x (ilist 'y (vector 's 'u) 'z)))

          (iquote #(1 (2 #(3 (4 . 5)) 6)))
          == (vector 1 (ilist 2 (vector 3 (ipair 4 5)) 6)))

 -- Syntax: iquasiquote ?DATUM
 -- Auxiliary Syntax: iunquote
 -- Auxiliary Syntax: iunquote-splicing
     Similar to the R6RS syntax 'iquasiquote': take a single datum and
     expand to an expression in which outer pairs are transformed into
     immutable pairs.  The datum may contain unquoted expressions.

     The arguments of a 'iunquote-splicing' form:

          (iunquote-splicing ?EXPR ...)

     must be expressions returning ilists.

     Some basic examples:

          (iquasiquote 1)                    == 1
          (iquasiquote (1))                  == (iquote (1))
          (iquasiquote (1 . 2))              == (iquote (1 . 2))
          (iquasiquote (1 2))                == (iquote (1 2))
          (iquasiquote (1 2 . 3))            == (iquote (1 2 . 3))
          (iquasiquote ((1) (2)))            == (iquote ((1) (2)))
          (iquasiquote ((1 2) (3 4)))        == (iquote ((1 2) (3 4)))
          (iquasiquote ((1 2) (3 4)))        == (iquote ((1 2) (3 4)))
          (iquasiquote ((1 . 2) (3 . 4)))    == (iquote ((1 . 2) (3 . 4)))
          (iquasiquote ((1 . 2) . (3 . 4)))  == (iquote ((1 . 2) . (3 . 4)))
          (iquasiquote ((1 2) . 3))          == (iquote ((1 2) . 3))
          (iquasiquote ((1 . 2) . 3))        == (iquote ((1 . 2) . 3))

     some 'iunquote' examples:

          (iquasiquote (iunquote 1))                 == 1
          (iquasiquote (iunquote (iquote (1 2 3))))  == (iquote (1 2 3))
          (iquasiquote ((iunquote) (+ 1 2)))         == (iquote ((+ 1 2)))
          (iquasiquote (1 (iunquote (+ 2 3))))       == (iquote (1 5))
          (iquasiquote (1 . (iunquote (+ 2 3))))     == (ipair 1 (+ 2 3))

          (iquasiquote ((iunquote (+ 10 1) (+ 20 2) (+ 30 3)) (+ 8 9)))
          == (iquote (11 22 33 (+ 8 9)))

          (iquasiquote #((iunquote (+ 1 2)) (+ 8 9)))
          == `#(3 ,(iquote (+ 8 9)))

     some 'iunquote-splicing' examples:

          (iquasiquote ((iunquote-splicing (iquote (1 2 3)))))
          == (iquote (1 2 3))

          (iquasiquote ((iunquote-splicing) 1))
          == (iquote (1))

          (iquasiquote ((iunquote-splicing '())
                        ()))
          == (ilist '())

          (iquasiquote ((iunquote-splicing '()) . ()))
          == '()

          (iquasiquote ((iunquote-splicing (ilist (+ 1 2))) . 4))
          == (ipair 3 4)

     two examples on the difference between 'iunquote' and
     'iunquote-splicing'.

          (iquasiquote ((iunquote (ilist (+ 10 1))
                                  (ilist (+ 20 2))
                                  (ilist (+ 30 3)))
                        (+ 8 9)))
          == (iquote ((11) (22) (33) (+ 8 9)))

          (iquasiquote ((iunquote-splicing (ilist (+ 10 1))
                                           (ilist (+ 20 2))
                                           (ilist (+ 30 3)))
                        (+ 8 9)))
          == (iquote (11 22 33 (+ 8 9)))


File: vicare-libs.info,  Node: srfi ilists procs,  Next: srfi ilists ack,  Prev: srfi ilists quotation,  Up: srfi ilists

2.40.6 Procedures
-----------------

* Menu:

* srfi ilists procs conventions::       Arguments notation conventions.
* srfi ilists procs constructors::      Constructors.
* srfi ilists procs predicates::        Predicates.
* srfi ilists procs selectors::         Selectors.
* srfi ilists procs misc::              Miscellaneous: length, append,
                                        concatenate, reverse,
                                        zip and count.
* srfi ilists procs fold::              Fold, unfold and map.
* srfi ilists procs filter::            Filtering and partitioning.
* srfi ilists procs searching::         Searching.
* srfi ilists procs deletion::          Deletion.
* srfi ilists procs alists::            Immutable association lists.
* srfi ilists procs replacement::       Replacement.
* srfi ilists procs conversion::        Conversion.
* srfi ilists procs apply::             Procedure application.
* srfi ilists procs comparators::       Comparators.
* srfi ilists procs iterthunks::        Iteration thunks.


File: vicare-libs.info,  Node: srfi ilists procs conventions,  Next: srfi ilists procs constructors,  Up: srfi ilists procs

2.40.6.1 Arguments notation conventions
.......................................

The templates given below obey the following conventions for procedure
formals:

ILIST
     A proper ('()'-terminated) ilist.

DILIST
     A proper or dotted ilist.

IPAIR
     An immutable pair.

X
Y
D
A
     Any value.

OBJECT
VALUE
     Any value.

N
I
     A natural number (an integer '>= 0').

PROC
     A procedure.

PRED
     A procedure whose return value is treated as a boolean.

=
     A boolean procedure taking two arguments.

   To interpret the examples, pretend that they are executed on a Scheme
that prints immutable pairs and lists with the syntax of mutable ones.

   It is an error to pass a dotted ilist to a procedure not defined to
accept such an argument.


File: vicare-libs.info,  Node: srfi ilists procs constructors,  Next: srfi ilists procs predicates,  Prev: srfi ilists procs conventions,  Up: srfi ilists procs

2.40.6.2 Constructors
.....................

 -- Function: IPAIR ipair A D
     The primitive constructor.  Return a newly allocated ipair whose
     icar is A and whose icdr is D.  The ipair is guaranteed to be
     different (in the sense of 'eqv?') from every existing object.

          (ipair 'a '())                  => (a)
          (ipair (iq a) (iq b c d))       => ((a) b c d)
          (ipair "a" (iq b c))            => ("a" b c)
          (ipair 'a 3)                    => (a . 3)
          (ipair (iq a b) 'c)             => ((a b ) . c)

 -- Function: ILIST ilist OBJECT ...
     Return a newly allocated ilist of its arguments.

          (ilist 'a (+ 3 4) 'c)           =>  (a 7 c)
          (ilist)                         =>  ()

 -- Function: IPAIR xipair D A
     Equivalent to:

          (lambda (d a) (ipair a d))

     Of utility only as a value to be conveniently passed to
     higher-order procedures.

          (xipair (iq b c) 'a)            => (a b c)

     The name stands for "eXchanged Immutable PAIR".

 -- Function: OBJECT ipair* ELT1 ELT2 ...
     Like 'ilist', but the last argument provides the tail of the
     constructed ilist, returning:

          (ipair elt1 (ipair elt2 (ipair ... eltn)))

          (ipair* 1 2 3 4)        => (1 2 3 . 4)
          (ipair* 1)              => 1

 -- Function: ILIST make-ilist N
 -- Function: ILIST make-ilist N FILL
     Return an N-element ilist, whose elements are all the value FILL.
     If the FILL argument is not given, the elements of the ilist may be
     arbitrary values.

          (make-ilist 4 'c)       => (c c c c)

 -- Function: ILIST ilist-tabulate N INIT-PROC
     Return an N-element ilist.  Element I of the ilist, where '0 <= I <
     N', is produced by '(init-proc I)'.  No guarantee is made about the
     dynamic order in which INIT-PROC is applied to these indices.

          (ilist-tabulate 4 values)       => (0 1 2 3)

 -- Function: DILIST ilist-copy DILIST
     Copy the spine of the argument, including the ilist tail.

 -- Function: ILIST iiota COUNT
 -- Function: ILIST iiota COUNT START STEP
     Return an ilist containing the elements:

          (start start+step ... start+(count-1)*step)

     The START and STEP parameters default to '0' and '1', respectively.
     This procedure takes its name from the APL primitive.

          (iiota 5)               => (0 1 2 3 4)
          (iiota 5 0 -0.1)        => (0 -0.1 -0.2 -0.3 -0.4)


File: vicare-libs.info,  Node: srfi ilists procs predicates,  Next: srfi ilists procs selectors,  Prev: srfi ilists procs constructors,  Up: srfi ilists procs

2.40.6.3 Predicates
...................

 -- Function: BOOLEAN proper-ilist? X
 -- Function: BOOLEAN ilist? X
     These identifiers are bound either to the same procedure, or to
     procedures of equivalent behavior.  In either case, true is
     returned if, and only if, X is a proper ilist a '()'-terminated
     ilist.

     More specifically: the empty list is a proper ilist.  An ipair
     whose icdr is a proper ilist is also a proper ilist.  Everything
     else is a dotted ilist.  This includes non-ipair, non-'()' values
     (e.g.  symbols, numbers, mutable pairs), which are considered to be
     dotted ilists of length zero.

 -- Function: BOOLEAN dotted-ilist? X
     True if X is a finite, non-nil-terminated ilist.  That is, there
     exists an 'n >= 0' such that 'icdrn(x)' is neither an ipair nor
     '()'.  This includes non-ipair, non-'()' values (e.g.  symbols,
     numbers), which are considered to be dotted ilists of length zero.

          (dotted-ilist? x) == (not (proper-ilist? x))

 -- Function: BOOLEAN ipair? OBJECT
     Return '#t' if OBJECT is an ipair; otherwise '#f'.

          (ipair? (ipair 'a 'b))  =>  #t
          (ipair? (iq a b c))     =>  #t
          (ipair? (cons 1 2))     =>  #f
          (ipair? '())            =>  #f
          (ipair? '#(a b))        =>  #f
          (ipair? 7)              =>  #f
          (ipair? 'a)             =>  #f

 -- Function: BOOLEAN null-ilist? ILIST
     ILIST is a proper ilist.  This procedure returns true if the
     argument is the empty list '()', and '#f' otherwise.  It is an
     error to pass this procedure a value which is not a proper ilist.
     This procedure is recommended as the termination condition for
     ilist-processing procedures that are not defined on dotted ilists.

 -- Function: BOOLEAN not-ipair? X
     Equivalent to:

          (lambda (x) (not (ipair? x)))

     Provided as a procedure as it can be useful as the termination
     condition for ilist-processing procedures that wish to handle all
     ilists, both proper and dotted.

 -- Function: BOOLEAN ilist= ELT= ILIST1 ...
     Determines ilist equality, given an element-equality procedure.
     Proper ilist A equals proper ilist B if they are of the same
     length, and their corresponding elements are equal, as determined
     by ELT=.  If the element-comparison procedure's first argument is
     from ILISTI, then its second argument is from ILISTI+1, i.e.  it is
     always called as '(ELT= A B)' for A an element of ilist A, and B an
     element of ilist B.

     In the N-ary case, every ILISTI is compared to ILISTI+1 (as
     opposed, for example, to comparing ILIST1 to ILISTI, for i>1).  If
     there are no ILIST arguments at all, 'ilist=' simply returns '#t'.

     It is an error to apply 'ilist=' to anything except proper ilists.
     It cannot reasonably be extended to dotted ilists, as it provides
     no way to specify an equality procedure for comparing the ilist
     terminators.

     Note that the dynamic order in which the ELT= procedure is applied
     to pairs of elements is not specified.  For example, if 'ilist=' is
     applied to three ilists, A, B, and C, it may first completely
     compare A to B, then compare B to C, or it may compare the first
     elements of A and B, then the first elements of B and C, then the
     second elements of A and B, and so forth.

     The equality procedure must be consistent with 'eq?'.  That is, it
     must be the case that:

          (eq? X Y) => (ELT= X Y)

     Note that this implies that two ilists which are 'eq?' are always
     'ilist=', as well; implementations may exploit this fact to
     "short-cut" the element-by-element comparisons.

          (ilist= eq?)            => #t ; trivial cases
          (ilist= eq? (iq a))     => #t


File: vicare-libs.info,  Node: srfi ilists procs selectors,  Next: srfi ilists procs misc,  Prev: srfi ilists procs predicates,  Up: srfi ilists procs

2.40.6.4 Selectors
..................

 -- Function: VALUE icar IPAIR
 -- Function: VALUE icdr IPAIR
     These procedures return the contents of the icar and icdr field of
     their argument, respectively.  Note that it is an error to apply
     them to the empty ilist.

          (icar (iq a b c))       =>  a
          (icdr (iq a b c))       =>  (b c)

          (icar (iq (a) b c d))   =>  (a)
          (icdr (iq (a) b c d))   =>  (b c d)

          (icar (ipair 1 2))      =>  1
          (icdr (ipair 1 2))      =>  2

          (icar '())              error->  invalid argument
          (icdr '())              error->  invalid argument

 -- Function: VALUE icaar IPAIR
 -- Function: VALUE icadr IPAIR
 -- Function: VALUE icdar IPAIR
 -- Function: VALUE icddr IPAIR
     Compositions of icar and icdr.

 -- Function: VALUE icaaar IPAIR
 -- Function: VALUE icaadr IPAIR
 -- Function: VALUE icadar IPAIR
 -- Function: VALUE icaddr IPAIR
 -- Function: VALUE icdaar IPAIR
 -- Function: VALUE icdadr IPAIR
 -- Function: VALUE icddar IPAIR
 -- Function: VALUE icdddr IPAIR
     Compositions of icar and icdr.

 -- Function: VALUE icaaaar IPAIR
 -- Function: VALUE icaaadr IPAIR
 -- Function: VALUE icaadar IPAIR
 -- Function: VALUE icaaddr IPAIR
 -- Function: VALUE icadaar IPAIR
 -- Function: VALUE icadadr IPAIR
 -- Function: VALUE icaddar IPAIR
 -- Function: VALUE icadddr IPAIR
 -- Function: VALUE icdaaar IPAIR
 -- Function: VALUE icdaadr IPAIR
 -- Function: VALUE icdadar IPAIR
 -- Function: VALUE icdaddr IPAIR
 -- Function: VALUE icddaar IPAIR
 -- Function: VALUE icddadr IPAIR
 -- Function: VALUE icdddar IPAIR
 -- Function: VALUE icddddr IPAIR
     Compositions of icar and icdr.

 -- Function: VALUE ilist-ref ILIST I
     Return the I-th element of ILIST.  (This is the same as the icar of
     '(idrop ilist i)'.)  It is an error if 'I >= N', where N is the
     length of ILIST.

          (ilist-ref (iq a b c d) 2)      => c

 -- Function: OBJECT ifirst IPAIR
 -- Function: OBJECT isecond IPAIR
 -- Function: OBJECT ithird IPAIR
 -- Function: OBJECT ifourth IPAIR
 -- Function: OBJECT ififth IPAIR
 -- Function: OBJECT isixth IPAIR
 -- Function: OBJECT iseventh IPAIR
 -- Function: OBJECT ieighth IPAIR
 -- Function: OBJECT ininth IPAIR
 -- Function: OBJECT itenth IPAIR
     Synonyms for 'icar', 'icadr', 'icaddr', ...

          (ithird '(a b c d e))           => c

 -- Function: X Y icar+icdr IPAIR
     The fundamental ipair deconstructor:

          (lambda (p) (values (icar p) (icdr p)))

     This can, of course, be implemented more efficiently by a compiler.

 -- Function: ILIST itake X I
 -- Function: OBJECT idrop X I
 -- Function: OBJECT ilist-tail X I
     'itake' returns the first I elements of ilist X.  'idrop' returns
     all but the first I elements of ilist X.  'ilist-tail' is either
     the same procedure as 'idrop' or else a procedure with the same
     behavior.

          (itake (iq a b c d e)  2)       => (a b)
          (idrop (iq a b c d e)  2)       => (c d e)

     X may be any value: a proper or dotted ilist:

          (itake (ipair 1 (ipair 2 (ipair 3 'd)))         => (1 2)
          (idrop (ipair 1 (ipair 2 (ipair 3 'd))) 2)      => (3 . d)
          (itake (ipair 1 (ipair 2 (ipair 3 'd))) 3)      => (1 2 3)
          (idrop (ipair 1 (ipair 2 (ipair 3 'd))) 3)      => d

     For a legal I, 'itake' and 'idrop' partition the ilist in a manner
     which can be inverted with 'iappend':

          (iappend (itake x i) (idrop x i))       => x

     'idrop' is exactly equivalent to performing I 'icdr' operations on
     X; the returned value shares a common tail with X.

 -- Function: ILIST itake-left X I
 -- Function: OBJECT idrop-left X I
     Aliases for 'itake' and 'idrop'.

          *NOTE* These syntactic bindings are Vicare extensions.

 -- Function: OBJECT itake-right DILIST I
 -- Function: OBJECT idrop-right DILIST I
     Return the last I elements of DILIST.  'idrop-right' returns all
     but the last I elements of DILIST.

          (itake-right (iq a b c d e) 2)  => (d e)
          (idrop-right (iq a b c d e) 2)  => (a b c)

     The returned ilist may share a common tail with the argument ilist.

     DILIST may be any ilist, either proper or dotted:

          (itake-right (iq ipair 1 (ipair 2 (ipair 3 'd))) 2)     => (2 3 . d)
          (idrop-right (ipair 1 (ipair 2 (ipair 3 'd))) 2)        => (1)
          (itake-right (ipair 1 (ipair 2 (ipair 3 'd))) 0)        => d
          (idrop-right (ipair 1 (ipair 2 (ipair 3 'd))) 0)        => (1 2 3)

     For a legal I, 'itake-right' and 'idrop-right' partition the ilist
     in a manner which can be inverted with iappend:

          (iappend (itake dilist i) (idrop dilist i)) => dilist

     'itake-right''s return value is guaranteed to share a common tail
     with DILIST.

 -- Function: ILIST OBJECT isplit-at X I
     Split the ilist X at index I, returning an ilist of the first I
     elements, and the remaining tail.  It is equivalent to:

          (values (itake x i) (idrop x i))

 -- Function: OBJECT ilast IPAIR
 -- Function: IPAIR last-ipair IPAIR
     Return the last element of the non-empty, possibly dotted, ilist
     ipair.  'last-ipair' returns the last ipair in the non-empty ilist
     pair.

          (ilast (iq a b c))              => c
          (last-ipair (iq a b c))         => (c)


File: vicare-libs.info,  Node: srfi ilists procs misc,  Next: srfi ilists procs fold,  Prev: srfi ilists procs selectors,  Up: srfi ilists procs

2.40.6.5 Miscellaneous: length, append, concatenate, reverse, zip and count
...........................................................................

 -- Function: INTEGER ilength ILIST
     Return the length of its argument.  It is an error to pass a value
     to ilength which is not a proper ilist ('()'-terminated).

     The length of a proper ilist is a non-negative integer N such that
     'icdr' applied N times to the ilist produces the empty list.

 -- Function: ILIST iappend ILIST1 ...
     Return an ilist consisting of the elements of ILIST1 followed by
     the elements of the other ilist parameters.

          (iappend (iq x) (iq y))        =>  (x y)
          (iappend (iq a) (iq b c d))    =>  (a b c d)
          (iappend (iq a (b)) (iq (c)))  =>  (a (b) (c))

     The resulting ilist is always newly allocated, except that it
     shares structure with the final ILISTI argument.  This last
     argument may be any value at all; an improper ilist results if it
     is not a proper ilist.  All other arguments must be proper ilists.

          (iappend (iq a b) (ipair 'c 'd))        => (a b c . d)
          (iappend '() 'a)                        => a
          (iappend (iq x y))                      => (x y)
          (iappend)                               => ()

 -- Function: VALUE iconcatenate ILIST-OF-ILISTS
     Append the elements of its argument together.  That is, return:

          (iapply iappend ILIST-OF-ILISTS)

     or, equivalently:

          (ireduce-right iappend '() ILIST-OF-ILISTS)

     Note that some Scheme implementations do not support passing more
     than a certain number (e.g., 64) of arguments to an N-ary
     procedure.  In these implementations, the '(iapply iappend ...)'
     idiom would fail when applied to long lists, but 'iconcatenate'
     would continue to function properly.

     As with 'iappend', the last element of the input list may be any
     value at all.

 -- Function: ILIST ireverse ILIST
     Return a newly allocated ilist consisting of the elements of ILIST
     in reverse order.

          (ireverse (iq a b c))                   => (c b a)
          (ireverse (iq a (b c) d (e (f))))       => ((e (f)) d (b c) a)

 -- Function: ILIST iappend-reverse REV-HEAD TAIL
     Return:

          (iappend (ireverse REV-HEAD) TAIL)

     It is provided because it is a common operation: a common
     list-processing style calls for this exact operation to transfer
     values accumulated in reverse order onto the front of another
     ilist, and because the implementation is significantly more
     efficient than the simple composition it replaces.  (But note that
     this pattern of iterative computation followed by a reverse can
     frequently be rewritten as a recursion, dispensing with the reverse
     and 'iappend-reverse' steps, and shifting temporary, intermediate
     storage from the heap to the stack, which is typically a win for
     reasons of cache locality and eager storage reclamation.)

 -- Function: ILIST izip ILIST1 ILIST2 ...
     Equivalent to.

          (lambda ilists (iapply imap ilist ilists))

     If 'izip' is passed N ilists, it returns an ilist as long as the
     shortest of these ilists, each element of which is an N-element
     ilist comprised of the corresponding elements from the parameter
     ilists.

          (izip (iq one two three)
                (iq 1 2 3)
                (iq odd even odd even odd even odd even))
          => ((one 1 odd) (two 2 even) (three 3 odd))

          (izip (iq 1 2 3))
          => ((1) (2) (3))

 -- Function: ILIST iunzip1 ILIST
 -- Function: ILIST ILIST iunzip2 ILIST
 -- Function: ILIST ILIST ILIST iunzip3 ILIST
 -- Function: ILIST ILIST ILIST ILIST iunzip4 ILIST
 -- Function: ILIST ILIST ILIST ILIST ILIST iunzip5 ILIST
     'iunzip1' takes an ilist of ilists, where every ilist must contain
     at least one element, and returns an ilist containing the initial
     element of each such ilist.  That is, it returns:

          (imap icar ilists)

     'iunzip2' takes an ilist of ilists, where every ilist must contain
     at least two elements, and returns two values: an ilist of the
     first elements, and an ilist of the second elements.

     'iunzip3' does the same for the first three elements of the ilists,
     and so forth.

          (iunzip2 (iq (1 one) (2 two) (3 three)))
          => (1 2 3) (one two three)

 -- Function: INTEGER icount PRED ILIST1 ILIST2 ...
     PRED is a procedure taking as many arguments as there are ilists
     and returning a single value.  It is applied element-wise to the
     elements of the ilists, and a count is tallied of the number of
     elements that produce a true value.  This count is returned.  COUNT
     is "iterative" in that it is guaranteed to apply PRED to the ilist
     elements in a left-to-right order.  The counting stops when the
     shortest ilist expires.

          (count even? (iq 3 1 4 1 5 9 2 5 6))            => 3
          (count < (iq 1 2 4 8) (iq 2 4 6 8 10 12 14 16)) => 3


File: vicare-libs.info,  Node: srfi ilists procs fold,  Next: srfi ilists procs filter,  Prev: srfi ilists procs misc,  Up: srfi ilists procs

2.40.6.6 Fold, unfold and map
.............................

 -- Function: VALUE ifold KONS KNIL ILIST1 ILIST2 ...
     The fundamental ilist iterator.

     First, consider the single ILIST-parameter case.  If:

          ILIST1 == (e1 e2 ... en)

     then this procedure returns

          (kons en ... (kons e2 (kons e1 knil)) ...)

     That is, it obeys the (tail) recursion:

          (ifold kons knil lis)
          == (ifold kons (kons (icar lis) knil) (icdr lis))

          (ifold kons knil '())
          == knil

     Examples:

          (ifold + 0 lis)                 ; Add up the elements of LIS.

          (ifold ipair '() lis)           ; Reverse LIS.

          (ifold ipair tail rev-head)     ; See APPEND-REVERSE.

          ;; How many symbols in LIS?
          (ifold (lambda (x count)
                   (if (symbol? x) (+ count 1) count))
             0
             lis)

          ;; Length of the longest string in LIS:
          (ifold (lambda (s max-len)
                   (max max-len (string-length s)))
             0
             lis)

     If N ilist arguments are provided, then the KONS function must take
     'N+1' parameters: one element from each ilist, and the "seed" or
     fold state, which is initially KNIL.  The fold operation terminates
     when the shortest ilist runs out of values:

          (ifold ipair* '() (iq a b c) (iq 1 2 3 4 5)) => (c 3 b 2 a 1)

 -- Function: VALUE ifold-right KONS KNIL ILIST1 ILIST2 ...
     The fundamental ilist recursion operator.

     First, consider the single ILIST-parameter case.  If:

          ILIST1 == (e1 e2 ... en)

     then this procedure returns:

          (kons e1 (kons e2 ... (kons en knil)))

     That is, it obeys the recursion

          (ifold-right kons knil lis)
          == (kons (icar lis) (ifold-right kons knil (icdr lis)))

          (ifold-right kons knil '())
          == knil

     Examples:

          (ifold-right ipair '() lis)         ; Copy LIS.

          ;; Filter the even numbers out of LIS.
          (ifold-right (lambda (x l)
                         (if (even? x) (ipair x l) l))
            '() lis)

     If N ilist arguments are provided, then the kons procedure must
     take 'N+1' parameters: one element from each ilist, and the "seed"
     or fold state, which is initially KNIL.  The fold operation
     terminates when the shortest ilist runs out of values:

          (ifold-right ipair* '() (iq a b c) (iq 1 2 3 4 5))
          => (a 1 b 2 c 3)

 -- Function: VALUE ipair-fold KONS KNIL ILIST2 ILIST2 ...
     Analogous to fold, but KONS is applied to successive sub-ilists of
     the ILISTs, rather than successive elements: that is, KONS is
     applied to the ipairs making up the lists, giving this (tail)
     recursion:

          (ipair-fold kons knil lis)
          == (let ((tail (icdr lis)))
             (ipair-fold kons (kons lis knil) tail))

          (ipair-fold kons knil '()) == knil

     Example:

          (ipair-fold ipair '() (iq a b c)) => ((c) (b c) (a b c))

 -- Function: VALUE ipair-fold-right KONS KNIL ILIST1 ILIST2 ...
     Hold the same relationship with 'ifold-right' that 'ipair-fold'
     holds with 'ifold'.  Obeys the recursion:

          (ipair-fold-right kons knil lis)
          == (kons lis (ipair-fold-right kons knil (icdr lis)))

          (ipair-fold-right kons knil '()) == knil

     Example:

          (ipair-fold-right ipair '() (iq a b c)) => ((a b c) (b c) (c))

 -- Function: VALUE ireduce F RIDENTITY ILIST
     'ireduce' is a variant of 'ifold'.

     RIDENTITY should be a "right identity" of the procedure F: that is,
     for any value X acceptable to F:

          (f x ridentity) == x

     'ireduce' has the following definition:

        * If 'ILIST == ()', return RIDENTITY.

        * Otherwise, return:

               (ifold f (icar ilist) (icdr ilist))

     in other words, we compute '(ifold F RIDENTITY ILIST)'.

     Note that RIDENTITY is used only in the empty-list case.  You
     typically use 'ireduce' when applying F is expensive and you'd like
     to avoid the extra application incurred when 'ifold' applies F to
     the head of ILIST and the identity value, redundantly producing the
     same value passed in to F.  For example, if F involves searching a
     file directory or performing a database query, this can be
     significant.  In general, however, 'ifold' is useful in many
     contexts where 'ireduce' is not (consider the examples given in the
     'ifold' definition: only one of the five folds uses a function with
     a right identity.  The other four may not be performed with
     'ireduce').

          ;; take the max of an ilist of non-negative integers
          (ireduce max 0 nums) ; i.e., (iapply max 0 nums)

 -- Function: VALUE ireduce-right F RIDENTITY ILIST
     'ireduce-right' is the fold-right variant of 'ireduce'.  It obeys
     the following definition:

          (ireduce-right f ridentity '()) == ridentity

          (ireduce-right f ridentity (iq e1))
          == (f e1 ridentity) == e1

          (ireduce-right f ridentity (iq e1 e2 ...))
          == (f e1 (ireduce f ridentity (e2 ...)))

     in other words, we compute '(ifold-right f ridentity ilist)'.

          ;; Append a bunch of ilists together.
          ;; I.e., (iapply iappend ilist-of-ilists)
          (ireduce-right iappend '() ilist-of-ilists)

 -- Function: ILIST iunfold P F G SEED
 -- Function: ILIST iunfold P F G SEED TAIL-GEN
     'iunfold' is best described by its basic recursion:

          (iunfold p f g seed) ==
            (if (p seed) (tail-gen seed)
                (ipair (f seed)
                       (iunfold p f g (g seed))))

     P
          Determines when to stop unfolding.

     F
          Maps each seed value to the corresponding ilist element.

     G
          Maps each seed value to next seed value.

     SEED
          The "state" value for the unfold.

     TAIL-GEN
          Creates the tail of the ilist; defaults to '(lambda (x) '())'.

     In other words, we use G to generate a sequence of seed values.

          seed, g(seed), g2(seed), g3(seed), ...

     these seed values are mapped to ilist elements by F, producing the
     elements of the result ilist in a left-to-right order.  P says when
     to stop.

     'iunfold' is the fundamental recursive ilist constructor, just as
     'ifold-right' is the fundamental recursive ilist consumer.  While
     'iunfold' may seem a bit abstract to novice functional programmers,
     it can be used in a number of ways:

          ;; Ilist of squares: 1^2 ... 10^2
          (iunfold (lambda (x) (> x 10))
                   (lambda (x) (* x x))
                   (lambda (x) (+ x 1))
                   1)

          (iunfold null-ilist? icar icdr lis) ; Copy a proper ilist.

          ;; Read current input port into an ilist of values.
          (iunfold eof-object? values (lambda (x) (read)) (read))

          ;; Copy a possibly non-proper ilist:
          (iunfold not-ipair? icar icdr lis values)

          ;; Append HEAD onto TAIL:
          (iunfold null-ilist? icar icdr head (lambda (x) tail))

     Interested functional programmers may enjoy noting that
     'ifold-right' and 'iunfold' are in some sense inverses.  That is,
     given operations KNULL?, KAR, KDR, KONS, and KNIL satisfying

          (kons (kar x) (kdr x)) => x
          (knull? knil) => #t

     then:

          (ifold-right kons knil (iunfold knull? kar kdr x)) => x

     and:

          (iunfold knull? kar kdr (ifold-right kons knil x)) => x

     This combinator sometimes is called an "anamorphism"; when an
     explicit TAIL-GEN procedure is supplied, it is called an
     "apomorphism".

 -- Function: ILIST iunfold-right P F G SEED
 -- Function: ILIST iunfold-right P F G SEED TAIL
     'iunfold-right' constructs an ilist with the following loop:

          (let lp ((seed seed) (lis tail))
            (if (p seed) lis
                (lp (g seed)
                    (ipair (f seed) lis))))

     P
          Determines when to stop unfolding.

     F
          Maps each seed value to the corresponding ilist element.

     G
          Maps each seed value to next seed value.

     SEED
          The "state" value for the unfold.

     TAIL
          Ilist terminator; defaults to '()'.

     In other words, we use G to generate a sequence of seed values:

          seed, g(seed), g2(seed), g3(seed), ...

     these seed values are mapped to ilist elements by F, producing the
     elements of the result ilist in a right-to-left order.  P says when
     to stop.

     'iunfold-right' is the fundamental iterative ilist constructor,
     just as 'ifold' is the fundamental iterative ilist consumer.  While
     'iunfold-right' may seem a bit abstract to novice functional
     programmers, it can be used in a number of ways:

          ;; Ilist of squares: 1^2 ... 10^2
          (iunfold-right zero?
                         (lambda (x) (* x x))
                         (lambda (x) (- x 1))
                         10)

          ;; Reverse a proper ilist.
          (iunfold-right null-ilist? icar icdr lis)

          ;; Read current input port into an ilist of values.
          (iunfold-right eof-object? values (lambda (x) (read)) (read))

          ;; (iappend-reverse rev-head tail)
          (iunfold-right null-ilist? icar icdr rev-head tail)

     Interested functional programmers may enjoy noting that 'ifold' and
     'iunfold-right' are in some sense inverses.  That is, given
     operations KNULL?, KAR, KDR, KONS, and KNIL satisfying:

          (kons (kar x) (kdr x)) => x
          (knull? knil) => #t

     then:

          (ifold kons knil (iunfold-right knull? kar kdr x)) => x

     and:

          (iunfold-right knull? kar kdr (ifold kons knil x)) => x

     This combinator presumably has some pretentious mathematical name;
     interested readers are invited to communicate it to the author.

 -- Function: ILIST imap PROC ILIST1 ILIST2 ...
     PROC is a procedure taking as many arguments as there are ilist
     arguments and returning a single value.  'imap' applies PROC
     element-wise to the elements of the ilists and returns an ilist of
     the results, in order.  The dynamic order in which PROC is applied
     to the elements of the ilists is unspecified.

          (imap icadr (iq (a b) (d e) (g h)))
          => (b e h)

          (imap (lambda (n) (expt n n)) (iq 1 2 3 4 5))
          => (1 4 27 256 3125)

          (imap + (iq 1 2 3) (iq 4 5 6))
          => (5 7 9)

          (let ((count 0))
            (imap (lambda (ignored)
                    (set! count (+ count 1))
                    count)
                  (iq a b)))
          => (1 2) or (2 1)

 -- Function: ifor-each PROC ILIST1 ILIST2 ...
     The arguments to 'ifor-each' are like the arguments to 'imap', but
     'ifor-each' calls PROC for its side effects rather than for its
     values.  Unlike 'imap', 'ifor-each' is guaranteed to call PROC on
     the elements of the ilists in order from the first element(s) to
     the last, and the value returned by 'ifor-each' is unspecified.

          (let ((v (make-vector 5)))
            (ifor-each (lambda (i)
                         (vector-set! v i (* i i)))
                       (iq 0 1 2 3 4))
            v)
          => #(0 1 4 9 16)

 -- Function: VALUE iappend-map F ILIST1 ILIST2 ...
     Equivalent to:

          (iapply iappend (imap f ilist1 ilist2 ...))

     and.

          (iapply iappend (imap f ilist1 ilist2 ...))

     Map F over the elements of the ilists, just as in the 'imap'
     function.  However, the results of the applications are appended
     together (using 'iappend') to make the final result.

     The dynamic order in which the various applications of F are made
     is not specified.

     Example:

          (iappend-map (lambda (x) (ilist x (- x))) (iq 1 3 8))
          => (1 -1 3 -3 8 -8)

 -- Function: ILIST imap-in-order F ILIST1 ILIST2 ...
     A variant of the 'imap' procedure that guarantees to apply F across
     the elements of the ILISTI arguments in a left-to-right order.
     This is useful for mapping procedures that both have side effects
     and return useful values.

 -- Function: ipair-for-each F ILIST1 ILIST2 ...
     Like 'ifor-each', but F is applied to successive sub-ilists of the
     argument ILISTs.  That is, F is applied to the cells of the ilists,
     rather than the ilists' elements.  These applications occur in
     left-to-right order.

          (ipair-for-each (lambda (ipair)
                            (display ipair)
                            (newline))
            (iq a b c))
          -| (a b c)
          -| (b c)
          -| (c)

 -- Function: ILIST ifilter-map F ILIST1 ILIST2 ...
     Like 'imap', but only true values are saved.

          (ifilter-map (lambda (x)
                         (and (number? x) (* x x)))
            (iq a 1 b 3 c 7))
          => (1 9 49)

     The dynamic order in which the various applications of F are made
     is not specified.


File: vicare-libs.info,  Node: srfi ilists procs filter,  Next: srfi ilists procs searching,  Prev: srfi ilists procs fold,  Up: srfi ilists procs

2.40.6.7 Filtering and partitioning
...................................

 -- Function: ILIST ifilter PRED ILIST
     Return all the elements of ILIST that satisfy predicate PRED.  The
     ILIST is not disordered: elements that appear in the result ilist
     occur in the same order as they occur in the argument ilist.  The
     returned ilist may share a common tail with the argument ilist.
     The dynamic order in which the various applications of PRED are
     made is not specified.

          (ifilter even? (iq 0 7 8 8 43 -4)) => (0 8 8 -4)

 -- Function: ILIST ILIST ipartition PRED ILIST
     Partitions the elements of ILIST with predicate PRED, and returns
     two values: the ilist of in-elements and the ilist of out-elements.
     The ilist is not disordered: elements occur in the result ilists in
     the same order as they occur in the argument ilist.  The dynamic
     order in which the various applications of PRED are made is not
     specified.  One of the returned ilists may share a common tail with
     the argument ilist.

          (ipartition symbol? (iq one 2 3 four five 6))
          => (one four five) (2 3 6)

 -- Function: ILIST iremove PRED ILIST
     Return ILIST without the elements that satisfy predicate PRED:

          (lambda (pred ilist)
            (ifilter (lambda (x)
                       (not (pred x)))
              ilist))

     The ilist is not disordered: elements that appear in the result
     ilist occur in the same order as they occur in the argument ilist.
     The returned ilist may share a common tail with the argument ilist.
     The dynamic order in which the various applications of PRED are
     made is not specified.

          (iremove even? (iq 0 7 8 8 43 -4)) => (7 43)


File: vicare-libs.info,  Node: srfi ilists procs searching,  Next: srfi ilists procs deletion,  Prev: srfi ilists procs filter,  Up: srfi ilists procs

2.40.6.8 Searching
..................

The following procedures all search ilists for a leftmost element
satisfying some criteria.  This means they do not always examine the
entire ilist; thus, there is no efficient way for them to reliably
detect and signal an error when passed a dotted ilist.  Here are the
general rules describing how these procedures work when applied to
different kinds of ilists:

Proper ilists
     The standard, canonical behavior happens in this case.

Dotted ilists
     It is an error to pass these procedures a dotted ilist that does
     not contain an element satisfying the search criteria.  That is, it
     is an error if the procedure has to search all the way to the end
     of the dotted ilist.  However, this SRFI does not specify anything
     at all about the behavior of these procedures when passed a dotted
     ilist containing an element satisfying the search criteria.  It may
     finish successfully, signal an error, or perform some third action.
     Different implementations may provide different functionality in
     this case; code which is compliant with this SRFI may not rely on
     any particular behavior.  Future SRFIs may refine this SRFI to
     define specific behavior in this case.

   In brief, compliant code may not pass a dotted ilist argument to
these procedures.

   Here are some examples, using the 'ifind' and 'iany' procedures as
canonical representatives:

     ;; Proper ilist: success
     (ifind even? (iq 1 2 3))	=> 2
     (iany  even? (iq 1 2 3))	=> #t

     ;; proper ilist: failure
     (ifind even? (iq 1 7 3))	=> #f
     (iany  even? (iq 1 7 3))	=> #f

     ;; Failure is error on a dotted ilist.
     (ifind even? (ipair (1 (ipair 3 x)))	error-> invalid argument
     (iany  even? (ipair (1 (ipair 3 x)))	error-> invalid argument

     ;; The dotted ilist contains an element satisfying the search.
     ;; This case is not specified: it could be success, an error,
     ;; or some third possibility.
     (ifind even? (ipair (1 (ipair 2 x)))
     => error/undefined
     (iany  even? (ipair (1 (ipair 2 x))))
     => error/undefined ; success, error or other

 -- Function: VALUE ifind PRED ILIST
     Return the first element of ILIST that satisfies predicate PRED;
     return '#f' if no element does.

          (ifind even? (iq 3 1 4 1 5 9)) => 4

     Note that 'ifind' has an ambiguity in its lookup semantics: if
     'ifind' returns '#f', you cannot tell (in general) if it found a
     '#f' element that satisfied pred, or if it did not find any element
     at all.  In many situations, this ambiguity cannot arise: either
     the ILIST being searched is known not to contain any '#f' elements,
     or the ilist is guaranteed to have an element satisfying PRED.
     However, in cases where this ambiguity can arise, you should use
     'ifind-tail' instead of 'ifind': 'ifind-tail' has no such
     ambiguity:

          (cond ((ifind-tail pred lis)
                 => (lambda (ipair) ...)) ; Handle (icar ipair)
                (else ...))               ; Search failed

 -- Function: VALUE ifind-tail PRED ILIST
     Return the first ipair of ILIST whose icar satisfies PRED.  If no
     ipair does, return '#f'.

     'ifind-tail' can be viewed as a general-predicate variant of the
     'imember' function.

     Examples:

          (ifind-tail even? (iq 3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
          (ifind-tail even? (iq 3 1 37 -5))        => #f

          ;; IMEMBER X LIS:
          (ifind-tail (lambda (elt) (equal? x elt)) lis)

     'ifind-tail' is essentially 'idrop-while', where the sense of the
     predicate is inverted: 'ifind-tail' searches until it finds an
     element satisfying the predicate; 'idrop-while' searches until it
     finds an element that doesn't satisfy the predicate.

 -- Function: ILIST itake-while PRED ILIST
     Return the longest initial prefix of ILIST whose elements all
     satisfy the predicate PRED.

          (itake-while even? (iq 2 18 3 10 22 9)) => (2 18)

 -- Function: ILIST 'idrop-while' PRED ILIST
     Drop the longest initial prefix of ilist whose elements all satisfy
     the predicate PRED, and returns the rest of the ILIST.

          (idrop-while even? (iq 2 18 3 10 22 9)) => (3 10 22 9)

 -- Function: ILIST ILIST ispan PRED ILIST
 -- Function: ILIST ILIST ibreak PRED ILIST
     'ispan' splits the ILIST into the longest initial prefix whose
     elements all satisfy PRED, and the remaining tail.  'ibreak'
     inverts the sense of the predicate: the tail commences with the
     first element of the input ilist that satisfies the predicate.

     In other words: 'ispan' finds the initial span of elements
     satisfying PRED, and 'ibreak' breaks the ilist at the first element
     satisfying PRED.

     'ispan' is equivalent to.

          (values (itake-while pred ilist)
                  (idrop-while pred ilist))

          (ispan even? (iq 2 18 3 10 22 9))
          => (2 18) (3 10 22 9)

          (ibreak even? (iq 3 1 4 1 5 9))
          => (3 1) (4 1 5 9)

 -- Function: VALUE iany PRED ILIST1 ILIST2 ...
     Applies the predicate across the ilists, returning true if the
     predicate returns true on any application.

     If there are N ilist arguments: then PRED must be a procedure
     taking N arguments and returning a boolean result.

     'iany' applies pred to the first elements of the ilist parameters.
     If this application returns a true value, 'iany' immediately
     returns that value.  Otherwise, it iterates, applying PRED to the
     second elements of the ilist parameters, then the third, and so
     forth.  The iteration stops when a true value is produced or one of
     the ilists runs out of values; in the latter case, 'iany' returns
     '#f'.  The application of pred to the last element of the ilists is
     a tail call.

     Note the difference between 'ifind' and 'iany': 'ifind' returns the
     element that satisfied the predicate; 'iany' returns the true value
     that the predicate produced.

     Like 'ievery', 'iany''s name does not end with a question mark:
     this is to indicate that it does not return a simple boolean ('#t'
     or '#f'), but a general value.

          (iany integer? (iq a 3 b 2.7))   => #t
          (iany integer? (iq a 3.1 b 2.7)) => #f
          (iany < (iq 3 1 4 1 5)
                  (iq 2 7 1 8 2))
          => #t

 -- Function: VALUE ievery PRED ILIST1 ILIST2 ...
     Applies the predicate across the ilists, returning true if the
     predicate returns true on every application.

     If there are N ilist arguments: PRED must be a procedure taking n
     arguments and returning a boolean result.

     'ievery' applies PRED to the first elements of the ilist
     parameters.  If this application returns '#f': 'ievery' immediately
     returns '#f'.  Otherwise, it iterates, applying PRED to the second
     elements of the ilist parameters, then the third, and so forth.
     The iteration stops when a '#f' value is produced or one of the
     ilists runs out of values.  In the latter case, 'ievery' returns
     the true value produced by its final application of PRED.  The
     application of PRED to the last element of the ilists is a tail
     call.

     If one of the ilist has no elements: 'ievery' simply returns '#f'.

     Like 'iany', 'ievery''s name does not end with a question mark:
     this is to indicate that it does not return a simple boolean ('#t'
     or '#f'), but a general value.

 -- Function: VALUE ilist-index PRED ILIST1 ILIST2 ...
     Return the index of the leftmost element that satisfies PRED.

     If there are N ilist arguments: PRED must be a function taking N
     arguments and returning a boolean result.

     'ilist-index' applies pred to the first elements of the ilist
     parameters.  If this application returns true, 'ilist-index'
     immediately returns zero; otherwise, it iterates, applying PRED to
     the second elements of the ilisti parameters, then the third, and
     so forth.  When it finds a tuple of ilist elements that cause PRED
     to return true, it stops and returns the zero-based index of that
     position in the ilists.

     The iteration stops when one of the ilists runs out of values; in
     this case: 'ilist-index' returns '#f'.

          (ilist-index even? (iq 3 1 4 1 5 9)) => 2
          (ilist-index < (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)) => 1
          (ilist-index = (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)) => #f

 -- Function: ILIST imember X ILIST
 -- Function: ILIST imember X ILIST =
 -- Function: ILIST imemq X ILIST
 -- Function: ILIST imemv X ILIST
     These procedures return the first sub-ilist of ilist whose icar is
     X, where the sub-ilists of ILIST are the non-empty ilists returned
     by '(idrop ILIST I)' for I less than the length of ILIST.  If X
     does not occur in ILIST: '#f' is returned.  'imemq' uses 'eq?' to
     compare X with the elements of ilist, while imemv uses 'eqv?', and
     'imember' uses 'equal?'.

          (imemq 'a (iq a b c))           =>  (a b c)
          (imemq 'b (iq a b c))           =>  (b c)
          (imemq 'a (iq b c d))           =>  #f
          (imemq (ilist 'a) (iq b (a) c)) =>  #f
          (imember (ilist 'a)
                   (iq b (a) c))          =>  ((a) c)
          (imemq 101 (iq 100 101 102))    =>  *unspecified*
          (imemv 101 (iq 100 101 102))    =>  (101 102)

     The comparison procedure is used to compare the elements EI of
     ILIST to the key X in this way:

          (= x ei) ; ilist is (E1 ... En)

     that is, the first argument is always X, and the second argument is
     one of the ilist elements.  Thus one can reliably find the first
     element of ilist that is greater than five with '(imember 5 ilist
     <)'.

     Note that fully general ilist searching may be performed with the
     'ifind-tail' and 'ifind' procedures, e.g.

          (ifind-tail even? ilist) ; Find the first elt with an even key.


File: vicare-libs.info,  Node: srfi ilists procs deletion,  Next: srfi ilists procs alists,  Prev: srfi ilists procs searching,  Up: srfi ilists procs

2.40.6.9 Deletion
.................

 -- Function: ILIST idelete X ILIST
 -- Function: ILIST idelete X ILIST =
     'idelete' uses the comparison procedure =, which defaults to
     'equal?', to find all elements of ILIST that are equal to X, and
     deletes them from ILIST.  The dynamic order in which the various
     applications of = are made is not specified.

     The ilist is not disordered: elements that appear in the result
     ilist occur in the same order as they occur in the argument ilist.
     The result may share a common tail with the argument ilist.

     Note that fully general element deletion can be performed with the
     'iremove' procedures, e.g.:

          ;; idelete all the even elements from LIS:
          (iremove even? lis)

     The comparison procedure is used in this way: '(= x ei)'.  That is,
     X is always the first argument, and an ilist element is always the
     second argument.  The comparison procedure will be used to compare
     each element of ILIST exactly once; the order in which it is
     applied to the various EI is not specified.  Thus, one can reliably
     remove all the numbers greater than five from an ilist with
     '(idelete 5 ilist <)'.

 -- Function: ILIST idelete-duplicates ILIST
 -- Function: ILIST idelete-duplicates ILIST =
     'idelete-duplicates' removes duplicate elements from the ilist
     argument.  If there are multiple equal elements in the argument
     ilist, the result ilist only contains the first or leftmost of
     these elements in the result.  The order of these surviving
     elements is the same as in the original ilist: 'idelete-duplicates'
     does not disorder the ilist (hence it is useful for "cleaning up"
     immutable association lists).

     The = parameter is used to compare the elements of the ilist; it
     defaults to 'equal?'.  If X comes before Y in ilist, then the
     comparison is performed '(= x y)'.  The comparison procedure will
     be used to compare each pair of elements in ilist no more than
     once; the order in which it is applied to the various pairs is not
     specified.

     Implementations of 'idelete-duplicates' are allowed to share common
     tails between argument and result ilists: for example, if the ilist
     argument contains only unique elements, it may simply return
     exactly this ilist.

     Be aware that, in general, 'idelete-duplicates' runs in time O(n2)
     for N-element ilists.  Uniquifying long ilists can be accomplished
     in O(n log n) time by sorting the ilist to bring equal elements
     together, then using a linear-time algorithm to remove equal
     elements.  Alternatively, one can use algorithms based on
     element-marking, with linear-time results.

          (idelete-duplicates (iq a b a c a b c z)) => (a b c z)

          ;; Clean up an ialist:
          (idelete-duplicates (iq (a . 3) (b . 7) (a . 9) (c . 1))
            (lambda (x y) (eq? (icar x) (icar y))))
          => ((a . 3) (b . 7) (c . 1))


File: vicare-libs.info,  Node: srfi ilists procs alists,  Next: srfi ilists procs replacement,  Prev: srfi ilists procs deletion,  Up: srfi ilists procs

2.40.6.10 Immutable association lists
.....................................

An "immutable association list" (or "ialist") is an ilist of ipairs.
The icar of each ipair contains a key value, and the icdr contains the
associated data value.  They can be used to construct simple look-up
tables in Scheme.  Note that ialists are probably inappropriate for
performance-critical use on large data; in these cases, immutable maps
or some other alternative should be employed.

 -- Function: VALUE iassoc KEY IALIST
 -- Function: VALUE iassoc KEY IALIST =
 -- Function: VALUE iassq KEY IALIST
 -- Function: VALUE iassv KEY IALIST
     IALIST must be an immutable association list: an ilist of ipairs.
     These procedures find the first ipair in ialist whose icar field is
     key, and returns that ipair.  If no ipair in ialist has key as its
     icar, then '#f' is returned.  'iassq' uses 'eq?' to compare key
     with the icar fields of the ipairs in ialist, while 'iassv' uses
     'eqv?' and 'iassoc' uses 'equal?'.

          (define e (iq (a 1) (b 2) (c 3)))
          (iassq 'a e)                               =>  (a 1)
          (iassq 'b e)                               =>  (b 2)
          (iassq 'd e)                               =>  #f
          (iassq (ilist 'a) (iq ((a)) ((b)) ((c))))  =>  #f
          (iassoc (ilist 'a) (iq ((a)) ((b)) ((c)))) =>  ((a))
          (iassq 5 (iq (2 3) (5 7) (11 13)))	   =>  *unspecified*
          (iassv 5 (iq (2 3) (5 7) (11 13)))	   =>  (5 7)

     The comparison procedure is used to compare the elements EI of
     ILIST to the key parameter in this way:

          (= key (icar ei)) ; ilist is (E1 ... En)

     that is, the first argument is always key, and the second argument
     is one of the ilist elements.  Thus one can reliably find the first
     entry of IALIST whose key is greater than five with '(iassoc 5
     ialist <)'.

     Note that fully general ialist searching may be performed with the
     'ifind-tail' and 'ifind' procedures, e.g.

          ;; Look up the first association in ialist with an even key:
          (ifind (lambda (a) (even? (icar a))) ialist)

 -- Function: IALIST ialist-cons KEY DATUM IALIST
     Equivalent to:

          (lambda (key datum ialist) (ipair (ipair key datum) ialist))

     Construct a new ialist entry mapping KEY/DATUM onto IALIST.

 -- Function: ALIST ialist-copy ALIST
     Make a fresh copy of ALIST.  This means copying each pair that
     forms an association as well as the spine of the list:

          (lambda (a)
            (imap (lambda (elt)
                    (icons (icar elt) (icdr elt)))
                 a))

 -- Function: IALIST ialist-delete KEY IALIST
 -- Function: IALIST ialist-delete KEY IALIST =
     Delete all associations from IALIST with the given KEY, using
     key-comparison procedure =, which defaults to 'equal?'.  The
     dynamic order in which the various applications of = are made is
     not specified.

     Return values may share common tails with the IALIST argument.  The
     ialist is not disordered: elements that appear in the result ialist
     occur in the same order as they occur in the argument ialist.

     The comparison procedure is used to compare the element keys KI of
     ialist's entries to the KEY parameter in this way: '(= key ki)'.
     Thus, one can reliably remove all entries of IALIST whose key is
     greater than five with '(ialist-delete 5 ialist <)'.


File: vicare-libs.info,  Node: srfi ilists procs replacement,  Next: srfi ilists procs conversion,  Prev: srfi ilists procs alists,  Up: srfi ilists procs

2.40.6.11 Replacement
.....................

These two procedures are analogues of the primitive side-effect
operations on pairs, 'set-car!' and 'set-cdr!'.

 -- Function: IPAIR replace-icar IPAIR OBJECT
     This procedure returns an ipair with object in the icar field and
     the icdr of ipair in the icdr field.

 -- Function: IPAIR replace-icdr IPAIR OBJECT
     This procedure returns an ipair with object in the icdr field and
     the icar of ipair in the icar field.


File: vicare-libs.info,  Node: srfi ilists procs conversion,  Next: srfi ilists procs apply,  Prev: srfi ilists procs replacement,  Up: srfi ilists procs

2.40.6.12 Conversion
....................

These procedures convert between mutable and immutable pair structures.

 -- Function: IPAIR pair->ipair PAIR
 -- Function: PAIR ipair->pair IPAIR
     These procedures, which are inverses, return an ipair and a pair
     respectively that have the same (i)car and (i)cdr fields as the
     argument.

 -- Function: DILIST list->ilist FLIST
 -- Function: FLIST ilist->list DILIST
     These procedures return an ilist and a list respectively that have
     the same elements as the argument.  The tails of dotted (i)lists
     are preserved in the result, which makes the procedures not
     inverses when the tail of a dotted ilist is a list or vice versa.
     The empty list is converted to itself.

     It is an error to apply 'list->ilist' to a circular list.

 -- Function: ILIST vector->ilist VECTOR
 -- Function: VECTOR ilist->list ILIST
     These procedures return an ilist and a vector respectively that
     have the same elements as the argument.  The empty list is
     converted to an empty vector.  It is an error to apply
     'ilist->vector' to a dotted list.

          *NOTE* These functions are Vicare extensions.

 -- Function: OBJECT tree->itree OBJECT
 -- Function: OBJECT itree->tree OBJECT
     These procedures walk a tree of pairs or ipairs respectively and
     make a deep copy of it, returning an isomorphic tree containing
     ipairs or pairs respectively.  The result may share structure with
     the argument.  If the argument is not of the expected type, it is
     returned.

     These procedures are not inverses in the general case.  For
     example, a pair of ipairs would be converted by 'tree->itree' to an
     ipair of ipairs, which if converted by 'itree->tree' would produce
     a pair of pairs.

 -- Function: OBJECT gtree->itree OBJECT
 -- Function: OBJECT gtree->tree OBJECT
     These procedures walk a generalized tree consisting of pairs,
     ipairs, or a combination of both, and make a deep copy of it,
     returning an isomorphic tree containing only ipairs or pairs
     respectively.  The result may share structure with the argument.
     If the argument is neither a pair nor an ipair, it is returned.


File: vicare-libs.info,  Node: srfi ilists procs apply,  Next: srfi ilists procs comparators,  Prev: srfi ilists procs conversion,  Up: srfi ilists procs

2.40.6.13 Procedure application
...............................

This procedure allows a procedure to be applied to an ilist.

 -- Function: OBJECT iapply PROCEDURE OBJECT ... ILIST
     The 'iapply' procedure is an analogue of 'apply' whose last
     argument is an ilist rather than a list.  It is equivalent to:

          (apply procedure object ... (ilist->list ilist))

     but may be implemented more efficiently.


File: vicare-libs.info,  Node: srfi ilists procs comparators,  Next: srfi ilists procs iterthunks,  Prev: srfi ilists procs apply,  Up: srfi ilists procs

2.40.6.14 Comparators
.....................

The following syntactic bindings are exported by the library '(srfi :116
comparators)'.

 -- Constant: ipair-comparator
     The 'ipair-comparator' object is a SRFI-114 comparator suitable for
     comparing ipairs.  Note that it is not a procedure.  It compares
     pairs using 'default-comparator' on their cars.  If the cars are
     not equal, that value is returned.  If they are equal,
     'default-comparator' is used on their cdrs and that value is
     returned.

 -- Constant: ilist-comparator
     The 'ilist-comparator' object is a SRFI-114 comparator suitable for
     comparing ilists.  Note that it is not a procedure.  It compares
     ilists lexicographically, as follows:

        * The empty ilist compares equal to itself.

        * The empty ilist compares less than any non-empty ilist.

        * Two non-empty ilists are compared by comparing their icars.
          If the icars are not equal when compared using
          'default-comparator', then the result is the result of that
          comparison.  Otherwise, the icdrs are compared using
          'ilist-comparator'.

 -- Function: COMPARATOR make-pair-comparator CAR-COMPARATOR
          CDR-COMPARATOR
     Return a comparator that compares pairs first on their cars using
     CAR-COMPARATOR.  If the cars are equal: it compares the cdrs using
     CDR-COMPARATOR.  The hash function makes use of both the car and
     the cdr.

 -- Function: COMPARATOR make-ilist-comparator ELEMENT-COMPARATOR
     Return a comparator suitable for comparing ilists using
     ELEMENT-COMPARATOR to compare the elements.

 -- Function: COMPARATOR make-improper-ilist-comparator COMPARATOR
     Return a comparator that compares arbitrary objects as follows: the
     empty list precedes all ipairs, which precede all other objects.
     Ipairs are compared as if with:

          (make-ipair-comparator COMPARATOR COMPARATOR)

     All other objects are compared using COMPARATOR.

 -- Function: COMPARATOR make-icar-comparator COMPARATOR
     Return a comparator that compares ipairs on their icars alone using
     COMPARATOR.

 -- Function: COMPARATOR make-icdr-comparator COMPARATOR
     Return a comparator that compares ipairs on their icdrs alone using
     COMPARATOR.


File: vicare-libs.info,  Node: srfi ilists procs iterthunks,  Prev: srfi ilists procs comparators,  Up: srfi ilists procs

2.40.6.15 Iteration thunks
..........................

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).

 -- Function: make-ilist-iteration-thunk ELL
     Return an iteration thunk for the objects in the proper immutable
     list ELL.

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold xcons
            '()
            (make-ilist-iteration-thunk (ilist 0 1 2 3 4)))
          => (4 3 2 1 0)


File: vicare-libs.info,  Node: srfi ilists ack,  Next: srfi ilists references,  Prev: srfi ilists procs,  Up: srfi ilists

2.40.7 Acknowledgements
-----------------------

Without the work of Olin Shivers on SRFI-1, this SRFI would not exist.
Everyone acknowledged there is transitively acknowledged here.  This is
not to imply that either Olin or anyone else necessarily endorses the
final results, of course.


File: vicare-libs.info,  Node: srfi ilists references,  Prev: srfi ilists ack,  Up: srfi ilists

2.40.8 References
-----------------

This document, in HTML:

           <http://srfi.schemers.org/srfi-116/srfi-116.html>

   Source code for the reference implementation:

           <http://srfi.schemers.org/srfi-116/ilists.tar.gz>

   Archive of SRFI-116 discussion-list email:

    <http://srfi.schemers.org/srfi-116/mail-archive/maillist.html>

   SRFI web site:

                      <http://srfi.schemers.org/>


File: vicare-libs.info,  Node: platform,  Next: posix,  Prev: srfi,  Up: Top

3 Hosting platform libraries
****************************

* Menu:

* platform constants::          Hosting platform constants.
* platform features::           Hosting platform features.
* platform utilities::          Hosting platform utilities.
* errno::                       More features for 'errno'.
* words::                       Exact integer predicates and constants.


File: vicare-libs.info,  Node: platform constants,  Next: platform features,  Up: platform

3.1 Hosting platform constants
==============================

The library '(vicare platform constants)' exports one syntax identifier
binding for each platform constant that makes sense to access from
Scheme.


File: vicare-libs.info,  Node: platform features,  Next: platform utilities,  Prev: platform constants,  Up: platform

3.2 Hosting platform features
=============================

The library '(vicare platform features)' exports an identifier syntax
for every 'HAVE_' symbol defined by the configuration script
'configure'; such syntaxes expand to a boolean value: '#t' if the
feature is available, '#f' otherwise.


File: vicare-libs.info,  Node: platform utilities,  Next: errno,  Prev: platform features,  Up: platform

3.3 Hosting platform utilities
==============================

The library '(vicare platform utilities)' defines helper functions to
deal with platform specific issues.  The following bindings are exported
by the library '(vicare platform utilities)'.

 -- Syntax: posix-signal->symbol CODE
     Given an integer representing an interprocess POSIX signal code,
     return the corresponding symbol; if CODE is not recognised as POSIX
     signal code: return '#f'.

          (import (rnrs)
            (vicare platform constants)
            (vicare platform utilities))

          (posix-signal->symbol SIGTERM)            => SIGTERM
          (posix-signal->symbol (greatest-fixnum))  => #f

 -- Function: errno-code->symbol CODE
     Given a fixnum representing an encoded 'errno' value, return the
     corresponding symbol; if CODE is not recognised as encoded 'errno'
     value: return '#f'.

          (import (rnrs)
            (vicare platform constants)
            (vicare platform utilities))

          (errno-code->symbol EINVAL)             => EINVAL
          (errno-code->symbol (greatest-fixnum))  => #f


File: vicare-libs.info,  Node: errno,  Next: words,  Prev: platform utilities,  Up: platform

3.4 More features for 'errno'
=============================

One syntax identifier binding for each known 'errno' value is exported
by the library '(vicare platform errno)' and reexported by the library
'(vicare platform constants)'; *note Interface to 'errno':
(vicare-scheme)iklib errno. for details on Vicare internal encoding of
'errno' codes.  The following bindings are exported by the library
'(vicare platform errno)'.

 -- Syntax: errno-code ?SYMBOL
     Verify that ?SYMBOL is one of the symbolic names of 'errno'; if
     successful expand to an expression evaluating to the coded 'errno'
     value, else raise a syntax violation.

 -- Syntax: case-errno ?ERRNO ((?CODE0 ?CODE ...) . ?CBODY) ...
 -- Syntax: case-errno ?ERRNO ((?CODE0 ?CODE ...) . ?CBODY) ... (else .
          ?EBODY)
 -- Auxiliary Syntax: else
     Specialised 'case' macro for 'errno' values.  'else' is the
     auxiliary keyword exported by '(rnrs)'.  Example:

          #!r6rs
          (import (rnrs)
            (vicare platform errno))

          (define identifier "some-port")

          (case-errno (errno)
            ((EACCES EFAULT)
             (make-i/o-file-protection-error identifier))
            ((EROFS)
             (make-i/o-file-is-read-only-error identifier))
            ((EEXIST)
             (make-i/o-file-already-exists-error identifier))
            ((EIO)
             (make-i/o-error))
            ((ENOENT)
             (make-i/o-file-does-not-exist-error identifier))
            (else
             (make-irritants-condition (list identifier))))

     The ?CODE must be symbols representing 'errno' codes, they are
     *not* meant to be binding identifiers.


File: vicare-libs.info,  Node: words,  Prev: errno,  Up: platform

3.5 Exact integer predicates and constants
==========================================

It is often needed to validate exact integers agains fixed range bounds,
for example for 32-bit and 64-bit representations or some platform
specific C language type.  The library '(vicare platform words)'
implements such predicates and minimum/maximum range constants.

* Menu:

* words syntaxes::              Miscellaneous syntaxes.
* words sizeof::                Knowing the size of C language types.
* words predicates::            Verifying the range of integers.
* words sign::                  Verifying the sign of integers.
* words limits::                Exact integer range limits.


File: vicare-libs.info,  Node: words syntaxes,  Next: words sizeof,  Up: words

3.5.1 Miscellaneous syntaxes
----------------------------

The following bindings are exported by the '(vicare platform words)'
library.

 -- Syntax: case-word-size ((32) . ?BODY-32) ((64) . ?BODY-64)
     If the platform word size is 32-bit expand to ?BODY-32, else expand
     to ?BODY-64.

 -- Syntax: case-endianness (?WHO ?ENDIANNESS) ((little) . ?LIT-BODY)
          ((big) . ?BIG-BODY)
 -- Syntax: case-endianness (?WHO ?ENDIANNESS) ((big) . ?BIG-BODY)
          ((little) . ?LIT-BODY)
 -- Auxiliary Syntax: big
 -- Auxiliary Syntax: little
     If the platform endianness is little expand to ?LIT-BODY, else
     expand to ?BIG-BODY.


File: vicare-libs.info,  Node: words sizeof,  Next: words predicates,  Prev: words syntaxes,  Up: words

3.5.2 Knowing the size of C language types
------------------------------------------

The following bindings are exported by the '(vicare platform words)'
library.

 -- Identifier Syntax: SIZEOF_CHAR
     Number of bytes in the C language type 'char'.

 -- Identifier Syntax: SIZEOF_SHORT
     Number of bytes in the C language type 'short int'.

 -- Identifier Syntax: SIZEOF_INT
     Number of bytes in the C language type 'int'.

 -- Identifier Syntax: SIZEOF_LONG
     Number of bytes in the C language type 'long'.

 -- Identifier Syntax: SIZEOF_LONG_LONG
     Number of bytes in the C language type 'long long'.

 -- Identifier Syntax: SIZEOF_SIZE_T
     Number of bytes in the C language type 'size_t'.

 -- Identifier Syntax: SIZEOF_SSIZE_T
     Number of bytes in the C language type 'ssize_t'.

 -- Identifier Syntax: SIZEOF_OFF_T
     Number of bytes in the C language type 'off_t'.

 -- Identifier Syntax: SIZEOF_PTRDIFF_T
     Number of bytes in the C language type 'ptrdiff_t'.

 -- Identifier Syntax: SIZEOF_FLOAT
     Number of bytes in the C language type 'float'.

 -- Identifier Syntax: SIZEOF_DOUBLE
     Number of bytes in the C language type 'double'.

 -- Identifier Syntax: SIZEOF_POINTER
     Number of bytes in the C language type 'void *'.


File: vicare-libs.info,  Node: words predicates,  Next: words sign,  Prev: words sizeof,  Up: words

3.5.3 Verifying the range of integers
-------------------------------------

The following bindings are exported by the '(vicare platform words)'
library.

 -- Syntax: word? OBJ
     Return '#t' if OBJ is a fixnum or bignum, that is an exact integer;
     else return '#f'.

 -- Syntax: machine-word? OBJ
     On 32-bit platforms: return '#t' if OBJ is a fixnum or bignum in
     the 32-bit range; on 64-bit platforms: return '#t' if OBJ is a
     fixnum or bignum in the 64-bit range; else return '#f'.

 -- Syntax: word-u8? OBJ
 -- Syntax: word-s8? OBJ
     Return '#t' if OBJ is a signed or unsigned fixnum in the 8-bit
     range; else return '#f'.

 -- Syntax: word-u16? OBJ
 -- Syntax: word-s16? OBJ
     Return '#t' if OBJ is a signed or unsigned fixnum in the 16-bit
     range; else return '#f'.

 -- Syntax: word-u32? OBJ
 -- Syntax: word-s32? OBJ
     Return '#t' if OBJ is a signed or unsigned fixnum or bignum in the
     32-bit range; else return '#f'.

 -- Syntax: word-u64? OBJ
 -- Syntax: word-s64? OBJ
     Return '#t' if OBJ is a signed or unsigned fixnum or bignum in the
     64-bit range; else return '#f'.

 -- Syntax: word-u128? OBJ
 -- Syntax: word-s128? OBJ
     Return '#t' if OBJ is a signed or unsigned fixnum or bignum in the
     128-bit range; else return '#f'.

 -- Syntax: word-u256? OBJ
 -- Syntax: word-s256? OBJ
     Return '#t' if OBJ is a signed or unsigned fixnum or bignum in the
     256-bit range; else return '#f'.

 -- Syntax: unsigned-char? OBJ
 -- Syntax: signed-char? OBJ
     Return '#t' if OBJ is a fixnum in the range representable with a
     platform C language type 'signed char' or 'unsigned char'.

 -- Syntax: unsigned-short? OBJ
 -- Syntax: signed-short? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'signed short int' or 'unsigned
     short int'.

 -- Syntax: unsigned-int? OBJ
 -- Syntax: signed-int? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'signed int' or 'unsigned int'.

 -- Syntax: unsigned-long? OBJ
 -- Syntax: signed-long? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'signed long int' or 'unsigned long
     int'.

 -- Syntax: unsigned-long-long? OBJ
 -- Syntax: signed-long-long? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'signed long long int' or 'unsigned
     long long int'.

 -- Syntax: pointer-integer? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'void *'.

 -- Syntax: size_t? OBJ
 -- Syntax: ssize_t? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'size_t' or 'ssize_t' as defined by
     'stddef.h'.

 -- Syntax: off_t? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'off_t' as defined by 'stdio.h'.

 -- Syntax: ptrdiff_t? OBJ
     Return '#t' if OBJ is a fixnum or bignum in the range representable
     with a platform C language type 'ptrdiff_t' as defined by
     'stddef.h'.

   The following predicates are meant to be used to validate indices in
bytevectors.

 -- Syntax: fixnum-aligned-to-2? N
     *Unsafe syntax: N must be a fixnum.*  Evaluate to '#t' if N is a
     fixnum multiple of 2; else evaluate to '#f'.

 -- Syntax: fixnum-aligned-to-4? N
     *Unsafe syntax: N must be a fixnum.*  Evaluate to '#t' if N is a
     fixnum multiple of 4; else evaluate to '#f'.

 -- Syntax: fixnum-aligned-to-8? N
     *Unsafe syntax: N must be a fixnum.*  Evaluate to '#t' if N is a
     fixnum multiple of 8; else evaluate to '#f'.

 -- Syntax: fixnum-aligned-to? N ALIGNMENT
     *Unsafe syntax: N and ALIGNMENT must be fixnums.*  Evaluate to '#t'
     if N is a fixnum multiple of alignment; else evaluate to '#f'.


File: vicare-libs.info,  Node: words sign,  Next: words limits,  Prev: words predicates,  Up: words

3.5.4 Verifying the sign of integers
------------------------------------

Starting with the specified version, the following bindings are exported
by the '(vicare platform words (0 4 2015 5 28))' library.

 -- Function: positive-word-s8? OBJ
 -- Function: negative-word-s8? OBJ
 -- Function: non-positive-word-s8? OBJ
 -- Function: non-negative-word-s8? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-word-s16? OBJ
 -- Function: negative-word-s16? OBJ
 -- Function: non-positive-word-s16? OBJ
 -- Function: non-negative-word-s16? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-word-s32? OBJ
 -- Function: negative-word-s32? OBJ
 -- Function: non-positive-word-s32? OBJ
 -- Function: non-negative-word-s32? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-word-s64? OBJ
 -- Function: negative-word-s64? OBJ
 -- Function: non-positive-word-s64? OBJ
 -- Function: non-negative-word-s64? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-word-s128? OBJ
 -- Function: negative-word-s128? OBJ
 -- Function: non-positive-word-s128? OBJ
 -- Function: non-negative-word-s128? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-word-s256? OBJ
 -- Function: negative-word-s256? OBJ
 -- Function: non-positive-word-s256? OBJ
 -- Function: non-negative-word-s256? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-signed-char? OBJ
 -- Function: negative-signed-char? OBJ
 -- Function: non-positive-signed-char? OBJ
 -- Function: non-negative-signed-char? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-signed-int? OBJ
 -- Function: negative-signed-int? OBJ
 -- Function: non-positive-signed-int? OBJ
 -- Function: non-negative-signed-int? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-signed-long? OBJ
 -- Function: negative-signed-long? OBJ
 -- Function: non-positive-signed-long? OBJ
 -- Function: non-negative-signed-long? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-signed-long-long? OBJ
 -- Function: negative-signed-long-long? OBJ
 -- Function: non-positive-signed-long-long? OBJ
 -- Function: non-negative-signed-long-long? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-ssize_t? OBJ
 -- Function: negative-ssize_t? OBJ
 -- Function: non-positive-ssize_t? OBJ
 -- Function: non-negative-ssize_t? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-off_t? OBJ
 -- Function: negative-off_t? OBJ
 -- Function: non-positive-off_t? OBJ
 -- Function: non-negative-off_t? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.

 -- Function: positive-ptrdiff_t? OBJ
 -- Function: negative-ptrdiff_t? OBJ
 -- Function: non-positive-ptrdiff_t? OBJ
 -- Function: non-negative-ptrdiff_t? OBJ
     Return '#t' if OBJ is an exact integer in the specified range with
     the specified sign; otherwise return '#f'.


File: vicare-libs.info,  Node: words limits,  Prev: words sign,  Up: words

3.5.5 Exact integer range limits
--------------------------------

The following bindings are exported by the '(vicare platform words)'
library.

Inclusive limits
................

 -- Syntax: greatest-u8
 -- Syntax: greatest-s8
 -- Syntax: least-u8
 -- Syntax: least-s8
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the 8-bit range.

 -- Syntax: greatest-u16
 -- Syntax: greatest-s16
 -- Syntax: least-u16
 -- Syntax: least-s16
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the 16-bit range.

 -- Syntax: greatest-u32
 -- Syntax: greatest-s32
 -- Syntax: least-u32
 -- Syntax: least-s32
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the 32-bit range.

 -- Syntax: greatest-u64
 -- Syntax: greatest-s64
 -- Syntax: least-u64
 -- Syntax: least-s64
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the 64-bit range.

 -- Syntax: greatest-s128
 -- Syntax: greatest-u128
 -- Syntax: least-u128
 -- Syntax: least-s128
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the 128-bit range.

 -- Syntax: greatest-s256
 -- Syntax: greatest-u256
 -- Syntax: least-u256
 -- Syntax: least-s256
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the 256-bit range.

 -- Syntax: greatest-machine-word
 -- Syntax: least-machine-word
     On 32-bit platforms: evaluate to the greatest or least unsigned
     exact integer in the 32-bit range.

     On 64-bit platforms: evaluate to the greatest or least unsigned
     exact integer in the 64-bit range.

 -- Syntax: greatest-c-unsigned-char
 -- Syntax: greatest-c-signed-char
 -- Syntax: least-c-unsigned-char
 -- Syntax: least-c-signed-char
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'char' range.

 -- Syntax: greatest-c-unsigned-short
 -- Syntax: greatest-c-signed-short
 -- Syntax: least-c-unsigned-short
 -- Syntax: least-c-signed-short
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'short int' range.

 -- Syntax: greatest-c-unsigned-int
 -- Syntax: greatest-c-signed-int
 -- Syntax: least-c-unsigned-int
 -- Syntax: least-c-signed-int
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'int' range.

 -- Syntax: greatest-c-unsigned-long
 -- Syntax: greatest-c-signed-long
 -- Syntax: least-c-unsigned-long
 -- Syntax: least-c-signed-long
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'long' range.

 -- Syntax: greatest-c-unsigned-long-long
 -- Syntax: greatest-c-signed-long-long
 -- Syntax: least-c-unsigned-long-long
 -- Syntax: least-c-signed-long-long
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'long long' range.

 -- Syntax: greatest-c-pointer
 -- Syntax: least-c-pointer
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'void *' range.

 -- Syntax: greatest-c-size_t
 -- Syntax: least-c-size_t
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'size_t' range.

 -- Syntax: greatest-c-ssize_t
 -- Syntax: least-c-ssize_t
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'ssize_t' range.

 -- Syntax: greatest-c-off_t
 -- Syntax: least-c-off_t
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'off_t' range.

 -- Syntax: greatest-c-ptrdiff_t
 -- Syntax: least-c-ptrdiff_t
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'ptrdiff_t' range.

Exclusive limits
................

 -- Syntax: greatest-u8*
 -- Syntax: greatest-s8*
 -- Syntax: least-u8*
 -- Syntax: least-s8*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the 8-bit range.

 -- Syntax: greatest-u16*
 -- Syntax: greatest-s16*
 -- Syntax: least-u16*
 -- Syntax: least-s16*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the 16-bit range.

 -- Syntax: greatest-u32*
 -- Syntax: greatest-s32*
 -- Syntax: least-u32*
 -- Syntax: least-s32*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the 32-bit range.

 -- Syntax: greatest-u64*
 -- Syntax: greatest-s64*
 -- Syntax: least-u64*
 -- Syntax: least-s64*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the 64-bit range.

 -- Syntax: greatest-s128*
 -- Syntax: greatest-u128*
 -- Syntax: least-u128*
 -- Syntax: least-s128*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the 128-bit range.

 -- Syntax: greatest-s256*
 -- Syntax: greatest-u256*
 -- Syntax: least-u256*
 -- Syntax: least-s256*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the 256-bit range.

 -- Syntax: greatest-machine-word*
 -- Syntax: least-machine-word*
     On 32-bit platforms: evaluate to the greatest-plus-1 or
     least-minus-1 unsigned exact integer in the 32-bit range.

     On 64-bit platforms: evaluate to the greatest-plus-1 or
     least-minus-1 unsigned exact integer in the 64-bit range.

 -- Syntax: greatest-c-unsigned-char*
 -- Syntax: greatest-c-signed-char*
 -- Syntax: least-c-unsigned-char*
 -- Syntax: least-c-signed-char*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the C language 'char' range.

 -- Syntax: greatest-c-unsigned-short*
 -- Syntax: greatest-c-signed-short*
 -- Syntax: least-c-unsigned-short*
 -- Syntax: least-c-signed-short*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the C language 'short int' range.

 -- Syntax: greatest-c-unsigned-int*
 -- Syntax: greatest-c-signed-int*
 -- Syntax: least-c-unsigned-int*
 -- Syntax: least-c-signed-int*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the C language 'int' range.

 -- Syntax: greatest-c-unsigned-long*
 -- Syntax: greatest-c-signed-long*
 -- Syntax: least-c-unsigned-long*
 -- Syntax: least-c-signed-long*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the C language 'long' range.

 -- Syntax: greatest-c-unsigned-long-long*
 -- Syntax: greatest-c-signed-long-long*
 -- Syntax: least-c-unsigned-long-long*
 -- Syntax: least-c-signed-long-long*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the C language 'long long' range.

 -- Syntax: greatest-c-pointer*
 -- Syntax: least-c-pointer*
     Evaluate to the greatest-plus-1 or least-minus-1, signed or
     unsigned, exact integer in the C language 'void *' range.

 -- Syntax: greatest-c-size_t*
 -- Syntax: least-c-size_t*
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'size_t*' range.

 -- Syntax: greatest-c-ssize_t*
 -- Syntax: least-c-ssize_t*
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'ssize_t*' range.

 -- Syntax: greatest-c-off_t*
 -- Syntax: least-c-off_t*
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'off_t' range.

 -- Syntax: greatest-c-ptrdiff_t*
 -- Syntax: least-c-ptrdiff_t*
     Evaluate to the greatest or least, signed or unsigned, exact
     integer in the C language 'ptrdiff_t' range.


File: vicare-libs.info,  Node: posix,  Next: glibc,  Prev: platform,  Up: Top

4 The POSIX interface
*********************

The POSIX functions are exported by the library '(vicare posix)'.  The
API attempts to create a one-to-one Scheme functions mapping towards
POSIX functions, keeping the same semantics as much as possible; the
platform's own documentation is relevant at the Scheme level.  *note
posix not:: for a list of POSIX functions not interfaced in this
library, and reasons for not doing it.

   To avoid name collisions with bindings exported by '(vicare)', when
importing '(vicare posix)' it is mandatory to assign it a prefix as
follows:

     (import (vicare)
       (prefix (vicare posix) px.))

   All the constants needed to use the interface are available as
identifier syntaxes exported by the '(vicare platform constants)'
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to '#f'.

   The library '(vicare platform features)' exports one identifier
syntax for each 'HAVE_' symbol defined by Vicare 'configure' script,
expanding to '#t' or '#f'.

   The availability of the POSIX API can be tested at run-time with the
function 'vicare-built-with-posix-enabled' from '(vicare)' (*note
vicare-built-with-posix-enabled: (vicare-scheme)iklib config.), and at
expand-time with the clause 'posix-enabled' of 'cond-expand' from SRFI-0
(*note posix-enabled: srfi cond-expand vicare.).

* Menu:

* posix conventions::           Conventions about the POSIX API.
* posix conditions::            Condition object types.
* posix cond-expand::           Feature-based expansion.
* posix env::                   Operating system environment variables.
* posix pid::                   Process identifier functions.
* posix process::               Spawning processes and the like.
* posix status::                Process termination status.
* posix signal::                Delivering signals to processes.
* posix stat::                  File system inspection.
* posix file::                  Interfacing with the file system.
* posix link::                  Hard and symbolic links.
* posix dir::                   File system directories.
* posix fd::                    File descriptors.
* posix mmap::                  Memory-mapped input/output.
* posix socket::                Network sockets.
* posix users::                 Users and groups.
* posix job::                   Job control.
* posix time::                  Time related functions.
* posix timers::                POSIX per-process timers.
* posix config::                System configuration.
* posix resources::             Resources usage.
* posix mq::                    Message queues.
* posix shm::                   Shared memory.
* posix sem::                   Semaphores.
* posix misc::                  Miscellaneous functions.
* posix args::                  Arguments validation clauses.
* posix not::                   POSIX functions not interfaced.

External libraries

* posix sel::                   Simple event loop.
* posix pid-files::             Creating PID files.
* posix lock-pid-files::        Creating lock PID files.
* posix log-files::             Logging facilities.
* posix daemonisations::        Turn the process into a daemon.
* posix tcp-server-sockets::    TCP server sockets.
* posix sendmail::              Sending email with 'sendmail'.
* posix mailx::                 Sending email with 'mailx'.
* posix curl::                  Downloading files with 'curl'.
* posix wget::                  Downloading files with 'wget'.
* posix find::                  Scanning the file system with 'find'.


File: vicare-libs.info,  Node: posix conventions,  Next: posix conditions,  Up: posix

4.1 Conventions about the POSIX API
===================================

The following common arguments are specified:

FD
     It must be a non-negative fixnum repsesenting a platform's file
     descriptor.

PATHNAME
FILENAME
DIRNAME
     It must be a string or bytevector representing a file system entry.

STAT
     It must be an instance of 'struct-stat' data structure, *note posix
     stat:: for details.

   The proper data type for file system pathnames is the bytevector; all
the functions requiring a pathname as argument accept both a bytevector
and a string for convenience.  String pathnames are converted to and
from bytevectors using the functions referenced by the parameters
'string->filename-func' and 'filename->string-func'.

   Whenever a system call returns a file system pathname: two functions
are provided by the POSIX API, one returning a bytevector and one
returning a string; the one returning a string has name ending with the
suffix '/string'.

   Whenever a function in the POSIX API fails: it raises an exception
with compound condition type '&error', '&who', '&message', '&irritants';
if the error is described by an 'errno' value, an additional '&errno'
component is present; if the function involves a file, an additional
type '&i/o-filename' is present.

   Values of the 'errno' C language variable are negated and encoded as
fixnums.  Values of the 'h_errno' C language variable are negated and
encoded as fixnums.


File: vicare-libs.info,  Node: posix conditions,  Next: posix cond-expand,  Prev: posix conventions,  Up: posix

4.2 Condition object types
==========================

 -- Condition Type: &errno
     Condition object type representing system errors described by an
     encoded 'errno' value; it is derived from '&condition'.

 -- Function: make-errno-condition ERRNO
     Build and return a new '&errno' condition object holding the given
     encoded 'errno' value.

 -- Function: errno-condition? OBJ
     Return '#t' if OBJ is an instance of '&errno'.

 -- Function: condition-errno OBJ
     Accessor for the encoded 'errno' value in OBJ, which must be an
     instance of '&errno'.

 -- Condition Type: &h_errno
     Condition object type representing system errors described by an
     encoded 'h_errno' value; it is derived from '&condition'.

 -- Function: make-h_errno-condition H_ERRNO
     Build and return a new '&h_errno' condition object holding the
     given encoded 'h_errno' value.

 -- Function: h_errno-condition? OBJ
     Return '#t' if OBJ is an instance of '&h_errno'.

 -- Function: condition-h_errno OBJ
     Accessor for the encoded 'h_errno' value in OBJ, which must be an
     instance of '&h_errno'.


File: vicare-libs.info,  Node: posix cond-expand,  Next: posix env,  Prev: posix conditions,  Up: posix

4.3 Feature-based expansion
===========================

 -- Syntax: cond-expand (?FEATURE-REQUIREMENT ?BODY0 ?BODY ...) ...
     Process the given clauses in left-to-right order and expand to the
     sequence of ?BODY forms from the first clause for which the
     ?FEATURE-REQUIREMENT is satisfied.

     This syntax supports all the features defined by 'cond-expand' from
     SRFI-0 (*note Features supported by Vicare: srfi cond-expand
     vicare.), and in addition it supports a feature for each system
     function exported by '(vicare posix)'; such features use the
     identifier exported by the library as feature requirement.

     As example, let's say we want to evaluate some code if 'truncate'
     is supported, otherwise we do something else; we write the
     following:

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.cond-expand
            (px.truncate
             (do-something))
            (else
             (do-something-else)))

     and if we want to do it only on a GNU+Linux host:

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.cond-expand
            ((or linux px.truncate)
             (do-something))
            (else
             (do-something-else)))


File: vicare-libs.info,  Node: posix env,  Next: posix pid,  Prev: posix cond-expand,  Up: posix

4.4 Interfacing with the execution environment
==============================================

The Scheme level representation of environment variables names and
values is a string, but internally it is a bytevector; strings are
internally converted to bytevectors using 'string->utf8'.

 -- Function: getenv VARNAME
     Interface to the C function 'getenv()', *note getenv:
     (libc)Environment Access.  Retrieve the value of environment
     variables.  VARIABLE must reference a string object representing
     the name of the environment variable.  If the environment variable
     is set: return a string representing its value; else return false.

          (getenv "PATH")
          => "/usr/local/bin:/usr/bin:/bin"

 -- Function: setenv VARIABLE VALUE OVERWRITE
     Interface to the C function 'setenv()', *note setenv:
     (libc)Environment Access.  Set a new value for an environment
     variable.

     VARIABLE must reference a string object representing the name of
     the environment variable; VALUE must reference a string object
     representing the new value.  If OVERWRITE is false and the
     environment variable already exists: the environment variable is
     left untouched; else the new value is set, either creating a new
     environment variable or replacing the old value.

     If successful return true, if an error occurs in 'setenv()' return
     false.

 -- Function: unsetenv VARIABLE
     Interface to the C function 'unsetenv()', *note unsetenv:
     (libc)Environment Access.  Unset an environment variable.  VARIABLE
     must reference a string object representing the name of the
     environment variable.  Return true if VARIABLE has the correct
     format, else return false; there is no way to know if a variable
     was actually unset.

 -- Function: environ
     Interface to the global C variable 'environ', *note unsetenv:
     (libc)Environment Access.  Retrieve the full environment.  Return a
     list of strings representing the contents of the 'environ' array;
     if the environment is empty (no environment variables set) return
     nil.

 -- Function: environ-table
     Internally invoke 'environ' and convert the alist of strings into a
     hashtable; return the hashtable.  Both keys and values are strings.

 -- Function: environ->table ENVIRON
 -- Function: table->environ TABLE
     Convert between an alist in "environ" format and a hashtable.


File: vicare-libs.info,  Node: posix pid,  Next: posix process,  Prev: posix env,  Up: posix

4.5 Process identifier functions
================================

 -- Function: getpid
     Return the process identifier as a fixnum.

 -- Function: getppid
     Return the process identifier of the parent as a fixnum.


File: vicare-libs.info,  Node: posix process,  Next: posix status,  Prev: posix pid,  Up: posix

4.6 Spawning processes and the like
===================================

* Menu:

* posix process system::        Executing a command through the shell.
* posix process fork::          Creating a subprocess.
* posix process exec::          Executing a file.


File: vicare-libs.info,  Node: posix process system,  Next: posix process fork,  Up: posix process

4.6.1 Executing a command through the shell
-------------------------------------------

 -- Function: system COMMAND
     Interface to the C function 'system()', *note system: (libc)Running
     a Command.  Execute a command through the system shell; COMMAND
     must be a string holding the command to execute.  If successful
     return the termination status of the executed process, *note posix
     status:: for details; if an error occurs: an exception is raised.

     Example that runs 'ls':

          (import (vicare)
            (prefix (vicare posix) px.))

          (system "ls -l")


File: vicare-libs.info,  Node: posix process fork,  Next: posix process exec,  Prev: posix process system,  Up: posix process

4.6.2 Creating a subprocess
---------------------------

Forking a process is the act of creating a new process by duplicating
the current one.

* Menu:

* posix process fork fork::     Forking a process.
* posix process fork fds::      Preparing file descriptors.
* posix process fork binary::   Preparing binary input/output ports.
* posix process fork textual::  Preparing textual input/output ports.


File: vicare-libs.info,  Node: posix process fork fork,  Next: posix process fork fds,  Up: posix process fork

4.6.2.1 Forking a process
.........................

 -- Function: fork
 -- Function: fork PARENT-PROC CHILD-THUNK
     Interface to the C function 'fork()', *note fork: (libc)Creating a
     Process.  The behaviour depends upon the number of arguments:

        * When called with no arguments: create a new process by forking
          the current one; if successful return a non-negative fixnum
          representing the return value of 'fork()', else raise an
          exception.  The return value is: '0' in the child process; the
          child process pid in the parent.

        * When called with two arguments: create a new process by
          forking the current one; if successful the parent process
          applies PARENT-PROC to a fixnum representing the child process
          pid and return its return value; if successful: the child
          process evaluates the CHILD-THUNK and returns its return
          value; if an error occurs: an exception is raised.

   When forking a process we must remember about input/output ports:

  1. Before forking, in the parent process we should call
     'flush-ports-in-close-on-exec-mode'; *note
     flush-ports-in-close-on-exec-mode: posix fd device, for details.

  2. After forking, in the child process we should call
     'close-ports-in-close-on-exec-mode'; *note
     close-ports-in-close-on-exec-mode: posix fd device, for details.

we must also remember that some file descriptors are marked to be
"closed on exec".

   Here is a simple example of forking a process:

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.))

     (px.fork
      (lambda (child-pid)
        (printf "in parent pid = ~a, child pid = ~s\n"
     	   (px.getpid) child-pid)
        (flush-output-port (current-output-port)))
      (lambda ()
        (printf "in child, pid = ~a\n" (px.getpid))
        (flush-output-port (current-output-port))
        (exit)))

     (printf "here we are in the parent\n")
     (flush-output-port (current-output-port))


File: vicare-libs.info,  Node: posix process fork fds,  Next: posix process fork binary,  Prev: posix process fork fork,  Up: posix process fork

4.6.2.2 Preparing file descriptors
..................................

 -- Function: fork-with-fds PARENT-PROC CHILD-THUNK
     Wrapper for 'fork' that sets up the file descriptor pipes to
     communicate with the child process, *note fork: posix process fork
     fork.  When successful: return the same return value of 'fork';
     otherwise raise the same exception of 'fork'.

     The procedure PARENT-PROC is called as follows:

          (parent-proc child-pid
                       parent->child-stdin
                       parent<-child-stdout
                       parent<-child-stderr)

     where the arguments are the following objects:

     'child-pid'
          It is a fixnum representing the pid of the child process.

     'parent->child-stdin'
          It is a file descriptor writing into the standard input of the
          child process.

     'parent<-child-stdout'
          It is a file descriptor reading from the standard output of
          the child process.

     'parent<-child-stderr'
          It is a file descriptor reading from the standard error of the
          child process.

     The thunk CHILD-THUNK is called with no arguments.  The child can
     use the standard file descriptors '0', '1', '2' which are made
     distinct from the parent's standard file descriptors.

 -- Function: after-fork/prepare-child-file-descriptors CHILD-STDIN
          CHILD-STDOUT CHILD-STDERR
     To be called in the child process, after a fork operation, to
     replace the standard file descriptors '0', '1', '2' with the file
     descriptors CHILD-STDIN, CHILD-STDOUT, CHILD-STDERR.  When
     successful: return unspecified values; otherwise raise an
     exception.

     Perform the following operations:

       1. Close the standard file descriptors '0', '1', '2'.

       2. Duplicate the file descriptors CHILD-STDIN, CHILD-STDOUT,
          CHILD-STDERR so that they become new standard file descriptors
          '0', '1', '2'.

       3. Close the file descriptors CHILD-STDIN, CHILD-STDOUT,
          CHILD-STDERR.

     Notice that:

        * All the ports that, before this call, were wrapping the old
          file descriptors '0', '1', '2' after this call will wrap the
          new file descriptors '0', '1', '2'.

        * It is responsibility of the caller to flush the output ports
          wrapping the standard file descriptors, like the ones returned
          by 'standard-output-port', 'standard-error-port',
          'console-output-port', 'console-error-port'.

   Here is an example that forks a process, sets up the file descriptors
in the child process, waits for child to terminate.

     (import (vicare)
       (prefix (vicare posix) px.))

     (let-values
         (((child-stdin          parent->child-stdin) (px.pipe))
          ((parent<-child-stdout child-stdout)        (px.pipe))
          ((parent<-child-stderr child-stderr)        (px.pipe)))

       (define (parent-proc child-pid)
         (px.close child-stdin)
         (px.close child-stdout)
         (px.close child-stderr)
         (unwind-protect
             (let ((bufout (make-bytevector 4 0))
                   (buferr (make-bytevector 4 0)))
               (px.write parent->child-stdin '#ve(ascii "ciao\n"))
               (let ((status (px.waitpid child-pid 0)))
                 (if (and (px.WIFEXITED status)
                          (zero? (px.WEXITSTATUS status)))
                     (begin
                       (px.read parent<-child-stdout bufout)
                       (px.read parent<-child-stderr buferr)
                       (values bufout buferr))
                   (error #f
                     "child process exited abnormally"
                     status))))
           (px.close parent->child-stdin)
           (px.close parent<-child-stdout)
           (px.close parent<-child-stderr)))

       (define (child-thunk)
         (guard (E (else
                    (print-condition E)
                    (exit 1)))
           (px.close parent->child-stdin)
           (px.close parent<-child-stdout)
           (px.close parent<-child-stderr)
           (px.after-fork/prepare-child-file-descriptors
               child-stdin child-stdout child-stderr)
           (let ((buf (make-bytevector 5 0)))
             (px.read 0 buf)
             (assert (bytevector=? buf '#ve(ascii "ciao\n")))
             (px.write 1 '#ve(ascii "out\n"))
             (px.write 2 '#ve(ascii "err\n"))
             (exit 0))))

       (flush-output-port (console-output-port))
       (flush-output-port (console-error-port))
       (px.fork parent-proc child-thunk))

here is the same example using 'fork-with-fds':

     (import (vicare)
       (prefix (vicare posix) px.))

     (define (parent-proc child-pid
                parent->child-stdin
                parent<-child-stdout
                parent<-child-stderr)
       (unwind-protect
           (let ((bufout (make-bytevector 4 0))
                 (buferr (make-bytevector 4 0)))
             (px.write parent->child-stdin '#ve(ascii "ciao\n"))
             (let ((status (px.waitpid child-pid 0)))
               (if (and (px.WIFEXITED status)
                        (zero? (px.WEXITSTATUS status)))
                   (begin
                     (px.read parent<-child-stdout bufout)
                     (px.read parent<-child-stderr buferr)
                     (values bufout buferr))
                 (error #f
                   "child process exited abnormally"
                   status))))
         (px.close parent->child-stdin)
         (px.close parent<-child-stdout)
         (px.close parent<-child-stderr)))

     (define (child-thunk)
       (guard (E (else
                  (print-condition E)
                  (exit 1)))
         (let ((buf (make-bytevector 5 0)))
           (px.read 0 buf)
           (assert (bytevector=? buf '#ve(ascii "ciao\n")))
           (px.write 1 '#ve(ascii "out\n"))
           (px.write 2 '#ve(ascii "err\n"))
           (exit 0))))

     (px.fork-with-fds parent-proc child-thunk)


File: vicare-libs.info,  Node: posix process fork binary,  Next: posix process fork textual,  Prev: posix process fork fds,  Up: posix process fork

4.6.2.3 Preparing binary input/output ports
...........................................

 -- Function: fork-with-binary-ports PARENT-PROC CHILD-THUNK
     Wrapper for 'fork' that sets up the file descriptor pipes and
     binary input/output ports to communicate with the child process,
     *note fork: posix process fork fork.  When successful: return the
     same return value of 'fork'; otherwise raise the same exception of
     'fork'.

     The procedure PARENT-PROC is called as follows:

          (parent-proc child-pid
                       parent->child-stdin
                       parent<-child-stdout
                       parent<-child-stderr)

     where the arguments are the following objects:

     'child-pid'
          It is a fixnum representing the pid of the child process.

     'parent->child-stdin'
          It is a binary output port writing into the standard input of
          the child process.

     'parent<-child-stdout'
          It is a binary input port reading from the standard output of
          the child process.

     'parent<-child-stderr'
          It is a binary input port reading from the standard error of
          the child process.

     The thunk CHILD-THUNK is called with no arguments.  The child can
     use the standard ports returned by 'standard-input-port',
     'standard-output-port', 'standard-error-port' which are made to
     wrap standard file descriptors distinct from the parent's standard
     file descriptors.

 -- Function: after-fork/prepare-child-binary-input/output-ports
     To be called in the child process, after a fork operation and after
     calling 'after-fork/prepare-child-file-descriptors' to prepare
     binary input and output ports wrapping the standard file
     descriptors.  Return 3 values:

       1. Binary input port reading from the standard file descriptor
          '0'.  It is the port returned by 'standard-input-port'.

       2. Binary input port writing to the standard file descriptor '1'.
          It is the port returned by 'standard-output-port'.

       3. Binary input port writing to the standard file descriptor '2'.
          It is the port returned by 'standard-error-port'.

 -- Function: after-fork/prepare-parent-binary-input/output-ports
          PARENT->CHILD-STDIN PARENT<-CHILD-STDOUT PARENT<-CHILD-STDERR
     To be called in the parent process, after a fork operation, to
     build Scheme input and output binary ports around standard file
     descriptors for the child process.  The arguments are:

     PARENT->CHILD-STDIN
          It must be a file descriptor that writes in the standard input
          of the child process.

     PARENT<-CHILD-STDOUT
          It must be a file descriptor that reads from the standard
          output of the child process.

     PARENT<-CHILD-STDERR
          It must be must be a file descriptor that reads from the
          standard error of the child process.

     Return 3 values:

       1. Binary output port that writes in the standard input of the
          child process.  Closing this port will also close the
          underlying file descriptor.

       2. Binary input port that reads from the standard output of the
          child process.  Closing this port will also close the
          underlying file descriptor.

       3. Binary input port that reads from the standard error of the
          child process.  Closing this port will also close the
          underlying file descriptor.

   Here is an example that forks a process, sets up the file descriptors
in the child process, sets up binary ports in both the parent and the
child, waits for child to terminate.

     (import (vicare)
       (prefix (vicare posix) px.))

     (let-values
         (((child-stdin          parent->child-stdin) (px.pipe))
          ((parent<-child-stdout child-stdout)        (px.pipe))
          ((parent<-child-stderr child-stderr)        (px.pipe)))

       (define (parent-proc child-pid)
         (px.close child-stdin)
         (px.close child-stdout)
         (px.close child-stderr)
         (receive (child-stdin child-stdout child-stderr)
             (px.after-fork/prepare-parent-binary-input/output-ports
                  parent->child-stdin
                  parent<-child-stdout
                  parent<-child-stderr)
           (unwind-protect
               (let ((bufout (make-bytevector 4 0))
                     (buferr (make-bytevector 4 0)))
                 (put-bytevector child-stdin '#ve(ascii "ciao\n"))
                 (flush-output-port child-stdin)
                 (let ((status (px.waitpid child-pid 0)))
                   (if (and (px.WIFEXITED status)
                            (zero? (px.WEXITSTATUS status)))
                       (begin
                         (get-bytevector-n! child-stdout bufout 0 4)
                         (get-bytevector-n! child-stderr buferr 0 4)
                         (values bufout buferr))
                     (error #f
                       "child process exited abnormally"
                       status))))
             (close-output-port child-stdin)
             (close-input-port  child-stdout)
             (close-input-port  child-stderr))))

       (define (child-thunk)
         (guard (E (else
                    (print-condition E)
                    (exit 1)))
           (px.close parent->child-stdin)
           (px.close parent<-child-stdout)
           (px.close parent<-child-stderr)
           (px.after-fork/prepare-child-file-descriptors
               child-stdin child-stdout child-stderr)
           (receive (stdin-port stdout-port stderr-port)
               (px.after-fork/prepare-child-binary-input/output-ports)
             (let ((buf (make-bytevector 5 0)))
               (get-bytevector-n! stdin-port buf 0 5)
               (assert (bytevector=? buf '#ve(ascii "ciao\n")))
               (put-bytevector stdout-port '#ve(ascii "out\n"))
               (put-bytevector stderr-port '#ve(ascii "err\n"))
               (flush-output-port stdout-port)
               (flush-output-port stderr-port)
               (exit 0)))))

       (flush-output-port (console-output-port))
       (flush-output-port (console-error-port))
       (px.fork parent-proc child-thunk))

here is the same example using 'fork-with-binary-ports':

     (import (vicare)
       (prefix (vicare posix) px.))

     (define (parent-proc child-pid
                child-stdin child-stdout child-stderr)
       (unwind-protect
           (let ((bufout (make-bytevector 4 0))
                 (buferr (make-bytevector 4 0)))
             (put-bytevector child-stdin '#ve(ascii "ciao\n"))
             (flush-output-port child-stdin)
             (let ((status (px.waitpid child-pid 0)))
               (if (and (px.WIFEXITED status)
                        (zero? (px.WEXITSTATUS status)))
                   (begin
                     (get-bytevector-n! child-stdout bufout 0 4)
                     (get-bytevector-n! child-stderr buferr 0 4)
                     (values bufout buferr))
                 (error #f
                   "child process exited abnormally"
                   status))))
         (close-output-port child-stdin)
         (close-input-port  child-stdout)
         (close-input-port  child-stderr)))

     (define (child-thunk)
       (guard (E (else
                  (print-condition E)
                  (exit 1)))
         (define-constant stdin-port  (standard-input-port))
         (define-constant stdout-port (standard-output-port))
         (define-constant stderr-port (standard-error-port))
         (let ((buf (make-bytevector 5 0)))
           (get-bytevector-n! stdin-port buf 0 5)
           (assert (bytevector=? buf '#ve(ascii "ciao\n")))
           (put-bytevector stdout-port '#ve(ascii "out\n"))
           (put-bytevector stderr-port '#ve(ascii "err\n"))
           (flush-output-port stdout-port)
           (flush-output-port stderr-port)
           (exit 0))))

     (px.fork-with-binary-ports parent-proc child-thunk)


File: vicare-libs.info,  Node: posix process fork textual,  Prev: posix process fork binary,  Up: posix process fork

4.6.2.4 Preparing textual input/output ports
............................................

 -- Function: fork-with-textual-ports PARENT-PROC CHILD-THUNK
     Wrapper for 'fork' that sets up the file descriptor pipes and
     textual input/output ports to communicate with the child process,
     *note fork: posix process fork fork.  When successful: return the
     same return value of 'fork'; otherwise raise the same exception of
     'fork'.

     The procedure PARENT-PROC is called as follows:

          (parent-proc child-pid
                       parent->child-stdin
                       parent<-child-stdout
                       parent<-child-stderr)

     where the arguments are the following objects:

     'child-pid'
          It is a fixnum representing the pid of the child process.

     'parent->child-stdin'
          It is a textual output port writing into the standard input of
          the child process.

     'parent<-child-stdout'
          It is a textual input port reading from the standard output of
          the child process.

     'parent<-child-stderr'
          It is a textual input port reading from the standard error of
          the child process.

     The thunk CHILD-THUNK is called with no arguments.  The child can
     use the standard ports returned by 'console-input-port',
     'console-output-port', 'console-error-port' which are made to wrap
     standard file descriptors distinct from the parent's standard file
     descriptors.

 -- Function: after-fork/prepare-child-textual-input/output-ports
     To be called in the child process, after a fork operation and after
     calling 'after-fork/prepare-child-file-descriptors' to prepare
     textual input and output ports wrapping the standard file
     descriptors.  New textual input and output ports are built and
     selected as values returned by 'console-input-port',
     'console-output-port' and 'console-error-port', we must use these
     functions to access the new ports.  Return unspecified values.

     It is responsibility of the caller to set the new ports as top
     values for the parameters 'current-input-port',
     'current-output-port', 'current-error-port'.

 -- Function: after-fork/prepare-parent-textual-input/output-ports
          PARENT->CHILD-STDIN PARENT<-CHILD-STDOUT PARENT<-CHILD-STDERR
     To be called in the parent process, after a fork operation, to
     build Scheme input and output textual ports around standard file
     descriptors for the child process.  The arguments are:

     PARENT->CHILD-STDIN
          It must be a file descriptor that writes in the standard input
          of the child process.

     PARENT<-CHILD-STDOUT
          It must be a file descriptor that reads from the standard
          output of the child process.

     PARENT<-CHILD-STDERR
          It must be must be a file descriptor that reads from the
          standard error of the child process.

     Return 3 values:

       1. Textual output port that writes in the standard input of the
          child process.  Closing this port will also close the
          underlying file descriptor.

       2. Textual input port that reads from the standard output of the
          child process.  Closing this port will also close the
          underlying file descriptor.

       3. Textual input port that reads from the standard error of the
          child process.  Closing this port will also close the
          underlying file descriptor.

   Here is an example that forks a process, sets up the file descriptors
in the child process, sets up textual ports in both the parent and
child, waits for the child to terminate.

     (import (vicare)
       (prefix (vicare posix) px.))

     (let-values
         (((child-stdin          parent->child-stdin) (px.pipe))
          ((parent<-child-stdout child-stdout)        (px.pipe))
          ((parent<-child-stderr child-stderr)        (px.pipe)))

       (define (parent-proc child-pid)
         (px.close child-stdin)
         (px.close child-stdout)
         (px.close child-stderr)
         (receive (child-stdin child-stdout child-stderr)
             (px.after-fork/prepare-parent-textual-input/output-ports
                  parent->child-stdin
                  parent<-child-stdout
                  parent<-child-stderr)
           (unwind-protect
               (let ((bufout (make-string 4 #\x00))
                     (buferr (make-string 4 #\x00)))
                 (put-string child-stdin "ciao\n")
                 (flush-output-port child-stdin)
                 (let ((status (px.waitpid child-pid 0)))
                   (if (and (px.WIFEXITED status)
                            (zero? (px.WEXITSTATUS status)))
                       (begin
                         (get-string-n! child-stdout bufout 0 4)
                         (get-string-n! child-stderr buferr 0 4)
                         (values bufout buferr))
                     (error #f
                       "child process exited abnormally"
                       status))))
             (close-output-port child-stdin)
             (close-input-port  child-stdout)
             (close-input-port  child-stderr))))

       (define (child-thunk)
         (guard (E (else
                    (print-condition E)
                    (exit 1)))
           (px.close parent->child-stdin)
           (px.close parent<-child-stdout)
           (px.close parent<-child-stderr)
           (px.after-fork/prepare-child-file-descriptors
               child-stdin child-stdout child-stderr)
           (px.after-fork/prepare-child-textual-input/output-ports)
           (let ((buf (make-string 5 #\x00)))
             (get-string-n! (console-input-port) buf 0 5)
             (assert (string=? buf "ciao\n"))
             (put-string (console-output-port) "out\n")
             (put-string (console-error-port) "err\n")
             (flush-output-port (console-output-port))
             (flush-output-port (console-error-port))
             (exit 0))))

       (flush-output-port (console-output-port))
       (flush-output-port (console-error-port))
       (px.fork parent-proc child-thunk))

here is the same example using 'fork-with-textual-ports':

     (import (vicare)
       (prefix (vicare posix) px.))

     (define (parent-proc child-pid
                child-stdin child-stdout child-stderr)
       (unwind-protect
           (let ((bufout (make-string 4 #\x00))
                 (buferr (make-string 4 #\x00)))
             (put-string child-stdin "ciao\n")
             (flush-output-port child-stdin)
             (let ((status (px.waitpid child-pid 0)))
               (if (and (px.WIFEXITED status)
                        (zero? (px.WEXITSTATUS status)))
                   (begin
                     (get-string-n! child-stdout bufout 0 4)
                     (get-string-n! child-stderr buferr 0 4)
                     (values bufout buferr))
                 (error #f
                   "child process exited abnormally"
                   status))))
         (close-output-port child-stdin)
         (close-input-port  child-stdout)
         (close-input-port  child-stderr)))

     (define (child-thunk)
       (guard (E (else
                  (print-condition E)
                  (exit 1)))
         (let ((buf (make-string 5 #\x00)))
           (get-string-n! (console-input-port) buf 0 5)
           (assert (string=? buf "ciao\n"))
           (put-string (console-output-port) "out\n")
           (put-string (console-error-port) "err\n")
           (flush-output-port (console-output-port))
           (flush-output-port (console-error-port))
           (exit 0))))

     (px.fork-with-textual-ports parent-proc child-thunk)


File: vicare-libs.info,  Node: posix process exec,  Prev: posix process fork,  Up: posix process

4.6.3 Executing a file
----------------------

The POSIX functions in the family 'exec*' execute a file and replace the
current Vicare process with the new process; when these functions are
successful: they do not return.

     *NOTE* For a clean subprocess execution: before executing the
     command we must call 'close-ports-in-close-on-exec-mode'.  All the
     'exec*' functions below perform this call automatically.

 -- Function: execv FILENAME ARGV
     Interface to the C function 'execv()', *note execv: (libc)Executing
     a File.  FILENAME must be the pathname of an executable file; ARGV
     must be a list of strings representing command line arguments.
     Execute the command; if the function returns: an error has
     occurred, an exception is raised.

     Example that runs 'ls':

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.execv "/bin/ls" '("ls" "-l"))

 -- Function: execve FILENAME ARGV ENV
     Interface to the C function 'execve()', *note execve:
     (libc)Executing a File.  FILENAME must be the pathname of an
     executable file; ARGV must be a list of strings representing
     command line arguments; ENV must be a list of strings representing
     environment variables assignments.  Execute the command; if the
     function returns: an error has occurred, an exception is raised.

     Example that runs 'sh':

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.execve "/bin/sh" '("sh" "-c" "echo A is $A") '("A=1"))

 -- Function: execvp FILENAME ARGV
     Interface to the C function 'execvp()', *note execvp:
     (libc)Executing a File.  FILENAME must be the pathname of an
     executable file reachable in the current 'PATH'; ARGV must be a
     list of strings representing command line arguments.  Execute the
     command; if the function returns: an error has occurred, an
     exception is raised.

     Example that runs 'ls':

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.execvp "ls" '("ls" "-l"))

 -- Function: execl FILENAME ARG0 ARG ...
     Like 'execv' but allows the arguments to be given explicitly.
     Example that runs 'ls':

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.execl "/bin/ls" "ls" "-l")

 -- Function: execle FILENAME ARGV0 ARG ... ENV
     Like 'execve' but allows the arguments to be given explicitly.
     Example that runs 'sh':

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.execle "/bin/sh" "sh" "-c" "echo A is $A" '("A=123"))

 -- Function: execlp FILENAME ARG0 ARG ...
     Like 'execvp' but allows the arguments to be given explicitly.
     Example that runs 'ls':

          (import (vicare)
            (prefix (vicare posix) px.))

          (px.execlp "ls" "ls" "-l")

Finding executable files
........................

 -- Function: find-executable-as-bytevector BV-PATHNAME
 -- Function: find-executable-as-string STR-PATHNAME
     Given an absolute or relative file pathname or just the name of a
     file, search the file system for a matching executable file; when
     found return its absolute pathname as bytevector or Scheme string,
     else return '#f'.  If an error occurs while inspecting the file
     system: raise an exception.

     BV-PATHNAME must be a bytevector, STR-PATHNAME must be a string.

          #!vicare
          (import (vicare)
            (prefix (vicare posix) px.))

          (px.find-executable-as-string "/usr/local/bin/vicare")
          => "/usr/local/bin/vicare"

          (px.find-executable-as-string "vicare")
          => "/usr/local/bin/vicare"

          (px.find-executable-as-string "this-cannot-exist")
          => #f

          (px.find-executable-as-string "ls")
          => "/usr/bin/ls"

 -- Function: vicare-executable-as-bytevector
 -- Function: vicare-executable-as-string
     Acquire the return value of 'vicare-argv0' and search the file
     system for a matching executable file; when found return its
     absolute pathname as bytevector or Scheme string, else return '#f'.
     If an error occurs while inspecting the file system: raise an
     exception.

     Upon starting a Vicare process:

        * If the executable 'vicare' is specified as pathname relative
          to the current working directory: these functions will return
          the wrong absolute path when the current working directory is
          changed before a call to them.

        * If the executable 'vicare' is specified as file name with no
          directory part: these functions may return the wrong absolute
          path when the environment variable 'PATH' is changed before a
          call to them.

     For these reasons: these functions are both invoked upon loading
     the library '(vicare posix)' and they cache the result internally.
     Beware to neither change the current working directory nor change
     the 'PATH' before loading '(vicare posix)'.


File: vicare-libs.info,  Node: posix status,  Next: posix signal,  Prev: posix process,  Up: posix

4.7 Process termination status.
===============================

 -- Function: waitpid PID OPTIONS
     Interface to the C function 'waitpid()', *note waitpid:
     (libc)Process Completion.  Request status informations on a process
     or group of processes knowing the identifier.

     The fixnum PID selects the target of the request; the fixnum
     OPTIONS must be the logical OR ('fxior') of platform specific
     constants specifying how to wait for the availability of the
     status.

     Upon returning behave as follows:

        * If successful and a child process it was waiting for exited:
          return a fixnum representing the status.

        * If the flag 'WNOHANG' was used in OPTIONS and *no* child
          process it was waiting for exited: return '#f'.

        * If an error occurs: an exception is raised.

 -- Function: wait
     Interface to the C function 'wait()', *note wait: (libc)Process
     Completion.  Request status informations on any process or group of
     processes.  If successful return a fixnum representing the status;
     if an error occurs: an exception is raised.

   The following functions accept as argument a fixnum representing the
process termination status, for example the return value of 'system' or
the status acquired by 'waitpid'.

 -- Function: WIFEXITED STATUS
     Interface to the C macro 'WIFEXITED()', *note WIFEXITED:
     (libc)Process Completion Status.  Return true if the process
     terminated normally with 'exit()'.

 -- Function: WEXITSTATUS STATUS
     Interface to the C macro 'WEXITSTATUS()', *note WEXITSTATUS:
     (libc)Process Completion Status.  If 'WIFEXITED' applied to STATUS
     would return true: return the low-order 8 bits from the exit
     status, which is the process exit status selected with 'exit()'.

 -- Function: WIFSIGNALED STATUS
     Interface to the C macro 'WIFSIGNALED()', *note WIFSIGNALED:
     (libc)Process Completion Status.  Return true if the process
     terminated because it received an interprocess signal which was not
     handled.

 -- Function: WTERMSIG STATUS
     Interface to the C macro 'WTERMSIG()', *note WTERMSIG:
     (libc)Process Completion Status.  If 'WIFSIGNALED' applied to
     STATUS would return true: return the number of the interprocess
     signal that terminated the process.

 -- Function: WCOREDUMP STATUS
     Interface to the C macro 'WCOREDUMP()', *note WCOREDUMP:
     (libc)Process Completion Status.  Return true if the process
     terminated and produced a core dump.

 -- Function: WIFSTOPPED STATUS
     Interface to the C macro 'WIFSTOPPED()', *note WIFSTOPPED:
     (libc)Process Completion Status.  Return true if the process is
     stopped.

 -- Function: WSTOPSIG STATUS
     Interface to the C macro 'WSTOPSIG()', *note WSTOPSIG:
     (libc)Process Completion Status.  If 'WIFSTOPPED' applied to STATUS
     would return true: return the number of the interprocess signal
     that caused the process to stop.


File: vicare-libs.info,  Node: posix signal,  Next: posix stat,  Prev: posix status,  Up: posix

4.8 Delivering signals to processes
===================================

 -- Function: raise SIGNUM
     Interface to the C function 'raise()', *note raise: (libc)Signaling
     Yourself.  Send the selected signal to the calling process.  If
     successful return zero, else raise an exception.

 -- Function: kill PID SIGNUM
     Interface to the C function 'kill()', *note kill: (libc)Signaling
     Another Process.  Send the selected signal to selected process.  If
     successful return zero, else raise an exception.

 -- Function: pause
     Interface to the C function 'pause()', *note pause: (libc)Using
     Pause.  Suspend the process until a signal is received; return the
     void object.

Block/unblock signals handling
..............................

The block/unblock (BUB) API is a simplified interface to detect the
arrival of interprocess signals; if it does not suit the application's
model, we should just ignore it.  It is impossible to use the BUB API
along with other interprocess signal APIs.  Here is a meaningless usage
example:

     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (px.signal-bub-init)

     (px.raise SIGUSR1)
     (px.signal-bub-acquire)

     (px.signal-bub-delivered? SIGUSR1) => #t
     (px.signal-bub-delivered? SIGUSR2) => #f

     (signal-bub-final)

 -- Function: signal-bub-init
     Block all the signals and initialise the BUB interface.

 -- Function: signal-bub-final
     Set all the signal handlers to 'SIG_IGN', then unblock all the
     signals and finalise the BUB interface.

 -- Function: signal-bub-acquire
     Unblock all the signals, then block them again.  This should allow
     all the pending signals to be delivered to the process.

 -- Function: signal-bub-delivered? SIGNUM
     Return '#t' if the signal SIGNUM has been delivered at least once
     *before* the last call to 'signal-bub-acquire'.  Calling this
     function with SIGNUM clears the internal flag for this signal, so
     calling it again without acquiring new signals always returns '#f'.

     This function interferes with 'signal-bub-all-delivered'.

 -- Function: signal-bub-all-delivered
     Return a list of fixnums representing the signals delivered before
     the last call to 'signal-bub-acquire'.  Calling this function
     clears the internal flags for all the signals, so calling it again
     without acquiring new signals always returns the empty list.

     This function interferes with 'signal-bub-delivered?'.

Synchronously waiting for signals
.................................

 -- Struct Type: struct-siginfo_t
     Scheme representation of the C language type 'siginfo_t' which is a
     structure typedef.  It has the following fields (some of them are
     not present on all the architectures):

     'si_signo'
          Signal number.

     'si_errno'
          An 'errno' value.

     'si_code'
          Signal code.

     'si_trapno'
          Trap number that caused hardware-generated signal (unused on
          most architectures).

     'si_pid'
          Sending process ID.

     'si_uid'
          Real user ID of sending process.

     'si_status'
          Exit value or signal.

     'si_utime'
          User time consumed.

     'si_stime'
          System time consumed.

     'si_value.sival_int'
     'si_value.sival_ptr'
          Signal value.  The C language type 'sigval_t' is a union with
          fields 'int sival_int' and 'void *sival_ptr'.

     'si_int'
          POSIX.1b signal.

     'si_ptr'
          POSIX.1b signal.

     'si_overrun'
          Timer overrun count; POSIX.1b timers.

     'si_timerid'
          Timer ID; POSIX.1b timers.

     'si_addr'
          Memory location which caused fault.

     'si_band'
          Band event.

     'si_fd'
          File descriptor.

     'si_addr_lsb'
          Least significant bit of address.

          *NOTE* On GNU+Linux: for details on the 'struct siginfo_t'
          type see the manual page 'sigaction(2)'.

 -- Function: make-struct-siginfo_t
 -- Function: make-struct-siginfo_t SIGNO ERRNO CODE TRAPNO PID UID
          STATUS UTIME STIME VALUE-INT VALUE-PTR INT PTR OVERRUN TIMERID
          ADDR BAND FD ADDR_LSB
     Build and return a new instance of 'struct-siginfo_t'.  If no
     arguments are given: all the fields are initialised to '#f'.

 -- Function: struct-siginfo_t? OBJ
     Return '#t' if OBJ is an instance of 'struct-siginfo_t'.

 -- Function: struct-siginfo_t-si_signo INFO
 -- Function: struct-siginfo_t-si_errno INFO
 -- Function: struct-siginfo_t-si_code INFO
 -- Function: struct-siginfo_t-si_trapno INFO
 -- Function: struct-siginfo_t-si_pid INFO
 -- Function: struct-siginfo_t-si_uid INFO
 -- Function: struct-siginfo_t-si_status INFO
 -- Function: struct-siginfo_t-si_utime INFO
 -- Function: struct-siginfo_t-si_stime INFO
 -- Function: struct-siginfo_t-si_value.sival_int INFO
 -- Function: struct-siginfo_t-si_value.sival_ptr INFO
 -- Function: struct-siginfo_t-si_int INFO
 -- Function: struct-siginfo_t-si_ptr INFO
 -- Function: struct-siginfo_t-si_overrun INFO
 -- Function: struct-siginfo_t-si_timerid INFO
 -- Function: struct-siginfo_t-si_addr INFO
 -- Function: struct-siginfo_t-si_band INFO
 -- Function: struct-siginfo_t-si_fd INFO
 -- Function: struct-siginfo_t-si_addr_lsb INFO
     Accessors for the fields of 'struct-siginfo_t'.

 -- Function: set-struct-siginfo_t-si_signo! INFO VALUE
 -- Function: set-struct-siginfo_t-si_errno! INFO VALUE
 -- Function: set-struct-siginfo_t-si_code! INFO VALUE
 -- Function: set-struct-siginfo_t-si_trapno! INFO VALUE
 -- Function: set-struct-siginfo_t-si_pid! INFO VALUE
 -- Function: set-struct-siginfo_t-si_uid! INFO VALUE
 -- Function: set-struct-siginfo_t-si_status! INFO VALUE
 -- Function: set-struct-siginfo_t-si_utime! INFO VALUE
 -- Function: set-struct-siginfo_t-si_stime! INFO VALUE
 -- Function: set-struct-siginfo_t-si_value.sival_int! INFO VALUE
 -- Function: set-struct-siginfo_t-si_value.sival_ptr! INFO VALUE
 -- Function: set-struct-siginfo_t-si_int! INFO VALUE
 -- Function: set-struct-siginfo_t-si_ptr! INFO VALUE
 -- Function: set-struct-siginfo_t-si_overrun! INFO VALUE
 -- Function: set-struct-siginfo_t-si_timerid! INFO VALUE
 -- Function: set-struct-siginfo_t-si_addr! INFO VALUE
 -- Function: set-struct-siginfo_t-si_band! INFO VALUE
 -- Function: set-struct-siginfo_t-si_fd! INFO VALUE
 -- Function: set-struct-siginfo_t-si_addr_lsb! INFO VALUE
     Mutators for the fields of 'struct-siginfo_t'.

 -- Function: sigwaitinfo SIGNO
 -- Function: sigwaitinfo SIGNO SIGINFO
     Interface to the C function 'sigwaitinfo()', see the manual page
     'sigwaitinfo(2)'.  Synchronously wait for a queued signal; if
     successful return two values: a fixnum representing a signal number
     and SIGINFO; else raise an exception.

     SIGNO must be a fixnum representing an interprocess signal code.

     The optional SIGINFO must be an instance of 'struct-siginfo_t',
     which is filled with the informations attached to the signal; when
     not given a new instance is allocated internally.

          #!r6rs
          (import (vicare)
            (prefix (vicare posix) px.)
            (vicare platform constants)
            (vicare language-extensions syntaxes))

          (px.signal-bub-init)
          (px.raise SIGALRM)
          (let-values
              (((signo info) (px.sigwaitinfo SIGALRM)))
            signo => SIGALRM
            (px.struct-siginfo_t-si_signo info)) => SIGALRM

 -- Function: sigtimedwait SIGNO TIMEOUT
 -- Function: sigtimedwait SIGNO SIGINFO TIMEOUT
     Interface to the C function 'sigtimedwait()', see the manual page
     'sigtimedwait(2)'.  Synchronously wait for a queued signal, with a
     timeout; if successful return two values: a fixnum representing a
     signal number and SIGINFO; else raise an exception.

     SIGNO must be a fixnum representing an interprocess signal code.

     SIGINFO must be an instance of 'struct-siginfo_t', which is filled
     with the informations attached to the signal; when not given a new
     instance is allocated internally.

     TIMEOUT must be an instance of 'struct-timespec': it represents the
     maximum interval of time to wait for the signal; *note posix time
     timespec:: for details.

          #!r6rs
          (import (vicare)
            (prefix (vicare posix) px.)
            (vicare platform constants)
            (vicare language-extensions syntaxes))

          (px.signal-bub-init)
          (px.raise SIGUSR1)
          (let-values
              (((signo info)
                (px.sigtimedwait SIGUSR1
                                 (px.make-struct-timespec 1 0))))
            signo => SIGUSR1
            (px.struct-siginfo_t-si_signo info)) => SIGUSR1


File: vicare-libs.info,  Node: posix stat,  Next: posix file,  Prev: posix signal,  Up: posix

4.9 File system inspection
==========================

 -- Data Structure: struct-stat
     Data structure type representing at the Scheme level the C
     structure 'struct stat', *note stat: (libc)Attribute Meanings.

 -- Function: make-struct-stat MODE INO DEV NLINK UID GID SIZE ATIME
          ATIME_NSEC MTIME MTIME_NSEC CTIME CTIME_NSEC BLOCKS BLKSIZE
     Build and return a new 'struct-stat' instance.

 -- Function: struct-stat? OBJ
     Return true if OBJ is an instance of 'struct-stat'.

 -- Function: struct-stat-st_mode STAT
 -- Function: struct-stat-st_ino STAT
 -- Function: struct-stat-st_dev STAT
 -- Function: struct-stat-st_nlink STAT
 -- Function: struct-stat-st_uid STAT
 -- Function: struct-stat-st_gid STAT
 -- Function: struct-stat-st_size STAT
 -- Function: struct-stat-st_atime STAT
 -- Function: struct-stat-st_atime_nsec STAT
 -- Function: struct-stat-st_mtime STAT
 -- Function: struct-stat-st_mtime_nsec STAT
 -- Function: struct-stat-st_ctime STAT
 -- Function: struct-stat-st_ctime_nsec STAT
 -- Function: struct-stat-st_blocks STAT
 -- Function: struct-stat-st_blksize STAT
     Accessors for the field of 'struct-stat' instances.

 -- Function: stat PATHNAME
 -- Function: lstat PATHNAME
     Interfaces to the C functions 'stat()' and 'lstat()', *note stat:
     (libc)Reading Attributes.  Inspect the file system entry selected
     by PATHNAME and return an instance of 'struct-stat'.  If an error
     occurs: an exception is raised.

 -- Function: fstat FD
     Interface to the C function 'fstat()', *note fstat: (libc)Reading
     Attributes.  Inspect the file system entry associated to the file
     descriptor FD, which must be a fixnum, and return an instance of
     'struct-stat'.  If an error occurs: an exception is raised.

 -- Function: file-is-directory? PATHNAME
 -- Function: file-is-char-device? PATHNAME
 -- Function: file-is-block-device? PATHNAME
 -- Function: file-is-regular-file? PATHNAME
 -- Function: file-is-symbolic-link? PATHNAME
 -- Function: file-is-socket? PATHNAME
 -- Function: file-is-fifo? PATHNAME
 -- Function: file-is-message-queue? PATHNAME
 -- Function: file-is-semaphore? PATHNAME
 -- Function: file-is-shared-memory? PATHNAME
 -- Function: file-is-directory? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-char-device? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-block-device? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-regular-file? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-symbolic-link? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-socket? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-fifo? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-message-queue? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-semaphore? PATHNAME FOLLOW-SYMLINKS?
 -- Function: file-is-shared-memory? PATHNAME FOLLOW-SYMLINKS?
     Return '#t' or '#f' if the file system entry selected by PATHNAME
     is of the specified type; if an error occurs: an exception is
     raised.  When FOLLOW-SYMLINKS? is true: 'stat()' is used to inspect
     the entry, else 'lstat()' is used.  FOLLOW-SYMLINKS? defaults to
     '#f'.

 -- Function: S_ISDIR ST_MODE
 -- Function: S_ISCHR ST_MODE
 -- Function: S_ISBLK ST_MODE
 -- Function: S_ISREG ST_MODE
 -- Function: S_ISLNK ST_MODE
 -- Function: S_ISSOCK ST_MODE
 -- Function: S_ISFIFO ST_MODE
     Return '#t' or '#f' if the argument is associated to a file system
     entry of the specified type.  ST_MODE must be the value of the
     'st_mode' field of a 'struct-stat' instance.

 -- Function: access PATHNAME HOW
     Interface to the C function 'access()', *note access: (libc)Testing
     File Access.  Test the access mode selected by HOW, which must be a
     fixnum, for the file system entry selected by PATHNAME.  Return
     '#t' or '#f' if the access is possible or not; if an error occurs:
     an exception is raised.

 -- Function: file-readable? PATHNAME
 -- Function: file-writable? PATHNAME
 -- Function: file-executable? PATHNAME
     Return '#t' or '#f' if the file system entry selected by PATHNAME
     is accessible in the specified mode.  These functions are
     equivalent but slower, respectively, to the following calls:

          (access pathname R_OK)
          (access pathname W_OK)
          (access pathname X_OK)

 -- Function: file-size FILENAME
     Determine the size of the file selected by FILENAME relying on a
     call to 'stat()'.  If successful: return an exact integer
     representing the size, else raise an exception.

 -- Function: file-atime PATHNAME
 -- Function: file-mtime PATHNAME
 -- Function: file-ctime PATHNAME
     Return an exact integer representing the access, modification and
     creation times for PATHNAME.  If an error occurs: raise an
     exception.


File: vicare-libs.info,  Node: posix file,  Next: posix link,  Prev: posix stat,  Up: posix

4.10 Interfacing with the file system
=====================================

The library '(vicare posix)' reexports the following bindings from
'(vicare language-extensions posix)' (*note Pathnames handling:
(vicare-scheme)iklib io pathnames.):

     file-pathname?
     file-string-pathname?           file-bytevector-pathname?
     file-absolute-pathname?         file-relative-pathname?
     split-pathname-root-and-tail
     file-colon-search-path?
     file-string-colon-search-path?  file-bytevector-colon-search-path?
     split-search-path               split-pathname
     split-search-path-bytevector    split-pathname-bytevector
     split-search-path-string        split-pathname-string
     search-file-in-environment-path search-file-in-list-path

 -- Function: chown PATHNAME OWNER GROUP
     Interface to the C function 'chown()', *note chown: (libc)File
     Owner.  Changes the owner and group of the file system entry
     selected by PATHNAME.  OWNER and GROUP must be fixnums.  If
     successful return zero, else raise an exception.

 -- Function: fchown FD OWNER GROUP
     Interface to the C function 'fchown()', *note fchown: (libc)File
     Owner.  Changes the owner and group of the file system entry
     selected by FD, which must be a fixnum representing a platform file
     descriptor.  OWNER and GROUP must be fixnums.  If successful return
     zero, else raise an exception.

 -- Function: chmod PATHNAME MODE
     Interface to the C function 'chmod()', *note chmod: (libc)Setting
     Permissions.  Change to MODE, which must be a fixnum, the access
     permissions for the file system entry selected by PATHNAME.  If
     successful return zero, else raise an exception.

 -- Function: fchmod FD MODE
     Interface to the C function 'fchmod()', *note fchmod: (libc)Setting
     Permissions.  Change to MODE, which must be a fixnum, the access
     permissions for the file system entry associated to FD, which must
     be a fixnum representing a platform file descriptor.  If successful
     return zero, else raise an exception.

 -- Function: umask MASK
     Interface to the C function 'umask()', *note umask: (libc)Setting
     Permissions.  Set the current file creation mask to MASK, which
     must be a fixnum, and return the previous mask as a fixnum.

 -- Function: getumask
     Interface to the C function 'getumask()', *note getumask:
     (libc)Setting Permissions.  Return the current file creation mask
     as a fixnum.

 -- Function: utime PATHNAME ATIME_SEC MTIME_SEC
     Interface to the C function 'utime()', *note utime: (libc)File
     Times.  Set the access and modification times of the file system
     entry selected by PATHNAME to the specified counts of seconds; both
     ATIME_SEC and MTIME_SEC must be fixnums.  If successful return
     zero, else raise an exception.

 -- Function: utimes PATHNAME ATIME_SEC ATIME_USEC MTIME_SEC MTIME_USEC
 -- Function: lutimes PATHNAME ATIME_SEC ATIME_USEC MTIME_SEC MTIME_USEC
     Interface to the C functions 'utimes()' and 'lutimes()', *note
     utimes: (libc)File Times.  Set the access and modification times of
     the file system entry selected by PATHNAME to the specified counts
     of seconds and microseconds; all the numeric arguments must be
     fixnums.  If successful return zero, else raise an exception.

 -- Function: futimes FD ATIME_SEC ATIME_USEC MTIME_SEC MTIME_USEC
     Interface to the C function 'futimes()', *note futimes: (libc)File
     Times.  Set the access and modification times of the file system
     entry associated to FD to the specified counts of seconds and
     microseconds; all the numeric arguments must be fixnums.  If
     successful return zero, else raise an exception.


File: vicare-libs.info,  Node: posix link,  Next: posix dir,  Prev: posix file,  Up: posix

4.11 Hard and symbolic links
============================

 -- Function: link OLD_PATHNAME NEW_PATHNAME
     Interface to the C function 'link()', *note link: (libc)Hard Links.
     Create a hard link NEW_PATHNAME to the source file system entry
     OLD_PATHNAME.  If successful return zero, else raise an exception.

 -- Function: symlink FILE_PATHNAME LINK_PATHNAME
     Interface to the C function 'symlink()', *note symlink:
     (libc)Symbolic Links.  Create a symbolic link LINK_PATHNAME to the
     source file system entry FILE_PATHNAME.  If successful return zero,
     else raise an exception.

 -- Function: readlink LINK_PATHNAME
 -- Function: readlink/string LINK_PATHNAME
     Interface to the C function 'readlink()', *note readlink:
     (libc)Symbolic Links.  If PATHNAME references a symbolic link:
     follow it once and return the referenced pathname; if an error
     occurs raise an exception.  'readlink' returns a bytevector;
     'readlink/string' returns a string.

 -- Function: realpath PATHNAME
 -- Function: realpath/string PATHNAME
     Interface to the C function 'realpath()', *note realpath:
     (libc)Symbolic Links.  If PATHNAME references a symbolic link:
     follow it and return the real canonicalised pathname; if an error
     occurs: an exception is raised.  'realpath' returns a bytevector;
     'realpath/string' returns a string.

 -- Function: unlink PATHNAME
     Interface to the C function 'unlink()', *note unlink:
     (libc)Deleting Files.  Delete the file system entry referenced by
     PATHNAME, which must reference a file.  If successful return
     unspecified values, else raise an exception.

     This function is the same of 'delete-file' defined by R6RS.

 -- Function: remove PATHNAME
     Interface to the C function 'remove()', *note remove:
     (libc)Deleting Files.  Delete the file system entry referenced by
     PATHNAME, which can reference a file or directory.  If successful
     return unspecified values, else raise an exception.

 -- Function: rename OLD-PATHNAME NEW-PATHNAME
     Interface to the C function 'rename()', *note rename:
     (libc)Renaming Files.  Rename the file system entry OLD-PATHNAME to
     NEW-PATHNAME.  If successful return unspecified values, else return
     an encoded 'errno' value.


File: vicare-libs.info,  Node: posix dir,  Next: posix fd,  Prev: posix link,  Up: posix

4.12 File system directories
============================

 -- Function: mkdir PATHNAME MODE
     Interface to the C function 'mkdir()', *note mkdir: (libc)Creating
     Directories.  Create a new directory file system entry with name
     PATHNAME; MODE must be a fixnum specifying access permissions.  If
     successful return unspecified values, else raise an exception.

 -- Function: mkdir/parents PATHNAME MODE
     Create a new directory file system entry with name PATHNAME and all
     its parents if they do not exist; MODE must be a fixnum specifying
     access permissions for all the components.  If successful return
     unspecified values, else raise an exception.

 -- Function: rmdir PATHNAME
     Interface to the C function 'rmdir()', *note rmdir: (libc)Creating
     Directories.  Remove the directory file system entry selected by
     PATHNAME.  If successful return unspecified values, else raise an
     exception.

 -- Function: getcwd
 -- Function: getcwd/string
     Interface to the C function 'getcwd()', *note getcwd: (libc)Working
     Directory.  Acquire the pathname of the current working directory.
     If successful 'getcwd' returns a bytevector holding the pathname,
     'getcwd/string' returns a string holding the pathname; else an
     exception is raised.

 -- Function: chdir PATHNAME
     Interface to the C function 'chdir()', *note chdir: (libc)Working
     Directory.  Change the current working directory to the file system
     entry selected by PATHNAME.  If successful return unspecified
     values, else raise an exception.

 -- Function: fchdir FD
     Interface to the C function 'fchdir()', *note fchdir: (libc)Working
     Directory.  Change the current working directory to the file system
     entry associated to FD, which must be a fixnum representing a file
     descriptor.  If successful return unspecified values, else raise an
     exception.

 -- Structure Type: directory-stream
     Opaque data structure type used in the inspection of file system
     directory entries.  Instances of this type can be destroyed by
     'closedir', but they are also automatically and correctly destroyed
     by the garbage collector.  It has the following fields:

     'pathname'
          False or a string representing the pathname.

     'pointer'
          A pointer object referencing the directory.

     'fd'
          False or a fixnum representing the file descriptor associated
          to the directory.

     'closed?'
          A boolean, true if this stream has already been closed.

 -- Function: make-directory-stream PATHNAME POINTER FD CLOSED?
     Constructor for 'directory-stream'.

 -- Function: directory-stream? OBJ
     Return true if OBJ is an instance of 'directory-stream'.

 -- Function: directory-stream-pathname STREAM
 -- Function: directory-stream-pointer STREAM
 -- Function: directory-stream-fd STREAM
 -- Function: directory-stream-closed? STREAM
     Accessors for the fields of 'directory-stream'.

 -- Function: opendir PATHNAME
     Interface to the C function 'opendir()', *note opendir:
     (libc)Opening a Directory.  Open a directory stream for the
     inspection of the file system entry PATHNAME.  If successful return
     an instance of 'directory-stream', else raise an exception.

 -- Function: fdopendir FD
     Interface to the C function 'fdopendir()', *note fdopendir:
     (libc)Opening a Directory.  Open a directory stream for the
     inspection of the file system entry associated to FD, which must be
     a fixnum representing a file descriptor.  If successful return an
     instance of 'directory-stream', else raise an exception.

 -- Function: readdir STREAM
 -- Function: readdir/string STREAM
     Interface to the C function 'readdir()', *note readdir:
     (libc)Reading/Closing Directory.  Acquire the next entry from a
     directory stream referenced by STREAM, which must be an instance of
     'directory-stream'.  If successful and an entry is available:
     'readdir' returns a pathname as a bytevector, 'readdir/string'
     returns a pathname as a string; if successful and no more entries
     are available: return '#f'; else raise an exception.

     When no more entries are available or an error occurs: the
     directory stream is closed.

 -- Function: closedir STREAM
     Interface to the C function 'closedir()', *note closedir:
     (libc)Reading/Closing Directory.  Close the directory stream
     referenced by STREAM, which must be an instance of
     'directory-stream'.  If successful return unspecified values, else
     raise an exception.

     This function has no effect if STREAM has been already closed.

 -- Function: rewinddir STREAM
     Interface to the C function 'rewinddir()', *note rewinddir:
     (libc)Random Access Directory.  Rewind to the beginning the
     directory stream referenced by STREAM, which must be an instance of
     'directory-stream'.  Return unspecified values.

 -- Function: telldir STREAM
     Interface to the C function 'telldir()', *note telldir:
     (libc)Random Access Directory.  Return an exact integer
     representing the current position in the directory stream
     referenced by STREAM, which must be an instance of
     'directory-stream'.

 -- Function: seekdir POINTER POS
     Interface to the C function 'seekdir()', *note seekdir:
     (libc)Random Access Directory.  Set to POS the position of the
     directory stream referenced by STREAM, which must be an instance of
     'directory-stream'; POS must be the return value of a previous call
     to 'telldir'.  Return unspecified values.


File: vicare-libs.info,  Node: posix fd,  Next: posix mmap,  Prev: posix dir,  Up: posix

4.13 File descriptors
=====================

* Menu:

* posix fd open::               Opening and closing.
* posix fd read::               Reading from file descriptors.
* posix fd write::              Writing to file descriptors.
* posix fd seek::               Moving the current position.
* posix fd scatter::            Scatter-gather operations.
* posix fd select::             Waiting for events with 'select'.
* posix fd poll::               Polling for events.
* posix fd device::             Special device operations.
* posix fd dup::                Duplicating file descriptors.
* posix fd pipe::               File descriptor pipes.
* posix fd fifo::               File descriptor fifos.
* posix fd trunc::              Truncating files.
* posix fd lock::               Locking files.


File: vicare-libs.info,  Node: posix fd open,  Next: posix fd read,  Up: posix fd

4.13.1 Opening and closing
--------------------------

 -- Function: open PATHNAME FLAGS MODE
     Interface to the C function 'open()', *note open: (libc)Opening and
     Closing Files.  Open a file descriptor for the file system entry
     PATHNAME; FLAGS and MODE must be fixnums.  If successful return a
     fixnum representing the file descriptor, else raise an exception.

     Example:

          #!r6rs
          (import (vicare)
            (prefix (vicare posix) px.)
            (vicare platform constants))

          (define fd
            (px.open "name.ext"
                     (fxior O_CREAT O_EXCL O_RDWR)
                     (fxior S_IRUSR S_IWUSR)))

 -- Function: close FD
     Interface to the C function 'close()', *note close: (libc)Opening
     and Closing Files.  Close a file descriptor represented by FD,
     which must be a fixnum.  If successful return unspecified values,
     else raise an exception.


File: vicare-libs.info,  Node: posix fd read,  Next: posix fd write,  Prev: posix fd open,  Up: posix fd

4.13.2 Reading from file descriptors
------------------------------------

 -- Function: read FD BUFFER
 -- Function: read FD BUFFER SIZE
     Interface to the C function 'read()', *note read: (libc)I/O
     Primitives.  Read bytes from the file descriptor FD and store them
     in BUFFER.  If successful return a non-negative fixnum representing
     the number of bytes read, else raise an exception.

     BUFFER and SIZE must represent a generalised C buffer, *note
     Introduction to generalised C buffers: (vicare-libs)cbuffers
     buffers.

 -- Function: pread FD BUFFER SIZE OFF
     Interface to the C function 'pread()', *note pread: (libc)I/O
     Primitives.  Like 'read', but start reading at offset OFF from the
     start of the file; OFF must be a non-negative exact integer.


File: vicare-libs.info,  Node: posix fd write,  Next: posix fd seek,  Prev: posix fd read,  Up: posix fd

4.13.3 Writing to file descriptors
----------------------------------

 -- Function: write FD BUFFER
 -- Function: write FD BUFFER SIZE
     Interface to the C function 'write()', *note write: (libc)I/O
     Primitives.  Write bytes to the file descriptor FD from BUFFER.  If
     successful return a non-negative fixnum representing the number of
     written bytes, else raise an exception.

     BUFFER and SIZE must represent a generalised C string, *note
     Introduction to generalised C strings: (vicare-libs)cbuffers
     strings.  When BUFFER is a Scheme string: it is converted to a
     bytevector with 'string->ascii'.

 -- Function: pwrite FD BUFFER SIZE OFF
     Interface to the C function 'pwrite()', *note pwrite: (libc)I/O
     Primitives.  Like 'write', but start writing at offset OFF from the
     start of the file; OFF must be a non-negative exact integer.


File: vicare-libs.info,  Node: posix fd seek,  Next: posix fd scatter,  Prev: posix fd write,  Up: posix fd

4.13.4 Moving the current position
----------------------------------

 -- Function: lseek FD OFF WHENCE
     Interface to the C function 'lseek()', *note lseek: (libc)File
     Position Primitive.  Change the file position of the file
     descriptor FD to OFF from WHENCE; WHENCE must a fixnum, OFF must be
     an exact integer.  If successful return a non-negative exact
     integer representing the number of bytes from the beginning of the
     file, else raise an exception.


File: vicare-libs.info,  Node: posix fd scatter,  Next: posix fd select,  Prev: posix fd seek,  Up: posix fd

4.13.5 Scatter-gather operations
--------------------------------

 -- Function: readv FD BUFFERS
     Interface to the C function 'readv()', *note readv:
     (libc)Scatter-Gather.  Read bytes from the file descriptor FD and
     store them into the list of bytevectors referenced by BUFFERS.  If
     successful return a non-negative exact integer representing the
     number of bytes actually read, else raise an exception.

 -- Function: writev FD BUFFERS
     Interface to the C function 'writev()', *note writev:
     (libc)Scatter-Gather.  Write bytes to the file descriptor FD from
     the list of bytevectors referenced by BUFFERS.  If successful
     return a non-negative exact integer representing the number of
     bytes actually written, else raise an exception.


File: vicare-libs.info,  Node: posix fd select,  Next: posix fd poll,  Prev: posix fd scatter,  Up: posix fd

4.13.6 Waiting for events with 'select'
---------------------------------------

* Menu:

* posix fd select fdset::       Allocating and accessing
                                file descriptor sets.
* posix fd select select::      Selecting events to wait for.
* posix fd select special::     Selecting special events to wait for.


File: vicare-libs.info,  Node: posix fd select fdset,  Next: posix fd select select,  Up: posix fd select

4.13.6.1 Allocating and accessing file descriptor sets
......................................................

At low level, the POSIX function 'select()' keeps track of file
descriptors organised in sets, represented by instances of the C
language type 'fd_set'; we can think of such data structures as arrays
of integers, holding 'FD_SETSIZE' bits, in which each bit represents a
file descriptor: '1' for inclusion, '0' for exclusion.

 -- Function: sizeof-fd-set
 -- Function: sizeof-fd-set COUNT
     Return an exact integer representing the number of bytes needed to
     hold COUNT instances of the C language type 'fd_set'.  The optional
     COUNT must be a positive fixnum; when not given: it defaults to
     '1'.

 -- Function: make-fd-set-bytevector
 -- Function: make-fd-set-bytevector COUNT
     Build and return a new bytevector capable of holding COUNT
     instances of the C language type 'fd_set' defined in 'sys/types.h';
     every allocated 'fd_set' is initialised with 'FD_ZERO()'.  The
     optional COUNT must be a positive fixnum; when not given: allocate
     enough room for a single instance of 'fd_set'.

 -- Function: make-fd-set-pointer
 -- Function: make-fd-set-pointer COUNT
     Use 'malloc()' to allocate a memory block capable of holding COUNT
     instances of the C language type 'fd_set' defined in 'sys/types.h';
     every allocated 'fd_set' is initialised with 'FD_ZERO()'.

     The optional COUNT must be a positive fixnum; when not given:
     allocate enough room for a single instance of 'fd_set'.

     If successful: return a pointer object referencing the memory
     block; else return '#f'.

 -- Function: make-fd-set-memory-block
 -- Function: make-fd-set-memory-block COUNT
     Use 'malloc()' to allocate a memory block capable of holding COUNT
     instances of the C language type 'fd_set' defined in 'sys/types.h';
     every allocated 'fd_set' is initialised with 'FD_ZERO()'.

     The optional COUNT must be a positive fixnum; when not given:
     allocate enough room for a single instance of 'fd_set'.

     If successful: return an instance of 'memory-block' referencing the
     memory block; else return '#f'.

 -- Function: FD_ZERO FDSETS
 -- Function: FD_ZERO FDSETS IDX
     Reset to empty the given file descriptor set; return unspecified
     values; *note FD_ZERO: (libc)Waiting for I/O.

     FDSETS must be a bytevector, pointer object or 'memory-block'
     instance holding or referencing one or more instances of the C
     language type 'fd_set'.

     IDX must be a non-negative fixnum representing the index of the
     selected 'fd_set' in FDSETS; when not given: it defaults to zero.

 -- Function: FD_SET FD FDSETS
 -- Function: FD_SET FD FDSETS IDX
     Add the file descriptor FD to the given set; return unspecified
     values; *note FD_SET: (libc)Waiting for I/O.

     FDSETS must be a bytevector, pointer object or 'memory-block'
     instance holding or referencing one or more instances of the C
     language type 'fd_set'.

     The optional IDX must be a non-negative fixnum representing the
     index of the selected 'fd_set' in FDSETS; when not given: it
     defaults to zero.

 -- Function: FD_CLR FD FDSETS
 -- Function: FD_CLR FD FDSETS IDX
     Remove the file descriptor FD from the given set; return
     unspecified values; *note FD_CLR: (libc)Waiting for I/O.

     FDSETS must be a bytevector, pointer object or 'memory-block'
     instance holding or referencing one or more instances of the C
     language type 'fd_set'.

     The optional IDX must be a non-negative fixnum representing the
     index of the selected 'fd_set' in FDSETS; when not given: it
     defaults to zero.

 -- Function: FD_ISSET FD FDSETS
 -- Function: FD_ISSET FD FDSETS IDX
     Return a boolean specifying if the file descriptor FD is contained
     in the given set; return unspecified values; *note FD_ISSET:
     (libc)Waiting for I/O.

     FDSETS must be a bytevector, pointer object or 'memory-block'
     instance holding or referencing one or more instances of the C
     language type 'fd_set'.

     The optional IDX must be a non-negative fixnum representing the
     index of the selected 'fd_set' in FDSETS; when not given: it
     defaults to zero.

 -- Function: fd-set-inspection FDSETS
 -- Function: fd-set-inspection FDSETS IDX
     Return a list of fixnums representing the file descriptors set in
     the selected 'fd_set' structure.  This function is for debugging
     purposes.

     FDSETS must be a bytevector, pointer object or 'memory-block'
     instance holding or referencing one or more instances of the C
     language type 'fd_set'.

     The optional IDX must be a non-negative fixnum representing the
     index of the selected 'fd_set' in FDSETS; when not given: it
     defaults to zero.


File: vicare-libs.info,  Node: posix fd select select,  Next: posix fd select special,  Prev: posix fd select fdset,  Up: posix fd select

4.13.6.2 Selecting events to wait for
.....................................

 -- Function: select NFDS READ-FDS WRITE-FDS EXCEPT-FDS SEC USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for read, write or exceptional events on selected
     lists of file descriptors.

     NFDS must be false or a non-negative fixnum, when false it defaults
     to the maximum file descriptor value in the given lists; it is the
     maximum file descriptor number in the sets to be checked for
     events, plus one.  READ-FDS, WRITE-FDS and EXCEPT-FDS must be nil
     or lists of file descriptors to be checked for events.  SEC and
     USEC must be fixnums representing timeout seconds and microseconds.

     If the timeout expires before any event arrives: return 3 values
     all being nil.  If an error occurs: raise an exception.  Else
     return 3 values being lists of file descriptors, respectively,
     ready for reading, writing or an exceptional condition.

 -- Function: select-fd FD SEC USEC
 -- Function: select-port PORT SEC USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for read, write or exceptional events on the single
     file descriptor FD or PORT having a file descriptor as device.  SEC
     and USEC must be fixnums representing timeout seconds and
     microseconds.

     If the timeout expires before any event arrives: return 3 values
     all being false.  If an error occurs: raise an exception.  Else
     return 3 values being '#f' or FD or PORT, respectively, if FD or
     PORT is ready for reading, writing or an exceptional condition.

 -- Function: select-from-sets NFDS READ-FDS WRITE-FDS EXCEPT-FDS SEC
          USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for read, write or exceptional events on selected
     lists of file descriptors.

     NFDS must be false or a non-negative fixnum, when false it defaults
     to 'FD_SETSIZE'; it must be the maximum file descriptor number in
     the sets to be checked for events, plus one.

     READ-FDS, WRITE-FDS and EXCEPT-FDS must be '#f' or bytevectors,
     pointer objects or instances of 'memory-block' holding an instance
     of the C language type 'fd_set'; when '#f' or a 'NULL' pointer: an
     empty 'fd_set' is internally allocated and used.

     SEC and USEC must be fixnums representing timeout seconds and
     microseconds.

     If the timeout expires before any event arrives: return 3 values
     all being '#f'; if an error occurs: raise an exception; else return
     3 values being READ-FDS, WRITE-FDS, EXCEPT-FDS.

 -- Function: select-from-sets-array NFDS FDSETS SEC USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for read, write or exceptional events on selected
     lists of file descriptors.

     NFDS must be false or a non-negative fixnum, when false it defaults
     to 'FD_SETSIZE'; it must be the maximum file descriptor number in
     the sets to be checked for events, plus one.  FDSETS must be a
     bytevector, pointer object or instance of 'memory-block' holding 3
     contiguous instances of the C language type 'fd_set'.  SEC and USEC
     must be fixnums representing timeout seconds and microseconds.

     If the timeout expires before any event arrives: return '#f'; if an
     error occurs: raise an exception; else return FDSETS itself.


File: vicare-libs.info,  Node: posix fd select special,  Prev: posix fd select select,  Up: posix fd select

4.13.6.3 Selecting special events to wait for
.............................................

 -- Function: select-fd-readable? FD SEC USEC
 -- Function: select-port-readable? PORT SEC USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for a readable event on the single file descriptor FD
     or PORT having a file descriptor as device.  SEC and USEC must be
     fixnums representing timeout seconds and microseconds.

     If the timeout expires before any event arrives: return '#f'.  If
     an error occurs: raise an exception.  Else return '#t' if the file
     descriptor becomes readable.

 -- Function: select-fd-writable? FD SEC USEC
 -- Function: select-port-writable? PORT SEC USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for a writable event on the single file descriptor FD
     or PORT having a file descriptor as device.  SEC and USEC must be
     fixnums representing timeout seconds and microseconds.

     If the timeout expires before any event arrives: return '#f'.  If
     an error occurs: raise an exception.  Else return '#t' if the file
     descriptor becomes writable.

 -- Function: select-fd-exceptional? FD SEC USEC
 -- Function: select-port-exceptional? PORT SEC USEC
     Interface to the C function 'select()', *note select: (libc)Waiting
     for I/O. Wait for an exceptional event on the single file
     descriptor FD or PORT having a file descriptor as device.  SEC and
     USEC must be fixnums representing timeout seconds and microseconds.

     If the timeout expires before any event arrives: return '#f'.  If
     an error occurs: raise an exception.  Else return '#t' if the file
     descriptor receives an exceptional notification.


File: vicare-libs.info,  Node: posix fd poll,  Next: posix fd device,  Prev: posix fd select,  Up: posix fd

4.13.7 Polling for events
-------------------------

The 'poll' function is an alternative to the 'select' function: it
allows to wait for events on file descriptors.  Meaningless example:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants))

     (define-values (in ou)
       (px.pipe))

     (px.write ou '#vu8(1))

     (define vec
       `#(#(,in ,POLLIN  0)
          #(,ou ,POLLOUT 0)))

     (px.poll vec 10)        => 2

     vec => `#(#(,in ,POLLIN ,POLLIN) #(,ou ,POLLOUT ,POLLOUT))

 -- Function: poll FDS TIMEOUT
     Interface to the C function 'poll()', *note Wait for some event on
     a file descriptor: (*manpages*)poll.  Poll for events the file
     descriptors selected by FDS; TIMEOUT must be an exact integer
     representing the timeout in milliseconds.  If successful: return
     the number of file descriptors ready for an event, else raise an
     exception.

     FDS must be a vector of vectors each having 3 elements: a fixnum
     representing the file descriptor, a fixnum representing the
     'events' field of a 'struct pollfd', a fixnum representing the
     'revents' field of a 'struct pollfd'.  On successful return: the
     third element of the subvectors is mutated to represent the events
     for which the file descriptor is ready.


File: vicare-libs.info,  Node: posix fd device,  Next: posix fd dup,  Prev: posix fd poll,  Up: posix fd

4.13.8 Special device operations
--------------------------------

 -- Function: fcntl FD COMMAND
 -- Function: fcntl FD COMMAND ARG
     Interface to the C function 'fcntl()', *note fcntl: (libc)Control
     Operations.  Perform the operation specified by COMMAND on the file
     descriptor FD using ARG; FD and COMMAND must be fixnums; ARG must
     be '#f', a fixnum, a bytevector or a pointer, if it is '#f' or not
     given no argument is handed to 'fcntl()'.  If successful return a
     fixnum representing the return value of 'fcntl()', else raise an
     exception.

 -- Function: ioctl FD COMMAND
 -- Function: ioctl FD COMMAND ARG
     Interface to the C function 'ioctl()', *note ioctl: (libc)IOCTLs.
     Perform the operation specified by COMMAND on the file descriptor
     FD using ARG; FD and COMMAND must be fixnums; ARG must be '#f', a
     fixnum, a bytevector or a pointer, if it is '#f' or not given no
     argument is handed to 'ioctl()'.  If successful return a fixnum
     representing the return value of 'ioctl()', else raise an
     exception.

* Menu:

* posix fd device blocking::    Non-blocking mode.
* posix fd device cloexec::     Close-on-exec mode.


File: vicare-libs.info,  Node: posix fd device blocking,  Next: posix fd device cloexec,  Up: posix fd device

4.13.8.1 File descriptors in non-blocking mode
..............................................

 -- Function: fd-set-non-blocking-mode! FD
 -- Function: fd-unset-non-blocking-mode! FD
     Special interface to the C function 'fcntl()', *note fcntl:
     (libc)Control Operations.  Configure the file descriptor FD in
     non-blocking mode or blocking mode; if successful return
     unspecified values, else raise an exception.

 -- Function: fd-in-non-blocking-mode? FD
     Special interface to the C function 'fcntl()', *note fcntl:
     (libc)Control Operations.  Query the file descriptor FD for its
     non-blocking mode; if successful: return '#t' if FD is in
     non-blocking mode, '#f' otherwise.  If an error occurs: raise an
     exception.


File: vicare-libs.info,  Node: posix fd device cloexec,  Prev: posix fd device blocking,  Up: posix fd device

4.13.8.2 Close-on-exec mode
...........................

On POSIX platforms, right after a 'fork' call: the parent and child will
share all the input/output file descriptors that are open at the time of
the 'fork' call.  This is problematic.

   Let's see what happens with the following program in which we open a
file, fork the process then close the file in both the parent and child:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.))

     (define (parent-proc child-pid)
       (px.waitpid child-pid 0)
       (close-output-port port)
       (exit 0))

     (define (child-thunk)
       (close-output-port port)
       (exit 0))

     (define port
       (parametrise ((output-file-buffer-size 8))
         (open-file-output-port "demo.txt"
     			   (file-options no-fail)
     			   (buffer-mode block)
     			   (native-transcoder))))

     (put-string port "0123456789ABCDEF")

     (px.fork parent-proc child-thunk)

the output PORT has a buffer of '8' characters and the string written to
it is '16' characters long; the call to 'put-string' immediately flushes
the first '8' characters and leaves the rest in the output buffer.  The
'fork' call causes the output buffer and its contents to be duplicated,
so, when we close the port, the two buffers are flushed to the same
file.  The resulting file contents are:

     0123456789ABCDEF89ABCDEF

which is not what we want.

   POSIX has a partial solution for this problem: to configure file
descriptors as _close-on-exec_; Vicare extends this to propose a partial
solution: to configure ports as _close-on-exec_.  Notice that it is
close-on-*exec*, not close-on-*fork*.  So we can try to address this
problem by:

  1. Registering ports to be in close-on-exec mode.

  2. Before calling 'fork': flush the ports in close-on-exec mode.

  3. In the child process: close the ports in close-on-exec mode, to
     free allocated file descriptors.

   Here is the example above modified to do so:

     #!vicare
     (import (vicare)
       (prefix (vicare posix) px.))

     (define (parent-proc child-pid)
       (px.waitpid child-pid 0)
       (close-output-port port)
       (exit 0))

     (define (child-thunk)
       (px.close-ports-in-close-on-exec-mode)
       (exit 0))

     (define port
       (parametrise ((output-file-buffer-size 8))
         (open-file-output-port "demo.txt"
                                (file-options no-fail)
                                (buffer-mode block)
                                (native-transcoder))))

     (px.port-set-close-on-exec-mode! port)

     (put-string port "0123456789ABCDEF")

     (px.flush-ports-in-close-on-exec-mode)
     (px.fork parent-proc child-thunk)

File descriptors in close-on-exec mode
......................................

 -- Function: fd-set-close-on-exec-mode! FD
 -- Function: fd-unset-close-on-exec-mode! FD
     Special interface to the C function 'fcntl()', *note fcntl:
     (libc)Control Operations.  Configure the file descriptor FD in
     "close on exec" mode or "do not close on exec" mode; if successful
     return unspecified values, else raise an exception.

 -- Function: fd-in-close-on-exec-mode? FD
     Special interface to the C function 'fcntl()', *note fcntl:
     (libc)Control Operations.  Query the file descriptor FD for its
     "close on exec" mode; if successful: return '#t' if FD is in "close
     on exec" mode, '#f' otherwise.  If an error occurs: raise an
     exception.

Ports in close-on-exec mode
...........................

 -- Function: port-set-close-on-exec-mode! PORT
     Register a Scheme PORT to be closed if the current process uses one
     of the 'exec' functions.  If successful: return unspecified values,
     else raise an exception.

     PORT can be any port: it is *not* required for it to have a file
     descriptor as underlying device.  If the underlying device is a
     file descriptor: this descriptor is configured in close-on-exec
     mode.

 -- Function: port-unset-close-on-exec-mode! PORT
     Unregister a Scheme PORT so that it is *not* closed if the current
     process uses one of the 'exec' functions.  If successful: return
     unspecified values, else raise an exception.

     If the underlying device is a file descriptor: this descriptor is
     configured *not* to be in close-on-exec mode.

 -- Function: port-in-close-on-exec-mode? PORT
     Return a boolean: true if PORT is in close-on-exec mode, false
     otherwise.

 -- Function: close-ports-in-close-on-exec-mode
 -- Function: close-ports-in-close-on-exec-mode ERROR-HANDLER
     Close all the ports registered to be in close-on-exec mode.  Each
     port is closed by applying 'close-port' to it.

        * When called with no arguments: if 'close-port' raises an
          exception, the exception is blocked and discarded.

        * When called with one argument: the procedure ERROR-HANDLER is
          installed as error handler before applying 'close-port' to the
          port; if ERROR-HANDLER raises an exception, the exception is
          blocked and discarded.

 -- Function: flush-ports-in-close-on-exec-mode
 -- Function: flush-ports-in-close-on-exec-mode ERROR-HANDLER
     Flush the output buffer of all the output ports registered to be in
     close-on-exec mode.  Each port is processed by applying
     'flush-output-port' to it.

        * When called with no arguments: if 'flush-output-port' raises
          an exception, the exception is blocked and discarded.

        * When called with one argument: the procedure ERROR-HANDLER is
          installed as error handler before applying 'flush-output-port'
          to the port; if ERROR-HANDLER raises an exception, the
          exception is blocked and discarded.


File: vicare-libs.info,  Node: posix fd dup,  Next: posix fd pipe,  Prev: posix fd device,  Up: posix fd

4.13.9 Duplicating file descriptors
-----------------------------------

The functions 'dup' and 'dup2' are often used to prepare the standard
file descriptors of a child process right after a 'fork' call; *note
Creating a subprocess: posix process fork, for details about this usage.

 -- Function: dup FD
     Interface to the C function 'dup()', *note dup: (libc)Duplicating
     Descriptors.  Duplicate the file descriptor FD.  If successful
     return a non-negative fixnum representing the new descriptor, else
     raise an exception.

 -- Function: dup2 OLD NEW
     Interface to the C function 'dup2()', *note dup: (libc)Duplicating
     Descriptors.  Duplicate the file descriptor OLD to NEW.  If
     successful return unspecified values, else raise an exception.


File: vicare-libs.info,  Node: posix fd pipe,  Next: posix fd fifo,  Prev: posix fd dup,  Up: posix fd

4.13.10 File descriptor pipes
-----------------------------

 -- Function: pipe
     Interface to the C function 'pipe()', *note pipe: (libc)Creating a
     Pipe.  Create a pair of file descriptors connected through a pipe.
     If successful return two values being fixnums representing the file
     descriptors, else raise an exception.

   The following is a simple example of process writing to itself
through a pipe:

     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.))

     (receive (in ou)
         (px.pipe)
       (px.write ou '#vu8(1 2 3 4) 4)
       (receive-and-return (bv)
           (make-bytevector 4)
         (px.read in bv 4)))
     => #vu8(1 2 3 4)


File: vicare-libs.info,  Node: posix fd fifo,  Next: posix fd trunc,  Prev: posix fd pipe,  Up: posix fd

4.13.11 File descriptor fifos
-----------------------------

 -- Function: mkfifo PATHNAME MODE
     Interface to the C function 'mkfifo()', *note mkfifo: (libc)FIFO
     Special Files.  Create a FIFO special file with name PATHNAME and
     mode MODE, which must be a fixnum.  If successful return
     unspecified values, else raise an exception.


File: vicare-libs.info,  Node: posix fd trunc,  Next: posix fd lock,  Prev: posix fd fifo,  Up: posix fd

4.13.12 Truncating files
------------------------

 -- Function: truncate PATHNAME LENGTH
     Interface to the C function 'truncate()', *note truncate:
     (libc)File Size.  Change the size of the file selected by PATHNAME
     to LENGTH; if successful return unspecified values, else raise an
     exception.

     LENGTH must be non-negative exact integer in the range of the C
     language type 'off_t'.

 -- Function: ftruncate FD LENGTH
     Interface to the C function 'ftruncate()', *note ftruncate:
     (libc)File Size.  Changes the size of the file selected by the file
     descriptor FD to LENGTH; if successful return unspecified values,
     else raise an exception.

     LENGTH must be non-negative exact integer in the range of the C
     language type 'off_t'.


File: vicare-libs.info,  Node: posix fd lock,  Prev: posix fd trunc,  Up: posix fd

4.13.13 Locking files
---------------------

 -- Function: lockf FD CMD LEN
     Interface to the C function 'lockf()', *note lockf:
     (*manpages*)lockf.  Apply, test or remove a POSIX lock on a section
     of an open file; if successful return unspecified values, else
     raise an exception

     The file is selected by the file descriptor FD.  The action by the
     signed integer CMD.  The file section is from the current position
     up to LEN bytes.

     CMD must be one of the constants: 'F_LOCK', 'F_TLOCK', 'F_ULOCK',
     'F_TEST'.


File: vicare-libs.info,  Node: posix mmap,  Next: posix socket,  Prev: posix fd,  Up: posix

4.14 Memory-mapped input/output
===============================

*note Shared memory through 'mmap': (vicare-scheme)shmem mmap. for a
description of shared memory through 'mmap'.

 -- Function: mmap ADDRESS LENGTH PROTECT FLAGS FD OFFSET
     Interface to the C function 'mmap()', *note mmap:
     (libc)Memory-mapped I/O. Create a new mapping and return a pointer
     object referencing the region of memory.

     ADDRESS can be '#f' or a pointer object; '#f' is interpreted as a
     'NULL' pointer.  LENGTH must be an exact integer in the range of
     the C language type 'size_t'.  PROTECT and FLAGS must fixnums of
     flags.  FD must be a fixnum representing a file descriptor.  OFFSET
     must be an exact integer in the range of the C language type
     'off_t'.

          *NOTE* On BSD and Darwin systems only 'MAP_ANON' is defined,
          'MAP_ANONYMOUS' is undefined.

 -- Function: munmap ADDRESS LENGTH
     Interface to the C function 'munmap()', *note munmap:
     (libc)Memory-mapped I/O. Remove memory mapping.  Return unspecified
     values.

     ADDRESS is a pointer object referencing the mapping.  LENGTH must
     be an exact integer in the range of the C language type 'size_t'.

 -- Function: msync ADDRESS LENGTH FLAGS
     Interface to the C function 'msync()', *note msync:
     (libc)Memory-mapped I/O. Synchronise the mapping with the
     underlying file.  Return unspecified values.

     ADDRESS is a pointer object referencing the mapping.  LENGTH must
     be an exact integer in the range of the C language type 'size_t'.
     FLAGS is a fixnum of flags.

 -- Function: mremap ADDRESS LENGTH NEW-LENGTH FLAGS
     Interface to the C function 'mremap()', *note mremap:
     (libc)Memory-mapped I/O. Change the size of an existing memory
     mapping; return a pointer object referencing the new mapping.

     ADDRESS is a pointer object referencing the mapping.  LENGTH and
     NEW-LENGTH must be exact integers in the range of the C language
     type 'size_t'.  FLAGS is a fixnum of flags.

 -- Function: madvise ADDRESS LENGTH ADVICE
     Interface to the C function 'madvise()', *note madvise:
     (libc)Memory-mapped I/O. Synchronise the mapping with the
     underlying file.  Return unspecified values.

     ADDRESS is a pointer object referencing the mapping.  LENGTH must
     be an exact integer in the range of the C language type 'size_t'.
     ADVICE is a fixnum of flags.

 -- Function: mlock ADDRESS LENGTH
 -- Function: munlock ADDRESS LENGTH
     Interface to the C functions 'mlock()' and 'munlock()', see the
     manual page 'mlock(2)'.  Lock or unlock a segment of virtual
     address space, preventing the memory from begin paged to the swap
     area.  If successful return unspecified values, else raise an
     exception.

 -- Function: mlockall FLAGS
 -- Function: munlockall
     Interface to the C functions 'mlockall()' and 'munlockall()', see
     the manual page 'mlock(2)'.  Lock or unlock all pages.  If
     successful return unspecified values, else raise an exception.
     FLAGS must be a fixnum being an OR combination of the constants:
     'MCL_CURRENT', 'MCL_FUTURE'.


File: vicare-libs.info,  Node: posix socket,  Next: posix users,  Prev: posix mmap,  Up: posix

4.15 Network sockets
====================

With the purpose of keeping at the Scheme level the same semantics of
the C level POSIX API, socket-related data structures are stored in
bytevectors; such raw manipulation can cause the process to crash if we
mishandle the values.

   For an introduction to the IP and related protocols APIs, on
GNU+Linux system, we should read the manual pages: *note Linux socket
interface: (*manpages*)ip(7), *note Packet interface on device level:
(*manpages*)packet(7), *note IP Protocol: (*manpages*)ip(7), *note TCP
Protocol: (*manpages*)tcp(7), *note UDP Protocol: (*manpages*)udp(7),
*note ICMP Protocol: (*manpages*)icmp(7), *note Raw sockets:
(*manpages*)raw(7).

* Menu:

* posix socket addresses::      Network address structures.
* posix socket hosts::          Network hosts database.
* posix socket protocols::      Network protocols database.
* posix socket services::       Network services database.
* posix socket networks::       Networks database.
* posix socket socket::         Network sockets operations.
* posix socket misc::           Error and miscellaneous functions.
* posix socket examples::       Examples of clients and servers.
* posix socket oob::            Notes on transmission of OOB data.

