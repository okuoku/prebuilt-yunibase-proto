This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: srfi random license,  Next: srfi random abstract,  Up: srfi random

2.16.1 Random document license
------------------------------

Copyright (C) 2002 Sebastian Egner.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi random abstract,  Next: srfi random rationale,  Prev: srfi random license,  Up: srfi random

2.16.2 Abstract
---------------

This document specifies an interface to sources of random bits, or
"random sources" for brevity.  In particular, there are three different
ways to use the interface, with varying demands on the quality of the
source and the amout of control over the production process:

   * The "no fuss" interface specifies that '(random-integer n)'
     produces the next random integer in '{0, ..., n-1}' and
     '(random-real)' produces the next random real number between zero
     and one.  The details of how these random values are produced may
     not be very relevant, as long as they appear to be sufficiently
     random.

   * For simulation purposes, on the contrary, it is usually necessary
     to know that the numbers are produced deterministically by a pseudo
     random number generator of high quality and to have explicit access
     to its state.  In addition, one might want to use several
     independent sources of random numbers at the same time and it can
     be useful to have some simple form of randomization.

   * For security applications a serious form of true randomization is
     essential, in the sense that it is difficult for an adversary to
     exploit or introduce imperfections into the distribution of random
     bits.  Moreover, the linear complexity of the stream of random bits
     is more important than its statistical properties.  In these
     applications, an entropy source (producing truly random bits at a
     low rate) is used to randomize a pseudo random number generator to
     increase the rate of available bits.

   Once random sources provide the infrastructure to obtain random bits,
these can be used to construct other random deviates.  Most important
are floating point numbers of various distributions and random discrete
structures, such as permutations or graphs.  As there is an essentially
unlimited number of such objects (with limited use elsewhere), we do not
include them in this SRFI.  In other words, this SRFI is not about
making all sorts of random objects; it is about obtaining random bits in
a portable, flexible, reliable, and efficient way.


File: vicare-libs.info,  Node: srfi random rationale,  Next: srfi random spec,  Prev: srfi random abstract,  Up: srfi random

2.16.3 Rationale
----------------

This SRFI defines an interface for sources of random bits computed by a
pseudo random number generator.  The interface provides range-limited
integer and real numbers.  It allows accessing the state of the
underlying generator.  Moreover, it is possible to obtain a large number
of independent generators and to invoke a mild form of true
randomization.

   The design aims at sufficient flexibility to cover the usage patterns
of many applications as diverse as discrete structures, numerical
simulations, and cryptographic protocols.  At the same time, the
interface aims at simplicity, which is important for occasional use.  As
there is no "one size fits all" random number generator, the design
necessarily represents some form of compromise between the needs of the
various applications.

   Although strictly speaking not part of the specification, the
emphasis of this proposal is on high quality random numbers and on high
performance.  As the state of the art in pseudo random number generators
is still advancing considerably, the choice of method for the reference
implementation should essentially be considered preliminary.


File: vicare-libs.info,  Node: srfi random spec,  Next: srfi random design,  Prev: srfi random rationale,  Up: srfi random

2.16.4 Specification
--------------------

 -- Function: random-integer N
     The next integer X in '{0, ..., n-1}' obtained from
     'default--random--source'.  Subsequent results of this procedure
     appear to be independent uniformly distributed over the range '{0,
     ..., n-1}'.  The argument N must be a positive integer, otherwise
     an error is signalled.

 -- Function: random-real
     The next number '0 < x < 1' obtained from 'default-random-source'.
     Subsequent results of this procedure appear to be independent
     uniformly distributed.  The numerical type of the results and the
     quantization of the output range depend on the implementation;
     refer to 'random-source-make-reals' for details.

 -- Variable: default-random-source
     A random source from which 'random-integer' and 'random-real' have
     been derived using 'random-source-make-integers' and
     'random-source-make-reals'.

     Note that an assignment to 'default-random-source' does not change
     the already built 'random-integer' or 'random-real'; it is also
     strongly recommended not to assign a new value.

 -- Function: make-random-source
     Create a new random source S.  Implementations may accept
     additional, optional arguments in order to create different types
     of random sources.  A random source created with
     'make-random-source' represents a deterministic stream of random
     bits generated by some form of pseudo random number generator.
     Each random source obtained as '(make-random-source)' generates the
     same stream of values, unless the state is modified with one of the
     procedures below.

 -- Function: random-source? OBJ
     Tests if OBJ is a random source.  Objects of type random source are
     distinct from all other types of objects.

 -- Function: random-source-state-ref S
 -- Function: random-source-state-set! S STATE
     Get and set the current state of a random source S.  The structure
     of the object state depends on the implementation; the only
     portable use of it is as argument to 'random-source-state-set!'.
     It is, however, required that a state possess an external
     representation.

 -- Function: random-source-randomize! S
     Makes an effort to set the state of the random source s to a truly
     random state.  The actual quality of this randomization depends on
     the implementation but it can at least be assumed that the
     procedure sets s to a different state for each subsequent run of
     the Scheme system.

 -- Function: random-source-pseudo-randomize! S I J
     Changes the state of the random source S into the initial state of
     the (I, J)-th independent random source, where I and J are
     non-negative integers.  This procedure provides a mechanism to
     obtain a large number of independent random sources (usually all
     derived from the same backbone generator), indexed by two integers.
     In contrast to 'random-source-randomize!', this procedure is
     entirely deterministic.

 -- Function: random-source-make-integers S
     Obtains a procedure RAND to generate random integers using the
     random source S.  RAND takes a single argument N, which must be a
     positive integer, and returns the next uniformly distributed random
     integer from the interval '{0, ..., n-1}' by advancing the state of
     the source S.

     If an application obtains and uses several generators for the same
     random source S, a call to any of these generators advances the
     state of S.  Hence, the generators do not produce the same sequence
     of random integers each but rather share a state.  This also holds
     for all other types of generators derived from a fixed random
     source.  Implementations that support concurrency make sure that
     the state of a generator is properly advanced.

 -- Function: random-source-make-reals S
 -- Function: random-source-make-reals S UNIT
     Obtains a procedure RAND to generate random real numbers '0 < x <
     1' using the random source S.  The procedure RAND is called without
     arguments.

     The optional parameter UNIT determines the type of numbers being
     produced by RAND and the quantization of the output.  UNIT must be
     a number such that '0 < unit < 1'.  The numbers created by rand are
     of the same numerical type as unit and the potential output values
     are spaced by at most UNIT.

     One can imagine RAND to create numbers as 'x*unit' where X is a
     random integer in '{1, ..., floor(1/unit)-1}'.  Note, however, that
     this need not be the way the values are actually created and that
     the actual resolution of RAND can be much higher than UNIT.  In
     case UNIT is absent it defaults to a reasonably small value
     (related to the width of the mantissa of an efficient number
     format).


File: vicare-libs.info,  Node: srfi random design,  Next: srfi random usage,  Prev: srfi random spec,  Up: srfi random

2.16.5 Design rationale
-----------------------

Why not combine 'random-integer' and 'random-real?'
...................................................

The two procedures are not combined into a single variable-arity
procedures to save a little time and space during execution.  Although
some Scheme systems can deal with variable arity as efficiently as with
fixed arity this is not always the case and time efficiency is very
important here.

Why not some object-oriented interface?
.......................................

There are many alternatives to the interface as specified in this SRFI.
In particular, every framework for object-orientation can be used to
define a class for random sources and specify the interface for the
methods on random sources.  However, as the object-oriented frameworks
differ considerably in terms of syntax and functionality, this SRFI does
not make use of any particular framework.

Why is there not just a generator with a fixed range?
.....................................................

A bare fixed-range generator is of very limited use.  Nearly every
application has to add some functionality to make use of the random
numbers.  The most fundamental task in manipulating random numbers is to
change the range and quantization.  This is exactly what is provided by
'random-integer' and 'random-real'.  In addition, is saves the user from
the pitfall of changing the range with a simple modulo-computation which
may substantially reduce the quality of the numbers being produced.

   The design of the interface is based on three prototype applications:

   * Repeatedly choose from relatively small sets: As the size of the
     set is likely to vary from call to call, 'random-integer' accepts a
     range argument N in every call.  The implementation should try to
     avoid boxing/unboxing of values if the ranges fit into immediate
     integers.

   * Generate a few large integers with a fixed number of bits: As
     generating the random number itself is expensive, passing the range
     argument in every call does not hurt performance.  Hence, the same
     interface as in the first application can be used.

   * Generate real numbers: Unlike the choose-from-set case, the range
     and the quantization is constant over a potentially very large
     number of calls.  In addition, there are usually just a few
     distinct instances of quantization and number type, most likely
     corresponding to underlying 'float' and 'double' representations.
     Therefore, 'random-real' does not accept any parameters but the
     procedure 'random-source-make-reals' creates a properly configured
     'random-real' procedure.

Why bother about floating point numbers at all?
...............................................

A proper floating point implementation of a random number generator is
potentially much more efficient that an integer implementation because
it can use more powerful arithmetics hardware.  If in addition the
application needs floating point random numbers it would be an
intolerable waste to run an integer generator to produce floating point
random numbers.  A secondary reason is to save the user from the "not as
easy as it seems" task of converting an integer generator into a real
generator.

Why are zero and one excluded from 'random-real'?
.................................................

The procedure 'random-real' does not return 'x = 0' or 'x = 1' in order
to allow '(log x)' and '(log (- 1 x))' without the danger of a numerical
exception.


File: vicare-libs.info,  Node: srfi random usage,  Next: srfi random ack,  Prev: srfi random design,  Up: srfi random

2.16.6 Recommended usage patterns
---------------------------------

Unless the functionality defined in this SRFI is sufficient, an
application has to implement more procedures to construct other random
deviates.  This section contains some recommendation on how to do this
technically by presenting examples of increasing difficulty with respect
to the interface.  Note that the code below is not part of the
specification, it is merely meant to illustrate the spirit

Generating Random Permutations
..............................

The following code defines procedures to generate random permutations of
the set '{0, ..., n-1}'.  Such a permutation is represented by a vector
of length N for the images of the points.

   Observe that the implementation first defines the procedure
'random-source-make-permutations' to turn a random source S into a
procedure to generate permutations of given degree N.  In a second step,
this is applied to the default source to define a ready-to-use procedure
for permutations: '(random-permutation n)' constructs a random
permutation of degree N.

     (define (random-source-make-permutations s)
       (let ([rand (random-source-make-integers s)])
         (lambda (n)
           (let ([x (make-vector n 0)])
             (do ([i 0 (+ i 1)])
                 ([= i n])
               (vector-set! x i i))
             (do ([k n (- k 1)])
                 ([= k 1] x)
               (let* ([i (- k 1)]
                      [j (rand k)]
                      [xi (vector-ref x i)]
                      [xj (vector-ref x j)])
                 (vector-set! x i xj)
                 (vector-set! x j xi)))))))

     (define random-permutation
       (random-source-make-permutations default-random-source))

   For the algorithm refer to Knuth's "The Art of Computer Programming",
Vol.  II, 2nd ed., Algorithm P of Section 3.4.2.

Generating Exponentially-Distributed Random Numbers
...................................................

The following code defines procedures to generate exponentially
Exp(mu)-distributed random numbers.  The technical difficulty of the
interface addressed here is how to pass optional arguments to
'random-source-make-reals'.

     (define (random-source-make-exponentials s . unit)
       (let ((rand (apply random-source-make-reals s unit)))
         (lambda (mu)
           (- (* mu (log (rand)))))))

     (define random-exponential
       (random-source-make-exponentials default-random-source))

   The algorithm is folklore.  Refer to Knuth's "The Art of Computer
Programming", Vol.  II, 2nd ed., Section 3.4.1.D.

Generating Normally-Distributed Random Numbers
..............................................

The following code defines procedures to generate normal N(mu,
sigma)-distributed real numbers using the polar method.

   The technical difficulty of the interface addressed here is that the
polar method generates two results per computation.  We return one of
the result and store the second one to be returned by the next call to
the procedure.  Note that this implies that 'random-source-state-set!'
(and the other procedures modifying the state) does not necessarily
affect the output of 'random-normal' immediately!

     (define (random-source-make-normals s . unit)
       (let ([rand (apply random-source-make-reals s unit)]
             [next #f])
         (lambda (mu sigma)
           (if next
               (let ([result next])
                 (set! next #f)
                 (+ mu (* sigma result)))
             (let loop ()
               (let* ([v1 (- (* 2 (rand)) 1)]
                      [v2 (- (* 2 (rand)) 1)]
                      [s (+ (* v1 v1) (* v2 v2))])
                 (if (>= s 1)
                     (loop)
                   (let ([scale (sqrt (/ (* -2 (log s)) s))])
                     (set! next (* scale v2))
                     (+ mu (* sigma scale v1))))))))))

     (define random-normal
       (random-source-make-normals default-random-source))

   For the algorithm refer to Knuth's "The Art of Computer Programming",
Vol.  II, 2nd ed., Algorithm P of Section 3.4.1.C.


File: vicare-libs.info,  Node: srfi random ack,  Next: srfi random references,  Prev: srfi random usage,  Up: srfi random

2.16.7 Acknowledgements
-----------------------

I would like to thank all people who have participated in the
discussion, in particular Brad Lucier and Pierre l'Ecuyer.  Their
contributions have greatly improved the design of this SRFI.  Moreover,
Brad has optimized the Gambit implementation quite substantially.


File: vicare-libs.info,  Node: srfi random references,  Prev: srfi random ack,  Up: srfi random

2.16.8 References
-----------------

_Diehard---Testsuite for Random Number Generators_.  G. Marsaglia.  Also
contains some generators that do pass Diehard.

                   <stat.fsu.edu/~geo/diehard.html>

_The Art of Computer Programming; Volume II Seminumerical Algorithms.
2nd ed._  D. E. Knuth.  Addison-Wesley, 1981.  The famous chapter on
random number generators.

_Software for Uniform Random Number Generation: Distinguishing the Good
and the Bad_.  P. L'Ecuyer.  Proceedings of the 2001 Winter Simulation
Conference, IEEE Press, Dec.  2001, 95-105.  Profound discussion of
random number generators.

       <www.iro.umontreal.ca/~lecuyer/myftp/papers/wsc01rng.pdf>

_Good Parameter Sets for Combined Multiple Recursive Random Number
Generators_.  P. L'Ecuyer.  Shorter version in Operations Research, 47,
1 (1999), 159-164.  Actual numbers for good generators.

       <www.iro.umontreal.ca/~lecuyer/myftp/papers/combmrg2.ps>

_MIT Scheme v7.6_.  A mechanism to run a fixed unspecified generator.

<http://www.swiss.ai.mit.edu/projects/scheme/documentation/scheme_5.html#SEC53>

_SLIB 2d2 with '(require 'random)'_.  A. Jaffer.

        <http://swiss.csail.mit.edu/~jaffer/slib_5.html#SEC108>

_Scheme 48 v0.57_.  R. Kelsey, J. Rees.  Internal procedures of
Scheme48; a fixed 28-bit generator.

_PLT MzScheme Version 200alpha1_.  M. Flatt.  A mechanism to run a
generator and to exchange the generator.

<http://download.plt-scheme.org/doc/200alpha1/html/mzscheme/mzscheme-Z-H-3.html#%_idx_144>

_Structure and Interpretation of Computer Programs_.  H. Abelson, G. J.
Sussmann, J. Sussman.  The rand-example shows a textbook way to define a
random number generator.

<http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_idx_2934>

_A portable random-number generator_.  John David Stone.  An
implementation of a linear congruental generator in Scheme.

 <http://www.math.grin.edu/~stone/events/scheme-workshop/random.html>

_RFC1750: Randomness Recommendations for Security_.  Network Working
Group.  A serious discussion of serious randomness for serious security.

        <http://www.cis.ohio-state.edu/htbin/rfc/rfc1750.html>

Resources on random number generators and randomness:

                  <http://www.random.org/essay.html>
             <http://www.taygeta.com/random/randrefs.html>


File: vicare-libs.info,  Node: srfi basic-format,  Next: srfi rec,  Prev: srfi random,  Up: srfi

2.17 SRFI-28 basic format strings
=================================

The library '(srfi :28)' is by Scott G. Miller as the reference
implementation for SRFI-28; see:

            <http://srfi.schemers.org/srfi-28/srfi-28.html>

for more details.

* Menu:

* srfi basic-format abstract::  Abstract.
* srfi basic-format rationale:: Rationale.
* srfi basic-format spec::      Specification.
* srfi basic-format examples::  Examples.
* srfi basic-format copyright:: Copyright.


File: vicare-libs.info,  Node: srfi basic-format abstract,  Next: srfi basic-format rationale,  Up: srfi basic-format

2.17.1 Abstract
---------------

This document specifies _Format Strings_, a method of interpreting a
Scheme string which contains a number of escape sequences that are
replaced with other string data according to the semantics of each
sequence.


File: vicare-libs.info,  Node: srfi basic-format rationale,  Next: srfi basic-format spec,  Prev: srfi basic-format abstract,  Up: srfi basic-format

2.17.2 Rationale
----------------

Many Scheme systems provide access to a function called 'format'.  This
function takes as arguments a format string, an ordinary Scheme string
containing zero or more escape sequences, followed zero or more Scheme
values.  The procedure processes the format string and performs string
replacement on the escape sequences according to the rules for each
code.  This SRFI defines a basic version of format which should allow
portable code to be written using the function without much (if any)
effort on the part of Scheme implementors.


File: vicare-libs.info,  Node: srfi basic-format spec,  Next: srfi basic-format examples,  Prev: srfi basic-format rationale,  Up: srfi basic-format

2.17.3 Specification
--------------------

 -- Function: format FORMAT-STRING OBJ ...
     Accept a message template (a Scheme String), and processes it,
     replacing any escape sequences in order with one or more
     characters, the characters themselves dependent on the semantics of
     the escape sequence encountered.

     An escape sequence is a two character sequence in the string where
     the first character is a tilde '~'.  Each escape code's meaning is
     as follows:

     '~a'
          The corresponding value is inserted into the string as if
          printed with 'display'.

     '~s'
          The corresponding value is inserted into the string as if
          printed with 'write'.

     '~%'
          A newline is inserted.

     '~~'
          A tilde '~' is inserted.

     '~a' and '~s', when encountered, require a corresponding Scheme
     value to be present after the format string.  The values provided
     as operands are used by the escape sequences in order.  It is an
     error if fewer values are provided than escape sequences that
     require them.

     '~%' and '~~' require no corresponding value.


File: vicare-libs.info,  Node: srfi basic-format examples,  Next: srfi basic-format copyright,  Prev: srfi basic-format spec,  Up: srfi basic-format

2.17.4 Examples
---------------

     (format "Hello, ~a" "World!")
     => "Hello, World!"

     (format "Error, list is too short: ~s~%" '(one "two" 3))
     => "Error, list is too short: (one \"two\" 3)\n"


File: vicare-libs.info,  Node: srfi basic-format copyright,  Prev: srfi basic-format examples,  Up: srfi basic-format

2.17.5 Copyright
----------------

Copyright (C) 2002 Scott G. Miller.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi rec,  Next: srfi parameters,  Prev: srfi basic-format,  Up: srfi

2.18 SRFI-31 a special form 'rec' for recursive evaluation
==========================================================

The library '(srfi :31)' is by Mirko Luedde <Mirko.Luedde@SAP.com> as
the reference implementation for SRFI-31; see:

            <http://srfi.schemers.org/srfi-31/srfi-31.html>

for more details.

* Menu:

* srfi rec license::            Rec document license.
* srfi rec abstract::           Abstract.
* srfi rec rationale::          Rationale.
* srfi rec spec::               Specification.
* srfi rec ack::                Acknowledgements.
* srfi rec references::         References.


File: vicare-libs.info,  Node: srfi rec license,  Next: srfi rec abstract,  Up: srfi rec

2.18.1 Rec document license
---------------------------

Copyright (C) 2002 Dr.  Mirko Luedde.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi rec abstract,  Next: srfi rec rationale,  Prev: srfi rec license,  Up: srfi rec

2.18.2 Abstract
---------------

We propose the implementation of a special form called 'rec'.  This form
is a generalization and combination of the forms 'rec' and
'named-lambda' of [Clinger1985].  It allows the simple and
non-imperative construction of self-referential expressions.

   As an important special case, it extends the A. Church form 'lambda'
such that it allows the direct definition of recursive procedures
without using further special forms like 'let' or 'letrec', without
using advanced constructions like the H. B. Curry combinator and, unlike
'define', without introducing variable bindings into the external
environment.


File: vicare-libs.info,  Node: srfi rec rationale,  Next: srfi rec spec,  Prev: srfi rec abstract,  Up: srfi rec

2.18.3 Rationale
----------------

General
-------

Among the prominent features of the Scheme programming language as
defined in [KCR1998] are the following:

   * it has simple syntax;

   * it encourages recursive definitions, e.g.  by ensuring memory
     efficient tail recursion;

   * it supports non-imperative programming.

   Nevertheless Scheme does not provide a syntax for recursive
evaluations with the properties of:

   * being as simple, intuitive and close to the mathematical standard
     notation as possible;

   * allowing general recursion;

   * being non-imperative.

Example
-------

Problem 1
.........

Let us look at the factorial function.  In mathematical notation this
function is expressed as:

     (F : N |--> 1,            if N = 0;
                 N * F(N - 1), otherwise

   This expression is a term and not a definition or proposition.

   We investigate some approaches to express the factorial function in
Scheme.

   * The simplest way perhaps is as:

          (define (F N)
            (if (zero? N)
                1
              (* N (F (- N 1)))))

     But this expression is not a term.  It binds the factorial function
     to the variable F.  The expression itself may not occur in a
     syntactical context where a name of the factorial is required.

   * We list several ways to express the factorial as a function term.

       1.      (let ()
                 (define (F N)
                   (if (zero? N)
                       1
                     (* N (F (- N 1)))))
                     F)

       2.      (lambda (N)
                 (let F ([N N])
                   (if (zero? N)
                       1
                     (* N (F (- N 1))))))

       3.      (letrec ([F (lambda (N)
                             (if (zero? N)
                                 1
                               (* N (F (- N 1)))))])
                 F)

       4.      ((lambda (F)
                  (F F))
                (lambda (G)
                  (lambda (N)
                    (if (zero? N)
                        1
                      (* N ((G G) (- N 1)))))))

     All these expressions define the factorial anonymously, not binding
     it to a variable.  However, all these expressions are more verbose
     than it seems necessary and they are less intuitive than it seems
     desirable.

Solution 1
..........

A solution to our problem was already provided in [Clinger1985] by the
form 'named-lambda'.  An even earlier solution with a slightly different
syntax was implemented in Kent Dybvig's Chez Scheme system.  Using this
special form, we can denote the factorial simply by:

     (named-lambda (F N)
       (if (zero? N)
           1
         (* N (F (- N 1)))))

   This expression is a function term that denotes the factorial in the
appropriate brevity.

   However, the form 'named-lambda' has been dropped from later versions
of the Scheme Report.  Also it is missing in state-of-the-art
implementations such as Chez Scheme (6.0a) and MIT Scheme (7.7.0).  (The
latter actually knows a form 'named-lambda' with different semantics.)

Problem 2
.........

The constant stream of ones can be defined via:

     (define S (cons 1 (delay S)))

   As in the case of the factorial, we are able to define the recursive
object at the price of spending an externally bound name.  Remedying
this with let or letrec leads to similar objections as above.

Solution 2
..........

This particular case of the self-referential problem was solved by the
'rec' form in [Clinger1985].  This form allows writing:

     (rec S (cons 1 (delay S)))

   This expression is non-imperative and does not introduce an external
variable binding.

   Also this form has been dropped from later versions of the Scheme
Report.  Moreover, from our point of view this form alone is not capable
of solving Problem 1.  The respective definition would look like:

     (rec F
       (lambda (N)
         (if (zero? N)
             1
           (* N (F (- N 1))))))

   This again does not seem quite as simple and intuitive as the
mathematical notation.

Proposal
--------

We therefore propose to implement the 'rec' special form in a
generalized way that combines the advantages of the 'named-lambda' and
'rec' forms.  The factorial function could be written:

     (rec (F N)
       (if (zero? N)
           1
         (* N (F (- N 1)))))


File: vicare-libs.info,  Node: srfi rec spec,  Next: srfi rec ack,  Prev: srfi rec rationale,  Up: srfi rec

2.18.4 Specification
--------------------

Syntax
......

The following production rules are to be added to those of [KCR1998] (we
reuse names of non-terminals).

     <derived expression> --> <rec expression>
     <rec expression>     --> (rec <variable>    <expression>)
     <rec expression>     --> (rec (<variable>+) <body>)

Semantics
.........

Scheme versions such as [KCR1998] providing 'define-syntax',
'syntax-rules', 'letrec' and 'lambda' might implement 'rec' as follows.

     (define-syntax rec
       (syntax-rules ()
         [(rec (NAME . VARIABLES) . BODY)
          (letrec ( (NAME (lambda VARIABLES . BODY)) ) NAME)]
         [(rec NAME EXPRESSION)
          (letrec ( (NAME EXPRESSION) ) NAME)]))

Test
....

The following session shows in which way 'rec' allows a tail-recursive
implementation of the factorial function.

     > (define F (rec (F N)
                     ((rec (G K L)
                        (if (zero? K) L
                          (G (- K 1) (* K L)))) N 1)))
     > F
     #<procedure>
     > (F 0)
     1
     > (F 10)
     3628800


File: vicare-libs.info,  Node: srfi rec ack,  Next: srfi rec references,  Prev: srfi rec spec,  Up: srfi rec

2.18.5 Acknowledgements
-----------------------

The author thanks Al Petrofsky for the final solution and Hal Abelson,
Chris Hanson and others for their input.  The work of the maintainers of
the SRFI forum is highly appreciated.


File: vicare-libs.info,  Node: srfi rec references,  Prev: srfi rec ack,  Up: srfi rec

2.18.6 References
-----------------

[Clinger1985] _Draft of Report of the October 1984 Workshop on Scheme_.
W. Clinger.  Proceedings Brandeis Workshop Oct.  22-23, 1984.  March,
1985.

    <http://www.swiss.ai.mit.edu/ftpdir/scheme-mail/HTML/rrrs-1985>

[KCR1998] _Revised^5 Report on the Algorithmic Language Scheme_.  R.
Kelsey, W. Clinger, J. Rees.  Higher-Order and Symbolic Computation,
volume 11, number 1, September 1998.


File: vicare-libs.info,  Node: srfi parameters,  Next: srfi args-fold,  Prev: srfi rec,  Up: srfi

2.19 SRFI-39 parameter objects
==============================

The library '(srfi :39)' is by Marc Feeley as the reference
implementation for SRFI-39; see:

            <http://srfi.schemers.org/srfi-39/srfi-39.html>

for more details.

* Menu:

* srfi parameters license::     Parameters document license.
* srfi parameters abstract::    Abstract.
* srfi parameters rationale::   Rationale.
* srfi parameters spec::        Specification.


File: vicare-libs.info,  Node: srfi parameters license,  Next: srfi parameters abstract,  Up: srfi parameters

2.19.1 Parameters document license
----------------------------------

Copyright (C) 2002 Marc Feeley.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi parameters abstract,  Next: srfi parameters rationale,  Prev: srfi parameters license,  Up: srfi parameters

2.19.2 Abstract
---------------

This SRFI defines parameter objects, the procedure 'make-parameter' to
create parameter objects and the 'parameterize' special form to
dynamically bind parameter objects.

   In the dynamic environment, each parameter object is bound to a cell
containing the value of the parameter.  When a procedure is called the
called procedure inherits the dynamic environment from the caller.  The
'parameterize' special form allows the binding of a parameter object to
be changed for the dynamic extent of its body.


File: vicare-libs.info,  Node: srfi parameters rationale,  Next: srfi parameters spec,  Prev: srfi parameters abstract,  Up: srfi parameters

2.19.3 Rationale
----------------

The _dynamic environment_ is the structure which allows the system to
find the value returned by the R5RS procedures 'current-input-port' and
'current-output-port'.  The R5RS procedures 'with-input-from-file' and
'with-output-to-file' extend the dynamic environment to produce a new
dynamic environment which is in effect for the dynamic extent of the
call to the thunk passed as their last argument.

   These procedures are essentially special purpose dynamic binding
operations on hidden dynamic variables (one for 'current-input-port' and
one for 'current-output-port').  The purpose of this SRFI is to
generalize this dynamic binding mechanism (which exists in all R5RS
compliant systems) to allow the user to introduce new dynamic variables
and dynamically bind them.

   General dynamic binding mechanisms exist in several implementations
of Scheme under various names, including "fluid" variables and parameter
objects.  The parameter objects specified in this SRFI are compatible
with the semantics of all implementations of Scheme we know which
currently support parameter objects (in the sense that it is possible to
implement this SRFI so that old code works the same as before).  We
believe Chez-Scheme was the first implementation of Scheme to have used
parameter objects.

   In the presence of threads, the dynamic binding mechanism does not
behave the same way in all implementations of Scheme supporting dynamic
binding.  The issue is the relationship between the dynamic environments
of the parent and child threads when a thread is created.  In Scheme 48
the child gets a fresh dynamic environment where (typically but not
necessarily) all the bindings are to their initial value.

   In MzScheme and Gambit-C the child is given a dynamic environment
inherited from the parent.  In this inherited dynamic environment the
dynamic variables have the same values as the parent's dynamic
environment.  However, in MzScheme the cells bound to the dynamic
variables in the child are distinct from those of the parent (i.e.  an
assignment of a value to a dynamic variable is not visible in the other
thread).  In Gambit-C the child and parent dynamic environment share the
same cells (i.e.  an assignment of a value to a dynamic variable is
visible in the other thread).  Note that in the absence of assignment to
dynamic variables the MzScheme and Gambit-C approaches are equivalent.

   Given that there are semantic differences in the presence of threads
and that there are valid reasons for choosing each semantics, this SRFI
does not specify the semantics of parameter objects in the presence of
threads.  It is left to the implementation and other SRFIs which extend
this SRFI to specify the interaction between parameter objects and
threads.


File: vicare-libs.info,  Node: srfi parameters spec,  Prev: srfi parameters rationale,  Up: srfi parameters

2.19.4 Specification
--------------------

The _dynamic environment_ is composed of two parts: the _local dynamic
environment_ and the _global dynamic environment_.  The global dynamic
environment is used to lookup parameter objects that can't be found in
the local dynamic environment.  When parameter objects are created,
their initial binding is put in the global dynamic environment (by
mutation).  The local dynamic environment is only extended by the
'parameterize' form.

   _Parameter objects_ are created with the 'make-parameter' procedure
which takes one or two arguments.  The second argument is a one argument
conversion procedure.  If only one argument is passed to
'make-parameter' the identity function is used as a conversion
procedure.  The global dynamic environment is updated to associate the
parameter object to a new cell.  The initial content of the cell is the
result of applying the conversion procedure to the first argument of
'make-parameter'.

   A _parameter object_ is a procedure which accepts zero or one
argument.  The cell bound to a particular parameter object in the
dynamic environment is accessed by calling the parameter object.  When
no argument is passed, the content of the cell is returned.  When one
argument is passed the content of the cell is updated with the result of
applying the parameter object's conversion procedure to the argument.

   The 'parameterize' special form, when given a parameter object and a
value, binds for the dynamic extent of its body the parameter object to
a new cell.  The initial content of the cell is the result of applying
the parameter object's conversion procedure to the value.  The
parameterize special form behaves analogously to let when binding more
than one parameter object (that is the order of evaluation is
unspecified and the new bindings are only visible in the body of the
parameterize special form).

   Note that the conversion procedure can be used for guaranteeing the
type of the parameter object's binding and/or to perform some conversion
of the value.

   Because it is possible to implement the R5RS procedures
'current-input-port' and 'current-output-port' as parameter objects and
this offers added functionnality, it is required by this SRFI that they
be implemented as parameter objects created with 'make-parameter'.

 -- Function: make-parameter INIT [CONVERTER]
     Returns a new parameter object which is bound in the global dynamic
     environment to a cell containing the value returned by the call
     '(converter init)'.  If the conversion procedure converter is not
     specified the identity function is used instead.

     The parameter object is a procedure which accepts zero or one
     argument.  When it is called with no argument, the content of the
     cell bound to this parameter object in the current dynamic
     environment is returned.  When it is called with one argument, the
     content of the cell bound to this parameter object in the current
     dynamic environment is set to the result of the call '(converter
     arg)', where ARG is the argument passed to the parameter object,
     and an unspecified value is returned.

          (define radix
            (make-parameter 10))

          (define write-shared
            (make-parameter #f
              (lambda (x)
                (if (boolean? x)
                    x
                  (error "only booleans are accepted by write-shared")))))

          (radix)           =>  10
          (radix 2)
          (radix)           =>  2
          (write-shared 0)  gives an error

          (define prompt
            (make-parameter 123
              (lambda (x)
                (if (string? x)
                    x
                  (with-output-to-string (lambda () (write x)))))))

          (prompt)       =>  "123"
          (prompt ">")
          (prompt)       =>  ">"

 -- Syntax: parameterize ((EXPR1 EXPR2) ...) BODY)
     The expressions EXPR1 and EXPR2 are evaluated in an unspecified
     order.  The value of the EXPR1 expressions must be parameter
     objects.  For each EXPR1 expression and in an unspecified order,
     the local dynamic environment is extended with a binding of the
     parameter object EXPR1 to a new cell whose content is the result of
     the call '(converter val)', where VAL is the value of EXPR2 and
     CONVERTER is the conversion procedure of the parameter object.

     The resulting dynamic environment is then used for the evaluation
     of BODY (which refers to the R5RS grammar nonterminal of that
     name).  The result(s) of the parameterize form are the result(s) of
     the BODY.

     With reference to thte example above:

          (radix)
          =>  2

          (parameterize ([radix 16])
            (radix))
          =>  16

          (radix)
          =>  2

          (define (f n)
            (number->string n (radix)))

          (f 10)
          =>  "1010"

          (parameterize ([radix 8])
            (f 10))
          =>  "12"

          (parameterize ([radix 8]
                         [prompt (f 10)])
            (prompt))
          =>  "1010"


File: vicare-libs.info,  Node: srfi args-fold,  Next: srfi streams,  Prev: srfi parameters,  Up: srfi

2.20 SRFI-37 a program argument processor
=========================================

The library '(srfi :37)' is by Anthony Carrico as the reference
implementation for SRFI-37; see:

            <http://srfi.schemers.org/srfi-37/srfi-37.html>

for more details.

* Menu:

* srfi args-fold license::      Original document license.
* srfi args-fold abstract::     Abstract.
* srfi args-fold rationale::    Rationale.
* srfi args-fold spec::         Specification.
* srfi args-fold examples::     Some usage examples.


File: vicare-libs.info,  Node: srfi args-fold license,  Next: srfi args-fold abstract,  Up: srfi args-fold

2.20.1 Original document license
--------------------------------

Copyright (C) 2002 Anthony Carrico (2002).  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi args-fold abstract,  Next: srfi args-fold rationale,  Prev: srfi args-fold license,  Up: srfi args-fold

2.20.2 Abstract
---------------

Many operating systems make the set of argument strings used to invoke a
program available (often following the program name string in an array
called 'argv').  Most programs need to parse and process these argument
strings in one way or another.  This SRFI describes a set of procedures
that support processing program arguments according to POSIX and GNU C
Library Reference Manual guidelines.


File: vicare-libs.info,  Node: srfi args-fold rationale,  Next: srfi args-fold spec,  Prev: srfi args-fold abstract,  Up: srfi args-fold

2.20.3 Rationale
----------------

Program arguments are the primary interface to many programs, so
processing arguments is a common programming task.  There are many
common (often conflicting) ways take care of this task, so a custom
processor is often necessary; however, many programmers (and their
users) would welcome a convenient interface supporting common
guidelines.

   POSIX provides several guidelines for the specification of program
options, option-arguments, and operands.  It also notes historical
exceptions to these guidelines.  The GNU C Library Reference Manual
describes long option extensions to the POSIX guidelines.

   This SRFI supports creating programs following the guidelines
mentioned above by:

   * parsing short-options and long-options in any order and possibly
     repeated;

   * option-arguments (possibly required or forbidden);

   * operands (non-option argument strings);

   * recognizing option processing termination.

   It parses argument strings according to the following rules:

  1. each short-option name is a single character;

  2. one or more short-options are accepted in a single argument string
     when grouped behind one '-' delimiter character; examples: '-a',
     '-bcd';

  3. a short-option-argument is accepted in a separate argument string
     immediately following a short-option; examples: '-a foo', '-bcd
     bar';

  4. also (for historical reasons) a short-option-argument is accepted
     immediately following the last short-option in a single argument
     string; examples: '-afoo', '-bcdbar';

  5. each long-option name is one or more characters;

  6. one long-option is accepted in a single argument string when
     preceded by two '-' delimiter characters; example: '--help';

  7. in a single argument string, a long-option followed by one '='
     delimiter character followed by a long-option-argument is accepted;
     example: '--speed=fast';

  8. the first '--' argument string is accepted as a delimiter
     indicating the end of options; it is not treated as an option or an
     operand; any argument strings following this delimiter are treated
     as operands, even if they begin with the '-' character;

  9. all other argument strings are treated as operands; this includes
     argument strings consisting of a single - character;

  10. operands may be intermingled with options in any order.

   Preliminary versions of this interface are already available for some
Scheme implementations: here for Chicken, and here for Scsh.


File: vicare-libs.info,  Node: srfi args-fold spec,  Next: srfi args-fold examples,  Prev: srfi args-fold rationale,  Up: srfi args-fold

2.20.4 Specification
--------------------

'args-fold' is an iterator similar to SRFI-1 fold procedure ("the
fundamental list iterator").  As it parses options and operands, it
calls their corresponding operand and option processors.  Unlike
mapping, folding passes state, called seeds, from one processor to the
next.

   For example, a program may need a list of operands and a table of
options.  To build these, 'args-fold' could be seeded with an empty
operand list, and an empty option table.  The operand processor could
add the operands to the operand list, and the option processors could
add the options to the option table.  Along the way, some option
processors might even take immediate action for options like '--version'
or '--help'.  This kind of heterogeneous processing is appropriate for
program arguments, and folding allows a functional implementation if
desired.

 -- Procedure Prototype: option-processor OPTION NAME ARG SEEDS ...
     Prototype for an option-processor.  It should return the next seeds
     as values.  OPTION will be the option.  NAME will be one of the
     OPTION's option-names as encountered by 'args-fold'.  ARG will be a
     string, or '#f' if 'args-fold' didn't encounter an option-argument.

 -- Procedure Prototype: operand-processor OPERAND SEEDS
     Prototype for an operand-processor.  It should return the next
     seeds as values.  OPERAND will be a string.

 -- Function: option NAMES REQUIRED-ARG? OPTIONAL-ARG? OPTION-PROC
     Return an option.  NAMES is a list of short (character) and long
     (string) option names.  REQUIRED-ARG? specifies if this options
     requires an option-argument (boolean).  OPTIONAL-ARG? specifies if
     this option can accept an option-argument (boolean).  OPTION-PROC
     is a procedure (following the 'option-processor' prototype) used to
     process this option.

 -- Function: option-names OPTION
 -- Function: option-required-arg? OPTION
 -- Function: option-optional-arg? OPTION
 -- Function: option-processor OPTION
     Return the contents of corresponding fields of OPTION.

 -- Function: args-fold ARGS OPTIONS UNRECOGNIZED-OPTION-PROC
          OPERAND-PROC SEEDS ...
     Parse argument strings left-to-right, calling the appropriate
     processors in-order (for the parsed known options, unknown options,
     and operands), passing the seed values from one processor to the
     next and returning the final seeds values as results.

     ARGS is a list of strings.  OPTIONS is a list of options.
     UNRECOGNIZED-OPTION-PROC is a procedure (following the
     'option-processor' prototype) for unrecognized options.
     OPERAND-PROC is a procedure (following the 'operand-processor'
     prototype) for operands.

          *NOTE* 'args-fold' will create temporary options as necessary
          for the 'unrecognized-option-proc'.


File: vicare-libs.info,  Node: srfi args-fold examples,  Prev: srfi args-fold spec,  Up: srfi args-fold

2.20.5 Some usage examples
--------------------------

Short options without arguments:

     (import (rnrs) (srfi :37))

     (define (unrecognised-option-proc option name arg seed)
       (error 'test "unknown option" option name arg))

     (define (make-seed)
       (make-vector 3 '()))

     (define (make-option-processor index)
       (lambda (option name arg seed)
         (vector-set! seed index (cons name (vector-ref seed index)))
         seed))

     (define (make-operand-processor index)
       (lambda (operand seed)
         (vector-set! seed index (cons operand (vector-ref seed index)))
         seed))

     (args-fold '("-a" "-b" "ciao")
        (list (option '(#\a) #f #f (make-option-processor 1))
              (option '(#\b) #f #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(("ciao") (#\a) (#\b))

     (args-fold '("salut" "-a" "hello" "-b" "ciao")
        (list (option '(#\a) #f #f (make-option-processor 1))
              (option '(#\b) #f #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(("ciao" "hello" "salut") (#\a) (#\b))

     (args-fold '("-ab")
        (list (option '(#\a) #f #f (make-option-processor 1))
              (option '(#\b) #f #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => '#(() (#\a) (#\b))

   Short options with required arguments:

     (import (rnrs) (srfi :37))

     (define (unrecognised-option-proc option name arg seed)
       (error 'test "unknown option" option name arg))

     (define (make-seed)
       (make-vector 3 '()))

     (define (make-option-processor index)
       (lambda (option name arg seed)
         (vector-set! seed index (cons arg (vector-ref seed index)))
         seed))

     (define (make-operand-processor index)
       (lambda (operand seed)
         (vector-set! seed index (cons operand (vector-ref seed index)))
         seed))

     (args-fold '("-a" "hello" "-b" "ciao")
        (list (option '(#\a) #t #f (make-option-processor 1))
              (option '(#\b) #t #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") ("ciao"))

     (args-fold '("-ahello" "-bciao")
        (list (option '(#\a) #t #f (make-option-processor 1))
              (option '(#\b) #t #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") ("ciao"))

     (args-fold '("salut" "-a" "hello" "-b" "ciao")
        (list (option '(#\a) #t #f (make-option-processor 1))
              (option '(#\b) #t #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(("salut") ("hello") ("ciao"))

     (args-fold '("-ahello" "-bciao")
        (list (option '(#\a) #t #f (make-option-processor 1))
              (option '(#\b) #t #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") ("ciao"))

   Short options with optional arguments:

     (import (rnrs) (srfi :37))

     (define (unrecognised-option-proc option name arg seed)
       (error 'test "unknown option" option name arg))

     (define (make-seed)
       (make-vector 3 '()))

     (define (make-option-processor index)
       (lambda (option name arg seed)
         (vector-set! seed index (cons arg (vector-ref seed index)))
         seed))

     (define (make-operand-processor index)
       (lambda (operand seed)
         (vector-set! seed index (cons operand (vector-ref seed index)))
         seed))

     (args-fold '("-ahello" "-b")
        (list (option '(#\a) #f #t (make-option-processor 1))
              (option '(#\b) #f #t (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") (#f))

   Long options without arguments:

     (import (rnrs) (srfi :37))

     (define (unrecognised-option-proc option name arg seed)
       (error 'test "unknown option" option name arg))

     (define (make-seed)
       (make-vector 3 '()))

     (define (make-option-processor index)
       (lambda (option name arg seed)
         (vector-set! seed index (cons name (vector-ref seed index)))
         seed))

     (define (make-operand-processor index)
       (lambda (operand seed)
         (vector-set! seed index (cons operand (vector-ref seed index)))
         seed))

     (args-fold '("--alpha" "--beta" "ciao")
        (list (option '("alpha") #f #f (make-option-processor 1))
              (option '("beta")  #f #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(("ciao") ("alpha") ("beta"))

     (args-fold '("salut" "--alpha" "hello" "--beta" "ciao")
        (list (option '("alpha") #f #f (make-option-processor 1))
              (option '("beta")  #f #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(("ciao" "hello" "salut") ("alpha") ("beta"))

   Long options with required arguments:

     (import (rnrs) (srfi :37))

     (define (unrecognised-option-proc option name arg seed)
       (error 'test "unknown option" option name arg))

     (define (make-seed)
       (make-vector 3 '()))

     (define (make-option-processor index)
       (lambda (option name arg seed)
         (vector-set! seed index (cons arg (vector-ref seed index)))
         seed))

     (define (make-operand-processor index)
       (lambda (operand seed)
         (vector-set! seed index (cons operand (vector-ref seed index)))
         seed))

     (args-fold '("--alpha" "hello" "--beta" "ciao")
        (list (option '("alpha") #t #f (make-option-processor 1))
              (option '("beta")  #t #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") ("ciao"))

     (args-fold '("salut" "--alpha" "hello" "--beta" "ciao")
        (list (option '("alpha") #t #f (make-option-processor 1))
              (option '("beta")  #t #f (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(("salut") ("hello") ("ciao"))

   Long options with optional arguments:

     (import (rnrs) (srfi :37))

     (define (unrecognised-option-proc option name arg seed)
       (error 'test "unknown option" option name arg))

     (define (make-seed)
       (make-vector 3 '()))

     (define (make-option-processor index)
       (lambda (option name arg seed)
         (vector-set! seed index (cons arg (vector-ref seed index)))
         seed))

     (define (make-operand-processor index)
       (lambda (operand seed)
         (vector-set! seed index (cons operand (vector-ref seed index)))
         seed))

     (args-fold '("--alpha=hello" "--beta")
        (list (option '("alpha") #f #t (make-option-processor 1))
              (option '("beta")  #f #t (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") (#f))

     (args-fold '("--alpha=hello" "--beta=ciao")
        (list (option '("alpha") #f #t (make-option-processor 1))
              (option '("beta")  #f #t (make-option-processor 2)))
        unrecognised-option-proc
        (make-operand-processor 0)
        (make-seed))
     => #(() ("hello") ("ciao"))


File: vicare-libs.info,  Node: srfi streams,  Next: srfi eager-comp,  Prev: srfi args-fold,  Up: srfi

2.21 SRFI-41 streams
====================

The library '(srfi :41)' is by by Philip L. Bewig as the reference
implementation for SRFI-41; see:

            <http://srfi.schemers.org/srfi-41/srfi-41.html>

for more details.

* Menu:

* srfi streams license::                Streams document license.
* srfi streams abstract::               Abstract.
* srfi streams rationale::              Rationale.
* srfi streams primitive::              The '(streams primitive)'
                                        library.
* srfi streams primitive example::      Streams primitive library
                                        example.
* srfi streams derived::                The '(streams derived)'
                                        library.
* srfi streams utilities::              Utilities.
* srfi streams examples::               Examples.
* srfi streams ack::                    Acknowledgments.
* srfi streams references::             References.


File: vicare-libs.info,  Node: srfi streams license,  Next: srfi streams abstract,  Up: srfi streams

2.21.1 Streams document license
-------------------------------

Copyright (C) 2007, 2008 by Philip L. Bewig.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi streams abstract,  Next: srfi streams rationale,  Prev: srfi streams license,  Up: srfi streams

2.21.2 Abstract
---------------

Streams, sometimes called lazy lists, are a sequential data structure
containing elements computed only on demand.  A stream is either null or
is a pair with a stream in its cdr.  Since elements of a stream are
computed only when accessed, streams can be infinite.  Once computed,
the value of a stream element is cached in case it is needed again.

   Streams without memoization were first described by Peter Landin in
1965.  Memoization became accepted as an essential feature of streams
about a decade later.  Today, streams are the signature data type of
functional programming languages such as Haskell.

   This Scheme Request for Implementation describes two libraries for
operating on streams: a canonical set of stream primitives and a set of
procedures and syntax derived from those primitives that permits
convenient expression of stream operations.  They rely on facilities
provided by R6RS, including libraries, records, and error reporting.


File: vicare-libs.info,  Node: srfi streams rationale,  Next: srfi streams primitive,  Prev: srfi streams abstract,  Up: srfi streams

2.21.3 Rationale
----------------

Harold Abelson and Gerald Jay Sussman discuss streams at length, giving
a strong justification for their use.  The streams they provide are
represented as a cons pair with a promise to return a stream in its cdr;
for instance, a stream with elements the first three counting numbers is
represented conceptually as:

     (cons 1 (delay (cons 2 (delay (cons 3 (delay '()))))))

   Philip Wadler, Walid Taha and David MacQueen describe such streams as
odd because, regardless of their length, the parity of the number of
constructors ('delay', 'cons', '(quote ())') in the stream is odd.

   The streams provided here differ from those of Abelson and Sussman,
being represented as promises that contain a cons pair with a stream in
its cdr; for instance, the stream with elements the first three counting
numbers is represented conceptually as:

     (delay (cons 1 (delay (cons 2 (delay (cons 3 (delay '())))))))

this is an even stream because the parity of the number of constructors
in the stream is even.

   Even streams are more complex than odd streams in both definition and
usage, but they offer a strong benefit: they fix the off-by-one error of
odd streams.  Wadler, Taha and MacQueen show, for instance, that an
expression like:

     (stream->list 4 (stream-map / (stream-from 4 -1)))

evaluates to '(1/4 1/3 1/2 1)' using even streams but fails with a
divide-by-zero error using odd streams, because the next element in the
stream, which will be 1/0, is evaluated before it is accessed.  This
extra bit of laziness is not just an interesting oddity; it is vitally
critical in many circumstances, as will become apparent below.

   When used effectively, the primary benefit of streams is improved
modularity.  Consider a process that takes a sequence of items,
operating on each in turn.  If the operation is complex, it may be
useful to split it into two or more procedures in which the
partially-processed sequence is an intermediate result.  If that
sequence is stored as a list, the entire intermediate result must reside
in memory all at once; however, if the intermediate result is stored as
a stream, it can be generated piecemeal, using only as much memory as
required by a single item.  This leads to a programming style that uses
many small operators, each operating on the sequence of items as a
whole, similar to a pipeline of unix commands.

   In addition to improved modularity, streams permit a clear exposition
of backtracking algorithms using the "stream of successes" technique,
and they can be used to model generators and co-routines.  The implicit
memoization of streams makes them useful for building persistent data
structures, and the laziness of streams permits some multi-pass
algorithms to be executed in a single pass.  Savvy programmers use
streams to enhance their programs in countless ways.

   There is an obvious space/time trade-off between lists and streams;
lists take more space, but streams take more time (to see why, look at
all the type conversions in the implementation of the stream
primitives).  Streams are appropriate when the sequence is truly
infinite, when the space savings are needed, or when they offer a
clearer exposition of the algorithms that operate on the sequence.


File: vicare-libs.info,  Node: srfi streams primitive,  Next: srfi streams primitive example,  Prev: srfi streams rationale,  Up: srfi streams

2.21.4 The '(streams primitive)' library
----------------------------------------

The '(streams primitive)' library provides two mutually-recursive
abstract data types: An object of the 'stream' abstract data type is a
promise that, when forced, is either 'stream-null' or is an object of
type 'stream-pair'.  An object of the 'stream-pair' abstract data type
contains a 'stream-car' and a 'stream-cdr', which must be a 'stream'.
The essential feature of streams is the systematic suspensions of the
recursive promises between the two data types.

     alpha stream
       :: (promise stream-null)
       |  (promise (alpha stream-pair))

     alpha stream-pair
       :: (promise alpha) x (promise (alpha stream))

   The object stored in the 'stream-car' of a 'stream-pair' is a promise
that is forced the first time the 'stream-car' is accessed; its value is
cached in case it is needed again.  The object may have any type, and
different stream elements may have different types.  If the 'stream-car'
is never accessed, the object stored there is never evaluated.
Likewise, the 'stream-cdr' is a promise to return a stream, and is only
forced on demand.

   This library provides eight operators: constructors for 'stream-null'
and 'stream-pairs', type recognizers for streams and the two kinds of
streams, accessors for both fields of a 'stream-pair', and a lambda that
creates procedures that return streams.

 -- Function: stream-null
     Return a promise that, when forced, is a single object,
     distinguishable from all other objects, that represents the null
     stream.  'stream-null' is immutable and unique.

 -- Syntax: stream-cons OBJECT STREAM
     A macro that accepts an object and a stream and creates a
     newly-allocated stream containing a promise that, when forced, is a
     'stream-pair' with the object in its 'stream-car' and the stream in
     its 'stream-cdr'.

     'stream-cons' must be syntactic, not procedural, because neither
     OBJECT nor STREAM is evaluated when 'stream-cons' is called.  Since
     STREAM is not evaluated, when the 'stream-pair' is created, it is
     not an error to call 'stream-cons' with a STREAM argument that is
     not of type 'stream'; however, doing so will cause an error later
     when the 'stream-cdr' of the 'stream-pair' is accessed.

     Once created, a 'stream-pair' is immutable; there is *no*
     'stream-set-car!' or 'stream-set-cdr!' that modifies an existing
     'stream-pair'.  There is no dotted-pair or improper stream as with
     lists.

 -- Function: stream? OBJECT
     Return '#t' if the OBJECT is a 'stream' and '#f' otherwise.  If
     OBJECT is a 'stream', 'stream?' does not force its promise.

     If '(stream? obj)' is '#t', then one of '(stream-null? obj)' and
     '(stream-pair? obj)' will be '#t' and the other will be '#f'; if
     '(stream? obj)' is '#f', both '(stream-null? obj)' and
     '(stream-pair? obj)' will be '#f'.

 -- Function: stream-null? OBJECT
     Return '#t' if the OBJECT is the distinguished null stream and '#f'
     otherwise.  If OBJECT is a 'stream', 'stream-null?' must force its
     promise in order to distinguish 'stream-null' from 'stream-pair'.

 -- Function: stream-pair? OBJECT
     Take an OBJECT and return '#t' if it is a 'stream-pair' constructed
     by 'stream-cons' and '#f' otherwise.  If OBJECT is a 'stream',
     'stream-pair?' must force its promise in order to distinguish
     'stream-null' from 'stream-pair'.

 -- Function: stream-car STREAM
     Return the object stored in the 'stream-car' of STREAM.
     'stream-car' signals an error if the object passed to it is not a
     'stream-pair'.  Calling 'stream-car' causes the object stored there
     to be evaluated if it has not yet been; the object's value is
     cached in case it is needed again.

 -- Function: stream-cdr STREAM
     Return the stream stored in the 'stream-cdr' of STREAM.
     'stream-cdr' signals an error if the object passed to it is not a
     'stream-pair'.  Calling 'stream-cdr' does not force the promise
     containing the stream stored in the 'stream-cdr' of the stream.

 -- Syntax: stream-lambda ARGS . BODY
     Create a procedure that returns a promise to evaluate the body of
     the procedure.  The last body expression to be evaluated must yield
     a stream.

     As with normal lambda, ARGS may be a single variable name, in which
     case all the formal arguments are collected into a single list, or
     a list of variable names, which may be null if there are no
     arguments, proper if there are an exact number of arguments, or
     dotted if a fixed number of arguments is to be followed by zero or
     more arguments collected into a list.

     BODY must contain at least one expression, and may contain internal
     definitions preceding any expressions to be evaluated.


File: vicare-libs.info,  Node: srfi streams primitive example,  Next: srfi streams derived,  Prev: srfi streams primitive,  Up: srfi streams

2.21.5 Streams primitive library example
----------------------------------------

     (define strm123
       (stream-cons 1
         (stream-cons 2
           (stream-cons 3
             stream-null))))

     (stream-car strm123) => 1

     (stream-car (stream-cdr strm123) => 2

     (stream-pair?
       (stream-cdr
         (stream-cons (/ 1 0) stream-null))) => #f

     (stream? (list 1 2 3)) => #f

     (define iter
       (stream-lambda (f x)
         (stream-cons x (iter f (f x)))))

     (define nats (iter (lambda (x) (+ x 1)) 0))

     (stream-car (stream-cdr nats)) => 1

     (define stream-add
       (stream-lambda (s1 s2)
         (stream-cons
           (+ (stream-car s1) (stream-car s2))
           (stream-add (stream-cdr s1)
                       (stream-cdr s2)))))

     (define evens (stream-add nats nats))

     (stream-car evens) => 0

     (stream-car (stream-cdr evens)) => 2

     (stream-car (stream-cdr (stream-cdr evens))) => 4


File: vicare-libs.info,  Node: srfi streams derived,  Next: srfi streams utilities,  Prev: srfi streams primitive example,  Up: srfi streams

2.21.6 The '(streams derived)' library
--------------------------------------

The '(streams derived)' library provides useful procedures and syntax
that depend on the primitives defined in *note srfi streams primitive::.

 -- Syntax: define-stream (NAME ARGS) . BODY
     Create a procedure that returns a 'stream', and may appear anywhere
     a normal 'define' may appear, including as an internal definition,
     and may have internal definitions of its own, including other
     'define-streams'.  The defined procedure takes arguments in the
     same way as 'stream-lambda'.

     'define-stream' is syntactic sugar on 'stream-lambda'; see also
     'stream-let', which is also a sugaring of 'stream-lambda'.

     The following example is a simple version of 'stream-map' that
     takes only a single input stream calls itself recursively:

          (define-stream (stream-map proc strm)
            (if (stream-null? strm)
                stream-null
                (stream-cons
                  (proc (stream-car strm))
                  (stream-map proc (stream-cdr strm))))))

 -- Function: list->stream LIST-OF-OBJECTS
     Return a newly-allocated 'stream' containing in its elements the
     objects in the list.  Since the objects are given in a list, they
     are evaluated when 'list->stream' is called, before the 'stream' is
     created.  If the list of objects is null, as in '(list->stream
     '())', the null 'stream' is returned.  See also 'stream'.

     Example:

          (define strm123 (list->stream '(1 2 3)))

          ; fails with divide-by-zero error
          (define s (list->stream (list 1 (/ 1 0) -1)))

 -- Function: port->stream [PORT]
     Return a newly-allocated 'stream' containing in its elements the
     characters on the PORT.  If PORT is not given it defaults to the
     current input port.  The returned 'stream' has finite length and is
     terminated by 'stream-null'.

     It looks like one use of 'port->stream' would be this:

          (define s ;wrong!
            (with-input-from-file filename
              (lambda () (port->stream))))

     but that fails, because 'with-input-from-file' is eager, and closes
     the input port prematurely, before the first character is read.  To
     read a file into a stream, use:

          (define-stream (file->stream filename)
            (let ((p (open-input-file filename)))
              (stream-let loop ((c (read-char p)))
                (if (eof-object? c)
                    (begin (close-input-port p)
                           stream-null)
                    (stream-cons c
                      (loop (read-char p)))))))

 -- Syntax: stream OBJECT ...
     Take zero or more objects and create a newly-allocated 'stream'
     containing in its elements the objects, in order.  Since 'stream'
     is syntactic, the objects are evaluated when they are accessed, not
     when the 'stream' is created.  If no objects are given, as in
     '(stream)', the null stream is returned.  See also 'list->stream'.

     Example:

          (define strm123 (stream 1 2 3))

          ; (/ 1 0) not evaluated when stream is created
          (define s (stream 1 (/ 1 0) -1))

 -- Function: stream->list [N] STREAM
     Take a natural number N and a STREAM and return a newly-allocated
     list containing in its elements the first items in the STREAM.  If
     the STREAM has less than N items all the items in the STREAM will
     be included in the returned list.  If N is not given it defaults to
     infinity, which means that unless STREAM is finite 'stream->list'
     will never return.

     Example:

          (stream->list 10
            (stream-map (lambda (x) (* x x))
              (stream-from 0)))
            => (0 1 4 9 16 25 36 49 64 81)

 -- Function: stream-append STREAM ...
     Return a newly-allocated 'stream' containing in its elements those
     elements contained in its input streams, in order of input.  If any
     of the input streams is infinite, no elements of any of the
     succeeding input streams will appear in the output stream; thus, if
     X is infinite, '(stream-append x y)' is identical to X.  See also
     'stream-concat'.

     Example: quicksort can be used to sort a 'stream', using
     'stream-append' to build the output; the sort is lazy; so if only
     the beginning of the output stream is needed, the end of the stream
     is never sorted.

          (define-stream (qsort lt? strm)
            (if (stream-null? strm)
                stream-null
                (let ((x (stream-car strm))
                      (xs (stream-cdr strm)))
                  (stream-append
                    (qsort lt?
                      (stream-filter
                        (lambda (u) (lt? u x))
                        xs))
                    (stream x)
                    (qsort lt?
                      (stream-filter
                        (lambda (u) (not (lt? u x)))
                        xs))))))

     Note also that, when used in tail position as in 'qsort',
     'stream-append' does not suffer the poor performance of 'append' on
     lists.  The list version of 'append' requires re-traversal of all
     its list arguments except the last each time it is called.  But
     'stream-append' is different.  Each recursive call to
     'stream-append' is suspended; when it is later forced, the
     preceding elements of the result have already been traversed, so
     tail-recursive loops that produce streams are efficient even when
     each element is appended to the end of the result stream.  This
     also implies that during traversal of the result only one promise
     needs to be kept in memory at a time.

 -- Function: stream-concat STREAM
     Take a STREAM consisting of one or more streams and return a
     newly-allocated stream containing all the elements of the input
     streams.  If any of the streams in the input stream is infinite,
     any remaining streams in the input stream will never appear in the
     output stream.  See also 'stream-append'.

     Example:

          (stream->list
            (stream-concat
              (stream
                (stream 1 2) (stream) (stream 3 2 1))))
            => (1 2 3 2 1)

     Example: the permutations of a finite stream can be determined by
     interleaving each element of the stream in all possible positions
     within each permutation of the other elements of the stream;
     'interleave' returns a stream of streams with X inserted in each
     possible position of YY:

          (define-stream (interleave x yy)
            (stream-match yy
              [() (stream (stream x))]
              [(y .  ys)
                (stream-append
                  (stream (stream-cons x yy))
                  (stream-map
                    (lambda (z) (stream-cons y z))
                    (interleave x ys)))]))

          (define-stream (perms xs)
            (if (stream-null? xs)
                (stream (stream))
                (stream-concat
                  (stream-map
                    (lambda (ys)
                      (interleave (stream-car xs) ys))
                    (perms (stream-cdr xs))))))

 -- Function: stream-constant OBJECT ...
     Take one or more objects and return a newly-allocated 'stream'
     containing in its elements the objects, repeating the objects in
     succession forever.

     Example:

          (stream-constant 1) => 1 1 1 ...

          (stream-constant #t #f) => #t #f #t #f #t #f ...

 -- Function: stream-drop N STREAM
     Return the suffix of the input stream that starts at the next
     element after the first N elements.  The output stream shares
     structure with the input stream; thus, promises forced in one
     instance of the stream are also forced in the other instance of the
     stream.  If the input stream has less than N elements,
     'stream-drop' returns the null stream.  See also 'stream-take'.

     Example:

          (define (stream-split n strm)
            (values (stream-take n strm)
                    (stream-drop n strm)))

 -- Function: stream-drop-while PRED? STREAM
     Return the suffix of the input stream that starts at the first
     element X for which '(pred? x)' is '#f'.  The output stream shares
     structure with the input stream.  See also 'stream-take-while'.

     Example: 'stream-unique' creates a new stream that retains only the
     first of any sub-sequences of repeated elements.

          (define-stream (stream-unique eql? strm)
            (if (stream-null? strm)
                stream-null
                (stream-cons (stream-car strm)
                  (stream-unique eql?
                    (stream-drop-while
                      (lambda (x)
                        (eql? (stream-car strm) x))
                      strm)))))

 -- Function: stream-filter PRED? STREAM
     Return a newly-allocated stream that contains only those elements X
     of the input stream for which '(pred? x)' is non-'#f'.

     Example:

          (stream-filter odd? (stream-from 0))
             => 1 3 5 7 9 ...

 -- Function: stream-fold PROC BASE STREAM
     Apply a binary procedure to BASE and the first element of STREAM to
     compute a new base, then apply the procedure to the new base and
     the next element of STREAM to compute a succeeding base, and so on,
     accumulating a value that is finally returned as the value of
     'stream-fold' when the end of the STREAM is reached.

     STREAM must be finite, or 'stream-fold' will enter an infinite
     loop.  See also 'stream-scan', which is similar to 'stream-fold',
     but useful for infinite streams.

     For readers familiar with other functional languages, this is a
     left-fold; there is no corresponding right-fold, since right-fold
     relies on finite streams that are fully-evaluated, at which time
     they may as well be converted to a list.

     Example: 'stream-fold' is often used to summarize a stream in a
     single value, for instance, to compute the maximum element of a
     stream.

          (define (stream-maximum lt? strm)
            (stream-fold
              (lambda (x y) (if (lt? x y) y x))
              (stream-car strm)
              (stream-cdr strm)))

     Example: sometimes, it is useful to have 'stream-fold' defined only
     on non-null streams:

          (define (stream-fold-one proc strm)
            (stream-fold proc
              (stream-car strm)
              (stream-cdr strm)))

     'stream-minimum' can then be defined as:

          (define (stream-minimum lt? strm)
            (stream-fold-one
              (lambda (x y) (if (lt? x y) x y))
              strm))

     Example: 'stream-fold' can also be used to build a stream:

          (define-stream (isort lt? strm)
              (define-stream (insert strm x)
                (stream-match strm
                  [() (stream x)]
                  [(y .  ys)
                    (if (lt? y x)
                        (stream-cons y (insert ys x))
                        (stream-cons x strm))]))
              (stream-fold insert stream-null strm))

 -- Function: stream-for-each PROC STREAM ...
     Apply a procedure element-wise to corresponding elements of the
     input streams for its side-effects; return nothing.
     'stream-for-each' stops as soon as any of its input streams is
     exhausted.

     Example: the following procedure displays the contents of a file:

          (define (display-file filename)
            (stream-for-each display
              (file->stream filename)))

 -- Function: stream-from FIRST [STEP]
     Create a newly-allocated stream that contains FIRST as its first
     element and increments each succeeding element by STEP.  If STEP is
     not given it defaults to '1'.  FIRST and STEP may be of any numeric
     type.  'stream-from' is frequently useful as a generator in
     'stream-of' expressions.  See also 'stream-range' for a similar
     procedure that creates finite streams.

     'stream-from' could be implemented as:

          (stream-iterate (lambda (x) (+ x step)) first)

     Example:

          (define nats (stream-from 0)) => 0 1 2 ...
          (define odds (stream-from 1 2)) => 1 3 5 ...

 -- Function: stream-iterate PROC BASE
     Create a newly-allocated stream containing BASE in its first
     element and apply PROC to each element in turn to determine the
     succeeding element.  See also 'stream-unfold' and 'stream-unfolds'.

     Examples:

          (stream-iterate (lambda (x) (+ x 1)) 0)
            => 0 1 2 3 4 ...

          (stream-iterate (lambda (x) (* x 2)) 1)
            => 1 2 4 8 16 ...

     Given a seed between 0 and 232, exclusive, the following expression
     creates a stream of pseudo-random integers between 0 and 232,
     exclusive, beginning with seed, using the method described by
     Stephen Park and Keith Miller:

          (stream-iterate
            (lambda (x) (modulo (* x 16807) 2147483647))
            seed)

     Example: successive of the following stream approach the value of
     the "golden ratio" 1.618...:

          (stream-iterate (lambda (x) (+ 1 (/ x))) 1)

 -- Function: stream-length STREAM
     Take an input stream and return the number of elements in the
     stream; it does not evaluate its elements.  'stream-length' may
     only be used on finite streams; it enters an infinite loop with
     infinite streams.

     Example:

          (stream-length strm123) => 3

 -- Syntax: stream-let TAG ((VAR EXPR) ...) BODY
     Create a local scope that binds each variable to the value of its
     corresponding expression.  Additionally bind TAG to a procedure
     which takes the bound variables as arguments and BODY as its
     defining expressions, binding the tag with 'stream-lambda'.  TAG is
     in scope within BODY, and may be called recursively.

     When the expanded expression defined by 'stream-let' is evaluated,
     'stream-let' evaluates the expressions in its body in an
     environment containing the newly-bound variables, returning the
     value of the last expression evaluated, which must yield a stream.

     'stream-let' provides syntactic sugar on 'stream-lambda', in the
     same manner as normal 'let' provides syntactic sugar on normal
     'lambda'.  However, unlike normal 'let', the TAG is required, not
     optional, because unnamed 'stream-let' is meaningless.

     Example: 'stream-member' returns the first 'stream-pair' of the
     input STRM with a 'stream-car' X that satisfies '(eql? obj x)', or
     the null stream if X is not present in STRM.

          (define-stream (stream-member eql? obj strm)
            (stream-let loop ((strm strm))
              (cond [(stream-null? strm) strm]
                    [(eql? obj (stream-car strm)) strm]
                    [else (loop (stream-cdr strm))])))

 -- Function: stream-map PROC STREAM ...
     Apply a procedure element-wise to corresponding elements of the
     input streams, returning a newly-allocated stream containing
     elements that are the results of those procedure applications.  The
     output stream has as many elements as the minimum-length input
     stream, and may be infinite.

     Example:

          (define (square x) (* x x))

          (stream-map square (stream 9 3)) => 81 9

          (define (sigma f m n)
            (stream-fold + 0
              (stream-map f (stream-range m (+ n 1)))))

          (sigma square 1 100) => 338350

     In some functional languages, 'stream-map' takes only a single
     input stream, and 'stream-zipwith' provides a companion function
     that takes multiple input streams.

 -- Syntax: stream-match STREAM CLAUSE ...
     Provide the syntax of pattern-matching for streams.  The input
     STREAM is an expression that evaluates to a stream.  CLAUSE
     arguments are of the form '(pattern [fender] expr)', consisting of
     a pattern that matches a stream of a particular shape, an optional
     fender that must succeed if the pattern is to match, and an
     expression that is evaluated if the pattern matches.  There are
     four types of patterns:

     '()'
          matches the null stream;

     '(pat0 pat1 ...)'
          matches a finite stream with length exactly equal to the
          number of pattern elements;

     '(pat0 pat1 ... . patrest)'
          matches an infinite stream, or a finite stream with length at
          least as great as the number of pattern elements before the
          literal dot;

     'pat'
          matches an entire stream; should always appear last in the
          list of nclauses; it's not an error to appear elsewhere, but
          subsequent clauses could never match.

     Each pattern element PATI may be either:

     _an identifier_
          matches any stream element; additionally, the value of the
          stream element is bound to the variable named by the
          identifier, which is in scope in the fender and expression of
          the corresponding clause; each identifier in a single pattern
          must be unique;

     _a literal underscore_
          matches any stream element, but creates no bindings.

     The patterns are tested in order, left-to-right, until a matching
     pattern is found; if FENDER is present, it must evaluate as
     non-'#f' for the match to be successful.  Pattern variables are
     bound in the corresponding fender and expression.  Once the
     matching pattern is found, the corresponding expression is
     evaluated and returned as the result of the match.  An error is
     signaled if no pattern matches the input stream.

     'stream-match' is often used to distinguish null streams from
     non-null streams, binding head and tail:

          (define (len strm)
            (stream-match strm
              [() 0]
              [(head .  tail) (+ 1 (len tail))]))

     Fenders can test the common case where two stream elements must be
     identical; the else pattern is an identifier bound to the entire
     stream, not a keyword as in 'cond'.

          (stream-match strm
            [(x y .  _) (equal? x y) 'ok]
            [else 'error])

     A more complex example uses two nested matchers to match two
     different stream arguments; '(stream-merge lt? . strms)' stably
     merges two or more streams ordered by the LT? predicate:

          (define-stream (stream-merge lt? .  strms)
            (define-stream (merge xx yy)
              (stream-match xx (() yy) ((x .  xs)
                (stream-match yy (() xx) ((y .  ys)
                  (if (lt? y x)
                      (stream-cons y (merge xx ys))
                    (stream-cons x (merge xs yy))))))))
            (stream-let loop ((strms strms))
              (cond [(null? strms) stream-null]
                    [(null? (cdr strms)) (car strms)]
                    [else (merge (car strms)
                                 (apply stream-merge lt?
                                   (cdr strms)))])))

 -- Syntax: stream-of EXPR CLAUSE ...
     Provide the syntax of stream comprehensions, which generate streams
     by means of looping expressions.  The result is a stream of objects
     of the type returned by EXPR.  There are four types of CLAUSE
     arguments:

     '(var in stream-expr)'
          loop over the elements of STREAM-EXPR, in order from the start
          of the stream, binding each element of the stream in turn to
          VAR.  'stream-from' and 'stream-range' are frequently useful
          as generators for STREAM-EXPR;

     '(var is expr)'
          bind VAR to the value obtained by evaluating EXPR;

     '(pred? expr)'
          include in the output stream only those elements X for which
          '(pred? x)' is non-'#f'.

     The scope of variables bound in the stream comprehension is the
     clauses to the right of the binding clause (but not the binding
     clause itself) plus the result expression.

     When two or more generators are present, the loops are processed as
     if they are nested from left to right; that is, the rightmost
     generator varies fastest.  A consequence of this is that only the
     first generator may be infinite and all subsequent generators must
     be finite.  If no generators are present, the result of a stream
     comprehension is a stream containing the result expression; thus,
     '(stream-of 1)' produces a finite stream containing only the
     element '1'.

          (stream-of (* x x)
            (x in (stream-range 0 10))
            (even? x))
            => 0 4 16 36 64

          (stream-of (list a b)
            (a in (stream-range 1 4))
            (b in (stream-range 1 3)))
            => (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)

          (stream-of (list i j)
            (i in (stream-range 1 5))
            (j in (stream-range (+ i 1) 5)))
            => (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)

 -- Function: stream-range FIRST PAST [STEP]
     Create a newly-allocated stream that contains FIRST as its first
     element and increments each succeeding element by STEP.  The stream
     is finite and ends before PAST, which is not an element of the
     stream.  If STEP is not given it defaults to '1' if FIRST is less
     than PAST and '-1' otherwise.

     FIRST, PAST and STEP may be of any numeric type.

     'stream-range' is frequently useful as a generator in 'stream-of'
     expressions.  See also 'stream-from' for a similar procedure that
     creates infinite streams.

     Examples:

          (stream-range 0 10)     => 0 1 2 3 4 5 6 7 8 9
          (stream-range 0 10 2)   => 0 2 4 6 8

     Successive elements of the stream are calculated by adding STEP to
     FIRST, so if any of FIRST, PAST or STEP are inexact, the length of
     the output stream may differ from:

          (ceiling (- (/ (- past first) step) 1)

 -- Function: stream-ref STREAM N
     Return the N-th element of STREAM, counting from zero.  An error is
     signaled if N is greater than or equal to the length of STREAM.

     Example:

          (define (fact n)
            (stream-ref
              (stream-scan * 1 (stream-from 1))
              n))

 -- Function: stream-reverse STREAM
     Return a newly-allocated stream containing the elements of the
     input STREAM but in reverse order.  'stream-reverse' may only be
     used with finite streams; it enters an infinite loop with infinite
     streams.  'stream-reverse' does not force evaluation of the
     elements of the stream.

          (define s (stream 1 (/ 1 0) -1))
          (define r (stream-reverse s))
          (stream-ref r 0)
          (stream-ref r 2)        => 1
          (stream-ref r 1)        => error: division by zero

 -- Function: stream-scan PROC BASE STREAM
     Accumulate the partial folds of an input STREAM into a
     newly-allocated output stream.  The output stream is the BASE
     followed by:

          (stream-fold proc base (stream-take i stream))

     for each of the first i elements of STREAM.

     Examples:

          (stream-scan + 0 (stream-from 1))
            => (stream 0 1 3 6 10 15 ...)

          (stream-scan * 1 (stream-from 1))
            => (stream 1 1 2 6 24 120 ...)

 -- Function: stream-take N STREAM
     Take a non-negative integer N and a STREAM and return a
     newly-allocated stream containing the first Fn elements of the
     input stream.  If the input stream has less than N elements, so
     does the output stream.  See also 'stream-drop'.

     Example: 'merge-sort' splits a stream into two equal-length pieces,
     sorts them recursively and merges the results:

          (define-stream (merge-sort lt? strm)
            (let* ([n     (quotient (stream-length strm) 2)]
                   [ts    (stream-take n strm)]
                   [ds    (stream-drop n strm)])
              (if (zero? n)
                  strm
                (stream-merge lt? (msort < ts) (msort < ds)))))

 -- Function: stream-take-while PRED? STREAM
     Take a predicate and a stream and return a newly-allocated stream
     containing those elements X that form the maximal prefix of the
     input stream for which '(pred? x)' is non-'#f'.  See also
     'stream-drop-while'.

          (stream-car
            (stream-reverse
              (stream-take-while
                (lambda (x) (< x 1000))
                primes)))
            => 997

 -- Function: stream-unfold MAP PRED? GEN BASE
     'stream-unfold' is the fundamental recursive stream constructor.
     It constructs a stream by repeatedly applying GEN to successive
     values of BASE, in the manner of 'stream-iterate', then applying
     MAP to each of the values so generated, appending each of the
     mapped values to the output stream as long as '(pred? base)' is
     non-'#f'.  See also 'stream-iterate' and 'stream-unfolds'.

     Example: the expression below creates the finite stream:

          0 1 4 9 16 25 36 49 64 81

     initially the base is '0', which is less than '10', so MAP squares
     the base and the mapped value becomes the first element of the
     output stream; then GEN increments the base by '1', so it becomes
     '1'; this is less than '10', so MAP squares the new base and '1'
     becomes the second element of the output stream; and so on, until
     the base becomes '10', when PRED? stops the recursion and
     'stream-null' ends the output stream.

          (stream-unfold
            (lambda (x) (expt x 2)) ; map
            (lambda (x) (< x 10))   ; pred?
            (lambda (x) (+ x 1))    ; gen
            0)                      ; base

 -- Function: stream-unfolds PROC SEED
     Return N newly-allocated streams containing those elements produced
     by successive calls to the generator PROC, which takes the current
     SEED as its argument and returns 'n+1' values:

          (proc seed) -> seed result0 ...  resultn-1

     where the returned SEED is the input SEED to the next call to the
     generator and RESULTI indicates how to produce the next element of
     the ith result stream:

     '(value)'
          VALUE is the next car of the result stream;

     '#f'
          no value produced by this iteration of the generator PROC for
          the result stream;

     '()'
          the end of the result stream.

     It may require multiple calls of PROC to produce the next element
     of any particular result stream.  See also 'stream-iterate' and
     'stream-unfold'.

     'stream-unfolds' is especially useful when writing expressions that
     return multiple streams.  For instance, '(stream-partition pred?
     strm)' is equivalent to:

          (values
            (stream-filter pred? strm)
            (stream-filter
              (lambda (x) (not (pred? x))) strm))

     but only tests 'pred?' once for each element of STRM.

     Example:

          (define (stream-partition pred? strm)
            (stream-unfolds
              (lambda (s)
                (if (stream-null? s)
                    (values s '() '())
                  (let ([a (stream-car s)]
                        [d (stream-cdr s)])
                    (if (pred? a)
                        (values d (list a) #f)
                      (values d #f (list a))))))
              strm))

          (call-with-values
            (lambda ()
              (stream-partition odd?
                (stream-range 1 6)))
            (lambda (odds evens)
              (list (stream->list odds)
                    (stream->list evens))))
            => ((1 3 5) (2 4))

 -- Function: stream-zip STREAM ...
     Take one or more input streams and return a newly-allocated stream
     in which each element is a list (not a stream) of the corresponding
     elements of the input streams.  The output stream is as long as the
     shortest input stream, if any of the input streams is finite, or is
     infinite if all the input streams are infinite.

     A common use of 'stream-zip' is to add an index to a stream, as in:

          (stream-finds eql? obj strm)

     which returns all the zero-based indices in STRM at which OBJ
     appears; '(stream-find eql? obj strm)' returns the first such
     index, or '#f' if OBJ is not in STRM.

          (define-stream (stream-finds eql? obj strm)
            (stream-of (car x)
              (x in (stream-zip (stream-from 0) strm))
              (eql? obj (cadr x))))

          (define (stream-find eql? obj strm)
            (stream-car
              (stream-append
                (stream-finds eql? obj strm)
                (stream #f))))

          (stream-find char=? #\l
            (list->stream
              (string->list "hello")))
            => 2

          (stream-find char=? #\l
            (list->stream
              (string->list "goodbye")))
            => #f

     'stream-find' is not as inefficient as it looks; although it calls
     'stream-finds', which finds all matching indices, the matches are
     computed lazily, and only the first match is needed for
     'stream-find'.


File: vicare-libs.info,  Node: srfi streams utilities,  Next: srfi streams examples,  Prev: srfi streams derived,  Up: srfi streams

2.21.7 Utilities
----------------

Streams, being the signature structured data type of functional
programming languages, find useful expression in conjunction with
higher-order functions.  Some of these higher-order functions, and their
relationship to streams, are described below.

   The identity and constant procedures are frequently useful as the
recursive base for maps and folds; '(identity obj)' always returns OBJ,
and '(const obj)' creates a procedure that takes any number of arguments
and always returns the same OBJ, no matter its arguments:

     (define (identity obj) obj)

     (define (const obj) (lambda x obj))

   Many of the stream procedures take a unary predicate that accepts an
element of a stream and returns a boolean.  Procedure '(negate pred?)'
takes a unary predicate and returns a new unary predicate that, when
called, returns the opposite boolean value as the original predicate.

     (define (negate pred?)
       (lambda (x) (not (pred? x))))

   'negate' is useful for procedures like 'stream-take-while' that take
a predicate, allowing them to be used in the opposite direction from
which they were written; for instance, with the predicate reversed,
'stream-take-while' becomes 'stream-take-until'.  'stream-remove' is the
opposite of 'stream-filter':

     (define-stream (stream-remove pred? strm)
       (stream-filter (negate pred?) strm))

   A section is a procedure which has been partially applied to some of
its arguments; for instance, '(double x)', which returns twice its
argument, is a partial application of the multiply operator to the
number 2.  Sections come in two kinds:

   * left sections partially apply arguments starting from the left;
   * right sections partially apply arguments starting from the right;

the procedure 'lsec' takes a procedure and some prefix of its arguments
and returns a new procedure in which those arguments are partially
applied; the procedure 'rsec' takes a procedure and some reversed suffix
of its arguments and returns a new procedure in which those arguments
are partially applied:

     (define (lsec proc . args)
       (lambda x (apply proc (append args x))))

     (define (rsec proc . args)
       (lambda x
         (apply proc (reverse (append (reverse args) (reverse x))))))

   Since most of the stream procedures take a stream as their last
(rightmost) argument, left sections are particularly useful in
conjunction with streams.

     (define stream-sum (lsec stream-fold + 0))

   Function composition creates a new function by partially applying
multiple functions, one after the other.  In the simplest case there are
only two functions, F and G, composed as '(compose f g)'; the
composition can be bound to create a new function, as in:

     (define fg (compose f g))

The procedure 'compose' takes one or more procedures and returns a new
procedure that performs the same action as the individual procedures
would if called in succession:

     (define (compose . fns)
       (let comp ((fns fns))
         (cond
           [(null? fns) 'error]
           [(null? (cdr fns)) (car fns)]
           [else
             (lambda args
               (call-with-values
                 (lambda ()
                   (apply
                     (comp (cdr fns))
                     args))
                 (car fns)))])))

   'compose' works with sections to create succinct but highly
expressive procedure definitions.  The expression to compute the squares
of the integers from 1 to 10 given above at 'stream-unfold' could be
written by composing 'stream-map', 'stream-take-while', and
'stream-iterate':

     ([compose
       (lsec stream-map (rsec expt 2))
       (lsec stream-take-while (negate (rsec > 10)))
       (lsec stream-iterate (rsec + 1))]
      1)


File: vicare-libs.info,  Node: srfi streams examples,  Next: srfi streams ack,  Prev: srfi streams utilities,  Up: srfi streams

2.21.8 Examples
---------------

The examples below show a few of the myriad ways streams can be
exploited, as well as a few ways they can trip the unwary user.  All the
examples are drawn from published sources; it is instructive to compare
the Scheme versions to the originals in other languages.

* Menu:

* srfi streams examples infinite::      Infinite streams.
* srfi streams examples generators::    Generators and co-routines.
* srfi streams examples pipeline::      A pipeline of procedures.
* srfi streams examples persistent::    Persistent data.
* srfi streams examples passes::        Reducing two passes to one.
* srfi streams examples pitfalls::      Pitfalls.


File: vicare-libs.info,  Node: srfi streams examples infinite,  Next: srfi streams examples generators,  Up: srfi streams examples

2.21.8.1 Infinite streams
.........................

As a simple illustration of infinite streams, consider this definition
of the natural numbers:

     (define nats
       (stream-cons 0
         (stream-map add1 nats)))

the recursion works because it is offset by one from the initial
'stream-cons'.  Another sequence that uses the offset trick is this
definition of the Fibonacci numbers:

     (define fibs
       (stream-cons 1
         (stream-cons 1
           (stream-map +
             fibs
             (stream-cdr fibs)))))

   Yet another sequence that uses the same offset trick is the Hamming
numbers, named for the mathematician and computer scientist Richard
Hamming, defined as all numbers that have no prime factors greater than
5; in other words, Hamming numbers are all numbers expressible as

     2i x 3j x 5k

where I, J and K are non-negative integers.  The Hamming sequence starts
with 1 2 3 4 5 6 8 9 10 12 and is computed starting with 1, taking 2, 3
and 5 times all the previous elements with 'stream-map', then merging
'sub-streams' and eliminating duplicates:

     (define hamming
       (stream-cons 1
         (stream-unique =
           (stream-merge <
             (stream-map (lsec * 2) hamming)
             (stream-map (lsec * 3) hamming)
             (stream-map (lsec * 5) hamming)))))

   It is possible to have an infinite stream of infinite streams.
Consider the definition of 'power-table':

     (define power-table
       (stream-of
         (stream-of (expt m n)
           (m in (stream-from 1)))
           (n in (stream-from 2))))

which evaluates to an infinite stream of infinite streams:

     (stream
       (stream 1 4 9 16 25 ...)
       (stream 1 8 27 64 125 ...)
       (stream 1 16 81 256 625 ...)
       ...)

   But even though it is impossible to display 'power-table' in its
entirety, it is possible to select just part of it:

     (stream->list 10 (stream-ref power-table 1))
       => (1 8 27 64 125 216 343 512 729 1000)

   This example clearly shows that the elements of a stream are computed
lazily, as they are needed; '(stream-ref power-table 0)' is not
computed, even when its successor is displayed, since computing it would
enter an infinite loop.

   Chris Reade shows how to calculate the stream of prime numbers
according to the sieve of Eratosthenes, using a method that eliminates
multiples of the sifting base with addition rather than division:

     (define primes (let ()
       (define-stream (next base mult strm)
         (let ((first (stream-car strm))
               (rest (stream-cdr strm)))
           (cond ((< first mult)
                   (stream-cons first
                     (next base mult rest)))
                 ((< mult first)
                   (next base (+ base mult) strm))
                 (else (next base
                         (+ base mult) rest)))))
       (define-stream (sift base strm)
         (next base (+ base base) strm))
       (define-stream (sieve strm)
         (let ((first (stream-car strm))>
               (rest (stream-cdr strm)))
           (stream-cons first
             (sieve (sift first rest)))))
       (sieve (stream-from 2))))

   A final example of infinite streams is a functional pearl from Jeremy
Gibbons, David Lester and Richard Bird that enumerates the positive
rational numbers without duplicates:

     (define rats
       (stream-iterate
         (lambda (x)
           (let* ((n (floor x)) (y (- x n)))
             (/ (- n -1 y))))
         1))


File: vicare-libs.info,  Node: srfi streams examples generators,  Next: srfi streams examples pipeline,  Prev: srfi streams examples infinite,  Up: srfi streams examples

2.21.8.2 Generators and co-routines
...................................

It is possible to model generators and co-routines using streams.
Consider the task, due to Carl Hewitt, of determining if two trees have
the same sequence of leaves:

     (same-fringe? = '(1 (2 3)) '((1 2) 3))  => #t

     (same-fringe? = '(1 2 3) '(1 (3 2)))    => #f

   The simplest solution is to flatten both trees into lists and compare
them element-by-element:

     (define (flatten tree)
       (cond [(null? tree) '()]
             [(pair? (car tree))
              (append (flatten (car tree))
                      (flatten (cdr tree)))]
             [else (cons (car tree)
                         (flatten (cdr tree)))]))

     (define (same-fringe? eql? tree1 tree2)
       (let loop ([t1 (flatten tree1)]
                  [t2 (flatten tree2)])
         (cond [(and (null? t1) (null? t2)) #t]
               [(or (null? t1) (null? t2)) #f]
               [(not (eql? (car t1) (car t2))) #f]
               [else (loop (cdr t1) (cdr t2))])))

   That works, but requires time to flatten both trees and space to
store the flattened versions; if the trees are large, that can be a lot
of time and space, and if the fringes differ, much of that time and
space is wasted.

   Hewitt used a generator to flatten the trees one element at a time,
storing only the current elements of the trees and the machines needed
to continue flattening them, so 'same-fringe?' could stop early if the
trees differ.  Dorai Sitaram presents both the generator solution and a
co-routine solution, which both involve tricky calls to
'call-with-current-continuation' and careful coding to keep them
synchronized.

   An alternate solution flattens the two trees to streams instead of
lists, which accomplishes the same savings of time and space, and
involves code that looks little different than the list solution
presented above:

     (define-stream (flatten tree)
       (cond [(null? tree) stream-null]
             [(pair? (car tree))
              (stream-append
                (flatten (car tree))
                (flatten (cdr tree)))]
             [else (stream-cons
                     (car tree)
                     (flatten (cdr tree)))]))

     (define (same-fringe? eql? tree1 tree2)
       (let loop ([t1 (flatten tree1)]
                  [t2 (flatten tree2)])
         (cond [(and (stream-null? t1)
                     (stream-null? t2)) #t]
               [(or  (stream-null? t1)
                     (stream-null? t2)) #f]
               [(not (eql? (stream-car t1)
                           (stream-car t2))) #f]
               [else (loop (stream-cdr t1)
                           (stream-cdr t2))])))

   Note that streams, a data structure, replace generators or
co-routines, which are control structures, providing a fine example of
how lazy streams enhance modularity.


File: vicare-libs.info,  Node: srfi streams examples pipeline,  Next: srfi streams examples persistent,  Prev: srfi streams examples generators,  Up: srfi streams examples

2.21.8.3 A pipeline of procedures
.................................

Another way in which streams promote modularity is enabling the use of
many small procedures that are easily composed into larger programs, in
the style of Unix pipelines, where streams are important because they
allow a large dataset to be processed one item at a time.  Bird and
Wadler provide the example of a text formatter.  Their example uses
right-folds:

     (define (stream-fold-right f base strm)
       (if (stream-null? strm)
           base
         (f (stream-car strm)
            (stream-fold-right f base
              (stream-cdr strm)))))

     (define (stream-fold-right-one f strm)
       (stream-match strm
         [(x) x]
         [(x . xs)
          (f x (stream-fold-right-one f xs))]))

   Bird and Wadler define text as a stream of characters, and develop a
standard package for operating on text, which they derive mathematically
(this assumes the line-separator character is a single '#\newline'):

     (define (breakon a)
       (stream-lambda (x xss)
         (if (equal? a x)
             (stream-append (stream (stream)) xss)
           (stream-append
             (stream (stream-append
                 (stream x) (stream-car xss)))
             (stream-cdr xss)))))

     (define-stream (lines strm)
       (stream-fold-right
         (breakon #\newline)
         (stream (stream))
         strm))

     (define-stream (words strm)
       (stream-filter stream-pair?
         (stream-fold-right
           (breakon #\space)
           (stream (stream))
           strm)))

     (define-stream (paras strm)
       (stream-filter stream-pair?
         (stream-fold-right
           (breakon stream-null)
           (stream (stream))
           strm)))

     (define (insert a)
       (stream-lambda (xs ys)
         (stream-append xs (stream a) ys)))

     (define unlines
       (lsec stream-fold-right-one
         (insert #\newline)))

     (define unwords
       (lsec stream-fold-right-one
         (insert #\space)))

     (define unparas
       (lsec stream-fold-right-one
         (insert stream-null)))

   These versatile procedures can be composed to count words, lines and
paragraphs; the 'normalize' procedure squeezes out multiple spaces and
blank lines:

     (define countlines
       (compose stream-length lines))

     (define countwords
       (compose stream-length
                stream-concat
                (lsec stream-map words)
                lines))

     (define countparas
       (compose stream-length paras lines))

     (define parse
       (compose (lsec stream-map
                  (lsec stream-map words))
                paras
                lines))

     (define unparse
       (compose unlines
                unparas
                (lsec stream-map
                  (lsec stream-map unwords))))

     (define normalize (compose unparse parse))

   More useful than normalization is text-filling, which packs as many
words onto each line as will fit.

     (define (greedy m ws)
       (- (stream-length
            (stream-take-while (rsec <= m)
              (stream-scan
                (lambda (n word)
                  (+ n (stream-length word) 1))
                -1
                ws))) 1))

     (define-stream (fill m ws)
       (if (stream-null? ws)
           stream-null
         (let* ([n (greedy m ws)]
                [fstline (stream-take n ws)]
                [rstwrds (stream-drop n ws)])
           (stream-append
             (stream fstline)
             (fill m rstwrds)))))

     (define linewords
       (compose stream-concat
                (lsec stream-map words)))

     (define textparas
       (compose (lsec stream-map linewords)
                paras
                lines))

     (define (filltext m strm)
       (unparse (stream-map (lsec fill m) (textparas strm))))

   To display filename in lines of N characters, say:

     (stream-for-each display
       (filltext n (file->stream filename)))

   Though each operator performs only a single task, they can be
composed powerfully and expressively.  The alternative is to build a
single monolithic procedure for each task, which would be harder and
involve repetitive code.  Streams ensure procedures are called as
needed.


File: vicare-libs.info,  Node: srfi streams examples persistent,  Next: srfi streams examples passes,  Prev: srfi streams examples pipeline,  Up: srfi streams examples

2.21.8.4 Persistent data
........................

Queues are one of the fundamental data structures of computer science.
In functional languages, queues are commonly implemented using two
lists, with the front half of the queue in one list, where the head of
the queue can be accessed easily, and the rear half of the queue in
reverse order in another list, where new items can easily be added to
the end of a queue.  The standard form of such a queue holds that the
front list can only be null if the rear list is also null:

     (define queue-null (cons '() '())

     (define (queue-null? obj)
       (and (pair? obj) (null? (car obj))))

     (define (queue-check f r)
       (if (null? f)
           (cons (reverse r) '())
         (cons f r)))

     (define (queue-snoc q x)
       (queue-check (car q) (cons x (cdr q))))

     (define (queue-head q)
       (if (null? (car q))
           (error "empty queue: head")
         (car (car q))))

     (define (queue-tail q)
       (if (null? (car q))
           (error "empty-head: tail")
         (queue-check (cdr (car q)) (cdr q))))

   This queue operates in amortized constant time per operation, with
two conses per element, one when it is added to the rear list, and
another when the rear list is reversed to become the front list.
'queue-snoc' and 'queue-head' operate in constant time; 'queue-tail'
operates in worst-case linear time when the front list is empty.

   Chris Okasaki points out that, if the queue is used persistently, its
time-complexity rises from linear to quadratic since each persistent
copy of the queue requires its own linear-time access.  The problem can
be fixed by implementing the front and rear parts of the queue as
streams, rather than lists, and rotating one element from rear to front
whenever the rear list is larger than the front list:

     (define queue-null
       (cons stream-null stream-null))

     (define (queue-null? x)
       (and (pair? x) (stream-null (car x))))

     (define (queue-check f r)
       (if (< (stream-length r) (stream-length f))
           (cons f r)
         (cons (stream-append f (stream-reverse r))
               stream-null)))

     (define (queue-snoc q x)
       (queue-check (car q) (stream-cons x (cdr q))))

     (define (queue-head q)
       (if (stream-null? (car q))
           (error "empty queue: head")
         (stream-car (car q))))

     (define (queue-tail q)
       (if (stream-null? (car q))
           (error "empty queue: tail")
         (queue-check (stream-cdr (car q)) (cdr q))))

   Memoization solves the persistence problem; once a queue element has
moved from rear to front, it needs never be moved again in subsequent
traversals of the queue.  Thus, the linear time-complexity to access all
elements in the queue, persistently, is restored.


File: vicare-libs.info,  Node: srfi streams examples passes,  Next: srfi streams examples pitfalls,  Prev: srfi streams examples persistent,  Up: srfi streams examples

2.21.8.5 Reducing two passes to one
...................................

The final example is a lazy dictionary, where definitions and uses may
occur in any order; in particular, uses may precede their corresponding
definitions.  This is a common problem.

   Many programming languages allow procedures to be used before they
are defined.  Macro processors must collect definitions and emit uses of
text in order.  An assembler needs to know the address that a linker
will subsequently give to variables.  The usual method is to make two
passes over the data, collecting the definitions on the first pass and
emitting the uses on the second pass.  But Chris Reade shows how streams
allow the dictionary to be built lazily, so that only a single pass is
needed.  Consider a stream of requests:

     (define requests
       (stream
         '(get 3)
         '(put 1 "a")    ; use follows definition
         '(put 3 "c")    ; use precedes definition
         '(get 1)
         '(get 2)
         '(put 2 "b")    ; use precedes definition
         '(put 4 "d")))  ; unused definition

   We want a procedure that will display cab, which is the result of
'(get 3)', '(get 1)', and '(get 2)', in order.  We first separate the
request stream into gets and puts:

     (define (get? obj) (eq? (car obj) 'get))

     (define-stream (gets strm)
       (stream-map cadr (stream-filter get? strm)))

     (define-stream (puts strm)
       (stream-map cdr  (stream-remove get? strm)))

   Now, 'run-dict' inserts each element of the puts stream into a lazy
dictionary, represented as a stream of key/value pairs (an association
stream), then looks up each element of the gets stream with
'stream-assoc':

     (define-stream (run-dict requests)
       (let ([dict (build-dict (puts requests))])
         (stream-map (rsec stream-assoc dict)
           (gets requests))))

     (define (stream-assoc key dict)
         (cond [(stream-null? dict) #f]
               [(equal? key (car (stream-car dict)))
                (stream-car dict)]
               [else (stream-assoc key
                       (stream-cdr dict))]))

   DICT is created in the 'let', but nothing is initially added to it.
Each time 'stream-assoc' performs a lookup, enough of DICT is built to
satisfy the lookup, but no more.  We are assuming that each item is
defined once and only once.  All that is left is to define the procedure
that inserts new items into the dictionary, lazily:

     (define-stream (build-dict puts)
       (if (stream-null? puts)
           stream-null
         (stream-cons
           (stream-car puts)
           (build-dict (stream-cdr puts)))))


   Now we can run the requests and print the result:

     (stream-for-each display
       (stream-map cadr (run-dict requests)))

   The '(put 4 "d")' definition is never added to the dictionary because
it is never needed.


File: vicare-libs.info,  Node: srfi streams examples pitfalls,  Prev: srfi streams examples passes,  Up: srfi streams examples

2.21.8.6 Pitfalls
.................

Programming with streams, or any lazy evaluator, can be tricky, even for
programmers experienced in the genre.  Programming with streams is even
worse in Scheme than in a purely functional language, because, though
the streams are lazy, the surrounding Scheme expressions in which they
are embedded are eager.  The impedance between lazy and eager can
occasionally lead to astonishing results.  Thirty-two years ago, William
Burge warned:

     Some care must be taken when a stream is produced to make sure that
     its elements are not really a list in disguise, in other words, to
     make sure that the stream elements are not materialized too soon.

   For example, a simple version of 'stream-map' that returns a stream
built by applying a unary procedure to the elements of an input stream
could be defined like this:

     (define-stream (stream-map proc strm) ;wrong!
       (let loop ([strm strm])
         (if (stream-null? strm)
             stream-null
           (stream-cons
             (proc (stream-car strm))
             (loop (stream-cdr strm))))))

   That looks right.  It properly wraps the procedure in
'stream-lambda', and the two legs of the 'if' both return streams, so it
type-checks.  But it fails because the named 'let' binds LOOP to a
procedure using normal 'lambda' rather than 'stream-lambda', so even
though the first element of the result stream is lazy, subsequent
elements are eager.  'stream-map' can be written using 'stream-let':

     (define-stream (stream-map proc strm)
       (stream-let loop ([strm strm])
         (if (stream-null? strm)
             stream-null
           (stream-cons
             (proc (stream-car strm))
             (loop (stream-cdr strm))))))

   Here, 'stream-let' assures that each element of the result stream is
properly delayed, because each is subject to the 'stream-lambda' that is
implicit in 'stream-let', so the result is truly a stream, not a "list
in disguise".  Another version of this procedure was given previously at
the description of 'define-stream'.

   Another common problem occurs when a stream-valued procedure requires
the next stream element in its definition.  Consider this definition of
'stream-unique':

     (define-stream (stream-unique eql? strm) ;wrong!
       (stream-match strm
         [() strm]
         [(_) strm]
         [(a b . _)
          (if (eql? a b)
              (stream-unique eql?
                (stream-cdr strm))
            (stream-cons a
              (stream-unique eql?
                (stream-cdr strm))))]))

the '(a b . _)' pattern requires the value of the next stream element
after the one being considered.  Thus, to compute the nth element of the
stream, one must know the n+1st element, and to compute the n+1st
element, one must know the n+2nd element, and to compute...  The correct
version, given above in the description of 'stream-drop-while', only
needs the current stream element.

   A similar problem occurs when the stream expression uses the previous
element to compute the current element:

     (define (nat n)
       (stream-ref
         (stream-let loop ([s (stream 0)])
           (stream-cons (stream-car s)
             (loop (stream (add1 (stream-car s))))))
         n))

this program traverses the stream of natural numbers, building the
stream as it goes.  The definition is correct: '(nat 15)' evaluates to
15; but it needlessly uses unbounded space because each stream element
holds the value of the prior stream element in the binding to S.

   When traversing a stream, it is easy to write the expression in such
a way that evaluation requires unbounded space, even when that is not
strictly necessary.  During the discussion of SRFI-40, Joe Marshall
created this infamous procedure:

     (define (times3 n)
       (stream-ref
         (stream-filter
           (lambda (x)
             (zero? (modulo x n)))
           (stream-from 0))
         3))

'(times3 5)' evaluates to 15 and '(times3 #e1e9)' evaluates to three
billion, though it takes a while.  In either case, 'times3' should
operate in bounded space, since each iteration mutates the promise that
holds the next value.  But it is easy to write 'times3' so that it does
not operate in bounded space, as the follies of SRFI-40 showed.

   The common problem is that some element of the stream (often the
first element) is bound outside the expression that is computing the
stream, so it holds the head of the stream, which holds the second
element, and so on.  In addition to testing the programmer, this
procedure tests the stream primitives (it caught several errors during
development) and also tests the underlying Scheme system (it found a bug
in one implementation).

   Laziness is no defense against an infinite loop; for instance, the
expression below never returns, because the 'odd?' predicate never finds
an odd stream element.

     (stream-null?
       (stream-filter odd?
         (stream-from 0 2)))

   Ultimately, streams are defined as promises, which are implemented as
thunks (lambda with no arguments).  Since a stream is a procedure,
comparisons such as 'eq?', 'eqv?' and 'equal?' are not meaningful when
applied to streams.  For instance, the expression

     (define s ((stream-lambda () stream-null)))

defines S as the null stream, and '(stream-null? s)' is '#t', but '(eq?
s stream-null)' is '#f'.

   To determine if two streams are equal, it is necessary to evaluate
the elements in their common prefixes, reporting '#f' if two elements
ever differ and '#t' if both streams are exhausted at the same time.

     (define (stream-equal? eql? xs ys)
       (cond [(and (stream-null? xs)
                   (stream-null? ys)) #t]
             [(or (stream-null? xs)
                  (stream-null? ys)) #f]
             [(not (eql? (stream-car xs)
                         (stream-car ys))) #f]
             [else (stream-equal? eql?
                     (stream-cdr xs)
                     (stream-cdr ys))]))

   It is generally not a good idea to mix lazy streams with eager
side-effects, because the order in which stream elements are evaluated
determines the order in which the side-effects occur.  For a simple
example, consider this side-effecting version of 'strm123':

     (define strm123-with-side-effects
       (stream-cons (begin (display "one") 1)
         (stream-cons (begin (display "two") 2)
           (stream-cons (begin (display "three") 3)
             stream-null))))

   The stream has elements '1 2 3'.  But depending on the order in which
stream elements are accessed, '"one"', '"two"' and '"three"' could be
printed in any order.

   Since the performance of streams can be very poor, normal (eager)
lists should be preferred to streams unless there is some compelling
reason to the contrary.  For instance, computing pythagorean triples
with streams:

     (stream-ref
       (stream-of (list a b c)
         (n in (stream-from 1))
         (a in (stream-range 1 n))
         (b in (stream-range a n))
         (c is (- n a b))
         (= (+ (* a a) (* b b)) (* c c)))
       50)

is about two orders of magnitude slower than the equivalent expression
using loops:

     (do ([n 1 (+ n 1)]) ([> n 228])
       (do ([a 1 (+ a 1)]) ([> a n])
         (do ([b a (+ b 1)]) ([> b n])
           (let ([c (- n a b)])
             (if (= (+ (* a a) (* b b)) (* c c))
                 (display (list a b c)))))))


File: vicare-libs.info,  Node: srfi streams ack,  Next: srfi streams references,  Prev: srfi streams examples,  Up: srfi streams

2.21.9 Acknowledgments
----------------------

Jos Koot sharpened my thinking during many email discussions, suggested
several discussion points in the text, and contributed the final version
of 'stream-match'.  Michael Sperber and Abdulaziz Ghuloum gave advice on
R6RS.


File: vicare-libs.info,  Node: srfi streams references,  Prev: srfi streams ack,  Up: srfi streams

2.21.10 References
------------------

All cited web pages visited during September 2007.

Harold Abelson and Gerald Jay Sussman with Julie Sussman.  _Structure
and Interpretation of Computer Programs_.  MIT Press, Cambridge,
Massachusetts.  Second edition, 1996.  The classic text on computer
science.  Section 3.5 includes extensive discussion of odd streams.

                        <mitpress.mit.edu/sicp>

Anne L. Bewig.  _Golden Ratio_ (personal communication).  Homework for
the high school course Calculus.  Teaching my daughter how to calculate
the 200th element of a continued fraction was a moment of sheer joy in
the development of the stream libraries.

Philip L. Bewig.  _Scheme Request for Implementation 40: A Library of
Streams_.  August, 2004.  Describes an implementation of the stream data
type.

                      <srfi.schemers.org/srfi-40>

Richard Bird and Philip Wadler.  _Introduction to Functional
Programming_.  Prentice Hall, 1988.  The classic text on functional
programming.  Even streams are discussed in the context of purely
functional programming.

William H. Burge.  _Recursive Programming Techniques_.  Addison-Wesley,
1975.  An early text on functional programming, and still one of the
best, though the terminology is dated.  Discusses even streams in
Section 3.10.

Jeremy Gibbons, David Lester and Richard Bird, _Functional Pearl:
Enumerating the Rationals,_ under consideration for publication in
Journal of Functional Programming.  Discusses a series of expressions
that enumerate the rational numbers without duplicates.

<http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf>

Carl Hewitt.  _Viewing control structures as patterns of passing
messages,_ in Journal of Artificial Intelligence, Volume 8, Number 3
(June, 1977), pp 323-364.  Also published as Artificial Intelligence
Memo 410 by the Massachusetts Institute of Technology.  Describes the
Actor message-passing system; one of the examples used is the
'same-fringe?' problem.

    <ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-410.pdf>

Peter J. Landin.  _A correspondence between ALGOL 60 and Church's
lambda-notation: Part I,_ Communications of the ACM, Volume 8, Number 2,
February 1965, pages 89-101.  The seminal description of streams.

Joe Marshall.  "Stream problem redux", from Usenet comp.lang.scheme,
June 28, 2002.  The original post on comp.lang.scheme that describes the
times3 problem.

    <groups.google.com/group/comp.lang.scheme/msg/db4b4a1f33e3eea8>

Chris Okasaki.  _Purely Functional Data Structures_.  Cambridge
University Press, 2003.  Revised version of Okasaki's thesis Purely
Functional Data Structures, Carnegie-Mellon University, 1996.  Provides
a strong defense of laziness, and describes several data structures that
exploit laziness, including streams and queues.

               <www.cs.cmu.edu/~rwh/theses/okasaki.pdf>

Stephen K. Park and Keith W. Miller.  _Random number generators: good
ones are hard to find_, Communications of the ACM, Volume 31, Issue 10
(October 1988), pages 1192-1201.  Describes a minimal standard random
number generator.

Simon Peyton-Jones, et al, editors.  _Haskell 98: Haskell 98 Language
and Libraries: The Revised Report_.  December 2002.  Haskell is the
prototypical purely functional language, and includes even streams,
which it calls lists, as its fundamental structured data type.

                    <www.haskell.org/onlinereport>

Chris Reade.  _Elements of Functional Programming_.  Addison-Wesley,
April 1989.  A textbook on functional programming.

Antoine de Saint-Exupery.  Chapter III _"L'Avion" of Terre des Hommes_.
1939.  "Perfection is achieved, not when there is nothing more to add,
but when there is nothing left to take away."

Dorai Sitaram.  _Teach Yourself Scheme in Fixnum Days_.  A useful
introduction to Scheme; includes generator and co-routine solutions to
the 'same-fringe?' problem.

        <www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html>

Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton von Straaten,
editors.  _Revised6 Report on the Algorithmic Language Scheme_.
September 26, 2007.  <www.r6rs.org>.  The standard definition of the
Scheme programming language.

Andre van Tonder.  _Scheme Request for Implementation 45: Primitives for
Expressing Iterative Lazy Algorithms_.  April, 2004.  Describes the
problems inherent in the promise data type of R5RS (also present in
R6RS), and provides the alternate promise data type used in the stream
primitives.

                      <srfi.schemers.org/srfi-45>

Philip Wadler.  _How to replace failure by a list of successes_, in
Proceedings of the conference on functional programming languages and
computer architecture, Nancy, France, 1985, pages 113-128.  Describes
the "list of successes" technique for implementing backtracking
algorithms using streams.

Philip Wadler, Walid Taha, and David MacQueen.  _How to add laziness to
a strict language without even being odd._  1998 ACM SIGPLAN Workshop on
ML, pp.  24ff.  Describes odd and even styles of lazy evaluation, and
shows how to add lazy evaluation to the strict functional language SML.

  <homepages.inf.ed.ac.uk/wadler/papers/lazyinstrict/lazyinstrict.ps>


File: vicare-libs.info,  Node: srfi eager-comp,  Next: srfi vectors,  Prev: srfi streams,  Up: srfi

2.22 SRFI-42 eager comprehensions
=================================

The library '(srfi :42)' is by Sebastian Egner as the reference
implementation for SRFI-42; see:

            <http://srfi.schemers.org/srfi-42/srfi-42.html>

for more details.

* Menu:

* srfi eager-comp license::     Original document license.
* srfi eager-comp abstract::    Abstract.
* srfi eager-comp rationale::   Rationale.
* srfi eager-comp spec::        Specification.
* srfi eager-comp design::      Design rationale.
* srfi eager-comp ack::         Related work and acknowledgements.
* srfi eager-comp references::  References.


File: vicare-libs.info,  Node: srfi eager-comp license,  Next: srfi eager-comp abstract,  Up: srfi eager-comp

2.22.1 Original document license
--------------------------------

Copyright (C) 2003 Sebastian Egner.  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi eager-comp abstract,  Next: srfi eager-comp rationale,  Prev: srfi eager-comp license,  Up: srfi eager-comp

2.22.2 Abstract
---------------

This SRFI defines a modular and portable mechanism for eager
comprehensions extending the algorithmic language Scheme.  An eager
comprehension is a convenient notation for one or more nested or
parallel loops generating a sequence of values, and accumulating this
sequence into a result.  In its most simple form, a comprehension
according to this SRFI looks like this:

     (list-ec (: i 5)
       (* i i))
     => (0 1 4 9 16)

Here, I is a local variable that is sequentially bound to the values 0,
1, ..., 4, and the squares of these numbers are collected in a list.
The following example illustrates most conventions of this SRFI with
respect to nesting and syntax:

     (list-ec (: n 1 4)
              (: i n)
       (list n i))
     => ((1 0) (2 0) (2 1) (3 0) (3 1) (3 2))

In the example, the variable N is first bound to 1 then to 2 and finally
to 3, and for each binding of N the variable I is bound to the values 0,
1, ..., N-1 in turn.  The expression '(list n i)' constructs a
two-element list for each bindings, and the comprehension 'list-ec'
collects all these results in a list.

   The mechanism defined in this SRFI has the following properties:

   * The set of comprehensions defined for this SRFI is inspired by
     those procedures and macros of R5RS leading to natural
     comprehensions such as 'list-ec', 'append-ec', 'sum-ec', 'min-ec',
     'every?-ec', 'do-ec', and others.  Some other natural
     comprehensions (e.g.  'gcd-ec') have not been included into this
     SRFI due to their low significance for most applications.  On the
     other hand, a few comprehensions ('fold-ec', 'fold3-ec') not
     inspired by R5RS have been included due to their broad
     applicability.

   * There are typed generators (':list', ':string', ...) expecting
     certain types of objects for their arguments.  These generators
     usually produce code as efficient as hand coded 'do'-loops.

   * There is also the special generator ':' (read "run through")
     dispatching on the value of its argument list at runtime.  In the
     examples above, one or two integers were used to define a range.
     The convenience of omitting the type comes at a certain performance
     penalty, both per iteration and during startup of the loop.

   * Generators can be nested depth-first (as in the example above), run
     in parallel (with an optional index variable or more generally with
     ':parallel'), and can be stopped early before (':while') or after
     (':until') producing the current value.

   * The sequence of values can be filtered ('if', 'not', 'and', 'or'),
     intermediate commands can be evaluated between generators
     ('begin'), and intermediate variables can be introduced (':let').

   * The mechanism is fully modular.  This means that no existing macro
     or procedure needs to be modified when adding application-specific
     comprehensions, application-specific typed generators, or
     application-specific dispatching generators.

   * Syntactically, this SRFI uses the '[outer .. inner | expr]'
     convention, meaning that the most right generator (INNER) spins
     fastest and is followed by the result expression over which the
     comprehension ranges (EXPR).  *note srfi eager-comp design:: for
     details.  Moreover, the syntax is strictly prefix and the naming
     convention 'my-comprehension-ec', ':my-generator' is used
     systematically.


File: vicare-libs.info,  Node: srfi eager-comp rationale,  Next: srfi eager-comp spec,  Prev: srfi eager-comp abstract,  Up: srfi eager-comp

2.22.3 Rationale
----------------

The purpose of this SRFI is to provide a compact notation for many
common cases of loops, in particular those constructing values for
further computation.  The origin of this SRFI is my frustration that
there is no simple way to iterate the list of integers from 0 to N-1.
With this SRFI it is '(list-ec (: i n) i)'.  Refer to the collection of
examples for the reference implementation to understand what it can be
used for, and what it should not be used for.  To give a practically
useful example, the following procedure computes the sorted list of all
prime numbers below a certain bound (you may want to run it yourself to
get an idea of its efficiency):

     ;; primes in {2..n-1} for n >= 1
     (define (eratosthenes n)
       (let ([p? (make-string n #\1)])
         (do-ec (:range k 2 n)
                (if (char=? (string-ref p? k) #\1))
                (:range i (* 2 k) n k)
           (string-set! p? i #\0))
         (list-ec (:range k 2 n)
                  (if (char=? (string-ref p? k) #\1))
           k)))

   Apart from making simple things simple, there is no other paradigm
involved for this SRFI.  In particular, it is not the ambition to
implement the powerful lazy list comprehensions of other functional
programming languages in Scheme.  If you are looking for that you may
want to refer to SRFI-41.  (The usual definition of the stream of all
primes does in fact also use Eratosthenes' sieve method.  It is
instructive to compare.)

   The main focus of the design of this SRFI is portability under R5RS
and modularity for extension.  Portability is achieved by limiting the
features included.  Modularity for generators is achieved by a special
implementation technique using Continuation Passing Style for macros
(which I learned from Richard Kelsey's implementation of "Macros for
writing loops") and by limiting the expressive power of generators.
Modularity for comprehensions requires no additional effort.  As
modularity was a major design goal, I hope many people will find it easy
to define their own comprehensions and generators.  As a starting point
for doing so, I have included several suggestions for extensions.

   *note srfi eager-comp design:: for a detailed motivation of the
design decisions.


File: vicare-libs.info,  Node: srfi eager-comp spec,  Next: srfi eager-comp design,  Prev: srfi eager-comp rationale,  Up: srfi eager-comp

2.22.4 Specification
--------------------

A comprehensions is a hygienic referentially transparent macro in the
sense of R5RS Section 4.3.  The macros extend the '<expression>'-syntax
defined in R5RS Section 7.1.3.  The main syntactic pattern used for
defining a comprehension is '<qualifier>', representing a generator or a
filter.  It is defined in Section "Qualifiers".

   The most important instances of '<qualifier>' are generators.  These
are defined in Section "Generators".  Generators come in three flavors,
as typed generators (':list', ':range', etc.), as the dispatching
generator ':' (pronounced as "run through"), and as combined and
modified generators (':parallel', ':while', ':until').  Most generators
in this SRFI also support an optional index variable counting the values
being generated.

   Finally, it is explained how to add a new application-specific
comprehension, how to add a new application-specific typed generator,
and how to add a new application-specific dispatching generator.  As
this concerns code unknown at the time this is being written, the
explanation should not be taken as a specification in the literal sense.
It rather suggests a convention to follow in order to ensure new
comprehensions and generators blend seamlessly with the ones defined in
this SRFI.

* Menu:

* srfi eager-comp spec comprehensions:: Comprehensions.
* srfi eager-comp spec qualifiers::     Qualifiers.
* srfi eager-comp spec generators::     Generators.
* srfi eager-comp spec suggest::        Suggestions for application
                                        specific extensions.


File: vicare-libs.info,  Node: srfi eager-comp spec comprehensions,  Next: srfi eager-comp spec qualifiers,  Up: srfi eager-comp spec

2.22.4.1 Comprehensions
.......................

 -- Syntax: do-ec QUALIFIER* COMMAND
     Evaluate the COMMAND exactly once for each binding in the sequence
     defined by the qualifiers.  If there are no qualifiers COMMAND is
     evaluated exactly once.  The expression is evaluated for its
     side-effects only.  The result of the comprehension is unspecified.

 -- Syntax: list-ec QUALIFIER* EXPRESSION
     The list of values obtained by evaluating EXPRESSION once for each
     binding in the sequence defined by the qualifiers.  If there are no
     qualifiers the result is the list with the value of EXPRESSION.

 -- Syntax: append-ec QUALIFIER* EXPRESSION
     The list obtained by appending all values of EXPRESSION, which must
     all be lists.  Think of it as:

          (apply append (list-ec QUALIFIER* EXPRESSION))

 -- Syntax: string-ec QUALIFIER* EXPRESSION
     The string of all values of EXPRESSION.  Think of it as:

          (list->string (list-ec QUALIFIER* EXPRESSION))

 -- Syntax: string-append-ec QUALIFIER* EXPRESSION
     The string obtained by appending all values of EXPRESSION, which
     must all be strings.  Think of it as:

          (apply string-append (list-ec QUALIFIER* EXPRESSION))

 -- Syntax: vector-ec QUALIFIER* EXPRESSION
     The vector of all values of EXPRESSION.  Think of it as:

          (list->vector (list-ec QUALIFIER* EXPRESSION))

 -- Syntax: vector-of-length-ec K QUALIFIER* EXPRESSION
     The vector of all values of EXPRESSION, of which there must be
     exactly K.  This comprehension behaves like 'vector-ec' but can be
     implemented more efficiently.

 -- Syntax: sum-ec QUALIFIER* EXPRESSION
     The sum of all values of EXPRESSION.  Think of it as:

          (apply + (list-ec QUALIFIER* EXPRESSION))

 -- Syntax: product-ec QUALIFIER* EXPRESSION
     The product of all values of EXPRESSION.  Think of it as:

          (apply * (list-ec QUALIFIER* EXPRESSION))

 -- Syntax: min-ec QUALIFIER* EXPRESSION
 -- Syntax: max-ec QUALIFIER* EXPRESSION
     The minimum and maximum of all values of EXPRESSION.  The sequence
     of values must be non-empty.  Think of these as

          (apply min (list-ec QUALIFIER* EXPRESSION))
          (apply max (list-ec QUALIFIER* EXPRESSION))

     If you want to return a default value in case the sequence is empty
     you may want to consider:

          (fold3-ec 'infinity QUALIFIER* EXPRESSION min min)

 -- Syntax: any?-ec QUALIFIER* TEST
     Tests whether any value of TEST in the sequence of bindings
     specified by the qualifiers is non-'#f'.  If this is the case, '#t'
     is returned, otherwise '#f'.  If there are no bindings at all, in
     the sequence specified by the qualifiers, then the result is '#f'.
     The enumeration of values stops after the first non-'#f'
     encountered.

 -- Syntax: every?-ec QUALIFIER* TEST
     Tests whether all values of TEST are non-'#f'.  If this is the
     case, '#t' is returned, otherwise '#f'.  If the sequence is empty
     the result is '#t'.  Enumeration stops after the first '#f'.

 -- Syntax: first-ec DEFAULT QUALIFIER* EXPRESSION
 -- Syntax: last-ec DEFAULT QUALIFIER* EXPRESSION
     The first or last value of EXPRESSION in the sequence of bindings
     specified by the qualifiers.  Before enumeration, the result is
     initialized with the value of DEFAULT; so this will be the result
     if the sequence is empty.  Enumeration is terminated in 'first-ec'
     when the first value has been computed.

 -- Syntax: fold-ec X0 QUALIFIER* EXPRESSION F2)
 -- Syntax: fold3-ec X0 QUALIFIER* EXPRESSION F1 F2)
     Reduce the sequence X[0], X[1], ..., X[n-1] of values obtained by
     evaluating EXPRESSION once for each binding as specified by
     QUALIFIER*.  The arguments X0, F2, and F1, all syntactically
     equivalent to EXPRESSION, specify the reduction process.

     The reduction process for 'fold-ec' is defined as follows.  A
     reduction variable X is initialized to the value of X0, and for
     each K in '{0, ..., n-1}' the command:

          (set! x (f2 x[k] x))

     is evaluated.  Finally, X is returned as the value of the
     comprehension.

     The reduction process for 'fold3-ec' is different.  If and only if
     'n = 0', i.e.  the sequence is empty, then X0 is evaluated and
     returned as the value of the comprehension.  Otherwise, a reduction
     variable X is initialized to the value of '(f1 x[0])', and for each
     K in '{1, ..., n-1}' the command:

          (set! x (f2 x[k] x))

     is evaluated.  Finally, X is returned as the value of the
     comprehension.

     As the order of the arguments suggests, X0 is evaluated outside the
     scope of the qualifiers, whereas the reduction expressions
     involving F1 and F2 are inside the scope of the qualifiers (so they
     may depend on any variable introduced by the qualifiers).  Note
     that F2 is evaluated repeatedly, with any side-effect or overhead
     this might have.

     The main purpose of these comprehensions is implementing other
     comprehensions as special cases.  They are generalizations of the
     procedures 'fold' and 'reduce' in the sense of SRFI-1.  (Concerning
     naming and argument order, please refer to the discussion archive
     of SRFI-1, in particular the posting [Folds].)  Note that
     'fold3-ec' is defined such that X0 is only evaluated in case the
     sequence is empty.  This allows raising an error for the empty
     sequence, as in the example definition of 'min-ec' below.

Application-specific comprehension
..................................

An important aspect of this SRFI is a modular mechanism to define
application-specific comprehensions.  To create a new comprehension a
hygienic macro with that name is defined.  The macro transforms the new
comprehension patterns into instances of 'do-ec', which is the most
fundamental eager comprehension, or any other comprehension already
defined.  For example, the following code defines 'list-ec' and 'min-ec'
in terms of 'fold-ec' and 'fold3-ec':

     (define-syntax list-ec
       (syntax-rules ()
         [(list-ec etc1 etc ...)
          (reverse (fold-ec '() etc1 etc ... cons))]))

     (define-syntax min-ec
       (syntax-rules ()
         [(min-ec etc1 etc ...)
          (fold3-ec (min) etc1 etc ... min min)]))

   Note that the pattern 'ETC1 ...' matches the syntax QUALIFIER*
EXPRESSION without separate access to QUALIFIER* and EXPRESSION.  In
order to define a comprehension that does need explicit access to the
EXPRESSION part, the following method is used.

   First, all qualifiers are collected into a nested-qualifier, and then
the "exactly one qualifier" case is implemented.  For illustration, the
following code defines 'fold3-ec' in terms of 'do-ec':

     (define-syntax fold3-ec
       (syntax-rules (nested)
         [(fold3-ec x0 (nested q1 ...) q etc1 etc2 etc3 etc ...)
          (fold3-ec x0 (nested q1 ... q) etc1 etc2 etc3 etc ...)]
         [(fold3-ec x0 q1 q2 etc1 etc2 etc3 etc ...)
          (fold3-ec x0 (nested q1 q2) etc1 etc2 etc3 etc ...)]
         [(fold3-ec x0 expression f1 f2)
          (fold3-ec x0 (nested) expression f1 f2)]

         [(fold3-ec x0 qualifier expression f1 f2)
          (let ([result #f]
                [empty  #t])
            (do-ec qualifier
              (let ([value expression]) ; don't duplicate code
                (if empty
                    (begin
                      (set! result (f1 value))
                      (set! empty #f))
                  (set! result (f2 value result)))))
            (if empty x0 result))]))

   Finally, observe that the newly defined 'fold3-ec' comprehension
inherits all types of qualifiers supported by 'do-ec', including all
application-specific generators; no further definitions are necessary.


File: vicare-libs.info,  Node: srfi eager-comp spec qualifiers,  Next: srfi eager-comp spec generators,  Prev: srfi eager-comp spec comprehensions,  Up: srfi eager-comp spec

2.22.4.2 Qualifiers
...................

This section defines the syntax QUALIFIER.  The nesting of qualifiers is
from left (outer) to right (inner).  In other words, the rightmost
generator spins fastest.  The nesting also defines the scope of the
variables introduced by the generators.  This implies that inner
generators may depend on the variables of outer generators.  The
sequence of enumeration of values is strictly depth first.  These
conventions are illustrated by the first example.

   The syntax QUALIFIER consists of the following alternatives.

 -- Qualifier: GENERATOR
     Enumerate a sequence of bindings of one or more variables.  The
     scope of the variables starts at the generator and extends over all
     subsequent qualifiers and expressions in the comprehension.  *note
     srfi eager-comp spec generators::.

 -- Qualifier: if TEST
     Filters the sequence of bindings by testing if TEST evaluates to
     non-'#f'.  Only for those bindings for which this is the case, the
     subsequent qualifiers of the comprehension are evaluated.

 -- Qualifier: not TEST
 -- Qualifier: and TEST*
 -- Qualifier: or TEST*
     Abbreviated notations for filters of the form '(if (not TEST))',
     '(if (and TEST*))', and '(if (or TEST*))'.  These represent
     frequent cases of filters.

 -- Qualifier: begin SEQUENCE
     Evaluate SEQUENCE, consisting of 'COMMAND* EXPRESSION', once for
     each binding of the variables defined by the previous qualifiers in
     the comprehension.  Using this qualifier, side effects can be
     inserted into the body of a comprehension.

 -- Qualifier: nested QUALIFIER*
     A syntactic construct to group qualifiers.  The meaning of a
     qualifier according to the 'nested' syntax is the same as inserting
     QUALIFIER* into the enclosing comprehension.  This construct can be
     used to reduce comprehensions with several qualifiers into a form
     with exactly one qualifier.


File: vicare-libs.info,  Node: srfi eager-comp spec generators,  Next: srfi eager-comp spec suggest,  Prev: srfi eager-comp spec qualifiers,  Up: srfi eager-comp spec

2.22.4.3 Generators
...................

This section defines the syntax GENERATOR.  Each generator defines a
sequence of bindings through which one or more variables are run.  The
scope of the variables begins after the closing parenthesis of the
generator expression and extends to the end of the comprehension it is
part of.

   The variables defined by the generators are specified using the
syntax:

     <vars> --> <variable1> [ (index <variable2>) ]

where VARIABLE1 runs through the values in the sequence defined by the
generator, and the optional VARIABLE2 is an exact integer-valued index
variable counting the values (starting from 0).  The names of the
variables must be distinct.  The following example illustrates the index
variable:

     (list-ec (: x (index i) "abc")
        (list x i))
     => ((#\a 0) (#\b 1) (#\c 2))

   Unless defined otherwise, all generators make sure that the
expressions provided for their syntactic arguments are evaluated exactly
once, before enumeration begins.  Moreover, it may be assumed that the
generators do not copy the code provided for their arguments, because
that could lead to exponential growth in code size.  Finally, it is
possible to assign a value to the variables defined by a generator, but
the effect of this assignment is unspecified.

   The syntax GENERATOR consists of the following alternatives.

 -- Generator: : VARS ARG1 ARG*
     First the expressions ARG1 ARG* are evaluated into 'A[1]', 'A[2]',
     ..., 'A[n]' and then a global dispatch procedure is used to
     dispatch on the number and types of the arguments and run the
     resulting generator.  Initially (after loading the SRFI), the
     following cases are recognized:

          :list           if      for all i in {1..n}: (list? a[i])

          :string         if      for all i in {1..n}: (string? a[i])

          :vector         if      for all i in {1..n}: (vector? a[i])

          :range          if      n in {1..3} and for all i in {1..n}:
                                  (integer? a[i]) and (exact? a[i])

          :real-range     if      n in {1..3} and for all i in {1..n}:
                                  (real? a[i])

          :char-range     if      n = 2 and for all i in {1, 2}:
                                  (char? a[i])

          :port           if      n in {1, 2} and (input-port? a[1])
                                  and (procedure? a[2])

     The current dispatcher can be retrieved as '(:-dispatch-ref)', a
     new dispatcher D can be installed by '(:-dispatch-set! d)' yielding
     an unspecified result, and a copy of the initial dispatcher can be
     obtained as '(make-initial-:-dispatch)'.  Please refer to the
     section below for recommendation how to add cases to the
     dispatcher.

 -- Generator: :list VARS ARG1 ARG*
 -- Generator: :string VARS ARG1 ARG*
 -- Generator: :vector VARS ARG1 ARG*
     Run through one or more lists, strings, or vectors.  First all
     expressions in ARG1 'ARG*' are evaluated and then all elements of
     the resulting values are enumerated from left to right.  One can
     think of it as first appending all arguments and then enumerating
     the combined object.  As a clarifying example, consider:

          (list-ec (:string c (index i) "a" "b")
            (cons c i))
          => ((#\a . 0)
              (#\b . 1))

 -- Generator: :integers VARS
     Runs through the sequence '0', '1', '2', ... of non-negative
     integers.  This is most useful in combination with ':parallel',
     ':while', and ':until' or with a non-local exit in the body of the
     comprehension.

 -- Generator: :range VARS STOP
 -- Generator: :range VARS START STOP
 -- Generator: :range VARS START STOP STEP
     Runs through a range of exact rational numbers.

     The form '(:range VARS STOP)' evaluates the expression STOP, which
     must result in an exact integer N, and runs through the finite
     sequence '0', '1', '2', ..., 'N-1'.  If N is zero or negative the
     sequence is empty.

     The form '(:range VARS START STOP)' evaluates the expressions START
     and STOP, which must result in exact integers A and B, and runs
     through the finite sequence A, 'A+1', 'A+2', ..., 'B-1'.  If B is
     less or equal A then the sequence is empty.

     The form '(:range VARS START STOP STEP)' first evaluates the
     expressions START, STOP, and STEP, which must result in exact
     integers A, B, and S such that S is unequal to zero.  Then the
     sequence A, 'A + S', 'A + 2 S', ..., 'A + (N-1) S' is enumerated
     where 'N = ceil((B-A)/S)'.  In other words, the sequence starts at
     A, increments by S, and stops when the next value would reach or
     cross B.  If N is zero or negative the sequence is empty.

 -- Generator: :real-range VARS STOP
 -- Generator: :real-range VARS START STOP
 -- Generator: :real-range VARS START STOP STEP
     Runs through a range of real numbers using an explicit index
     variable.  This form of range enumeration avoids accumulation of
     rounding errors and is the one to use if any of the numbers
     defining the range is inexact, not an integer, or a bignum of large
     magnitude.

     Providing default value '0' for START and '1' for STEP, the
     generator first evaluates START, STOP, and STEP, which must result
     in reals A, B, and S such that 'N = (B-A)/S' is also representable
     as a real.  Then the sequence '0', '1', '2', ... is enumerated
     while the current value I is less than N, and the variable in VARS
     is bound to the value 'A + I S'.  If any of the values A, B, or S
     is non-exact then all values in the sequence are non-exact.

 -- Generator: :char-range VARS MIN MAX
     Run through a range of characters.  First MIN and MAX are
     evaluated, which must result in two characters A and B.  Then the
     sequence of characters A, 'A+1', 'A+2', ..., B is enumerated in the
     order defined by 'char<=?' in the sense of R5RS Section 6.3.4.  If
     B is smaller than A then the sequence is empty.  (Note that B is
     included in the sequence.)

 -- Generator: :port VARS PORT
 -- Generator: :port VARS PORT READ-PROC
     Read from the port until the eof-object is read.  Providing the
     default read for READ-PROC, the generator first evaluates PORT and
     READ-PROC, which must result in an input port P and a procedure R.
     Then the variable is run through the sequence obtained by '(R P)'
     while the result does not satisfy 'eof-object?'.

 -- Generator: :dispatched VARS DISPATCH ARG1 ARG*
     Runs the variables through a sequence defined by DISPATCH and ARG1
     ARG*.  The purpose of ':dispatched' is implementing dispatched
     generators, in particular the predefined dispatching generator ':'.

     The working of ':dispatched' is as follows.  First DISPATCH and
     ARG1 ARG* are evaluated, resulting in a procedure D (the
     "dispatcher") and the values 'A[1]', 'A[2]', ..., 'A[n]'.  Then:

          (d (list a[1] a[2] ... a[n]))

     is evaluated, resulting in a value G.  If G is not a procedure then
     the dispatcher did not recognize the argument list and an error is
     raised.  Otherwise the "generator procedure" G is used to run VARS
     through a sequence of values.

     The sequence defined by G is obtained by repeated evaluation of '(G
     EMPTY)' until the result is EMPTY.  In other words, G indicates the
     end of the sequence by returning its only argument, for which the
     caller has provided an object distinct from anything G can produce.
     (Generator procedures are state based, they are no such noble
     things as streams in the sense of SRFI-41.)

     The definition of dispatchers is greatly simplified by the macro
     ':generator-proc' that constructs a generator procedure from a
     typed generator.  Let '(G VAR ARG1 ARG ...)' be an instance of the
     GENERATOR syntax, for example an application-specific typed
     generator, with a single variable VAR and no index variable.  Then:

          (:generator-proc (g arg1 arg ...))
          => g

     where the generator procedure G runs through the list:

          (list-ec (g var arg1 arg ...) var)

     In order to define a new dispatching generator (say ':my') first a
     dispatching procedure (say ':my-dispatch') is defined.  The
     dispatcher will be called with a single (!)  argument containing
     the list of all values to dispatch on.  To enable informative error
     messages, the dispatcher should return a descriptive object (e.g.
     a symbol for the module name) when it is called with the empty
     list.  Otherwise (if there is at least one value to dispatch on),
     the dispatcher must either return a generator procedure or '#f'
     (which means: no interest).  As an example, the following skeleton
     code defines a dispatcher similar to the initial dispatcher of ':':

          (define (:my-dispatch args)
            (case (length args)
              [(0) 'SRFI-NN]
              [(1) (let ([a1 (car args)])
                     (cond
                      [(list? a1)
                       (:generator-proc (:list a1))]
                      [(string? a1)
                       (:generator-proc (:string a1))]
                      ...more unary cases...
                      [else
                       #f]))]
              [(2) (let ([a1 (car args)]
                         [a2 (cadr args)])
                     (cond
                      [(and (list? a1) (list? a2))
                       (:generator-proc (:list a1 a2))]
                      ...more binary cases...
                      [else
                       #f]))]
              ...more arity cases...
              [else
               (cond
                [(every?-ec (:list a args) (list? a))
                 (:generator-proc (:list (apply append args)))]
                ...more large variable arity cases...
                [else
                 #f])]))

     Once the dispatcher has been defined, the following macro
     implements the new dispatching generator:

          (define-syntax :my
            (syntax-rules (index)
              [(:my cc var (index i) arg1 arg ...)
               (:dispatched cc var (index i) :my-dispatch arg1 arg ...)]
              [(:my cc var arg1 arg ...)
               (:dispatched cc var :my-dispatch arg1 arg ...)]))

     This method of extension yields complete control of the dispatching
     process.  Other modules can only add cases to ':my' if they have
     access to ':my-dispatch'.

     Extending the predefined dispatched generator.  An alternative to
     adding a new dispatched generator is to extend the predefined
     generator ':'.  Technically, extending ':' means installing a new
     global dispatching procedure using ':-dispatch-set!' as described
     above.  In most cases, however, the already installed dispatcher
     should be extended by new cases.  The following procedure is a
     utility for doing so:

          (dispatch-union d1 d2)
          => d

     where the new dispatcher D recognizes the union of the cases
     recognized by the dispatchers D1 and D2.  The new dispatcher always
     tries both component dispatchers and raises an error in case of
     conflict.  The identification returned by '(d)' is the
     concatenation of the component identifications '(d1)' and '(d2)',
     enclosed in lists if necessary.  For illustration, consider the
     following code:

          (define (example-dispatch args)
            (cond
             [(null? args)
              'example]
             [(and (= (length args) 1) (symbol? (car args)) )
              (:generator-proc (:string (symbol->string (car args))))]
             [else
              #f]))

          (:-dispatch-set! (dispatch-union (:-dispatch-ref) example-dispatch))

     After evaluation of this code, the following example will work:

          (list-ec (: c 'abc)
            c)
          => (#\a #\b #\c)

     Adding cases to ':' is particularly useful for frequent cases of
     interactive input.  Be warned, however, that the advantage of
     global extension also carries the danger of conflicts, unexpected
     side-effects, and slow dispatching.

 -- Generator: :do (LB*) NE1? (LS*)
 -- Generator: :do (let (OB*) OC*) (LB*) NE1? (let (IB*) IC*) NE2? (LS*)
     Defines a generator in terms of a named-'let', optionally decorated
     with inner and outer lets.  This generator is for defining other
     generators.  (In fact, the reference implementation transforms any
     other generator into an instance of fully decorated ':do'.)

     The generator is a compromise between expressive power (more
     flexible loops) and fixed structure (necessary for merging and
     modifying generators).

     In the fully decorated form, the syntactic variables OB (outer
     binding), OC (outer command), LB (loop binding), NE1? (not-end1?),
     IB (inner binding), IC (inner command), NE2? (not-end2?), and LS
     (loop step) define the following loop skeleton:

          (let (OB*)
            OC*
            (let loop (LB*)
              (if NE1?
                  (let (IB*)
                    IC*
                    payload
                    (if NE2?
                        (loop LS*) )))))

     where 'OC*' and 'IC*' are syntactically equivalent to COMMAND*,
     i.e.  they do not begin with a DEFINITION.  The latter requirement
     allows the code generator to produce more efficient code for
     special cases by removing empty 'let'-expressions altogether.

 -- Generator: :let VARS EXPRESSION
     Run through the sequence consisting of the value of EXPRESSION,
     only.  This is the same as:

          (:list VARS (list EXPRESSION))

     If an index variable is specified, its value is '0'.  The ':let'
     generator can be used to introduce an intermediate variable
     depending on outer generators.

 -- Generator: :parallel GENERATOR*
     Run several generators in parallel.  This means that the next
     binding in the sequence is obtained by advancing each generator in
     'GENERATOR*' by one step.  The parallel generator terminates when
     any of its component generators terminate.  The generators share a
     common scope for the variables they introduce.  This implies that
     the names of the variables introduced by the various generators
     must be distinct.

 -- Generator: :while GENERATOR EXPRESSION
     Run GENERATOR while EXPRESSION evaluates to non-'#f'.  The guarding
     expression is included in the scope of the variables introduced by
     the generator.

     Note the distinction between the filter 'if' and the modified
     generator expressed by ':while'.

 -- Generator: :until GENERATOR EXPRESSION
     Run GENERATOR until after EXPRESSION has evaluated to non-'#f'.
     The guarding expression is included in the scope of the variables
     introduced by the generator.

     Note the distinction between ':while', stopping at a certain
     condition, and ':until', stopping after a certain condition has
     occurred.  The latter implies that the binding that has triggered
     termination has been processed by the comprehension.

Application specific typed generator
....................................

An important aspect of this SRFI is a modular mechanism to define new
typed generators.  To define a new typed generator a hygienic
referentially transparent macro of the same name is defined to transform
the generator pattern into an instance of the ':do-generator'.  The
extension is fully modular, meaning that no other macro has to be
modified to add the new generator.  This is achieved by defining the new
macro in Continuation Passing Style.

   Technically, this works as follows.  Assume the generator syntax:

     (:mygen VAR ARG)

is to be implemented, for example running the variable VAR through the
list '(reverse ARG)'.  The following definition implements ':mygen' in
terms of ':list' using the additional syntactic variable CC (read
current continuation):

     (define-syntax :mygen
       (syntax-rules ()
         [(:mygen cc var arg)
          (:list cc var (reverse arg))]))

   After this definition, any comprehension will accept the ':mygen'
generator and produce the proper code for it.  This works as follows.
When a comprehension sees something of the form '(G ARG ...)' in the
position of a QUALIFIER then it will transform the entire comprehension
into:

     (G (continue ...) ARG ...)

   This effectively "transfers control" to the macro G, for example
':mygen'.  The macro G has full control of the transformation, but
eventually it should transform the expression into:

     (:do (continue ...)  etc ...)

   In the ':mygen' example this is done by the ':list-macro'.  The macro
':do' finally transforms into:

     (continue ... (:do etc ...))

   As 'continue' has been chosen by the macro implementing the
comprehension, it can regain control and proceed with other qualifiers.

   In order to ensure consistency of new generators with the ones
defined in this SRFI, a few conventions are in order.  Firstly, the
generator patterns begin with one or more variables followed by
arguments defining the sequence.  Secondly, each generator except ':do'
can handle an optional index variable.  This is most easily implemented
using ':parallel' together with ':integers'.  In case the payload
generator needs an index anyhow (e.g.  ':vector') it is more efficient
to add an index variable if none is given and to implement the indexed
case.  Finally, make sure that no syntactic variable of the generator
pattern ever gets duplicated in the code (to avoid exponential code size
in nested application), and introduce sufficient intermediate variables
to make sure expressions are evaluated at the correct time.


File: vicare-libs.info,  Node: srfi eager-comp spec suggest,  Prev: srfi eager-comp spec generators,  Up: srfi eager-comp spec

2.22.4.4 Suggestions for application specific extensions
........................................................

Arrays in the sense of SRFI-25
..............................

In order to create an array from a sequence of elements, a comprehension
with the following syntax would be useful:

     (array-ec SHAPE QUALIFIER* EXPRESSION)

   The comprehension constructs a new array of the given shape by
filling it row-major with the sequence of elements as specified by the
qualifiers.  On the generator side, it would be most useful to have a
generator of the form:

     (:array VARS ARG)

running through the elements of the array in row-major.  For the
optional index variable, the extension '(index K1 K*)' could be defined
where K1 'K*' are variable names indexing the various dimensions.

Random Numbers in the sense of SRFI-27
......................................

In order to create a vector or list of random numbers, it would be
convenient to have generators of the following form:

     (:random-integer [ RANGE [ NUMBER ] ] )
     (:random-real    [ NUMBER ] )

where RANGE (default 2) indicates the range of the integers and NUMBER
(default infinity) specifies how many elements are to be generated.
Derived from these basic generators, one could define several other
generators for other distributions (e.g.  Gaussian).

Bitstrings in the sense of SRFI-33
..................................

As eager comprehensions are efficient, they can be useful for operations
involving strings of bits.  It could be useful to have the following
comprehension:

     (bitwise-ec QUALIFIER* EXPRESSION)

which constructs an integer from bits obtained as values of EXPRESSION
in the ordering defined by SRFI-33.  In other words, if the sequence of
values is 'X[0]', 'X[1]', ..., 'X[n-1]' then the result is:

     x[0] + x[1] 2 + ... + x[n-1] 2^(n-1)

   On the generator side, a generator of the form:

     (:bitwise VARS ARG1 ARG*)

runs through the sequence of bits obtained by appending the binary
digits of the integers ARG1 ARG*.

Streams in the sense of SRFI-41
...............................

It is possible to "lazify" the eager comprehension 'list-ec',
constructing a stream in the sense of SRFI-41.  Clearly, such a
comprehension ('stream-ec') is not eager at all since it only runs the
loops when results are requested.  It is also possible to define a
':stream' generator with the same API as ':list' but running through
streams instead of lists.

   For what is worth, the file 'srfi40-ec.scm' implements ':stream' and
'stream-ec' and gives an example.  The implementation makes substantial
use of 'call-with-current-continuation' to run the loop only when
necessary.  In some implementations of Scheme this may involve
considerable overhead.

Reading Text Files
..................

Eager comprehensions can also be used to process files.  However, bear
in mind that an eager comprehension wants to read and process the entire
file right away.  Nevertheless, these generators would be useful for
reading through the lines of a file or through the characters of a file:

     (:lines-of-file VARS FILE)
     (:chars-of-file VARS [ (line VARIABLE1) ] [ (column VARIABLE2) ] FILE)

   Here FILE is either an input port or a string interpreted as a
filename.  In a similar fashion, generators reading from sockets defined
by URLs or other communication facilities could be defined.

The Scheme shell Scsh
.....................

In the Scheme-shell, Scsh, it could be useful to have certain
comprehensions and generators.  Candidates for comprehensions are
'begin-ec', '|-ec', '||-ec', and '&&-ec'.

   Concerning generators, it might be useful to have ':directory'
running through the records of a directory, and maybe a sophisticated
':file-match-generator' could enumerate file record in a directory
structure.  Optional variables of the generators could give convenient
access frequent components of the file records (e.g.  the filename).
Another candidate is ':env' to run through the environment associations.
It is left to other authors and other SRFIs to define a useful set of
comprehensions and generators for Scsh.


File: vicare-libs.info,  Node: srfi eager-comp design,  Next: srfi eager-comp ack,  Prev: srfi eager-comp spec,  Up: srfi eager-comp

2.22.5 Design rationale
-----------------------

What is the difference between eager and lazy comprehensions?
.............................................................

A lazy comprehension, for example 'stream-of' in the sense of SRFI-41,
constructs an object representing a sequence of values.  They are
actually produced only at the time they are needed.  An eager
comprehension, on the other hand, is an instruction to run through a
certain sequence of values and do something with it, for example as in
'do-ec'.  In other words, it is nothing more sophisticated than a loop,
potentially with a more convenient notation.  This also explains why
'stream-of' is the most fundamental lazy comprehension, and all others
can be formulated in terms of it, whereas the most fundamental eager
comprehension is 'do-ec'.

Why the '[OUTER .. INNER | EXPR]' order of qualifiers?
......................................................

In principle, there are six possible orders in which the qualifiers and
the expression of a comprehension can be written.  We denote the
different conventions with a pattern in which EXPR denotes the
expression over which the comprehension ranges, INNER denotes the
generator spinning fastest, and OUTER denotes the generator spinning
slowest.  For example, Haskell and Python use:

     [EXPR | OUTER .. INNER]

   Probably with sufficient persistence, instances for any of the
conventions can be found on the Internet.  In addition, there is the
common mathematical notation '{f(x) | x in X}'.

   It is important to understand that the notational convention does not
only determine the order of enumeration but also the scope of the
variables introduced by the generators.  The scope of INNER includes
EXPR, and the scope of OUTER should include INNER to allow INNER
generators to depend on OUTER generators.  Eventually, the choice for a
particular syntactic convention is largely a matter of personal
preferences.  However, there are a few considerations that went into the
choice made for this SRFI:

  1. The mathematical notation is universally known and widely used.
     However, the mathematical notation denotes a set of comprehensions
     in which the order of the qualifiers is either irrelevant or must
     be deduced from the context.  For the purpose of eager
     comprehensions as a programming language construct, the order does
     matter and a simple convention is a plus.  For these reasons, the
     mathematical notation as such is undesirable, but its widespread
     use is in favor of:

          [EXPR | INNER .. OUTER]

     and:

          [EXPR | OUTER .. INNER]

  2. It is desirable to have the scope of the variables increase into
     one direction, as in:

          [EXPR | INNER .. OUTER]

     and:

          [OUTER .. INNER | EXPR]

     and not change direction, as in:

          [EXPR | OUTER .. INNER]

     where EXPR is in the scope of INNER but OUTER is not.  This is even
     more important if the syntax in Scheme does not explicitly contain
     the '|' separator.

  3. More complicated comprehensions with several nested generators
     eventually look like nested loops and Scheme always introduces them
     OUTER ... INNER as in 'do' and named 'let'.  This is in favor of:

          [EXPR | OUTER .. INNER]

     and:

          [OUTER .. INNER | EXPR]

     Shorter comprehensions may look more naturally the other way
     around.

   Regarding these contradicting preferences, I regard linearity in
scoping (point 2) most important, followed by readability for more
complicated comprehensions (point 3).  This leads to:

     [OUTER .. INNER | EXPR]

   An example in Scheme syntax is:

     (list-ec (: x 10) (: y x) (f x y))

which looks acceptable to me even without similarity to the mathematical
notation.  As a downside, the convention clashes with other the
convention used in other languages (e.g.  Haskell and Python).

You forgot _choose your favorite here_-'ec!'
............................................

I tried to construct a reasonably useful set of tools according to what
R5RS specifies.  Nevertheless, the choice about what to include and what
to leave out is a matter of personal preference.

   When "packing the toolbox" I went for travelling light; this SRFI
does not include everything imaginable or even everything useful.  I
oriented myself at the standard procedures of R5RS, with a few omissions
and additions.  A notable omission are 'gcd-ec' and 'lcm-ec' because
they are one-liners, and more severely, of questionable value in
practice.  Notable additions are 'fold-ec' and 'fold3-ec', providing a
mechanism to define lots of useful one-liners.  The other notable
addition is 'first-ec', which is the fundamental "early stopping"
comprehension.  It is used to define 'any?-ec' and 'every?-ec' which are
among the most frequent comprehensions.

   Concerning the generators, the same principle has been used.
Additions include ':range' and friends because they are universally
needed, and ':dispatched' which is primarily intended for implementing
':'.

Why is the order of enumeration specified?
..........................................

For the purpose of this SRFI, every generator runs through its sequence
of bindings in a well specified order, and nested generators run through
the Cartesian product in the order of nested loops.  The purpose of this
definition is making the sequence as easily predictable as possible.  On
the other hand, many mechanisms for lazy comprehensions do not specify
the order in which the elements are enumerated.  When it comes to
infinite streams, this has the great advantage that a comprehension may
interleave an inner and an outer enumeration, a method also known as
"dove-tailing" or "diagonalizing".  Interleaving ensures that any value
of the resulting stream is produced after a finite amount of time, even
if one or more inner streams are infinite.

Why both typed and dispatching generators?
..........................................

The reason for typed generators is runtime efficiency.  In fact, the
code produced by ':range' and others will run as fast as a hand-coded
'do' loop.  The primary purpose of the dispatching generator is
convenience.  It comes at the price of reduced runtime performance, both
for loop iteration and startup.

Why the 'something-ec' and ':type' naming?
..........................................

The purpose of the ':type' convention is to keep many common
comprehensions down to one-liners.  In my opinion, the fundamental
nature of eager comprehensions justifies a single character naming
convention.  The 'something-ec' convention is primarily intended to stay
away from the widely used 'something-of'.  It reduces confusion and
conflict with related mechanisms.

Why combine variable binding and sequence definition?
.....................................................

The generators of this SRFI do two different things with a single
syntactic construct: They define a sequence of values to enumerate and
they specify a variable (within a certain scope) to run through that
sequence.  An alternative is to separate the two, for example as it has
been done in SRFI-41.

   The reason for combining sequence definition and enumeration for the
purpose of this SRFI is threefold.  Firstly, sequences of values are not
explicitly represented as objects in the typed generators; the
generators merely manipulate an internal state.  Secondly, this SRFI
aims at a most concise notation for common comprehensions and reduces
syntax to the naked minimum.  Thirdly, this SRFI aims at the highest
possible performance for typed generators, which is achieved if the
state being manipulated is represented by the loop variable itself.

Why is '(: VARS)' illegal?
..........................

It is reasonable and easy to define:

     (: VARS)

as:

     (:integers VARS)

enumerating the non-negative integers.  However, it turned out that a
frequent mistake in using the eager comprehensions is to forget either
the variable or an argument for the enumeration.  As this would lead to
an infinite loop (not always equally pleasant in interactive sessions),
it is not allowed.

Why is there no ':sequential'?
..............................

Just like ':parallel' enumerates generators in parallel, a ':sequential'
generator could enumerate a concatenation of several generator, starting
the next one when the previous has finished.  The reason for not having
such a qualifier is that the generators should use all the same variable
name and there is no hygienic and referentially transparent way of
enforcing this (or even knowing the variable).

Why is there no general 'let' qualifier?
........................................

It is easy to add 'let', 'let*', and 'letrec' as cases to QUALIFIER.
This would allow more sophisticated local variables and expressions than
possible with:

     (:let VARS EXPRESSION)

and:

     (begin SEQUENCE*)

   In particular, a local DEFINITION in the sense of R5RS Section 7.1.5
would be possible.

   There are two reasons for not including 'let' and friends as
qualifiers.  The first reason concerns readability.  A qualifier of the
form:

     (let (BINDING-SPEC*) BODY)

only makes sense if the scope of the new variables ends at the end of
the comprehension, and not already after BODY.  The similarity with
ordinary 'let' expressions would be very confusing.  The second reason
concerns the design rationale.  If sophisticated 'let' qualifiers
involving recursion or local definitions are needed, it is likely that
eager comprehensions are being overused.  In that case it might be
better to define a procedure for the task.  So including an invitation
to overuse the mechanism would be a serious violation of the Keep It
Simple and Stupid principle.

Why is there no ':nested' generator?
....................................

The specification above defines nested as a qualifier but ':parallel' as
a generator.  In particular, this makes it impossible to make parallel
generators from nested ones.

   This design simply reflects an implementability limitation.  All
component generators of ':parallel' are transformed into
':do-generators' and these can be merged into a parallel generator.
However, nested generators cannot be merged easily without losing the
type of the generator, which would seriously hurt modularity and
performance.

Is 'any?-ec' eager?
...................

Yes, it is still eager because it immediately starts to run through the
sequence.

   In fact, the reference implementation makes sure 'first-ec',
'any?-ec', and 'every?-ec' execute efficiently so they can be used
conveniently as in:

     (every?-ec (:list x my-list) (pred? x))

Why this whole ':dispatched' business?
......................................

It is specified above that the dispatching generator, called ':', is
just a special case of ':dispatched' using a global dispatching
procedure.  Alternatively, a simple fixed global mechanism to extend ':'
could have been used.  This is much simpler but does not support the
definition of new dispatched generators.

   The purpose of ':dispatched' and its utilities (':generator-proc' and
'dispatch-union') is the following.  Assume ':' is to be used inside a
module but it is essential that no other module can spoil it, e.g.  by
installing a very slow dispatcher.  The recommended way to proceed in
this case is to define a local copy of the original dispatching
generator ':', for example with the following code:

     (define :my-dispatch
       (make-initial-:-dispatch))

     (define-syntax :my
       (syntax-rules (index)
         [(:my cc var (index i) arg1 arg ...)
          (:dispatched cc var (index i) :my-dispatch arg1 arg ...)]
         [(:my cc var arg1 arg ...)
          (:dispatched cc var :my-dispatch arg1 arg ...)]))

and to use the new generator ':my' instead of ':'.

   An alternative for the dispatching mechanism as defined in this SRFI
is the use of parameter objects in the sense of SRFI-39.  The
dispatching generator would then access a dynamically scoped variable to
find the dispatcher, allowing full control over dispatching.  However,
this approach does not solve the dilemma that it is sometimes useful
that ':' is global and sometimes undesired.  The approach specified for
this SRFI addresses this dilemma by offering options.

   Another alternative for dealing with the dispatching problem is
adding an optional argument to the syntax of ':' through which the
dispatcher can be passed explicitly.  However, as ':' has variable arity
and the identifier for the variable cannot be distinguished from any
value for a dispatcher, this is syntactically problematic.

Why is there no local mechanism for adding to ':'?
..................................................

According to R5RS Section 7.1.6 macros can only be defined at the level
of the '<program>' syntax.  This implies that the scope of typed
generators cannot easily be limited to local scopes.  As typed and
dispatched generators go together, there is also no strong need for a
limited scope of dispatched generators either.  Furthermore, locally
extendable dispatchers are another major headache to those trying to
understand other people's code.

Why are dispatchers unary?
..........................

As defined in ':dispatched', a dispatching procedure is called with a
single argument being the list of values to dispatch on.  An alternative
is to apply the dispatcher to the list of values to dispatch on, which
would be more natural in Scheme.

   The reason for not using apply is a minor improvement in efficiency.
Every time APPLY is used on a procedure of variable arity, an object
containing the argument list is allocated on the heap.  As a dispatcher
may call many other dispatchers, this will add to the overhead of
dispatching, which is relevant in inner loops.

Why are there two fold comprehensions?
......................................

The reason for having two fold comprehensions ('fold-ec' and 'fold3-ec')
is efficiency.

   Clearly, the more general construction is 'fold3-ec' as it allows
individual treatment of the empty sequence case and the singleton
sequence case.  However, this comes at the price of more book-keeping as
can be seen from the implementation example.  As the overhead is located
within inner loops, it makes sense to define another fold comprehension
for the case where the added flexibility is not needed.  This is
'fold-ec'.

   The names 'fold-ec' and 'fold3-ec' have been chosen for the
comprehensions in order to stay clear any other 'fold' that may be
around.

Why is ':char-range' not defined by 'integer->char'?
....................................................

The definition of ':char-range' specifies a sequence of adjacent
characters ordered by 'char<=?'.  The reason for not using
'char->integer' and 'integer->char' is the fact that R5RS Section 6.3.4
leaves it to the implementation whether the integers representing
characters are consecutive or not.  In effect, this underspecification
is inherited by ':char-range'.


File: vicare-libs.info,  Node: srfi eager-comp ack,  Next: srfi eager-comp references,  Prev: srfi eager-comp design,  Up: srfi eager-comp

2.22.6 Related work and acknowledgements
----------------------------------------

Several other proposals related to the mechanism specified here exists.
The following mechanisms are made for and in Scheme (or at least a
specific dialect thereof).

   First of all, the report R5RS of Scheme itself defines two constructs
for writing loops: 'do' and named 'let'.  Both constructs express a
single loop (not nested), possibly with several variables running in
parallel, based on explicit manipulation of the state variables.  For
example:

     (do ([x 0 (+ x 1)])
         ([= x 10])
       (display x))

explicitly mentions how to obtain the next binding of X.

   Richard Kelsey's "Macros for writing loops", are an extension to
Scheme48 to simplify the formulation of loops.  The basic idea is to
stick with a 'do'-like syntax for more sophisticated loop constructs,
not necessarily manipulating a state variable explicitly.  For example:

     (list* x '(1 2 3))

expresses an enumeration of the variable X through the list '(1 2 3)'
without explicit state manipulation.  The iteration constructs of MWL,
'named' 'iterate' and 'reduce', express a single (not nested) loop
('iterate') or comprehension ('reduce') with any number of parallel
enumerations.

   A most important feature of the MWL-concept is a modular way to add
sequence types (generators).  In effect, the addition of a new sequence
type does not require a modification of the existing macros.  This is
achieved by carefully limiting the expressive power of the loop
constructs and by using the macros in Continuation Passing Style to call
other macros.  The MWL-concept, and its implementation, were most
influential for this SRFI.

   Another related mechanism is the library of streams recently
submitted by Phil L. Bewig as SRFI-40 (superseded by SRFI-41).  The
library contains a data type to represent even streams (both car and cdr
potentially delayed) and defines procedures for manipulating these
streams.  Moreover, the macro 'stream-of' defines a lazy comprehension
resulting in the stream of values of an expression subject to generators
and filters.

   A fixed set of generators (lists, vector, string, port, and
naturally: streams) is supported; extending the list of generators
requires changing 'stream-of'.  Nevertheless, modularity is high since
it is easy to define a procedure producing a stream object and this can
be used for enumeration.  The order of enumeration is left unspecified
to allow interleaving of generators (also refer to above).

   Before Phil submitted his SRFIs, we had a short discussion in which
we clarified the semantic and syntactic differences of our approaches.
It turned out that the mechanisms are sufficiently different not to
unify them.  The most important difference is the design rationale: Phil
created his library to support the stream paradigm in Scheme, inspired
by the work done for Haskell and other lazy languages, and intrigued by
the beauty of programming with infinite streams.  My work only aims at a
convenient way of expressing frequent patterns of loops in a compact
way.  For what it is worth, section SRFI-40-ec contains a suggestion for
extending the eager comprehension mechanism for SRFI-41 streams.

   Phil's work on streams and lazy comprehensions in Scheme triggered
Eli Barzilay to implement a library of eager comprehensions for
PLT-Scheme.  The mechanism implemented by Eli is in essence very similar
to the one proposed in this SRFI, and the two efforts have been
independent until recently.  Syntactically, Eli uses infix operators for
generators, whereas this SRFI is purely prefix, and Eli uses the:

     [EXPR | OUTER .. INNER]

convention for nesting, whereas this SRFI uses the:

     [outer .. inner | expr]

convention.  Semantically, Eli's mechanism defines more flexible loops
than this SRFI.  Comprehensions are regarded as generalized collection
processes like 'fold' and 'reduce'.  The mechanism in this SRFI is more
restricted with respect to control flow (there is no general 'while')
and more extensive with respect to generators and comprehensions.
Despite the strong conceptual similarity, the design rationales are
different.  This SRFI focuses on portability and modular extension,
whatever that may cost in terms of expressive power.

   Finally, I would like to thank Mike Sperber for his encouragement to
proceed with the SRFI and for several discussions of the matter.  In
particular, the dispatching mechanism evolved rapidly during discussions
with Mike.


File: vicare-libs.info,  Node: srfi eager-comp references,  Prev: srfi eager-comp ack,  Up: srfi eager-comp

2.22.7 References
-----------------

_Revised(5) Report on the Algorithmic Language Scheme_.  Richard Kelsey,
William Clinger, and Jonathan Rees (eds.).  February 20, 1998.
Higher-Order and Symbolic Computation, Vol.  11, No.  1, September 1998.

            <http://schemers.org/Documents/Standards/R5RS/>

_The Incomplete Scheme48 Reference Manual for Release 0.57 (July 15,
2001)_.  Richard Kelsey, Jonathan Rees.  Section "Macros for writing
loops".

            <http://s48.org/0.57/manual/s48manual_49.html>

_SRFI-1 List library_.  Olin Shivers.

                  <http://srfi.schemers.org/srfi-1/>

_SRFI-23 Error reporting mechanism_.  Stephan Houben:.

                  <http://srfi.schemers.org/srfi-23/>

_SRFI-25 Multi-dimensional Array Primitives_.  Jussi Piitulainen.

                  <http://srfi.schemers.org/srfi-25/>

_SRFI-27 Sources of Random Bits_.  Sebastian Egner.

                  <http://srfi.schemers.org/srfi-27/>

_SRFI-33 Integer Bitwise-operation Library_.  Olin Shivers.

                  <http://srfi.schemers.org/srfi-33/>

_SRFI-39 Parameter objects_.  Marc Feeley.

                  <http://srfi.schemers.org/srfi-39/>

_SRFI-41 A Library of Streams_.  Philip L. Bewig.

                  <http://srfi.schemers.org/srfi-41/>

_Documentation for 'misc.ss'_.  Eli Barzilay.  2002.

     <http://www.cs.cornell.edu/eli/Swindle/misc-doc.html#collect>

_Folds and reductions_.  John David Stone.  Posting in relation to
SRFI-1 on 8-Jan-1999.

     <http://srfi.schemers.org/srfi-1/mail-archive/msg00021.html>

_The Haskell 98 Report 1 February 1999_.  Simon L. Peyton Jones, John
Hughes.  Section 3.11 "List Comprehensions".

       <http://www.haskell.org/onlinereport/exps.html#sect3.11>

_Python Reference Manual_.  Guido van Rossum, Fred L. Drake Jr.  (eds.).
Section 5.2.4 "List displays".  Release 2.2, December 21, 2001.

              <http://python.org/doc/2.2/ref/lists.html>

_Structure and Interpretation of Computer Programs_.  Harold Abelson,
Gerald J. Sussman, Julie Sussman.  MIT Press, 1985.

                    <http://mitpress.mit.edu/sicp/>

_List Comprehensions (Chapter 7)_.  Philip Wadler.  In: Simon L. Peyton
Jones: The Implementation of Functional Programming Languages.  Prentice
Hall, 1987.

_Scheme48 Release 0.57 (July 15, 2001)_.  Richard Kelsey, Jonathan Rees.

                           <http://s48.org/>

_SCM Scheme Implementation.  Version 5d7 (November 27, 2002)_.  Aubrey
Jaffer.

            <http://www.swiss.ai.mit.edu/~jaffer/SCM.html>

_PLT Scheme, DrScheme Version 203_.  PLT People.

                     <http://www.plt-scheme.org/>

_Scsh Reference Manual_.  Olin Shivers, Brian D. Carlstrom, Martin
Gasbichler, Mike Sperber.  For scsh release 0.6.3.

                          <http://scsh.net/>


File: vicare-libs.info,  Node: srfi vectors,  Next: srfi lazy,  Prev: srfi eager-comp,  Up: srfi

2.23 SRFI-43 vector library
===========================

The library '(srfi :43)' is by Taylor Campbell as the reference
implementation for SRFI-43; see:

            <http://srfi.schemers.org/srfi-43/srfi-43.html>

for more details.

* Menu:

* srfi vector license::    Original document license.
* srfi vector abstract::   Abstract.
* srfi vector rationale::  Rationale.
* srfi vector spec::       Specification.
* srfi vector ack::        Acknowledgements.
* srfi vector references:: References.


File: vicare-libs.info,  Node: srfi vector license,  Next: srfi vector abstract,  Up: srfi vectors

2.23.1 Original document license
--------------------------------

Copyright (C) 2003 Taylor Campbell.  All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi vector abstract,  Next: srfi vector rationale,  Prev: srfi vector license,  Up: srfi vectors

2.23.2 Abstract
---------------

This SRFI proposes a comprehensive and complete library of vector
operations accompanied by a freely available and complete reference
implementation.  The reference implementation is unencumbered by
copyright, and useable with no modifications on any Scheme system that
is R5RS-compliant.  It also provides several hooks for
implementation-specific optimization as well.

   Because this SRFI is more of a library or module specification than a
request for additions to readers or any other internal implementation
detail, in an implementation that supports a module or structure or
package or library or unit (et cetera) systems, these procedures should
be contained in a module/structure/package/library/unit called
'vector-lib'.


File: vicare-libs.info,  Node: srfi vector rationale,  Next: srfi vector spec,  Prev: srfi vector abstract,  Up: srfi vectors

2.23.3 Rationale
----------------

R5RS provides very few list-processing procedures, for which reason
SRFI-1 exists.  However, R5RS provides even fewer vector operations;
while it provides mapping, appending, et cetera operations for lists, it
specifies only nine vector manipulation operations:

     vector?         make-vector     vector
     vector-length   vector-ref      vector-set!
     vector->list    list->vector    vector-fill!

   Many Scheme implementations provide several vector operations beyond
the minuscule set that R5RS defines (the typical 'vector-append',
'vector-map', et cetera), but often these procedures have different
names, take arguments in different orders, don't take the same number of
arguments, or have some other flaw that makes them unportable.  For this
reason, this SRFI is proposed.

   It should be noted that no vector sorting procedures are provided by
this SRFI, because there already is a SRFI for such a purpose, SRFI-32,
which includes routines for sorting not only vectors but also lists.


File: vicare-libs.info,  Node: srfi vector spec,  Next: srfi vector ack,  Prev: srfi vector rationale,  Up: srfi vectors

2.23.4 Specification
--------------------

* Menu:

* srfi vector spec intro::      Introduction.
* srfi vector spec cons::       Constructors.
* srfi vector spec pred::       Predicates.
* srfi vector spec select::     Selectors.
* srfi vector spec iter::       Iteration.
* srfi vector spec search::     Searching.
* srfi vector spec mutators::   Mutators.
* srfi vector spec conv::       Conversion.


File: vicare-libs.info,  Node: srfi vector spec intro,  Next: srfi vector spec cons,  Up: srfi vector spec

2.23.4.1 Introduction
.....................

In this section containing specifications of procedures, the following
notation is used to specify parameters and return values:

'(f arg1 arg2 ) -> something'
     Indicates a function F takes the parameters ARG1, ARG2, ... and
     returns a value of the type SOMETHING.  If SOMETHING is
     unspecified, then what F returns is implementation-dependant; this
     SRFI does not specify what it returns, and in order to write
     portable code, the return value should be ignored.

'vec'
     The argument in this place must be a vector, i.e.  it must satisfy
     the predicate 'vector?'.

'i, j, start, size'
     The argument in this place must be a nonnegative integer, i.e.  it
     must satisfy the predicates 'integer?' and either 'zero?' or
     'positive?'.  The third case of it indicates the index at which
     traversal begins; the fourth case of it indicates the size of a
     vector.

'end'
     The argument in this place must be a positive integer, i.e.  it
     must satisfy the predicates 'integer?' and 'positive?'.  This
     indicates the index directly before which traversal will stop;
     processing will occur until the the index of the vector is end.  It
     is the closed right side of a range.

'f'
     The argument in this place must be a function of one or more
     arguments, returning exactly one value.

'pred?'
     The argument in this place must be a function of one or more
     arguments that returns one value, which is treated as a boolean.

'x, y, z, seed, knil, fill, key, value'
     The argument in this place may be any Scheme value.

'[something]'
     Indicates that SOMETHING is an optional argument; it needn't
     necessarily be applied.  Something needn't necessarily be one
     thing; for example, this usage of it is perfectly valid:

          [start [end]]

     and is indeed used quite often.

'something '
     Indicates that zero or more somethings are allowed to be arguments.

'something1 something2 '
     Indicates that at least one something must be arguments.

'something1 something2  somethingn'
     Exactly equivalent to the previous argument notation, but this also
     indicates that N will be used later in the procedure description.

   It should be noted that all of the procedures that iterate across
multiple vectors in parallel stop iterating and produce the final result
when the end of the shortest vector is reached.  The sole exception is
'vector=', which automatically returns '#f' if the vectors' lengths
vary.


File: vicare-libs.info,  Node: srfi vector spec cons,  Next: srfi vector spec pred,  Prev: srfi vector spec intro,  Up: srfi vector spec

2.23.4.2 Constructors
.....................

 -- Function: make-vector SIZE [FILL] -> vector
     R5RS Create and return a vector of size SIZE, optionally filling it
     with FILL.  The default value of FILL is unspecified.

     Example:

          (make-vector 5 3)
          => #(3 3 3 3 3)

 -- Function: vector X ... -> vector
     R5RS Create and return a vector whose elements are X ...

     Example:

          (vector 0 1 2 3 4)
          => #(0 1 2 3 4)

 -- Function: vector-unfold F LENGTH INITIAL-SEED ... -> vector
     The fundamental vector constructor.  Create a vector whose length
     is LENGTH and iterates across each index K between 0 and LENGTH,
     applying F at each iteration to the current index and current
     seeds, in that order, to receive 'N + 1' values: first, the element
     to put in the K-th slot of the new vector and N new seeds for the
     next iteration.  It is an error for the number of seeds to vary
     between iterations.

     Examples:

          (vector-unfold (lambda (i x)
                           (values x (- x 1)))
                         10 0)
          => #(0 -1 -2 -3 -4 -5 -6 -7 -8 -8)

          ;; construct a vector of the sequence of integers
          ;; in the range [0,n)
          (vector-unfold values n)
          => #(0 1 2  n-2 n-1)

          ;; copy a vector
          (vector-unfold (lambda (i)
                           (vector-ref vector i))
                         (vector-length vector))

 -- Function: vector-unfold-right F LENGTH INITIAL-SEED ... -> vector
     Like 'vector-unfold', but it uses F to generate elements from
     right-to-left, rather than left-to-right.

     Examples:

          ;; Construct a vector in reverse of the integers
          ;; in the range [0,n).
          (vector-unfold-right (lambda (i x)
                                 (values x (+ x 1)))
                               n 0)
          => #(n-1 n-2  2 1 0)

          ;; Reverse vector.
          (vector-unfold-right (lambda (i x)
                                 (values (vector-ref vector x) (+ x 1)))
                               (vector-length vector)
                               0)

 -- Function: vector-copy VEC [START [END [FILL]]] -> vector
     Allocate a new vector whose length is 'END - START' and fills it
     with elements from VEC, taking elements from VEC starting at index
     START and stopping at index END.

     START defaults to 0 and END defaults to the value of
     '(vector-length VEC)'.

     If END extends beyond the length of VEC, the slots in the new
     vector that obviously cannot be filled by elements from VEC are
     filled with FILL, whose default value is unspecified.

     Examples:

          (vector-copy '#(a b c d e f g h i))
          => #(a b c d e f g h i)

          (vector-copy '#(a b c d e f g h i) 6)
          => #(g h i)

          (vector-copy '#(a b c d e f g h i) 3 6)
          => #(d e f)

          (vector-copy '#(a b c d e f g h i) 6 12 'x)
          => #(g h i x x x)

 -- Function: vector-reverse-copy VEC [START [END]] -> vector
     Like 'vector-copy', but it copies the elements in the reverse order
     from VEC.

     Example:

          (vector-reverse-copy '#(5 4 3 2 1 0) 1 5)
          => #(1 2 3 4)

 -- Function: vector-append VEC ... -> vector
     Returns a newly allocated vector that contains all elements in
     order from the subsequent locations in VEC ...

     Examples:

          (vector-append '#(x) '#(y))
          => #(x y)

          (vector-append '#(a) '#(b c d))
          => #(a b c d)

          (vector-append '#(a #(b)) '#(#(c)))
          => #(a #(b) #(c))

 -- Function: vector-concatenate LIST-OF-VECTORS -> vector
     Appends each vector in LIST-OF-VECTORS.  This is equivalent to:

          (apply vector-append list-of-vectors)

     however, it may be implemented better.

     Example:

          (vector-concatenate '(#(a b) #(c d)))
          => #(a b c d)


File: vicare-libs.info,  Node: srfi vector spec pred,  Next: srfi vector spec select,  Prev: srfi vector spec cons,  Up: srfi vector spec

2.23.4.3 Predicates
...................

 -- Function: vector? X -> boolean
     R5RS Disjoint type predicate for vectors: return '#t' if X is a
     vector, and '#f' otherwise.

     Examples:

          (vector? '#(a b c))
          => #t

          (vector? '(a b c))
          => #f

          (vector? #t)
          => #f

          (vector? '#())
          => #t

          (vector? '())
          => #f

 -- Function: vector-empty? VEC -> boolean
     Return '#t' if VEC is empty, i.e.  its length is 0, otherwise '#f'.

     Examples:

          (vector-empty? '#(a))
          => #f

          (vector-empty? '#(()))
          => #f

          (vector-empty? '#(#()))
          => #f

          (vector-empty? '#())
          => #t

 -- Function: vector= ELT=? VEC ... -> boolean
     Vector structure comparator, generalized across user-specified
     element comparators.  Vectors A and B are considered equal by
     'vector=' if, and only if, their lengths are the same, and for each
     respective elements EA and EB, '(ELT=? EA EB)' returns a true
     value.

     ELT=? is always applied to two arguments.

     Element comparison must be consistent with 'eq?'; that is, if '(eq?
     EA EB)' results in a true value, then '(ELT=? EA EB)' must also
     result in a true value.  This may be exploited to avoid unnecessary
     element comparisons.  (The reference implementation does, but it
     does not consider the situation where ELT=? is in fact itself 'eq?'
     to avoid yet more unnecessary comparisons.)

     If there are only zero or one vector arguments, '#t' is
     automatically returned.

     The dynamic order in which comparisons of elements and of vectors
     are performed is left completely unspecified; do not rely on a
     particular order.

     Examples:

          (vector= eq? '#(a b c d) '#(a b c d))
          => #t

          (vector= eq? '#(a b c d) '#(a b d c))
          => #f

          (vector= = '#(1 2 3 4 5) '#(1 2 3 4))
          => #f

          (vector= = '#(1 2 3 4) '#(1 2 3 4))
          => #t

     the two trivial cases:

          (vector= eq?)
          => #t

          (vector= eq? '#(a))
          => #t

     Note the fact that we don't use vector literals in the next two; it
     is unspecified whether or not literal vectors with the same
     external representation are 'eq?':

          (vector= eq? (vector (vector 'a)) (vector (vector 'a)))
          => #f

          (vector= equal? (vector (vector 'a)) (vector (vector 'a)))
          => #t


File: vicare-libs.info,  Node: srfi vector spec select,  Next: srfi vector spec iter,  Prev: srfi vector spec pred,  Up: srfi vector spec

2.23.4.4 Selectors
..................

 -- Function: vector-ref VEC I -> value
     R5RS Vector element dereferencing: return the value that the
     location in VEC at I is mapped to in the store.  Indexing is based
     on zero.  The argument I must be within the range: '[0,
     (vector-length VEC))'.

     Example:

          (vector-ref '#(a b c d) 2)
          => c

 -- Function: vector-length VEC -> exact nonnegative integer
     R5RS Return the length of VEC, the number of locations reachable
     from VEC.  (The careful word "reachable" is used to allow for
     "vector slices", whereby VEC refers to a larger vector that
     contains more locations that are unreachable from VEC.  This SRFI
     does not define vector slices, but later SRFIs may.)

     Example:

          (vector-length '#(a b c))
          => 3


File: vicare-libs.info,  Node: srfi vector spec iter,  Next: srfi vector spec search,  Prev: srfi vector spec select,  Up: srfi vector spec

2.23.4.5 Iteration
..................

 -- Function: vector-fold KONS KNIL VEC1 VEC2 ... -> value
     The fundamental vector iterator.  KONS is iterated over each index
     in all of the vectors, stopping at the end of the shortest; KONS is
     applied as:

          (KONS I STATE
                      (vector-ref VEC1 I)
                      (vector-ref VEC2 I)
                      )

     where STATE is the current state value; the current state value
     begins with KNIL, and becomes whatever KONS returned at the
     respective iteration; and I is the current index.

     The iteration is strictly left-to-right.

     Examples:

          ;; Find the longest string's length in vector-of-strings.
          (vector-fold (lambda (index len str)
                         (max (string-length str) len))
                       0 vector-of-strings)

          ;; Produce a list of the reversed elements of vec.
          (vector-fold (lambda (index tail elt)
                         (cons elt tail))
                       '() vec)

          ;; Count the number of even numbers in vec.
          (vector-fold (lambda (index counter n)
                         (if (even? n) (+ counter 1) counter))
                       0 vec)

 -- Function: vector-fold-right KONS KNIL VEC1 VEC2 ... -> value
     Similar to 'vector-fold', but it iterates right to left instead of
     left to right.

     Example:

          ;; Convert a vector to a list.
          (vector-fold-right (lambda (index tail elt)
                               (cons elt tail))
                             '() '#(a b c d))
          => (a b c d)

 -- Function: vector-map F VEC1 VEC2 ... -> vector
     Construct a new vector of the shortest size of the vector
     arguments.  Each element at index I of the new vector is mapped
     from the old vectors by:

          (F I (vector-ref VEC1 I)
                           (vector-ref VEC2 I)
                           )

     The dynamic order of application of F is unspecified.

     Examples:

          (vector-map (lambda (i x) (* x x))
                        (vector-unfold (lambda (i x)
                                         (values x (+ x 1)))
                                       4 1))
          => #(1 4 9 16)

          (vector-map (lambda (i x y) (* x y))
                        (vector-unfold (lambda (i x)
                                         (values x (+ x 1)))
                                       5 1)
                        (vector-unfold (lambda (i x)
                                         (values x (- x 1)))
                                       5 5))
          => #(5 8 9 8 5)

          (let ([count 0])
            (vector-map (lambda (ignored-index ignored-elt)
                          (set! count (+ count 1))
                          count)
                        '#(a b)))
          => #(1 2) OR #(2 1)

          (vector-map (lambda (i elt)
                        (+ i elt))
                      '#(1 2 3 4))
          => #(1 3 5 7)

 -- Function: vector-map! F VEC1 VEC2 ... -> unspecified
     Similar to 'vector-map', but rather than mapping the new elements
     into a new vector, the new mapped elements are destructively
     inserted into VEC1.  The dynamic order of application of F
     unspecified, so it is dangerous for F to apply either 'vector-ref'
     or 'vector-set!' to VEC1 in F.

 -- Function: vector-for-each F VEC1 VEC2 ... -> unspecified
     Simple vector iterator: apply F to each index in the range '[0,
     LENGTH)', where LENGTH is the length of the smallest vector
     argument passed, and the respective list of parallel elements from
     VEC1, VEC2, ... at that index.  In contrast with 'vector-map', F is
     reliably applied to each subsequent elements, starting at index 0,
     in the vectors.

     Example:

          (vector-for-each (lambda (i x)
                             (display x)
                             (newline))
          => '#("foo" "bar" "baz" "quux" "zot"))

     displays:

          foo
          bar
          baz
          quux
          zot

 -- Function: vector-count PRED? VEC1 VEC2 ... -> exact nonnegative
          integer
     Count the number of parallel elements in the vectors that satisfy
     PRED?, which is applied, for each index I in the range '[0,
     LENGTH)', where LENGTH is the length of the smallest vector
     argument, to I and each parallel element in the vectors at that
     index, in order.

     Examples:

          (vector-count (lambda (i elt)
                          (even? elt))
                        '#(3 1 4 1 5 9 2 5 6))
          => 3

          (vector-count (lambda (i x y)
                          (< x y))
                        '#(1 3 6 9)
                        '#(2 4 6 8 10 12))
          => 2


File: vicare-libs.info,  Node: srfi vector spec search,  Next: srfi vector spec mutators,  Prev: srfi vector spec iter,  Up: srfi vector spec

2.23.4.6 Searching
..................

 -- Function: vector-index PRED? VEC1 VEC2 ... -> exact nonnegative
          integer or #f
     Find and return the index of the first elements in VEC1, VEC2, ...
     that satisfy PRED?.  If no matching element is found by the end of
     the shortest vector, '#f' is returned.

     Examples:

          (vector-index even? '#(3 1 4 1 5 9))
          => 2

          (vector-index < '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
          => 1

          (vector-index = '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
          => #f

 -- Function: vector-index-right PRED? VEC1 VEC2 ... -> exact
          nonnegative integer or #f
     Like 'vector-index', but it searches right-to-left, rather than
     left-to-right, and all of the vectors must have the same length.

 -- Function: vector-skip PRED? VEC1 VEC2 ... -> exact nonnegative
          integer or #f
     Find and return the index of the first elements in VEC1, VEC2, ...
     that do not satisfy PRED?.  If all the values in the vectors
     satisfy PRED? until the end of the shortest vector, this returns
     '#f'.  This is equivalent to:

          (vector-index (lambda (x1 x2 )
                          (not (pred? x1 x1 )))
                        vec1 vec2 ...)

     Example:

          (vector-skip number? '#(1 2 a b 3 4 c d))
          => 2

 -- Function: vector-skip-right PRED? VEC1 VEC2 ... -> exact nonnegative
          integer or #f
     Like 'vector-skip', but it searches for a non-matching element
     right-to-left, rather than left-to-right, and all of the vectors
     must have the same length.  This is equivalent to:

          (vector-index-right (lambda (x1 x2 ...)
                                (not (pred? x1 x1 ...)))
                              vec1 vec2 ...)

 -- Function: vector-binary-search VEC VALUE CMP -> exact nonnegative
          integer or #f
     Similar to 'vector-index' and 'vector-index-right', but instead of
     searching left to right or right to left, this performs a binary
     search.  CMP should be a procedure of two arguments and return: a
     negative integer, which indicates that its first argument is less
     than its second; zero, which indicates that they are equal; a
     positive integer, which indicates that the first argument is
     greater than the second argument.  An example CMP might be:

          (lambda (char1 char2)
            (cond [(char<? char1 char2) -1]
                  [(char=? char1 char2) 0]
                  [else 1]))

 -- Function: vector-any PRED? VEC1 VEC2 ... -> value or #f
     Find the first set of elements in parallel from VEC1, VEC2, ...
     for which PRED? returns a true value.  If such a parallel set of
     elements exists, 'vector-any' returns the value that PRED? returned
     for that set of elements.  The iteration is strictly left-to-right.

 -- Function: vector-every PRED? VEC1 VEC2 ... -> value or #f
     If, for every index I between 0 and the length of the shortest
     vector argument, the set of elements:

          (vector-ref VEC1 I)
          (vector-ref VEC2 I)
           

     satisfies PRED?, 'vector-every' returns the value that PRED?
     returned for the last set of elements, at the last index of the
     shortest vector.  The iteration is strictly left-to-right.


File: vicare-libs.info,  Node: srfi vector spec mutators,  Next: srfi vector spec conv,  Prev: srfi vector spec search,  Up: srfi vector spec

2.23.4.7 Mutators
.................

 -- Function: vector-set! VEC I VALUE -> unspecified
     R5RS Assign the contents of the location at I in VEC to VALUE.

 -- Function: vector-swap! VEC I J -> unspecified
     Swap or exchange the values of the locations in VEC at I and J.

 -- Function: vector-fill! VEC FILL [START [END]] -> unspecified
     R5RS+ Assign the value of every location in VEC between START,
     which defaults to 0 and END, which defaults to the length of VEC,
     to FILL.

 -- Function: vector-reverse! VEC [START [END]] -> unspecified
     Destructively reverse the contents of the sequence of locations in
     VEC between START and END.  Start defaults to 0 and end defaults to
     the length of VEC.  Note that this does not deeply reverse.

 -- Function: vector-copy! TARGET TSTART SOURCE [SSTART [SEND]] ->
          unspecified
     Copy a block of elements from SOURCE to TARGET, both of which must
     be vectors, starting in TARGET at TSTART and starting in SOURCE at
     SSTART, ending when 'SEND - SSTART' elements have been copied.  It
     is an error for TARGET to have a length less than:

          TSTART + (SEND - SSTART)

     SSTART defaults to 0 and send defaults to the length of SOURCE.

 -- Function: vector-reverse-copy! TARGET TSTART SOURCE [SSTART [SEND]]
          -> unspecified
     Like 'vector-copy!', but this copies the elements in the reverse
     order.  It is an error if TARGET and SOURCE are identical vectors
     and the TARGET and SOURCE ranges overlap; however, if 'TSTART =
     SSTART', 'vector-reverse-copy!' behaves as:

          (vector-reverse! TARGET TSTART SEND)

     would.


File: vicare-libs.info,  Node: srfi vector spec conv,  Prev: srfi vector spec mutators,  Up: srfi vector spec

2.23.4.8 Conversion
...................

 -- Function: vector->list VEC [START [END]] -> proper-list
     R5RS Create a list containing the elements in VEC between START,
     which defaults to 0, and END, which defaults to the length of VEC.

 -- Function: reverse-vector->list VEC [START [END]] -> proper-list
     Like 'vector->list', but the resulting list contains the elements
     in reverse between the the specified range.

 -- Function: list->vector PROPER-LIST -> vector
     R5RS Create a vector of elements from PROPER-LIST.

 -- Function: reverse-list->vector PROPER-LIST -> vector
     Like 'list->vector', but the resulting list contains the elements
     in reverse of PROPER-LIST.


File: vicare-libs.info,  Node: srfi vector ack,  Next: srfi vector references,  Prev: srfi vector spec,  Up: srfi vectors

2.23.5 Acknowledgements
-----------------------

Thanks to Olin Shivers for his wonderfully complete list and string
packages; to all the members of the '#scheme' IRC channel on Freenode
who nitpicked a great deal, but also helped quite a lot in general, and
helped test the reference implementation in various Scheme systems; to
Michael Burschik for his numerous comments; to Sergei Egorov for helping
to narrow down the procedures; to Mike Sperber for putting up with an
extremely overdue draft; to Felix Winkelmann for continually bugging me
about finishing up the SRFI so that it would be only overdue and not
withdrawn; and to everyone else who gave questions, comments, thoughts,
or merely attention to the SRFI.


File: vicare-libs.info,  Node: srfi vector references,  Prev: srfi vector ack,  Up: srfi vectors

2.23.6 References
-----------------

_The Revised5 Report on Scheme_.  R. Kelsey, W. Clinger, J. Rees
(editors).  Higher-Order and Symbolic Computation, Vol.  11, No.  1,
September, 1998, and ACM SIGPLAN Notices, Vol.  33, No.  9, October,
1998.

          <http://www.schemers.org/Documents/Standards/R5RS/>

_SRFI: Scheme Request for Implementation_.  The SRFI website can be
found at:

                      <http://srfi.schemers.org/>

_SRFI-1: List Library_.  A SRFI of list processing procedures, written
by Olin Shivers.

                  <http://srfi.schemers.org/srfi-1/>

_SRFI-13: String Library_.  A SRFI of string processing procedures,
written by Olin Shivers.

                  <http://srfi.schemers.org/srfi-13/>

_SRFI-23: Error Reporting Mechanism_.  A SRFI that defines a new
primitive (error) for reporting that an error occurred, written by
Stephan Houben.

                  <http://srfi.schemers.org/srfi-23/>

_SRFI-32: Sort Libraries (draft)_.  A SRFI of list and vector sorting
routines, written by Olin Shivers.

                  <http://srfi.schemers.org/srfi-32/>


File: vicare-libs.info,  Node: srfi lazy,  Next: srfi intermediate-format,  Prev: srfi vectors,  Up: srfi

2.24 SRFI-45 lazy iterative algorithms
======================================

The library '(srfi :45)' is by Andre van Tonder as the reference
implementation for SRFI-45; see:

            <http://srfi.schemers.org/srfi-45/srfi-45.html>

for more details.

* Menu:

* srfi lazy abstract::          Abstract.
* srfi lazy rationale::         Rationale.
* srfi lazy spec::              Specification.
* srfi lazy usage::             Correct usage.
* srfi lazy refs::              References.
* srfi lazy copyright::         Copyright.


File: vicare-libs.info,  Node: srfi lazy abstract,  Next: srfi lazy rationale,  Up: srfi lazy

2.24.1 Abstract
---------------

Lazy evaluation is traditionally simulated in Scheme using 'delay' and
'force'.  However, these primitives are not powerful enough to express a
large class of lazy algorithms that are iterative.  Indeed, it is
folklore in the Scheme community that typical iterative lazy algorithms
written using 'delay' and 'force' will often require unbounded memory.

   Although various modifications of 'delay' and 'force' had been
proposed to resolve this problem (see e.g., the SRFI-40 discussion list)
they all fail some of the benchmarks provided by this SRFI.  To our
knowledge, the current SRFI provides the first exhaustive solution to
this problem.

   As motivation, we first explain how the usual laziness encoding using
only 'delay' and 'force' will break the iterative behavior of typical
algorithms that would have been properly tail-recursive in a true lazy
language, causing the computation to require unbounded memory.

   The problem is then resolved by introducing a set of three
operations:

     {lazy, delay, force}

which allow the programmer to succinctly express lazy algorithms while
retaining bounded space behavior in cases that are properly
tail-recursive.  A general recipe for using these primitives is
provided.  An additional procedure 'eager' is provided for the
construction of eager promises in cases where efficiency is a concern.

   Although this SRFI redefines 'delay' and 'force', the extension is
conservative in the sense that the semantics of the subset '{delay,
force}' in isolation (i.e., as long as the program does not use 'lazy')
agrees with that in R5RS.  In other words, no program that uses the R5RS
definitions of 'delay' and 'force' will break if those definition are
replaced by the SRFI-45 definitions of 'delay' and 'force'.


File: vicare-libs.info,  Node: srfi lazy rationale,  Next: srfi lazy spec,  Prev: srfi lazy abstract,  Up: srfi lazy

2.24.2 Rationale
----------------

Wadler et al.  in the paper _How to add laziness to a strict language
without even being odd_ [Wad98], provide a straightforward recipe for
transforming arbitrary lazy data structures and algorithms into a strict
language using 'delay' and 'force'.

   However, it is known (see e.g.  the SRFI-40 discussion list) that
this transformation can lead to programs that suffer from unbounded
space consumption, even if the original lazy algorithm was properly
tail-recursive.  Example Consider the following procedure, written in a
hypothetical lazy language with Scheme syntax:

     (define (stream-filter p? s)
       (if (null? s) '()
           (let ((h (car s))
                 (t (cdr s)))
             (if (p? h)
                 (cons h (stream-filter p? t))
                 (stream-filter p? t)))))

   According to the tranformation proposed in [Wad98], this algorithm
can be espressed as follows in Scheme:

     (define (stream-filter p? s)
       (delay (force
               (if (null? (force s)) (delay '())
                   (let ((h (car (force s)))
                         (t (cdr (force s))))
                     (if (p? h)
                         (delay (cons h (stream-filter p? t)))
                         (stream-filter p? t)))))))

   The recipe, which we will modify below, is as follows:

  1. Wrap all constructors (e.g., '()', 'cons') with 'delay'.

  2. Apply 'force' to arguments of deconstructors (e.g., 'car', 'cdr'
     and 'null?').

  3. Wrap procedure bodies with '(delay (force ...))'.

   However, evaluating the following with a sufficiently value for
large-number will cause a typical Scheme implementation to run out of
memory, despite the fact that the original (lazy) algorithm was
iterative, only needing tail calls to evaluate the first element of the
result stream.

     (define (from n)
       (delay (cons n (from (+ n 1)))))

     (define large-number 1000000000)

     (car (force (stream-filter (lambda (n) (= n large-number))
                                (from 0))))

Why the space leak occurs
.........................

The problem occurring in the above 'stream-filter' example can already
be seen in the following simple infinite loop, expressed in our
hypothetical lazy language as:

     (define (loop) (loop))

which becomes, according to the [Wad98] transformation:

     (define (loop) (delay (force (loop))))

   Taking the semantics of '{delay, force}' to be informally:

     (force (delay expr)) = update promise : (delay expr)
                              with value of expr
                            return value in promise

we get:

     (force (loop)) = update promise1 : (delay (force (loop)))
                        with value of (force (loop))
                      return value in promise1
                    = update promise1 : (delay (force (loop)))
                        with value of
                          update promise2 : (delay (force (loop)))
                            with value of (force (loop))
                          return value in promise2
                      return value in promise1
                    = update promise1 : (delay (force (loop)))
                        with value of
                          update promise2 : (delay (force (loop)))
                            with value of
                               update promise3 : (delay (force (loop)))
                                 with value of (force (loop))
                               return value in promise3
                          return value in promise2
                      return value in promise1
                    = ...

   We see that an ever growing sequence of pending promises builds up
until the heap is exhausted.

Why the above is not call-by-need
.................................

Expressing the above algorithm in terms of '{delay, force}' in fact does
not correctly capture common notions of call-by-need evaluation
semantics.  For example, in a call-by-need language with naive graph
reduction semantics, the above algorithm would run in bounded space
since naive graph reduction is known to be tail-safe.  For a good
discussion of this issue, see e.g.  R. Jones _Tail recursion without
space leaks_ [Jon98].

   Our problem may be regarded as analogous to graph reduction, with
promises corresponding to graph nodes and force corresponding to
reduction.  As described by Jones, one has to be careful with the order
in which nodes are evaluated and overwritten to avoid space leaks.  In
our context this would correspond to the order in which promises are
evaluated and overwritten when forced.

   In the above example, naive graph reduction would correspond to the
promise at the root being overwritten at each step before the next
iteration is evaluated, thus avoiding the need for a growing sequence of
unfulfilled promises representing (unnecessary) future copy operations.

The solution
............

The accumulation of unnecessary promises in the above examples is a
consequence of suspensions being forced in increasingly nested contexts.
In order to correctly simulate naive graph reduction we should instead
find a way of forcing tail suspensions iteratively, each time
overwriting the previous result.

   A solution to this problem exists and is described (in a different
context) in _Compiling higher order languages into fully tail-recursive
portable C_, Feely et al.  [Fee97].  This reference introduces a method
widely known as the trampoline technique for evaluating tail contexts
iteratively.

   Adapting the trampoline technique to the situation at hand, we
introduce a new primitive lazy, which behaves like an "atomic" '(delay
(force ...))', and which will replace the combination '(delay (force
...))' at procedure entry points.  We also redefine delay and force as
below:

     ; type Promise a = lazy (Promise a) | eager a

     (define-syntax lazy
       (syntax-rules ()
         ((lazy exp)
          (box (cons 'lazy (lambda () exp))))))

     (define (eager x)
       (box (cons 'eager x)))

     (define-syntax delay
       (syntax-rules ()
         ((delay exp) (lazy (eager exp)))))

     (define (force promise)
       (let ((content (unbox promise)))
         (case (car content)
           ((eager) (cdr content))
           ((lazy)  (let* ((promise* ((cdr content)))
                           (content  (unbox promise)))                      ; *
                      (if (not (eqv? (car content) 'eager))                 ; *
                          (begin (set-car! content (car (unbox promise*)))
                                 (set-cdr! content (cdr (unbox promise*)))
                                 (set-box! promise* content)))
                      (force promise))))))

     (*) These two lines re-fetch and check the original promise in case
         the first line of the let* caused it to be forced.  For an example
         where this happens, see reentrancy test 3 below.

     (define (box x) (list x))
     (define unbox car)
     (define set-box! set-car!)

   Our example is then coded (see the full recipe below):

     (define (loop) (lazy (loop)))

   When we now evaluate '(force (loop))', the force procedure will
execute a top-level loop which will iteratively evaluate and overwrite
subsequent suspensions.

   In the language of [Fee97], the iterative loop in force plays the
role of "dispatcher".  The lazy form marks "control points" (procedure
entry and return points).  This technique is tail-safe because lazy
procedures, instead of calling other lazy procedures directly, simply
return a suspension representing a control point to be called upon the
next iteration of the dispatcher loop in force.  For more details, see
[FMRW].


File: vicare-libs.info,  Node: srfi lazy spec,  Next: srfi lazy usage,  Prev: srfi lazy rationale,  Up: srfi lazy

2.24.3 Specification
--------------------

The following macros should be provided.  The semantics, which is
informally described here, should conform to that of the reference
implementation.

 -- Syntax: delay ?EXPRESSION
     Take an expression of arbitrary type 'A0 A ...' and return a
     promise of type '(Promise A0 A ...)' which at some point in the
     future may be asked (by the 'force' procedure) to evaluate the
     expression and deliver the resulting values.

 -- Syntax: lazy ?EXPRESSION
     Take an expression of type '(Promise A0 A ...)' and return a
     promise of type '(Promise A0 A ...)' which at some point in the
     future may be asked (by the 'force' procedure) to evaluate the
     expression and deliver the resulting promise.

   The following procedures should be provided.

 -- Function: force EXPRESSION
     Take an argument of type '(Promise A0 A ...)' and return a value of
     type 'A0 A ...' as follows: if values of type 'A0 A ...' have been
     computed for the promise, these values are returned.  Otherwise,
     the promise is first evaluated, then overwritten by the obtained
     promise or value, and then 'force' is again applied (iteratively)
     to the promise.

 -- Function: eager EXPRESSION0 EXPRESSION ...
     Take an argument of type 'A0 A ...' and return a value of type
     '(Promise A0 A ...)'.  As opposed to 'delay', the argument is
     evaluated eagerly.  Semantically, writing '(eager expression)' is
     equivalent to writing:

          (let ((value expression)) (delay value))

     However, the former is more efficient since it does not require
     unnecessary creation and evaluation of thunks.  We also have the
     equivalence:

          (delay expression) == (lazy (eager expression))

   The following reduction rules may be helpful for reasoning about
these primitives.  However, they do not express the memoization and
memory usage semantics specified above:

     (force (delay expression)) -> expression
     (force (lazy  expression)) -> (force expression)
     (force (eager value))      -> value

   The typing can be succinctly expressed as follows:

     type Promise a = lazy (Promise a) | eager a

            expression  : a
     ------------------------------
     (eager expression) : Promise a

            expression  : Promise a
     ------------------------------
     (lazy expression)  : Promise a

            expression  : a
     ------------------------------
     (delay expression) : Promise a

            expression  : Promise a
     ------------------------------
     (force expression) : a

   Although this SRFI specifies an extension to the semantics of
'force', the extension is conservative in the sense that the semantics
of the subset '{delay, force}' in isolation (i.e., as long as the
program does not use 'lazy') agrees with that in R5RS.


File: vicare-libs.info,  Node: srfi lazy usage,  Next: srfi lazy refs,  Prev: srfi lazy spec,  Up: srfi lazy

2.24.4 Correct usage
--------------------

We now provide a general recipe for using the primitives:

     {lazy, delay, force}

to express lazy algorithms in Scheme.  The transformation is best
described by way of an example: Consider again the 'stream-filter'
algorithm, expressed in a hypothetical lazy language as:

     (define (stream-filter p? s)
       (if (null? s) '()
           (let ((h (car s))
                 (t (cdr s)))
             (if (p? h)
                 (cons h (stream-filter p? t))
                 (stream-filter p? t)))))

   This algorithm can be espressed as follows in Scheme:

     (define (stream-filter p? s)
       (lazy
          (if (null? (force s)) (delay '())
              (let ((h (car (force s)))
                    (t (cdr (force s))))
                (if (p? h)
                    (delay (cons h (stream-filter p? t)))
                    (stream-filter p? t))))))

   In other words, we:

  1. Wrap all constructors (e.g., '()', 'cons') with 'delay'.

  2. Apply force to arguments of deconstructors (e.g., 'car', 'cdr' and
     'null?').

  3. Wrap procedure bodies with '(lazy ...)'.

   The only difference with the [Wad98] transformation described above
is in replacing the combination '(delay (force ...))' with '(lazy ...)'
in the third rule.


File: vicare-libs.info,  Node: srfi lazy refs,  Next: srfi lazy copyright,  Prev: srfi lazy usage,  Up: srfi lazy

2.24.5 References
-----------------

[Wad98] Philip Wadler, Walid Taha, and David MacQueen.  How to add
laziness to a strict language, without even being odd, Workshop on
Standard ML, Baltimore, September 1998.

[Jon92] Richard Jones.  Tail recursion without space leaks, Journal of
Functional Programming, 2(1):73-79, January 1992.

[Fee97] Marc Feeley, James S. Miller, Guillermo J. Rozas, Jason A.
Wilson.  Compiling Higher-Order Languages into Fully Tail-Recursive
Portable C, Rapport technique 1078, departement d'informatique et r.o.,
Universite de Montreal, aoet 1997.


File: vicare-libs.info,  Node: srfi lazy copyright,  Prev: srfi lazy refs,  Up: srfi lazy

2.24.6 Copyright
----------------

Copyright (C) Andre van Tonder (2003).  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi intermediate-format,  Next: srfi general-cond,  Prev: srfi lazy,  Up: srfi

2.25 SRFI-48 intermediate format strings
========================================

The library '(srfi :48)' is by Kenneth Dickey as the reference
implementation for SRFI-48; see:

            <http://srfi.schemers.org/srfi-48/srfi-48.html>

for more details.

* Menu:

* srfi intermediate-format abstract::   Abstract.
* srfi intermediate-format issue::      Issues.
* srfi intermediate-format rationale::  Rationale.
* srfi intermediate-format spec::       Specification.
* srfi intermediate-format examples::   Examples.
* srfi intermediate-format copyright::  Copyright.


File: vicare-libs.info,  Node: srfi intermediate-format abstract,  Next: srfi intermediate-format issue,  Up: srfi intermediate-format

2.25.1 Abstract
---------------

This document specifies _Format Strings_, a method of interpreting a
Scheme string which contains a number of format directives that are
replaced with other string data according to the semantics of each
directive.  This SRFI extends SRFI-28 in being more generally useful but
is less general than advanced format strings in that it does not allow,
aside from '~F', for controlled positioning of text within fields.


File: vicare-libs.info,  Node: srfi intermediate-format issue,  Next: srfi intermediate-format rationale,  Prev: srfi intermediate-format abstract,  Up: srfi intermediate-format

2.25.2 Issues
-------------

Some may disagree with specific escape options or return values.  For
those who desire complex options as implemented by SLIB or Common Lisp's
'format', an upwards compatible "Advanced Format" SRFI should be
proposed.

   In particular, the reference implementation given here does not
accept numeric arguments (aside from '~F').  Hence it does not support
SRFI-29.

   It is highly desireable that baseline library code be small, attempt
to eliminiate heap allocation and bound stack usage.  This is especially
important in embedded systems.  This can be accomplished by writing
directly to a port, rather than a string, by not supporting '~W' or
'~F', and by replacing:

     (display (number->string n r) p)

with a carefully written:

     (display:number->string n r p)

which does not build intermediate strings.

   As this is intermediate format, it was felt that '~F' and '~W' are
too highly useful to elide.  The '~H' option is helpful to users, allows
for programattic query, and makes clear which format directives are
supported.


File: vicare-libs.info,  Node: srfi intermediate-format rationale,  Next: srfi intermediate-format spec,  Prev: srfi intermediate-format issue,  Up: srfi intermediate-format

2.25.3 Rationale
----------------

Inheriting from MacLisp, nearly all Lisp and Scheme implementations
support some form of 'format' function with support for various numbers
of format directives.  By agreeing to the options here, we raise the bar
for portable code.

   The reference implementation is R5RS compliant and easy to port.  In
not requiring advanced features (aside from '~W' and '~F') small
implementations are possible.  E.g.  the reference code does not use
side effects (assignment) and is less than a third the source size of
the latest SLIB implementation of 'format' (less than a tenth if '~F'
support is elided).

   The optional port argument allows for compatibility with older code
written for, e.g.  scheme48, MIT Scheme, T, et cetera, which required a
port argument.  It is also useful in cases where a synoptic
implementation of Scheme and CommonLisp is maintained.


File: vicare-libs.info,  Node: srfi intermediate-format spec,  Next: srfi intermediate-format examples,  Prev: srfi intermediate-format rationale,  Up: srfi intermediate-format

2.25.4 Specification
--------------------

 -- Function: format FORMAT-STRING
 -- Function: format FORMAT-STRING OBJ ...
 -- Function: format PORT FORMAT-STRING
 -- Function: format PORT FORMAT-STRING OBJ ...
     Accept a format template (a Scheme String), and process it,
     replacing any format directives in order with one or more
     characters, the characters themselves dependent on the semantics of
     the format directive encountered.  Each directive may consume one
     OBJ.  It is an error if fewer or more OBJ values are provided than
     format directives that require them.

     When a PORT is specified it must be either an output port or a
     boolean.

        * If an output port is specified: the formatted output is output
          into that port.

        * If the PORT argument is '#t': output is to the
          'current-output-port'.

        * If the PORT is '#f' or no PORT is specified: the output is
          returned as a string.

        * If the PORT is specified and is '#t' or an output port: the
          return value of the 'format' function is unspecified.

     It is unspecified which encoding is used (e.g.  ASCII, EBCDIC,
     Unicode).  A given implementation must specify which encoding is
     used.  The implementation may or may not allow the encoding to be
     selected or changed.

     It is an error if a format directive consumes an OBJ argument and
     that argument does not conform to a required type as noted in the
     table below.

     It is permissible, but highly discouraged, to implement
     'pretty-print' as:

          (define pretty-print write)

     A format directive is a two character sequence in the string where
     the first character is a tilde '~'.  Directive characters are
     case-independent, i.e.  upper and lower case characters are
     interpreted the same.  Each directive code's meaning is described
     in the following table:

     DIRECTIVE    MNEMONIC       ACTION                               CONSUMES?
     ---------------------------------------------------------------------------
     '~a'         Any            '(display obj)' for humans.          yes
     '~s'         Slashified     '(write obj)' for parsers.           yes
     '~w'         WriteCircular  '(write-with-shared-structure        yes
                                 obj)' like '~s', but handles
                                 recursive structures.
     '~d'         Decimal        The OBJ is a number which is         yes
                                 output in decimal radix.
     '~x'         heXadecimal    The OBJ is a number which is         yes
                                 output in hexdecimal radix.
     '~o'         Octal          The OBJ is a number which is         yes
                                 output in octal radix.
     '~b'         Binary         The OBJ is a number which is         yes
                                 output in binary radix.
     '~c'         Character      The single charater OBJ is output    yes
                                 by 'write-char'.
     '~y'         Yuppify        The list OBJ is pretty-printed to    yes
                                 the output.
     '~?'         Indirection    The OBJ is another format-string     yes
                                 and the following OBJ is a list of
                                 arguments; format is called
                                 recursively.
     '~K'         Indirection    The same as '~?' for backward        yes
                                 compatability with some existing
                                 implementations.
     '~[w[,d]]F'  Fixed          '~w,dF' outputs a number with        yes
                                 width 'w' and 'd' digits after the
                                 decimal; '~wF' outputs a string or
                                 number with width 'w'.
     '~~'         Tilde          Output a tilde.                      no
     '~t'         Tab            Output a tab character.              no
     '~%'         Newline        Output a newline character.          no
     '~&'         Freshline      Output a newline character if it     no
                                 is known that the previous output
                                 was not a newline.
     '~_'         Space          A single space character is          no
                                 output.
     '~h'         Help           Outputs one line of call synopsis,   no
                                 one line of comment, and one line
                                 of synopsis for each format
                                 directive, starting with the
                                 directive (e.g.  '"~t"').

     The '~F', fixed format, directive requires some elucidation.

     '~wF' is useful for strings or numbers.  Where the string (or
     'number->string' of the number) has fewer characters than the
     integer width 'w', the string is padded on the left with space
     characters.

     '~w,dF' is typically used only on numbers.  For strings, the 'd'
     specifier is ignored.  For numbers, the integer 'd' specifies the
     number of decimal digits after the decimal place.  Both 'w' and 'd'
     must be zero or positive.

     If 'd' is specified, the number is processed as if added to '0.0',
     i.e.  it is converted to an inexact value.

          (format "~8,2F" 1/3)    => "    0.33"

     If no 'd' is specified, the number is not coerced to inexact.

          (format "~6F" 32)       => "    32"

     Digits are padded to the right with zeros

          (format "~8,2F" 32)     => "   32.00"

     If the number it too large to fit in the width specified, a string
     longer than the width is returned:

          (format "~1,2F" 4321)   => "4321.00"

     If the number is complex, 'd' is applied to both real and imaginal
     parts:

          (format "~1,2F" (sqrt -3.9)) => "0.00+1.97i"

     For very large or very small numbers, the point where exponential
     notation is used is implementation defined.

          (format "~8F" 32e5)     => "   3.2e6" or "3200000.0"


File: vicare-libs.info,  Node: srfi intermediate-format examples,  Next: srfi intermediate-format copyright,  Prev: srfi intermediate-format spec,  Up: srfi intermediate-format

2.25.5 Examples
---------------

     (format "Hello, ~a" "World!")
     => "Hello, World!"

     (format "Error, list is too short: ~s" '(one "two" 3))
     => "Error, list is too short: (one \"two\" 3))"

     (format "test me")
     => "test me"

     (format "~a ~s ~a ~s" 'this 'is "a" "test")
     => "this is a \"test\""

     (format #t "#d~d #x~x #o~o #b~b~%" 32 32 32 32)
     -| #d32 #x20 #o40 #b100000
     => #<unspecified>

     (format "~a ~? ~a" 'a "~s" '(new) 'test)
     => "a new test"

     (format #f "~&1~&~&2~&~&~&3~%")
     => "
     1
     2
     3
     "

     (format #f "~a ~? ~a ~%" 3 " ~s ~s " '(2 2) 3)
     => "3  2 2  3
     "

     (format "~w" (let ( (c '(a b c)) ) (set-cdr! (cddr c) c) c))
     => "#1=(a b c . #1#)"

     (format "~8,2F" 32)
     => "   32.00"

     (format "~8,3F" (sqrt -3.8))
     => "0.000+1.949i"

     (format "~8,2F" 3.4567e11)
     => " 3.45e11"

     (format "~6,3F" 1/3)
     => " 0.333"

     (format "~4F" 12)
     => "  12"

     (format "~8,3F" 123.3456)
     => " 123.346"

      (format "~6,3F" 123.3456)
     => "123.346"

      (format "~2,3F" 123.3456)
     => "123.346"

     (format "~8,3F" "foo")
     => "     foo"

     (format "~a~a~&" (list->string (list #\newline)) "")
     => "
     "


File: vicare-libs.info,  Node: srfi intermediate-format copyright,  Prev: srfi intermediate-format examples,  Up: srfi intermediate-format

2.25.6 Copyright
----------------

Copyright (C) Kenneth A. Dickey (2003).  All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi general-cond,  Next: srfi testing,  Prev: srfi intermediate-format,  Up: srfi

2.26 SRFI-61 a more general 'cond' clause
=========================================

The library '(srfi :61)' are written by Taylor Campbell as the reference
implementation for SRFI-61; see:

            <http://srfi.schemers.org/srfi-61/srfi-61.html>

for more details.

* Menu:

* srfi general-cond license::   Original document license.
* srfi general-cond abstract::  Abstract.
* srfi general-cond rationale:: Rationale.
* srfi general-cond spec::      Specification.


File: vicare-libs.info,  Node: srfi general-cond license,  Next: srfi general-cond abstract,  Up: srfi general-cond

2.26.1 Original document license
--------------------------------

Copyright (C) 2004 Taylor Campbell.  All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi general-cond abstract,  Next: srfi general-cond rationale,  Prev: srfi general-cond license,  Up: srfi general-cond

2.26.2 Abstract
---------------

This SRFI proposes an extension to the 'cond' syntax to allow a more
general clause, one that allows binding the results of tests as in the
'=>' clauses and user-defined meaning of the success and failure of
tests.


File: vicare-libs.info,  Node: srfi general-cond rationale,  Next: srfi general-cond spec,  Prev: srfi general-cond abstract,  Up: srfi general-cond

2.26.3 Rationale
----------------

The present set of 'cond' clauses is based on simple boolean testing.
It is prohibitively inexpressive in that the condition part of a 'cond'
clause that uses '=>' may pass only a single value to the receiver, and
it enforces a semantics whereby '#f' implies failure of the condition.

   Programmers frequently use different tokens to imply failure, such as
in R5RS's I/O readers which return a distinguished "EOF object" to
denote failure, and a successful condition may produce more than one
useful value.  This simple extension allows any meaning of "failure" to
be assigned on a per-clause basis, and it also allows the condition to
return multiple values to be passed to the receiver.


File: vicare-libs.info,  Node: srfi general-cond spec,  Prev: srfi general-cond rationale,  Up: srfi general-cond

2.26.4 Specification
--------------------

The '<cond clause>' production in the formal syntax of Scheme as written
by R5RS Section 7.1.3 is extended with a new option:

     <cond clause> --->
         ...
       | (<generator> <guard> => <receiver>)

where '<generator>', '<guard>' and '<receiver>' are all '<expression>'.

   Clauses of this form have the following semantics: '<generator>' is
evaluated and it may return arbitrarily many values.  '<guard>' is
applied to an argument list containing the values in order that
'<generator>' returned.  If '<guard>' returns a true value for that
argument list, '<receiver>' is applied with an equivalent argument list.
If '<guard>' returns a false value, however, the clause is abandoned and
the next one is tried.

Examples
........

This 'port->char-list' procedure accepts an input port and returns a
list of all the characters it produces until the end.

     (define (port->char-list port)
       (cond [(read-char port)
                 char?
              => (lambda (c)
                   (cons c (port->char-list port)))]
             [else '()]))

   Consider now a hypothetical 'table-entry' procedure that accepts two
arguments, a table (perhaps a hash table) and a key to an entry that may
be in the table; it returns two values: a boolean that denotes whether
or not an entry with the given key was in the table and, if it was, the
value associated with the key.  Also, a hypothetical PROJ0 combinator
(projection of argument 0) returns its 0th argument and ignores all
others.  One might conditionally branch to a certain body of code if the
table contains the desired entry like so with the new type of 'cond'
clause:

     (cond ...
           [(table-entry <table> <key>) proj0
            => (lambda (present? value)
                 ...[VALUE is bound to the value of the entry]...)]
           ...)


File: vicare-libs.info,  Node: srfi testing,  Next: srfi compare-procedures,  Prev: srfi general-cond,  Up: srfi

2.27 SRFI-64 testing
====================

The library '(srfi :64)' is by Per Bothner as the reference
implementation for SRFI-64; see:

            <http://srfi.schemers.org/srfi-64/srfi-64.html>

for more details.

* Menu:

* srfi testing abstract::       Abstract.
* srfi testing rationale::      Rationale.
* srfi testing spec::           Specification.
* srfi testing copyright::      Copyright.


File: vicare-libs.info,  Node: srfi testing abstract,  Next: srfi testing rationale,  Up: srfi testing

2.27.1 Abstract
---------------

This SRFI defines an API for writing test suites, to make it easy to
portably test Scheme APIs, libraries, applications, and implementations.
A test suite is a collection of test cases that execute in the context
of a test-runner.  This specifications also supports writing new
test-runners, to allow customization of reporting and processing the
result of running test suites.


File: vicare-libs.info,  Node: srfi testing rationale,  Next: srfi testing spec,  Prev: srfi testing abstract,  Up: srfi testing

2.27.2 Rationale
----------------

The Scheme community needs a standard for writing test suites.  Every
SRFI or other library should come with a test suite.  Such a test suite
must be portable, without requiring any non-standard features, such as
modules.  The test suite implementation or "runner" need not be
portable, but it is desirable that it be possible to write a portable
basic implementation.

   There are other testing frameworks written in Scheme, including
SchemeUnit.  However SchemeUnit is not portable.  It is also a bit on
the verbose side.  It would be useful to have a bridge between this
framework and SchemeUnit so SchemeUnit tests could run under this
framework and vice versa.  There exists also at least one Scheme wrapper
providing a Scheme interface to the "standard" JUnit API for Java.  It
would be useful to have a bridge so that tests written using this
framework can run under a JUnit runner.  Neither of these features are
part of this specification.

   This API makes use of implicit dynamic state, including an implicit
"test runner".  This makes the API convenient and terse to use, but it
may be a little less elegant and "compositional" than using explicit
test objects, such as JUnit-style frameworks.  It is not claimed to
follow either object-oriented or functional design principles, but I
hope it is useful and convenient to use and extend.

   This proposal allows converting a Scheme source file to a test suite
by just adding a few macros.  You don't have to write the entire file in
a new form, thus you don't have to reindent it.

   All names defined by the API start with the prefix 'test-'.  All
function-like forms are defined as syntax.  They may be implemented as
functions or macros or builtins.  The reason for specifying them as
syntax is to allow specific tests to be skipped without evaluating
subexpressions, or for implementations to add features such as printing
line numbers or catching exceptions.


File: vicare-libs.info,  Node: srfi testing spec,  Next: srfi testing copyright,  Prev: srfi testing rationale,  Up: srfi testing

2.27.3 Specification
--------------------

While this is a moderately complex specification, you should be able to
write simple test suites after just reading the first few sections
below.  More advanced functionality, such as writing a custom
test-runner, is at the end of the specification.

* Menu:

* srfi testing spec basic::     Writing basic test suites.
* srfi testing spec advanced::  Conditonal test-suites and
                                other advanced features.
* srfi testing spec runner::    Test runner.
* srfi testing spec results::   Test results.
* srfi testing spec writing::   Writing a new test-runner.


File: vicare-libs.info,  Node: srfi testing spec basic,  Next: srfi testing spec advanced,  Up: srfi testing spec

2.27.3.1 Writing basic test suites
..................................

Let's start with a simple example.  This is a complete self-contained
test suite.

     ;; Initialize and give a name to a simple testsuite.
     (test-begin "vec-test")
     (define v (make-vector 5 99))

     ;; Require that an expression evaluate to true.
     (test-assert (vector? v))

     ;; Test that an expression is eqv? to some other expression.
     (test-eqv 99 (vector-ref v 2))
     (vector-set! v 2 7)
     (test-eqv 7 (vector-ref v 2))

     ;; Finish the testsuite, and report results.
     (test-end "vec-test")

   This test suite could be saved in its own source file.  Nothing else
is needed: We do not require any top-level forms, so it is easy to wrap
an existing program or test to this form, without adding indentation.
It is also easy to add new tests, without having to name individual
tests (though that is optional).

   Test cases are executed in the context of a test runner, which is a
object that accumulates and reports test results.  This specification
defines how to create and use custom test runners, but implementations
should also provide a default test runner.  It is suggested (but not
required) that loading the above file in a top-level environment will
cause the tests to be executed using an implementation-specified default
test runner, and 'test-end' will cause a summary to be displayed in an
implementation-specified manner.

Simple test-cases
.................

Primitive test cases test that a given condition is true.  They may have
a name.  The core test case form is 'test-assert'.

 -- Syntax: test-assert ?EXPRESSION
 -- Syntax: test-assert ?TEST-NAME ?EXPRESSION
     Evaluate the ?EXPRESSION.  The test passes if the result is true;
     if the result is false, a test failure is reported.  The test also
     fails if an exception is raised, assuming the implementation has a
     way to catch exceptions.

     How the failure is reported depends on the test runner environment.
     The ?TEST-NAME is a string that names the test case.  (Though the
     ?TEST-NAME is a string literal in the examples, it is an
     expression.  It is evaluated only once.)  It is used when reporting
     errors, and also when skipping tests, as described below.

     It is an error to invoke 'test-assert' if there is no current test
     runner.

   The following forms may be more convenient than using test-assert
directly:

 -- Syntax: test-eqv ?EXPECTED ?TEST-EXPR
 -- Syntax: test-eqv ?TEST-NAME ?EXPECTED ?TEST-EXPR
     This is equivalent to:

          (test-assert ?TEST-NAME (eqv? ?EXPECTED ?TEST-EXPR))

   Similarly 'test-equal' and 'test-eq' are shorthand for test-assert
combined with equal?  or eq?, respectively:

     (test-equal [test-name] expected test-expr)
     (test-eq [test-name] expected test-expr)

   Here is a simple example:

     (define (mean x y) (/ (+ x y) 2.0))
     (test-eqv 4 (mean 3 5))

   For testing approximate equality of inexact reals we can use
'test-approximate':

     (test-approximate [test-name] expected test-expr error)

   This is equivalent to (except that each argument is only evaluated
once):

     (test-assert [test-name]
       (and (>= test-expr (- expected error))
            (<= test-expr (+ expected error))))

Tests for catching errors
.........................

We need a way to specify that evaluation should fail.  This verifies
that errors are detected when required.

 -- Syntax: test-error ?TEST-EXPR
 -- Syntax: test-error ?ERROR-TYPE ?TEST-EXPR
 -- Syntax: test-error ?TEST-NAME ?ERROR-TYPE ?TEST-EXPR
     Evaluating ?TEST-EXPR is expected to signal an error.  The kind of
     error is indicated by ?ERROR-TYPE.

     If the ?ERROR-TYPE is left out, or it is '#t', it means "some kind
     of unspecified error should be signaled".  For example:

          (test-error #t (vector-ref '#(1 2) 9))

     This specification leaves it implementation-defined (or for a
     future specification) what form ?TEST-ERROR may take, though all
     implementations must allow '#t'.  Some implementations may support
     SRFI-35's conditions, but these are only standardized for SRFI-36's
     I/O conditions, which are seldom useful in test suites.  An
     implementation may also allow implementation-specific "exception
     types".  For example Java-based implementations may allow the names
     of Java exception classes:

          ;; Kawa-specific example
          (test-error <java.lang.IndexOutOfBoundsException>
            (vector-ref '#(1 2) 9))

     An implementation that cannot catch exceptions should skip
     ?TEST-ERROR forms.

Testing syntax
..............

Testing syntax is tricky, especially if we want to check that invalid
syntax is causes an error.  The following utility function can help.

 -- Function: test-read-eval-string STRING
     Parse STRING (using 'read') and evaluate the result.  The result of
     evaluation is returned by 'test-read-eval-string'.  An error is
     signalled if there are unread characters after the read is done.
     For example:

     '(test-read-eval-string "(+ 3 4)")'
          Evaluates to 7.

     '(test-read-eval-string "(+ 3 4")'
          Signals an error.

     '(test-read-eval-string "(+ 3 4) ")'
          Signals an error, because there is extra "junk" (i.e.  a
          space) after the list is read.

     The 'test-read-eval-string' used in tests:

          (test-equal 7 (test-read-eval-string "(+ 3 4)"))
          (test-error (test-read-eval-string "(+ 3"))
          (test-equal #\newline (test-read-eval-string "#\\newline"))
          (test-error (test-read-eval-string "#\\newlin"))

          ;; Skip the next 2 tests unless srfi-62 is available.
          (test-skip (cond-expand (srfi-62 0) (else 2)))
          (test-equal 5 (test-read-eval-string "(+ 1 #;(* 2 3) 4)"))
          (test-equal '(x z) (test-read-string "(list 'x #;'y 'z)"))

Test groups and paths
.....................

A test group is a named sequence of forms containing test cases,
expressions, and definitions.  Entering a group sets the test group
name; leaving a group restores the previous group name.  These are
dynamic (run time) operations, and a group has no other effect or
identity.  Test groups are informal groupings: they are neither Scheme
values, nor are they syntactic forms.

   A test group may contain nested inner test groups.  The test group
path is a list of the currently-active (entered) test group names,
oldest (outermost) first.

 -- Syntax: test-begin ?SUITE-NAME
 -- Syntax: test-begin ?SUITE-NAME ?COUNT
     Enter a new test group.  The ?SUITE-NAME becomes the current test
     group name, and is added to the end of the test group path.
     Portable test suites should use a sting literal for ?SUITE-NAME;
     the effect of expressions or other kinds of literals is
     unspecified.

          *RATIONALE* In some ways using symbols would be preferable.
          However, we want human-readable names, and standard Scheme
          does not provide a way to include spaces or mixed-case text in
          literal symbols.

     The optional ?COUNT must match the number of test cases executed by
     this group.  (Nested test groups count as a single test case for
     this count.)  This extra test may be useful to catch cases where a
     test doesn't get executed because of some unexpected error.

     Additionally, if there is no currently executing test runner, one
     is installed in an implementation-defined manner.

 -- Syntax: test-end
 -- Syntax: test-end ?SUITE-NAME
     Leave the current test group.  An error is reported if the
     ?SUITE-NAME does not match the current test group name.

     Additionally, if the matching 'test-begin' installed a new
     test-runner, then the 'test-end' will deinstall it, after reporting
     the accumulated test results in an implementation-defined manner.

 -- Syntax: test-group ?SUITE-NAME ?DECL-OR-EXPR ...
     Equivalent to:

          (if (not (test-to-skip% ?SUITE-NAME))
            (dynamic-wind
              (lambda () (test-begin ?SUITE-NAME))
              (lambda () ?DECL-OR-EXPR ...)
              (lambda () (test-end ?SUITE-NAME))))

     This is usually equivalent to executing the ?DECL-OR-EXPRS within
     the named test group.  However, the entire group is skipped if it
     matched an active 'test-skip' (see later).  Also, the 'test-end' is
     executed in case of an exception.

Handling set-up and cleanup
...........................

 -- Syntax: test-group-with-cleanup ?SUITE-NAME ?DECL-OR-EXPR ...
          ?CLEANUP-FORM
     Execute each of the ?DECL-OR-EXPR forms in order (as in a
     '<body>'), and then execute the ?CLEANUP-FORM.  The latter should
     be executed even if one of a ?DECL-OR-EXPR forms raises an
     exception (assuming the implementation has a way to catch
     exceptions).

     For example:

          (test-group-with-cleanup "test-file"
            (define f (open-output-file "log"))
            (do-a-bunch-of-tests f)
            (close-output-port f))


File: vicare-libs.info,  Node: srfi testing spec advanced,  Next: srfi testing spec runner,  Prev: srfi testing spec basic,  Up: srfi testing spec

2.27.3.2 Conditonal test-suites and other advanced features
...........................................................

The following describes features for controlling which tests to execute,
or specifing that some tests are expected to fail.

Test specifiers
...............

Sometimes we want to only run certain tests, or we know that certain
tests are expected to fail.  A test specifier is a one-argument function
that takes a test-runner and returns a boolean.  The specifier may be
run before a test is performed, and the result may control whether the
test is executed.  For convenience, a specifier may also be a
non-procedure value, which is coerced to a specifier procedure, as
described below for count and name.

   A simple example is:

     (if some-condition
       (test-skip 2)) ;; skip next 2 tests

 -- Function: test-match-name NAME
     The resulting specifier matches if the current test name (as
     returned by 'test-runner-test-name') is 'equal?' to name.

 -- Function: test-match-nth N
 -- Function: test-match-nth N COUNT
     Evaluate to a stateful predicate: A counter keeps track of how many
     times it has been called.  The predicate matches the N'th time it
     is called (where 1 is the first time), and the next '(- COUNT 1)'
     times, where count defaults to 1.

 -- Function: test-match-any SPECIFIER ...
     The resulting specifier matches if any specifier matches.  Each
     specifier is applied, in order, so side-effects from a later
     specifier happen even if an earlier specifier is true.

 -- Function: test-match-all SPECIFIER ...
     The resulting specifier matches if each specifier matches.  Each
     specifier is applied, in order, so side-effects from a later
     specifier happen even if an earlier specifier is false.

     COUNT
          An integer.  Convenience short-hand for:

               (test-match-nth 1 COUNT)

     NAME
          A string.  Convenience short-hand for:

               (test-match-name NAME)

Skipping selected tests
.......................

In some cases you may want to skip a test.

 -- Syntax: test-skip ?SPECIFIER
     Evaluating 'test-skip' adds the resulting specifier to the set of
     currently active skip-specifiers.  Before each test (or test-group)
     the set of active skip-specifiers are applied to the active
     test-runner.  If any specifier matches, then the test is skipped.

     For convenience, if the specifier is a string that is syntactic
     sugar for '(test-match-name specifier)'.  For example:

          (test-skip "test-b")
          (test-assert "test-a")   ;; executed
          (test-assert "test-b")   ;; skipped

     Any skip specifiers introduced by a test-skip are removed by a
     following non-nested 'test-end'.

          (test-begin "group1")
          (test-skip "test-a")
          (test-assert "test-a")   ;; skipped
          (test-end "group1")      ;; Undoes the prior test-skip
          (test-assert "test-a")   ;; executed

Expected failures
.................

Sometimes you know a test case will fail, but you don't have time to or
can't fix it.  Maybe a certain feature only works on certain platforms.
However, you want the test-case to be there to remind you to fix it.
You want to note that such tests are expected to fail.

 -- Syntax: test-expect-fail ?SPECIFIER
     Matching tests (where matching is defined as in 'test-skip') are
     expected to fail.  This only affects test reporting, not test
     execution.  For example:

          (test-expect-fail 2)
          (test-eqv ...) ;; expected to fail
          (test-eqv ...) ;; expected to fail
          (test-eqv ...) ;; expected to pass


File: vicare-libs.info,  Node: srfi testing spec runner,  Next: srfi testing spec results,  Prev: srfi testing spec advanced,  Up: srfi testing spec

2.27.3.3 Test runner
....................

A _test-runner_ is an object that runs a test-suite, and manages the
state.  The test group path, and the sets skip and expected-fail
specifiers are part of the _test-runner_.  A _test-runner_ will also
typically accumulate statistics about executed tests,

 -- Function: test-runner? VALUE
     True iff value is a test-runner object.

 -- Function: test-runner-current
 -- Function: test-runner-current RUNNER
     Get or set the current test-runner.  If an implementation supports
     parameter objects (as in SRFI-39), then 'test-runner-current' can
     be a parameter object.  Alternatively, 'test-runner-current' may be
     implemented as a macro or function that uses a fluid or
     thread-local variable, or a plain global variable.

 -- Function: test-runner-get
     Same as '(test-runner-current)', buth throws an exception if there
     is no current test-runner.

 -- Function: test-runner-simple
     Create a new simple test-runner, that prints errors and a summary
     on the standard output port.

 -- Function: test-runner-null
     Create a new test-runner, that does nothing with the test results.
     This is mainly meant for extending when writing a custom runner.

   Implementations may provide other test-runners, perhaps a
'(test-runner-gui)'.

 -- Function: test-runner-create
     Create a new test-runner.  Equivalent to:

          ((test-runner-factory))

 -- Function: test-runner-factory
 -- Function: test-runner-factory FACTORY
     Get or set the current test-runner factory.  A factory is a
     zero-argument function that creates a new test-runner.  The default
     value is 'test-runner-simple', but implementations may provide a
     way to override the default.  As with 'test-runner-current', this
     may be a parameter object, or use a per-thread, fluid, or global
     variable.

Running specific tests with a specified runner
..............................................

 -- Function: test-apply SPECIFIER ... PROCEDURE
 -- Function: test-apply RUNNER SPECIFIER ... PROCEDURE
     Call PROCEDURE with no arguments using the specified RUNNER as the
     current test-runner.  If RUNNER is omitted, then
     '(test-runner-current)' is used.  (If there is no current runner,
     one is created as in 'test-begin'.)

     If one or more specifiers are listed then only tests matching the
     specifiers are executed.  A specifier has the same form as one used
     for 'test-skip'.  A test is executed if it matches any of the
     specifiers in the 'test-apply' and does not match any active
     'test-skip' specifiers.

 -- Function: test-with-runner RUNNER DECL-OR-EXPR ...
     Execute each DECL-OR-EXPR in order in a context where the current
     test-runner is runner.


File: vicare-libs.info,  Node: srfi testing spec results,  Next: srfi testing spec writing,  Prev: srfi testing spec runner,  Up: srfi testing spec

2.27.3.4 Test results
.....................

Running a test sets various status properties in the current
test-runner.  This can be examined by a custom test-runner, or (more
rarely) in a test-suite.

Result kind
...........

Running a test may yield one of the following status symbols:

'pass'
     The passed, as expected.

'fail'
     The test failed (and was not expected to).

'xfail'
     The test failed and was expected to.

'xpass'
     The test passed, but was expected to fail.

'skip'
     The test was skipped.

 -- Function: test-result-kind
 -- Function: test-result-kind RUNNER
     Return one of the above result codes from the most recent tests.
     Return '#f' if no tests have been run yet.  If we've started on a
     new test, but don't have a result yet, then the result kind is
     'xfail' is the test is expected to fail, 'skip' is the test is
     supposed to be skipped, or '#f' otherwise.

 -- Function: test-passed?
 -- Function: test-passed? RUNNER
     True if the value of:

          (test-result-kind)
          (test-result-kind RUNNER)

     is one of 'pass' or 'xpass'.  This is a convenient shorthand that
     might be useful in a test suite to only run certain tests if the
     previous test passed.

Test result properties
......................

A test runner also maintains a set of more detailed "result properties"
associated with the current or most recent test.  (I.e.  the properties
of the most recent test are available as long as a new test hasn't
started.)  Each property has a name (a symbol) and a value (any value).
Some properties are standard or set by the implementation;
implementations can add more.

 -- Function: test-result-ref RUNNER PNAME
 -- Function: test-result-ref RUNNER PNAME DEFAULT
     Return the property value associated with the PNAME property name.
     If there is no value associated with PNAME return DEFAULT, or '#f'
     if default isn't specified.

 -- Function: test-result-set! RUNNER PNAME VALUE
     Set the property value associated with the PNAME property name to
     VALUE.  Usually implementation code should call this function, but
     it may be useful for a custom test-runner to add extra properties.

 -- Function: test-result-remove RUNNER PNAME
     Remove the property with the name PNAME.

 -- Function: test-result-clear RUNNER
     Remove all result properties.  The implementation automatically
     calls 'test-result-clear' at the start of a 'test-assert' and
     similar procedures.

 -- Function: test-result-alist RUNNER
     Return an association list of the current result properties.  It is
     unspecified if the result shares state with the test-runner.  The
     result should not be modified, on the other hand the result may be
     implicitly modified by future 'test-result-set!' or
     'test-result-remove' calls.  However, a 'test-result-clear' does
     not modify the returned alist.  Thus you can "archive" result
     objects from previous runs.

Standard result properties
..........................

The set of available result properties is implementation-specific.
However, it is suggested that the following might be provided:

'result-kind'
     The result kind, as defined previously.  This is the only mandatory
     result property.

          (test-result-kind RUNNER)
          == (test-result-ref RUNNER 'result-kind)

'source-file'
'source-line'
     If known, the location of test statements (such as 'test-assert')
     in test suite source code.

'source-form'
     The source form, if meaningful and known.

'expected-value'
     The expected non-error result, if meaningful and known.

'expected-error'
     The error-type specified in a test-error, if it meaningful and
     known.

'actual-value'
     The actual non-error result value, if meaningful and known.

'actual-error'
     The error value, if an error was signalled and it is known.  The
     actual error value is implementation-defined.


File: vicare-libs.info,  Node: srfi testing spec writing,  Prev: srfi testing spec results,  Up: srfi testing spec

2.27.3.5 Writing a new test-runner
..................................

This section specifies how to write a test-runner.  It can be ignored if
you just want to write test cases.

Callback functions
..................

These callback functions are "methods"" (in the object-oriented sense)
of a test-runner.  A method 'test-runner-on-event' is called by the
implementation when event happens.

   To define (set) the callback function for event use the following
expression.  (This is normally done when initializing a test-runner.)

     (test-runner-on-event! RUNNER EVENT-FUNCTION)

   An EVENT-FUNCTION takes a test-runner argument, and possibly other
arguments, depending on the event.

   To extract (get) the callback function for event do this:

     (test-runner-on-event RUNNER)

   To extract call the callback function for event use the following
expression.  (This is normally done by the implementation core.)

     ((test-runner-on-event RUNNER) RUNNER OTHER-ARGS ...)

   The following callback hooks are available.

 -- Function: test-runner-on-test-begin RUNNER
 -- Function: test-runner-on-test-begin! RUNNER ON-TEST-BEGIN-FUNCTION
 -- Function: on-test-begin-function RUNNER
     The ON-TEST-BEGIN-FUNCTION is called at the start of an individual
     testcase, before the test expression (and expected value) are
     evaluated.

 -- Function: test-runner-on-test-end RUNNER
 -- Function: test-runner-on-test-end! RUNNER ON-TEST-END-FUNCTION
 -- Function: on-test-end-function RUNNER
     The ON-TEST-END-FUNCTION is called at the end of an individual
     testcase, when the result of the test is available.

 -- Function: test-runner-on-group-begin RUNNER
 -- Function: test-runner-on-group-begin! RUNNER ON-GROUP-BEGIN-FUNCTION
 -- Function: on-group-begin-function RUNNER SUITE-NAME COUNT
     The ON-GROUP-BEGIN-FUNCTION is called by a 'test-begin', including
     at the start of a 'test-group'.  The SUITE-NAME is a Scheme string,
     and COUNT is an integer or '#f'.

 -- Function: test-runner-on-group-end RUNNER
 -- Function: test-runner-on-group-end! RUNNER ON-GROUP-END-FUNCTION
 -- Function: on-group-end-function RUNNER
     The ON-GROUP-END-FUNCTION is called by a 'test-end', including at
     the end of a 'test-group'.

 -- Function: test-runner-on-bad-count RUNNER
 -- Function: test-runner-on-bad-count! RUNNER ON-BAD-COUNT-FUNCTION
 -- Function: on-bad-count-function RUNNER ACTUAL-COUNT EXPECTED-COUNT
     Called from 'test-end' (before the ON-GROUP-END-FUNCTION is called)
     if an EXPECTED-COUNT was specified by the matching 'test-begin' and
     the EXPECTED-COUNT does not match the ACTUAL-COUNT of tests
     actually executed or skipped.

 -- Function: test-runner-on-bad-end-name RUNNER
 -- Function: test-runner-on-bad-end-name! RUNNER
          ON-BAD-END-NAME-FUNCTION
 -- Function: on-bad-end-name-function RUNNER BEGIN-NAME END-NAME
     Called from 'test-end' (before the ON-GROUP-END-FUNCTION is called)
     if a SUITE-NAME was specified, and it did not that the name in the
     matching 'test-begin'.

 -- Function: test-runner-on-final RUNNER
 -- Function: test-runner-on-final! RUNNER ON-FINAL-FUNCTION
 -- Function: on-final-function RUNNER
     The ON-FINAL-FUNCTION takes one parameter (a test-runner) and
     typically displays a summary (count) of the tests.  The
     ON-FINAL-FUNCTION is called after called the ON-GROUP-END-FUNCTION
     correspondiong to the outermost 'test-end'.  The default value is
     'test-on-final-simple' which writes to the standard output port the
     number of tests of the various kinds.

   The default test-runner returned by 'test-runner-simple' uses the
following callback functions:

     (test-on-test-begin-simple RUNNER)
     (test-on-test-end-simple RUNNER)
     (test-on-group-begin-simple RUNNER SUITE-NAME COUNT)
     (test-on-group-end-simple RUNNER)
     (test-on-bad-count-simple RUNNER ACTUAL-COUNT EXPECTED-COUNT)
     (test-on-bad-end-name-simple RUNNER BEGIN-NAME END-NAME)

   You can call those if you want to write your own test-runner.

Test-runner components
......................

The following functions are for accessing the other components of a
test-runner.  They would normally only be used to write a new
test-runner or a match-predicate.

 -- Function: test-runner-pass-count RUNNER
     Return the number of tests that passed, and were expected to pass.

 -- Function: test-runner-fail-count RUNNER
     Return the number of tests that failed, but were expected to pass.

 -- Function: test-runner-xpass-count RUNNER
     Return the number of tests that passed, but were expected to fail.

 -- Function: test-runner-xfail-count RUNNER
     Returns the number of tests that failed, and were expected to pass.

 -- Function: test-runner-skip-count RUNNER
     Return the number of tests or test groups that were skipped.

 -- Function: test-runner-test-name RUNNER
     Return the name of the current test or test group, as a string.
     During execution of 'test-begin' this is the name of the test
     group; during the execution of an actual test, this is the name of
     the test-case.  If no name was specified, the name is the empty
     string.

 -- Function: test-runner-group-path RUNNER
     A list of names of groups we're nested in, with the outermost group
     first.

 -- Function: test-runner-group-stack RUNNER
     A list of names of groups we're nested in, with the outermost group
     last.  (This is more efficient than 'test-runner-group-path', since
     it doesn't require any copying.)

 -- Function: test-runner-aux-value RUNNER
 -- Function: test-runner-aux-value! RUNNER ON-TEST
     Get or set the AUX-value field of a test-runner.  This field is not
     used by this API or the 'test-runner-simple' test-runner, but may
     be used by custom test-runners to store extra state.

 -- Function: test-runner-reset RUNNER
     Reset the state of the runner to its initial state.

Example
.......

This is an example of a simple custom test-runner.  Loading this program
before running a test-suite will install it as the default test runner.

     (define (my-simple-runner filename)
       (let ((runner (test-runner-null))
     	(port (open-output-file filename))
             (num-passed 0)
             (num-failed 0))
         (test-runner-on-test-end! runner
           (lambda (runner)
             (case (test-result-kind runner)
               ((pass xpass) (set! num-passed (+ num-passed 1)))
               ((fail xfail) (set! num-failed (+ num-failed 1)))
               (else #t))))
         (test-runner-on-final! runner
            (lambda (runner)
               (format port "Passing tests: ~d.~%Failing tests: ~d.~%"
                       num-passed num-failed)
     	  (close-output-port port)))
         runner))

     (test-runner-factory
      (lambda () (my-simple-runner "/tmp/my-test.log")))


File: vicare-libs.info,  Node: srfi testing copyright,  Prev: srfi testing spec,  Up: srfi testing

2.27.4 Copyright
----------------

Copyright (C) 2005, 2006 Per Bothner.

   Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: vicare-libs.info,  Node: srfi compare-procedures,  Next: srfi hash-tables,  Prev: srfi testing,  Up: srfi

2.28 SRFI-67 compare procedures
===============================

The library '(srfi :67)' is by Sebastian Egner and Jens Axel Soegaard as
the reference implementation for SRFI-67; see:

            <http://srfi.schemers.org/srfi-67/srfi-67.html>

for more details.

* Menu:

* srfi compare-procedures copyright::   Copyright.
* srfi compare-procedures abstract::    Abstract and rationale.
* srfi compare-procedures intro::       Introduction.
* srfi compare-procedures conv::        Terminology and conventions.
* srfi compare-procedures spec::        Specification.
* srfi compare-procedures design::      Design rationale.
* srfi compare-procedures related::     Related work.
* srfi compare-procedures refs::        References.

