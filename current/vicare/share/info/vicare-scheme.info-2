This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: baselib math ops trascend,  Next: baselib math ops exponentiation,  Prev: baselib math ops part,  Up: baselib math ops

4.6.4.7 Trascendental functions
...............................

 -- Procedure: exp Z
 -- Procedure: log Z
 -- Procedure: log Z1 Z2
 -- Procedure: sin Z
 -- Procedure: cos Z
 -- Procedure: tan Z
 -- Procedure: asin Z
 -- Procedure: acos Z
 -- Procedure: atan Z
 -- Procedure: atan X1 X2
     These procedures compute the usual transcendental functions.

     The 'exp' procedure computes the base-E exponential of Z.

     The 'log' procedure with a single argument computes the natural
     logarithm of Z (*not* the base-10 logarithm); '(log Z1 Z2)'
     computes the base-Z2 logarithm of Z1.

     The 'asin', 'acos', and 'atan' procedures compute arcsine,
     arccosine, and arctangent, respectively.  The two-argument variant
     of 'atan' computes:

          (angle (make-rectangular X2 X1))

     These procedures may return inexact results even when given exact
     arguments.

          (exp +inf.0)    => +inf.0
          (exp -inf.0)    => 0.0
          (log +inf.0)    => +inf.0
          (log 0.0)       => -inf.0
          (log 0)         => exception &assertion

          (log -inf.0)    => +inf.0+3.141592653589793i
                          ; approximately

          (atan -inf.0)   => -1.5707963267948965
                          ; approximately

          (atan +inf.0)   => 1.5707963267948965
                          ; approximately

          (log -1.0+0.0i) => 0.0+3.141592653589793i
                          ; approximately

          (log -1.0-0.0i) => 0.0-3.141592653589793i
                          ; approximately if -0.0 is distinguished


File: vicare-scheme.info,  Node: baselib math ops exponentiation,  Next: baselib math ops complex,  Prev: baselib math ops trascend,  Up: baselib math ops

4.6.4.8 Exponentiation functions
................................

 -- Procedure: sqrt Z
     Return the principal square root of Z.  For rational Z, the result
     has either positive real part, or zero real part and non-negative
     imaginary part.  With \log defined as in *note baselib math
     semantics trascend::, the value of '(sqrt Z)' could be expressed as
     e^{(\log z)/2}.

     The 'sqrt' procedure may return an inexact result even when given
     an exact argument.

          (sqrt -5)               => 0.0+2.23606797749979i
                                  ; approximately
          (sqrt +inf.0)           => +inf.0
          (sqrt -inf.0)           => +inf.0i

 -- Procedure: exact-integer-sqrt K
     The 'exact-integer-sqrt' procedure returns two non-negative exact
     integer objects s and r where K = s^2 + r and K < (s+1)^2.

          (exact-integer-sqrt 4)  => 2 0 ; two return values
          (exact-integer-sqrt 5)  => 2 1 ; two return values

 -- Procedure: expt Z1 Z2
     Return Z1 raised to the power Z2.  For non-zero Z1, this is e^{(z_2
     \log z_1)}.  0.0^z is 1.0 if Z = 0.0, and 0.0 if '(real-part Z)' is
     positive.  For other cases in which the first argument is zero,
     either an exception is raised with condition type
     '&implementation-restriction', or an unspecified number object is
     returned.

     For an exact real number object Z1 and an exact integer object Z2,
     '(expt Z1 Z2)' must return an exact result.  For all other values
     of Z1 and Z2, '(expt Z1 Z2)' may return an inexact result, even
     when both Z1 and Z2 are exact.

          (expt 5 3)                  => 125
          (expt 5 -3)                 => 1/125
          (expt 5 0)                  => 1
          (expt 0 5)                  => 0
          (expt 0 5+.0000312i)        => 0.0
          (expt 0 -5)                 => unspecified
          (expt 0 -5+.0000312i)       => unspecified
          (expt 0 0)                  => 1
          (expt 0.0 0.0)              => 1.0


File: vicare-scheme.info,  Node: baselib math ops complex,  Prev: baselib math ops exponentiation,  Up: baselib math ops

4.6.4.9 Complex numbers functions
.................................

 -- Procedure: make-rectangular X1 X2
 -- Procedure: make-polar X3 X4
 -- Procedure: real-part Z
 -- Procedure: imag-part Z
 -- Procedure: magnitude Z
 -- Procedure: angle Z
     Suppose a_1, a_2, a_3, and a_4 are real numbers, and c is a complex
     number such that the following holds:

          c = a_1 + a_2 i = a_3 e^(i a_4)

     Then, if X1, X2, X3, and X4 are number objects representing a_1,
     a_2, a_3, and a_4, respectively, '(make-rectangular X1 X2)' returns
     c, and '(make-polar X3 X4)' returns c.

          (make-rectangular 1.1 2.2)    => 1.1+2.2i ; approximately
          (make-polar 1.1 2.2)          => 1.1@2.2 ; approximately

     Conversely, if -\pi <= a_4 <= \pi, and if z is a number object
     representing c, then '(real-part Z)' returns a_1, '(imag-part Z)'
     returns a_2, '(magnitude Z)' returns a_3, and '(angle Z)' returns
     a_4.

          (real-part 1.1+2.2i)    => 1.1
                                  ; approximately
          (imag-part 1.1+2.2i)    => 2.2
                                  ; approximately
          (magnitude 1.1@2.2)     => 1.1
                                  ; approximately
          (angle     1.1@2.2)     => 2.2
                                  ; approximately

          (angle -1.0)            => 3.141592653589793
                                  ; approximately
          (angle -1.0+0.0i)       => 3.141592653589793
                                  ; approximately
          (angle -1.0-0.0i)       => -3.141592653589793
                                  ; approximately if -0.0 is distinguished
          (angle +inf.0)          => 0.0
          (angle -inf.0)          => 3.141592653589793
                                  ; approximately

     Moreover, suppose X1, X2 are such that either X1 or X2 is an
     infinity, then

          (make-rectangular x1 x2)        => Z
          (magnitude z)                   => +inf.0

     The 'make-polar', 'magnitude', and 'angle' procedures may return
     inexact results even when given exact arguments.

          (angle -1)              => 3.141592653589793
                                  ; approximately


File: vicare-scheme.info,  Node: baselib math string,  Prev: baselib math ops,  Up: baselib math

4.6.5 Numerical Input and Output
--------------------------------

 -- Procedure: number->string Z
 -- Procedure: number->string Z RADIX
 -- Procedure: number->string Z RADIX PRECISION
     The 'number->string' procedure takes a number object and a radix
     and returns as a string an external representation of the given
     number object in the given radix such that:

          (let ((number Z)
                (radix  RADIX))
            (eqv?
              (string->number (number->string number radix) radix)
              number))

     is true.  If no possible result makes this expression true, an
     exception with condition type '&implementation-restriction' is
     raised.

     RADIX must be an exact integer object, either 2, 8, 10, or 16.  If
     omitted, RADIX defaults to 10.  If a PRECISION is specified, then Z
     must be an inexact complex number object, PRECISION must be an
     exact positive integer object, and RADIX must be 10.

          *NOTE* The error case can occur only when Z is not a complex
          number object or is a complex number object with a
          non-rational real or imaginary part.

     If a PRECISION is specified, then the representations of the
     inexact real components of the result, unless they are infinite or
     NaN, specify an explicit ?MANTISSA-WIDTH p, and p is the least p >=
     PRECISION for which the above expression is true.

     If Z is inexact, the radix is 10, and the above expression and
     condition can be satisfied by a result that contains a decimal
     point, then the result contains a decimal point and is expressed
     using the minimum number of digits (exclusive of exponent, trailing
     zeroes, and mantissa width) needed to make the above expression and
     condition true; otherwise the format of the result is unspecified.

     The result returned by 'number->string' never contains an explicit
     radix prefix.

 -- Procedure: string->number STRING
 -- Procedure: string->number STRING RADIX
     Return a number object with maximally precise representation
     expressed by the given STRING.

     RADIX must be an exact integer object, either 2, 8, 10, or 16.  If
     supplied, RADIX is a default radix that may be overridden by an
     explicit radix prefix in STRING (e.g.  '#o177').  If RADIX is not
     supplied, then the default radix is 10.

     If STRING is not a syntactically valid notation for a number object
     or a notation for a rational number object with a zero denominator,
     then 'string->number' returns '#f'.

          (string->number "100")          => 100
          (string->number "100" 16)       => 256
          (string->number "1e2")          => 100.0
          (string->number "0/0")          => #f
          (string->number "+inf.0")       => +inf.0
          (string->number "-inf.0")       => -inf.0
          (string->number "+nan.0")       => +nan.0

          *NOTE* The 'string->number' procedure always returns a number
          object or '#f'; it never raises an exception.


File: vicare-scheme.info,  Node: baselib booleans,  Next: baselib lists,  Prev: baselib math,  Up: baselib

4.7 Booleans
============

The standard boolean objects for true and false have external
representations '#t' and '#f'.  However, of all objects, only '#f'
counts as false in conditional expressions.

     *NOTE* Programmers accustomed to other dialects of Lisp should be
     aware that Scheme distinguishes both '#f' and the empty list from
     each other and from the symbol 'nil'.

 -- Procedure: not OBJ
     Return '#t' if OBJ is '#f', or '#f' otherwise.

          (not #t)         => #f
          (not 3)          => #f
          (not (list 3))   => #f
          (not #f)         => #t
          (not '())        => #f
          (not (list))     => #f
          (not 'nil)       => #f

 -- Procedure: boolean? OBJ
     Return '#t' if OBJ is either '#t' or '#f', or '#f' otherwise.

          (boolean? #f)   => #t
          (boolean? 0)    => #f
          (boolean? '())  => #f

 -- Procedure: boolean=? BOOL1 BOOL2 BOOL3 ...
     Return '#t' if the booleans are the same.


File: vicare-scheme.info,  Node: baselib lists,  Next: baselib symbols,  Prev: baselib booleans,  Up: baselib

4.8 Pairs and lists
===================

A _pair_ is a compound structure with two fields called the car and cdr
fields (for historical reasons).  Pairs are created by the procedure
'cons'.  The car and cdr fields are accessed by the procedures 'car' and
'cdr'.

   Pairs are used primarily to represent lists.  A list can be defined
recursively as either the empty list or a pair whose cdr is a list.
More precisely, the set of lists is defined as the smallest set X such
that:

   * The empty list is in X.

   * If LIST is in X, then any pair whose cdr field contains LIST is
     also in X.

   The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list.  The length of a list is the
number of elements, which is the same as the number of pairs.

   The empty list is a special object of its own type.  It is not a
pair.  It has no elements and its length is zero.

     *NOTE* The above definitions imply that all lists have finite
     length and are terminated by the empty list.

   A chain of pairs not ending in the empty list is called an _improper
list_.  Note that an improper list is not a list.  The list and dotted
notations can be combined to represent improper lists:

     (a b c . d)

is equivalent to

     (a . (b . (c . d)))

   Whether a given pair is a list depends upon what is stored in the cdr
field.

 -- Procedure: pair? OBJ
     Return '#t' if OBJ is a pair, '#f' otherwise.

          (pair? '(a . b))        => #t
          (pair? '(a b c))        => #t
          (pair? '())             => #f
          (pair? '#(a b))         => #f

 -- Procedure: cons OBJ1 OBJ2
     Return a newly allocated pair whose car is OBJ1 and whose cdr is
     OBJ2.  The pair is guaranteed to be different (in the sense of
     'eqv?') from every existing object.

          (cons 'a '())           =>  (a)
          (cons '(a) '(b c d))    =>  ((a) b c d)
          (cons "a" '(b c))       =>  ("a" b c)
          (cons 'a 3)             =>  (a . 3)
          (cons '(a b) 'c)        =>  ((a b) . c)

 -- Procedure: car PAIR
     Return the contents of the car field of PAIR.

          (car '(a b c))          => a
          (car '((a) b c d))      => (a)
          (car '(1 . 2))          => 1
          (car '())               => exception &assertion

 -- Procedure: cdr PAIR
     Return the contents of the cdr field of PAIR.

          (cdr '((a) b c d))      => (b c d)
          (cdr '(1 . 2))          => 2
          (cdr '())               => exception &assertion

 -- Procedure: caar PAIR
 -- Procedure: cadr PAIR
 -- Procedure: ...
 -- Procedure: cdddar PAIR
 -- Procedure: cddddr PAIR
     These procedures are compositions of 'car' and 'cdr', where for
     example 'caddr' could be defined by

          (define caddr (lambda (x) (car (cdr (cdr x)))))

     Arbitrary compositions, up to four deep, are provided.  There are
     twenty-eight of these procedures in all.

 -- Procedure: null? OBJ
     Return '#t' if OBJ is the empty list, '#f' otherwise.

 -- Procedure: list? OBJ
     Return '#t' if OBJ is a list, '#f' otherwise.  By definition, all
     lists are chains of pairs that have finite length and are
     terminated by the empty list.

          (list? '(a b c))     => #t
          (list? '())          => #t
          (list? '(a . b))     => #f

 -- Procedure: list OBJ ...
     Return a newly allocated list of its arguments.

          (list 'a (+ 3 4) 'c)    => (a 7 c)
          (list)                  => ()

 -- Procedure: length LIST
     Return the length of LIST.

          (length '(a b c))               =>  3
          (length '(a (b) (c d e)))       =>  3
          (length '())                    =>  0

 -- Procedure: append
 -- Procedure: append LIST ... OBJ
     Return a possibly improper list consisting of the elements of the
     first LIST followed by the elements of the other LISTs, with OBJ as
     the cdr of the final pair.  An improper list results if OBJ is not
     a list.

          (append '(x) '(y))              =>  (x y)
          (append '(a) '(b c d))          =>  (a b c d)
          (append '(a (b)) '((c)))        =>  (a (b) (c))
          (append '(a b) '(c . d))        =>  (a b c . d)
          (append '() 'a)                 =>  a

     If 'append' constructs a non-empty chain of pairs, it is always
     newly allocated.  If no pairs are allocated, OBJ is returned.

          R6RS mandates that this function requires at least the
          argument OBJ; it is illegal to call this function with no
          arguments.  Despite this: The Scheme implementations supported
          by Nausicaa (Mosh, Petite Chez, Vicare, Ypsilon) allow calling
          this function with no arguments, in which case the return
          value is the empty string.  The '(nausicaa)' language will
          ensure this behaviour.  (Fri Jun 5, 2009)

 -- Procedure: reverse LIST
     Return a newly allocated list consisting of the elements of LIST in
     reverse order.

          (reverse '(a b c))              => (c b a)
          (reverse '(a (b c) d (e (f))))  => ((e (f)) d (b c) a)

 -- Procedure: list-tail LIST K
     LIST should be a list of size at least K.  Return the subchain of
     pairs of LIST obtained by omitting the first K elements.

          (list-tail '(a b c d) 2)        =>  (c d)

     *Implementation responsibilities:* The implementation must check
     that LIST is a chain of pairs whose length is at least K.  It
     should not check that it is a chain of pairs beyond this length.

 -- Procedure: list-ref LIST K
     LIST must be a list whose length is at least _K + 1_.  The
     'list-tail' procedure returns the Kth element of LIST.

          (list-ref '(a b c d) 2)         => c

     *Implementation responsibilities:* The implementation must check
     that LIST is a chain of pairs whose length is at least _K + 1_.  It
     should not check that it is a list of pairs beyond this length.

 -- Procedure: map PROC LIST1 LIST2 ...
     The LISTs should all have the same length.  PROC should accept as
     many arguments as there are LISTs and return a single value.  PROC
     should not mutate any of the LISTs.

     The 'map' procedure applies PROC element-wise to the elements of
     the LISTs and returns a list of the results, in order.  PROC is
     always called in the same dynamic environment as 'map' itself.  The
     order in which PROC is applied to the elements of the LISTs is
     unspecified.  If multiple returns occur from 'map', the values
     returned by earlier returns are not mutated.

          (map cadr '((a b) (d e) (g h)))         =>  (b e h)

          (map (lambda (n) (expt n n))
               '(1 2 3 4 5))                      =>  (1 4 27 256 3125)

          (map + '(1 2 3) '(4 5 6))               =>  (5 7 9)

          (let ((count 0))
            (map (lambda (ignored)
                   (set! count (+ count 1))
                   count)
                 '(a b)))                         =>  (1 2) or (2 1)

     *Implementation responsibilities:* The implementation should check
     that the LISTs all have the same length.  The implementation must
     check the restrictions on PROC to the extent performed by applying
     it as described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: for-each PROC LIST1 LIST2 ...
     The LISTs should all have the same length.  PROC should accept as
     many arguments as there are LISTs.  PROC should not mutate any of
     the LISTs.

     The 'for-each' procedure applies PROC element-wise to the elements
     of the LISTs for its side effects, in order from the first elements
     to the last.  PROC is always called in the same dynamic environment
     as 'for-each' itself.  The return values of 'for-each' are
     unspecified.

          (let ((v (make-vector 5)))
            (for-each (lambda (i)
                        (vector-set! v i (* i i)))
                      '(0 1 2 3 4))
            v)
          =>  #(0 1 4 9 16)

          (for-each (lambda (x) x) '(1 2 3 4))
          => unspecified

          (for-each even? '())
          => unspecified

     *Implementation responsibilities:* The implementation should check
     that the LISTs all have the same length.  The implementation must
     check the restrictions on PROC to the extent performed by applying
     it as described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

          *NOTE* Implementations of 'for-each' may or may not tail-call
          PROC on the last elements.


File: vicare-scheme.info,  Node: baselib symbols,  Next: baselib characters,  Prev: baselib lists,  Up: baselib

4.9 Symbols
===========

Symbols are objects whose usefulness rests on the fact that two symbols
are identical (in the sense of 'eq?', 'eqv?' and 'equal?') if and only
if their names are spelled the same way.  A symbol literal is formed
using 'quote'.

 -- Procedure: symbol? OBJ
     Return '#t' if OBJ is a symbol, '#f' otherwise.

          (symbol? 'foo)          => #t
          (symbol? (car '(a b)))  => #t
          (symbol? "bar")         => #f
          (symbol? 'nil)          => #t
          (symbol? '())           => #f
          (symbol? #f)            => #f

 -- Procedure: symbol->string SYMBOL
     Return the name of SYMBOL as an immutable string.

          (symbol->string 'flying-fish)                   =>  "flying-fish"
          (symbol->string 'Martin)                        =>  "Martin"
          (symbol->string (string->symbol "Malvina"))     =>  "Malvina"

 -- Procedure: symbol=? SYMBOL1 SYMBOL2 SYMBOL3 ...
     Return '#t' if the symbols are the same, i.e., if their names are
     spelled the same.

 -- Procedure: string->symbol STRING
     Return the symbol whose name is STRING.

          (eq? 'mISSISSIppi 'mississippi)
          => #f

          (string->symbol "mISSISSIppi")
          => the symbol with name "mISSISSIppi"

          (eq? 'bitBlt (string->symbol "bitBlt"))
          => #t

          (eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
          => #t

          (string=? "K. Harper, M.D."
                    (symbol->string (string->symbol "K. Harper, M.D.")))
          => #t


File: vicare-scheme.info,  Node: baselib characters,  Next: baselib strings,  Prev: baselib symbols,  Up: baselib

4.10 Characters
===============

The "characters" are objects that represent Unicode scalar values.

     Unicode defines a standard mapping between sequences of _Unicode
     scalar values_ (integers in the range 0 to '#x10FFFF', excluding
     the range '#xD800' to '#xDFFF') in the latest version of the
     standard and human-readable "characters".

     More precisely, Unicode distinguishes between glyphs, which are
     printed for humans to read, and characters, which are abstract
     entities that map to glyphs (sometimes in a way that's sensitive to
     surrounding characters).  Furthermore, different sequences of
     scalar values sometimes correspond to the same character.  The
     relationships among scalar, characters, and glyphs are subtle and
     complex.

     Despite this complexity, most things that a literate human would
     call a "character" can be represented by a single Unicode scalar
     value (although several sequences of Unicode scalar values may
     represent that same character).  For example, Roman letters,
     Cyrillic letters, Hebrew consonants, and most Chinese characters
     fall into this category.

     Unicode scalar values exclude the range '#xD800' to '#xDFFF', which
     are part of the range of Unicode _code points_.  However, the
     Unicode code points in this range, the so-called _surrogates_, are
     an artifact of the UTF-16 encoding, and can only appear in specific
     Unicode encodings, and even then only in pairs that encode scalar
     values.  Consequently, all characters represent code points, but
     the surrogate code points do not have representations as
     characters.

 -- Procedure: char? OBJ
     Return '#t' if OBJ is a character, '#f' otherwise.

 -- Procedure: char->integer CHAR
 -- Procedure: integer->char SV
     SV must be a Unicode scalar value, i.e., a non-negative exact
     integer object in '[0, #xD7FF] union [#xE000, #x10FFFF]'.

     Given a character, 'char->integer' returns its Unicode scalar value
     as an exact integer object.  For a Unicode scalar value SV,
     'integer->char' returns its associated character.

          (integer->char 32)                      => #\space
          (char->integer (integer->char 5000))    => 5000
          (integer->char #\xD800)                 => exception &assertion

 -- Procedure: char=? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char<? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char>? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char<=? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char>=? CHAR1 CHAR2 CHAR3 ...
     These procedures impose a total ordering on the set of characters
     according to their Unicode scalar values.

          (char<? #\z #\Z)                => #f


File: vicare-scheme.info,  Node: baselib strings,  Next: baselib vectors,  Prev: baselib characters,  Up: baselib

4.11 Strings
============

Strings are sequences of characters.  The _length_ of a string is the
number of characters that it contains.  This number is fixed when the
string is created.  The _valid indices_ of a string are the integers
less than the length of the string.  The first character of a string has
index 0, the second has index 1, and so on.

 -- Procedure: string? OBJ
     Return '#t' if OBJ is a string, '#f' otherwise.

 -- Procedure: make-string K
 -- Procedure: make-string K CHAR
     Return a newly allocated string of length K.  If CHAR is given,
     then all elements of the string are initialized to CHAR, otherwise
     the contents of the string are unspecified.

 -- Procedure: string CHAR ...
     Return a newly allocated string composed of the arguments.

 -- Procedure: string-length STRING
     Return the number of characters in the given STRING as an exact
     integer object.

 -- Procedure: string-ref STRING K
     K must be a valid index of STRING.  The 'string-ref' procedure
     returns character K of STRING using zero-origin indexing.

          *NOTE* Implementors should make 'string-ref' run in constant
          time.

 -- Procedure: string=? STRING1 STRING2 STRING3 ...
     Return '#t' if the strings are the same length and contain the same
     characters in the same positions.  Otherwise, the 'string=?'
     procedure returns '#f'.

          (string=? "Strause" "Strasse")    => #f

 -- Procedure: string<? STRING1 STRING2 STRING3 ...
 -- Procedure: string>? STRING1 STRING2 STRING3 ...
 -- Procedure: string<=? STRING1 STRING2 STRING3 ...
 -- Procedure: string>=? STRING1 STRING2 STRING3 ...
     These procedures are the lexicographic extensions to strings of the
     corresponding orderings on characters.  For example, 'string<?' is
     the lexicographic ordering on strings induced by the ordering
     'char<?' on characters.  If two strings differ in length but are
     the same up to the length of the shorter string, the shorter string
     is considered to be lexicographically less than the longer string.

          (string<? "z" "a")      => #t
          (string<? "z" "zz")     => #t
          (string<? "z" "Z")      => #f

 -- Procedure: substring STRING START END
     STRING must be a string, and START and END must be exact integer
     objects satisfying:

          0 <= START <= END <= (string-length STRING)

     The 'substring' procedure returns a newly allocated string formed
     from the characters of STRING beginning with index START
     (inclusive) and ending with index END (exclusive).

 -- Procedure: string-append STRING ...
     Return a newly allocated string whose characters form the
     concatenation of the given strings.

 -- Procedure: string->list STRING
 -- Procedure: list->string LIST
     LIST must be a list of characters.

     The 'string->list' procedure returns a newly allocated list of the
     characters that make up the given string.

     The 'list->string' procedure returns a newly allocated string
     formed from the characters in LIST.

     The 'string->list' and 'list->string' procedures are inverses so
     far as 'equal?' is concerned.

 -- Procedure: string-for-each PROC STRING1 STRING2 ...
     The STRINGs must all have the same length.  PROC should accept as
     many arguments as there are STRINGs.

     The 'string-for-each' procedure applies PROC element-wise to the
     characters of the STRINGs for its side effects, in order from the
     first characters to the last.  PROC is always called in the same
     dynamic environment as 'string-for-each' itself.  The return values
     of 'string-for-each' are unspecified.

     Analogous to 'for-each'.

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: string-copy STRING
     Return a newly allocated copy of the given STRING.


File: vicare-scheme.info,  Node: baselib vectors,  Next: baselib errors,  Prev: baselib strings,  Up: baselib

4.12 Vectors
============

Vectors are heterogeneous structures whose elements are indexed by
integers.  A vector typically occupies less space than a list of the
same length, and the average time needed to access a randomly chosen
element is typically less for the vector than for the list.

   The _length_ of a vector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the vector is
created.  The _valid indices_ of a vector are the exact non-negative
integer objects less than the length of the vector.  The first element
in a vector is indexed by zero, and the last element is indexed by one
less than the length of the vector.

   Like list constants, vector constants must be quoted:

     '#(0 (2 2 2 2) "Anna")     =>  #(0 (2 2 2 2) "Anna")

 -- Procedure: vector? OBJ
     Return '#t' if OBJ is a vector, '#f' otherwise.

 -- Procedure: make-vector K
 -- Procedure: make-vector K FILL
     Return a newly allocated vector of K elements.  If a second
     argument is given, then each element is initialized to FILL.
     Otherwise the initial contents of each element is unspecified.

          As Vicare extension: when FILL is unused, it defaults to the
          void object.

 -- Procedure: vector OBJ ...
     Return a newly allocated vector whose elements contain the given
     arguments.  Analogous to 'list'.

          (vector 'a 'b 'c)               =>  #(a b c)

 -- Procedure: vector-length VECTOR
     Return the number of elements in VECTOR as an exact integer object.

 -- Procedure: vector-ref VECTOR K
     K must be a valid index of VECTOR.  The 'vector-ref' procedure
     returns the contents of element K of VECTOR.

          (vector-ref '#(1 1 2 3 5 8 13 21) 5)     =>  8

 -- Procedure: vector-set! VECTOR K OBJ
     K must be a valid index of VECTOR.  The 'vector-set!' procedure
     stores OBJ in element K of VECTOR, and returns unspecified.

     Passing an immutable vector to 'vector-set!' should cause an
     exception with condition type '&assertion' to be raised.

          (let ((vec (vector 0 '(2 2 2 2) "Anna")))
            (vector-set! vec 1 '("Sue" "Sue"))
            vec)
          =>  #(0 ("Sue" "Sue") "Anna")

          (vector-set! '#(0 1 2) 1 "doe")
          =>  unspecified
              ;; constant vector
              ;; should raise exception &assertion

 -- Procedure: vector->list VECTOR
 -- Procedure: list->vector LIST
     The 'vector->list' procedure returns a newly allocated list of the
     objects contained in the elements of VECTOR.

     The 'list->vector' procedure returns a newly created vector
     initialized to the elements of the list LIST.

          (vector->list '#(dah dah didah))        => (dah dah didah)
          (list->vector '(dididit dah))           => #(dididit dah)

 -- Procedure: vector-fill! VECTOR FILL
     Store FILL in every element of VECTOR and returns unspecified
     values.

 -- Procedure: vector-map PROC VECTOR1 VECTOR2 ...
     The VECTORs must all have the same length.  PROC should accept as
     many arguments as there are VECTORs and return a single value.

     The 'vector-map' procedure applies PROC element-wise to the
     elements of the VECTORs and returns a vector of the results, in
     order.  PROC is always called in the same dynamic environment as
     'vector-map' itself.  The order in which PROC is applied to the
     elements of the VECTORs is unspecified.  If multiple returns occur
     from 'vector-map', the return values returned by earlier returns
     are not mutated.

     Analogous to 'map'.

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: vector-for-each PROC VECTOR1 VECTOR2 ...
     The VECTORs must all have the same length.  PROC should accept as
     many arguments as there are VECTORs.  The 'vector-for-each'
     procedure applies PROC element-wise to the elements of the VECTORs
     for its side effects, in order from the first elements to the last.
     PROC is always called in the same dynamic environment as
     'vector-for-each' itself.  The return values of 'vector-for-each'
     are unspecified.

     Analogous to 'for-each'.

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.


File: vicare-scheme.info,  Node: baselib errors,  Next: baselib control,  Prev: baselib vectors,  Up: baselib

4.13 Errors and violations
==========================

 -- Procedure: error WHO MESSAGE IRRITANT1 ...
 -- Procedure: assertion-violation WHO MESSAGE IRRITANT1 ...
     WHO must be a string or a symbol or '#f'.  MESSAGE must be a
     string.  The IRRITANTs are arbitrary objects.

     These procedures raise an exception.  The 'error' procedure should
     be called when an error has occurred, typically caused by something
     that has gone wrong in the interaction of the program with the
     external world or the user.  The 'assertion-violation' procedure
     should be called when an invalid call to a procedure was made,
     either passing an invalid number of arguments, or passing an
     argument that it is not specified to handle.

     The WHO argument should describe the procedure or operation that
     detected the exception.  The MESSAGE argument should describe the
     exceptional situation.  The IRRITANTs should be the arguments to
     the operation that detected the operation.

     The condition object provided with the exception has the following
     condition types:

        * If WHO is not '#f', the condition has condition type '&who',
          with WHO as the value of its field.  In that case, WHO should
          be the name of the procedure or entity that detected the
          exception.  If it is '#f', the condition does not have
          condition type '&who'.

        * The condition has condition type '&message', with MESSAGE as
          the value of its field.

        * The condition has condition type '&irritants', and its field
          has as its value a list of the IRRITANTs.

     Moreover, the condition created by 'error' has condition type
     '&error', and the condition created by 'assertion-violation' has
     condition type '&assertion'.

          (define (fac n)
            (if (not (integer-valued? n))
                (assertion-violation
                 'fac "non-integral argument" n))
            (if (negative? n)
                (assertion-violation
                 'fac "negative argument" n))
            (letrec
              ((loop (lambda (n r)
                       (if (zero? n)
                           r
                           (loop (- n 1) (* r n))))))
                (loop n 1)))

          (fac 5)         => 120
          (fac 4.5)       => exception &assertion
          (fac -3)        => exception &assertion

 -- Syntax: assert ?EXPRESSION
     An 'assert' form is evaluated by evaluating ?EXPRESSION.  If
     ?EXPRESSION returns a true value, that value is returned from the
     'assert' expression.  If ?EXPRESSION returns '#f', an exception
     with condition types '&assertion' and '&message' is raised.  The
     message provided in the condition object is
     implementation-dependent.

          *NOTE* Implementations should exploit the fact that 'assert'
          is a syntax to provide as much information as possible about
          the location of the assertion failure.


File: vicare-scheme.info,  Node: baselib control,  Next: baselib iteration,  Prev: baselib errors,  Up: baselib

4.14 Control features
=====================

This chapter describes various primitive procedures which control the
flow of program execution in special ways.

 -- Procedure: apply PROC ARG1 ... REST-ARGS
     REST-ARGS must be a list.  PROC should accept _n_ arguments, where
     _n_ is number of ARGs plus the length of REST-ARGS.  The 'apply'
     procedure calls PROC with the elements of the list:

          (append (list ARG1 ...) REST-ARGS)

     as the actual arguments.

     If a call to 'apply' occurs in a tail context, the call to PROC is
     also in a tail context.

          (apply + (list 3 4))                    =>  7

          (define compose
            (lambda (f g)
              (lambda args
                (f (apply g args)))))

          ((compose sqrt *) 12 75)                =>  30

 -- Procedure: call-with-current-continuation PROC
 -- Procedure: call/cc PROC
     PROC should accept one argument.  The procedure 'call/cc' (which is
     the same as the procedure 'call-with-current-continuation')
     packages the current continuation as an "escape procedure" and
     passes it as an argument to PROC.

     The escape procedure is a Scheme procedure that, if it is later
     called, will abandon whatever continuation is in effect at that
     later time and will instead reinstate the continuation that was in
     effect when the escape procedure was created.

     Calling the escape procedure may cause the invocation of BEFORE and
     AFTER procedures installed using 'dynamic-wind'.

     The escape procedure accepts the same number of arguments as the
     continuation of the original call to 'call/cc'.

     The escape procedure that is passed to PROC has unlimited extent
     just like any other procedure in Scheme.  It may be stored in
     variables or data structures and may be called as many times as
     desired.

     If a call to 'call/cc' occurs in a tail context, the call to PROC
     is also in a tail context.

     The following examples show only some ways in which 'call/cc' is
     used.  If all real uses were as simple as these examples, there
     would be no need for a procedure with the power of 'call/cc'.

          (call-with-current-continuation
            (lambda (exit)
              (for-each (lambda (x)
                          (if (negative? x)
                              (exit x)))
                        '(54 0 37 -3 245 19))
              #t))
          =>  -3

          (define list-length
            (lambda (obj)
              (call-with-current-continuation
                (lambda (return)
                  (letrec ((r
                            (lambda (obj)
                              (cond ((null? obj) 0)
                                    ((pair? obj)
                                     (+ (r (cdr obj)) 1))
                                    (else (return #f))))))
                    (r obj))))))

          (list-length '(1 2 3 4))                        =>  4
          (list-length '(a b . c))                        => #f
          (call-with-current-continuation procedure?)     => #t

          *NOTE* Calling an escape procedure reenters the dynamic extent
          of the call to 'call/cc', and thus restores its dynamic
          environment.

 -- Procedure: values OBJ ...
     Delivers all of its arguments to its continuation.  The 'values'
     procedure might be defined as follows:

          (define (values . things)
            (call-with-current-continuation
              (lambda (cont) (apply cont things))))

     The continuations of all non-final expressions within a sequence of
     expressions, such as in 'lambda', 'begin', 'let', 'let*', 'letrec',
     'letrec*', 'let-values', 'let*-values', 'case', and 'cond' forms,
     usually take an arbitrary number of values.

     Except for these and the continuations created by
     'call-with-values', 'let-values', and 'let*-values', continuations
     implicitly accepting a single value, such as the continuations of
     ?OPERATOR and ?OPERANDs of procedure calls or the ?TEST expressions
     in conditionals, take exactly one value.  The effect of passing an
     inappropriate number of values to such a continuation is undefined.

 -- Procedure: call-with-values PRODUCER CONSUMER
     PRODUCER must be a procedure and should accept zero arguments.
     CONSUMER must be a procedure and should accept as many values as
     PRODUCER returns.  The 'call-with-values' procedure calls PRODUCER
     with no arguments and a continuation that, when passed some values,
     calls the CONSUMER procedure with those values as arguments.  The
     continuation for the call to CONSUMER is the continuation of the
     call to 'call-with-values'.

          (call-with-values
              (lambda () (values 4 5))
            (lambda (a b) b))
          =>  5

          (call-with-values * -)
          =>  -1

     If a call to 'call-with-values' occurs in a tail context, the call
     to CONSUMER is also in a tail context.

     *Implementation responsibilities:* After PRODUCER returns, the
     implementation must check that CONSUMER accepts as many values as
     CONSUMER has returned.

 -- Procedure: dynamic-wind BEFORE THUNK AFTER
     BEFORE, THUNK, and AFTER must be procedures, and each should accept
     zero arguments.  These procedures may return any number of values.

     The 'dynamic-wind' procedure calls THUNK without arguments,
     returning the results of this call.  Moreover, 'dynamic-wind' calls
     BEFORE without arguments whenever the dynamic extent of the call to
     THUNK is entered, and AFTER without arguments whenever the dynamic
     extent of the call to THUNK is exited.  Thus, in the absence of
     calls to escape procedures created by 'call/cc', 'dynamic-wind'
     calls BEFORE, THUNK, and AFTER, in that order.

     While the calls to BEFORE and AFTER are not considered to be within
     the dynamic extent of the call to THUNK, calls to the BEFORE and
     AFTER procedures of any other calls to 'dynamic-wind' that occur
     within the dynamic extent of the call to THUNK are considered to be
     within the dynamic extent of the call to THUNK.

     More precisely, an escape procedure transfers control out of the
     dynamic extent of a set of zero or more active 'dynamic-wind' calls
     _x ..._ and transfer control into the dynamic extent of a set of
     zero or more active 'dynamic-wind' calls _y ..._.  It leaves the
     dynamic extent of the most recent _x_ and calls without arguments
     the corresponding AFTER procedure.  If the AFTER procedure returns,
     the escape procedure proceeds to the next most recent _x_, and so
     on.  Once each _x_ has been handled in this manner, the escape
     procedure calls without arguments the BEFORE procedure
     corresponding to the least recent _y_.  If the BEFORE procedure
     returns, the escape procedure reenters the dynamic extent of the
     least recent _y_ and proceeds with the next least recent _y_, and
     so on.  Once each _y_ has been handled in this manner, control is
     transferred to the continuation packaged in the escape procedure.

     *Implementation responsibilities:* The implementation must check
     the restrictions on THUNK and AFTER only if they are actually
     called.

          (let ((path '())
                (c #f))
            (let ((add (lambda (s)
                         (set! path (cons s path)))))
              (dynamic-wind
                (lambda () (add 'connect))
                (lambda ()
                  (add (call-with-current-continuation
                         (lambda (c0)
                           (set! c c0)
                           'talk1))))
                (lambda () (add 'disconnect)))
              (if (< (length path) 4)
                  (c 'talk2)
                  (reverse path))))
          => (connect talk1 disconnect connect talk2 disconnect)

          (let ((n 0))
            (call-with-current-continuation
              (lambda (k)
                (dynamic-wind
                  (lambda ()
                    (set! n (+ n 1))
                    (k))
                  (lambda ()
                    (set! n (+ n 2)))
                  (lambda ()
                    (set! n (+ n 4))))))
            n)
          => 1

          (let ((n 0))
            (call-with-current-continuation
              (lambda (k)
                (dynamic-wind
                  values
                  (lambda ()
                    (dynamic-wind
                      values
                      (lambda ()
                        (set! n (+ n 1))
                        (k))
                      (lambda ()
                        (set! n (+ n 2))
                        (k))))
                  (lambda ()
                    (set! n (+ n 4))))))
            n)
          => 7

          *NOTE* Entering a dynamic extent restores its dynamic
          environment.


File: vicare-scheme.info,  Node: baselib iteration,  Next: baselib quasiquotation,  Prev: baselib control,  Up: baselib

4.15 Iteration
==============

 -- Syntax: let ?VARIABLE ?BINDINGS ?BODY
     "Named 'let'" is a variant on the syntax of 'let' that provides a
     general looping construct and may also be used to express
     recursion.  It has the same syntax and semantics as ordinary 'let'
     except that ?VARIABLE is bound within ?BODY to a procedure whose
     parameters are the bound variables and whose body is ?BODY.  Thus
     the execution of ?BODY may be repeated by invoking the procedure
     named by ?VARIABLE.

          (let loop ((numbers '(3 -2 1 6 -5))
                     (nonneg '())
                     (neg '()))
            (cond ((null? numbers) (list nonneg neg))
                  ((>= (car numbers) 0)
                   (loop (cdr numbers)
                         (cons (car numbers) nonneg)
                         neg))
                  ((< (car numbers) 0)
                   (loop (cdr numbers)
                         nonneg
                         (cons (car numbers) neg)))))
          => ((6 1 3) (-5 -2))


File: vicare-scheme.info,  Node: baselib quasiquotation,  Next: baselib syntax binding,  Prev: baselib iteration,  Up: baselib

4.16 Quasiquotation
===================

 -- Syntax: quasiquote ?QQ-TEMPLATE
 -- Auxiliary Syntax: unquote
 -- Auxiliary Syntax: unquote-splicing
     "Backquote" or "quasiquote" expressions are useful for constructing
     a list or vector structure when some but not all of the desired
     structure is known in advance.

     ?QQ-TEMPLATE should be as specified by the grammar at the end of
     this entry.

     If no 'unquote' or 'unquote-splicing' forms appear within the
     ?QQ-TEMPLATE, the result of evaluating '(quasiquote ?QQ-TEMPLATE)'
     is equivalent to the result of evaluating '(quote ?QQ-TEMPLATE)'.

     If an '(unquote ?EXPRESSION ...)' form appears inside a
     ?QQ-TEMPLATE, however, the ?EXPRESSIONs are evaluated ("unquoted")
     and their results are inserted into the structure instead of the
     'unquote' form.

     If an '(unquote-splicing ?EXPRESSION ...)' form appears inside a
     ?QQ-TEMPLATE, then the ?EXPRESSIONs must evaluate to lists; the
     opening and closing parentheses of the lists are then "stripped
     away" and the elements of the lists are inserted in place of the
     'unquote-splicing' form.

     Any 'unquote-splicing' or multi-operand 'unquote' form must appear
     only within a list or vector ?QQ-TEMPLATE.

     The following abbreviations may be used:

          (quasiquote ?QQ-TEMPLATE)       =  `?QQ-TEMPLATE
          (unquote ?EXPRESSION)           =  ,?EXPRESSION
          (unquote-splicing ?EXPRESSION)  =  ,@?EXPRESSION

     Examples:

          `(list ,(+ 1 2) 4)                      => (list 3 4)

          (let ((name 'a))
            `(list ,name ',name))                 => (list a (quote a))

          `(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)   => (a 3 4 5 6 b)

          `((foo ,(- 10 3))
            ,@(cdr '(c)) . ,(car '(cons)))        => ((foo 7) . cons)

          `#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)
                                                  => #(10 5 2 4 3 8)

          (let ((name 'foo))
            `((unquote name name name)))          => (foo foo foo)

          (let ((name '(foo)))
            `((unquote-splicing name name name))) => (foo foo foo)

          (let ((q '((append x y) (sqrt 9))))
            ``(foo ,,@q))
          => `(foo (unquote (append x y) (sqrt 9)))

          (let ((x '(2 3))
                (y '(4 5)))
            `(foo (unquote (append x y) (sqrt 9))))
          => (foo (2 3 4 5) 3)

     Quasiquote forms may be nested.  Substitutions are made only for
     unquoted components appearing at the same nesting level as the
     outermost 'quasiquote'.  The nesting level increases by one inside
     each successive quasiquotation, and decreases by one inside each
     unquotation.

          `(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
          =>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)

          (let ((name1 'x)
                (name2 'y))
            `(a `(b ,,name1 ,',name2 d) e))
          =>  (a `(b ,x ,'y d) e)

     A 'quasiquote' expression may return either fresh, mutable objects
     or literal structure for any structure that is constructed at run
     time during the evaluation of the expression.  Portions that do not
     need to be rebuilt are always literal.  Thus:

          (let ((a 3))
            `((1 2) ,a ,4 ,'five 6))

     may be equivalent to either of the following expressions:

          '((1 2) 3 4 five 6)

          (let ((a 3))
            (cons '(1 2)
                  (cons a (cons 4 (cons 'five '(6))))))

     However, it is not equivalent to this expression:

          (let ((a 3))
            (list (list 1 2) a 4 'five 6))

     It is a syntax violation if any of the identifiers 'quasiquote',
     'unquote', or 'unquote-splicing' appear in positions within a
     ?QQ-TEMPLATE other than as described above.

     The following grammar for quasiquote expressions is not
     context-free.  It is presented as a recipe for generating an
     infinite number of production rules.  Imagine a copy of the
     following rules for N = 1, 2, 3, ...; N keeps track of the nesting
     depth.

          ;;This is the argument of QUASIQUOTE.
          ;;
          ?QQ-TEMPLATE -> ?QQ-TEMPLATE-1

          ;;This represents an expression to be evaluated.  It exists
          ;;to represent ?QQ-TEMPLATE-(N-1) when N=1.
          ;;
          ?QQ-TEMPLATE-0 -> ?EXPRESSION

          ?QUASIQUOTATION-N -> (quasiquote ?QQ-TEMPLATE-N)

          ?QQ-TEMPLATE-N
             -> ?LEXEME-DATUM
              | ?LIST-QQ-TEMPLATE-N
              | ?VECTOR-QQ-TEMPLATE-N
              | ?UNQUOTATION-N

          ?LIST-QQ-TEMPLATE-N
             -> (?QQ-TEMPLATE-OR-SPLICE-N*)
              | (?QQ-TEMPLATE-OR-SPLICE-N+ . ?QQ-TEMPLATE-N)
              | ?QUASIQUOTATION-(N+1)

          ?VECTOR-QQ-TEMPLATE-N -> #(?QQ-TEMPLATE-OR-SPLICE-N*)

          ?UNQUOTATION-N -> (unquote ?QQ-TEMPLATE-(N-1))

          ?QQ-TEMPLATE-OR-SPLICE-N
             -> ?QQ-TEMPLATE-N
              | ?SPLICING-UNQUOTATION-N

          ?SPLICING-UNQUOTATION-N
             -> (unquote-splicing ?QQ-TEMPLATE-(N-1)*)
              | (unquote ?QQ-TEMPLATE-(N-1)*)

     In 'quasiquotation's, a ?LIST-QQ-TEMPLATE-N can sometimes be
     confused with either an ?UNQUOTATION-N or a
     ?SPLICING-UNQUOTATION-N. The interpretation as an ?UNQUOTATION-N or
     ?SPLICING-UNQUOTATION-N takes precedence.


File: vicare-scheme.info,  Node: baselib syntax binding,  Next: baselib transformers,  Prev: baselib quasiquotation,  Up: baselib

4.17 Binding constructs for syntactic keywords
==============================================

The 'let-syntax' and 'letrec-syntax' forms bind keywords.  Like a
'begin' form, a 'let-syntax' or 'letrec-syntax' form may appear in a
definition context, in which case it is treated as a definition, and the
forms in the body must also be definitions.  A 'let-syntax' or
'letrec-syntax' form may also appear in an expression context, in which
case the forms within their bodies must be expressions.

 -- Syntax: let-syntax ?BINDINGS ?FORM ...
     ?BINDINGS must have the form:

          ((?KEYWORD ?EXPRESSION) ...)

     Each ?KEYWORD is an identifier, and each ?EXPRESSION is an
     expression that evaluates, at macro-expansion time, to a
     "transformer".  Transformers may be created by 'syntax-rules' or
     'identifier-syntax' or by one of the other mechanisms described in
     *note Syntax-case: stdlib syntax-case.  It is a syntax violation
     for ?KEYWORD to appear more than once in the list of keywords being
     bound.

     The ?FORMs are expanded in the syntactic environment obtained by
     extending the syntactic environment of the 'let-syntax' form with
     macros whose keywords are the ?KEYWORDs, bound to the specified
     transformers.  Each binding of a ?KEYWORD has the ?FORMs as its
     region.

     The ?FORMs of a 'let-syntax' form are treated, whether in
     definition or expression context, as if wrapped in an implicit
     'begin'.  Thus definitions in the result of expanding the ?FORMs
     have the same region as any definition appearing in place of the
     'let-syntax' form would have.

     *Implementation responsibilities:* The implementation should detect
     if the value of ?EXPRESSION cannot possibly be a transformer.

          (let-syntax ((when (syntax-rules ()
                               ((when test stmt1 stmt2 ...)
                                (if test
                                    (begin stmt1 stmt2 ...))))))
            (let ((if #t))
              (when if (set! if 'now))
              if))
          =>  now

          (let ((x 'outer))
            (let-syntax ((m (syntax-rules () ((m) x))))
              (let ((x 'inner))
                (m))))
          =>  outer

          (let ()
            (let-syntax ((def (syntax-rules ()
                                ((def stuff ...) (define stuff ...)))))
              (def foo 42))
            foo)
          => 42

          (let ()
            (let-syntax ())
            5)
          => 5

 -- Syntax: letrec-syntax ?BINDINGS ?FORM ...
     Same as for 'let-syntax'.

     The ?FORMs are expanded in the syntactic environment obtained by
     extending the syntactic environment of the 'letrec-syntax' form
     with macros whose keywords are the ?KEYWORDs, bound to the
     specified transformers.  Each binding of a ?KEYWORD has the
     ?BINDINGS as well as the ?FORMs within its region, so the
     transformers can transcribe forms into uses of the macros
     introduced by the 'letrec-syntax' form.

     The ?FORMs of a 'letrec-syntax' form are treated, whether in
     definition or expression context, as if wrapped in an implicit
     'begin'.  Thus definitions in the result of expanding the ?FORMs
     have the same region as any definition appearing in place of the
     'letrec-syntax' form would have.

     *Implementation responsibilities:* The implementation should detect
     if the value of ?EXPRESSION cannot possibly be a transformer.

          (letrec-syntax
              ((my-or (syntax-rules ()
                        ((my-or)
                         #f)
                        ((my-or e)
                         e)
                        ((my-or e1 e2 ...)
                         (let ((temp e1))
                           (if temp
                               temp
                             (my-or e2 ...)))))))
            (let ((x     #f)
                  (y     7)
                  (temp  8)
                  (let   odd?)
                  (if    even?))
              (my-or x (let temp) (if y) y)))
          => 7

     The following example highlights how 'let-syntax' and
     'letrec-syntax' differ.

          (let ((f (lambda (x) (+ x 1))))
            (let-syntax ((f (syntax-rules ()
                              ((f x) x)))
                         (g (syntax-rules ()
                              ((g x) (f x)))))
              (list (f 1) (g 1))))
          => (1 2)

          (let ((f (lambda (x) (+ x 1))))
            (letrec-syntax ((f (syntax-rules ()
                                 ((f x) x)))
                            (g (syntax-rules ()
                                 ((g x) (f x)))))
              (list (f 1) (g 1))))
          => (1 1)

     The two expressions are identical except that the 'let-syntax' form
     in the first expression is a 'letrec-syntax' form in the second.
     In the first expression, the 'f' occurring in 'g' refers to the
     'let'-bound variable 'f', whereas in the second it refers to the
     keyword 'f' whose binding is established by the 'letrec-syntax'
     form.


File: vicare-scheme.info,  Node: baselib transformers,  Next: baselib tail call,  Prev: baselib syntax binding,  Up: baselib

4.18 Macro transformers
=======================

 -- Syntax (for 'expand'): syntax-rules (?LITERAL ...) ?SYNTAX-RULE ...
 -- Auxiliary Syntax (for 'expand'): _
 -- Auxiliary Syntax (for 'expand'): ...
     Each ?LITERAL must be an identifier.  Each ?SYNTAX-RULE must have
     the following form:

          (?SRPATTERN ?TEMPLATE)

     An ?SRPATTERN is a restricted form of ?PATTERN, namely, a nonempty
     ?PATTERN in one of four parenthesized forms below whose first
     subform is an identifier or an underscore '_'.  A ?PATTERN is an
     identifier, constant, or one of the following.

          (?PATTERN ...)
          (?PATTERN ?PATTERN ... . ?PATTERN)
          (?PATTERN ... ?PATTERN ?ELLIPSIS ?PATTERN ...)
          (?PATTERN ... ?PATTERN ?ELLIPSIS ?PATTERN ... . ?PATTERN)
          #(?PATTERN ...)
          #(?PATTERN ... ?PATTERN ?ELLIPSIS ?PATTERN ...)

     An ?ELLIPSIS is the identifier '...' (three periods).

     A ?TEMPLATE is a pattern variable, an identifier that is not a
     pattern variable, a pattern datum, or one of the following.

          (?SUBTEMPLATE ...)
          (?SUBTEMPLATE ... . ?TEMPLATE)
          #(?SUBTEMPLATE ...)

     A ?SUBTEMPLATE is a ?TEMPLATE followed by zero or more ellipses.

     An instance of 'syntax-rules' evaluates, at macro-expansion time,
     to a new macro transformer by specifying a sequence of hygienic
     rewrite rules.  A use of a macro whose keyword is associated with a
     transformer specified by 'syntax-rules' is matched against the
     patterns contained in the ?SYNTAX-RULEs, beginning with the
     leftmost ?SYNTAX-RULE.  When a match is found, the macro use is
     transcribed hygienically according to the template.  It is a syntax
     violation when no match is found.

     An identifier appearing within a ?PATTERN may be an underscore '_',
     an ellipsis '...' or a literal identifier listed in the list of
     literals '(?LITERAL ...)'.  All other identifiers appearing within
     a ?PATTERN are "pattern variables".  It is a syntax violation if an
     ellipsis or underscore appears in '(?LITERAL ...)'.

     While the first subform of ?SRPATTERN may be an identifier, the
     identifier is not involved in the matching and is not considered a
     pattern variable or literal identifier.

     Pattern variables match arbitrary input subforms and are used to
     refer to elements of the input.  It is a syntax violation if the
     same pattern variable appears more than once in a ?PATTERN.

     Underscores also match arbitrary input subforms but are not pattern
     variables and so cannot be used to refer to those elements.
     Multiple underscores may appear in a ?PATTERN.

     A ?LITERAL identifier matches an input subform if and only if the
     input subform is an identifier and either both its occurrence in
     the input expression and its occurrence in the list of literals
     have the same lexical binding, or the two identifiers have the same
     name and both have no lexical binding.

     A subpattern followed by an ellipsis can match zero or more
     elements of the input.

     More formally, an input form F matches a pattern P if and only if
     one of the following holds:

        * P is an underscore ('_').

        * P is a pattern variable.

        * P is a literal identifier and F is an identifier such that
          both P and F would refer to the same binding if both were to
          appear in the output of the macro outside of any bindings
          inserted into the output of the macro.  (If neither of two
          like-named identifiers refers to any binding, i.e., both are
          undefined, they are considered to refer to the same binding.)

        * P is of the form:

               (P_1 ... P_n)

          and F is a list of n elements that match P_1 through P_n.

        * P is of the form:

               (P_1 ... P_n . P_x)

          and F is a list or improper list of n or more elements whose
          first n elements match P_1 through P_n and whose n-th cdr
          matches P_x.

        * P is of the form:

               (P_1 ... P_k P_e ?ELLIPSIS P_(m+1) ... P_n)

          where ?ELLIPSIS is the identifier '...' and F is a list of n
          elements whose first k elements match P_1 through P_k, whose
          next m-k elements each match P_e, and whose remaining n-m
          elements match P_(m+1) through P_n.

        * P is of the form:

               (P_1 ... P_k P_e ?ELLIPSIS P_(m+1) ... P_n . P_x)

          where ?ELLIPSIS is the identifier '...' and F is a list or
          improper list of n elements whose first k elements match P_1
          through P_k, whose next m-k elements each match P_e, whose
          next n-m elements match P_(m+1) through P_n, and whose nth and
          final cdr matches P_x.

        * P is of the form:

               #(P_1 ... P_n)

          and F is a vector of n elements that match P_1 through P_n.

        * P is of the form:

               #(P_1 ... P_k P_e ?ELLIPSIS P_(m+1) ... P_n)

          where ?ELLIPSIS is the identifier '...' and F is a vector of n
          or more elements whose first k elements match P_1 through P_k,
          whose next m-k elements each match P_e, and whose remaining
          n-m elements match P_(m+1) through P_n.

        * P is a pattern datum (any nonlist, nonvector, nonsymbol datum)
          and F is equal to P in the sense of the 'equal?' procedure.

     When a macro use is transcribed according to the template of the
     matching ?SYNTAX-RULE, pattern variables that occur in the template
     are replaced by the subforms they match in the input.

     Pattern data and identifiers that are not pattern variables or
     ellipses are copied into the output.  A subtemplate followed by an
     ellipsis expands into zero or more occurrences of the subtemplate.
     Pattern variables that occur in subpatterns followed by one or more
     ellipses may occur only in subtemplates that are followed by (at
     least) as many ellipses.  These pattern variables are replaced in
     the output by the input subforms to which they are bound,
     distributed as specified.  If a pattern variable is followed by
     more ellipses in the subtemplate than in the associated subpattern,
     the input form is replicated as necessary.  The subtemplate must
     contain at least one pattern variable from a subpattern followed by
     an ellipsis, and for at least one such pattern variable, the
     subtemplate must be followed by exactly as many ellipses as the
     subpattern in which the pattern variable appears.  (Otherwise, the
     expander would not be able to determine how many times the subform
     should be repeated in the output.)  It is a syntax violation if the
     constraints of this paragraph are not met.

     A template of the form '(?ELLIPSIS ?TEMPLATE)' is identical to
     ?TEMPLATE, except that ellipses within the template have no special
     meaning.  That is, any ellipses contained within ?TEMPLATE are
     treated as ordinary identifiers.  In particular, the template '(...
     ...)' produces a single ellipsis, '...'.  This allows syntactic
     abstractions to expand into forms containing ellipses.

          (define-syntax be-like-begin
            (syntax-rules ()
              ((be-like-begin name)
               (define-syntax name
                 (syntax-rules ()
                   ((name expr (... ...))
                    (begin expr (... ...))))))))

          (be-like-begin sequence)
          (sequence 1 2 3 4)
          => 4

     As an example for hygienic use of auxiliary identifier, if 'let'
     and 'cond' are defined as in *note let: baselib expressions
     binding. and *note cond: scheme derived. then they are hygienic (as
     required) and the following is not an error.

          (let ((=> #f))
            (cond (#t => 'ok)))
          => ok

     The macro transformer for 'cond' recognizes '=>' as a local
     variable, and hence an expression, and not as the identifier '=>',
     which the macro transformer treats as a syntactic keyword.  Thus
     the example expands into:

          (let ((=> #f))
            (if #t (begin => 'ok)))

     instead of:

          (let ((=> #f))
            (let ((temp #t))
              (if temp ('ok temp))))

     which would result in an assertion violation.

 -- Syntax (for 'expand'): identifier-syntax ?TEMPLATE
 -- Syntax (for 'expand'): identifier-syntax (?ID1 ?TEMPLATE1) ((set!
          ?ID2 ?PATTERN) ?TEMPLATE2)
 -- Auxiliary Syntax (for 'expand'): set!
     The ?IDs must be identifiers.  The ?TEMPLATEs must be as for
     'syntax-rules'.

     When a keyword is bound to a transformer produced by the first form
     of 'identifier-syntax', references to the keyword within the scope
     of the binding are replaced by ?TEMPLATE.

          (define p (cons 4 5))
          (define-syntax p.car (identifier-syntax (car p)))
          p.car           => 4
          (set! p.car 15) error-> exception &syntax

     The second, more general, form of 'identifier-syntax' permits the
     transformer to determine what happens when 'set!' is used.  In this
     case, uses of the identifier by itself are replaced by ?TEMPLATE1,
     and uses of 'set!' with the identifier are replaced by ?TEMPLATE2.

          (define p (cons 4 5))

          (define-syntax p.car
            (identifier-syntax
              (_
               (car p))
              ((set! _ e)
               (set-car! p e))))

          (set! p.car 15)
          p.car           => 15
          p               => (15 . 5)

How to use literal arguments
............................

Here we give a little explanation on the '(?LITERAL ...)' arguments of
'syntax-rules'.  Scheme defines the 'if' syntax as:

     (if ?test ?consequent ?alternate)

where the only "language keyword" is 'if' itself.  Many other languages
use a version with 'then' and 'else', which are also "reserved keywords"
for those languages; Scheme has no reserved keywords.

   A Scheme 'if' with 'then' and 'else', let's call it 'if*', would look
like:

     (if* ?test (then ?consequent) (else ?alternate))

we can define it with the following simple 'syntax-rules':

     #!r6rs
     (import (rnrs))

     (define-syntax if*
       (syntax-rules ()
         ((_ ?test (?then ?consequent) (?else ?alternate))
          (if ?test ?consequent ?alternate))))

     (let ((a 2))
       (if* (< 1 a)
            (then (display "yeah"))
            (else (display "nay"))))
     -| yeah

but notice that in this definition the pattern is:

     (_ ?test (?then ?consequent) (?else ?alternate))

and the identifiers '?THEN' and '?ELSE' become pattern variables, with
no validation of their value; so the following macro use also works with
no error:

     (let ((a 2))
       (if* (< 1 a)
            (123 (display "yeah"))
            (456 (display "nay"))))

that is in the template of the first arm of 'syntax-rules':

   * The identifier '?then' is a pattern variable bound to a syntax
     object holding the number 123.

   * The identifier '?else' is a pattern variable bound to a syntax
     object holding the number 456.

we can verify it with the following modified program:

     #!r6rs
     (import (rnrs))

     (define-syntax if*
       (syntax-rules ()
         ((_ ?test (?then ?consequent) (?else ?alternate))
          (display ?then))))

     (let ((a 2))
       (if* (< 1 a)
            (123 (display "yeah"))
            (456 (display "nay"))))
     -| 123

   This is not what we want: we would like the macro to verify that the
components of the input form falling in the positions of '?then' and
'?else' in the pattern, are identifiers having as names the symbol
'then' and the symbol 'else'.

   Specifically we would like, in those positions, identifiers being
'free-identifier=?' to "auxiliary keywords" 'then' and 'else' that we
have defined.  We could do such a test using 'syntax-case':

     #!r6rs
     (import (except (rnrs) else))

     ;;Define auxiliary keywords, they are just identifiers
     ;;bound to something.
     (define-syntax then (syntax-rules ()))
     (define-syntax else (syntax-rules ()))

     (define-syntax if*
       (lambda (stx)
         (syntax-case stx ()
           ((_ ?test (?then ?consequent) (?else ?alternate))
            (begin
              (if (and (identifier? #'?then)
                       (free-identifier=? #'?then #'then))
                  (display 'good)
                (display 'bad))
              #f)))))

     (let ((a 2))
       (if* (< 1 a)
            (then (display "yeah"))
            (else (display "nay"))))
     -| good

     (let ((a 2))
       (if* (< 1 a)
            (123 (display "yeah"))
            (456 (display "nay"))))
     -| bad

   We do not need to use 'syntax-case' for such a simple validation,
because 'syntax-rules' offers the ?LITERAL arguments exactly for this
purpose.  So the full version of 'IF... THEN... ELSE...' is:

     #!r6rs
     (import (except (rnrs) else))

     (define-syntax if*
       (syntax-rules (then else)
         ((_ ?test (then ?consequent) (else ?alternate))
          (if ?test ?consequent ?alternate))))

     (define-syntax then (syntax-rules ()))
     (define-syntax else (syntax-rules ()))

     (let ((a 2))
       (if* (< 1 a)
            (then (display "yeah"))
            (else (display "nay"))))
     -| yeah

     (let ((a 2))
       (if* (< 1 a)
            (123 (display "yeah"))
            (456 (display "nay"))))
     error-> syntax error

   The language '(rnrs)' already defines an auxiliary syntax 'else' and
it is all right to use it for 'if*' so we can just do:

     #!r6rs
     (import (rnrs))

     (define-syntax if*
       (syntax-rules (then else)
         ((_ ?test (then ?consequent) (else ?alternate))
          (if ?test ?consequent ?alternate))))

     (define-syntax then (syntax-rules ()))

   Notice that with these definitions we have created actual bindings
for 'then' and 'else' in the lexical context of the definition for
'if*', and 'if*' will recognise only those.  So when writing a library
that exports 'if*' we have to export 'then' and 'else' along with it:

     #!r6rs
     (library (if-star)
       (export if* then else)
       (import (rnrs))
       (define-syntax if*
         (syntax-rules (then else)
           ((_ ?test (then ?consequent) (else ?alternate))
            (if ?test ?consequent ?alternate))))
       (define-syntax then (syntax-rules ())))

and use it as:

     #!r6rs
     (import (rnrs)
       (if-star))

     (let ((a 2))
       (if* (< 1 a)
            (then (display "yeah"))
            (else (display "nay"))))
     -| yeah

     (let ((a 2))
       (if* (< 1 a)
            (123 (display "yeah"))
            (456 (display "nay"))))
     error-> syntax error


File: vicare-scheme.info,  Node: baselib tail call,  Prev: baselib transformers,  Up: baselib

4.19 Tail calls and tail contexts
=================================

A _tail call_ is a procedure call that occurs in a _tail context_.  Tail
contexts are defined inductively.  Note that a tail context is always
determined with respect to a particular lambda expression.

   * The last expression within the body of a lambda expression, shown
     as ?TAIL-EXPRESSION below, occurs in a tail context.

          (lambda ?FORMALS
            ?DEFINITION*
            ?EXPRESSION* ?TAIL-EXPRESSION)

   * If one of the following expressions is in a tail context, then the
     subexpressions shown as ?TAIL-EXPRESSION are in a tail context.
     These were derived from specifications of the syntax of the forms
     described in this chapter by replacing some occurrences of
     ?EXPRESSION with ?TAIL-EXPRESSION.  Only those rules that contain
     tail contexts are shown here.

          (if ?EXPRESSION ?TAIL-EXPRESSION ?TAIL-EXPRESSION)
          (if ?EXPRESSION ?TAIL-EXPRESSION)

          (cond ?COND-CLAUSE+)
          (cond ?COND-CLAUSE* (else ?TAIL-SEQUENCE))

          (case ?EXPRESSION
            ?CASE-CLAUSE+)
          (case ?EXPRESSION
            ?CASE-CLAUSE*
            (else ?TAIL-SEQUENCE))

          (and ?EXPRESSION* ?TAIL EXPRESSION)
          (or ?EXPRESSION* ?TAIL EXPRESSION)

          (let ?BINDINGS ?TAIL-BODY)
          (let ?VARIABLE ?BINDINGS ?TAIL-BODY)
          (let* ?BINDINGS ?TAIL-BODY)
          (letrec* ?BINDINGS ?TAIL-BODY)
          (letrec ?BINDINGS ?TAIL-BODY)
          (let-values ?MV-BINDINGS ?TAIL-BODY)
          (let*-values ?MV-BINDINGS ?TAIL-BODY)

          (let-syntax ?BINDINGS ?TAIL-BODY)
          (letrec-syntax ?BINDINGS ?TAIL-BODY)

          (begin ?TAIL-SEQUENCE)

     A ?COND CLAUSE is:

          (?TEST ?TAIL-SEQUENCE)

     a ?CASE-CLAUSE is:

          ((?DATUM*) ?TAIL SEQUENCE)

     a ?TAIL-BODY is:

          ?DEFINITION* ?TAIL-SEQUENCE

     and a ?TAIL-SEQUENCE is:

          ?EXPRESSION* ?TAIL-EXPRESSION

   * If a 'cond' expression is in a tail context, and has a clause of
     the form '(?EXPRESSION1 => ?EXPRESSION2)' then the (implied) call
     to the procedure that results from the evaluation of ?EXPRESSION2
     is in a tail context.  ?EXPRESSION2 itself is not in a tail
     context.

   Certain built-in procedures must also perform tail calls.  The first
argument passed to 'apply' and to 'call/cc', and the second argument
passed to 'call-with-values', must be called via a tail call.

   In the following example the only tail call is the call to 'f'.  None
of the calls to 'g' or 'h' are tail calls.  The reference to 'x' is in a
tail context, but it is not a call and thus is not a tail call.

     (lambda ()
       (if (g)
           (let ((x (h)))
             x)
           (and (g) (f))))

     *NOTE* Implementations may recognize that some non-tail calls, such
     as the call to 'h' above, can be evaluated as though they were tail
     calls.  In the example above, the 'let' expression could be
     compiled as a tail call to 'h'.  (The possibility of 'h' returning
     an unexpected number of values can be ignored, because in that case
     the effect of the 'let' is explicitly unspecified and
     implementation-dependent.)


File: vicare-scheme.info,  Node: stdlib,  Next: iklib,  Prev: baselib,  Up: Top

5 Standard libraries
********************

* Menu:

* stdlib unicode::              Unicode.
* stdlib bytevector::           Bytevectors.
* stdlib list::                 List utilities.
* stdlib sorting::              Sorting.
* stdlib control::              Control structures.
* stdlib records::              Records.
* stdlib exceptions::           Exceptions and conditions.
* stdlib io::                   Input/output.
* stdlib files::                File system.
* stdlib programlib::           Command line access and exit values.
* stdlib arithmetic::           Arithmetics.
* stdlib syntax-case::          Syntax-case.
* stdlib hashtable::            Hashtables.
* stdlib enum::                 Enumerations.
* stdlib complib::              Composite library.
* stdlib eval::                 Evaluation.
* stdlib mutable pairs::        Mutable pairs.
* stdlib mutable strings::      Mutable strings.
* stdlib rfive compat::         R5RS compatibility.


File: vicare-scheme.info,  Node: stdlib unicode,  Next: stdlib bytevector,  Up: stdlib

5.1 Unicode
===========

The procedures exported by the '(rnrs unicode (6))' library provide
access to some aspects of the Unicode semantics for characters and
strings: category information, case-independent comparisons, case
mappings, and normalization.

   Some of the procedures that operate on characters or strings ignore
the difference between upper case and lower case.  These procedures have
'-ci' (for "case insensitive") embedded in their names.

* Menu:

* stdlib unicode characters::   Characters.
* stdlib unicode strings::      Strings.


File: vicare-scheme.info,  Node: stdlib unicode characters,  Next: stdlib unicode strings,  Up: stdlib unicode

5.1.1 Characters
----------------

 -- Procedure: char-upcase CHAR
 -- Procedure: char-downcase CHAR
 -- Procedure: char-titlecase CHAR
 -- Procedure: char-foldcase CHAR
     These procedures take a character argument and return a character
     result.

     If the argument is an upper-case or title-case character, and if
     there is a single character that is its lower-case form, then
     'char-downcase' returns that character.

     If the argument is a lower-case or title-case character, and there
     is a single character that is its upper-case form, then
     'char-upcase' returns that character.

     If the argument is a lower-case or upper-case character, and there
     is a single character that is its title-case form, then
     'char-titlecase' returns that character.

     If the argument is not a title-case character and there is no
     single character that is its title-case form, then 'char-titlecase'
     returns the upper-case form of the argument.

     Finally, if the character has a case-folded character, then
     'char-foldcase' returns that character.  Otherwise the character
     returned is the same as the argument.

     For Turkic characters '#\x130' and '#\x131', 'char-foldcase'
     behaves as the identity function; otherwise 'char-foldcase' is the
     same as 'char-downcase' composed with 'char-upcase'.

          (char-upcase #\i)               => #\I
          (char-downcase #\i)             => #\i
          (char-titlecase #\i)            => #\I
          (char-foldcase #\i)             => #\i

          *NOTE* 'char-titlecase' does not always return a title-case
          character.

          *NOTE* These procedures are consistent with Unicode's
          locale-independent mappings from scalar values to scalar
          values for upcase, downcase, titlecase, and case-folding
          operations.  These mappings can be extracted from
          'UnicodeData.txt' and 'CaseFolding.txt' from the Unicode
          Consortium, ignoring Turkic mappings in the latter.

          Note that these character-based procedures are an incomplete
          approximation to case conversion, even ignoring the user's
          locale.  In general, case mappings require the context of a
          string, both in arguments and in result.  The 'string-upcase',
          'string-downcase', 'string-titlecase', and 'string-foldcase'
          procedures (*note stdlib unicode strings:: perform more
          general case conversion.

 -- Procedure: char-ci=? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char-ci<? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char-ci>? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char-ci<=? CHAR1 CHAR2 CHAR3 ...
 -- Procedure: char-ci>=? CHAR1 CHAR2 CHAR3 ...
     These procedures are similar to 'char=?', etc., but operate on the
     case-folded versions of the characters.

          (char-ci<? #\z #\Z)             => #f
          (char-ci=? #\z #\Z)             => #f

 -- Procedure: char-alphabetic? CHAR
 -- Procedure: char-numeric? CHAR
 -- Procedure: char-whitespace? CHAR
 -- Procedure: char-upper-case? CHAR
 -- Procedure: char-lower-case? CHAR
 -- Procedure: char-title-case? CHAR
     These procedures return '#t' if their arguments are alphabetic,
     numeric, whitespace, upper-case, lower-case, or title-case
     characters, respectively; otherwise they return '#f'.

     A character is alphabetic if it has the Unicode "Alphabetic"
     property.  A character is numeric if it has the Unicode "Numeric"
     property.  A character is whitespace if has the Unicode
     "White_Space" property.  A character is upper case if it has the
     Unicode "Uppercase" property, lower case if it has the "Lowercase"
     property, and title case if it is in the Lt general category.

          (char-alphabetic? #\a)          => #t
          (char-numeric? #\1)             => #t
          (char-whitespace? #\space)      => #t
          (char-whitespace? #\x00A0)      => #t
          (char-lower-case? #\x00AA)      => #t
          (char-title-case? #\I)          => #f
          (char-title-case? #\x01C5)      => #t

 -- Procedure: char-general-category CHAR
     Return a symbol representing the Unicode general category of CHAR,
     one of 'Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Mn', 'Mc', 'Me', 'Nd', 'Nl',
     'No', 'Ps', 'Pe', 'Pi', 'Pf', 'Pd', 'Pc', 'Po', 'Sc', 'Sm', 'Sk',
     'So', 'Zs', 'Zp', 'Zl', 'Cc', 'Cf', 'Cs', 'Co', or 'Cn'.

          (char-general-category #\a)             => Ll
          (char-general-category #\space)         => Zs
          (char-general-category #\x10FFFF)       => Cn


File: vicare-scheme.info,  Node: stdlib unicode strings,  Prev: stdlib unicode characters,  Up: stdlib unicode

5.1.2 Strings
-------------

 -- Procedure: string-upcase STRING
 -- Procedure: string-downcase STRING
 -- Procedure: string-titlecase STRING
 -- Procedure: string-foldcase STRING
     These procedures take a string argument and return a string result.
     They are defined in terms of Unicode's locale-independent case
     mappings from Unicode scalar-value sequences to scalar-value
     sequences.  In particular, the length of the result string can be
     different from the length of the input string.  When the specified
     result is equal in the sense of 'string=?' to the argument, these
     procedures may return the argument instead of a newly allocated
     string.

     The 'string-upcase' procedure converts a string to upper case;
     'string-downcase' converts a string to lower case.  The
     'string-foldcase' procedure converts the string to its case-folded
     counterpart, using the full case-folding mapping, but without the
     special mappings for Turkic languages.  The 'string-titlecase'
     procedure converts the first cased character of each word, and
     downcases all other cased characters.

          (string-upcase "Hi")                    => "HI"
          (string-downcase "Hi")                  => "hi"
          (string-foldcase "Hi")                  => "hi"

          (string-titlecase "kNock KNoCK")        => "Knock Knock"
          (string-titlecase "who's there?")       => "Who's There?"
          (string-titlecase "r6rs")               => "R6rs"
          (string-titlecase "R6RS")               => "R6rs"

          *NOTE* The case mappings needed for implementing these
          procedures can be extracted from 'UnicodeData.txt',
          'SpecialCasing.txt', 'WordBreakProperty.txt' (the "MidLetter"
          property partly defines case-ignorable characters), and
          'CaseFolding.txt' from the Unicode Consortium.

          Since these procedures are locale-independent, they may not be
          appropriate for some locales.

          *NOTE* Word breaking, as needed for the correct casing of the
          upper case greek sigma and for 'string-titlecase', is
          specified in Unicode Standard Annex #29.

 -- Procedure: string-ci=? STRING1 STRING2 STRING3 ...
 -- Procedure: string-ci<? STRING1 STRING2 STRING3 ...
 -- Procedure: string-ci>? STRING1 STRING2 STRING3 ...
 -- Procedure: string-ci<=? STRING1 STRING2 STRING3 ...
 -- Procedure: string-ci>=? STRING1 STRING2 STRING3 ...
     These procedures are similar to 'string=?', etc., but operate on
     the case-folded versions of the strings.

          (string-ci<? "z" "Z")                   => #f
          (string-ci=? "z" "Z")                   => #t

 -- Procedure: string-normalize-nfd STRING
 -- Procedure: string-normalize-nfkd STRING
 -- Procedure: string-normalize-nfc STRING
 -- Procedure: string-normalize-nfkc STRING
     These procedures take a string argument and return a string result,
     which is the input string normalized to Unicode normalization form
     D, KD, C, or KC, respectively.  When the specified result is equal
     in the sense of 'string=?' to the argument, these procedures may
     return the argument instead of a newly allocated string.

          (string-normalize-nfd "\xE9;")          => "\x65;\x301;"
          (string-normalize-nfc "\xE9;")          => "\xE9;"
          (string-normalize-nfd "\x65;\x301;")    => "\x65;\x301;"
          (string-normalize-nfc "\x65;\x301;")    => "\xE9;"


File: vicare-scheme.info,  Node: stdlib bytevector,  Next: stdlib list,  Prev: stdlib unicode,  Up: stdlib

5.2 Bytevectors
===============

Many applications deal with blocks of binary data by accessing them in
various ways--extracting signed or unsigned numbers of various sizes.
Therefore, the '(rnrs bytevectors (6))' library provides a single type
for blocks of binary data with multiple ways to access that data.  It
deals with integers and floating-point representations in various sizes
with specified endianness.

   Bytevectors are objects of a disjoint type.  Conceptually, a
bytevector represents a sequence of 8-bit bytes.  The description of
bytevectors uses the term "byte" for an exact integer object in the
interval (-128, ..., 127) and the term "octet" for an exact integer
object in the interval (0, ..., 255).  A byte corresponds to its two's
complement representation as an octet.

   The length of a bytevector is the number of bytes it contains.  This
number is fixed.  A valid index into a bytevector is an exact,
non-negative integer object less than the length of the bytevector.  The
first byte of a bytevector has index 0; the last byte has an index one
less than the length of the bytevector.

   Generally, the access procedures come in different flavors according
to the size of the represented integer and the endianness of the
representation.  The procedures also distinguish signed and unsigned
representations.  The signed representations all use two's complement.

   Like string literals, literals representing bytevectors do not need
to be quoted:

     #vu8(12 23 123)         => #vu8(12 23 123)

* Menu:

* stdlib bytevector endianness::        Endianness.
* stdlib bytevector general::           General operations.
* stdlib bytevector bytes and octets::  Operations on bytes and octets.
* stdlib bytevector integers::          Operations on integers of
                                        arbitrary size.
* stdlib bytevector integers 16::       Operations on 16-bit integers.
* stdlib bytevector integers 32::       Operations on 32-bit integers.
* stdlib bytevector integers 64::       Operations on 64-bit integers.
* stdlib bytevector flonum::            Operations on IEEE 754
                                        representations.
* stdlib bytevector strings::           Operations on strings.


File: vicare-scheme.info,  Node: stdlib bytevector endianness,  Next: stdlib bytevector general,  Up: stdlib bytevector

5.2.1 Endianness
----------------

Many operations described in this chapter accept an ENDIANNESS argument.
Endianness describes the encoding of exact integer objects as several
contiguous bytes in a bytevector.  For this purpose, the binary
representation of the integer object is split into consecutive bytes.
The little-endian encoding places the least significant byte of an
integer first, with the other bytes following in increasing order of
significance.  The big-endian encoding places the most significant byte
of an integer first, with the other bytes following in decreasing order
of significance.

   This terminology also applies to IEEE 754 numbers: IEEE 754 describes
how to represent a floating-point number as an exact integer object, and
endianness describes how the bytes of such an integer are laid out in a
bytevector.

     *NOTE* Little and big-endianness are only the most common kinds of
     endianness.  Some architectures distinguish between the endianness
     at different levels of a binary representation.


File: vicare-scheme.info,  Node: stdlib bytevector general,  Next: stdlib bytevector bytes and octets,  Prev: stdlib bytevector endianness,  Up: stdlib bytevector

5.2.2 General operations
------------------------

 -- Syntax: endianness ?ENDIANNESS-SYMBOL
     The name of ?ENDIANNESS-SYMBOL must be a symbol describing an
     endianness.  An implementation must support at least the symbols
     'big' and 'little', but may support other endianness symbols.

     '(endianness ?ENDIANNESS-SYMBOL)' evaluates to the symbol named
     ?ENDIANNESS-SYMBOL.  Whenever one of the procedures operating on
     bytevectors accepts an endianness as an argument, that argument
     must be one of these symbols.  It is a syntax violation for
     ?ENDIANNESS-SYMBOL to be anything other than an endianness symbol
     supported by the implementation.

          *NOTE* Implementors should use widely accepted designations
          for endianness symbols other than 'big' and 'little'.

          *NOTE* Only the name of ?ENDIANNESS-SYMBOL is significant.

 -- Procedure: native-endianness
     Return the endianness symbol associated implementation's preferred
     endianness (usually that of the underlying machine architecture).
     This may be any ?ENDIANNESS-SYMBOL, including a symbol other than
     'big' and 'little'.

 -- Procedure: bytevector? OBJ
     Return '#t' if OBJ is a bytevector, '#f' otherwise.

 -- Procedure: make-bytevector K
 -- Procedure: make-bytevector K FILL
     Return a newly allocated bytevector of K bytes.  If the FILL
     argument is missing, the initial contents of the returned
     bytevector are unspecified.  If the FILL argument is present, it
     must be an exact integer object in the interval (-128, ... 255)
     that specifies the initial value for the bytes of the bytevector:
     If FILL is positive, it is interpreted as an octet; if it is
     negative, it is interpreted as a byte.

 -- Procedure: bytevector-length BYTEVECTOR
     Return, as an exact integer object, the number of bytes in
     BYTEVECTOR.

 -- Procedure: bytevector=? BYTEVECTOR1 BYTEVECTOR2
     Return '#t' if BYTEVECTOR1 and BYTEVECTOR2 are equal; that is, if
     they have the same length and equal bytes at all valid indices.  It
     returns '#f' otherwise.

 -- Procedure: bytevector-fill! BYTEVECTOR FILL
     The FILL argument is as in the description of the 'make-bytevector'
     procedure.  The 'bytevector-fill!' procedure stores FILL in every
     element of BYTEVECTOR and returns unspecified values.  Analogous to
     'vector-fill!'.

 -- Procedure: bytevector-copy! SOURCE SOURCE-START TARGET TARGET-START
          K
     SOURCE and TARGET must be bytevectors.  SOURCE-START, TARGET-START,
     and K must be non-negative exact integer objects that satisfy:

          0 <= SOURCE-START <= SOURCE-START + K <= l_SOURCE
          0 <= TARGET-START <= TARGET-START + K <= l_TARGET

     where _l_SOURCE_ is the length of SOURCE and _l_TARGET_ is the
     length of TARGET.

     The 'bytevector-copy!' procedure copies the bytes from SOURCE at
     indices:

          SOURCE-START, ..., SOURCE-START + K - 1

     to consecutive indices in TARGET starting at TARGET-START.

     This must work even if the memory regions for the source and the
     target overlap, i.e., the bytes at the target location after the
     copy must be equal to the bytes at the source location before the
     copy.

     Return unspecified values.

          (let ((b (u8-list->bytevector '(1 2 3 4 5 6 7 8))))
            (bytevector-copy! b 0 b 3 4)
            (bytevector->u8-list b))
          => (1 2 3 1 2 3 4 8)

 -- Procedure: bytevector-copy BYTEVECTOR
     Return a newly allocated copy of BYTEVECTOR.


File: vicare-scheme.info,  Node: stdlib bytevector bytes and octets,  Next: stdlib bytevector integers,  Prev: stdlib bytevector general,  Up: stdlib bytevector

5.2.3 Operations on bytes and octets
------------------------------------

 -- Procedure: bytevector-u8-ref BYTEVECTOR K
 -- Procedure: bytevector-s8-ref BYTEVECTOR K
     K must be a valid index of BYTEVECTOR.

     The 'bytevector-u8-ref' procedure returns the byte at index K of
     BYTEVECTOR, as an octet.

     The 'bytevector-s8-ref' procedure returns the byte at index K of
     BYTEVECTOR, as a (signed) byte.

          (let ((b1 (make-bytevector 16 -127))
                (b2 (make-bytevector 16 255)))
            (list
              (bytevector-s8-ref b1 0)
              (bytevector-u8-ref b1 0)
              (bytevector-s8-ref b2 0)
              (bytevector-u8-ref b2 0)))
          => (-127 129 -1 255)

 -- Procedure: bytevector-u8-set! BYTEVECTOR K OCTET
 -- Procedure: bytevector-s8-set! BYTEVECTOR K BYTE
     K must be a valid index of BYTEVECTOR.

     The 'bytevector-u8-set!' procedure stores OCTET in element K of
     BYTEVECTOR.

     The 'bytevector-s8-set!' procedure stores the two's-complement
     representation of BYTE in element K of BYTEVECTOR.

     Both procedures return unspecified values.

          (let ((b (make-bytevector 16 -127)))

            (bytevector-s8-set! b 0 -126)
            (bytevector-u8-set! b 1 246)

            (list
              (bytevector-s8-ref b 0)
              (bytevector-u8-ref b 0)
              (bytevector-s8-ref b 1)
              (bytevector-u8-ref b 1)))
          => (-126 130 -10 246)

 -- Procedure: bytevector->u8-list BYTEVECTOR
 -- Procedure: u8-list->bytevector LIST
     LIST must be a list of octets.

     The 'bytevector->u8-list' procedure returns a newly allocated list
     of the octets of BYTEVECTOR in the same order.

     The 'u8-list->bytevector' procedure returns a newly allocated
     bytevector whose elements are the elements of list LIST, in the
     same order.  It is analogous to 'list->vector'.


File: vicare-scheme.info,  Node: stdlib bytevector integers,  Next: stdlib bytevector integers 16,  Prev: stdlib bytevector bytes and octets,  Up: stdlib bytevector

5.2.4 Operations on integers of arbitrary size
----------------------------------------------

 -- Procedure: bytevector-uint-ref BYTEVECTOR K ENDIANNESS SIZE
 -- Procedure: bytevector-sint-ref BYTEVECTOR K ENDIANNESS SIZE
 -- Procedure: bytevector-uint-set! BYTEVECTOR K N ENDIANNESS SIZE
 -- Procedure: bytevector-sint-set! BYTEVECTOR K N ENDIANNESS SIZE
     SIZE must be a positive exact integer object.  K, ..., K+SIZE-1
     must be valid indices of BYTEVECTOR.

     The 'bytevector-uint-ref' procedure retrieves the exact integer
     object corresponding to the unsigned representation of size SIZE
     and specified by ENDIANNESS at indices K, ..., K + SIZE - 1.

     The 'bytevector-sint-ref' procedure retrieves the exact integer
     object corresponding to the two's-complement representation of size
     SIZE and specified by ENDIANNESS at indices K, ..., K+SIZE-1.

     For 'bytevector-uint-set!', N must be an exact integer object in
     the interval (0, ..., 256^(SIZE-1)).

     The 'bytevector-uint-set!' procedure stores the unsigned
     representation of size SIZE and specified by ENDIANNESS into
     BYTEVECTOR at indices K, ..., K + SIZE - 1.

     For 'bytevector-sint-set!', N must be an exact integer object in
     the interval [-(256^SIZE)/2, (256^SIZE)/2-1].
     'bytevector-sint-set!' stores the two's-complement representation
     of size SIZE and specified by ENDIANNESS into BYTEVECTOR at indices
     K, ..., K + SIZE - 1.

     The '...-set!' procedures return unspecified values.

          (define b (make-bytevector 16 -127))

          (bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness little) 16)

          (bytevector-uint-ref b 0 (endianness little) 16)
          => #xfffffffffffffffffffffffffffffffd

          (bytevector-sint-ref b 0 (endianness little) 16)
          => -3

          (bytevector->u8-list b)
          => (253 255 255 255 255 255 255 255
              255 255 255 255 255 255 255 255)

          (bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness big) 16)

          (bytevector-uint-ref b 0 (endianness big) 16)
          => #xfffffffffffffffffffffffffffffffd

          (bytevector-sint-ref b 0 (endianness big) 16)
          => -3

          (bytevector->u8-list b)
          => (255 255 255 255 255 255 255 255
              255 255 255 255 255 255 255 253))

 -- Procedure: bytevector->uint-list BYTEVECTOR ENDIANNESS SIZE
 -- Procedure: bytevector->sint-list BYTEVECTOR ENDIANNESS SIZE
 -- Procedure: uint-list->bytevector LIST ENDIANNESS SIZE
 -- Procedure: sint-list->bytevector LIST ENDIANNESS SIZE
     SIZE must be a positive exact integer object.

     For 'uint-list->bytevector', LIST must be a list of exact integer
     objects in the interval (0, ..., (256^SIZE)-1).

     For 'sint-list->bytevector', LIST must be a list of exact integer
     objects in the interval (-(256^SIZE)/2, ..., (256^SIZE)/2-1).

     The length of BYTEVECTOR must be divisible by SIZE.

     These procedures convert between lists of integer objects and their
     consecutive representations according to SIZE and ENDIANNESS in the
     BYTEVECTOR objects in the same way as 'bytevector->u8-list' and
     'u8-list->bytevector' do for one-byte representations.

          (let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
            (bytevector->sint-list b (endianness little) 2))
          => (513 -253 513 513)

          (let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
            (bytevector->uint-list b (endianness little) 2))
          => (513 65283 513 513)


File: vicare-scheme.info,  Node: stdlib bytevector integers 16,  Next: stdlib bytevector integers 32,  Prev: stdlib bytevector integers,  Up: stdlib bytevector

5.2.5 Operations on 16-bit integers
-----------------------------------

 -- Procedure: bytevector-u16-ref BYTEVECTOR K ENDIANNESS
 -- Procedure: bytevector-s16-ref BYTEVECTOR K ENDIANNESS
 -- Procedure: bytevector-u16-native-ref BYTEVECTOR K
 -- Procedure: bytevector-s16-native-ref BYTEVECTOR K
 -- Procedure: bytevector-u16-set! BYTEVECTOR K N ENDIANNESS
 -- Procedure: bytevector-s16-set! BYTEVECTOR K N ENDIANNESS
 -- Procedure: bytevector-u16-native-set! BYTEVECTOR K N
 -- Procedure: bytevector-s16-native-set! BYTEVECTOR K N
     K must be a valid index of BYTEVECTOR; so must K+1.

     For 'bytevector-u16-set!' and 'bytevector-u16-native-set!', N must
     be an exact integer object in the interval 0 <= n <= 2^{16}-1.

     For 'bytevector-s16-set!' and 'bytevector-s16-native-set!', N must
     be an exact integer object in the interval -2^{15} <= n <=
     2^{15}-1.

     These procedures retrieve and set two-byte representations of
     numbers at indices K and K+1 according to the endianness specified
     by ENDIANNESS.  The procedures with 'u16' in their names deal with
     the unsigned representation; those with 's16' in their names deal
     with the two's-complement representation.

     The procedures with 'native' in their names employ the native
     endianness, and work only at aligned indices: K must be a multiple
     of 2.

     The '...-set!' procedures return unspecified values.

          (define b
            (u8-list->bytevector
              '(255 255 255 255 255 255 255 255
                255 255 255 255 255 255 255 253)))

          (bytevector-u16-ref b 14 (endianness little))           => 65023
          (bytevector-s16-ref b 14 (endianness little))           => -513
          (bytevector-u16-ref b 14 (endianness big))              => 65533
          (bytevector-s16-ref b 14 (endianness big))              => -3

          (bytevector-u16-set! b 0 12345 (endianness little))
          (bytevector-u16-ref b 0 (endianness little))            => 12345

          (bytevector-u16-native-set! b 0 12345)
          (bytevector-u16-native-ref b 0)                         => 12345

          (bytevector-u16-ref b 0 (endianness little))            => unspecified


File: vicare-scheme.info,  Node: stdlib bytevector integers 32,  Next: stdlib bytevector integers 64,  Prev: stdlib bytevector integers 16,  Up: stdlib bytevector

5.2.6 Operations on 32-bit integers
-----------------------------------

 -- Procedure: bytevector-u32-ref BYTEVECTOR K ENDIANNESS
 -- Procedure: bytevector-s32-ref BYTEVECTOR K ENDIANNESS
 -- Procedure: bytevector-u32-native-ref BYTEVECTOR K
 -- Procedure: bytevector-s32-native-ref BYTEVECTOR K
 -- Procedure: bytevector-u32-set! BYTEVECTOR K N ENDIANNESS
 -- Procedure: bytevector-s32-set! BYTEVECTOR K N ENDIANNESS
 -- Procedure: bytevector-u32-native-set! BYTEVECTOR K N
 -- Procedure: bytevector-s32-native-set! BYTEVECTOR K N
     K, ..., K+3 must be valid indices of BYTEVECTOR.

     For 'bytevector-u32-set!' and 'bytevector-u32-native-set!', N must
     be an exact integer object in the interval 0 <= n <= 2^{32}-1.

     For 'bytevector-s32-set!' and 'bytevector-s32-native-set!', N must
     be an exact integer object in the interval -2^{31} <= n <=
     2^{32}-1.

     These retrieve and set four-byte representations of numbers at
     indices K, ..., K+3, according to the endianness specified by
     ENDIANNESS.  The procedures with 'u32' in their names deal with the
     unsigned representation; those with 's32' with the two's-complement
     representation.

     The procedures with 'native' in their names employ the native
     endianness, and work only at aligned indices: K must be a multiple
     of 4.

     The '...-set!' procedures return unspecified values.

          (define b
            (u8-list->bytevector
              '(255 255 255 255 255 255 255 255
                255 255 255 255 255 255 255 253)))

          (bytevector-u32-ref b 12 (endianness little))   => 4261412863
          (bytevector-s32-ref b 12 (endianness little))   => -33554433
          (bytevector-u32-ref b 12 (endianness big))      => 4294967293
          (bytevector-s32-ref b 12 (endianness big))      => -3


File: vicare-scheme.info,  Node: stdlib bytevector integers 64,  Next: stdlib bytevector flonum,  Prev: stdlib bytevector integers 32,  Up: stdlib bytevector

5.2.7 Operations on 64-bit integers
-----------------------------------

 -- Procedure: bytevector-u64-ref BYTEVECTOR K ENDIANNESS
 -- Procedure: bytevector-s64-ref BYTEVECTOR K ENDIANNESS
 -- Procedure: bytevector-u64-native-ref BYTEVECTOR K
 -- Procedure: bytevector-s64-native-ref BYTEVECTOR K
 -- Procedure: bytevector-u64-set! BYTEVECTOR K N ENDIANNESS
 -- Procedure: bytevector-s64-set! BYTEVECTOR K N ENDIANNESS
 -- Procedure: bytevector-u64-native-set! BYTEVECTOR K N
 -- Procedure: bytevector-s64-native-set! BYTEVECTOR K N
     K, ..., K+7 must be valid indices of BYTEVECTOR.

     For 'bytevector-u64-set!' and 'bytevector-u64-native-set!', N must
     be an exact integer object in the interval 0 <= n <= 2^{64}-1.

     For 'bytevector-s64-set!' and 'bytevector-s64-native-set!', N must
     be an exact integer object in the interval -2^{63} <= n <=
     2^{64}-1.

     These retrieve and set eight-byte representations of numbers at
     indices K, ..., K+7, according to the endianness specified by
     ENDIANNESS.  The procedures with 'u64' in their names deal with the
     unsigned representation; those with 's64' with the two's-complement
     representation.

     The procedures with 'native' in their names employ the native
     endianness, and work only at aligned indices: K must be a multiple
     of 8.

     The '...-set!' procedures return unspecified values.

          (define b
            (u8-list->bytevector
              '(255 255 255 255 255 255 255 255
                255 255 255 255 255 255 255 253)))

          (bytevector-u64-ref b 8 (endianness little))
          => 18302628885633695743
          (bytevector-s64-ref b 8 (endianness little))
          => -144115188075855873
          (bytevector-u64-ref b 8 (endianness big))
          => 18446744073709551613
          (bytevector-s64-ref b 8 (endianness big))
          => -3


File: vicare-scheme.info,  Node: stdlib bytevector flonum,  Next: stdlib bytevector strings,  Prev: stdlib bytevector integers 64,  Up: stdlib bytevector

5.2.8 Operations on IEEE 754 representations
--------------------------------------------

 -- Procedure: bytevector-ieee-single-native-ref BYTEVECTOR K
 -- Procedure: bytevector-ieee-single-ref BYTEVECTOR K ENDIANNESS
     K, ..., K+3 must be valid indices of BYTEVECTOR.

     For 'bytevector-ieee-single-native-ref', K must be a multiple of 4.

     These procedures return the inexact real number object that best
     represents the IEEE 754 single-precision number represented by the
     four bytes beginning at index K.

 -- Procedure: bytevector-ieee-double-native-ref BYTEVECTOR K
 -- Procedure: bytevector-ieee-double-ref BYTEVECTOR K ENDIANNESS
     K, ..., K+7 must be valid indices of BYTEVECTOR.

     For 'bytevector-ieee-double-native-ref', K must be a multiple of 8.

     These procedures return the inexact real number object that best
     represents the IEEE 754 double-precision number represented by the
     eight bytes beginning at index K.

 -- Procedure: bytevector-ieee-single-native-set! BYTEVECTOR K X
 -- Procedure: bytevector-ieee-single-set! BYTEVECTOR K X ENDIANNESS
     K, ..., K+3 must be valid indices of BYTEVECTOR.

     For 'bytevector-ieee-single-native-set!', K must be a multiple of
     4.

     These procedures store an IEEE 754 single-precision representation
     of X into elements K through K+3 of BYTEVECTOR, and return
     unspecified values.

 -- Procedure: bytevector-ieee-double-native-set! BYTEVECTOR K X
 -- Procedure: bytevector-ieee-double-set! BYTEVECTOR K X ENDIANNESS
     K, ..., K+7 must be valid indices of BYTEVECTOR.

     For 'bytevector-ieee-double-native-set!', K must be a multiple of
     8.

     These procedures store an IEEE 754 double-precision representation
     of X into elements K through K+7 of BYTEVECTOR, and return
     unspecified values.


File: vicare-scheme.info,  Node: stdlib bytevector strings,  Prev: stdlib bytevector flonum,  Up: stdlib bytevector

5.2.9 Operations on strings
---------------------------

This section describes procedures that convert between strings and
bytevectors containing Unicode encodings of those strings.  When
decoding bytevectors, encoding errors are handled as with the 'replace'
semantics of textual I/O: If an invalid or incomplete character encoding
is encountered, then the replacement character 'U+FFFD' is appended to
the string being generated, an appropriate number of bytes are ignored,
and decoding continues with the following bytes.

 -- Procedure: string->utf8 STRING
     Return a newly allocated (unless empty) bytevector that contains
     the UTF-8 encoding of the given string.

 -- Procedure: string->utf16 STRING
 -- Procedure: string->utf16 STRING ENDIANNESS
     If ENDIANNESS is specified, it must be the symbol 'big' or the
     symbol 'little'.  The 'string->utf16' procedure returns a newly
     allocated (unless empty) bytevector that contains the UTF-16BE or
     UTF-16LE encoding of the given string (with no byte-order mark).
     If endianness is not specified or is 'big', then UTF-16BE is used.
     If endianness is 'little', then UTF-16LE is used.

 -- Procedure: string->utf32 STRING
 -- Procedure: string->utf32 STRING ENDIANNESS
     If ENDIANNESS is specified, it must be the symbol 'big' or the
     symbol 'little'.  The 'string->utf32' procedure returns a newly
     allocated (unless empty) bytevector that contains the UTF-32BE or
     UTF-32LE encoding of the given string (with no byte mark).  If
     endianness is not specified or is 'big', then UTF-32BE is used.  If
     endianness is 'little', then UTF-32LE is used.

 -- Procedure: utf8->string BYTEVECTOR
 -- Procedure: utf8->string BYTEVECTOR HANDLING-MODE
     Return a newly allocated (unless empty) string whose character
     sequence is encoded by the given bytevector.

     As Vicare extension: the optional argument HANDLING-MODE must be a
     symbol representing an error handling mode, as validated by
     'error-handling-mode' (*note error-handling-mode: stdlib io port
     transcoders.); when not given, it defaults to 'raise'.

 -- Procedure: utf16->string BYTEVECTOR ENDIANNESS
 -- Procedure: utf16->string BYTEVECTOR ENDIANNESS ENDIANNESS-MANDATORY
 -- Procedure: utf16->string BYTEVECTOR ENDIANNESS ENDIANNESS-MANDATORY
          HANDLING-MODE
     The argument ENDIANNESS must be the symbol 'big' or the symbol
     'little'.

     The 'utf16->string' procedure returns a newly allocated (unless
     empty) string whose character sequence is encoded by the given
     bytevector.

     BYTEVECTOR is decoded according to UTF-16, UTF-16BE, UTF-16LE, or a
     fourth encoding scheme that differs from all three of those as
     follows: If ENDIANNESS-MANDATORY is absent or '#f', 'utf16->string'
     determines the endianness according to a UTF-16 Byte Order Mark
     (BOM) at the beginning of BYTEVECTOR if a BOM is present; in this
     case, the BOM is not decoded as a character.  Also in this case, if
     no UTF-16 BOM is present, ENDIANNESS specifies the endianness of
     the encoding.  If ENDIANNESS-MANDATORY is a true value, ENDIANNESS
     specifies the endianness of the encoding, and any UTF-16 BOM in the
     encoding is decoded as a regular character.

          *NOTE* A UTF-16 BOM is either a sequence of bytes '#xFE',
          '#xFF' specifying 'big' and UTF-16BE, or '#xFF', '#xFE'
          specifying 'little' and UTF-16LE.

          (utf16->string '#vu8(#xAA #xBB) (endianness big))
          => "\xAABB;"
          (utf16->string '#vu8(#xAA #xBB) (endianness little))
          => "\xBBAA;"

          ;;In all the following tests: the endianness argument is
          ;;ignored; the BOM is processed; an empty string is generated.

          ;;Big endian BOM.
          (utf16->string '#vu8(#xFE #xFF) (endianness big)    #f)
          => ""
          (utf16->string '#vu8(#xFE #xFF) (endianness little) #f)
          => ""
          ;;Little endian BOM.
          (utf16->string '#vu8(#xFF #xFE) (endianness big)    #f)
          => ""
          (utf16->string '#vu8(#xFF #xFE) (endianness little) #f)
          => ""

          ;;In all the following tests: the endianness argument is
          ;;ignored; the BOM is processed; a string of 1 character is
          ;;generated.

          ;;Big endian BOM.
          (utf16->string '#vu8(#xFE #xFF #xAA #xBB) (endianness big)    #f)
          => "\xAABB;"
          (utf16->string '#vu8(#xFE #xFF #xAA #xBB) (endianness little) #f)
          => "\xAABB;"
          ;;Little endian BOM.
          (utf16->string '#vu8(#xFF #xFE #xAA #xBB) (endianness big)    #f)
          => "\xBBAA;"
          (utf16->string '#vu8(#xFF #xFE #xAA #xBB) (endianness little) #f)
          => "\xBBAA;"

     As Vicare extension: the optional argument HANDLING-MODE must be a
     symbol representing an error handling mode, as validated by
     'error-handling-mode' (*note error-handling-mode: stdlib io port
     transcoders.); when not given, it defaults to 'raise'.

 -- Procedure: utf32->string BYTEVECTOR ENDIANNESS
 -- Procedure: utf32->string BYTEVECTOR ENDIANNESS ENDIANNESS-MANDATORY
 -- Procedure: utf32->string BYTEVECTOR ENDIANNESS ENDIANNESS-MANDATORY
          HANDLING-MODE
     ENDIANNESS must be the symbol 'big' or the symbol 'little'.

     The 'utf32->string' procedure returns a newly allocated (unless
     empty) string whose character sequence is encoded by the given
     bytevector.

     BYTEVECTOR is decoded according to UTF-32, UTF-32BE, UTF-32LE, or a
     fourth encoding scheme that differs from all three of those as
     follows: If ENDIANNESS-MANDATORY is absent or '#f', 'utf32->string'
     determines the endianness according to a UTF-32 Byte Order Mark
     (BOM) at the beginning of BYTEVECTOR if a BOM is present; in this
     case, the BOM is not decoded as a character.  Also in this case, if
     no UTF-32 BOM is present, ENDIANNESS specifies the endianness of
     the encoding.  If ENDIANNESS-MANDATORY is a true value, ENDIANNESS
     specifies the endianness of the encoding, and any UTF-32 BOM in the
     encoding is decoded as a regular character.

          *NOTE* A UTF-32 BOM is either a sequence of bytes '#x00',
          '#x00', '#xFE', '#xFF' specifying 'big' and UTF-32BE, or
          '#xFF', '#xFE', '#x00', '#x00', specifying 'little' and
          UTF-32LE.

     As Vicare extension: the optional argument HANDLING-MODE must be a
     symbol representing an error handling mode, as validated by
     'error-handling-mode' (*note error-handling-mode: stdlib io port
     transcoders.); when not given, it defaults to 'raise'.


File: vicare-scheme.info,  Node: stdlib list,  Next: stdlib sorting,  Prev: stdlib bytevector,  Up: stdlib

5.3 List utilities
==================

This chapter describes the '(rnrs lists (6))' library, which contains
various useful procedures that operate on lists.

 -- Procedure: find PROC LIST
     PROC should accept one argument and return a single value.  PROC
     should not mutate LIST.  The 'find' procedure applies PROC to the
     elements of LIST in order.  If PROC returns a true value for an
     element, 'find' immediately returns that element.  If PROC returns
     '#f' for all elements of the list, 'find' returns '#f'.  PROC is
     always called in the same dynamic environment as 'find' itself.

          (find even? '(3 1 4 1 5 9))
          => 4

          (find even? '(3 1 5 1 5 9))
          => #f

     *Implementation responsibilities:* The implementation must check
     that LIST is a chain of pairs up to the found element, or that it
     is indeed a list if no element is found.  It should not check that
     it is a chain of pairs beyond the found element.  The
     implementation must check the restrictions on PROC to the extent
     performed by applying it as described.  An implementation may check
     whether PROC is an appropriate argument before applying it.

 -- Procedure: for-all PROC LIST1 LIST2 ... LISTN
 -- Procedure: exists PROC LIST1 LIST2 ... LISTN
     The LISTs should all have the same length, and PROC should accept n
     arguments and return a single value.  PROC should not mutate the
     LIST arguments.

     For natural numbers i = 0, 1, ..., the 'for-all' procedure
     successively applies PROC to arguments x_i^1 ... x_i^n, where x_i^j
     is the i-th element of LISTJ, until '#f' is returned.

     If PROC returns true values for all but the last element of LIST1,
     'for-all' performs a tail call of PROC on the k-th elements, where
     k is the length of LIST1.  If PROC returns '#f' on any set of
     elements, 'for-all' returns '#f' after the first such application
     of PROC.  If the LISTs are all empty, 'for-all' returns '#t'.

     For natural numbers i = 0, 1, ..., the 'exists' procedure applies
     PROC successively to arguments x_i^1 ... x_i^n, where x_i^j is the
     i-th element of LISTJ, until a true value is returned.

     If PROC returns '#f' for all but the last elements of the LISTs,
     'exists' performs a tail call of PROC on the _k_th elements, where
     _k_ is the length of LIST1.  If PROC returns a true value on any
     set of elements, 'exists' returns that value after the first such
     application of PROC.  If the LISTs are all empty, 'exists' returns
     '#f'.

     PROC is always called in the same dynamic environment as 'for-all'
     or, respectively, 'exists' itself.

          (for-all even? '(3 1 4 1 5 9))
          => #f

          (for-all even? '(3 1 4 1 5 9 . 2))
          => #f

          (for-all even? '(2 4 14))
          => #t

          (for-all even? '(2 4 14 . 9))
          error-> exception &assertion

          (for-all (lambda (n) (and (even? n) n))
                   '(2 4 14))
          => 14

          (for-all < '(1 2 3) '(2 3 4))
          => #t

          (for-all < '(1 2 4) '(2 3 4))
          => #f

          (exists even? '(3 1 4 1 5 9))
          => #t

          (exists even? '(3 1 1 5 9))
          => #f

          (exists even? '(3 1 1 5 9 . 2))
          error-> exception &assertion

          (exists (lambda (n) (and (even? n) n))
                  '(2 1 4 14))
          => 2

          (exists < '(1 2 4) '(2 3 4))
          => #t

          (exists > '(1 2 3) '(2 3 4))
          => #f

     *Implementation responsibilities:* The implementation must check
     that the LISTs are chains of pairs to the extent necessary to
     determine the return value.  If this requires traversing the lists
     entirely, the implementation should check that the LISTs all have
     the same length.  If not, it should not check that the LISTs are
     chains of pairs beyond the traversal.  The implementation must
     check the restrictions on PROC to the extent performed by applying
     it as described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: filter PROC LIST
 -- Procedure: partition PROC LIST
     PROC should accept one argument and return a single value.  PROC
     should not mutate LIST.

     The 'filter' procedure applies PROC to each element of LIST and
     returns a list of the elements of LIST for which PROC returned a
     true value.

     The 'partition' procedure also applies PROC to each element of
     LIST, but returns two values, the first one a list of the elements
     of LIST for which PROC returned a true value, and the second a list
     of the elements of LIST for which PROC returned '#f'.

     In both cases, the elements of the result list(s) are in the same
     order as they appear in the input list.  PROC is always called in
     the same dynamic environment as 'filter' or, respectively,
     'partition' itself.  If multiple returns occur from 'filter' or
     'partitions', the return values returned by earlier returns are not
     mutated.

          (filter even? '(3 1 4 1 5 9 2 6))
          => (4 2 6)

          (partition even? '(3 1 4 1 5 9 2 6))
          => (4 2 6) (3 1 1 5 9)   ; two values

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: fold-left COMBINE NIL LIST1 LIST2 ... LISTN
     The LISTs should all have the same length.  COMBINE must be a
     procedure; it should accept one more argument than there are LISTs
     and return a single value; it should not mutate the LIST arguments.

     The 'fold-left' procedure iterates the COMBINE procedure over an
     accumulator value and the elements of the LISTs from left to right,
     starting with an accumulator value of NIL.  COMBINE must have
     signature:

          (lambda (nil item0 item ...) . ?BODY)

     More specifically, 'fold-left' returns NIL if the LISTs are empty.
     If they are not empty, COMBINE is first applied to NIL and the
     respective first elements of the LISTs in order.  The result
     becomes the new accumulator value, and COMBINE is applied to the
     new accumulator value and the respective next elements of the LIST.
     This step is repeated until the end of the list is reached; then
     the accumulator value is returned.

     COMBINE is always called in the same dynamic environment as
     'fold-left' itself.

          (fold-left + 0 '(1 2 3 4 5))
          => 15

          (fold-left (lambda (a e)
                       (cons e a))
                     '()
                     '(1 2 3 4 5))
          => (5 4 3 2 1)

          (fold-left (lambda (count x)
                       (if (odd? x)
                           (+ count 1)
                         count))
                     0
                     '(3 1 4 1 5 9 2 6 5 3))
          => 7

          (fold-left (lambda (max-len s)
                       (max max-len (string-length s)))
                     0
                     '("longest" "long" "longer"))
          => 7

          (fold-left cons '(q) '(a b c))
          => ((((q) . a) . b) . c)

          (fold-left + 0 '(1 2 3) '(4 5 6))
          => 21

     *Implementation responsibilities:* The implementation should check
     that the LISTs all have the same length.  The implementation must
     check the restrictions on COMBINE to the extent performed by
     applying it as described.  An implementation may check whether
     COMBINE is an appropriate argument before applying it.

 -- Procedure: fold-right COMBINE NIL LIST1 LIST2 ... LISTN
     The LISTs should all have the same length.  COMBINE must be a
     procedure; it should accept one more argument than there are LISTs
     and return a single value; COMBINE should not mutate the LIST
     arguments.

     The 'fold-right' procedure iterates the COMBINE procedure over the
     elements of the LISTs from right to left and an accumulator value,
     starting with an accumulator value of NIL; COMBINE must have
     signature:

          (lambda (item0 item ... nil) . ?BODY)

     More specifically, 'fold-right' returns NIL if the LISTs are empty.
     If they are not empty, COMBINE is first applied to the respective
     last elements of the LISTs in order and NIL.  The result becomes
     the new accumulator value, and COMBINE is applied to the respective
     previous elements of the LISTs and the new accumulator value.  This
     step is repeated until the beginning of the list is reached; then
     the accumulator value is returned.

     PROC is always called in the same dynamic environment as
     'fold-right' itself.

          (fold-right + 0 '(1 2 3 4 5))
          => 15

          (fold-right cons '() '(1 2 3 4 5))
          => (1 2 3 4 5)

          (fold-right (lambda (item knil)
                        (cons item knil))
            '()
            '(1 2 3 4))
          => (1 2 3 4)

          (fold-right (lambda (x l)
                        (if (odd? x) (cons x l) l))
                      '()
                      '(3 1 4 1 5 9 2 6 5))
          => (3 1 1 5 9 5)

          (fold-right cons '(q) '(a b c))
          => (a b c q)

          (fold-right + 0 '(1 2 3) '(4 5 6))
          => 21

     *Implementation responsibilities:* The implementation should check
     that the LISTs all have the same length.  The implementation must
     check the restrictions on COMBINE to the extent performed by
     applying it as described.  An implementation may check whether
     COMBINE is an appropriate argument before applying it.

 -- Procedure: remp PROC LIST
 -- Procedure: remove OBJ LIST
 -- Procedure: remv OBJ LIST
 -- Procedure: remq OBJ LIST
     PROC should accept one argument and return a single value.  PROC
     should not mutate LIST.

     Each of these procedures returns a list of the elements of LIST
     that do not satisfy a given condition.

     The 'remp' procedure applies PROC to each element of LIST and
     returns a list of the elements of LIST for which PROC returned
     '#t'.  PROC is always called in the same dynamic environment as
     'remp' itself.

     The 'remove', 'remv', and 'remq' procedures return a list of the
     elements that are not OBJ.  The 'remq' procedure uses 'eq?' to
     compare OBJ with the elements of LIST, while 'remv' uses 'eqv?' and
     'remove' uses 'equal?'.

     The elements of the result list are in the same order as they
     appear in the input list.  If multiple returns occur from 'remp',
     the return values returned by earlier returns are not mutated.

          (remp even? '(3 1 4 1 5 9 2 6 5))
          => (3 1 1 5 9 5)

          (remove 1 '(3 1 4 1 5 9 2 6 5))
          => (3 4 5 9 2 6 5)

          (remv 1 '(3 1 4 1 5 9 2 6 5))
          => (3 4 5 9 2 6 5)

          (remq 'foo '(bar foo baz))
          => (bar baz)

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: memp PROC LIST
 -- Procedure: member OBJ LIST
 -- Procedure: memv OBJ LIST
 -- Procedure: memq OBJ LIST
     PROC should accept one argument and return a single value.  PROC
     should not mutate LIST.

     These procedures return the first sublist of LIST whose car
     satisfies a given condition, where the sublists of LISTS are the
     lists returned by '(list-tail LIST K)' for K less than the length
     of LIST.

     The 'memp' procedure applies PROC to the cars of the sublists of
     LIST until it finds one for which PROC returns a true value.  PROC
     is always called in the same dynamic environment as 'memp' itself.

     The 'member', 'memv', and 'memq' procedures look for the first
     occurrence of OBJ.  If LIST does not contain an element satisfying
     the condition, then '#f' (not the empty list) is returned.  The
     'member' procedure uses 'equal?' to compare OBJ with the elements
     of LIST, while 'memv' uses 'eqv?' and 'memq' uses 'eq?'.

          (memp even? '(3 1 4 1 5 9 2 6 5))
          => (4 1 5 9 2 6 5)

          (memq 'a '(a b c))
          => (a b c)

          (memq 'b '(a b c))
          => (b c)

          (memq 'a '(b c d))
          => #f

          (memq (list 'a) '(b (a) c))
          => #f

          (member (list 'a) '(b (a) c))
          => ((a) c)

          (memq 101 '(100 101 102))
          => unspecified

          (memv 101 '(100 101 102))
          => (101 102)

     *Implementation responsibilities:* The implementation must check
     that LIST is a chain of pairs up to the found element, or that it
     is indeed a list if no element is found.  It should not check that
     it is a chain of pairs beyond the found element.  The
     implementation must check the restrictions on PROC to the extent
     performed by applying it as described.  An implementation may check
     whether PROC is an appropriate argument before applying it.

 -- Procedure: assp PROC ALIST
 -- Procedure: assoc OBJ ALIST
 -- Procedure: assv OBJ ALIST
 -- Procedure: assq OBJ ALIST
     ALIST (for "association list") should be a list of pairs.  PROC
     should accept one argument and return a single value.  PROC should
     not mutate ALIST.

     These procedures find the first pair in ALIST whose car field
     satisfies a given condition, and returns that pair without
     traversing ALIST further.  If no pair in ALIST satisfies the
     condition, then '#f' is returned.

     The 'assp' procedure successively applies PROC to the car fields of
     ALIST and looks for a pair for which it returns a true value.  PROC
     is always called in the same dynamic environment as 'assp' itself.

     The 'assoc', 'assv', and 'assq' procedures look for a pair that has
     OBJ as its car.  The 'assoc' procedure uses 'equal?' to compare OBJ
     with the car fields of the pairs in ALIST, while 'assv' uses 'eqv?'
     and 'assq' uses 'eq?'.

     *Implementation responsibilities:* The implementation must check
     that ALIST is a chain of pairs containing pairs up to the found
     pair, or that it is indeed a list of pairs if no element is found.
     It should not check that it is a chain of pairs beyond the found
     element.  The implementation must check the restrictions on PROC to
     the extent performed by applying it as described.  An
     implementation may check whether PROC is an appropriate argument
     before applying it.

          (define d '((3 a) (1 b) (4 c)))

          (assp even? d)
          => (4 c)

          (assp odd? d)
          => (3 a)

          (define e '((a 1) (b 2) (c 3)))

          (assq 'a e)
          => (a 1)

          (assq 'b e)
          => (b 2)

          (assq 'd e)
          => #f

          (assq (list 'a) '(((a)) ((b)) ((c))))
          => #f

          (assoc (list 'a) '(((a)) ((b)) ((c))))
          => ((a))

          (assq 5 '((2 3) (5 7) (11 13)))
          => unspecified

          (assv 5 '((2 3) (5 7) (11 13)))
          => (5 7)

 -- Procedure: cons* OBJ1 ... OBJN OBJ
 -- Procedure: cons* OBJ
     If called with at least two arguments, 'cons*' returns a freshly
     allocated chain of pairs whose cars are OBJ1, ..., OBJN, and whose
     last cdr is OBJ.  If called with only one argument, 'cons*' returns
     that argument.

          (cons* 1 2 '(3 4 5))
          => (1 2 3 4 5)

          (cons* 1 2 3)
          => (1 2 . 3)

          (cons* 1)
          => 1


File: vicare-scheme.info,  Node: stdlib sorting,  Next: stdlib control,  Prev: stdlib list,  Up: stdlib

5.4 Sorting
===========

This chapter describes the '(rnrs sorting (6))' library for sorting
lists and vectors.

 -- Procedure: list-sort PROC LIST
 -- Procedure: vector-sort PROC VECTOR
     PROC should accept any two elements of LIST or VECTOR, and should
     not have any side effects.  PROC should return a true value when
     its first argument is strictly less than its second, and '#f'
     otherwise.

     The 'list-sort' and 'vector-sort' procedures perform a stable sort
     of LIST or VECTOR in ascending order according to PROC, without
     changing LIST or VECTOR in any way.  The 'list-sort' procedure
     returns a list, and 'vector-sort' returns a vector.

     The results may be 'eq?' to the argument when the argument is
     already sorted, and the result of 'list-sort' may share structure
     with a tail of the original list.

     The sorting algorithm performs O(n log n) calls to PROC where n is
     the length of LIST or VECTOR, and all arguments passed to PROC are
     elements of the list or vector being sorted, but the pairing of
     arguments and the sequencing of calls to PROC are not specified.
     If multiple returns occur from 'list-sort' or 'vector-sort', the
     return values returned by earlier returns are not mutated.

          (list-sort < '(3 5 2 1))        => (1 2 3 5)
          (vector-sort < '#(3 5 2 1))     => #(1 2 3 5)

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.

 -- Procedure: vector-sort! PROC VECTOR
     PROC should accept any two elements of the vector, and should not
     have any side effects.  PROC should return a true value when its
     first argument is strictly less than its second, and '#f'
     otherwise.

     The 'vector-sort!' procedure destructively sorts VECTOR in
     ascending order according to PROC.  The sorting algorithm performs
     O(n^2) calls to PROC where n is the length of VECTOR, and all
     arguments passed to PROC are elements of the vector being sorted,
     but the pairing of arguments and the sequencing of calls to PROC
     are not specified.  The sorting algorithm may be unstable.  The
     procedure returns unspecified values.

          (define v (vector 3 5 2 1))
          (vector-sort! < v)              => unspecified
          v                               => #(1 2 3 5)

     *Implementation responsibilities:* The implementation must check
     the restrictions on PROC to the extent performed by applying it as
     described.  An implementation may check whether PROC is an
     appropriate argument before applying it.


File: vicare-scheme.info,  Node: stdlib control,  Next: stdlib records,  Prev: stdlib sorting,  Up: stdlib

5.5 Control structures
======================

This chapter describes the '(rnrs control (6))' library, which provides
useful control structures.

 -- Syntax: when ?TEST ?EXPRESSION1 ?EXPRESSION2 ...
 -- Syntax: unless ?TEST ?EXPRESSION1 ?EXPRESSION2 ...
     ?TEST must be an expression.

     A 'when' expression is evaluated by evaluating the ?TEST
     expression.  Only if ?TEST evaluates to a true value, the remaining
     ?EXPRESSIONs are evaluated in order.  A syntax use of 'when' always
     returns zero values.

          *NOTE* This breaks R6RS compliance.  According to the
          standard: if ?TEST evaluates to a true value: the results of
          the last ?EXPRESSION are returned as the results of the entire
          'when' expression; otherwise, the 'when' expression returns
          unspecified values.

     An 'unless' expression is evaluated by evaluating the ?TEST
     expression.  Only if ?TEST evaluates to '#f', the remaining
     ?EXPRESSIONs are evaluated in order.  A syntax use of 'unless'
     always returns zero values.

          *NOTE* This breaks R6RS compliance.  According to the
          standard: if ?TEST evaluates to a true value: the results of
          the last ?EXPRESSION are returned as the results of the entire
          'unless' expression; otherwise, the 'unless' expression
          returns unspecified values.

     The 'when' and 'unless' expressions are derived forms.  They could
     be defined by the following macros:

          (define-syntax when
            (syntax-rules ()
              ((when test result1 result2 ...)
               (if test
                   (begin result1 result2 ...)))))

          (define-syntax unless
            (syntax-rules ()
              ((unless test result1 result2 ...)
               (if (not test)
                   (begin result1 result2 ...)))))

 -- Syntax: do ((?VARIABLE1 ?INIT1 ?STEP1) ...) (?TEST ?EXPRESSION ...)
          ?COMMAND ...
     The ?INITs, ?STEPs, ?TESTs, and ?COMMANDs must be expressions.  The
     ?VARIABLEs must be pairwise distinct variables.

     The 'do' expression is an iteration construct.  It specifies a set
     of variables to be bound, how they are to be initialized at the
     start, and how they are to be updated on each iteration.

     A 'do' expression is evaluated as follows: The ?INIT expressions
     are evaluated (in some unspecified order), the ?VARIABLEs are bound
     to fresh locations, the results of the ?INIT expressions are stored
     in the bindings of the ?VARIABLEs, and then the iteration phase
     begins.

     Each iteration begins by evaluating ?TEST; if the result is '#f',
     then the ?COMMANDs are evaluated in order for effect, the ?STEP
     expressions are evaluated in some unspecified order, the ?VARIABLEs
     are bound to fresh locations holding the results, and the next
     iteration begins.

     If ?TEST evaluates to a true value, the ?EXPRESSIONs are evaluated
     from left to right and the values of the last ?EXPRESSION are
     returned.  If no ?EXPRESSIONs are present, then the 'do' expression
     returns unspecified values.

     The region consists of the entire 'do' expression except for the
     ?INITs.

     A ?STEP may be omitted, in which case the effect is the same as if
     '(?VARIABLE ?INIT ?VARIABLE)' had been written instead of
     '(?VARIABLE ?INIT)'.

     If a 'do' expression appears in a tail context, the ?EXPRESSIONs
     are a ?TAIL SEQUENCE in the sense of report section *note baselib
     tail call::, i.e., the last ?EXPRESSION is also in a tail context.

          (do ((vec (make-vector 5))
               (i 0 (+ i 1)))
              ((= i 5) vec)
            (vector-set! vec i i))
          => #(0 1 2 3 4)

          (let ((x '(1 3 5 7 9)))
            (do ((x x (cdr x))
                 (sum 0 (+ sum (car x))))
                ((null? x) sum)))
          => 25

     The following definition of 'do' uses a trick to expand the
     variable clauses.

          (define-syntax do
            (syntax-rules ()
              ((do ((var init step ...) ...)
                   (test expr ...)
                   command ...)
               (letrec
                 ((loop
                   (lambda (var ...)
                     (if test
                         (begin
                           #f ; avoid empty begin
                           expr ...)
                         (begin
                           command
                           ...
                           (loop (do "step" var step ...)
                                 ...))))))
                 (loop init ...)))
              ((do "step" x)
               x)
              ((do "step" x y)
               y)))

 -- Syntax: case-lambda ?CASE-LAMBDA-CLAUSE ...
     Each ?CASE-LAMBDA-CLAUSE must be of the form:

          (?FORMALS ?BODY)

     ?FORMALS must be as in a 'lambda' form (*note baselib expressions
     procedures::), and ?BODY is as described in report section *note
     baselib bodies::.

     A 'case-lambda' expression evaluates to a procedure.  This
     procedure, when applied, tries to match its arguments to the
     ?CASE-LAMBDA-CLAUSEs in order.  The arguments match a clause if one
     of the following conditions is fulfilled:

        * ?FORMALS has the form '(?VARIABLE ...)' and the number of
          arguments is the same as the number of formal parameters in
          ?FORMALS.

        * ?FORMALS has the form:

               (?VARIABLE1 ... ?VARIABLEN . ?VARIABLEN+1)

          and the number of arguments is at least n.

        * ?FORMALS has the form '?VARIABLE'.

     For the first clause matched by the arguments, the variables of the
     ?FORMALS are bound to fresh locations containing the argument
     values in the same arrangement as with 'lambda'.

     The last expression of a ?BODY in a 'case-lambda' expression is in
     tail context.

     If the arguments match none of the clauses, an exception with
     condition type '&assertion' is raised.

          (define foo
            (case-lambda
             (() 'zero)
             ((x) (list 'one x))
             ((x y) (list 'two x y))
             ((a b c d . e) (list 'four a b c d e))
             (rest (list 'rest rest))))

          (foo)                   => zero
          (foo 1)                 => (one 1)
          (foo 1 2)               => (two 1 2)
          (foo 1 2 3)             => (rest (1 2 3))
          (foo 1 2 3 4)           => (four 1 2 3 4 ())

     The 'case-lambda' keyword can be defined in terms of 'lambda' by
     the following macros:

          (define-syntax case-lambda
            (syntax-rules ()
              ((_ (fmls b1 b2 ...))
               (lambda fmls b1 b2 ...))
              ((_ (fmls b1 b2 ...) ...)
               (lambda args
                 (let ((n (length args)))
                   (case-lambda-help args n
                     (fmls b1 b2 ...) ...))))))

          (define-syntax case-lambda-help
            (syntax-rules ()
              ((_ args n)
               (assertion-violation #f
                 "unexpected number of arguments"))
              ((_ args n ((x ...) b1 b2 ...) more ...)
               (if (= n (length '(x ...)))
                   (apply (lambda (x ...) b1 b2 ...) args)
                   (case-lambda-help args n more ...)))
              ((_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
               (if (>= n (length '(x1 x2 ...)))
                   (apply (lambda (x1 x2 ... . r) b1 b2 ...)
                             args)
                   (case-lambda-help args n more ...)))
              ((_ args n (r b1 b2 ...) more ...)
               (apply (lambda r b1 b2 ...) args))))


File: vicare-scheme.info,  Node: stdlib records,  Next: stdlib exceptions,  Prev: stdlib control,  Up: stdlib

5.6 Records
===========

This section describes abstractions for creating new data types
representing records.

* Menu:

* stdlib records intro::                Introduction.
* stdlib records mutability::           Mutability and equivalence
                                        of records.
* stdlib records syntactic layer::      Syntactic layer.
* stdlib records procedural layer::     Procedural layer.
* stdlib records inspection::           Inspection.


File: vicare-scheme.info,  Node: stdlib records intro,  Next: stdlib records mutability,  Up: stdlib records

5.6.1 Introduction
------------------

A record is a compound data structure with a fixed number of components,
called "fields".  Each record has an associated type specified by a
"record-type descriptor", which is an object that specifies the fields
of the record and various other properties that all records of that type
share.  Record objects are created by a "record constructor", a
procedure that creates a fresh record object and initializes its fields
to values.  Records of different types can be distinguished from each
other and from other types of objects by "record predicates".  A record
predicate returns '#t' when passed a record of the type specified by the
record-type descriptor and '#f' otherwise.  An "accessor" extracts from
a record the component associated with a field, and a "mutator" changes
the component to a different value.

   Record types can be extended via single inheritance, allowing record
types to model hierarchies that occur in applications like algebraic
data types as well as single-inheritance class systems.  If a record
type T extends another record type P, each record of type T is also a
record of type P, and the predicate, accessors, and mutators applicable
to a record of type P are also applicable to a record of type T.  The
extension relationship is transitive in the sense that a type extends
its parent's parent, if any, and so on.  A record type that does not
extend another record type is called a _base record type_.

   A record type can be _sealed_ to prevent it from being extended.
Moreover, a record type can be _nongenerative_, i.e., it is globally
identified by a "uid", and new, compatible definitions of a
nongenerative record type with the same uid as a previous always yield
the same record type.

   The record mechanism spans three libraries:

'(rnrs records syntactic (6))'
     Library, a syntactic layer for defining a record type and
     associated constructor, predicate, accessor, and mutators.

'(rnrs records procedural (6))'
     Library, a procedural layer for creating and manipulating record
     types and creating constructors, predicates, accessors, and
     mutators.

'(rnrs records inspection (6))'
     Library, a set of inspection procedures.

   The inspection procedures allow programs to obtain from a record
instance a descriptor for the type and from there obtain access to the
fields of the record instance.  This facility allows the creation of
portable printers and inspectors.  A program may prevent access to a
record's type (and thereby protect the information stored in the record
from the inspection mechanism) by declaring the type opaque.  Thus,
opacity as presented here can be used to enforce abstraction barriers.

   Any of the standard types mentioned in this report may or may not be
implemented as an opaque record type.  Thus, it may be possible to use
inspection on objects of the standard types.

   The procedural layer is particularly useful for writing interpreters
that construct host-compatible record types.  It may also serve as a
target for expansion of the syntactic layers.  The record operations
provided through the procedural layer may, however, be less efficient
than the operations provided through the syntactic layer, which is
designed to allow expand-time determination of record-instance sizes and
field offsets.  Therefore, alternative implementations of syntactic
record-type definition should, when possible, expand into the syntactic
layer rather than the procedural layer.

   The syntactic layer is used more commonly and therefore described
first.  This chapter uses the RTD and CONSTRUCTOR-DESCRIPTOR parameter
names for arguments that must be record-type descriptors and constructor
descriptors, respectively.


File: vicare-scheme.info,  Node: stdlib records mutability,  Next: stdlib records syntactic layer,  Prev: stdlib records intro,  Up: stdlib records

5.6.2 Mutability and equivalence of records
-------------------------------------------

The fields of a record type are designated "mutable" or "immutable".
Correspondingly, a record type with no mutable field is called
immutable, and all records of that type are immutable objects.  All
other record types are mutable, and so are their records.

   Each call to a record constructor returns a new record with a fresh
location (*note scheme basic storage model::).  Consequently, for two
records OBJ1 and OBJ2, the return value of '(eqv? OBJ1 OBJ2)', as well
as the return value of '(eq? OBJ1 OBJ2)', adheres to the following
criteria (*note baselib predicates::):

   * If OBJ1 and OBJ2 have different record types (i.e., their
     record-type descriptors are not 'eqv?'), 'eqv?' returns '#f'.

   * If OBJ1 and OBJ2 are both records of the same record type, and are
     the results of two separate calls to record constructors, then
     'eqv?' returns '#f'.
   * If OBJ1 and OBJ2 are both the result of a single call to a record
     constructor, then 'eqv?' returns '#t'.

   * If OBJ1 and OBJ2 are both records of the same record type, where
     applying an accessor to both yields results for which 'eqv?'
     returns '#f', then 'eqv?' returns '#f'.


File: vicare-scheme.info,  Node: stdlib records syntactic layer,  Next: stdlib records procedural layer,  Prev: stdlib records mutability,  Up: stdlib records

5.6.3 Syntactic layer
---------------------

The syntactic layer is provided by the '(rnrs records syntactic (6))'
library.  Some details of the specification are explained in terms of
the specification of the procedural layer.  *note Procedural layer:
stdlib records procedural layer.

   The record-type-defining form 'define-record-type' is a definition
and can appear anywhere any other ?DEFINITION can appear (for Vicare's
extensions to record type definitions see *note define-record-type:
iklib records defs.).

 -- Syntax: define-record-type ?NAME-SPEC ?RECORD-CLAUSE*
     A 'define-record-type' form defines a record type along with
     associated constructor descriptor and constructor, predicate, field
     accessors, and field mutators.  The 'define-record-type' form
     expands into a set of definitions in the environment where
     'define-record-type' appears; hence, it is possible to refer to the
     bindings (except for that of the record type itself) recursively.

     The ?NAME-SPEC specifies the names of the record type, constructor,
     and predicate.  It must take one of the following forms:

          (?RECORD-NAME ?CONSTRUCTOR-NAME ?PREDICATE-NAME)
          ?RECORD-NAME

     ?RECORD-NAME, ?CONSTRUCTOR-NAME, and ?PREDICATE-NAME must all be
     identifiers.

     ?RECORD-NAME, taken as a symbol, becomes the name of the record
     type.  (See the description of 'make-record-type-descriptor'
     below.)  Additionally, it is bound by this definition to an
     expand-time or run-time representation of the record type and can
     be used as parent name in syntactic record-type definitions that
     extend this definition.  It can also be used as a handle to gain
     access to the underlying record-type descriptor and constructor
     descriptor (see 'record-type-descriptor' and
     'record-constructor-descriptor' below).

     ?CONSTRUCTOR-NAME is defined by this definition to be a constructor
     for the defined record type, with a protocol specified by the
     'protocol' clause, or, in its absence, using a default protocol.
     For details, see the description of the 'protocol' clause below.

     ?PREDICATE-NAME is defined by this definition to a predicate for
     the defined record type.

     The second form of ?NAME-SPEC is an abbreviation for the first
     form, where the name of the constructor is generated by prefixing
     the record name with 'make-', and the predicate name is generated
     by adding a question mark ('?') to the end of the record name.  For
     example, if the record name is 'frob', the name of the constructor
     is 'make-frob', and the predicate name is 'frob?'.

     Each ?RECORD-CLAUSE must take one of the following forms; it is a
     syntax violation if multiple ?RECORD-CLAUSEs of the same kind
     appear in a 'define-record-type' form.

 -- Auxiliary Syntax: fields ?FIELD-SPEC*
     Each ?FIELD-SPEC has one of the following forms

          (immutable ?FIELD-NAME ?ACCESSOR-NAME)
          (mutable ?FIELD-NAME
                   ?ACCESSOR-NAME ?MUTATOR-NAME)
          (immutable ?FIELD-NAME)
          (mutable ?FIELD-NAME)
          ?FIELD-NAME

     ?FIELD-NAME, ?ACCESSOR-NAME, and ?MUTATOR-NAME must all be
     identifiers.  The first form declares an immutable field called
     ?FIELD-NAME, with the corresponding accessor named ?ACCESSOR-NAME.
     The second form declares a mutable field called ?FIELD-NAME, with
     the corresponding accessor named ?ACCESSOR-NAME, and with the
     corresponding mutator named ?MUTATOR-NAME.

     If ?FIELD-SPEC takes the third or fourth form, the accessor name is
     generated by appending the record name and field name with a hyphen
     separator, and the mutator name (for a mutable field) is generated
     by adding a '-set!' suffix to the accessor name.  For example, if
     the record name is 'frob' and the field name is 'widget', the
     accessor name is 'frob-widget' and the mutator name is
     'frob-widget-set!'.

     If ?FIELD-SPEC is just a ?FIELD NAME form, it is an abbreviation
     for '(immutable ?FIELD-NAME)'.

     The ?FIELD-NAMEs become, as symbols, the names of the fields in the
     record-type descriptor being created, in the same order.

     The 'fields' clause may be absent; this is equivalent to an empty
     'fields' clause.

 -- Auxiliary Syntax: parent ?PARENT-NAME
     Specifies that the record type is to have parent type ?PARENT-NAME,
     where ?PARENT-NAME is the ?RECORD-NAME of a record type previously
     defined using 'define-record-type'.  The record-type definition
     associated with ?PARENT-NAME must not be sealed.  If no 'parent'
     clause and no 'parent-rtd' (*note stdlib records procedural
     layer::) clause is present, the record type is a base type.

 -- Auxiliary Syntax: protocol ?EXPRESSION
     ?EXPRESSION is evaluated in the same environment as the
     'define-record-type' form, and must evaluate to a protocol
     appropriate for the record type being defined.

     The protocol is used to create a record-constructor descriptor as
     described below.  If no 'protocol' clause is specified, a
     constructor descriptor is still created using a default protocol.
     The clause can be absent only if the record type being defined has
     no parent type, or if the parent definition does not specify a
     protocol.

 -- Auxiliary Syntax: sealed #t
 -- Auxiliary Syntax: sealed #f
     If this option is specified with operand '#t', the defined record
     type is sealed, i.e., no extensions of the record type can be
     created.  If this option is specified with operand '#f', or is
     absent, the defined record type is not sealed.

 -- Auxiliary Syntax: opaque #t
 -- Auxiliary Syntax: opaque #f
     If this option is specified with operand '#t', or if an opaque
     parent record type is specified, the defined record type is opaque.
     Otherwise, the defined record type is not opaque.  See the
     specification of 'record-rtd' below for details.

 -- Auxiliary Syntax: nongenerative ?UID
 -- Auxiliary Syntax: nongenerative
     This specifies that the record type is nongenerative with unique
     identifier (UID) ?UID, which must be an ?IDENTIFIER.  If ?UID is
     absent, a unique UID is generated at macro-expansion time.

          *NOTE* Under Vicare, the UID is generated by appending the
          record-type name to 'vicare:nongenerative:'.

     If two record-type definitions specify the same UID, then the
     record-type definitions should be equivalent, i.e., the implied
     arguments to 'make-record-type-descriptor' must be equivalent as
     described under 'make-record-type-descriptor'.

     If this condition is not met, it is either considered a syntax
     violation or an exception with condition type '&assertion' is
     raised.  If the condition is met, a single record type is generated
     for both definitions.

     In the absence of a 'nongenerative' clause, a new record type is
     generated every time a 'define-record-type' form is evaluated:

          (let ((f (lambda (x)
                     (define-record-type r ...)
                     (if x r? (make-r ...)))))
            ((f #t) (f #f)))
          => #f

          *NOTE* On Vicare: the 'value' slot of the symbol object used
          as ?UID holds the record-type descriptor object.

 -- Auxiliary Syntax: parent-rtd ?PARENT-RTD ?PARENT-CD
     Specifies that the record type is to have its parent type specified
     by ?PARENT-RTD, which should be an expression evaluating to a
     record-type descriptor, and ?PARENT-CD, which should be an
     expression evaluating to a constructor descriptor (*note
     'make-record-constructor-descriptor': stdlib records procedural
     layer.).  Either ?PARENT-RTD or ?PARENT-CD can evaluate to '#f'.
     The record-type definition associated with the value of ?PARENT-RTD
     must not be sealed.  Moreover, a record-type definition must not
     have both a 'parent' and a 'parent-rtd' clause.

          *Note* The syntactic layer is designed to allow
          record-instance sizes and field offsets to be determined at
          expand time, i.e., by a macro definition of
          'define-record-type', as long as the parent (if any) is known.
          Implementations that take advantage of this may generate less
          efficient constructor, accessor, and mutator code when the
          'parent-rtd' clause is used, since the type of the parent is
          generally not known until run time.  The 'parent' clause
          should therefore be used instead when possible.

   All bindings created by 'define-record-type' (for the record type,
the constructor, the predicate, the accessors, and the mutators) must
have names that are pairwise distinct.

   The constructor created by a 'define-record-type' form is a procedure
as follows:

   * If there is no 'parent' clause and no 'protocol' clause, the
     constructor accepts as many arguments as there are fields, in the
     same order as they appear in the 'fields' clause, and returns a
     record object with the fields initialized to the corresponding
     arguments.

   * If there is no 'parent' or 'parent-rtd' clause and a 'protocol'
     clause, the protocol expression must evaluate to a procedure that
     accepts a single argument.  The protocol procedure is called once
     during the evaluation of the 'define-record-type' form with a
     procedure P as its argument.  It should return a procedure, which
     will become the constructor bound to ?CONSTRUCTOR-NAME.  The
     procedure P accepts as many arguments as there are fields, in the
     same order as they appear in the 'fields' clause, and returns a
     record object with the fields initialized to the corresponding
     arguments.

     The constructor returned by the protocol procedure can accept an
     arbitrary number of arguments, and should call P once to construct
     a record object, and return that record object.

     For example, the following protocol expression for a record-type
     definition with three fields creates a constructor that accepts
     values for all fields, and initializes them in the reverse order of
     the arguments:

          (lambda (p)
            (lambda (v1 v2 v3)
              (p v3 v2 v1)))

   * If there is both a 'parent' clause and a 'protocol' clause, then
     the protocol procedure is called once with a procedure N as its
     argument.  As in the previous case, the protocol procedure should
     return a procedure, which will become the constructor bound to
     ?CONSTRUCTOR-NAME.  However, N is different from P in the previous
     case: It accepts arguments corresponding to the arguments of the
     constructor of the parent type.  It then returns a procedure P that
     accepts as many arguments as there are (additional) fields in this
     type, in the same order as in the 'fields' clause, and returns a
     record object with the fields of the parent record types
     initialized according to their constructors and the arguments to N,
     and the fields of this record type initialized to its arguments of
     P.

     The constructor returned by the protocol procedure can accept an
     arbitrary number of arguments, and should call N once to construct
     the procedure P, and call P once to create the record object, and
     finally return that record object.

     For example, the following protocol expression assumes that the
     constructor of the parent type takes three arguments:

          (lambda (n)
            (lambda (v1 v2 v3 x1 x2 x3 x4)
              (let ((p (n v1 v2 v3)))
                (p x1 x2 x3 x4))))

     The resulting constructor accepts seven arguments, and initializes
     the fields of the parent types according to the constructor of the
     parent type, with V1, V2, and V3 as arguments.  It also initializes
     the fields of this record type to the values of X1, ..., X4.

   * If there is a 'parent' clause, but no 'protocol' clause, then the
     parent type must not have a 'protocol' clause itself.  The
     constructor bound to ?CONSTRUCTOR-NAME is a procedure that accepts
     arguments corresponding to the parent types' constructor first, and
     then one argument for each field in the same order as in the
     'fields' clause.  The constructor returns a record object with the
     fields initialized to the corresponding arguments.

   * If there is a 'parent-rtd' clause, then the constructor is as with
     a 'parent' clause, except that the constructor of the parent type
     is determined by the constructor descriptor of the 'parent-rtd'
     clause.

   A protocol may perform other actions consistent with the requirements
described above, including mutation of the new record or other side
effects, before returning the record.

   Any definition that takes advantage of implicit naming for the
constructor, predicate, accessor, and mutator names can be rewritten
trivially to a definition that specifies all names explicitly.  For
example, the implicit-naming record definition:

     (define-record-type frob
       (fields (mutable widget))
       (protocol
         (lambda (p)
           (lambda (n) (p (make-widget n))))))

is equivalent to the following explicit-naming record definition.

     (define-record-type (frob make-frob frob?)
       (fields (mutable widget
                        frob-widget
                        frob-widget-set!))
       (protocol
         (lambda (p)
           (lambda (n) (p (make-widget n))))))

   Also, the implicit-naming record definition:

     (define-record-type point (fields x y))

is equivalent to the following explicit-naming record definition:

     (define-record-type (point make-point point?)
       (fields
         (immutable x point-x)
         (immutable y point-y)))

   With implicit naming, it is still possible to specify some of the
names explicitly; for example, the following overrides the choice of
accessor and mutator names for the widget field.

     (define-record-type frob
       (fields (mutable widget getwid setwid!))
       (protocol
         (lambda (p)
           (lambda (n) (p (make-widget n))))))

 -- Syntax: record-type-descriptor ?RECORD-NAME
     Evaluates to the record-type descriptor (see below) associated with
     the type specified by ?RECORD-NAME.

          *NOTE* The 'record-type-descriptor' procedure works on both
          opaque and non-opaque record types.

 -- Syntax: record-constructor-descriptor ?RECORD-NAME
     Evaluates to the record-constructor descriptor (see below)
     associated with ?RECORD-NAME.

   The following example uses the 'record?' procedure from the '(rnrs
records inspection (6))' library:

     (define-record-type (point make-point point?)
       (fields (immutable x point-x)
               (mutable y point-y set-point-y!))
       (nongenerative
         point-4893d957-e00b-11d9-817f-00111175eb9e))

     (define-record-type (cpoint make-cpoint cpoint?)
       (parent point)
       (protocol
        (lambda (n)
          (lambda (x y c)
            ((n x y) (color->rgb c)))))
       (fields
         (mutable rgb cpoint-rgb cpoint-rgb-set!)))

     (define (color->rgb c)
       (cons 'rgb c))

     (define p1 (make-point 1 2))
     (define p2 (make-cpoint 3 4 'red))

     (point? p1)                             => #t
     (point? p2)                             => #t
     (point? (vector))                       => #f
     (point? (cons 'a 'b))                   => #f
     (cpoint? p1)                            => #f
     (cpoint? p2)                            => #f
     (point-x p1)                            => 1
     (point-y p1)                            => 2
     (point-x p2)                            => 3
     (point-y p2)                            => 4
     (cpoint-rgb p2)                         => (rgb . red)

     (set-point-y! p1 17)                    => unspecified
     (point-y p1)                            => 17

     (record-rtd p1)
     => (record-type-descriptor point)

     (define-record-type (ex1 make-ex1 ex1?)
       (protocol (lambda (p) (lambda a (p a))))
       (fields (immutable f ex1-f)))

     (define ex1-i1 (make-ex1 1 2 3))
     (ex1-f ex1-i1)                          => (1 2 3)

     (define-record-type (ex2 make-ex2 ex2?)
       (protocol
         (lambda (p) (lambda (a . b) (p a b))))
       (fields (immutable a ex2-a)
               (immutable b ex2-b)))

     (define ex2-i1 (make-ex2 1 2 3))
     (ex2-a ex2-i1)                          => 1
     (ex2-b ex2-i1)                          => (2 3)

     (define-record-type (unit-vector
                          make-unit-vector
                          unit-vector?)
       (protocol
        (lambda (p)
          (lambda (x y z)
            (let ((length
                    (sqrt (+ (* x x)
                             (* y y)
                             (* z z)))))
              (p (/ x length)
                 (/ y length)
                 (/ z length))))))
       (fields (immutable x unit-vector-x)
               (immutable y unit-vector-y)
               (immutable z unit-vector-z)))

     (define *ex3-instance* #f)

     (define-record-type ex3
       (parent cpoint)
       (protocol
        (lambda (n)
          (lambda (x y t)
            (let ((r ((n x y 'red) t)))
              (set! *ex3-instance* r)
              r))))
       (fields
        (mutable thickness))
       (sealed #t) (opaque #t))

     (define ex3-i1 (make-ex3 1 2 17))
     (ex3? ex3-i1)                           => #t
     (cpoint-rgb ex3-i1) => (rgb . red)
     (ex3-thickness ex3-i1)                  => 17
     (ex3-thickness-set! ex3-i1 18)          => unspecified
     (ex3-thickness ex3-i1)                  => 18
     *ex3-instance*                          => ex3-i1

     (record? ex3-i1)                        => #f


File: vicare-scheme.info,  Node: stdlib records procedural layer,  Next: stdlib records inspection,  Prev: stdlib records syntactic layer,  Up: stdlib records

5.6.4 Procedural layer
----------------------

The procedural layer is provided by the '(rnrs records procedural (6))'
library.

 -- Procedure: make-record-type-descriptor NAME PARENT UID SEALED?
          OPAQUE? FIELDS
     Return a "record-type descriptor" (RTD) representing a record type
     distinct from all built-in types and other record types.

     The NAME argument must be a symbol.  It names the record type, and
     is intended purely for informational purposes and may be used for
     printing by the underlying Scheme system.

     The PARENT argument must be either '#f' or an RTD.  If it is an
     RTD, the returned record type, T, extends the record type P
     represented by PARENT.  An exception with condition type
     '&assertion' is raised if PARENT is sealed (see below).

     The UID argument must be either '#f' or a symbol.  If UID is a
     symbol, the record-creation operation is _nongenerative_ i.e., a
     new record type is created only if no previous call to
     'make-record-type-descriptor' was made with the UID.  If UID is
     '#f', the record-creation operation is _generative_, i.e., a new
     record type is created even if a previous call to
     'make-record-type-descriptor' was made with the same arguments.

     If 'make-record-type-descriptor' is called twice with the same UID
     symbol, the parent arguments in the two calls must be 'eqv?', the
     FIELDS arguments 'equal?', the SEALED? arguments boolean-equivalent
     (both '#f' or both true), and the OPAQUE? arguments
     boolean-equivalent.  If these conditions are not met, an exception
     with condition type '&assertion' is raised when the second call
     occurs.  If they are met, the second call returns, without creating
     a new record type, the same record-type descriptor (in the sense of
     'eqv?') as the first call.

          *NOTE* Users are encouraged to use symbol names constructed
          using the UUID namespace (for example, using the record-type
          name as a prefix) for the uid argument.

     The SEALED? flag must be a boolean.  If true, the returned record
     type is sealed, i.e., it cannot be extended.

     The OPAQUE? flag must be a boolean.  If true, the record type is
     opaque.  If passed an instance of the record type, 'record?'
     returns '#f'.  Moreover, if 'record-rtd' is called with an instance
     of the record type, an exception with condition type '&assertion'
     is raised.  The record type is also opaque if an opaque parent is
     supplied.  If OPAQUE? is '#f' and an opaque parent is not supplied,
     the record is not opaque.

     The FIELDS argument must be a vector of field specifiers.  Each
     field specifier must be a list of the form '(mutable NAME)' or a
     list of the form '(immutable NAME)'.  Each name must be a symbol
     and names the corresponding field of the record type; the names
     need not be distinct.  A field identified as mutable may be
     modified, whereas, when a program attempts to obtain a mutator for
     a field identified as immutable, an exception with condition type
     '&assertion' is raised.  Where field order is relevant, e.g., for
     record construction and field access, the fields are considered to
     be ordered as specified, although no particular order is required
     for the actual representation of a record instance.

     The specified fields are added to the parent fields, if any, to
     determine the complete set of fields of the returned record type.
     If FIELDS is modified after 'make-record-type-descriptor' has been
     called, the effect on the returned RTD is unspecified.

     A generative record-type descriptor created by a call to
     'make-record-type-descriptor' is not 'eqv?' to any record-type
     descriptor (generative or nongenerative) created by another call to
     'make-record-type-descriptor'.  A generative record-type descriptor
     is 'eqv?' only to itself, i.e., '(eqv? RTD1 RTD2)' if, and only if,
     '(eq? RTD1 RTD2)'.  Also, two nongenerative record-type descriptors
     are 'eqv?' if, and only if, they were created by calls to
     'make-record-type-descriptor' with the same uid arguments.

 -- Procedure: record-type-descriptor? OBJ
     Return '#t' if the argument is a record-type descriptor, '#f'
     otherwise.

 -- Procedure: make-record-constructor-descriptor RTD
          PARENT-CONSTRUCTOR-DESCRIPTOR PROTOCOL
     Return a "record-constructor descriptor" (or "constructor
     descriptor" for short) that specifies a "record constructor" (or
     "constructor" for short), that can be used to construct record
     values of the type specified by RTD, and which can be obtained via
     'record-constructor'.  A constructor descriptor can also be used to
     create other constructor descriptors for subtypes of its own record
     type.  RTD must be a record-type descriptor.  PROTOCOL must be a
     procedure or '#f'.  If it is '#f', a default PROTOCOL procedure is
     supplied.

     If PROTOCOL is a procedure, it is handled analogously to the
     protocol expression in a 'define-record-type' form.

     If RTD is a base record type PARENT-CONSTRUCTOR-DESCRIPTOR must be
     '#f'.  In this case, PROTOCOL is called by 'record-constructor'
     with a single argument P.  P is a procedure that expects one
     argument for every field of RTD and returns a record with the
     fields of RTD initialized to these arguments.  The procedure
     returned by PROTOCOL should call P once with the number of
     arguments P expects and return the resulting record as shown in the
     simple example below:

          (lambda (p)
            (lambda (v1 v2 v3)
              (p v1 v2 v3)))

     Here, the call to P returns a record whose fields are initialized
     with the values of V1, V2, and V3.  The expression above is
     equivalent to '(lambda (p) p)'.  Note that the procedure returned
     by PROTOCOL is otherwise unconstrained; specifically, it can take
     any number of arguments.

     If RTD is an extension of another record type PARENT-RTD and
     PROTOCOL is a procedure, PARENT-CONSTRUCTOR-DESCRIPTOR must be a
     constructor descriptor of PARENT-RTD or '#f'.  If
     PARENT-CONSTRUCTOR-DESCRIPTOR is a constructor descriptor, PROTOCOL
     is called by 'record-constructor' with a single argument N, which
     is a procedure that accepts the same number of arguments as the
     constructor of PARENT-CONSTRUCTOR-DESCRIPTOR and returns a
     procedure P that, when called, constructs the record itself.  The P
     procedure expects one argument for every field of RTD (not
     including parent fields) and returns a record with the fields of
     RTD initialized to these arguments, and the fields of PARENT-RTD
     and its parents initialized as specified by
     PARENT-CONSTRUCTOR-DESCRIPTOR.

     The procedure returned by PROTOCOL should call N once with the
     number of arguments N expects, call the procedure P it returns once
     with the number of arguments P expects and return the resulting
     record.  A simple PROTOCOL in this case might be written as
     follows:

          (lambda (n)
            (lambda (v1 v2 v3 x1 x2 x3 x4)
              (let ((p (n v1 v2 v3)))
                (p x1 x2 x3 x4))))

     This passes arguments V1, V2, V3 to N for
     PARENT-CONSTRUCTOR-DESCRIPTOR and calls 'p' with X1, ..., X4 to
     initialize the fields of RTD itself.

     Thus, the constructor descriptors for a record type form a sequence
     of protocols parallel to the sequence of record-type parents.  Each
     constructor descriptor in the chain determines the field values for
     the associated record type.  Child record constructors need not
     know the number or contents of parent fields, only the number of
     arguments accepted by the parent constructor.

     PROTOCOL may be '#f', specifying a default constructor that accepts
     one argument for each field of RTD (including the fields of its
     parent type, if any).  Specifically, if RTD is a base type, the
     default PROTOCOL procedure behaves as if it were '(lambda (p) p)'.
     If RTD is an extension of another type, then
     PARENT-CONSTRUCTOR-DESCRIPTOR must be either '#f' or itself specify
     a default constructor, and the default PROTOCOL procedure behaves
     as if it were:

          (lambda (n)
            (lambda (V1 ... VJ X1 ... XK)
              (let ((p (n V1 ... VJ)))
                (p X1 ... XK))))

     The resulting constructor accepts one argument for each of the
     record type's complete set of fields (including those of the parent
     record type, the parent's parent record type, etc.)  and returns a
     record with the fields initialized to those arguments, with the
     field values for the parent coming before those of the extension in
     the argument list.  (In the example, _j_ is the complete number of
     fields of the parent type, and $k$ is the number of fields of RTD
     itself.)

     If RTD is an extension of another record type and
     PARENT-CONSTRUCTOR-DESCRIPTOR is '#f',
     PARENT-CONSTRUCTOR-DESCRIPTOR is treated as if it were a
     constructor descriptor for the parent rtd of RTD with a default
     protocol.

     *Implementation responsibilities:* If PROTOCOL is a procedure, the
     implementation must check the restrictions on it to the extent
     performed by applying it as described when the constructor is
     called.  An implementation may check whether PROTOCOL is an
     appropriate argument before applying it.

          (define rtd1
            (make-record-type-descriptor
             'rtd1 #f #f #f #f
             '#((immutable x1) (immutable x2))))

          (define rtd2
            (make-record-type-descriptor
             'rtd2 rtd1 #f #f #f
             '#((immutable x3) (immutable x4))))

          (define rtd3
            (make-record-type-descriptor
             'rtd3 rtd2 #f #f #f
             '#((immutable x5) (immutable x6))))

          (define protocol1
            (lambda (p)
              (lambda (a b c)
                (p (+ a b) (+ b c)))))

          (define protocol2
            (lambda (n)
              (lambda (a b c d e f)
                (let ((p (n a b c)))
                  (p (+ d e) (+ e f))))))

          (define protocol3
            (lambda (n)
              (lambda (a b c d e f g h i)
                (let ((p (n a b c d e f)))
                  (p (+ g h) (+ h i))))))

          (define cd1
            (make-record-constructor-descriptor
              rtd1 #f protocol1))

          (define cd2
            (make-record-constructor-descriptor
              rtd2 cd1 protocol2))

          (define cd3
            (make-record-constructor-descriptor
              rtd3 cd2 protocol3))

          (define make-rtd1 (record-constructor cd1))

          (define make-rtd2 (record-constructor cd2))

          (define make-rtd3 (record-constructor cd3))

          (make-rtd3 1 2 3 4 5 6 7 8 9)
          => #<record with fields initialized to 3, 5, 9, 11, 15, 17>

 -- Procedure: record-constructor CONSTRUCTOR-DESCRIPTOR
     Call the PROTOCOL of CONSTRUCTOR-DESCRIPTOR (as described for
     'make-record-constructor-descriptor') and return the resulting
     constructor CONSTRUCTOR for records of the record type associated
     with CONSTRUCTOR-DESCRIPTOR.

 -- Procedure: record-predicate RTD
     Return a procedure that, given an object OBJ, returns '#t' if OBJ
     is a record of the type represented by RTD, and '#f' otherwise.

 -- Procedure: record-accessor RTD K
     K must be a valid field index of RTD.  The 'record-accessor'
     procedure returns a one-argument procedure whose argument must be a
     record of the type represented by RTD.  This procedure returns the
     value of the selected field of that record.

     The field selected corresponds to the Kth element (0-based) of the
     FIELDS argument to the invocation of 'make-record-type-descriptor'
     that created RTD.  Note that K cannot be used to specify a field of
     any type RTD extends.

 -- Procedure: record-mutator RTD K
     K must be a valid field index of RTD.  The 'record-mutator'
     procedure returns a two-argument procedure whose arguments must be
     a record record R of the type represented by RTD and an object OBJ.
     This procedure stores OBJ within the field of R specified by K.
     The K argument is as in 'record-accessor'.  If K specifies an
     immutable field, an exception with condition type '&assertion' is
     raised.  The mutator returns unspecified values.

     (define :point
       (make-record-type-descriptor
         'point #f
         #f #f #f
         '#((mutable x) (mutable y))))

     (define :point-cd
       (make-record-constructor-descriptor :point #f #f))

     (define make-point (record-constructor :point-cd))

     (define point? (record-predicate :point))
     (define point-x (record-accessor :point 0))
     (define point-y (record-accessor :point 1))
     (define point-x-set! (record-mutator :point 0))
     (define point-y-set! (record-mutator :point 1))

     (define p1 (make-point 1 2))
     (point? p1)                             => #t
     (point-x p1)                            => 1
     (point-y p1)                            => 2
     (point-x-set! p1 5)                     => unspecified
     (point-x p1)                            => 5

     (define :point2
       (make-record-type-descriptor
         'point2 :point
         #f #f # f '#((mutable x) (mutable y))))

     (define make-point2
       (record-constructor
         (make-record-constructor-descriptor :point2
           #f #f)))
     (define point2? (record-predicate :point2))
     (define point2-xx (record-accessor :point2 0))
     (define point2-yy (record-accessor :point2 1))

     (define p2 (make-point2 1 2 3 4))
     (point? p2)                             => #t
     (point-x p2)                            => 1
     (point-y p2)                            => 2
     (point2-xx p2)                          => 3
     (point2-yy p2)                          => 4

     (define :point-cd/abs
       (make-record-constructor-descriptor
        :point #f
        (lambda (new)
          (lambda (x y)
            (new (abs x) (abs y))))))

     (define make-point/abs
       (record-constructor :point-cd/abs))

     (point-x (make-point/abs -1 -2))        => 1
     (point-y (make-point/abs -1 -2))        => 2

     (define :cpoint
       (make-record-type-descriptor
        'cpoint :point
        #f #f #f
        '#((mutable rgb))))

     (define make-cpoint
       (record-constructor
        (make-record-constructor-descriptor
         :cpoint :point-cd
         (lambda (p)
           (lambda (x y c)
     	((p x y) (color->rgb c)))))))

     (define make-cpoint/abs
       (record-constructor
        (make-record-constructor-descriptor
         :cpoint :point-cd/abs
         (lambda (p)
           (lambda (x y c)
     	((p x y) (color->rgb c)))))))

     (define cpoint-rgb
       (record-accessor :cpoint 0))

     (define (color->rgb c)
       (cons 'rgb c))

     (cpoint-rgb (make-cpoint -1 -3 'red))   => (rgb . red)
     (point-x (make-cpoint -1 -3 'red))      => -1
     (point-x (make-cpoint/abs -1 -3 'red))  => 1


File: vicare-scheme.info,  Node: stdlib records inspection,  Prev: stdlib records procedural layer,  Up: stdlib records

5.6.5 Inspection
----------------

The '(rnrs records inspection (6))' library provides procedures for
inspecting records and their record-type descriptors.  These procedures
are designed to allow the writing of portable printers and inspectors.

   On the one hand, 'record?' and 'record-rtd' treat records of opaque
record types as if they were not records.  On the other hand, the
inspection procedures that operate on record-type descriptors themselves
are not affected by opacity.  In other words, opacity controls whether a
program can obtain an RTD from a record.  If the program has access to
the original RTD via 'make-record-type-descriptor' or
'record-type-descriptor', it can still make use of the inspection
procedures.

 -- Procedure: record? OBJ
     Return '#t' if OBJ is a record, and its record type is not opaque,
     and return '#f' otherwise.

 -- Procedure: record-rtd RECORD
     Return the RTD representing the type of RECORD if the type is not
     opaque.  The RTD of the most precise type is returned; that is, the
     type T such that RECORD is of type T but not of any type that
     extends T.  If the type is opaque, an exception is raised with
     condition type '&assertion'.

 -- Procedure: record-type-name RTD
     Return a symbol representing the name of the record-type descriptor
     RTD.

 -- Procedure: record-type-parent RTD
     Return the parent of the record-type descriptor RTD, or '#f' if it
     has none.

 -- Procedure: record-type-uid RTD
     Return the UID of the record-type descriptor RTD, or '#f' if it has
     none.  (An implementation may assign a generated UID to a record
     type even if the type is generative, so the return of a UID does
     not necessarily imply that the type is nongenerative.)

 -- Procedure: record-type-generative? RTD
     Return '#t' if RTD is generative, and '#f' if not.

 -- Procedure: record-type-sealed? RTD
     Return '#t' if the record-type descriptor is sealed, and '#f' if
     not.

 -- Procedure: record-type-opaque? RTD
     Return '#t' if the the record-type descriptor is opaque, and '#f'
     if not.

 -- Procedure: record-type-field-names RTD
     Return a vector of symbols naming the fields of the type
     represented by RTD (not including the fields of parent types) where
     the fields are ordered as described under
     'make-record-type-descriptor'.  The returned vector may be
     immutable.  If the returned vector is modified, the effect on RTD
     is unspecified.

 -- Procedure: record-field-mutable? RTD K
     Returns '#t' if the field specified by K of the type represented by
     RTD is mutable, and '#f' if not.  K is as in 'record-accessor'.


File: vicare-scheme.info,  Node: stdlib exceptions,  Next: stdlib io,  Prev: stdlib records,  Up: stdlib

5.7 Exceptions and conditions
=============================

Scheme allows programs to deal with exceptional situations using two
cooperating facilities: The exception system for raising and handling
exceptional situations, and the condition system for describing these
situations.

   The exception system allows the program, when it detects an
exceptional situation, to pass control to an exception handler, and to
dynamically establish such exception handlers.  Exception handlers are
always invoked with an object describing the exceptional situation.
Scheme's condition system provides a standardized taxonomy of such
descriptive objects, as well as a facility for extending the taxonomy.

* Menu:

* stdlib exceptions exceptions::        Exceptions.
* stdlib exceptions conditions::        Conditions.


File: vicare-scheme.info,  Node: stdlib exceptions exceptions,  Next: stdlib exceptions conditions,  Up: stdlib exceptions

5.7.1 Exceptions
----------------

This section describes Scheme's exception-handling and exception-raising
constructs provided by the '(rnrs exceptions (6))' library.

   Exception handlers are one-argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

   The program raises an exception by invoking the current exception
handler, passing it an object encapsulating information about the
exception.  Any procedure accepting one argument may serve as an
exception handler and any object may be used to represent an exception.

   The system maintains the current exception handler as part of the
dynamic environment of the program (*note scheme basic dynamic
extent::).

   When a program begins its execution, the current exception handler is
expected to handle all '&serious' conditions by interrupting execution,
reporting that an exception has been raised, and displaying information
about the condition object that was provided.  The handler may then
exit, or may provide a choice of other options.  Moreover, the exception
handler is expected to return when passed any other non-'&serious'
condition.  Interpretation of these expectations necessarily depends
upon the nature of the system in which programs are executed, but the
intent is that users perceive the raising of an exception as a
controlled escape from the situation that raised the exception, not as a
crash.

 -- Procedure: with-exception-handler HANDLER THUNK
     HANDLER must be a procedure and should accept one argument.  THUNK
     must be a procedure that accepts zero arguments.  The
     'with-exception-handler' procedure returns the results of invoking
     THUNK.  HANDLER is installed as the current exception handler for
     the dynamic extent (as determined by 'dynamic-wind') of the
     invocation of THUNK.

     *Implementation responsibilities:* The implementation must check
     the restrictions on HANDLER to the extent performed by applying it
     as described when it is called as a result of a call to 'raise' or
     'raise-continuable'.  An implementation may check whether HANDLER
     is an appropriate argument before applying it.

 -- Syntax: guard (?VARIABLE ?COND-CLAUSE1 ?COND-CLAUSE2 ...) ?BODY
 -- Auxiliary Syntax: =>
 -- Auxiliary Syntax: else
     Each ?COND-CLAUSE is as in the specification of 'cond', *note
     baselib expressions derived cond::.  '=>' and 'else' are the same
     as in the '(rnrs base (6))' library.

     Evaluating a 'guard' form evaluates ?BODY with an exception handler
     that binds the raised object to ?VARIABLE and within the scope of
     that binding evaluates the clauses as if they were the clauses of a
     'cond' expression.  That implicit 'cond' expression is evaluated
     with the continuation and dynamic environment of the 'guard' form.
     If every ?COND-CLAUSE's ?TEST evaluates to '#f' and there is no
     'else' clause, then 'raise-continuable' is re-invoked on the raised
     object within the dynamic environment of the original call to
     'raise' except that the current exception handler is that of the
     'guard' expression.

     The final expression in a 'cond' clause is in a tail context if the
     'guard' expression itself is.

 -- Procedure: raise OBJ
     Raise a non-continuable exception by invoking the current exception
     handler on OBJ.  The handler is called with a continuation whose
     dynamic environment is that of the call to 'raise', except that the
     current exception handler is the one that was in place when the
     handler being called was installed.  When the handler returns, a
     non-continuable exception with condition type '&non-continuable' is
     raised in the same dynamic environment as the handler.

 -- Procedure: raise-continuable OBJ
     Raise a _continuable exception_ by invoking the current exception
     handler on OBJ.  The handler is called with a continuation that is
     equivalent to the continuation of the call to 'raise-continuable',
     with these two exceptions:

       1. The current exception handler is the one that was in place
          when the handler being called was installed.

       2. If the handler being called returns, then it will again become
          the current exception handler.

     If the handler returns, the values it returns become the values
     returned by the call to 'raise-continuable'.

   Miscellaneous examples:

     (guard (con
              ((error? con)
               (if (message-condition? con)
                   (display (condition-message con))
                   (display "an error has occurred"))
               'error)
              ((violation? con)
               (if (message-condition? con)
                   (display (condition-message con))
                   (display "the program has a bug"))
               'violation))
       (raise
         (condition
           (make-error)
           (make-message-condition "I am an error"))))
     -| I am an error
     => error

     (guard (con
              ((error? con)
               (if (message-condition? con)
                   (display (condition-message con))
                   (display "an error has occurred"))
               'error))
       (raise
         (condition
           (make-violation)
           (make-message-condition "I am an error"))))
     => exception &violation

     (guard (con
              ((error? con)
               (display "error opening file")
               #f))
       (call-with-input-file "foo.scm" read))
     -| error opening file
     => #f

     (with-exception-handler
       (lambda (con)
         (cond
           ((not (warning? con))
            (raise con))
           ((message-condition? con)
            (display (condition-message con)))
           (else
            (display "a warning has been issued")))
         42)
       (lambda ()
         (+ (raise-continuable
              (condition
                (make-warning)
                (make-message-condition
                  "should be a number")))
            23)))
     -| should be a number
     => 65

Discussion on a possible implementation
.......................................

Given a single-thread program, the following implementation of
'with-exception-handler', 'raise' and 'raise-continuable' is compliant:

     (import (except (rnrs)
                     with-exception-handler
                     raise
                     raise-continuable
                     guard))

     (define default-error-port (current-error-port))

     (define stack-of-handlers
       (list
        (lambda (raised-object)
          (display "unhandled exception:\n" default-error-port)
          (display raised-object default-error-port)
          (newline default-error-port)
          (when (serious-condition? raised-object)
            (exit -1)))
        (lambda args
          (exit -1))))

     (define-syntax %with-popped-handler
       (syntax-rules ()
         ((_ ?handler . ?body)
          (let ((ell      stack-of-handlers)
                (?handler (car stack-of-handlers)))
            (dynamic-wind
                (lambda () (set! stack-of-handlers (cdr ell)))
                (lambda () . ?body)
                (lambda () (set! stack-of-handlers ell)))))))

     (define (with-exception-handler handler thunk)
       (let ((ell stack-of-handlers))
         (dynamic-wind
             (lambda () (set! stack-of-handlers (cons handler ell)))
             thunk
             (lambda () (set! stack-of-handlers ell)))))

     (define (raise-continuable raised-object)
       (%with-popped-handler handler
          (handler raised-object)))

     (define (raise raised-object)
       (%with-popped-handler handler
          (handler raised-object)
          (raise
           (condition
            (make-non-continuable-violation)
            (make-message-condition
             "return from handler of non-continuable exception")))))

we see that no function rewinds the stack nor invokes a continuation;
also, in 'raise', the recursive invocation raising a non-continuable
violation can return to the caller if the handler returns.

   The implementation of the 'guard' syntax needs some reasoning to be
understood; first, the skeleton of the transformation is a
'with-exception-handler' syntax, the following form:

     (guard (E ((alpha-condition? E)
                (do-alpha))
               ((beta-condition? E)
                (do-beta))
               ((condition-gamma-value E)
                => (lambda (value)
                     (do-gamma value)))
               (else
                (do-else)))
       (form-a)
       (form-b))

is basically transformed to:

     (with-exception-handler
         (lambda (E)
           (cond ((alpha-condition? E)
                  (do-alpha))
                 ((beta-condition? E)
                  (do-beta))
                 ((condition-gamma-value E)
                  => (lambda (value)
                       (do-gamma value)))
                 (else
                  (do-else))))
       (lambda ()
         (form-a)
         (form-b)))

to make it compliant, we need to add to this transformation the correct
handling of continuations and of the dynamic environment.

   We need the mechanism explained step by step in what follows; given
the form:

     (alpha ... (beta ...))

in which the form 'beta' is nested at some level in the form 'alpha', we
want to answer the question: how do we evaluate the form 'beta' so that
it has the same continuation and dynamic environment of 'alpha'?

   We begin by understanding that this chunk of code:

     (begin
       (form-a)
       (form-b))

can be rewritten in the following equivalent form, in which an anonymous
function is created and just evaluated in place:

     ((lambda ()
        (begin
          (form-a)
          (form-b))))

or more explicitly:

     (apply (lambda ()
              (begin
                (form-a)
                (form-b))))

we should understand that, from the point of view of the executed
computation, the 'apply' and 'begin' forms have the same continuation.

   The last version can be rewritten as:

     (apply (call/cc
               (lambda (kont)
                 (lambda () ;body
                   (begin
                     (form-a)
                     (form-b))))))

in which the 'call/cc' form evaluates to the anonymous function
commented as 'body' which is then evaluated by 'apply'; so we can say
again that, from the point of view of the executed computation, the
'apply' and 'begin' forms have the same continuation.  We notice that
the escape procedure 'kont' is not used.

   Let's consider the following transformation of the previous example
and understand why it is equivalent:

     (apply (call/cc
               (lambda (kont)
                 (lambda () ;shell
                   (kont (lambda () ;body
                           (begin
                             (form-a)
                             (form-b))))))))

the 'call/cc' form evaluates to the anonymous function commented as
'shell' which is evaluated by 'apply'; the 'kont' escape procedure jumps
back to the continuation of 'call/cc' which is again 'apply' and its
return value is the anonymous function commented as 'body' which is
evaluated by 'apply'.  So once again we can say that, from the point of
view of the executed computation, the 'apply' and 'begin' forms have the
same continuation.

   As a final consideration, let's modify the form as follows:

     (apply (call/cc
               (lambda (kont)
                 (lambda () ;shell
                   (dynamic-wind
                       (lambda ()
                         (in-guard))
                       (lambda ()
                         (kont (lambda () ;body
                                 (begin
                                   (form-a)
                                   (form-b)))))
                       (lambda ()
                         (out-guard)))))))

when the 'shell' function is evaluated, the dynamic environment may be
modified by the 'dynamic-wind' form's 'in-guard' and 'out-guard', but
the 'begin' form is still evaluated with the same continuation and the
same dynamic environment of 'apply': both 'in-guard' and 'out-guard' are
evaluated before the 'body' function is evaluated.

   Now we can go back to the 'guard' implementation and consider a
'guard' form with 'else' clause:

     (guard (E ((alpha-condition? E)
                (do-alpha))
               (else
                (do-else)))
       (dynamic-wind
         (lambda () (in-guard))
         (lambda () (form-a))
         (lambda () (out-guard))))

we observed that the skeleton expansion of 'guard' is:

     (with-exception-handler
          (lambda (E)
            (cond ((alpha-condition? E)
                   (do-alpha))
                  (else
                   (do-else))))
       (lambda ()
         (dynamic-wind
           (lambda () (in-guard))
           (lambda () (form-a))
           (lambda () (out-guard)))))

the report establishes that:

     That implicit 'cond' expression is evaluated with the continuation
     and dynamic environment of the 'guard' form.

using the mechanism described above, we can expand the 'guard' form as
follows:

     ((call/cc
          (lambda (guard-kont)
            (lambda ()
              (with-exception-handler
                  (lambda (E) ;shell
                    (guard-kont
                     (lambda () ;handler
                       (cond ((alpha-condition? E)
                              (do-alpha))
                             (else
                              (do-else))))))
                (lambda () ;body
                  (dynamic-wind
                      (lambda () (in-guard))
                      (lambda () (form-a))
                      (lambda () (out-guard)))))))))

if the anonymous function commented as 'body' raises an exception, the
handler function commented as 'shell' is applied to the raised object;
the 'guard-kont' escape procedure is used to jump to the continuation of
'call/cc' and then the 'cond' form is evaluated.  This expansion is
compliant.  We notice explicitly that:

   * With this mechanism the exception handler does not return to the
     continuation of 'raise' or other form which raised the exception,
     rather it returns to the continuation of 'guard'.

   * When 'guard-kont' is invoked: 'out-guard' is evaluated and only
     after that the anonymous function commented as 'handler' is
     evaluated.  This is different from the default behaviour of
     'with-exception-handler', in which the handler is evaluated in the
     same dynamic environment of the body function with the single
     difference of the current exception handler.

   Now let's consider a 'guard' form without 'else' clause:

     (guard (E ((alpha-condition? E)
                (do-alpha))
               ((beta-condition? E)
                (do-beta)))
       (dynamic-wind
         (lambda () (in-guard))
         (lambda () (form-a))
         (lambda () (out-guard))))

applying the same expansion described above yields:

     (apply
      (call/cc
          (lambda (guard-kont)
            (lambda ()
              (with-exception-handler
                  (lambda (E) ;shell
                    (guard-kont
                     (lambda () ;handler
                       (cond ((alpha-condition? E)
                              (do-alpha))
                             ((beta-condition? E)
                              (do-beta))))))
                (lambda () ;body
                  (dynamic-wind
                      (lambda () (in-guard))
                      (lambda () (form-a))
                      (lambda () (out-guard)))))))))

but the report establishes that:

     If every ?COND-CLAUSE's ?TEST evaluates to '#f' and there is no
     'else' clause, then 'raise-continuable' is re-invoked on the raised
     object within the dynamic environment of the original call to
     'raise' except that the current exception handler is that of the
     'guard' expression.

so we use again the same mechanism and expand as follows:

     (apply ;external apply
      (call/cc
          (lambda (guard-kont)
            (lambda ()
              (with-exception-handler
                  (lambda (E) ;shell
                    (apply ;internal apply
                      (call/cc
                          (lambda (reraise-kont)
                            (guard-kont
                              (lambda () ;handler
                                (cond ((alpha-condition? E)
                                       (do-alpha))
                                      ((beta-condition? E)
                                       (do-beta))
                                      (else
                                       (reraise-kont
                                        (lambda () ;reraise
                                          (raise-continuable E))))))
                            )))))
                (lambda () ;body
                  (dynamic-wind
                      (lambda () (in-guard))
                      (lambda () (form-a))
                      (lambda () (out-guard)))))))))

if the body function raises an exception and one of the non-'else'
clauses matches, everything works as above and the 'cond' form is
evaluated with the continuation of 'guard'; but if the clause which
matches is 'else': the 'reraise-kont' escape procedure is used to jump
back to the continuation of the internal 'call/cc' which has a dynamic
environment equal to the one of the original raise invocation; the
return value of 'reraise-kont' is the anonymous function commented as
'reraise', which is evaluated in place by the internal 'apply'; the
return value of 'raise-continuable' becomes the argument of
'guard-kont'.

   We notice explicitly that:

   * When the execution flow enters the body function: 'in-guard' is
     evaluated; if 'form-a' raises an exception: 'guard-kont' is
     evaluated and so 'out-guard' is evaluated.

   * If the 'else' clause is evaluated, then 'reraise-kont' is
     evaluated: 'in-guard' is evaluated again before
     'raise-continuable'; if 'raise-continuable' returns: 'guard-kont'
     is evaluated and 'out-guard' is evaluated again.

   As the last touch, let's introduce a binding for the raised object as
follows:

     (apply ;external apply
      (call/cc
          (lambda (guard-kont)
            (lambda ()
              (with-exception-handler
                  (lambda (D) ;shell
                    (apply ;internal apply
                      (call/cc
                          (lambda (reraise-kont)
                            (guard-kont
                              (lambda () ;handler
                                (let ((E D))
                                  (cond ((alpha-condition? E)
                                         (do-alpha))
                                        ((beta-condition? E)
                                         (do-beta))
                                        (else
                                         (reraise-kont
                                          (lambda () ;reraise
                                            (raise-continuable D)))))))
                              )))))
                (lambda () ;body
                  (dynamic-wind
                      (lambda () (in-guard))
                      (lambda () (form-a))
                      (lambda () (out-guard)))))))))

this way we are sure to reraise the original raised object in the 'else'
clause even though the tests in the clauses may have modified the biding
of 'E' or its value.


File: vicare-scheme.info,  Node: stdlib exceptions conditions,  Prev: stdlib exceptions exceptions,  Up: stdlib exceptions

5.7.2 Conditions
----------------

This section describes Scheme's '(rnrs conditions (6))' library for
creating and inspecting condition types and values.  A condition value
encapsulates information about an exceptional situation.  Scheme also
defines a number of basic condition types.

   Scheme conditions provides two mechanisms to enable communication
about an exceptional situation: subtyping among condition types allows
handling code to determine the general nature of an exception even
though it does not anticipate its exact nature, and compound conditions
allow an exceptional situation to be described in multiple ways.

* Menu:

* stdlib exceptions conditions objects::        Condition objects.
* stdlib exceptions conditions types::          Standard condition types.


File: vicare-scheme.info,  Node: stdlib exceptions conditions objects,  Next: stdlib exceptions conditions types,  Up: stdlib exceptions conditions

5.7.2.1 Condition objects
.........................

Conceptually, there are two different kinds of condition objects:
_simple conditions_ and _compound conditions_.  An object that is either
a simple condition or a compound condition is simply a _condition_.
Compound conditions form a type disjoint from the base types described
in report section *note baselib types::.  A simple condition describes a
single aspect of an exceptional situation.  A compound condition
represents multiple aspects of an exceptional situation as a list of
simple conditions, its _components_.  Most of the operations described
in this section treat a simple condition identically to a compound
condition with itself as its own sole component.  For a subtype T of
'&condition', a _condition of type T_ is either a record of type T or a
compound condition containing a component of type T.

 -- Condition Type: &condition
     Simple conditions are records of subtypes of the '&condition'
     record type.  The '&condition' type has no fields and is neither
     sealed nor opaque.

 -- Procedure: condition CONDITION1 ...
     The 'condition' procedure returns a condition object with the
     components of the CONDITIONs as its components, in the same order,
     i.e., with the components of CONDITION1 appearing first in the same
     order as in CONDITION1, then with the components of CONDITION2, and
     so on.  The returned condition is compound if the total number of
     components is zero or greater than one.  Otherwise, it may be
     compound or simple.

 -- Procedure: simple-conditions CONDITION
     The 'simple-conditions' procedure returns a list of the components
     of CONDITION, in the same order as they appeared in the
     construction of CONDITION.  The returned list is immutable.  If the
     returned list is modified, the effect on CONDITION is unspecified.

          *NOTE* Because 'condition' decomposes its arguments into
          simple conditions, 'simple-conditions' always returns a
          "flattened" list of simple conditions.

 -- Procedure: condition? OBJ
     Return '#t' if OBJ is a (simple or compound) condition, otherwise
     return '#f'.

 -- Procedure: condition-predicate RTD
     RTD must be a record-type descriptor of a subtype of '&condition'.
     The 'condition-predicate' procedure returns a procedure that takes
     one argument.  This procedure returns '#t' if its argument is a
     condition of the condition type represented by RTD, i.e., if it is
     either a simple condition of that record type (or one of its
     subtypes) or a compound conditition with such a simple condition as
     one of its components, and '#f' otherwise.

 -- Procedure: condition-accessor RTD PROC
     RTD must be a record-type descriptor of a subtype of '&condition'.
     PROC should accept one argument, a record of the record type of
     RTD.  The 'condition-accessor' procedure returns a procedure that
     accepts a single argument, which must be a condition of the type
     represented by RTD.  This procedure extracts the first component of
     the condition of the type represented by RTD, and returns the
     result of applying PROC to that component.

     (define-record-type (&cond1 make-cond1 real-cond1?)
       (parent &condition)
       (fields
        (immutable x real-cond1-x)))

     (define cond1?
       (condition-predicate
         (record-type-descriptor &cond1)))
     (define cond1-x
       (condition-accessor
         (record-type-descriptor &cond1)
         real-cond1-x))

     (define foo (make-cond1 'foo))

     (condition? foo)                        => #t
     (cond1? foo)                            => #t
     (cond1-x foo)                           => foo

     (define-record-type (&cond2 make-cond2 real-cond2?)
       (parent &condition)
       (fields
        (immutable y real-cond2-y)))

     (define cond2?
       (condition-predicate
         (record-type-descriptor &cond2)))
     (define cond2-y
       (condition-accessor
          (record-type-descriptor &cond2)
          real-cond2-y))

     (define bar (make-cond2 'bar))

     (condition? (condition foo bar))        => #t
     (cond1? (condition foo bar))            => #t
     (cond2? (condition foo bar))            => #t
     (cond1? (condition foo))                => #t
     (real-cond1? (condition foo))           => unspecified
     (real-cond1? (condition foo bar))       => #f
     (cond1-x (condition foo bar))           => foo
     (cond2-y (condition foo bar))           => bar

     (equal? (simple-conditions (condition foo bar))
             (list foo bar))                 => #t

     (equal? (simple-conditions
               (condition foo (condition bar)))
             (list foo bar))                 => #t

 -- Syntax: define-condition-type ?CONDITION-TYPE ?SUPERTYPE
          ?CONSTRUCTOR ?PREDICATE ?FIELD-SPEC1 ...
     ?CONDITION-TYPE, ?SUPERTYPES, ?CONSTRUCTOR, and ?PREDICATE must all
     be identifiers.  Each ?FIELD-SPEC must be of the form

          (?FIELD ?ACCESSOR)

     where both ?FIELD and ?ACCESSOR must be identifiers.

     The 'define-condition-type' form expands into a record-type
     definition for a record type ?CONDITION-TYPE.  The record type will
     be non-opaque, non-sealed, and its fields will be immutable.  It
     will have ?SUPERTYPE has its parent type.  The remaining
     identifiers will be bound as follows:

        * ?CONSTRUCTOR is bound to a default constructor for the type:
          It accepts one argument for each of the record type's complete
          set of fields (including parent types, with the fields of the
          parent coming before those of the extension in the arguments)
          and returns a condition object initialized to those arguments.

        * ?PREDICATE is bound to a predicate that identifies conditions
          of type ?CONDITION-TYPE or any of its subtypes.

        * Each ?ACCESSOR is bound to a procedure that extracts the
          corresponding field from a condition of type ?CONDITION-TYPE.

     (define-condition-type &c &condition
       make-c c?
       (x c-x))

     (define-condition-type &c1 &c
       make-c1 c1?
       (a c1-a))

     (define-condition-type &c2 &c
       make-c2 c2?
       (b c2-b))

     (define v1 (make-c1 "V1" "a1"))

     (c? v1)        => #t
     (c1? v1)       => #t
     (c2? v1)       => #f
     (c-x v1)       => "V1"
     (c1-a v1)      => "a1"

     (define v2 (make-c2 "V2" "b2"))

     (c? v2)        => #t
     (c1? v2)       => #f
     (c2? v2)       => #t
     (c-x v2)       => "V2"
     (c2-b v2)      => "b2"

     (define v3 (condition
                  (make-c1 "V3/1" "a3")
                  (make-c2 "V3/2" "b3")))

     (c? v3)        => #t
     (c1? v3)       => #t
     (c2? v3)       => #t
     (c-x v3)       => "V3/1"
     (c1-a v3)      => "a3"
     (c2-b v3)      => "b3"

     (define v4 (condition v1 v2))

     (c? v4)        => #t
     (c1? v4)       => #t
     (c2? v4)       => #t
     (c-x v4)       => "V1"
     (c1-a v4)      => "a1"
     (c2-b v4)      => "b2"

     (define v5 (condition v2 v3))

     (c? v5)        => #t
     (c1? v5)       => #t
     (c2? v5)       => #t
     (c-x v5)       => "V2"
     (c1-a v5)      => "a3"
     (c2-b v5)      => "b2"


File: vicare-scheme.info,  Node: stdlib exceptions conditions types,  Prev: stdlib exceptions conditions objects,  Up: stdlib exceptions conditions

5.7.2.2 Standard condition types
................................

Hierarchy of standard condition types:

     &condition
        |
        +-----> &warning
        |
        +-----> &message
        |       &irritants
        |       &who
        |
        +-----> &serious
                   |
                   +-----> &error
                   |
                   +-----> &violation
                              |
                              +-----> &assertion
                              |
                              +-----> &non-continuable
                              |
                              +-----> &implementation-restriction
                              |
                              +-----> &lexical
                              |
                              +-----> &syntax
                              |
                               -----> &undefined

 -- Condition Type: &message
 -- Procedure: make-message-condition MESSAGE
 -- Procedure: message-condition? OBJ
 -- Procedure: condition-message CONDITION
     This condition type could be defined by:

          (define-condition-type &message &condition
            make-message-condition message-condition?
            (message condition-message))

     It carries a message further describing the nature of the condition
     to humans.

 -- Condition Type: &warning
 -- Procedure: make-warning
 -- Procedure: warning? OBJ
     This condition type could be defined by:

          (define-condition-type &warning &condition
            make-warning warning?)

     This type describes conditions that do not, in principle, prohibit
     immediate continued execution of the program, but may interfere
     with the program's execution later.

 -- Condition Type: &serious
 -- Procedure: make-serious-condition
 -- Procedure: serious-condition? OBJ
     This condition type could be defined by:

          (define-condition-type &serious &condition
            make-serious-condition serious-condition?)

     This type describes conditions serious enough that they cannot
     safely be ignored.  This condition type is primarily intended as a
     supertype of other condition types.

 -- Condition Type: &error
 -- Procedure: make-error
 -- Procedure: error? OBJ
     This condition type could be defined by:

          (define-condition-type &error &serious
            make-error error?)

     This type describes errors, typically caused by something that has
     gone wrong in the interaction of the program with the external
     world or the user.

 -- Condition Type: &violation
 -- Procedure: make-violation
 -- Procedure: violation? OBJ
     This condition type could be defined by:

          (define-condition-type &violation &serious
            make-violation violation?)

     This type describes violations of the language standard or a
     library standard, typically caused by a programming error.

 -- Condition Type: &assertion
 -- Procedure: make-assertion-violation
 -- Procedure: assertion-violation? OBJ
     This condition type could be defined by:

          (define-condition-type &assertion &violation
            make-assertion-violation assertion-violation?)

     This type describes an invalid call to a procedure, either passing
     an invalid number of arguments, or passing an argument of the wrong
     type.

 -- Condition Type: &irritants
 -- Procedure: make-irritants-condition IRRITANTS
 -- Procedure: irritants-condition? OBJ
 -- Procedure: condition-irritants CONDITION
     This condition type could be defined by:

          (define-condition-type &irritants &condition
            make-irritants-condition irritants-condition?
            (irritants condition-irritants))

     IRRITANTS should be a list of objects.  This condition provides
     additional information about a condition, typically the argument
     list of a procedure that detected an exception.  Conditions of this
     type are created by the procedures 'error' and
     'assertion-violation'.

 -- Condition Type: &who
 -- Procedure: make-who-condition WHO
 -- Procedure: who-condition? OBJ
 -- Procedure: condition-who CONDITION
     This condition type could be defined by:

          (define-condition-type &who &condition
            make-who-condition who-condition?
            (who condition-who))

     WHO should be a symbol or string identifying the entity reporting
     the exception.  Conditions of this type are created by the 'error'
     and 'assertion-violation' procedures (report section *note baselib
     errors::), and the 'syntax-violation' procedure (section *note
     scheme basic syntax violations::).

 -- Condition Type: &non-continuable
 -- Procedure: make-non-continuable-violation
 -- Procedure: non-continuable-violation? OBJ
     This condition type could be defined by:

          (define-condition-type &non-continuable &violation
            make-non-continuable-violation
            non-continuable-violation?)

     This type indicates that an exception handler invoked via 'raise'
     has returned.

 -- Condition Type: &implementation-restriction
 -- Procedure: make-implementation-restriction-violation
 -- Procedure: implementation-restriction-violation? OBJ
     This condition type could be defined by:

          (define-condition-type &implementation-restriction
              &violation
            make-implementation-restriction-violation
            implementation-restriction-violation?)

     This type describes a violation of an implementation restriction
     allowed by the specification, such as the absence of
     representations for NaNs and infinities.

 -- Condition Type: &lexical
 -- Procedure: make-lexical-violation
 -- Procedure: lexical-violation? OBJ
     This condition type could be defined by:

          (define-condition-type &lexical &violation
            make-lexical-violation lexical-violation?)

     This type describes syntax violations at the level of the datum
     syntax.

 -- Condition Type: &syntax
 -- Procedure: make-syntax-violation FORM SUBFORM
 -- Procedure: syntax-violation? OBJ
 -- Procedure: syntax-violation-form CONDITION
 -- Procedure: syntax-violation-subform CONDITION
     This condition type could be defined by:

          (define-condition-type &syntax &violation
            make-syntax-violation syntax-violation?
            (form syntax-violation-form)
            (subform syntax-violation-subform))

     This type describes syntax violations.  FORM should be the
     erroneous syntax object or a datum representing the code of the
     erroneous form.  SUBFORM should be an optional syntax object or
     datum within the erroneous form that more precisely locates the
     violation.  It can be '#f' to indicate the absence of more precise
     information.

 -- Condition Type: &undefined
 -- Procedure: make-undefined-violation
 -- Procedure: undefined-violation? OBJ
     This condition type could be defined by:

          (define-condition-type &undefined &violation
            make-undefined-violation undefined-violation?)

     This type describes unbound identifiers in the program.


File: vicare-scheme.info,  Node: stdlib io,  Next: stdlib files,  Prev: stdlib exceptions,  Up: stdlib

5.8 Input/output
================

This chapter describes Scheme's libraries for performing input and
output:

'(rnrs io ports (6))'
     it is an I/O layer for conventional, imperative buffered input and
     output with text and binary data;

'(rnrs io simple (6))'
     it is a convenience library atop the '(rnrs io ports (6))' library
     for textual I/O, compatible with the traditional Scheme I/O
     procedures.

   The section on conditions defines a condition-type hierarchy that is
exported by both the '(rnrs io ports (6))' and '(rnrs io simple (6))'
libraries.

* Menu:

* stdlib io conditions::        Condition types.
* stdlib io port::              Port input/output.
* stdlib io simple::            Simple input/output.


File: vicare-scheme.info,  Node: stdlib io conditions,  Next: stdlib io port,  Up: stdlib io

5.8.1 Condition types
---------------------

The procedures described in this chapter, when they detect an
exceptional situation that arises from an "I/O errors", raise an
exception with condition type '&i/o'.

   The condition types and corresponding predicates and accessors are
exported by both the '(rnrs io ports (6))' and '(rnrs io simple (6))'
libraries.  They are also exported by the '(rnrs files (6))' library.

 -- Condition Type: &i/o
 -- Procedure: make-i/o-error
 -- Procedure: i/o-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o &error
            make-i/o-error i/o-error?)

     This is a supertype for a set of more specific I/O errors.

 -- Condition Type: &i/o-read
 -- Procedure: make-i/o-read-error
 -- Procedure: i/o-read-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-read &i/o
            make-i/o-read-error i/o-read-error?)

     This condition type describes read errors that occurred during an
     I/O operation.

 -- Condition Type: &i/o-write
 -- Procedure: make-i/o-write-error
 -- Procedure: i/o-write-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-write &i/o
            make-i/o-write-error i/o-write-error?)

     This condition type describes write errors that occurred during an
     I/O operation.

 -- Condition Type: &i/o-invalid-position
 -- Procedure: make-i/o-invalid-position-error POSITION
 -- Procedure: i/o-invalid-position-error? OBJ
 -- Procedure: i/o-error-position CONDITION
     This condition type could be defined by:

          (define-condition-type &i/o-invalid-position &i/o
            make-i/o-invalid-position-error
            i/o-invalid-position-error?
            (position i/o-error-position))

     This condition type describes attempts to set the file position to
     an invalid position.  POSITION should be the file position that the
     program intended to set.  This condition describes a range error,
     but not an assertion violation.

 -- Condition Type: &i/o-filename
 -- Procedure: make-i/o-filename-error FILENAME
 -- Procedure: i/o-filename-error? OBJ
 -- Procedure: i/o-error-filename CONDITION
     This condition type could be defined by:

          (define-condition-type &i/o-filename &i/o
            make-i/o-filename-error i/o-filename-error?
            (filename i/o-error-filename))

     This condition type describes an I/O error that occurred during an
     operation on a named file.  FILENAME should be the name of the
     file, a Scheme string object.

 -- Condition Type: &i/o-file-protection
 -- Procedure: make-i/o-file-protection-error FILENAME
 -- Procedure: i/o-file-protection-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-file-protection
              &i/o-filename
            make-i/o-file-protection-error
            i/o-file-protection-error?)

     A condition of this type specifies that an operation tried to
     operate on a named file with insufficient access rights.

 -- Condition Type: &i/o-file-is-read-only
 -- Procedure: make-i/o-file-is-read-only-error FILENAME
 -- Procedure: i/o-file-is-read-only-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-file-is-read-only
              &i/o-file-protection
            make-i/o-file-is-read-only-error
            i/o-file-is-read-only-error?)

     A condition of this type specifies that an operation tried to
     operate on a named read-only file under the assumption that it is
     writeable.

 -- Condition Type: &i/o-file-already-exists
 -- Procedure: make-i/o-file-already-exists-error FILENAME
 -- Procedure: i/o-file-already-exists-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-file-already-exists
              &i/o-filename
            make-i/o-file-already-exists-error
            i/o-file-already-exists-error?)

     A condition of this type specifies that an operation tried to
     operate on an existing named file under the assumption that it did
     not exist.

 -- Condition Type: &i/o-file-does-not-exist
 -- Procedure: make-i/o-file-does-not-exist-error FILENAME
 -- Procedure: i/o-file-does-not-exist-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-file-does-not-exist
              &i/o-filename
            make-i/o-file-does-not-exist-error
            i/o-file-does-not-exist-error?)

     A condition of this type specifies that an operation tried to
     operate on an non-existent named file under the assumption that it
     existed.

 -- Condition Type: &i/o-port
 -- Procedure: make-i/o-port-error PORT
 -- Procedure: i/o-port-error? OBJ
 -- Procedure: i/o-error-port CONDITION
     This condition type could be defined by:

          (define-condition-type &i/o-port &i/o
            make-i/o-port-error i/o-port-error?
            (port i/o-error-port))

     This condition type specifies the port with which an I/O error is
     associated.  PORT should be the port.  Conditions raised by
     procedures accepting a port as an argument should include an
     '&i/o-port-error' condition.


File: vicare-scheme.info,  Node: stdlib io port,  Next: stdlib io simple,  Prev: stdlib io conditions,  Up: stdlib io

5.8.2 Port input/output
-----------------------

The '(rnrs io ports (6))' library defines an I/O layer for conventional,
imperative buffered input and output.  A "port" represents a buffered
access object for a data sink or source or both simultaneously.  The
library allows ports to be created from arbitrary data sources and
sinks.

   The '(rnrs io ports (6))' library distinguishes between "input ports"
and "output ports".  An input port is a source for data, whereas an
output port is a sink for data.  A port may be both an input port and an
output port; such a port typically provides simultaneous read and write
access to a file or other data.

   The '(rnrs io ports (6))' library also distinguishes between "binary
ports", which are sources or sinks for uninterpreted bytes, and "textual
ports", which are sources or sinks for characters and strings.

   This section uses INPUT-PORT, OUTPUT-PORT, BINARY-PORT, TEXTUAL-PORT,
BINARY-INPUT-PORT, TEXTUAL-INPUT-PORT, BINARY-OUTPUT-PORT,
TEXTUAL-OUTPUT-PORT, and PORT as names for arguments that must be input
ports (or combined input/output ports), output ports (or combined
input/output ports), binary ports, textual ports, binary input ports,
textual input ports, binary output ports, textual output ports, or any
kind of port, respectively.

* Menu:

* stdlib io port file names::           File names.
* stdlib io port file options::         File options.
* stdlib io port buffer modes::         Buffer modes.
* stdlib io port transcoders::          Transcoders.
* stdlib io port eof object::           End of file object.
* stdlib io port io ports::             Input and output ports.
* stdlib io port input ports::          Input ports.
* stdlib io port binary input::         Binary input.
* stdlib io port textual input::        Textual input.
* stdlib io port output ports::         Output ports.
* stdlib io port binary output::        Binary output.
* stdlib io port textual output::       Textual output.
* stdlib io port input output ports::   Input/output ports.


File: vicare-scheme.info,  Node: stdlib io port file names,  Next: stdlib io port file options,  Up: stdlib io port

5.8.2.1 File names
..................

Some of the procedures described in this chapter accept a file name as
an argument.  Valid values for such a file name include strings that
name a file using the native notation of filesystem paths on an
implementation's underlying operating system, and may include
implementation-dependent values as well.

   A FILENAME parameter name means that the corresponding argument must
be a file name.


File: vicare-scheme.info,  Node: stdlib io port file options,  Next: stdlib io port buffer modes,  Prev: stdlib io port file names,  Up: stdlib io port

5.8.2.2 File options
....................

When opening a file, the various procedures in this library accept a
'file-options' object that encapsulates flags to specify how the file is
to be opened.  A 'file-options' object is an enum-set over the symbols
constituting valid file options.  A FILE-OPTIONS parameter name means
that the corresponding argument must be a file-options object.

 -- Syntax: file-options ?FILE-OPTIONS-SYMBOL ...
     Each ?FILE-OPTIONS-SYMBOL must be a symbol.  The 'file-options'
     syntax returns a file-options object that encapsulates the
     specified options.

     When supplied to an operation that opens a file for output, the
     file-options object returned by '(file-options)' (without
     arguments) specifies that the file is created if it does not exist
     and an exception with condition type '&i/o-file-already-exists' is
     raised if it does exist.  The following standard options can be
     included to modify the default behavior.

     'no-create'
          If the file does not already exist, it is not created;
          instead, an exception with condition type
          '&i/o-file-does-not-exist' is raised.  If the file already
          exists, the exception with condition type
          '&i/o-file-already-exists' is not raised and the file is
          truncated to zero length.

     'no-fail'
          If the file already exists, the exception with condition type
          '&i/o-file-already-exists' is not raised, even if 'no-create'
          is not included, and the file is truncated to zero length.

     'no-truncate'
          If the file already exists and the exception with condition
          type '&i/o-file-already-exists' has been inhibited by
          inclusion of 'no-create' or 'no-fail', the file is not
          truncated, but the port's current position is still set to the
          beginning of the file.

     These options have no effect when a file is opened only for input.
     Symbols other than those listed above may be used as
     ?FILE-OPTIONS-SYMBOLs; they have implementation-specific meaning,
     if any.

          *NOTE* Only the name of ?FILE-OPTIONS-SYMBOL is significant.


File: vicare-scheme.info,  Node: stdlib io port buffer modes,  Next: stdlib io port transcoders,  Prev: stdlib io port file options,  Up: stdlib io port

5.8.2.3 Buffer modes
....................

Each port has an associated buffer mode.  For an output port, the buffer
mode defines when an output operation flushes the buffer associated with
the output port.  For an input port, the buffer mode defines how much
data will be read to satisfy read operations.  The possible buffer modes
are the symbols:

'none'
     for no buffering,

'line'
     for flushing upon line endings and reading up to line endings, or
     other implementation-dependent behavior,

'block'
     for arbitrary buffering.

   This section uses the parameter name BUFFER-MODE for arguments that
must be buffer-mode symbols.

   If two ports are connected to the same mutable source, both ports are
unbuffered, and reading a byte or character from that shared source via
one of the two ports would change the bytes or characters seen via the
other port, a lookahead operation on one port will render the peeked
byte or character inaccessible via the other port, while a subsequent
read operation on the peeked port will see the peeked byte or character
even though the port is otherwise unbuffered.

   In other words, the semantics of buffering is defined in terms of
side effects on shared mutable sources, and a lookahead operation has
the same side effect on the shared source as a read operation.

 -- Syntax: buffer-mode ?BUFFER-MODE-SYMBOL
     ?BUFFER-MODE-SYMBOL must be a symbol whose name is one of 'none',
     'line', and 'block'.  The result is the corresponding symbol, and
     specifies the associated buffer mode.

          *NOTE* Only the name of ?BUFFER-MODE-SYMBOL is significant.

 -- Procedure: buffer-mode? OBJ
     Return '#t' if the argument is a valid buffer-mode symbol, and
     returns '#f' otherwise.


File: vicare-scheme.info,  Node: stdlib io port transcoders,  Next: stdlib io port eof object,  Prev: stdlib io port buffer modes,  Up: stdlib io port

5.8.2.4 Transcoders
...................

Several different Unicode encoding schemes describe standard ways to
encode characters and strings as byte sequences and to decode those
sequences.  Within this document, a "codec" is an immutable Scheme
object that represents a Unicode or similar encoding scheme.

   An "end-of-line style" is a symbol that, if it is not 'none',
describes how a textual port transcodes representations of line endings.

   A "transcoder" is an immutable Scheme object that combines a codec
with an end-of-line style and a method for handling decoding errors.
Each transcoder represents some specific bidirectional (but not
necessarily lossless), possibly stateful translation between byte
sequences and Unicode characters and strings.  Every transcoder can
operate in the input direction (bytes to characters) or in the output
direction (characters to bytes).  A TRANSCODER argument name means that
the corresponding argument must be a transcoder.

   A "binary port" is a port that supports binary I/O, does not have an
associated transcoder and does not support textual I/O. A "textual port"
is a port that supports textual I/O, and does not support binary I/O. A
textual port may or may not have an associated transcoder.

 -- Procedure: latin-1-codec
 -- Procedure: utf-8-codec
 -- Procedure: utf-16-codec
     These are predefined codecs for the ISO 8859-1, UTF-8, and UTF-16
     encoding schemes.

     A call to any of these procedures returns a value that is equal in
     the sense of 'eqv?' to the result of any other call to the same
     procedure.

 -- Syntax: eol-style ?EOL-STYLE-SYMBOL
     ?EOL-STYLE-SYMBOL should be a symbol whose name is one of 'lf',
     'cr', 'crlf', 'nel', 'crnel', 'ls', and 'none'.

     The form evaluates to the corresponding symbol.  If the name of
     ?EOL-STYLE-SYMBOL is not one of these symbols, the effect and
     result are implementation-dependent; in particular, the result may
     be an eol-style symbol acceptable as an EOL-STYLE argument to
     'make-transcoder'.  Otherwise, an exception is raised.

     All eol-style symbols except 'none' describe a specific line-ending
     encoding:

          lf              ?LINEFEED
          cr              ?CARRIAGE-RETURN
          crlf            ?CARRIAGE-RETURN ?LINEFEED
          nel             ?NEXT-LINE
          crnel           ?CARRIAGE-RETURN ?NEXT-LINE
          ls              ?LINE-SEPARATOR

     For a textual port with a transcoder, and whose transcoder has an
     eol-style symbol 'none', no conversion occurs.  For a textual input
     port, any eol-style symbol other than 'none' means that all of the
     above line-ending encodings are recognized and are translated into
     a single linefeed.  For a textual output port, 'none' and 'lf' are
     equivalent.  Linefeed characters are encoded according to the
     specified eol-style symbol, and all other characters that
     participate in possible line endings are encoded as is.

          *NOTE* Only the name of ?EOL-STYLE-SYMBOL is significant.

 -- Procedure: native-eol-style
     Return the default end-of-line style of the underlying platform,
     e.g., 'lf' on Unix and 'crlf' on Windows.

 -- Condition Type: &i/o-decoding
 -- Procedure: make-i/o-decoding-error PORT
 -- Procedure: i/o-decoding-error? OBJ
     This condition type could be defined by:

          (define-condition-type &i/o-decoding &i/o-port
            make-i/o-decoding-error i/o-decoding-error?)

     An exception with this type is raised when one of the operations
     for textual input from a port encounters a sequence of bytes that
     cannot be translated into a character or string by the input
     direction of the port's transcoder.

     When such an exception is raised, the port's position is past the
     invalid encoding.

 -- Condition Type: &i/o-encoding
 -- Procedure: make-i/o-encoding-error PORT CHAR
 -- Procedure: i/o-encoding-error? OBJ
 -- Procedure: i/o-encoding-error-char CONDITION
     This condition type could be defined by:

          (define-condition-type &i/o-encoding &i/o-port
            make-i/o-encoding-error i/o-encoding-error?
            (char i/o-encoding-error-char))

     An exception with this type is raised when one of the operations
     for textual output to a port encounters a character that cannot be
     translated into bytes by the output direction of the port's
     transcoder.  CHAR is the character that could not be encoded.

 -- Syntax: error-handling-mode ?ERROR-HANDLING-MODE-SYMBOL
     ?ERROR-HANDLING-MODE-SYMBOL should be a symbol whose name is one of
     'ignore', 'raise', and 'replace'.

     The form evaluates to the corresponding symbol.  If
     ?ERROR-HANDLING-MODE-SYMBOL is not one of these identifiers, effect
     and result are implementation-dependent: the result may be an
     error-handling-mode symbol acceptable as a HANDLING-MODE argument
     to 'make-transcoder'.  If it is not acceptable as a HANDLING-MODE
     argument to 'make-transcoder', an exception is raised.

          *NOTE* Only the name of ?ERROR-HANDLING-STYLE-SYMBOL is
          significant.

     The error-handling mode of a transcoder specifies the behavior of
     textual I/O operations in the presence of encoding or decoding
     errors.

     If a textual input operation encounters an invalid or incomplete
     character encoding, and the error-handling mode is 'ignore', an
     appropriate number of bytes of the invalid encoding are ignored and
     decoding continues with the following bytes.  If the error-handling
     mode is 'replace', the replacement character 'U+FFFD' is injected
     into the data stream, an appropriate number of bytes are ignored,
     and decoding continues with the following bytes.  If the
     error-handling mode is 'raise', an exception with condition type
     '&i/o-decoding' is raised.

     If a textual output operation encounters a character it cannot
     encode, and the error-handling mode is 'ignore', the character is
     ignored and encoding continues with the next character.  If the
     error-handling mode is 'replace', a codec-specific replacement
     character is emitted by the transcoder, and encoding continues with
     the next character.  The replacement character is 'U+FFFD' for
     transcoders whose codec is one of the Unicode encodings, but is the
     '?' character for the Latin-1 encoding.  If the error-handling mode
     is 'raise', an exception with condition type '&i/o-encoding' is
     raised.

 -- Procedure: make-transcoder CODEC
 -- Procedure: make-transcoder CODEC EOL-STYLE
 -- Procedure: make-transcoder CODEC EOL-STYLE HANDLING-MODE
     CODEC must be a codec; EOL-STYLE, if present, an eol-style symbol;
     and HANDLING-MODE, if present, an error-handling-mode symbol.

     EOL-STYLE may be omitted, in which case it defaults to the native
     end-of-line style of the underlying platform.  HANDLING-MODE may be
     omitted, in which case it defaults to 'replace'.  The result is a
     transcoder with the behavior specified by its arguments.

 -- Procedure: native-transcoder
     Return an implementation-dependent transcoder that represents a
     possibly locale-dependent "native" transcoding.

 -- Procedure: transcoder-codec TRANSCODER
 -- Procedure: transcoder-eol-style TRANSCODER
 -- Procedure: transcoder-error-handling-mode TRANSCODER
     These are accessors for transcoder objects; when applied to a
     transcoder returned by 'make-transcoder', they return the CODEC,
     EOL-STYLE, and HANDLING-MODE arguments, respectively.

 -- Procedure: bytevector->string BYTEVECTOR TRANSCODER
     Return the string that results from transcoding the BYTEVECTOR
     according to the input direction of the transcoder.

 -- Procedure: string->bytevector STRING TRANSCODER
     Return the bytevector that results from transcoding the STRING
     according to the output direction of the transcoder.


File: vicare-scheme.info,  Node: stdlib io port eof object,  Next: stdlib io port io ports,  Prev: stdlib io port transcoders,  Up: stdlib io port

5.8.2.5 End-of-file object
..........................

The end-of-file object is returned by various I/O procedures when they
reach end of file.

 -- Procedure: eof-object
     Return the end-of-file object.

          (eqv? (eof-object) (eof-object))        => #t
          (eq? (eof-object) (eof-object))         => #t

     *NOTE* The end-of-file object is not a datum value, and thus has no
     external representation.

 -- Procedure: eof-object? OBJ
     Return '#t' if OBJ is the end-of-file object, '#f' otherwise.


File: vicare-scheme.info,  Node: stdlib io port io ports,  Next: stdlib io port input ports,  Prev: stdlib io port eof object,  Up: stdlib io port

5.8.2.6 Input and output ports
..............................

The operations described in this section are common to input and output
ports, both binary and textual.  A port may also have an associated
_position_ that specifies a particular place within its data sink or
source, and may also provide operations for inspecting and setting that
place.

 -- Procedure: port? OBJ
     Return '#t' if the argument is a port, '#f' otherwise.

 -- Procedure: port-transcoder PORT
     Return the transcoder associated with PORT if PORT is textual and
     has an associated transcoder, and returns '#f' if PORT is binary or
     does not have an associated transcoder.

 -- Procedure: textual-port? PORT
 -- Procedure: binary-port? PORT
     The 'textual-port?' procedure returns '#t' if PORT is textual, and
     returns '#f' otherwise.

     The 'binary-port?' procedure returns '#t' if PORT is binary, and
     returns '#f' otherwise.

 -- Procedure: transcoded-port BINARY-PORT TRANSCODER
     The 'transcoded-port' procedure returns a new textual port with the
     specified TRANSCODER.  Otherwise the new textual port's state is
     largely the same as that of BINARY-PORT.

     If BINARY-PORT is an input port, the new textual port will be an
     input port and will transcode the bytes that have not yet been read
     from BINARY-PORT.  If BINARY-PORT is an output port, the new
     textual port will be an output port and will transcode output
     characters into bytes that are written to the byte sink represented
     by BINARY-PORT.

     As a side effect, however, 'transcoded-port' closes BINARY-PORT in
     a special way that allows the new textual port to continue to use
     the byte source or sink represented by BINARY-PORT, even though
     BINARY-PORT itself is closed and cannot be used by the input and
     output operations described in this chapter.

 -- Procedure: port-has-port-position? PORT
 -- Procedure: port-position PORT
     The 'port-has-port-position?' procedure returns '#t' if the port
     supports the 'port-position' operation, and '#f' otherwise.

     For a binary port, 'port-position' returns the index of the
     position at which the next byte would be read from or written to
     the port as an exact non-negative integer object.  For a textual
     port, 'port-position' returns a value of some
     implementation-dependent type representing the port's position;
     this value may be useful only as the POS argument to
     'set-port-position!', if the latter is supported on the port (see
     below).

     If the port does not support the operation, 'port-position' raises
     an exception with condition type '&assertion'.

          *NOTE* For a textual port, the port position may or may not be
          an integer object.  If it is an integer object, the integer
          object does not necessarily correspond to a byte or character
          position.

 -- Procedure: port-has-set-port-position!? PORT
 -- Procedure: set-port-position! PORT POS
     If PORT is a binary port, POS should be a non-negative exact
     integer object.  If PORT is a textual port, POS should be the
     return value of a call to 'port-position' on PORT.

     The 'port-has-set-port-position!?' procedure returns '#t' if the
     port supports the 'set-port-position!' operation, and '#f'
     otherwise.

     The 'set-port-position!' procedure raises an exception with
     condition type '&assertion' if the port does not support the
     operation, and an exception with condition type
     '&i/o-invalid-position' if POS is not in the range of valid
     positions of PORT.  Otherwise, it sets the current position of the
     port to POS.  If PORT is an output port, 'set-port-position!' first
     flushes PORT.

     If PORT is a binary output port and the current position is set
     beyond the current end of the data in the underlying data sink, the
     object is not extended until new data is written at that position.
     The contents of any intervening positions are unspecified.  Binary
     ports created by 'open-file-output-port' and
     'open-file-input/output-port' can always be extended in this manner
     within the limits of the underlying operating system.  In other
     cases, attempts to set the port beyond the current end of data in
     the underlying object may result in an exception with condition
     type '&i/o-invalid-position'.

 -- Procedure: close-port PORT
     Closes the port, rendering the port incapable of delivering or
     accepting data.  If PORT is an output port, it is flushed before
     being closed.  This has no effect if the port has already been
     closed.  A closed port is still a port.  The 'close-port' procedure
     returns unspecified values.

 -- Procedure: call-with-port PORT PROC
     PROC must accept one argument.  The 'call-with-port' procedure
     calls PROC with PORT as an argument.  If PROC returns, PORT is
     closed automatically and the values returned by PROC are returned.
     If PROC does not return, PORT is not closed automatically, except
     perhaps when it is possible to prove that PORT will never again be
     used for an input or output operation.


File: vicare-scheme.info,  Node: stdlib io port input ports,  Next: stdlib io port binary input,  Prev: stdlib io port io ports,  Up: stdlib io port

5.8.2.7 Input ports
...................

An input port allows the reading of an infinite sequence of bytes or
characters punctuated by end-of-file objects.  An input port connected
to a finite data source ends in an infinite sequence of end-of-file
objects.

   It is unspecified whether a character encoding consisting of several
bytes may have an end of file between the bytes.  If, for example,
'get-char' raises an '&i/o-decoding' exception because the character
encoding at the port's position is incomplete up to the next end of
file, a subsequent call to 'get-char' may successfully decode a
character if bytes completing the encoding are available after the end
of file.

 -- Procedure: input-port? OBJ
     Return '#t' if the argument is an input port (or a combined input
     and output port), and returns '#f' otherwise.

 -- Procedure: port-eof? INPUT-PORT
     Return '#t' if the 'lookahead-u8' procedure (if INPUT-PORT is a
     binary port) or the 'lookahead-char' procedure (if INPUT-PORT is a
     textual port) would return the end-of-file object, and '#f'
     otherwise.  The operation may block indefinitely if no data is
     available but the port cannot be determined to be at end of file.

 -- Procedure: open-file-input-port FILENAME
 -- Procedure: open-file-input-port FILENAME FILE-OPTIONS
 -- Procedure: open-file-input-port FILENAME FILE-OPTIONS BUFFER-MODE
 -- Procedure: open-file-input-port FILENAME FILE-OPTIONS BUFFER-MODE
          MAYBE-TRANSCODER
     MAYBE-TRANSCODER must be either a transcoder or '#f'.

     The 'open-file-input-port' procedure returns an input port for the
     named file.  The FILE-OPTIONS and MAYBE-TRANSCODER arguments are
     optional.

     The FILE-OPTIONS argument, which may determine various aspects of
     the returned port, defaults to the value of '(file-options)'.

     The BUFFER-MODE argument, if supplied, must be one of the symbols
     that name a buffer mode.  The BUFFER-MODE argument defaults to
     'block'.

     If MAYBE-TRANSCODER is a transcoder, it becomes the transcoder
     associated with the returned port.

     If MAYBE-TRANSCODER is '#f' or absent, the port will be a binary
     port and will support the 'port-position' and 'set-port-position!'
     operations.  Otherwise the port will be a textual port, and whether
     it supports the 'port-position' and 'set-port-position!' operations
     is implementation-dependent (and possibly transcoder-dependent).

 -- Procedure: open-bytevector-input-port BYTEVECTOR
 -- Procedure: open-bytevector-input-port BYTEVECTOR MAYBE-TRANSCODER
     MAYBE-TRANSCODER must be either a transcoder or '#f'.

     The 'open-bytevector-input-port' procedure returns an input port
     whose bytes are drawn from BYTEVECTOR.  If TRANSCODER is specified,
     it becomes the transcoder associated with the returned port.

     If MAYBE-TRANSCODER is '#f' or absent, the port will be a binary
     port and will support the 'port-position' and 'set-port-position!'
     operations.  Otherwise the port will be a textual port, and whether
     it supports the 'port-position' and 'set-port-position!' operations
     will be implementation-dependent (and possibly
     transcoder-dependent).

     If BYTEVECTOR is modified after 'open-bytevector-input-port' has
     been called, the effect on the returned port is unspecified.

 -- Procedure: open-string-input-port STRING
     Return a textual input port whose characters are drawn from STRING.
     The port may or may not have an associated transcoder; if it does,
     the transcoder is implementation-dependent.  The port should
     support the 'port-position' and 'set-port-position!' operations.

     If STRING is modified after 'open-string-input-port' has been
     called, the effect on the returned port is unspecified.

 -- Procedure: standard-input-port
     Return a fresh binary input port connected to standard input.
     Whether the port supports the 'port-position' and
     'set-port-position!' operations is implementation-dependent.

 -- Procedure: current-input-port
     This returns a default textual port for input.  Normally, this
     default port is associated with standard input, but can be
     dynamically re-assigned using the 'with-input-from-file' procedure
     from the '(rnrs io simple (6))' library.  The port may or may not
     have an associated transcoder; if it does, the transcoder is
     implementation-dependent.

 -- Procedure: make-custom-binary-input-port ID READ! GET-POSITION
          SET-POSITION! CLOSE
     Return a newly created binary input port whose byte source is an
     arbitrary algorithm represented by the 'read!' procedure.  ID must
     be a string naming the new port, provided for informational
     purposes only.  READ! must be a procedure and should behave as
     specified below; it will be called by operations that perform
     binary input.

     Each of the remaining arguments may be '#f'; if any of those
     arguments is not '#f', it must be a procedure and should behave as
     specified below.

     '(READ! BYTEVECTOR START COUNT)'
          START will be a non-negative exact integer object, COUNT will
          be a positive exact integer object, and BYTEVECTOR will be a
          bytevector whose length is at least START+COUNT.

          The READ! procedure should obtain up to COUNT bytes from the
          byte source, and should write those bytes into BYTEVECTOR
          starting at index START.  The READ! procedure should return an
          exact integer object.  This integer object should represent
          the number of bytes that it has read.  To indicate an end of
          file, the READ! procedure should write no bytes and return 0.

     '(GET-POSITION)'
          The GET-POSITION procedure (if supplied) should return an
          exact integer object representing the current position of the
          input port.  If not supplied, the custom port will not support
          the 'port-position' operation.

     '(SET-POSITION! POS)'
          POS will be a non-negative exact integer object.  The
          SET-POSITION! procedure (if supplied) should set the position
          of the input port to POS.  If not supplied, the custom port
          will not support the 'set-port-position!' operation.

     '(CLOSE)'
          The CLOSE procedure (if supplied) should perform any actions
          that are necessary when the input port is closed.

     *Implementation responsibilities:* The implementation must check
     the return values of READ! and GET-POSITION only when it actually
     calls them as part of an I/O operation requested by the program.
     The implementation is not required to check that these procedures
     otherwise behave as described.  If they do not, however, the
     behavior of the resulting port is unspecified.

 -- Procedure: make-custom-textual-input-port ID READ! GET-POSITION
          SET-POSITION! CLOSE
     Return a newly created textual input port whose character source is
     an arbitrary algorithm represented by the READ! procedure.  ID must
     be a string naming the new port, provided for informational
     purposes only.  READ! must be a procedure and should behave as
     specified below; it will be called by operations that perform
     textual input.

     Each of the remaining arguments may be '#f'; if any of those
     arguments is not '#f', it must be a procedure and should behave as
     specified below.

     '(READ! STRING START COUNT)'
          START will be a non-negative exact integer object, COUNT will
          be a positive exact integer object, and STRING will be a
          string whose length is at least START+COUNT.

          The READ! procedure should obtain up to COUNT characters from
          the character source, and should write those characters into
          STRING starting at index START.  The READ! procedure should
          return an exact integer object representing the number of
          characters that it has written.  To indicate an end of file,
          the READ! procedure should write no bytes and return 0.

     '(GET-POSITION)'
          The GET-POSITION procedure (if supplied) should return a
          single value.  The return value should represent the current
          position of the input port.  If not supplied, the custom port
          will not support the 'port-position' operation.

     '(SET-POSITION! POS)'
          The SET-POSITION! procedure (if supplied) should set the
          position of the input port to POS if POS is the return value
          of a call to GET-POSITION.  If not supplied, the custom port
          will not support the 'set-port-position!' operation.

     '(CLOSE)'
          The CLOSE procedure (if supplied) should perform any actions
          that are necessary when the input port is closed.

     The port may or may not have an an associated transcoder; if it
     does, the transcoder is implementation-dependent.

     *Implementation responsibilities:* The implementation must check
     the return values of READ! and GET-POSITION only when it actually
     calls them as part of an I/O operation requested by the program.
     The implementation is not required to check that these procedures
     otherwise behave as described.  If they do not, however, the
     behavior of the resulting port is unspecified.


File: vicare-scheme.info,  Node: stdlib io port binary input,  Next: stdlib io port textual input,  Prev: stdlib io port input ports,  Up: stdlib io port

5.8.2.8 Binary input
....................

 -- Procedure: get-u8 BINARY-INPUT-PORT
     Read from BINARY-INPUT-PORT, blocking as necessary, until a byte is
     available from BINARY-INPUT-PORT or until an end of file is
     reached.  If a byte becomes available, 'get-u8' returns the byte as
     an octet and updates BINARY-INPUT-PORT to point just past that
     byte.  If no input byte is seen before an end of file is reached,
     the end-of-file object is returned.

 -- Procedure: lookahead-u8 BINARY-INPUT-PORT
     The 'lookahead-u8' procedure is like 'get-u8', but it does not
     update BINARY-INPUT-PORT to point past the byte.

 -- Procedure: get-bytevector-n BINARY-INPUT-PORT COUNT
     COUNT must be an exact, non-negative integer object representing
     the number of bytes to be read.

     The 'get-bytevector-n' procedure reads from BINARY-INPUT-PORT,
     blocking as necessary, until COUNT bytes are available from
     BINARY-INPUT-PORT or until an end of file is reached.

     If COUNT bytes are available before an end of file,
     'get-bytevector-n' returns a bytevector of size COUNT.

     If fewer bytes are available before an end of file,
     'get-bytevector-n' returns a bytevector containing those bytes.  In
     either case, the input port is updated to point just past the bytes
     read.

     If an end of file is reached before any bytes are available,
     'get-bytevector-n' returns the end-of-file object.

 -- Procedure: get-bytevector-n! BINARY-INPUT-PORT BYTEVECTOR START
          COUNT
     COUNT must be an exact, non-negative integer object, representing
     the number of bytes to be read.  BYTEVECTOR must be a bytevector
     with at least START+COUNT elements.

     The 'get-bytevector-n!' procedure reads from BINARY-INPUT-PORT,
     blocking as necessary, until COUNT bytes are available from
     BINARY-INPUT-PORT or until an end of file is reached.

     If COUNT bytes are available before an end of file, they are
     written into BYTEVECTOR starting at index START, and the result is
     COUNT.

     If fewer bytes are available before the next end of file, the
     available bytes are written into BYTEVECTOR starting at index
     START, and the result is a number object representing the number of
     bytes actually read.

     In either case, the input port is updated to point just past the
     bytes read.  If an end of file is reached before any bytes are
     available, 'get-bytevector-n!' returns the end-of-file object.

 -- Procedure: get-bytevector-some BINARY-INPUT-PORT
     Read from BINARY-INPUT-PORT, blocking as necessary, until bytes are
     available from BINARY-INPUT-PORT or until an end of file is
     reached.  If bytes become available, 'get-bytevector-some' returns
     a freshly allocated bytevector containing the initial available
     bytes (at least one), and it updates BINARY-INPUT-PORT to point
     just past these bytes.  If no input bytes are seen before an end of
     file is reached, the end-of-file object is returned.

 -- Procedure: get-bytevector-all BINARY-INPUT-PORT
     Attempts to read all bytes until the next end of file, blocking as
     necessary.  If one or more bytes are read, 'get-bytevector-all'
     returns a bytevector containing all bytes up to the next end of
     file.  Otherwise, 'get-bytevector-all' returns the end-of-file
     object.  The operation may block indefinitely waiting to see if
     more bytes will become available, even if some bytes are already
     available.


File: vicare-scheme.info,  Node: stdlib io port textual input,  Next: stdlib io port output ports,  Prev: stdlib io port binary input,  Up: stdlib io port

5.8.2.9 Textual input
.....................

 -- Procedure: get-char TEXTUAL-INPUT-PORT
     Read from TEXTUAL-INPUT-PORT, blocking as necessary, until a
     complete character is available, or until an end of file is
     reached.

     If a complete character is available before the next end of file,
     'get-char' returns that character and updates the input port to
     point past the character.  If an end of file is reached before any
     character is read, 'get-char' returns the end-of-file object.

 -- Procedure: lookahead-char TEXTUAL-INPUT-PORT
     The 'lookahead-char' procedure is like 'get-char', but it does not
     update TEXTUAL-INPUT-PORT to point past the character.

          *NOTE* With some of the standard transcoders described in this
          document, up to four bytes of lookahead are needed.
          Non-standard transcoders may need even more lookahead.

 -- Procedure: get-string-n TEXTUAL-INPUT-PORT COUNT
     COUNT must be an exact, non-negative integer object, representing
     the number of characters to be read.

     The 'get-string-n' procedure reads from TEXTUAL-INPUT-PORT,
     blocking as necessary, until COUNT characters are available, or
     until an end of file is reached.

     If COUNT characters are available before end of file,
     'get-string-n' returns a string consisting of those COUNT
     characters.

     If fewer characters are available before an end of file, but one or
     more characters can be read, 'get-string-n' returns a string
     containing those characters.

     In either case, the input port is updated to point just past the
     characters read.  If no characters can be read before an end of
     file, the end-of-file object is returned.

 -- Procedure: get-string-n! TEXTUAL-INPUT-PORT STRING START COUNT
     START and COUNT must be exact, non-negative integer objects, with
     COUNT representing the number of characters to be read.  STRING
     must be a string with at least START+COUNT characters.

     The 'get-string-n!' procedure reads from TEXTUAL-INPUT-PORT in the
     same manner as 'get-string-n'.

     If COUNT characters are available before an end of file, they are
     written into STRING starting at index START, and COUNT is returned.

     If fewer characters are available before an end of file, but one or
     more can be read, those characters are written into STRING starting
     at index START and the number of characters actually read is
     returned as an exact integer object.

     If no characters can be read before an end of file, the end-of-file
     object is returned.

 -- Procedure: get-string-all TEXTUAL-INPUT-PORT
     Read from TEXTUAL-INPUT-PORT until an end of file, decoding
     characters in the same manner as 'get-string-n' and
     'get-string-n!'.

     If characters are available before the end of file, a string
     containing all the characters decoded from that data is returned.
     If no character precedes the end of file, the end-of-file object is
     returned.

 -- Procedure: get-line TEXTUAL-INPUT-PORT
     Read from TEXTUAL-INPUT-PORT up to and including the linefeed
     character or end of file, decoding characters in the same manner as
     'get-string-n' and 'get-string-n!'.

     If a linefeed character is read, a string containing all of the
     text up to (but not including) the linefeed character is returned,
     and the port is updated to point just past the linefeed character.

     If an end of file is encountered before any linefeed character is
     read, but some characters have been read and decoded as characters,
     a string containing those characters is returned.

     If an end of file is encountered before any characters are read,
     the end-of-file object is returned.

          *NOTE* The end-of-line style, if not 'none', will cause all
          line endings to be read as linefeed characters.

 -- Procedure: get-datum TEXTUAL-INPUT-PORT
     Read an external representation from TEXTUAL-INPUT-PORT and return
     the datum it represents.  The 'get-datum' procedure returns the
     next datum that can be parsed from the given TEXTUAL-INPUT-PORT,
     updating TEXTUAL-INPUT-PORT to point exactly past the end of the
     external representation of the object.

     Any ?INTERLEXEME-SPACE (*note scheme lex syntax::) in the input is
     first skipped.  If an end of file occurs after the
     ?INTERLEXEME-SPACE, the end-of-file object is returned.

     If a character inconsistent with an external representation is
     encountered in the input, an exception with condition types
     '&lexical' and '&i/o-read' is raised.

     Also, if the end of file is encountered after the beginning of an
     external representation, but the external representation is
     incomplete and therefore cannot be parsed, an exception with
     condition types '&lexical' and '&i/o-read' is raised.


File: vicare-scheme.info,  Node: stdlib io port output ports,  Next: stdlib io port binary output,  Prev: stdlib io port textual input,  Up: stdlib io port

5.8.2.10 Output ports
.....................

An output port is a sink to which bytes or characters are written.  The
written data may control external devices or may produce files and other
objects that may subsequently be opened for input.

 -- Procedure: output-port? OBJ
     Return '#t' if the argument is an output port (or a combined input
     and output port), '#f' otherwise.

 -- Procedure: flush-output-port OUTPUT-PORT
     Flushes any buffered output from the buffer of OUTPUT-PORT to the
     underlying file, device, or object.  The 'flush-output-port'
     procedure returns unspecified values.

 -- Procedure: output-port-buffer-mode OUTPUT-PORT
     Return the symbol that represents the buffer mode of OUTPUT-PORT.

 -- Procedure: open-file-output-port FILENAME
 -- Procedure: open-file-output-port FILENAME FILE-OPTIONS
 -- Procedure: open-file-output-port FILENAME FILE-OPTIONS BUFFER-MODE
 -- Procedure: open-file-output-port FILENAME FILE-OPTIONS BUFFER-MODE
          MAYBE-TRANSCODER
     MAYBE-TRANSCODER must be either a transcoder or '#f'.

     The 'open-file-output-port' procedure returns an output port for
     the named file.

     The FILE-OPTIONS argument, which may determine various aspects of
     the returned port, defaults to the value of '(file-options)'.

     The BUFFER-MODE argument, if supplied, must be one of the symbols
     that name a buffer mode.  The BUFFER-MODE argument defaults to
     'block'.

     If MAYBE-TRANSCODER is a transcoder, it becomes the transcoder
     associated with the port.

     If MAYBE-TRANSCODER is '#f' or absent, the port will be a binary
     port and will support the 'port-position' and 'set-port-position!'
     operations.  Otherwise the port will be a textual port, and whether
     it supports the 'port-position' and 'set-port-position!' operations
     is implementation-dependent (and possibly transcoder-dependent).

 -- Procedure: open-bytevector-output-port
 -- Procedure: open-bytevector-output-port MAYBE-TRANSCODER
     MAYBE-TRANSCODER must be either a transcoder or '#f'.

     The 'open-bytevector-output-port' procedure returns two values: an
     output port and an extraction procedure.  The output port
     accumulates the bytes written to it for later extraction by the
     procedure.

     If MAYBE-TRANSCODER is a transcoder, it becomes the transcoder
     associated with the port.  If MAYBE-TRANSCODER is '#f' or absent,
     the port will be a binary port and will support the 'port-position'
     and 'set-port-position!' operations.  Otherwise the port will be a
     textual port, and whether it supports the 'port-position' and
     'set-port-position!' operations is implementation-dependent (and
     possibly transcoder-dependent).

     The extraction procedure takes no arguments.  When called, it
     returns a bytevector consisting of all the port's accumulated bytes
     (regardless of the port's current position), removes the
     accumulated bytes from the port, and resets the port's position.

 -- Procedure: call-with-bytevector-output-port PROC
 -- Procedure: call-with-bytevector-output-port PROC MAYBE-TRANSCODER
     PROC must accept one argument.  MAYBE-TRANSCODER must be either a
     transcoder or '#f'.

     The 'call-with-bytevector-output-port' procedure creates an output
     port that accumulates the bytes written to it and calls PROC with
     that output port as an argument.

     Whenever PROC returns, a bytevector consisting of all of the port's
     accumulated bytes (regardless of the port's current position) is
     returned and the port is closed.

     The transcoder associated with the output port is determined as for
     a call to 'open-bytevector-output-port'.

 -- Procedure: open-string-output-port
     Return two values: a textual output port and an extraction
     procedure.  The output port accumulates the characters written to
     it for later extraction by the procedure.

     The port may or may not have an associated transcoder; if it does,
     the transcoder is implementation-dependent.  The port should
     support the 'port-position' and 'set-port-position!' operations.

     The extraction procedure takes no arguments.  When called, it
     returns a string consisting of all of the port's accumulated
     characters (regardless of the current position), removes the
     accumulated characters from the port, and resets the port's
     position.

 -- Procedure: call-with-string-output-port PROC
     PROC must accept one argument.

     The 'call-with-string-output-port' procedure creates a textual
     output port that accumulates the characters written to it and calls
     PROC with that output port as an argument.

     Whenever PROC returns, a string consisting of all of the port's
     accumulated characters (regardless of the port's current position)
     is returned and the port is closed.

     The port may or may not have an associated transcoder; if it does,
     the transcoder is implementation-dependent.  The port should
     support the 'port-position' and 'set-port-position!' operations.

 -- Procedure: standard-output-port
 -- Procedure: standard-error-port
     Return a fresh binary output port connected to the standard output
     or standard error respectively.  Whether the port supports the
     'port-position' and 'set-port-position!' operations is
     implementation-dependent.

 -- Procedure: current-output-port
 -- Procedure: current-error-port
     These return default textual ports for regular output and error
     output.  Normally, these default ports are associated with standard
     output, and standard error, respectively.

     The return value of 'current-output-port' can be dynamically
     re-assigned using the 'with-output-to-file' procedure from the
     '(rnrs io simple (6))' library.  A port returned by one of these
     procedures may or may not have an associated transcoder; if it
     does, the transcoder is implementation-dependent.

 -- Procedure: make-custom-binary-output-port ID WRITE! GET-POSITION
          SET-POSITION! CLOSE
     Return a newly created binary output port whose byte sink is an
     arbitrary algorithm represented by the WRITE! procedure.  ID must
     be a string naming the new port, provided for informational
     purposes only.  WRITE! must be a procedure and should behave as
     specified below; it will be called by operations that perform
     binary output.

     Each of the remaining arguments may be '#f'; if any of those
     arguments is not '#f', it must be a procedure and should behave as
     specified in the description of 'make-custom-binary-input-port'.

     '(WRITE! BYTEVECTOR START COUNT)'
          START and COUNT will be non-negative exact integer objects,
          and BYTEVECTOR will be a bytevector whose length is at least
          START+COUNT.

          The WRITE! procedure should write up to COUNT bytes from
          BYTEVECTOR starting at index START to the byte sink.  In any
          case, the WRITE! procedure should return the number of bytes
          that it wrote, as an exact integer object.

     *Implementation responsibilities:* The implementation must check
     the return values of WRITE! only when it actually calls WRITE! as
     part of an I/O operation requested by the program.  The
     implementation is not required to check that WRITE! otherwise
     behaves as described.  If it does not, however, the behavior of the
     resulting port is unspecified.

 -- Procedure: make-custom-textual-output-port ID WRITE! GET-POSITION
          SET-POSITION! CLOSE
     Return a newly created textual output port whose byte sink is an
     arbitrary algorithm represented by the WRITE! procedure.  ID must
     be a string naming the new port, provided for informational
     purposes only.  WRITE! must be a procedure and should behave as
     specified below; it will be called by operations that perform
     textual output.

     Each of the remaining arguments may be '#f'; if any of those
     arguments is not '#f', it must be a procedure and should behave as
     specified in the description of 'make-custom-textual-input-port'.

     '(WRITE! STRING START COUNT)'
          START and COUNT will be non-negative exact integer objects,
          and STRING will be a string whose length is at least
          START+COUNT.

          The WRITE! procedure should write up to COUNT characters from
          STRING starting at index START to the character sink.  In any
          case, the WRITE! procedure should return the number of
          characters that it wrote, as an exact integer object.

     The port may or may not have an associated transcoder; if it does,
     the transcoder is implementation-dependent.

     *Implementation responsibilities:* The implementation must check
     the return values of WRITE! only when it actually calls WRITE! as
     part of an I/O operation requested by the program.  The
     implementation is not required to check that WRITE! otherwise
     behaves as described.  If it does not, however, the behavior of the
     resulting port is unspecified.


File: vicare-scheme.info,  Node: stdlib io port binary output,  Next: stdlib io port textual output,  Prev: stdlib io port output ports,  Up: stdlib io port

5.8.2.11 Binary output
......................

 -- Procedure: put-u8 BINARY-OUTPUT-PORT OCTET
     Write OCTET to the output port and returns unspecified values.

 -- Procedure: put-bytevector BINARY-OUTPUT-PORT BYTEVECTOR
 -- Procedure: put-bytevector BINARY-OUTPUT-PORT BYTEVECTOR START
 -- Procedure: put-bytevector BINARY-OUTPUT-PORT BYTEVECTOR START COUNT
     START and COUNT must be non-negative exact integer objects that
     default to 0 and:

          (- (bytevector-length BYTEVECTOR) START)

     respectively.  BYTEVECTOR must have a length of at least
     START+COUNT.  The 'put-bytevector' procedure writes the COUNT bytes
     of the bytevector BYTEVECTOR starting at index START to the output
     port.  The 'put-bytevector' procedure returns unspecified values.


File: vicare-scheme.info,  Node: stdlib io port textual output,  Next: stdlib io port input output ports,  Prev: stdlib io port binary output,  Up: stdlib io port

5.8.2.12 Textual output
.......................

 -- Procedure: put-char TEXTUAL-OUTPUT-PORT CHAR
     Write CHAR to the port.  Return unspecified values.

 -- Procedure: put-string TEXTUAL-OUTPUT-PORT STRING
 -- Procedure: put-string TEXTUAL-OUTPUT-PORT STRING START
 -- Procedure: put-string TEXTUAL-OUTPUT-PORT STRING START COUNT
     START and COUNT must be non-negative exact integer objects.  STRING
     must have a length of at least START+COUNT.

     START defaults to 0.  COUNT defaults to:

          (- (string-length STRING) START)

     The 'put-string' procedure writes the COUNT characters of STRING
     starting at index START to the port.  The 'put-string' procedure
     returns unspecified values.

 -- Procedure: put-datum TEXTUAL-OUTPUT-PORT DATUM
     DATUM should be a datum value.

     The 'put-datum' procedure writes an external representation of
     DATUM to TEXTUAL-OUTPUT-PORT.  The specific external representation
     is implementation-dependent.  However, whenever possible, an
     implementation should produce a representation for which
     'get-datum', when reading the representation, will return an object
     equal (in the sense of 'equal?') to DATUM.

          *NOTE* Not all datums may allow producing an external
          representation for which 'get-datum' will produce an object
          that is equal to the original.  Specifically, NaNs contained
          in DATUM may make this impossible.

          *NOTE* The 'put-datum' procedure merely writes the external
          representation, but no trailing delimiter.  If 'put-datum' is
          used to write several subsequent external representations to
          an output port, care should be taken to delimit them properly
          so they can be read back in by subsequent calls to
          'get-datum'.


File: vicare-scheme.info,  Node: stdlib io port input output ports,  Prev: stdlib io port textual output,  Up: stdlib io port

5.8.2.13 Input/output ports
...........................

 -- Procedure: open-file-input/output-port FILENAME
 -- Procedure: open-file-input/output-port FILENAME FILE-OPTIONS
 -- Procedure: open-file-input/output-port FILENAME FILE-OPTIONS
          BUFFER-MODE
 -- Procedure: open-file-input/output-port FILENAME FILE-OPTIONS
          BUFFER-MODE TRANSCODER
     Return a single port that is both an input port and an output port
     for the named file.  The optional arguments default as described in
     the specification of 'open-file-output-port'.  If the input/output
     port supports 'port-position' and/or 'set-port-position!', the same
     port position is used for both input and output.

 -- Procedure: make-custom-binary-input/output-port ID READ! WRITE!
          GET-POSITION SET-POSITION! CLOSE
     Return a newly created binary input/output port whose byte source
     and sink are arbitrary algorithms represented by the READ! and
     WRITE! procedures.

     ID must be a string naming the new port, provided for informational
     purposes only.

     READ! and WRITE! must be procedures, and should behave as specified
     for the 'make-custom-binary-input-port' and
     'make-custom-binary-output-port' procedures.

     Each of the remaining arguments may be '#f'; if any of those
     arguments is not '#f', it must be a procedure and should behave as
     specified in the description of 'make-custom-binary-input-port'.

 -- Procedure: make-custom-textual-input/output-port ID READ! WRITE!
          GET-POSITION SET-POSITION! CLOSE
     Return a newly created textual input/output port whose textual
     source and sink are arbitrary algorithms represented by the READ!
     and WRITE! procedures.

     ID must be a string naming the new port, provided for informational
     purposes only.

     READ! and WRITE! must be procedures, and should behave as specified
     for the 'make-custom-textual-input-port' and
     'make-custom-textual-output-port' procedures.

     Each of the remaining arguments may be '#f'; if any of those
     arguments is not '#f', it must be a procedure and should behave as
     specified in the description of 'make-custom-textual-input-port'.


File: vicare-scheme.info,  Node: stdlib io simple,  Prev: stdlib io port,  Up: stdlib io

5.8.3 Simple input/output
-------------------------

This section describes the '(rnrs io simple (6))' library, which
provides a somewhat more convenient interface for performing textual I/O
on ports.  This library implements most of the I/O procedures of the
previous revision of this report.

   The ports created by the procedures of this library are textual ports
associated implementation-dependent transcoders.

 -- Procedure: eof-object
 -- Procedure: eof-object? OBJ
     These are the same as 'eof-object' and 'eof-object?' from the
     '(rnrs io ports (6))' library.

 -- Procedure: call-with-input-file FILENAME PROC
 -- Procedure: call-with-output-file FILENAME PROC
     PROC should accept one argument.

     These procedures open the file named by FILENAME for input or for
     output, with no specified file options, and call PROC with the
     obtained port as an argument.

     If PROC returns, the port is closed automatically and the values
     returned by PROC are returned.

     If PROC does not return, the port is not closed automatically,
     unless it is possible to prove that the port will never again be
     used for an I/O operation.

 -- Procedure: input-port? OBJ
 -- Procedure: output-port? OBJ
     These are the same as the 'input-port?' and 'output-port?'
     procedures in the '(rnrs io ports (6))' library.

 -- Procedure: current-input-port
 -- Procedure: current-output-port
 -- Procedure: current-error-port
     These are the same as the 'current-input-port',
     'current-output-port', and 'current-error-port' procedures from the
     '(rnrs io ports (6))' library.

 -- Procedure: with-input-from-file FILENAME THUNK
 -- Procedure: with-output-to-file FILENAME THUNK
     THUNK must be a procedure and must accept zero arguments.

     The file is opened for input or output using empty file options,
     and THUNK is called with no arguments.

     During the dynamic extent of the call to THUNK, the obtained port
     is made the value returned by 'current-input-port' or
     'current-output-port' procedures; the previous default values are
     reinstated when the dynamic extent is exited.

     When THUNK returns, the port is closed automatically.  The values
     returned by THUNK are returned.

     If an escape procedure is used to escape back into the call to
     THUNK after THUNK is returned, the behavior is unspecified.

 -- Procedure: open-input-file FILENAME
     Open FILENAME for input, with empty file options, and return the
     obtained port.

 -- Procedure: open-output-file FILENAME
     Open FILENAME for output, with empty file options, and return the
     obtained port.

 -- Procedure: close-input-port INPUT-PORT
 -- Procedure: close-output-port OUTPUT-PORT
     Close INPUT-PORT or OUTPUT-PORT, respectively.

 -- Procedure: read-char
 -- Procedure: read-char TEXTUAL-INPUT-PORT
     Reads from TEXTUAL-INPUT-PORT, blocking as necessary until a
     character is available, or the data that is available cannot be the
     prefix of any valid encoding, or an end of file is reached.

     If a complete character is available before the next end of file:
     'read-char' returns that character and updates the input port to
     point past that character.

     If an end of file is reached before any data are read: 'read-char'
     returns the end-of-file object.

     If TEXTUAL-INPUT-PORT is omitted, it defaults to the value returned
     by 'current-input-port'.

 -- Procedure: peek-char
 -- Procedure: peek-char TEXTUAL-INPUT-PORT
     This is the same as 'read-char', but does not consume any data from
     the port.

 -- Procedure: read
 -- Procedure: read TEXTUAL-INPUT-PORT
     Read an external representation from TEXTUAL-INPUT-PORT and return
     the datum it represents.

     The 'read' procedure operates in the same way as 'get-datum'.

     If TEXTUAL-INPUT-PORT is omitted, it defaults to the value returned
     by 'current-input-port'.

 -- Procedure: write-char CHAR
 -- Procedure: write-char CHAR TEXTUAL-OUTPUT-PORT
     Write an encoding of the character CHAR to the TEXTUAL-OUTPUT-PORT,
     and return unspecified values.

     If TEXTUAL-OUTPUT-PORT is omitted, it defaults to the value
     returned by 'current-output-port'.

 -- Procedure: newline
 -- Procedure: newline TEXTUAL-OUTPUT-PORT
     This is equivalent to using 'write-char' to write '#\linefeed' to
     TEXTUAL-OUTPUT-PORT.

     If TEXTUAL-OUTPUT-PORT is omitted, it defaults to the value
     returned by 'current-output-port'.

 -- Procedure: display OBJ
 -- Procedure: display OBJ TEXTUAL-OUTPUT-PORT
     Write a representation of OBJ to the given TEXTUAL-OUTPUT-PORT.

     Strings that appear in the written representation are not enclosed
     in doublequotes, and no characters are escaped within those
     strings.

     Character objects appear in the representation as if written by
     'write-char' instead of by 'write'.

     The 'display' procedure returns unspecified values.

     The TEXTUAL-OUTPUT-PORT argument may be omitted, in which case it
     defaults to the value returned by 'current-output-port'.

 -- Procedure: write OBJ
 -- Procedure: write OBJ TEXTUAL-OUTPUT-PORT
     Write the external representation of OBJ to TEXTUAL-OUTPUT-PORT.

     The 'write' procedure operates in the same way as 'put-datum'.

     If TEXTUAL-OUTPUT-PORT is omitted, it defaults to the value
     returned by 'current-output-port'.


File: vicare-scheme.info,  Node: stdlib files,  Next: stdlib programlib,  Prev: stdlib io,  Up: stdlib

5.9 File system
===============

This chapter describes the '(rnrs files (6))' library for operations on
the file system.  This library, in addition to the procedures described
here, also exports the I/O condition types described in section *note
stdlib io conditions::.

 -- Procedure: file-exists? FILENAME
     FILENAME must be a file name.

     The 'file-exists?' procedure returns '#t' if the named file exists
     at the time the procedure is called, '#f' otherwise.

 -- Procedure: delete-file FILENAME
     FILENAME must be a file name.

     The 'delete-file' procedure deletes the named file if it exists and
     can be deleted, and returns unspecified values.  If the file does
     not exist or cannot be deleted, an exception with condition type
     '&i/o-filename' is raised.


File: vicare-scheme.info,  Node: stdlib programlib,  Next: stdlib arithmetic,  Prev: stdlib files,  Up: stdlib

5.10 Command line access and exit values
========================================

The procedures described in this section are exported by the '(rnrs
programs (6))' library.

 -- Procedure: command-line
     Return a nonempty list of strings.  The first element is an
     implementation-specific name for the running top-level program.
     The remaining elements are command-line arguments according to the
     operating system's conventions.

 -- Procedure: exit
 -- Procedure: exit OBJ
     Exit the running program and communicates an exit value to the
     operating system.

     If no argument is supplied, the 'exit' procedure should communicate
     to the operating system that the program exited normally.

     If an argument is supplied, the 'exit' procedure should translate
     the argument into an appropriate exit value for the operating
     system.  If OBJ is '#f', the exit is assumed to be abnormal.

          *NOTE* Vicare implements exit hooks that can be evaluated
          whenever 'exit' is called; *note exit-hooks: iklib misc.


File: vicare-scheme.info,  Node: stdlib arithmetic,  Next: stdlib syntax-case,  Prev: stdlib programlib,  Up: stdlib

5.11 Arithmetics
================

This chapter describes Scheme's libraries for more specialized numerical
operations: fixnum and flonum arithmetic, as well as bitwise operations
on exact integer objects.

* Menu:

* stdlib arithmetic bitwise::        Bitwise operations.
* stdlib arithmetic fixnums::        Fixnums.
* stdlib arithmetic flonums::        Flonums.
* stdlib arithmetic exact bitwise::  Exact bitwise arithmetic.


File: vicare-scheme.info,  Node: stdlib arithmetic bitwise,  Next: stdlib arithmetic fixnums,  Up: stdlib arithmetic

5.11.1 Bitwise operations
-------------------------

A number of procedures operate on the binary two's-complement
representations of exact integer objects: Bit positions within an exact
integer object are counted from the right, i.e.  bit 0 is the least
significant bit.  Some procedures allow extracting _bit fields_, i.e.,
number objects representing subsequences of the binary representation of
an exact integer object.  Bit fields are always positive, and always
defined using a finite number of bits.


File: vicare-scheme.info,  Node: stdlib arithmetic fixnums,  Next: stdlib arithmetic flonums,  Prev: stdlib arithmetic bitwise,  Up: stdlib arithmetic

5.11.2 Fixnums
--------------

Every implementation must define its fixnum range as a closed interval:
[-2^{(w-1)}, 2^{(w-1)}-1] such that _w_ is a (mathematical) integer w >=
24.  Every mathematical integer within an implementation's fixnum range
must correspond to an exact integer object that is representable within
the implementation.  A fixnum is an exact integer object whose value
lies within this fixnum range.

   This section describes the '(rnrs arithmetic fixnums (6))' library,
which defines various operations on fixnums.  Fixnum operations perform
integer arithmetic on their fixnum arguments, but raise an exception
with condition type '&implementation-restriction' if the result is not a
fixnum.

   This section uses FX, FX1, FX2, etc., as names for arguments that
must be fixnums.

 -- Procedure: fixnum? OBJ
     Return '#t' if OBJ is an exact integer object within the fixnum
     range, '#f' otherwise.

 -- Procedure: fixnum-width
 -- Procedure: least-fixnum
 -- Procedure: greatest-fixnum
     These procedures return w, -2^{(w-1)} and 2^{(w-1)} - 1: the width,
     minimum and the maximum value of the fixnum range, respectively.

 -- Procedure: fx=? FX1 FX2 FX3 ...
 -- Procedure: fx>? FX1 FX2 FX3 ...
 -- Procedure: fx<? FX1 FX2 FX3 ...
 -- Procedure: fx>=? FX1 FX2 FX3 ...
 -- Procedure: fx<=? FX1 FX2 FX3 ...
     These procedures return '#t' if their arguments are (respectively):
     equal, monotonically increasing, monotonically decreasing,
     monotonically nondecreasing, or monotonically nonincreasing, '#f'
     otherwise.

 -- Procedure: fxzero? FX
 -- Procedure: fxpositive? FX
 -- Procedure: fxnegative? FX
 -- Procedure: fxodd? FX
 -- Procedure: fxeven? FX
     These numerical predicates test a fixnum for a particular property,
     returning '#t' or '#f'.  The five properties tested by these
     procedures are: whether the number object is zero, greater than
     zero, less than zero, odd, or even.

 -- Procedure: fxmax FX1 FX2 ...
 -- Procedure: fxmin FX1 FX2 ...
     These procedures return the maximum or minimum of their arguments.

 -- Procedure: fx+ FX1 FX2
 -- Procedure: fx* FX1 FX2
     These procedures return the sum or product of their arguments,
     provided that sum or product is a fixnum.  An exception with
     condition type '&implementation-restriction' is raised if that sum
     or product is not a fixnum.

 -- Procedure: fx- FX1 FX2
 -- Procedure: fx- FX
     With two arguments, this procedure returns the difference FX1 -
     FX2, provided that difference is a fixnum.

     With one argument, this procedure returns the additive inverse of
     its argument, provided that integer object is a fixnum.

     An exception with condition type '&implementation-restriction' is
     raised if the mathematically correct result of this procedure is
     not a fixnum.

          (fx- (least-fixnum))  => exception &assertion

 -- Procedure: fxdiv-and-mod FX1 FX2
 -- Procedure: fxdiv FX1 FX2
 -- Procedure: fxmod FX1 FX2
 -- Procedure: fxdiv0-and-mod0 FX1 FX2
 -- Procedure: fxdiv0 FX1 FX2
 -- Procedure: fxmod0 FX1 FX2
     FX2 must be nonzero.

     These procedures implement number-theoretic integer division and
     return the results of the corresponding mathematical operations
     specified in *note Integer division: baselib math semantics
     integer.

          (fxdiv FX1 FX2)         => FX1 div FX2
          (fxmod FX1 FX2)         => FX1 mod FX2
          (fxdiv-and-mod FX1 FX2) => FX1 div FX2, FX1 mod FX2
                                                  ; two return values
          (fxdiv0 FX1 FX2)        => FX1 div_0 FX2
          (fxmod0 FX1 FX2)        => FX1 mod_0 FX2
          (fxdiv0-and-mod0 FX1 FX2)
          => FX1 FX1 div_0 FX2, FX1 mod_0 FX2
             ; two return values

 -- Procedure: fx+/carry FX1 FX2 FX3
     Return the two fixnum results of the following computation:

          (let* ((s (+ FX1 FX2 FX3))
                 (s0 (mod0 s (expt 2 (fixnum-width))))
                 (s1 (div0 s (expt 2 (fixnum-width)))))
            (values s0 s1))

 -- Procedure: fx-/carry FX1 FX2 FX3
     Return the two fixnum results of the following computation:

          (let* ((d (- FX1 FX2 FX3))
                 (d0 (mod0 d (expt 2 (fixnum-width))))
                 (d1 (div0 d (expt 2 (fixnum-width)))))
            (values d0 d1))

 -- Procedure: fx*/carry FX1 FX2 FX3
     Return the two fixnum results of the following computation:

          (let* ((s (+ (* FX1 FX2) FX3))
                 (s0 (mod0 s (expt 2 (fixnum-width))))
                 (s1 (div0 s (expt 2 (fixnum-width)))))
            (values s0 s1))

 -- Procedure: fxnot FX
     Return the unique fixnum that is congruent mod _2^w_ to the
     one's-complement of FX.

 -- Procedure: fxand FX1 ...
 -- Procedure: fxior FX1 ...
 -- Procedure: fxxor FX1 ...
     These procedures return the fixnum that is the bit-wise "and",
     "inclusive or", or "exclusive or" of the two's complement
     representations of their arguments.  If they are passed only one
     argument, they return that argument.  If they are passed no
     arguments, they return the fixnum (either _-1_ or _0_) that acts as
     identity for the operation.

 -- Procedure: fxif FX1 FX2 FX3
     Return the fixnum that is the bit-wise "if" of the two's complement
     representations of its arguments, i.e.  for each bit, if it is 1 in
     FX1, the corresponding bit in FX2 becomes the value of the
     corresponding bit in the result, and if it is 0, the corresponding
     bit in FX3 becomes the corresponding bit in the value of the
     result.  This is the fixnum result of the following computation:

          (fxior (fxand FX1 FX2)
                 (fxand (fxnot FX1) FX3))

 -- Procedure: fxbit-count FX
     If FX is non-negative, this procedure returns the number of 1 bits
     in the two's complement representation of FX.  Otherwise it returns
     the result of the following computation:

          (fxnot (fxbit-count (fxnot EI)))

 -- Procedure: fxlength FX
     Return the number of bits needed to represent FX if it is positive,
     and the number of bits needed to represent '(fxnot FX)' if it is
     negative, which is the fixnum result of the following computation:

          (do ((result 0 (+ result 1))
               (bits (if (fxnegative? FX)
                         (fxnot FX)
                         FX)
                     (fxarithmetic-shift-right bits 1)))
              ((fxzero? bits)
               result))

 -- Procedure: fxfirst-bit-set FX
     Return the index of the least significant 1 bit in the two's
     complement representation of FX.  If FX is 0, then -1 is returned.

          (fxfirst-bit-set 0)        =>  -1
          (fxfirst-bit-set 1)        =>  0
          (fxfirst-bit-set -4)       =>  2

 -- Procedure: fxbit-set? FX1 FX2
     FX2 must be non-negative.

     The 'fxbit-set?' procedure returns '#t' if the FX2th bit is 1 in
     the two's complement representation of FX1, and '#f' otherwise.
     This is the fixnum result of the following computation:

          (if (fx>= FX2 (fx- (fixnum-width) 1))
              (fxnegative? FX1)
              (not
                (fxzero?
                   (fxand FX1
                          (fxarithmetic-shift-left 1 FX2)))))

 -- Procedure: fxcopy-bit FX1 FX2 FX3
     FX2 must be non-negative and less than w-1.  FX3 must be 0 or 1.

     The 'fxcopy-bit' procedure returns the result of replacing the
     FX2th bit of FX1 by FX3, which is the result of the following
     computation:

          (let* ((mask (fxarithmetic-shift-left 1 FX2)))
            (fxif mask
                  (fxarithmetic-shift-left FX3 FX2)
                  FX1))

 -- Procedure: fxbit-field FX1 FX2 FX3
     FX2 and FX3 must be non-negative and less than '(fixnum-width)'.
     Moreover, FX2 must be less than or equal to FX3.

     The 'fxbit-field' procedure returns the number represented by the
     bits at the positions from FX2 (inclusive) to FX3 (exclusive),
     which is the fixnum result of the following computation:

          (let* ((mask (fxnot
                        (fxarithmetic-shift-left -1 FX3))))
            (fxarithmetic-shift-right (fxand FX1 mask)
                                      FX2))

 -- Procedure: fxcopy-bit-field FX1 FX2 FX3 FX4
     FX2 and FX3 must be non-negative and less than '(fixnum-width)'.
     Moreover, FX2 must be less than or equal to FX3.

     The 'fxcopy-bit-field' procedure returns the result of replacing in
     FX1 the bits at positions from FX2 (inclusive) to FX3 (exclusive)
     by the bits in FX4 from position 0 (inclusive) to position FX3-FX2
     (exclusive), which is the fixnum result of the following
     computation:

          (let* ((to    FX1)
                 (start FX2)
                 (end   FX3)
                 (from  FX4)
                 (mask1 (fxarithmetic-shift-left -1 start))
                 (mask2 (fxnot (fxarithmetic-shift-left -1 end)))
                 (mask  (fxand mask1 mask2))
                 (mask3 (fxnot (fxarithmetic-shift-left -1 (- end start)))))
            (fxif mask
                  (fxarithmetic-shift-left (fxand from mask3)
                                           start)
                  to))

 -- Procedure: fxarithmetic-shift FX1 FX2
     The absolute value of FX2 must be less than '(fixnum-width)'.

     If:

          (floor (* FX1 (expt 2 FX2)))

     is a fixnum, then that fixnum is returned.  Otherwise an exception
     with condition type '&implementation-restriction' is raised.

 -- Procedure: fxarithmetic-shift-left FX1 FX2
 -- Procedure: fxarithmetic-shift-right FX1 FX2
     FX2 must be non-negative, and less than '(fixnum-width)'.

     The 'fxarithmetic-shift-left' procedure behaves the same as
     'fxarithmetic-shift', and '(fxarithmetic-shift-right FX1 FX2)'
     behaves the same as '(fxarithmetic-shift FX1 (fx- FX2))'.

 -- Procedure: fxrotate-bit-field FX1 FX2 FX3 FX4
     FX2, FX3, and FX4 must be non-negative and less than
     '(fixnum-width)'.  FX2 must be less than or equal to FX3.  FX4 must
     be less than or equal to the difference between FX3 and FX2.

     The 'fxrotate-bit-field' procedure returns the result of cyclically
     permuting in FX1 the bits at positions from FX2 (inclusive) to FX3
     (exclusive) by FX4 bits towards the more significant bits, which is
     the result of the following computation:

          (let* ((n     FX1)
                 (start FX2)
                 (end   FX3)
                 (count FX4)
                 (width (fx- end start)))
            (fxcopy-bit-field n start end
              (fxior
                (fxarithmetic-shift-left
                  (fxbit-field n start (fx- end count)) count)
                (fxarithmetic-shift-right
                  (fxbit-field n start end) (fx- width count)))))

 -- Procedure: fxreverse-bit-field FX1 FX2 FX3
     FX2 and FX3 must be non-negative and less than '(fixnum-width)'.
     Moreover, FX2 must be less than or equal to FX3.

     The 'fxreverse-bit-field' procedure returns the fixnum obtained
     from FX1 by reversing the order of the bits at positions from FX2
     (inclusive) to FX3 (exclusive).

          (fxreverse-bit-field #b1010010 1 4)       =>  88 ; #b1011000

