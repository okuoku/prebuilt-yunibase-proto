This is vicare-typed.info, produced by makeinfo version 6.5 from
vicare-typed.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.  The focus of this document is
over the typed language extension.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2016-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-typed: (vicare-typed). Vicare Scheme's Typed Language.
END-INFO-DIR-ENTRY


File: vicare-typed.info,  Node: Top,  Next: overview,  Up: (dir)

Vicare Scheme's Typed Language
******************************

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.  The focus of this document is
over the typed language extension.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2016-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.

* Menu:

* overview::                    Overview of the typed language.
* annotations::                 Type annotations.
* specifications::              Type specifications.
* descriptors::                 Type descriptors.
* syntaxes::                    Type-exploiting syntaxes.
* built-in::                    Built-in object types.
* methods::                     Methods and virtual methods.
* protlev::                     Protection levels.
* mixins::                      Sharing object-type definition clauses.
* interfaces::                  Interface types.
* labels::                      Sub-typing with labels.
* friends::                     Friend functions.

Appendices

* Package License::             GNU General Public License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.


File: vicare-typed.info,  Node: overview,  Next: annotations,  Prev: Top,  Up: Top

1 Overview of the package
*************************

Vicare's expander implements an extension to the language defined by
R6RS that allows the definition of typed syntactic bindings.  Type
annotations are optional: we are free to specify them or leave the type
of variables unspecified.

* Menu:

* overview philosophy::         Typed language philosophy.
* overview enabling::           Enabling typed language extensions.
* overview type ids::           Type identifiers.
* overview typed vars::         Typed lexical variables.


File: vicare-typed.info,  Node: overview philosophy,  Next: overview enabling,  Up: overview

1.1 Typed language philosophy
=============================

In this document we refer to the standard Scheme language defined by the
R6RS specifications as the "standard language"; we refer to the typed
Scheme language defined by Vicare as the "typed language".

   To understand how Vicare represents the types of values, we must
remember that every Scheme expression might return multiple values; so
we can think of an expression evaluation as follows:

     (call-with-values
          (lambda () ?EPXR)
       (lambda ?FORMALS ?BODY))

the return values of ?EXPR are bound to the ?FORMALS and used in the
?BODY.  For example, in the code:

     (call-with-values
          (lambda () (values 1 2 3))
       (lambda (a b c) ?BODY))

while the expansion of ?BODY takes place: a typed language would
annotate the syntactic bindings 'a', 'b' and 'c' with the information
that the values are fixnums.

   The tuple of type annotations associated to the ?FORMALS is called
"type signature"; a type signature represents informations about both
the number of values and their type.  We need a type signature to
represent the types of values returned by an expression.  We need a type
signature to represent the types of the arguments accepted in a function
application.

   Given the 'call-with-values' model of thinking to expressions
evaluations: the whole purpose of a typed language is to verify, at
expand-time, that the type signature of an expression matches the type
signature of the arguments of a function.

   The standard language already mandates that the operands in a
function application must be validated at run-time; this means the type
signature of the operands is matched, at run-time, with the type
signature of the arguments.  The typed language extends this feature to
make it possible at expand-time.

   Type annotations are not mandatory in the typed language, so some
operands are validated and others are not.

   To understand the role of Vicare's typed language extensions, we have
to consider that:

   * Standard Scheme is dynamically typed: language implementations
     might perform application signatures validation at run-time every
     time a function is called, considering that the return values of a
     function application are discarded or become the arguments of
     another function application.  For example the function 'flsin' can
     be implemented as:

          #!r6rs
          (import (except (rnrs (6))
                          flsin)
            (vicare system $flonums))

          (define (flsin x)
            (assert (flonum? x))
            ($flsin x))

   * It is possible to build a standard Scheme language implementation
     that performs compile-time type inference; with such
     implementation: occasionally the compiler can determine the type of
     operands and return values and collapse multiple validations into a
     single one.  For example:

          #!r6rs
          (import (rnrs (6)))

          (define (flsomething x)
            (values (flsin x) (flcos x) (fltan x)))

     can be transformed into (pseudo-code):

          #!r6rs
          (import (rnrs (6))
            (vicare system $flonums))

          (define (flsomething x)
            (assert (flonum? x))
            (values ($flsin x) ($flcos x) ($fltan x)))

     or automatically defined safe and unsafe variants of the same
     function:

          #!r6rs
          (import (rnrs (6))
            (vicare system $flonums))

          (define (flsomething x)
            (assert (flonum? x))
            ($flsomething x))

          (define ($flsomething x)
            (values ($flsin x) ($flcos x) ($fltan x)))

     so that the unsafe '$flsomething' can be used later in place of the
     safe 'flsomething' if we know that the argument is a flonum.

   * The evaluation of a Scheme language program or library is defined
     to have two steps: expansion; compilation-and-evaluation or
     interpretation.  Standard Scheme is a "high-level language" which
     is transformed into a "core language" by the process of expansion;
     the expander allows macros to implement customised high-level
     transformations.  The core language expressions are handed to the
     compiler or the interpreter.

   * Type inference does not blend well with standard Scheme macro
     expansion; it is, in general, impossible to infer the types of a
     macro use before fully expanding it, or, in special cases, at least
     partially expanding it.  True type inference can be performed on
     the core language that is the result of fully expanding the
     standard language.  This means we cannot integrate the powerful
     features of the expander in the code resulting from transformations
     made possible by type inference.

   * Vicare is a language dialect whose purpose is to be a standard
     Scheme language with extensions; it allows mixed use of standard
     language syntax and extended language syntax.  The language
     extensions are mostly implemented in the expander, to allow user
     code to customise the generation of core language.

   * By explicitly specifying the types of lexical bindings: Vicare's
     dialect allows some of the expand-time validations and
     transformations that would be possible in a language with full type
     inference.

   Since there is no type inference: the code writer is invited to
explicitly add type annotations to the syntaxes that establish syntactic
bindings.


File: vicare-typed.info,  Node: overview enabling,  Next: overview type ids,  Prev: overview philosophy,  Up: overview

1.2 Enabling typed language extensions
======================================

Typed language extensions are *off* by default.  To enable the
extensions we have to use the 'typed-language' option as follows:

   * For libraries:

          (library (demo)
            (options typed-language)
            (export)
            (import (vicare))
            ---)

     *note typed-language: (vicare-scheme)iklib libraries options.

   * For programs:

          (program (demo)
            (options typed-language)
            (import (vicare))
            ---)

     *note typed-language: (vicare-scheme)iklib programs options.

we usually want to import the library '(vicare)' to use the extended
syntaxes that recognise type definitions and annotations.

   We can use the function 'typed-language-enabled?' to enable the typed
language at the REPL (*note typed-language-enabled?:
(vicare-scheme)iklib expander language.).

Strict type checking
....................

An additional option is available for both programs and libraries:
'strict-type-checking'.  It enables expand-time warnings about non-exact
matching between values and the typed variables they are assigned to.

   Under the typed language, the types of variables and values are
matched as with the following forms:

     (import (prefix (vicare expander) xp::))

     (xp::type-annotation-matching <number> <fixnum>)
     => exact-match

     (xp::type-annotation-matching <fixnum> <number>)
     => possible-match

that is:

   * An operand with type '<fixnum>' exactly matches an expected
     argument of type '<number>'.  The operand validation is successful
     at expand-time.

   * An operand with type '<number>' is compatible with an expected
     argument of type '<fixnum>'.  The operand validation is successful
     at expand-time, but further validation at run-time is required.

   When the option 'strict-type-checking' is used: a warning is raised
when a possible match is detected.  For example, the following 'let'
syntax use will raise a warning because the right-hand side expression
returns a '<integer>', while the syntactic binding for 'O' expects a
'<fixnum>':

     (let (({O <fixnum>} (cast-signature (<integer>) (read))))
       ---)

   When examining the raised warnings we must remember that some binding
syntaxes expand into uses of other binding syntaxes; for some built-in
syntaxes of this type:

   * Multiple warnings may be raised for the same non-exact type
     matching.

   * A warning may be raised by the target syntax use rather than the
     source syntax use.


File: vicare-typed.info,  Node: overview type ids,  Next: overview typed vars,  Prev: overview enabling,  Up: overview

1.3 Type identifiers
====================

A "type identifier" is a bound syntactic identifier whose syntactic
binding's descriptor contains informations about the type's properties.
Examples of type identifiers are:

   * Struct-type name identifiers defined by 'define-struct'; they are
     automatically made type identifiers by Vicare.

   * Record-type name identifiers defined by 'define-record-type'; they
     are automatically made type identifiers by Vicare.  Condition
     object types (like '&i/o') are special cases of these.

   * The library '(vicare)' exports a set type identifiers (whose
     implementation is integrated in Vicare's expander) representing the
     types of built-in objects.  Some of them are: '<fixnum>',
     '<string>', '<vector>', '<textual-input-port>'.  *note Built-in
     object types: built-in.

   Type identifiers are organised in a tree hierarchy, with subtypes
inheriting properties of supertypes; by convention, '<top>' is the
parent of all the type annotations, the root of the tree; '<top>' has no
parent.

   Many predefined type identifiers have names enclosed in "angular
parentheses" '< >', but this is just a convention.  Any valid Scheme
symbol can be used as name for a type identifier.


File: vicare-typed.info,  Node: overview typed vars,  Prev: overview type ids,  Up: overview

1.4 Typed lexical variables
===========================

A "typed lexical variable", shortly "typed variable", is a bound
syntactic identifier whose syntactic binding's descriptor contains both
informations about a lexical variable and its type annotation.  Typed
variables are created by the built-in binding syntaxes 'lambda',
'define', 'let', 'letrec', 'let-values', et cetera.

   An example of typed binding creation follows:

     #!vicare
     (program (demo)
       (options typed-language)
       (import (vicare)
       (define {O <fixnum>}
         123))

the syntactic identifier 'O' represents a typed variable with type
annotation '<fixnum>'.

   At the time the typed variable's syntactic binding is established:
the type annotation must hold only already bound type identifiers.  So
the following program (where '---' represents an unspecified form) is
correct because '<duo>' is bound before O:

     #!vicare
     (program (demo)
       (options typed-language)
       (import (vicare))
       (define-record-type <duo>
         (fields one two))
       (define {O <duo>}
         ---))

the follow program is *not* correct:

     #!vicare
     (program (demo)
       (options typed-language)
       (import (vicare))
       (define {O <duo>}
         ---)
       (define-record-type <duo>
         (fields one two)))

and will cause an expand-time syntax violation.


File: vicare-typed.info,  Node: annotations,  Next: specifications,  Prev: overview,  Up: Top

2 Type annotations
******************

Type annotations are special forms that make use of the 'brace' syntax
to associate a type specification to a lexical variable (*note brace:
(vicare-scheme)iklib syntaxes misc.).  It works as follows:

     (define (brace O <fixnum>)
       123)

in which the variable 'O' is defined as having type '<fixnum>'.

     *NOTE* To use the extensions in a friendly manner we need to put
     the source code reader in '#!vicare' mode, this way 'brace' can be
     inserted using actual brace characters:

          #!vicare
          (define {O <fixnum>}
            123)

* Menu:

* annotations inserting::       Inserting type annotations.
* annotations syntaxes::        The syntax of type annotations.
* annotations relations::       Relations between type annotations.
* annotations signatures::      Relations between type signatures.


File: vicare-typed.info,  Node: annotations inserting,  Next: annotations syntaxes,  Up: annotations

2.1 Inserting type annotations
==============================

Everywhere the name of a syntactic binding appears in binding position:
we can add a type annotation by wrapping the syntactic identifier in
braces and appending a type syntax.  With 'let'-like syntaxes we can do:

     (let (({a <fixnum>} 1)
           ({b <string>} "ciao")
           ({c <symbol>} 'hello))
       (list a b c))

with 'lambda' and 'case-lambda' syntaxes we can do:

     (lambda ({a <fixnum>} {b <string>})
       (list a b))

     (case-lambda
       (({a <fixnum>} {b <string>})
        (list a b))
       (({a <fixnum>} {b <string>} {c <symbol>})
        (list a b c)))

with 'define' and 'case-define' syntaxes we can do:

     (define (fun1 {a <fixnum>} {b <string>})
       (list a b))

     (case-define fun2
       (({a <fixnum>} {b <string>})
        (list a b))
       (({a <fixnum>} {b <string>} {c <symbol>})
        (list a b c)))

   When using the syntaxes 'lambda', 'case-lambda', 'define',
'case-define', 'receive', 'let-values' and 'let*-values' we can specify
a "rest" argument that is bound to a list of the rest of the operands;
this syntactic binding can be annotated only with a type that is a
sub-type of '<list>', and so represents a list.  For example:

     ((lambda ({a <fixnum>} {b <string>} . {rest (list-of <symbol>)})
        (vector a b rest))
      1 "ciao" 'x 'y 'z)
     => #(1 "ciao" (x y z))

     ((lambda {args <list>} args)
      1 2 3)
     => (1 2 3)

     (receive ({a <fixnum>} {b <string>} . {rest <list>})
         (values 1 "ciao" 'x 'y 'z)
       rest)
     => (x y z)


File: vicare-typed.info,  Node: annotations syntaxes,  Next: annotations relations,  Prev: annotations inserting,  Up: annotations

2.2 The syntax of type annotations
==================================

Type annotations are either standalone type identifiers like '<fixnum>',
'<string>', '&message' or compound type syntaxes like the following:

     (pair      <fixnum> <string>)
     (list      <fixnum> <string> <symbol>)
     (vector    <fixnum> <string> <symbol>)
     (pair-of   <fixnum>)
     (list-of   <fixnum>)
     (nelist-of <fixnum>)
     (vector-of <fixnum>)
     (nevector-of <fixnum>)
     (hashtable <symbol> <string>)
     (alist     <symbol> <string>)
     (enumeration ?SYMBOL0 ?SYMBOL ...)
     (condition &who &message &irritants)
     (or    <false> <symbol> <string>)
     (and   <exact> <positive>)
     (not   <exact>)
     (maybe <string>)
     (lambda (<fixnum>) => (<string>))
     (case-lambda
       ((<fixnum>) => (<string>))
       ((<flonum>) => (<string>)))
     (type-of ?EXPR)

and others; compound type annotations can be nested at will:

     (or (list-of   <fixnum>)
         (vector-of <fixnum>))

   For every type annotation: a parent type is documented, but the
super-type/sub-type relation is "flexible".  For example, 'list-of' and
'list' annotations are both sub-types of '<list>'; but it also stands
that:

     (type-annotation-super-and-sub? (list-of <fixnum>)
                                     (list <fixnum> <fixnum>))
     => #t

     (type-annotation-super-and-sub? (list-of <fixnum>)
                                     (list <fixnum> <string>))
     => #f

   The following syntactic bindings are exported by '(vicare)'.

 -- Type Annotation: pair ?CAR-TYPE ?CAR-TYPE
 -- Parent Type: <pair>
     Describe a pair having car of type ?CAR-TYPE and cdr of type
     ?CAR-TYPE.  Both ?CAR-TYPE and ?CDR-TYPE are nested type
     annotations.

          (is-a? '(1 . 2.3) (pair <fixnum> <flonum>))
          => #t

 -- Type Annotation: list ?ITEM-TYPE0 ?ITEM-TYPE ...
 -- Parent Type: <list>
     Describe a proper list holding a fixed number of items of the
     specified types (in the given order).  Every ?ITEM-TYPE is a nested
     type annotation.

          (is-a? '(1 2.3) (list <fixnum> <flonum>))
          => #t

 -- Type Annotation: vector ?ITEM-TYPE0 ?ITEM-TYPE ...
 -- Parent Type: <vector>
     Describe a vector holding a fixed number of items of the specified
     types (in the given order).  Every ?ITEM-TYPE is a nested type
     annotation.

          (is-a? '#(1 2.3) (vector <fixnum> <flonum>))
          => #t

 -- Type Annotation: pair-of ?ITEM-TYPE
 -- Parent Type: <pair>
     Describe a pair having both the car and cdr of type ?ITEM-TYPE.
     The syntax ?ITEM-TYPE is a nested type annotation.

          (is-a? '(1 . 2) (pair-of <fixnum>))
          => #t

 -- Type Annotation: list-of ?ITEM-TYPE
 -- Parent Type: <list>
     Describe a proper list holding any number of items (including zero)
     all of the specified type.  The syntax ?ITEM-TYPE is a nested type
     annotation.

          (is-a? '(1 2) (list-of <fixnum>))       => #t
          (is-a? '()    (list-of <fixnum>))       => #t

 -- Type Annotation: nelist-of ?ITEM-TYPE
 -- Parent Type: <pair>
     Describe a proper non-empty list holding any number of items all of
     the specified type.  The syntax ?ITEM-TYPE is a nested type
     annotation.  This type annotation is expanded to:

          (pair ?ITEM-TYPE (list-of ?ITEM-TYPE))

 -- Type Annotation: vector-of ?ITEM-TYPE
 -- Parent Type: <vector>
     Describe a vector holding any number of items (including zero) all
     of the specified type.  The syntax ?ITEM-TYPE is a nested type
     annotation.

          (is-a? '#(1 2) (vector-of <fixnum>))    => #t
          (is-a? '#()    (vector-of <fixnum>))    => #t

 -- Type Annotation: nevector-of ?ITEM-TYPE
 -- Parent Type: <nevector>
     Describe a vector holding one or more items all of the specified
     type.  The syntax ?ITEM-TYPE is a nested type annotation.

          (is-a? '#(1 2) (nevector-of <fixnum>))  => #t
          (is-a? '#()    (nevector-of <fixnum>))  => #f

 -- Type Annotation: hashtable ?KEY-TYPE ?VALUE-TYPE
 -- Parent Type: <hashtable>
     Describe a hashtable having keys of type ?KEY-TYPE and values of
     type ?VALUE-TYPE.  Both ?KEY-TYPE and ?VALUE-TYPE are nested type
     annotations.

 -- Type Annotation: enumeration ?SYMBOL0 ?SYMBOL ...
 -- Parent Type: <symbol>
     Describe an enumeration of symbols; it is used to match a symbol in
     a specified enumeration set.

          (is-a? 'ciao (enumeration hello ciao salut ohayo))
          => #t

          (is-a? 'blue (enumeration hello ciao salut ohayo))
          => #f

     As special case, if we define an alias for an 'enumeration' type
     annotation: we can use such identifier to validate symbols.
     Example:

          (define-type greetings
            (enumeration hello ciao salut ohayo))

          (is-a? 'ciao greetings) => #t
          (greetings ciao)        => ciao
          (greetings blue)        error-> symbol not in enumeration

     The enumeration identifier is indeed used in the implementation of
     the 'define-enumeration' built-in syntax; *note define-enumeration:
     (vicare-scheme)stdlib enum.

          (define-enumeration greetings
            (hello ciao salut ohayo)
            make-greetings)

          (is-a? 'ciao greetings) => #t
          (greetings ciao)        => ciao
          (greetings blue)        error-> symbol not in enumeration

 -- Type Annotation: alist ?KEY-TYPE ?VALUE-TYPE
 -- Parent Type: <list>
     Describe an association list having keys of type ?KEY-TYPE and
     values of type ?VALUE-TYPE.  Both ?KEY-TYPE and ?VALUE-TYPE are
     nested type annotations.

 -- Type Annotation: condition ?COND-TYPE0 ?COND-TYPE ...
 -- Parent Type: <compound-condition>
     Describe a compound condition object holding at least one instance
     of the specified types (the order does not matter).  Every
     ?COND-TYPE is a nested type annotation that must be one among:
     '<condition>', '<compound-condition>', a sub-type of '&condition'.

          (is-a? (condition (make-who-condition 'I)
                            (make-message-condition "hello"))
                 (condition &who &message))
          => #t

          (is-a? (condition (make-who-condition 'I)
                            (make-message-condition "hello"))
                 (condition &message &who))
          => #t

 -- Type Annotation: lambda ?ARGS-SIGNATURE => ?RV-SIGNATURE
 -- Parent Type: <procedure>
     Describe a sub-type of '<procedure>' having a single clause, like
     procedures defined by 'lambda'.  '=>' is the syntactic binding
     exported by '(rnrs base (6))'.

     The argument ?ARGS-SIGNATURE must be a syntax object representing
     the type signature of the procedure's arguments.  The argument
     ?RV-SIGNATURE must be a syntax object representing the type
     signature of the procedure's return values.

 -- Type Annotation: case-lambda ?CLAUSE0 ?CLAUSE ...
 -- Parent Type: <procedure>
     Describe a sub-type of '<procedure>' having multiple clauses, like
     procedures defined by 'case-lambda'.  '=>' is the syntactic binding
     exported by '(rnrs base (6))'.

     Each ?CLAUSE argument must have the format:

          (?ARGS-SIGNATURE => ?RV-SIGNATURE)

     where: ?ARGS-SIGNATURE must be a syntax object representing the
     type signature of the clause's arguments; ?RV-SIGNATURE must be a
     syntax object representing the type signature of the clause's
     return values.

 -- Type Annotation: or ?TYPE0 ?TYPE ...
 -- Parent Type: <top>
     Describe the union between the specified types.  Every ?TYPE is a
     nested type annotation.  A value matches a union of types if its
     type matches at least one of the union's types.

          (is-a? 1      (or <fixnum> <string>))   => #t
          (is-a? "ciao" (or <fixnum> <string>))   => #t
          (is-a? 1.23   (or <fixnum> <string>))   => #f

 -- Type Annotation: or ?TYPE0 ?TYPE ...
 -- Parent Type: <top>
     Describe the union between the specified types.  Every ?TYPE is a
     nested type annotation.  A value matches a union of types if its
     type matches at least one of the union's types.

          (is-a? 1      (or <fixnum> <string>))   => #t
          (is-a? "ciao" (or <fixnum> <string>))   => #t
          (is-a? 1.23   (or <fixnum> <string>))   => #f

 -- Type Annotation: maybe ?TYPE
 -- Parent Type: <top>
     It is a shortcut for:

          (or <false> ?TYPE)

 -- Type Annotation: not ?TYPE
 -- Parent Type: <top>
     Describe the complement of the type.  The argument ?TYPE is a
     nested type annotation.  A value of type ?VAL-TYPE matches the
     complement of ?TYPE if ?VAL-TYPE is neither ?TYPE nor a sub-type of
     ?TYPE.

          (is-a? 1   (not <string>))      => #t
          (is-a? 1.0 (not <fixnum>))      => #f

          ;;If something is not a "<number>", for sure it is
          ;;not a "<fixnum>".
          (type-annotation-super-and-sub? (not <fixnum>) (not <number>))
          => #t

 -- Type Annotation: parent-of ?TYPE
 -- Parent Type: <top>
     Describe the parent of the type; an exception is raised if the type
     has no parent.  The argument ?TYPE is a nested type annotation.

          (type-annotation=? <struct> (parent-of <record>))
          => #t

          (type-annotation=? <fixnum> (parent-of <positive-fixnum>))
          => #t

          (type-annotation=? <positive-fixnum> (parent-of <fixnum>))
          => #f

 -- Type Annotation: ancestor-of ?TYPE
 -- Parent Type: <top>
     Describe the ancestors of the type; if the type has no parent: the
     list of ancestors is empty.  The argument ?TYPE is a nested type
     annotation and it is not included in its list of ancestors.

     This type annotation can be used to match *exactly* a type
     annotation with one of the ancestors of ?TYPE:

          (type-annotation-matching (ancestor-of &condition)
                                    &condition)
          => no-match

          (type-annotation-matching (ancestor-of &condition)
                                    <condition>)
          => exact-match

          (type-annotation-matching (ancestor-of &condition)
                                    <record>)
          => exact-match

          (type-annotation-matching (ancestor-of &condition)
                                    <struct>)
          => exact-match

          (type-annotation-matching (ancestor-of &condition)
                                    <top>)
          => exact-match

          (type-annotation-matching <condition>
                                    (ancestor-of &condition))
          => exact-match

     When used along with 'not', it is used to avoid matching exactly a
     type annotation with one of the ancestors of ?TYPE:

          (type-annotation-matching (not (ancestor-of &condition))
                                    <condition>)
          => no-match

 -- Type Annotation: type-predicate ?TYPE
     A short-cut to specify:

          (lambda (?TYPE) => (<boolean>))

 -- Type Annotation: equality-predicate ?TYPE
     A short-cut to specify:

          (lambda (?TYPE ?TYPE) => (<boolean>))

 -- Type Annotation: comparison-procedure ?TYPE
     A short-cut to specify:

          (lambda (?TYPE ?TYPE) => (<fixnum>))

 -- Type Annotation: hash-function ?TYPE
     A short-cut to specify:

          (lambda (?TYPE) => (<non-negative-fixnum>))

 -- Type Annotation: type-of ?EXPR
     Describe the type of ?EXPR, which must be a Scheme expression.  The
     type signature of ?EXPR must hold a single value.  The expression
     is expanded and not evaluated; the side effects of the expansion
     are performed, so this type annotation must be used with care.

          (type-annotation-syntax (type-of 123))
          => <positive-fixnum>

          (type-annotation-syntax (type-of (void)))
          => <void>

          (let ((fun (lambda () 123)))
            (type-annotation-syntax (type-of (fun))))
          => <positive-fixnum>

          (type-annotation-syntax (or (type-of 1)
                                      (type-of "ciao")
                                      (type-of 'hey)))
          => (or <positive-fixnum> <string> (enumeration hey))

     The expression is not allowed not to return:

          (type-annotation-syntax (type-of (error #f "error")))
          error-> &assertion

     The expression is not allowed to return zero, two or more values:

          (type-annotation-syntax (type-of (values)))
          error-> &assertion

          (type-annotation-syntax (type-of (values 1 2)))
          error-> &assertion

          (type-annotation-syntax (type-of (values 1 2 3)))
          error-> &assertion

     The expression is not allowed to return unspecified values:

          (letrec ((fun (lambda ({_ . <list>}) (fun))))
            (type-annotation-syntax (type-of (fun))))
          error-> &assertion

     The expression is expanded in the current lexical environment for
     phase zero, but with empty lexical environment for the other
     phases:

          (let-syntax ((outer (lambda (stx) 123)))
            (type-annotation-syntax (outer)))
          error-> identifier OUTER out of context

          (let-syntax  ((outer (lambda (stx) 123)))
            (type-annotation-syntax
               (type-of (let-syntax ((inner (lambda (stx) (outer))))
                          (inner)))))
          error-> identifier OUTER out of context


File: vicare-typed.info,  Node: annotations relations,  Next: annotations signatures,  Prev: annotations syntaxes,  Up: annotations

2.3 Relations between type annotations
======================================

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Syntax: type-annotation-syntax ?TYPE
     Expand to a syntax object representing the type annotation of
     ?TYPE.  If ?TYPE is a compound annotation ('or', 'and',
     'condition', ...) some simplification may have been applied to the
     input to produce the output.

          (type-annotation-syntax (or <fixnum> <bignum>))
          => (or <fixnum> <bignum>)

          (type-annotation-syntax (or (enumeration hello salut)
                                      (enumeration ciao)
                                      (enumeration ohayo ciao)))
          => (enumeration hello salut ciao ohayo)

 -- Syntax: type-annotation=? ?TYPE1 ?TYPE2
     Expand to a boolean constant: '#t' if ?TYPE1 is equal to ?TYPE2;
     otherwise '#f'.

          (type-annotation=? <top>    <top>)              => #t
          (type-annotation=? <fixnum> <fixnum>)           => #t
          (type-annotation=? <fixnum> <positive-fixnum>)  => #f

          (internal-body
            (define-type <my-fixnum> <fixnum>)
            (type-annotation=? <fixnum> <my-fixnum>))     => #t

          (type-annotation=? (lambda (<fixnum>) => (<fixnum>))
                             (lambda (<fixnum>) => (<fixnum>)))
          => #t

 -- Syntax: type-annotation-super-and-sub? ?TYPE1 ?TYPE2
     Expand to a boolean constant: '#t' if ?TYPE1 is a super-type of
     ?TYPE2; otherwise '#f'.

          *NOTE* The type '<top>' is conventionally the super-type of
          all the types, with the exception of '<void>'.  The type
          '<bottom>' is conventionally the sub-type of all the types.

          (type-annotation-super-and-sub? <number> <fixnum>)  => #t
          (type-annotation-super-and-sub? <number> <string>)  => #f
          (type-annotation-super-and-sub? <top> <number>)     => #t
          (type-annotation-super-and-sub? <number> <top>)     => #f

          (expansion-of
            (type-annotation-super-and-sub? <number> <fixnum>))
          => (quote #t)

          (expansion-of
            (type-annotation-super-and-sub? <number> <string>))
          => (quote #f)

          (define-record-type alpha)

          (define-record-type beta
            (parent alpha))

          (define-record-type gamma
            (parent beta))

          (type-annotation-super-and-sub? alpha beta)        => #t
          (type-annotation-super-and-sub? beta alpha)        => #f

          (type-annotation-super-and-sub? alpha gamma)       => #t
          (type-annotation-super-and-sub? gamma alpha)       => #f

          (type-annotation-super-and-sub? beta gamma)        => #t
          (type-annotation-super-and-sub? gamma beta)        => #f

 -- Syntax: type-annotation-matching ?TYPE1 ?TYPE2
     Match the two type annotations as if: ?TYPE1 is the type of an
     argument requested by a closure object; ?TYPE2 is the type of the
     operand given to a closure object application.

     Expand to a quoted symbol:

     'exact-match'
          If there is an exact match between the argument's and
          operand's annotation.

     'possible-match'
          If there is a possible match between the argument's and
          operand's annotation; the operand must be further validated at
          run-time.

     'no-match'
          If there is no match between the argument's and operand's
          annotation.

 -- Syntax: type-annotation-common-ancestor ?TYPE1 ?TYPE2
     Expand to a syntax object representing the type annotation that is
     the common ancestor of ?TYPE1 and ?TYPE2.

          (type-annotation-common-ancestor <top> <top>)
          => #'<top>

          (type-annotation-common-ancestor <top> <fixnum>)
          => #'<top>

          (type-annotation-common-ancestor <fixnum> <top>)
          => #'<top>

          (type-annotation-common-ancestor <fixnum> <flonum>)
          => #'<real>

 -- Syntax: type-annotation-ancestors ?TYPE
     Expand to a (possibly empty) list of type annotations representing
     the ancestors of ?TYPE.  ?TYPE is *not* included.

          (type-annotation-ancestors <top>)       => ()
          (type-annotation-ancestors <void>)      => ()

          (type-annotation-ancestors <condition>)
          => (<record> <struct> <top>)

          (type-annotation-ancestors <positive-fixnum>)
          => (<fixnum>
              <exact-integer> <integer> <rational> <rational-valued>
              <real> <real-valued> <complex> <number> <top>)


File: vicare-typed.info,  Node: annotations signatures,  Prev: annotations relations,  Up: annotations

2.4 Relations between type signatures
=====================================

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Syntax: type-signature-super-and-sub? ?SIGNATURE1 ?SIGNATURE2
     Expand to a boolean constant: '#t' if ?SIGNATURE1 is a
     super-signature of ?SIGNATURE2; otherwise '#f'.  The arguments
     ?SIGNATURE must be proper or improper lists of type annotations.

          (type-signature-super-and-sub? (<number>) (<fixnum>))  => #t
          (type-signature-super-and-sub? (<number>) (<string>))  => #f

          (expansion-of
            (type-signature-super-and-sub? (<number>) (<fixnum>))
          => (quote #t)

          (expansion-of
            (type-signature-super-and-sub? (<number>) (<string>))
          => (quote #f)

          (type-signature-super-and-sub? (<top>) (<number>))   => #t
          (type-signature-super-and-sub? (<number>) (<top>))   => #f

          (type-signature-super-and-sub? (<number> <number>)
                                         (<fixnum> <fixnum>))
          => #t
          (type-signature-super-and-sub? (<fixnum> <fixnum>)
                                         (<number> <number>))
          => #f

          (type-signature-super-and-sub? (<number> <number> . <list>)
                                         (<fixnum> <real>   . <list>))
          => #t

 -- Syntax: type-signature-matching ?ARGS-SIGNATURE ?RANDS-SIGNATURE
     Match the two signatures as if: ?ARGS-SIGNATURE is the type
     signature of the arguments requested by a closure object;
     ?RANDS-SIGNATURE is the type signature of the operands given to a
     closure object application.

     Expand to a quoted symbol:

     'exact-match'
          If there is an exact match between the arguments' and
          operands' signatures.

     'possible-match'
          If there is a possible match between the arguments' and
          operands' signatures; the operands must be further validated
          at run-time.

     'no-match'
          If there is no match between the arguments' and operands'
          signatures.

          (type-signature-matching (<top>) (<void>))
          => no-match

          (type-signature-matching (<void>) (<top>))
          => no-match

          (type-signature-matching (<top>) (<fixnum>))
          => exact-match

          (type-signature-matching (<fixnum>) (<positive-fixnum>))
          => exact-match

          (type-signature-matching (<fixnum>) (<top>))
          => possible-match

 -- Syntax: type-signature-common-ancestor ?SIGNATURE1 ?SIGNATURE2
     Expand to a syntax object representing the type signature that is
     the common ancestor of ?SIGNATURE1 and ?SIGNATURE2.

          (type-signature-common-ancestor (<fixnum> <fixnum>)
                                          (<flonum> <bignum>))
          => #'(<real> <exact-integer>)

          (type-signature-common-ancestor (<fixnum> <fixnum> <string>)
                                          (<flonum> <bignum>)
          => #'(<real> <exact-integer> . <list>)

          (type-signature-common-ancestor (<fixnum> <fixnum>)
                                          (<flonum> <bignum> <string>)
          => #'(<real> <exact-integer> . <list>)

 -- Syntax: type-signature-union ?TYPE-SIGNATURE ...
     Compute the union between the given type signatures and expand to a
     quoted symbolic expression representing the result.  Each
     ?TYPE-SIGNATURE argument must be a symbolic expression representing
     a type signature.

          (type-signature-union)
          => <list>

          (type-signature-union (<fixnum>) (<exact-integer>))
          => (<exact-integer>)

          ;;If a component is "<void>" the whole union between type
          ;;annotations becomes "<void>".
          (type-signature-union (<fixnum>) (<void>))
          => (<void>)

          ;;If there are both "<true>" and "<false>": they are
          ;;replaced with a single "<boolean>".
          (type-signature-union (<true>) (<false>))
          => (<boolean>)

          (type-signature-union (<fixnum> <string> <vector>)
                                (<fixnum> <string> <vector>))
          => (<fixnum> <string> <vector>)

          (type-signature-union (<fixnum> <string> <vector>)
                                (<positive-fixnum> <string> <vector>))
          => (<fixnum> <string> <vector>)


File: vicare-typed.info,  Node: specifications,  Next: descriptors,  Prev: annotations,  Up: Top

3 Type specifications
*********************

Type specifications are expand-time objects that describe the
characteristics of object-types.  Type specifications are part of the
lexical environment and are contained in syntactic binding's
descriptors.

   Every type annotation has an internal representation as type
specification.  Usually we do not have to deal with type specifications;
so most of the syntactic bindings are exported by the library '(vicare
expander)'.  For details *note Object-type specifications:
(vicare-scheme)expander specs.


File: vicare-typed.info,  Node: descriptors,  Next: syntaxes,  Prev: specifications,  Up: Top

4 Type descriptors
******************

Type descriptors are run-time objects that "describe" the
characteristics of object-types.  For example R6RS record-type
descriptors, R6RS record-constructor descriptors, Vicare's struct
descriptors are all special cases of type descriptors.

   Every expand-time type annotation has a corresponding run-time type
descriptor.  Usually we do not have to deal with type descriptors; so
most of the syntactic bindings are exported by the library '(vicare
system type-descriptors)', while the public API is exported by
'(vicare)'.

   Whenever we need a type descriptor, we must use the syntax
'type-descriptor' or the function 'type-descriptor-of'; we should never
call directly the constructors of the type descriptor types.

* Menu:

* descriptors retrieving::      Retrieving type descriptors.
* descriptors core::            Core object-type descriptors.
* descriptors compound::        Compound object-type descriptors.
* descriptors other::           Other object-type descriptors.
* descriptors signatures::      Type descriptor signatures.
* descriptors relations::       Relations between type descriptors.


File: vicare-typed.info,  Node: descriptors retrieving,  Next: descriptors core,  Up: descriptors

4.1 Retrieving type descriptors
===============================

The following syntactic bindings are exported by the library '(vicare)'.

 -- Syntax: type-descriptor ?TYPE-ANNOTATION
     Expand to an expression which, compiled and evaluated, results in
     the type descriptor of the specified type annotation.

          (type-descriptor <fixnum>)
          ==> <fixnum>-ctd

          (type-descriptor (list <fixnum> <flonum>))
          ==> (make-list-type-descr (list <fixnum>-ctd <flonum>-ctd))

     Internally, first an expand-time type specification is built; then
     the type descriptor is built from the specification.

 -- Function: type-descriptor-of OBJ
     Return the type descriptor of OBJ.

          (type-descriptor-of +1)         => <positive-fixnum>-ctd
          (type-descriptor-of "ciao")     => <nestring>-ctd


File: vicare-typed.info,  Node: descriptors core,  Next: descriptors compound,  Prev: descriptors retrieving,  Up: descriptors

4.2 Core object-type descriptors
================================

Core object-type descriptors gather the run-time characteristics of
object-types like fixnums and strings; for every core object-type there
is an already defined type descriptor, bound to a syntactic binding
exported by the library '(vicare system type-descriptors)'.

   Such syntactic bindings have name derived from the type name by
appending '-ctd' (where 'ctd' stands for Core Type Descriptor).  So the
type name '<fixnum>' has the associated type descriptor '<fixnum>-ctd',
the type name '<string>' has the associated type descriptor
'<string>-ctd', et cetera.

   Some usage examples:

     (import (only (vicare system type-descriptors)
                   <string>-ctd))

     (type-descriptor <string>)         => <string>-ctd
     (.name <string>-ctd)               => <string>
     (.parent <string>-ctd)             => <top>-ctd

     (.uids-list <string>-ctd)
     => (vicare:core-type:<string> vicare:core-type:<top>)

     (let* ((retriever (.method-retriever <string>-ctd))
            (strlen    (retriever 'length)))
       (strlen "ciao"))
     => 4

   The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <core-type-descriptor>
     The type name of objects describing core object-types.  It has the
     following immutable fields:

     'name'
          A symbol representing the name of this type.  For example:
          '<string>'.

     'parent'
          If this type has a parent: an instance of
          '<core-type-descriptor>' representing the parent of this type;
          otherwise '#f'.

     'type-predicate'
          '#f' or a function implementing the type predicate.

     'equality-predicate'
          '#f' or a function implementing the equality predicate.

     'comparison-procedure'
          '#f' or a function implementing the comparison procedure.

     'hash-function'
          '#f' or a function implementing the hash function.

     'uids-list'
          A list of symbols representing the hierarchy of unique
          identifiers (UIDs) for this type.  The first item in the list
          is the UID of this type, then the parent's UID, then the
          grandparent's UID, et cetera.

     'method-retriever'
          If this type has methods: a procedure to be applied to the
          method name (a symbol) to retrieve the method implementation
          function; otherwise '#f'.

 -- Function: core-type-descriptor? OBJ
     Return '#t' if OBJ is an instance of '<core-type-descriptor>';
     otherwise return '#f'.

 -- Function: core-type-descriptor.name CTD
 -- Function: core-type-descriptor.parent CTD
 -- Function: core-type-descriptor.uids-list CTD
 -- Function: core-type-descriptor.type-predicate CTD
 -- Function: core-type-descriptor.equality-predicate CTD
 -- Function: core-type-descriptor.comparison-procedure CTD
 -- Function: core-type-descriptor.hash-function CTD
 -- Function: core-type-descriptor.method-retriever CTD
     Accessors for the fields of '<core-type-descriptor>'.

 -- Function: core-type-descriptor.uid CTD
     Return the UID of the core-type descriptor CTD.


File: vicare-typed.info,  Node: descriptors compound,  Next: descriptors other,  Prev: descriptors core,  Up: descriptors

4.3 Compound object-type descriptors
====================================

* Menu:

* descriptors compound pair::      Pair type descriptors.
* descriptors compound pair-of::   Pair-of type descriptors.
* descriptors compound list::      List type descriptors.
* descriptors compound list-of::   List-of type descriptors.
* descriptors compound vector::    Vector type descriptors.
* descriptors compound vector-of:: Vector-of type descriptors.
* descriptors compound condobj::   Condition-object type descriptors.
* descriptors compound enum::      Enumeration type descriptors.
* descriptors compound hashtable:: Hashtable type descriptors.
* descriptors compound alist::     Association list type descriptors.
* descriptors compound closure::   Closure object type descriptors.
* descriptors compound union::     Union type descriptors.
* descriptors compound intersect:: Intersection type descriptors.
* descriptors compound complem::   Complement type descriptors.
* descriptors compound ancestor::  Ancestor-of type descriptors.


File: vicare-typed.info,  Node: descriptors compound pair,  Next: descriptors compound pair-of,  Up: descriptors compound

4.3.1 Pair type descriptors
---------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <pair-type-descr>
     Name of type descriptors for pairs of heterogeneous values.  It has
     the following fields:

     'car-des'
          A type descriptor describing the type of the car.

     'cdr-des'
          A type descriptor describing the type of the cdr.

 -- Function: make-pair-type-descr CAR-DES CDR-DES
     Build and return a new instance of '<pair-type-descr>'.

 -- Function: pair-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<pair-type-descr>'; otherwise
     return '#f'.

 -- Function: pair-type-descr.car-des DES
 -- Function: pair-type-descr.cdr-des DES
     Accessors for the fields of '<pair-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound pair-of,  Next: descriptors compound list,  Prev: descriptors compound pair,  Up: descriptors compound

4.3.2 Pair-of type descriptors
------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <pair-of-type-descr>
     Name of type descriptors for pairs of homogeneous values.  It has
     the following fields:

     'item-des'
          A type descriptor describing the type of the car and cdr.

 -- Function: make-pair-of-type-descr ITEM-DES
     Build and return a new instance of '<pair-of-type-descr>'.

 -- Function: pair-of-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<pair-of-type-descr>';
     otherwise return '#f'.

 -- Function: pair-of-type-descr.item-des DES
     Accessor for the field of '<pair-of-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound list,  Next: descriptors compound list-of,  Prev: descriptors compound pair-of,  Up: descriptors compound

4.3.3 List type descriptors
---------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <list-type-descr>
     Name of type descriptors for lists of heterogeneous values.  It has
     the following fields:

     'item-des*'
          A list of type descriptors describing the types of the items.

 -- Function: make-list-type-descr DES-LIST
     Build and return a new instance of '<list-type-descr>'.

 -- Function: list-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<list-type-descr>'; otherwise
     return '#f'.

 -- Function: list-type-descr.item-des* DES
     Accessor for the field of '<list-type-descr>' instances.

 -- Function: list-type-descr.length DES
     Return the length of the list, a non-negative exact integer.


File: vicare-typed.info,  Node: descriptors compound list-of,  Next: descriptors compound vector,  Prev: descriptors compound list,  Up: descriptors compound

4.3.4 List-of type descriptors
------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <list-of-type-descr>
     Name of type descriptors for lists of homogeneous values.  It has
     the following fields:

     'item-des'
          A type descriptor describing the type of the items.

 -- Function: make-list-of-type-descr ITEM-DES
     Build and return a new instance of '<list-of-type-descr>'.

 -- Function: list-of-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<list-of-type-descr>';
     otherwise return '#f'.

 -- Function: list-of-type-descr.item-des DES
     Accessor for the field of '<list-of-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound vector,  Next: descriptors compound vector-of,  Prev: descriptors compound list-of,  Up: descriptors compound

4.3.5 Vector type descriptors
-----------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <vector-type-descr>
     Name of type descriptors for vectors of heterogeneous values.  It
     has the following fields:

     'item-des*'
          A list of type descriptors describing the types of the items.

 -- Function: make-vector-type-descr DES-LIST
     Build and return a new instance of '<vector-type-descr>'.

 -- Function: vector-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<vector-type-descr>';
     otherwise return '#f'.

 -- Function: vector-type-descr.item-des* DES
     Accessor for the field of '<vector-type-descr>' instances.

 -- Function: vector-type-descr.length DES
     Return the length of the vector, a non-negative exact integer.


File: vicare-typed.info,  Node: descriptors compound vector-of,  Next: descriptors compound condobj,  Prev: descriptors compound vector,  Up: descriptors compound

4.3.6 Vector-of type descriptors
--------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <vector-of-type-descr>
     Name of type descriptors for vectors of homogeneous values.  It has
     the following fields:

     'item-des'
          A type descriptor describing the type of the items.

 -- Function: make-vector-of-type-descr ITEM-DES
     Build and return a new instance of '<vector-of-type-descr>'.

 -- Function: vector-of-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<vector-of-type-descr>';
     otherwise return '#f'.

 -- Function: vector-of-type-descr.item-des DES
     Accessor for the field of '<vector-of-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound condobj,  Next: descriptors compound enum,  Prev: descriptors compound vector-of,  Up: descriptors compound

4.3.7 Condition-object type descriptors
---------------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <compound-condition-type-descr>
     Name of type descriptors for compound condition objects.  It has
     the following fields:

     'component-des*'
          A list of type descriptors describing the types of the
          component condition objects.

 -- Function: make-compound-condition-type-descr DES-LIST
     Build and return a new instance of
     '<compound-condition-type-descr>'.

 -- Function: compound-condition-type-descr? OBJ
     Return '#t' if OBJ is an instance of
     '<compound-condition-type-descr>'; otherwise return '#f'.

 -- Function: compound-condition-type-descr.component-des* DES
     Accessor for the field of '<compound-condition-type-descr>'
     instances.


File: vicare-typed.info,  Node: descriptors compound enum,  Next: descriptors compound hashtable,  Prev: descriptors compound condobj,  Up: descriptors compound

4.3.8 Enumeration type descriptors
----------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <enumeration-type-descr>
     Name of type descriptors for symbols enumerations.  It has the
     following fields:

     'symbol*'
          A list of symbols representing the enumerated items.

 -- Function: make-enumeration-type-descr SYMBOLS
     Build and return a new instance of '<enumeration-type-descr>'.

 -- Function: enumeration-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<enumeration-type-descr>';
     otherwise return '#f'.

 -- Function: enumeration-type-descr.symbols* DES
     Accessor for the field of '<enumeration-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound hashtable,  Next: descriptors compound alist,  Prev: descriptors compound enum,  Up: descriptors compound

4.3.9 Hashtable type descriptors
--------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <hashtable-type-descr>
     Name of type descriptors for hashtables.  It has the following
     fields:

     'key-des'
          A type descriptor describing the type of the keys.

     'val-des'
          A type descriptor describing the type of the values.

 -- Function: make-hashtable-type-descr KEY-DES VAL-DES
     Build and return a new instance of '<hashtable-type-descr>'.

 -- Function: hashtable-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<hashtable-type-descr>';
     otherwise return '#f'.

 -- Function: hashtable-type-descr.key-des DES
 -- Function: hashtable-type-descr.val-des DES
     Accessors for the fields of '<hashtable-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound alist,  Next: descriptors compound closure,  Prev: descriptors compound hashtable,  Up: descriptors compound

4.3.10 Association list type descriptors
----------------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <alist-type-descr>
     Name of type descriptors for association lists.  It has the
     following fields:

     'key-des'
          A type descriptor describing the type of the keys.

     'val-des'
          A type descriptor describing the type of the values.

 -- Function: make-alist-type-descr KEY-DES VAL-DES
     Build and return a new instance of '<alist-type-descr>'.

 -- Function: alist-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<alist-type-descr>';
     otherwise return '#f'.

 -- Function: alist-type-descr.key-des DES
 -- Function: alist-type-descr.val-des DES
     Accessors for the fields of '<alist-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound closure,  Next: descriptors compound union,  Prev: descriptors compound alist,  Up: descriptors compound

4.3.11 Closure object type descriptors
--------------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <closure-type-descr>
     Name of type descriptors for closure objects.  It has the following
     fields:

     'signature'
          An instance of '<case-lambda-descriptors>' representing the
          type signatures of the closure's clauses.

 -- Function: make-closure-type-descr SIGNATURE
     Build and return a new instance of '<closure-type-descr>'.

 -- Function: closure-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<closure-type-descr>';
     otherwise return '#f'.

 -- Function: closure-type-descr.signature DES
     Accessor for the field of '<closure-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound union,  Next: descriptors compound intersect,  Prev: descriptors compound closure,  Up: descriptors compound

4.3.12 Union type descriptors
-----------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <union-type-descr>
     Name of type descriptors for unions of type descriptors.  It has
     the following fields:

     'item-des*'
          A list of type descriptors describing the types of the
          components.

 -- Function: make-union-type-descr DES-LIST
     Build and return a new instance of '<union-type-descr>'.

 -- Function: union-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<union-type-descr>';
     otherwise return '#f'.

 -- Function: union-type-descr.item-des* DES
     Accessor for the field of '<union-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound intersect,  Next: descriptors compound complem,  Prev: descriptors compound union,  Up: descriptors compound

4.3.13 Intersection type descriptors
------------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <intersection-type-descr>
     Name of type descriptors for intersections of type descriptors.  It
     has the following fields:

     'item-des*'
          A list of type descriptors describing the types of the
          components.

 -- Function: make-intersection-type-descr DES-LIST
     Build and return a new instance of '<intersection-type-descr>'.

 -- Function: intersection-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<intersection-type-descr>';
     otherwise return '#f'.

 -- Function: intersection-type-descr.item-des* DES
     Accessor for the field of '<intersection-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound complem,  Next: descriptors compound ancestor,  Prev: descriptors compound intersect,  Up: descriptors compound

4.3.14 Complement type descriptors
----------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <complement-type-descr>
     Name of type descriptors for the complement of a type descriptor.
     It has the following fields:

     'item-des'
          The type descriptor to be complemented.

 -- Function: make-complement-type-descr DES
     Build and return a new instance of '<complement-type-descr>'.

 -- Function: complement-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<complement-type-descr>';
     otherwise return '#f'.

 -- Function: complement-type-descr.item-des DES
     Accessor for the field of '<complement-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors compound ancestor,  Prev: descriptors compound complem,  Up: descriptors compound

4.3.15 Ancestor-of type descriptors
-----------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <ancestor-of-type-descr>
     Name of type descriptors representing the ancestors of a type
     descriptor.  It has the following fields:

     'item-des'
          The type descriptor of which we describe the ancestors.

     'ancestor-des*'
          List of type descriptors representing the ancestors.  The head
          of the list is the parent type descriptor.

 -- Function: make-ancestor-of-type-descr DES
     Build and return a new instance of '<ancestor-of-type-descr>'.

 -- Function: ancestor-of-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<ancestor-of-type-descr>';
     otherwise return '#f'.

 -- Function: ancestor-of-type-descr.item-des DES
 -- Function: ancestor-of-type-descr.ancestor-des* DES
     Accessors for the fields of '<ancestor-of-type-descr>' instances.


File: vicare-typed.info,  Node: descriptors other,  Next: descriptors signatures,  Prev: descriptors compound,  Up: descriptors

4.4 Other object-type descriptors
=================================

* Menu:

* descriptors other interface::         Interface type descriptors.


File: vicare-typed.info,  Node: descriptors other interface,  Up: descriptors other

4.4.1 Interface type descriptors
--------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <interface-type-descr>
     Name of type descriptors representing interfaces.  It has the
     following fields:

     'type-name'
          A symbol representing the name of this interface type.

     'uid'
          A symbol acting as unique identifier associated to this type
          descriptor.

     'parent-type-descriptor'
          An instance of '<interface-type-descr>' representing the
          parent of this interface-type; '#f' if this interface-type has
          no parent.

     'implemented-interface-uids'
          A list of symbols representing the UIDs of the interfaces
          implemented by this interface-type.

     'method-prototype-names'
          A list of symbols representing the names of public methods
          that must be provided by object-types implementing this
          interface.

     'method-retriever'
          A function that retrieves method implementation functions
          given the name of a method as symbol.

 -- Function: make-interface-type-descr TYPE-NAME UID
          PARENT-TYPE-DESCRIPTOR IMPLEMENTED-INTERFACE-UIDS
          METHOD-PROTOTYPE-NAMES METHOD-RETRIEVER
     Build and return a new instance of '<interface-type-descr>'.

 -- Function: interface-type-descr? OBJ
     Return '#t' if OBJ is an instance of '<interface-type-descr>';
     otherwise return '#f'.

 -- Function: interface-type-descr.type-name DES
 -- Function: interface-type-descr.uid DES
 -- Function: interface-type-descr.parent-type-descriptor DES
 -- Function: interface-type-descr.implemented-interface-uids DES
 -- Function: interface-type-descr.method-prototype-names DES
 -- Function: interface-type-descr.method-retriever DES
     Accessors for the fields of '<interface-type-descr>' instances.

 -- Function: object-type-implements-interface? INTERFACE-UID DESCR
     The argument DESCR must be an object-type's run-time descriptor.
     Return '#t' if the object-type implements the interface-type whose
     UID is INTERFACE-UID; otherwise return '#f'.

     Usage example, a record-type implements an interface-type:

          (define-interface-type <IOne>
            (nongenerative dummy:<IOne>)
            (method-prototype doit
              (lambda (<string>) => (<number>))))

          (define-record-type <blue>
            (implements <IOne>)
            (method ({doit <number>} {S <string>})
              1))

          (object-type-implements-interface?
            'dummy:<IOne>
            (record-type-descriptor <blue>))
          => #t

          (object-type-implements-interface?
            (car (type-unique-identifiers <IOne>))
            (record-type-descriptor <blue>))
          => #t

          (define O
            (new <blue>))

          (is-a? O <IOne>)                                => #t
          (is-a? (cast-signature (<top>) O) <IOne>)       => #t

     Another usage example, a record-type implements an interface-type
     and its parent:

          (define-interface-type <IOne>
            (method-prototype one
              (lambda (<string>) => (<number>))))

          (define-interface-type <ITwo>
            (parent <IOne>)
            (method-prototype two
              (lambda (<string>) => (<number>))))

          (define-record-type <blue>
            (implements <ITwo>)
            (method ({one <number>} {S <string>})
              1)
            (method ({two <number>} {S <string>})
              1))

          (object-type-implements-interface?
            (car (type-unique-identifiers <IOne>))
            (record-type-descriptor <blue>))
          => #t

          (object-type-implements-interface?
            (car (type-unique-identifiers <ITwo>))
            (record-type-descriptor <blue>))
          => #t

          (define O
            (new <blue>))

          (is-a? O <IOne>)        => #t
          (is-a? O <ITwo>)        => #t

          (is-a? (cast-signature (<top>) O) <IOne>)       => #t
          (is-a? (cast-signature (<top>) O) <ITwo>)       => #t


File: vicare-typed.info,  Node: descriptors signatures,  Next: descriptors relations,  Prev: descriptors other,  Up: descriptors

4.5 Type descriptor signatures
==============================

* Menu:

* descriptors signatures descriptors::  Descriptors signatures.
* descriptors signatures lambda::       Lambda signature descriptors.
* descriptors signatures case-lambda::  Case-lambda signature descriptors.


File: vicare-typed.info,  Node: descriptors signatures descriptors,  Next: descriptors signatures lambda,  Up: descriptors signatures

4.5.1 Descriptors signatures
----------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <descriptors-signature>
     Type name of descriptors representing tuples of values signatures.
     It has the following fields:

     'object-type-descrs'
          A proper or improper list of type descriptors representing the
          signatures of lambda formals.

 -- Function: make-descriptors-signature DESCRIPTORS
     Build and return a new instance of '<descriptors-signature>'.

 -- Function: descriptors-signature? OBJ
     Return '#t' if OBJ is an instance of '<descriptors-signature>';
     otherwise return '#f'.

 -- Function: descriptors-signature.object-type-descrs DES
     Accessor for the field of '<descriptors-signature>' instances.


File: vicare-typed.info,  Node: descriptors signatures lambda,  Next: descriptors signatures case-lambda,  Prev: descriptors signatures descriptors,  Up: descriptors signatures

4.5.2 Lambda signature descriptors
----------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <lambda-descriptors>
     Type name of descriptors representing the type signature of single
     lambda clauses.  It has the following fields:

     'retvals'
          An instance of '<descriptors-signature>' representing the
          types of values returned by this lambda clause.

     'argvals'
          An instance of '<descriptors-signature>' representing the
          types of arguments expected by this lambda clause.

 -- Function: make-lambda-descriptors RETVALS ARGVALS
     Build and return a new instance of '<lambda-descriptors>'.

 -- Function: lambda-descriptors? OBJ
     Return '#t' if OBJ is an instance of '<lambda-descriptors>';
     otherwise return '#f'.

 -- Function: lambda-descriptors.retvals DES
 -- Function: lambda-descriptors.argvals DES
     Accessors for the fields of '<lambda-descriptors>' instances.


File: vicare-typed.info,  Node: descriptors signatures case-lambda,  Prev: descriptors signatures lambda,  Up: descriptors signatures

4.5.3 Case-lambda signature descriptors
---------------------------------------

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Record Type: <case-lambda-descriptors>
     Type name of descriptors representing the type signature of a tuple
     of lambda clauses.  It has the following fields:

     'clause-signature*'
          A list of '<lambda-descriptors>' representing the type
          signatures of the clauses.

 -- Function: make-case-lambda-descriptors CLAUSE-SIGNATURE*
     Build and return a new instance of '<case-lambda-descriptors>'.

 -- Function: case-lambda-descriptors? OBJ
     Return '#t' if OBJ is an instance of '<case-lambda-descriptors>';
     otherwise return '#f'.

 -- Function: case-lambda-descriptors.clause-signature* DES
     Accessor for the field of '<case-lambda-descriptors>' instances.


File: vicare-typed.info,  Node: descriptors relations,  Prev: descriptors signatures,  Up: descriptors

4.6 Relations between type descriptors
======================================

The following syntactic bindings are exported by the library '(vicare
system type-descriptors)'.

 -- Syntax: type-descriptor-parent ?TYPE-ANNOTATION
     Expand to an expression which, compiled and evaluated, returns the
     type descriptor of the parent of the specified type annotation.

          (type-descriptor-parent <fixnum>)
          => <exact-integer>-ctd

          (type-descriptor-parent (pair <fixnum> <flonum>))
          => <pair>-ctd

          (define-record-type alpha)

          (type-descriptor-parent alpha)  => <record>-ctd

          (define-record-type beta
            (parent alpha))

          (type-descriptor-parent beta)
          ==> (record-type-descriptor alpha)

 -- Syntax: type-descriptor-ancestors ?TYPE-ANNOTATION
     Expand to an expression which, compiled and evaluated, returns the
     list of type descriptors representing the ancestors of the
     specified type annotation.  The descriptor of the annotation itself
     is *not* included.

          (type-descriptor-ancestors <top>)
          => ()

          (type-descriptor-ancestors <string>)
          => (<top>-ctd)

          (type-descriptor-ancestors <record>)
          => (<struct>-ctd <top>-ctd)

          (type-descriptor-ancestors <nelist>)
          => (<list>-ctd <top>-ctd)

 -- Syntax: type-descriptor=? ?TYPE-ANNOTATION1 ?TYPE-ANNOTATION2
     Expand to an expression which, compiled and evaluated, returns '#t'
     if the type descriptors associated to the specified type
     annotations are equal; otherwise it returns '#f'.

          (type-descriptor=? <top> <top>)
          => #t

          (type-descriptor=? <top> <number>)
          => #f

          (type-descriptor=? (pair <fixnum> <string>)
                             (pair <fixnum> <string>))
          => #t

 -- Syntax: type-descriptor-super-and-sub? ?TYPE-ANNOTATION1
          ?TYPE-ANNOTATION2
     Expand to an expression which, compiled and evaluated, returns '#t'
     if the type descriptor associated to ?TYPE-ANNOTATION1 is a
     matching super-type of the type descriptor associated to
     ?TYPE-ANNOTATION2; otherwise it returns '#f'.

          (type-descriptor-super-and-sub?
             <top> <top>)
          => #t

          (type-descriptor-super-and-sub?
             <top> <number>)
          => #t

          (type-descriptor-super-and-sub?
             <number> <top>)
          => #f

          (type-descriptor-super-and-sub?
             (pair <fixnum> <null>) (list <fixnum>))
          => #t

 -- Syntax: type-descriptor-matching ?TYPE-ANNOTATION1 ?TYPE-ANNOTATION2
     Expand to an expression which, compiled and evaluated, matches the
     arguments as if: the descriptor associated to ?TYPE-ANNOTATION1 is
     the type of a formal argument requested by a closure object; the
     type descriptor associated to ?TYPE-ANNOTATION2 is the type of the
     operand given to a closure object application.

     Expand to a quoted symbol:

     'exact-match'
          If there is an exact match between the argument's and
          operand's descriptors.

     'possible-match'
          If there is a possible match between the argument's and
          operand's descriptors; the operand must be further validated
          at run-time.

     'no-match'
          If there is no match between the argument's and operand's
          descriptors.

 -- Syntax: descriptors-signature-matching ?SIGNATURE-ANNOTATION1
          ?SIGNATURE-ANNOTATION2
     The arguments SIGNATURE-ANNOTATION must be proper or improper lists
     of type annotations.  Expand to an expression which, compiled and
     evaluated, matches the arguments as if:

        * The '<descriptors-signature>' instance associated to
          ?SIGNATURE-ANNOTATION1 represents the types of formal
          arguments requested by a closure object.

          The '<descriptors-signature>' instance associated to
          ?SIGNATURE-ANNOTATION2 represents the types of the operands
          given to a closure object application.

     Expand to a quoted symbol:

     'exact-match'
          If there is an exact match between the argument's and
          operand's descriptors.

     'possible-match'
          If there is a possible match between the argument's and
          operand's descriptors; the operand must be further validated
          at run-time.

     'no-match'
          If there is no match between the argument's and operand's
          descriptors.

     Usage examples:

          (descriptors-signature-matching
            (<number> <string>)
            (<fixnum> <nestring>))
          => exact-match

          (descriptors-signature-matching
            (<number> <string>)
            (<fixnum> <top>))
          => possible-match

          (descriptors-signature-matching
            (<number> <string>)
            (<fixnum> <vector>))
          => no-match


File: vicare-typed.info,  Node: syntaxes,  Next: built-in,  Prev: descriptors,  Up: Top

5 Type-exploiting syntaxes
**************************

Vicare allows us to perform some operations on objects through generic
syntaxes, provided that we use the type annotation.

   Unless otherwise specified, the syntactic bindings documented in this
section are exported by the library '(vicare)'.  When showing code
examples, we always assume: to have imported the library '(vicare)'; to
have enabled the typed language; to have put the Scheme source code
reader in '#!vicare' mode.

* Menu:

* syntaxes type-of::      Determining the type of expressions.
* syntaxes define::       Defining type annotations.
* syntaxes new-delete::   Constructors and destructors.
* syntaxes predicates::   Predicate syntaxes.
* syntaxes assert::       Validating signatures.
* syntaxes unsafe-cast::  Casting the type of expressions.
* syntaxes case-type::    Branching on type of expression.
* syntaxes variables::    Defining typed variables.
* syntaxes overloads::    Overloaded functions.
* syntaxes operations::   Miscellaneous operations.


File: vicare-typed.info,  Node: syntaxes type-of,  Next: syntaxes define,  Up: syntaxes

5.1 Determining the type of expressions
=======================================

The following syntactic bindings are exported by the library '(vicare)'.

 -- Syntax: type-of ?EXPR
     Fully expand the given expression in the current lexical
     environment and return a structure of type '<type-signature>'
     representing the types of the tuple of returned values.  The
     expression is *not* evaluated, only expanded; this means that the
     expansion side effects are performed.

     Examples:

          (type-of (values))
          => #[signature ()]

          (type-of (values 1 2))
          => #[signature (<positive-fixnum> <positive-fixnum>)]

          (type-of 123)
          => #[signature (<positive-fixnum>)]

          (type-of ((lambda ({_ symbol}) 'ciao)))
          => #[signature (<symbol>)]

          (type-of (+ 1 2))
          => #[signature (<exact-integer>)]

          (type-of (+ 1.2 2.3))
          => #[signature (<flonum>)]

          (type-of (list 1 2.3))
          => #[signature ((list <positive-fixnum> <positive-flonum>))]

          (type-of (condition (make-who-condition 'io)
                              (make-message-condition "ciao")))
          => #[signature ((condition &who &message))]

 -- Syntax: type-unique-identifiers ?TYPE-NAME
     Expand into a list of symbols representing the type hierarchy of
     ?TYPE-NAME, which must be a syntactic identifier bound to an object
     type specification.

          (type-unique-identifiers <top>)
          => (vicare:scheme-type:<top>)

          (type-unique-identifiers <string>)
          => (vicare:scheme-type:<string>
              vicare:scheme-type:<top>)

          (type-unique-identifiers <condition>)
          => (vicare:scheme-type:<condition>
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)

          (type-unique-identifiers <compound-condition>)
          => (vicare:scheme-type:<compound-condition>
              vicare:scheme-type:<condition>
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)

          (type-unique-identifiers &condition)
          => (vicare:scheme-type:&condition
              vicare:scheme-type:<condition>
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)

          (type-unique-identifiers &message)
          => (vicare:scheme-type:&message
              vicare:scheme-type:&condition
              vicare:scheme-type:<condition>
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)

          (internal-body
            (define-struct duo
              (one two)
              (nongenerative yeah))
            (type-unique-identifiers duo))
          => (yeah
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)

          (internal-body
            (define-record-type duo
              (nongenerative duo)
              (fields one two))
            (type-unique-identifiers duo))
          => (duo
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)

          (internal-body
             (define-record-type alpha
               (nongenerative alpha))
             (define-record-type beta
               (parent alpha)
               (nongenerative beta))
             (type-unique-identifiers beta))
          => (beta
              alpha
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)


File: vicare-typed.info,  Node: syntaxes define,  Next: syntaxes new-delete,  Prev: syntaxes type-of,  Up: syntaxes

5.2 Defining type annotations
=============================

The following syntactic bindings are exported by the library '(vicare)'.

 -- Syntax: define-type ?NAME
 -- Syntax: define-type ?NAME ?ANNOTATION
     Define a new type annotation bound to ?NAME.  The argument ?NAME
     must be a syntactic identifier.  The argument ?ANNOTATION must be a
     type annotation syntax.

   We can define new type annotations using the syntax 'define-type':

     (define-type <nnfx>
       <non-negative-fixnum>)

     (define-type <compound>
       (or <vector> <list>))

   This syntax allows recursive type definitions:

     (define-type <it>
       (or (list-of <fixnum>)
           (vector-of <it>)))

   This syntax allows "forward definitions": type annotations that are
half-defined to allow for mutually recursive type definitions.  Here is
an example of forward definition that does nothing useful:

     (define-type <it>)      ;forward definition
     (define-type <it>)      ;does nothing

     ;;Complete the definition of "<it>".
     (define-type <it> <number>)

Here is a possible definition for a '<syntax-object>' type using
mutually recursive definitions:

     (import (rename (only (vicare expander)
                           <stx> <syntactic-identifier>)
                     (<stx> <wrapped-syntax-object>)))

     (define-type <datum>
       (or <null> <boolean> <char> <number> <string> <bytevector>))

     (define-type <syntax-object>)

     (define-type <pair-of-syntax-objects>
       (pair-of <syntax-object>))

     (define-type <vector-of-syntax-objects>
       (vector-of <syntax-object>))

     (define-type <syntax-object>
       (or <datum>
           <wrapped-syntax-object>
           <syntactic-identifier>
           <pair-of-syntax-objects>
           <vector-of-syntax-objects>))

   Forward definitions work only for identifiers defined in the same
lexical contour.  So the following works:

     (define-type <it>)
     (define-type <it>
       <fixnum>)

but the following will fail:

     (define-type <it>)
     (module (<it>)
       (define-type <it>
         <fixnum>))

because the concrete definition is inside a module, which represents a
lexical contour.


File: vicare-typed.info,  Node: syntaxes new-delete,  Next: syntaxes predicates,  Prev: syntaxes define,  Up: syntaxes

5.3 Constructors and destructors
================================

The syntaxes 'new' and 'delete' allow us to retrieve the constructor and
destructor functions of Scheme objects of some types.  For example, with
records:

     (define-record-type duo
       (fields one two)
       (destructor-protocol
         (lambda ()
           (lambda (self)
             (fprintf (current-error-port) "destroying ~s\n" self)))))

     (define O
       (new duo 1 2))

     (delete O)
     -| destroying #[record duo one=1 two=2]

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Syntax: new ?TYPE ?ARG ...
     Retrieve the default constructor function of the type TYPE-NAME and
     apply it to the given arguments; return the result of the
     application.

 -- Syntax: delete ?EXPR
     Retrieve the destructor function, if any, of the object returned by
     the evaluation of the expression ?EXPR and apply it to the object;
     return the return value of the application.  The evaluation of
     ?EXPR must return a single return value.

     If the object has no destructor function: an exception is raised.

     The destructor function must return zero values.


File: vicare-typed.info,  Node: syntaxes predicates,  Next: syntaxes assert,  Prev: syntaxes new-delete,  Up: syntaxes

5.4 Predicate syntaxes
======================

The following syntactic bindings are exported by the library '(vicare)'.

 -- Syntax: is-a? ?EXPR ?TYPE
 -- Syntax: is-a? _ ?TYPE
 -- Auxiliary Syntax: _
     Expand to an expression which, when evaluated, returns '#t' if
     ?EXPR evaluates to a value of type ?TYPE.  ?EXPR can be any
     expression returning a single value.

     When '_' is used as first argument: the syntax evaluates to a
     predicate function.

          (define-record-type duo
            (fields one two))

          (is-a? (new duo 1 2) two)       => #t

          ((is-a? _ duo) (new duo 1 2))   => #t

          (is-a? 123 duo)                 => #f

          (is-a? '(1 2 3) (list <fixnum> <exact-integer> <number>))
          => #t


File: vicare-typed.info,  Node: syntaxes assert,  Next: syntaxes unsafe-cast,  Prev: syntaxes predicates,  Up: syntaxes

5.5 Validating signatures
=========================

The following syntactic bindings are exported by the library '(vicare)'.

 -- Syntax: assert-signature ?SIGNATURE ?EXPR
 -- Syntax: assert-signature-and-return ?SIGNATURE ?EXPR
 -- Syntax: cast-signature ?SIGNATURE ?EXPR
     Validate the type signature of the values returned by ?EXPR, either
     at expand-time or run-time.  ?EXPR can be any Scheme expression.
     ?SIGNATURE must be a proper or improper list of type annotations
     representing the type signature.

     The syntax 'assert-signature' returns a single unspecified value.
     The syntax 'assert-signature-and-return' returns the return values
     of ?EXPR with the original type signature of ?EXPR.  The syntax
     'cast-signature' returns the return values of ?EXPR with the type
     signature ?SIGNATURE.

          (type-of 123)
          => #[signature (<positive-fixnum>)]

          (type-of (assert-signature-and-return (<top>) 123))
          => #[signature (<positive-fixnum>)]

          (type-of (cast-signature (<top>) 123))
          => #[signature (<top>)]

     If it is possible to validate the signature at expand-time: when
     successful, the syntax use just expands to the evaluation of ?EXPR;
     when a type mismatch is detected, an expand-time exception is
     raised.  Otherwise the syntax use expands to an expression that
     validates the values at run-time.

     As special cases, when ?SIGNATURE is '()', a proper or improper
     list of '<top>' and '<list>' types like:

          <list>
          (<top>)
          (<top> <top> <top>)
          (<top> <top> . <list>)

     no validation is performed at run-time, only at expand-time.

   Here are some validation examples:

     (assert-signature () (values))
     (assert-signature-and-return (<fixnum>) 123)    => 123
     (assert-signature-and-return (<string>) "ciao") => "ciao"

     (assert-signature-and-return (<fixnum> <flonum>) (values 1 2.0))
     => 1 2.0

     (expansion-of
       (assert-signature (<fixnum>) 123))
     => (begin (quote 123) (quote #!void))

     (expansion-of
       (assert-signature-and-return (<fixnum>) 123))
     => (quote 123)

     (expansion-of
       (assert-signature-and-return (<fixnum>)
         (unsafe-cast-signature <fixnum> (read))))
     => ((primitive read))

   There are some interesting special cases:

   * If we want to assert (at expand-time) that an expression returns
     zero values, we can do:

          (assert-signature () ?EXPR)

   * If we want to assert nothing, we can do:

          (assert-signature <list> ?EXPR)

     which will just expand to the evaluation of ?EXPR; this might be
     useful when the syntax is used in the output form of another macro
     use.

   * If we want to assert (at expand-time) that an expression returns a
     single value, of any type, we can do:

          (assert-signature (<top>) ?EXPR)

   * If we want to assert (at expand-time) that an expression returns
     two values, of any type, we can do:

          (assert-signature (<top> <top>) ?EXPR)

   * If we want to assert (at expand-time) that an expression returns
     two or more values, of any type, we can do:

          (assert-signature (<top> <top> . <list>) ?EXPR)

Expansion examples for run-time validation
------------------------------------------

Let's say we have a function 'fun' such that:

     (type-of (fun))
     => #[signature <list>]

there is nothing the expander can do to infer the type signature of the
function application.

Example 1: multiple values and return values
............................................

The following syntax use:

     (assert-signature-and-return
         (<fixnum> <flonum> <string>)
       (fun))

is expanded to:

     (call-with-values
         (lambda () (fun))
       (lambda (arg1 arg2 arg3)
         (values ((lambda (obj value-index caller-who)
                    (if (fixnum? obj)
                        obj
                      (expression-return-value-violation
                          caller-who
                        '"return value of invalid type"
                        value-index '(is-a? _ <fixnum>) obj)))
                  arg1 '1 'assert-signature-and-return)
                 ((lambda (obj value-index caller-who)
                    (if (flonum? obj)
                        obj
                      (expression-return-value-violation
                          caller-who
                        '"return value of invalid type"
                        value-index '(is-a? _ <flonum>) obj)))
                  arg2 '2 'assert-signature-and-return)
                 ((lambda (obj value-index caller-who)
                    (if (string? obj)
                        obj
                      (expression-return-value-violation
                          caller-who
                        '"return value of invalid type"
                        value-index '(is-a? _ <string>) obj)))
                  arg3 '3 'assert-signature-and-return))))

Example 2: multiple values and no return values
...............................................

The following syntax use:

     (assert-signature
         (<fixnum> <flonum> <string>)
       (fun))

is expanded to:

     (call-with-values
         (lambda () (fun))
       (lambda (arg1 arg2 arg3)
         ((lambda (obj value-index caller-who)
            (if (not (fixnum? obj))
                (expression-return-value-violation
                    caller-who '"return value of invalid type"
                    value-index '(is-a? _ <fixnum>) obj)
              '#!void))
          arg1 '1 'assert-signature)
         ((lambda (obj value-index caller-who)
            (if (not (flonum? obj))
                (expression-return-value-violation
                    caller-who '"return value of invalid type"
                    value-index '(is-a? _ <flonum>) obj)
              '#!void))
          arg2 '2 'assert-signature)
         ((lambda (obj value-index caller-who)
            (if (not (string? obj))
                (expression-return-value-violation
                    caller-who '"return value of invalid type"
                    value-index '(is-a? _ <string>) obj)
              '#!void))
          arg3 '3 'assert-signature)
         (void)))

Example 3: list of values and return values
...........................................

The following syntax use:

     (assert-signature-and-return
         (list-of <fixnum>)
       (fun))

is expanded to:

     ((lambda arg1
        (lambda (list-value first-value-index caller-who)
          (fold-left
              (lambda (item-index item-value)
                ((lambda (obj value-index caller-who)
                   (if (not ((letrec
                                 ((pred (lambda (obj)
                                          (if (pair? obj)
                                              (if (fixnum? (car obj))
                                                  (pred (cdr obj))
                                                '#f)
                                            (null? obj)))))
                               pred)
                             obj))
                       (expression-return-value-violation caller-who
                         '"return value of invalid type"
                         value-index '(is-a? _ (list-of <fixnum>))
                         obj)
                     '#!void))
                 item-value item-index caller-who)
                (fxadd1 item-index))
            first-value-index list-value)
          list-value))
      (fun))

Example 5: multiple values and return values
............................................

The following syntax use:

     (assert-signature-and-return
         (<fixnum> <flonum> . (list-of <fixnum>))
       (fun))

is expanded to:

     (call-with-values
         (lambda () (fun))
       (lambda (arg1 arg2 . arg3)
         (apply values
                ((lambda (obj value-index caller-who)
                   (if (fixnum? obj)
                       obj
                     (expression-return-value-violation
                         caller-who
                       '"return value of invalid type"
                       value-index '(is-a? _ <fixnum>) obj)))
                 arg1 '1 'assert-signature-and-return)
                ((lambda (obj value-index caller-who)
                   (if (flonum? obj)
                       obj
                     (expression-return-value-violation
                         caller-who
                       '"return value of invalid type"
                       value-index '(is-a? _ <flonum>) obj)))
                 arg2 '2 'assert-signature-and-return)
                (lambda (list-value first-value-index caller-who)
                  (fold-left
                      (lambda (item-index item-value)
                        ((lambda (obj value-index caller-who)
                           (if (not ((letrec
                                         ((pred (lambda (obj)
                                                  (if (pair? obj)
                                                      (if (fixnum? (car obj))
                                                          (pred (cdr obj))
                                                        '#f)
                                                    (null? obj)))))
                                       pred) obj))
                               (expression-return-value-violation
                                   caller-who
                                 '"return value of invalid type"
                                 value-index
                                 '(is-a? _ (list-of <fixnum>)) obj)
                             '#!void))
                         item-value item-index caller-who)
                        (fxadd1 item-index))
                    first-value-index list-value)
                  list-value)
                arg3 '3 'assert-signature-and-return)))

Example 5: single value and return values
.........................................

The following syntax use:

     (assert-signature-and-return
         (<fixnum>)
       (fun))

is expanded to:

     ((lambda (arg1)
        ((lambda (obj value-index caller-who)
           (if (fixnum? obj)
               obj
             (expression-return-value-violation caller-who
               '"return value of invalid type"
               value-index '(is-a? _ <fixnum>) obj)))
         arg1 '1 'assert-signature-and-return))
      (fun))

Example 6: no validation and single return value
................................................

The following syntax use:

     (assert-signature-and-return
         (<top>)
       (fun))

is expanded to:

     (fun)

there is no need to insert a validation form because a single value of
any type matches the type signature.

Example 7: no validation and return values
..........................................

The following syntax use:

     (assert-signature-and-return
         <list>
       (fun))

is expanded to:

     (fun)

there is no need to insert a validation form because any number of
return values of any type matches the type signature.


File: vicare-typed.info,  Node: syntaxes unsafe-cast,  Next: syntaxes case-type,  Prev: syntaxes assert,  Up: syntaxes

5.6 Casting the type of expressions
===================================

It is sometimes useful to explicitly declare the type signature of an
expression, so that the expander can perform more type checks and,
maybe, optimisations.  We might want to do it as an unsafe operation,
without introducing run-time validation of values.  For example, if we
know that the result of an expression is a vector of 3 fixnums, we might
write:

     ($vector-ref ?EXPR 1)

and everything is all right, but we are not specifying that the return
value is a fixnum.

   In these corner cases, we can use the syntax 'unsafe-cast-signature':
at expand-time, it tags an expression as returning values of a specified
type signature.  So, in the above example, we could write:

     (unsafe-cast-signature (<fixnum>)
       ($vector-ref ?EXPR 1))

   We can easily check how 'unsafe-cast-signature' works at the REPL:

     vicare> (unsafe-cast-signature (<fixnum>) 123)
     $1 = 123
     vicare> (expansion-of (unsafe-cast-signature (<fixnum>) 123))
     $1 = '123
     vicare> (type-of (unsafe-cast-signature (<fixnum>) 123))
     $1 = #[signature (<fixnum>)]

for a truly untyped expression:

     vicare> (expansion-of (unsafe-cast-signature (<fixnum>) (read)))
     $1 = ((primitive read))
     vicare> (type-of (unsafe-cast-signature (<fixnum>) (read)))
     $1 = #[signature (<fixnum>)]

if the type is incompatible, and we know it at expand-time:

     vicare> (unsafe-cast-signature (<fixnum>) "ciao")
     Unhandled exception
      Condition components:
        1. &who: unsafe-cast-signature
        2. &message: "expression type is incompatible with the requested tag"
        3. &syntax:
            form: #<syntax expr=(unsafe-cast-signature (<fixnum>) "ciao")>
            subform: #<syntax expr="ciao" mark*=(src)>
        4. &irritants: (#[signature (<string>)])

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Syntax: unsafe-cast-signature ?SIGNATURE ?EXPR
     Expand to the ?EXPR expression itself, but, in the expander, tag
     the expression as returning a tuple of values with type signature
     ?SIGNATURE.


File: vicare-typed.info,  Node: syntaxes case-type,  Next: syntaxes variables,  Prev: syntaxes unsafe-cast,  Up: syntaxes

5.7 Branching on type of expression
===================================

The following syntactic bindings are exported by the library '(vicare)'.

 -- Syntax: case-type ?EXPR ?CLAUSE0 ?CLAUSE ...
 -- Auxiliary Syntax: =>
 -- Auxiliary Syntax: else
     Similar to 'case' but branches based on the type of the single
     value returned by ?EXPR.  This syntax is meant to be used with the
     typed language only, its behaviour is unspecified when using the
     standard language.

     Each ?CLAUSE must have one of the formats:

          ((?TYPE-ID) . ?BODY)
          ((?TYPE-ID) => ?RECEIVER-EXPR)
          (else . ?BODY)

     where: ?TYPE-ID must be a type identifier; the 'else' clause is
     valid only as last clause; ?RECEIVER-EXPR must be an expression
     evaluating to a closure object accepting a single argument.

     Examples:

          (case-type 123
            ((<vector>)   'vector)
            ((<fixnum>)   'fixnum)
            ((<string>)   'string))
          => no values

          (case-type 123
            ((<vector>)   'vector)
            ((<fixnum>)   => (lambda (arg) (list arg 'fixnum)))
            ((<string>)   'string)
            (else   'else))
          => (123 fixnum)

          (case-type #t
            ((<vector>)   'vector)
            ((<fixnum>)   'fixnum)
            ((<string>)   'string)
            (else         'else))
          => else


File: vicare-typed.info,  Node: syntaxes variables,  Next: syntaxes overloads,  Prev: syntaxes case-type,  Up: syntaxes

5.8 Defining typed variables
============================

In all the following syntax definitions, we assume the following formats
for the input form components:

     ?STANDARD-CLAUSE ==
       | (?STANDARD-FORMALS . ?BODY)

     ?TYPED-CLAUSE ==
       | (?TYPED-CLAUSE-FORMALS . ?BODY)

     ?TYPED-CLAUSE-FORMALS ==
       | ?TYPED-FORMALS
       | (?ANONYMOUS-RETVALS . ?TYPED-FORMALS)

     ?ANONYMOUS-RETVALS ==
       | (brace _ ?RV-TYPE0 ?RV-TYPE ...)
       | (brace _ ?RV-TYPE ... . ?REST-RV-TYPE)

     ?TYPED-VAR ==
       | ?NAME-ID
       | (brace ?NAME-ID ?TYPE)

     ?TYPED-WHO ==
       | ?WHO-ID
       | (brace ?WHO-ID ?RV-TYPE0 ?RV-TYPE ...)
       | (brace ?WHO-ID ?RV-TYPE ... . ?REST-RV-TYPE)

     ?STANDARD-FORMALS ==
       | ?ARGS-ID
       | (?ARG-ID ...)
       | (?ARG-ID ?ARG-ID0 ... . ?ARGS-ID)

     ?TYPED-FORMALS ==
       | ?TYPED-ARGS
       | (?TYPED-ARG ...)
       | (?TYPED-ARG0 ?TYPED-ARG ... . ?TYPED-REST)

     ?TYPED-ARG ==
       | ?ARG-ID
       | (brace ?ARG-ID ?ARG-TYPE)

     ?TYPED-ARGS ==
       | ?ARGS-ID
       | (brace ?ARGS-ID ?ARGS-TYPE)

     ?TYPED-REST ==
       | ?REST-ID
       | (brace ?REST-ID ?REST-TYPE)

     ?STANDARD-BINDING ==
       | ?STANDARD-VAR

     ?STANDARD-VAR ==
       | ?NAME-ID

     ?TYPED-BINDING ==
       | ?STANDARD-VAR

where the following components are syntactic identifiers:

     ?NAME-ID ?WHO-ID ?ARG-ID ?ARGS-ID ?REST-ID

the following components are type annotations:

     ?TYPE ?ARG-TYPE ?RV-TYPE

and the following components are type annotations that must represent
lists:

     ?ARGS-TYPE ?REST-TYPE ?REST-RV-TYPE

   The following syntactic bindings are exported by the library
'(vicare)'.

Standard syntaxes
.................

 -- Syntax: define/std ?WHO-ID
 -- Syntax: define/std ?WHO-ID ?EXPR
 -- Syntax: define/std (?WHO-ID . ?STANDARD-FORMALS) . ?BODY
     This is the 'define' syntax as defined by R6RS; whenever the
     'define' syntactic binding is used in code with the typed language
     *disabled*: it expands into a use of 'define/std'.

 -- Syntax: case-define/std ?WHO-ID ?STANDARD-CLAUSE0 ?STANDARD-CLAUSE
          ...
     This is a 'case-define' syntax compatible with the R6RS language;
     whenever the 'case-define' syntactic binding is used in code with
     the typed language *disabled*: it expands into a use of
     'case-define/std'.

 -- Syntax: lambda/std ?STANDARD-FORMALS . ?BODY
     This is the 'lambda' syntax as defined by R6RS; whenever the
     'lambda' syntactic binding is used in code with the typed language
     *disabled*: it expands into a use of 'lambda/std'.

 -- Syntax: named-lambda/std ?NAME ?STANDARD-FORMALS . ?BODY
     This is like 'lambda/std', but accepts an argument ?NAME which must
     be a syntactic identifier representing the name of the generated
     closure object.  In the body of the clauses the quoted name is
     bound to the fluid syntax '__who__'.

 -- Syntax: case-lambda/std ?STANDARD-CLAUSE0 ?STANDARD-CLAUSE ...
     This is a 'case-lambda' syntax defined by R6RS; whenever the
     'case-lambda' syntactic binding is used in code with the typed
     language *disabled*: it expands into a use of 'case-lambda/std'.

 -- Syntax: named-case-lambda/std ?NAME ?STANDARD-CLAUSE0
          ?STANDARD-CLAUSE ...
     This is like 'case-lambda/std', but accepts an argument ?NAME which
     must be a syntactic identifier representing the name of the
     generated closure object.  In the body of the clauses the quoted
     name is bound to the fluid syntax '__who__'.

 -- Syntax: let/std (?STANDARD-BINDING ...) . ?BODY
 -- Syntax: let*/std (?STANDARD-BINDING ...) . ?BODY
 -- Syntax: letrec/std (?STANDARD-BINDING ...) . ?BODY
 -- Syntax: letrec*/std (?STANDARD-BINDING ...) . ?BODY
     These are the binding syntaxes defined by R6RS: whenever the
     syntaxes 'let', 'let*', 'letrec', 'letrec*' are used in code with
     the typed language *disabled*: they expand into a uses of
     'let/std', 'let*/std', 'letrec/std', 'letrec*/std'.

 -- Syntax: receive/std ?STANDARD-FORMALS ?PRODUCER-EXPR . ?BODY
 -- Syntax: receive-and-return/std ?STANDARD-FORMALS ?PRODUCER-EXPR .
          ?BODY
     These are 'receive' and 'receive-and-return' syntaxes which define
     standard syntactic bindings: whenever the syntaxes 'receive',
     'receive-and-return' are used in code with the typed language
     *disabled*: they expand into a uses of 'receive/std' and
     'receive-and-return/std'.

Checked syntaxes
................

 -- Syntax: define/checked ?TYPED-VAR
 -- Syntax: define/checked ?TYPED-VAR ?EXPR
 -- Syntax: define/checked (?TYPED-WHO . ?TYPED-FORMALS) . ?BODY
     This is the 'define' syntax that supports the typed language;
     whenever the 'define' syntactic binding is used in code with the
     typed language *enabled*: it expands into a use of
     'define/checked'.

     When defining a variable: the result of the expression is validated
     either at expand-time or at run-time, to make sure that it matches
     the type of the variable.  The expression's type must be a sub-type
     of the variable's type.

     When defining a function: the operands and return values are
     validated either at expand-time or at run-time, to make sure that
     they match the type of the function's type signature.  The
     operands' types must be sub-types of the arguments' types; the
     return values' types must be sub-types of the declared signature
     types.

     Usage examples:

          (define/checked var1
            123)

          (define/checked {var2 <string>}
            "hello")

          (define/checked ({fun <string>} {N <fixnum>})
            (fixnum->string N))

 -- Syntax: case-define/checked ?WHO-ID ?TYPED-CLAUSE0 ?TYPED-CLAUSE ...
     This is a 'case-define' variant that supports the typed language.
     Operands and return values are validated either at expand-time or
     at run-time, to make sure that they match the type signature.

     Usage examples:

          (case-define/checked fun-1
            ((a b c)
             (list a b c))
            ((a b c . rest)
             (cons* a b c rest)))

          (case-define/checked fun-2
            (({_ (list <fixnum> <fixnum> <fixnum>)}
                {a <fixnum>} {b <fixnum>} {c <fixnum>})
             (list a b c))
            (({_ (list-of <fixnum>)}
                {a <fixnum>} {b <fixnum>} {c <fixnum>}
                . {rest (list-of <fixnum>)})
             (cons* a b c rest)))

 -- Syntax: lambda/checked ?TYPED-CLAUSE-FORMALS . ?BODY
     This is the 'lambda' syntax that supports the typed language;
     whenever the 'lambda' syntactic binding is used in code with the
     typed language *enabled*: it expands into a use of
     'lambda/checked'.

     The operands and return values are validated either at expand-time
     and at run-time, to make sure that they match the type of the
     function's type signature.  The operands' types must be sub-types
     of the arguments' types; the return values' types must be sub-types
     of the declared signature types.

     Usage examples:

          (lambda/checked (a b)
            (list a b))

          (lambda/checked ({_ (list <fixnum> <fixnum>)}
                            {a <fixnum>} {b <fixnum>})
            (list a b))

 -- Syntax: named-lambda/checked ?NAME ?TYPED-CLAUSE-FORMALS . ?BODY
     This is like 'lambda/checked', but accepts an argument ?NAME which
     must be a syntactic identifier representing the name of the
     generated closure object.  In the body of the clauses the quoted
     name is bound to the fluid syntax '__who__'.

     Usage examples:

          (named-lambda/checked fun ({_ <string>} {N <fixnum>})
            (fixnum->string N))

 -- Syntax: case-lambda/checked ?TYPED-CLAUSE0 ?TYPED-CLAUSE ...
     This is a 'case-lambda' syntax that supports the typed language;
     whenever the 'case-lambda' syntactic binding is used in code with
     the typed language *enabled*: it expands into a use of
     'case-lambda/checked'.

     Usage examples:

          (case-lambda/checked
            (({_ <string>} {N <fixnum>})
             (fixnum->string N))
            (({_ <string>} {N <fixnum>} {base <fixnum>})
             (fixnum->string N base)))

 -- Syntax: named-case-lambda/checked ?NAME ?TYPED-CLAUSE0 ?TYPED-CLAUSE
          ...
     This is like 'case-lambda/checked', but accepts an argument ?NAME
     which must be a syntactic identifier representing the name of the
     generated closure object.  In the body of the clauses the quoted
     name is bound to the fluid syntax '__who__'.

 -- Syntax: let/checked (?TYPED-BINDING ...) . ?BODY
 -- Syntax: let/checked ?RECUR (?TYPED-BINDING ...) . ?BODY
 -- Syntax: let*/checked (?TYPED-BINDING ...) . ?BODY
 -- Syntax: letrec/checked (?TYPED-BINDING ...) . ?BODY
 -- Syntax: letrec*/checked (?TYPED-BINDING ...) . ?BODY
     These are the binding syntaxes that support the typed language:
     whenever the syntaxes 'let', 'let*', 'letrec', 'letrec*' are used
     in code with the typed language *enabled*: they expand into a uses
     of 'let/checked', 'let*/checked', 'letrec/checked',
     'letrec*/checked'.

     Notice how we can specify type annotation when using the
     named-'let' syntax.  The following recursive function and its
     application to operands:

          (define/checked ({loop <fixnum>} {a <fixnum>} {b <list>})
            (if (fx=? a 3)
                b
              (loop (fxadd1 a) (cons a b))))

          (loop 1 '())

     can be written:

          (let/checked {loop <fixnum>} (({a <fixnum>} 1)
                                          ({b <list>}   '()))
            (if (fx=? a 3)
                b
              (loop (fxadd1 a) (cons a b))))

     where the "name" of the named-'let' contains the type annotations
     of the return values.

 -- Syntax: receive/checked ?TYPED-FORMALS ?PRODUCER-EXPR . ?BODY
 -- Syntax: receive-and-return/checked ?TYPED-FORMALS ?PRODUCER-EXPR .
          ?BODY
     These are 'receive' and 'receive-and-return' syntaxes which define
     typed syntactic bindings: whenever the syntaxes 'receive',
     'receive-and-return' are used in code with the typed language
     *enabled*: they expand into a uses of 'receive/checked' and
     'receive-and-return/checked'.

Typed syntaxes
..............

 -- Syntax: define/typed ?TYPED-VAR
 -- Syntax: define/typed ?TYPED-VAR ?EXPR
 -- Syntax: define/typed (?TYPED-WHO . ?TYPED-FORMALS) . ?BODY
     This is a 'define' syntax variant that supports the typed language:
     with expand-time validation, without run-time validation.

     When defining a variable: the result of the expression is validated
     only at expand-time, to make sure that it matches the type of the
     variable.  The expression's type must be a sub-type of the
     variable's type.

     When defining a function: the operands and return values are
     validated only at expand-time, to make sure that they match the
     type of the function's type signature.  The operands' types must be
     sub-types of the arguments' types; the return values' types must be
     sub-types of the declared signature types.

 -- Syntax: case-define/typed ?WHO-ID ?TYPED-CLAUSE0 ?TYPED-CLAUSE ...
     This is a 'case-define' variant that supports the typed language.
     Operands and return values are validated only expand-time, to make
     sure that they match the type signature.

 -- Syntax: lambda/typed ?TYPED-CLAUSE-FORMALS . ?BODY
     This is a 'lambda' syntax variant supports the typed language: with
     expand-time validation, without run-time validation.

     The operands and return values are validated only at expand-time,
     to make sure that they match the type of the function's type
     signature.  The operands' types must be sub-types of the arguments'
     types; the return values' types must be sub-types of the declared
     signature types.

 -- Syntax: named-lambda/typed ?NAME ?TYPED-CLAUSE-FORMALS . ?BODY
     This is like 'lambda/typed', but accepts an argument ?NAME which
     must be a syntactic identifier representing the name of the
     generated closure object.  In the body of the clauses the quoted
     name is bound to the fluid syntax '__who__'.

 -- Syntax: case-lambda/typed ?TYPED-CLAUSE0 ?TYPED-CLAUSE ...
     This is a 'case-lambda' syntax that supports the typed language:
     with expand-time validation, without run-time validation.

 -- Syntax: named-case-lambda/typed ?NAME ?TYPED-CLAUSE0 ?TYPED-CLAUSE
          ...
     This is like 'case-lambda/typed', but accepts an argument ?NAME
     which must be a syntactic identifier representing the name of the
     generated closure object.  In the body of the clauses the quoted
     name is bound to the fluid syntax '__who__'.


File: vicare-typed.info,  Node: syntaxes overloads,  Next: syntaxes operations,  Prev: syntaxes variables,  Up: syntaxes

5.9 Overloaded functions
========================

An "overloaded function" represents an aggregation of functions linked
to the same name and having different number and/or type of arguments.
For example, in the code:

     (define/overload (fun {O <fixnum>})
       (list 'fixnum O))

     (define/overload (fun {O <string>})
       (list 'string O))

     (define/overload (fun {A <vector>} {B <vector>})
       (list 'vectors (vector-append A B)))

     (fun 123)               => (fixnum 123)
     (fun "ciao")            => (string "ciao")
     (fun '#(1) '#(2))       => (vectors #(1 2))

an overloaded function named 'fun' is defined by the first use of
'define/overload'; subsequent uses add new specialisations to the same
function.

   In the above example: the selection of the specialised function
happens at expand-time, because the expander can determine the type of
the operands.  Early binding (more precisely: expand-time dispatching)
is available only with the "canonical" function application syntax:

     (?FUN ?OPERAND ...)

   Here is an example of late binding (more precisely: run-time
dispatching, or dynamic dispatching):

     (define/overload (doit {O <string>})
       (list 'string O))

     (define/overload (doit {O <fixnum>})
       (list 'fixnum O))

     (map doit '("ciao" 123))
     => ((string "ciao") (fixnum 123))

putting the overloaded function's syntactic identifier in reference
position will reference a special function that implements dynamic
dispatching.

   It is an error to define two specialised functions with the same
formals type signature.  Specialised functions are allowed to have
different type signatures for the returned values, but we should use
this feature with care; it is suggested not to abuse overloaded
functions by adding specialised functions that perform unrelated
operations.

   We can overload functions only in the same lexical context, the
following code will create *two* functions:

     (define/overload (fun {O <fixnum>})
       ---)

     (internal-body
       (define/overload (fun {O <string>})
         ---)
       ---)

   We can define an overloaded function in a library and then add
specialised functions in a second library which depends on the first
one.

   Whenever an overloaded function is applied to a tuple of operands:
first expand-time early binding is attempted; if it fails, run-time late
binding is attempted.  At expand-time:

  1. The expander determines the type of the operands, if it fails a
     syntax violation is raised (for example if an operand expression
     returns multiple values).

  2. The set of specialised functions is visited and the syntactic
     identifier bound to the better matching one is inserted in the code
     to be applied to the operands.  The return values of the
     specialised function will become the return values of the
     overloaded function application.

  3. If no matching function is found: code performing late binding is
     inserted.  If the option '-Woverloaded-function-late-binding' was
     used: a '&warning' exception is raised signalling failure in early
     binding.

At run-time:

  1. The type of the operands is determined using 'type-descriptor-of',
     *note type-descriptor-of: descriptors retrieving.

  2. The set of specialised functions is visited and the better matching
     one is applied to the operands.  The return values of the
     specialised function become the return values of the overloaded
     function application.

  3. If no matching function is found: an exception is raised with type
     '&overloaded-function-late-binding-error', *note Overloaded
     function late binding conditions: (vicare-scheme)iklib conditions
     late-bind overload.

   Specialised functions are ranked to select the better matching.  At
both expand-time and run-time, ranking works by iterating a list of
specialised functions:

  1. Get the next function from the list.  When there are no more
     functions: if a better matching function was selected, it becomes
     the one; if no matching function was found, perform the default
     action.

  2. If the formals' type signature of the next function is a super-type
     of the operands' type signature: the function is the "next matching
     one", otherwise it is discarded and we iterate to step 1.

  3. If the next matching function is the first in the list: it becomes
     the "current better matching" and we iterate to step 1.

  4. If the formals' type signature of the next matching is a sub-type
     of the formals' type signature of the better matching: the next
     matching becomes the new better matching; otherwise the old better
     matching stands.  We iterate to step 1.

   Here is an example that shows how ranking works:

     (define/overload (fun {O <number>})
       `(number ,O))

     (define/overload (fun {O <real>})
       `(real ,O))

     (define/overload (fun {O <fixnum>})
       `(fixnum ,O))

     (fun 1+2i)      => (number 1+2i)
     (fun 3.4)       => (real   3.4)
     (fun 5)         => (fixnum 5)

notice that, at expand-time, only the operands' type signature seen by
the expander is the one that matters, with the same definitions above:

     (fun (cast-signature (<number>) 123))   => (number 123)
     (fun (cast-signature (<real>)   123))   => (real   123)
     (fun (cast-signature (<fixnum>) 123))   => (fixnum 123)

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Syntax: define/overload (?WHO . ?FORMALS) . ?BODY
 -- Syntax: define/overload ((brace ?WHO . ?RV-TYPES) . ?FORMALS) .
          ?BODY
 -- Auxiliary Syntax: brace
     Define a specialisation for the overloaded function ?WHO.  If this
     is the first specialisation for ?WHO, also define the overloaded
     function; otherwise define only the specialisation and register it
     in the already existent ?WHO.

     The syntax has the same format of 'define/typed', it defines a
     function with type annotations for both the arguments and the
     return values.  The function's type signature is used only at
     expand-time to validate the type of the operands used in an
     application.


File: vicare-typed.info,  Node: syntaxes operations,  Prev: syntaxes overloads,  Up: syntaxes

5.10 Miscellaneous operations
=============================

Vicare allows us to specify special procedures for built-in Scheme
types, record-types and label-types; they are:

*Type predicates*
     When applied to a value the type predicate returns '#t' if the
     value matches the type; otherwise it returns '#f'.  It is always
     possible to use the type predicate with the 'is-a?' syntax, *note
     is-a?: syntaxes predicates.

*Equality predicates*
     When applied to two values of the same type: the predicate returns
     '#t' if the values are equal; otherwise it returns '#f'.

*Comparison procedures*
     When applied to two values A and B of the same type, the procedure
     returns a fixnum:

     '-1'
          If A is less than B.

     '0'
          If A is equal to B.

     '+1'
          If A is greater than B.

*Hash functions*
     When applied to an instance of the type: compute and return a
     non-negative fixnum suitable to be used by hashtables.

   The following syntactic bindings are exported by the library
'(vicare)'.

 -- Macro: equality-predicate ?TYPE
     Return a function that can be used as equality predicate between
     instances of ?TYPE, which must be a type annotation.  If ?TYPE
     itself has no equality predicate: traverse the hierarchy of parents
     in search of a predicate.  If the hierarchy has no equality
     predicate: raise a syntax violation.

 -- Macro: comparison-procedure ?TYPE
     Return a function that can be used as comparison procedure between
     instances of ?TYPE, which must be a type annotation.  If ?TYPE
     itself has no comparison procedure: traverse the hierarchy of
     parents in search of a procedure.  If the hierarchy has no
     comparison procedure: raise a syntax violation.

 -- Macro: hash-function ?TYPE
     Return '#f' or a function that can be used as hash function for
     instances of ?TYPE, which must be a type annotation.  If ?TYPE
     itself has no hash function: traverse the hierarchy of parents in
     search of a function.  If the hierarchy has no hash function: raise
     a syntax violation.

 -- Macro: hash ?EXPR
     When the expander succeeds in determining the type of ?EXPR at
     expand-time: if there is a single return value, expand into an
     expression that computes and returns a hash value for the return
     value; otherwise raise a syntax violation.

     When the expander fails to determine the type of ?EXPR at
     expand-time: expand into an expression that attempts, at run-time,
     to determine the type of the return value and compute and return a
     hash value for it.

     The hash function used by this syntax is:

        * For core object-types: the one hard-coded in the object-type
          definition; for example: for fixnums it is 'fixnum-hash'.

        * For struct-types it is 'struct-hash'.

        * For record-types it is the one specified in the record-type
          definition with the 'hash-function' clause; when no hash
          function is specified, 'record-hash' is used.


File: vicare-typed.info,  Node: built-in,  Next: methods,  Prev: syntaxes,  Up: Top

6 Built-in object types
***********************

The library '(vicare)' exports keyword syntactic bindings representing
the types of built-in objects: fixnum, strings, vectors, et cetera.

* Menu:

* built-in void::               Type of the void object.
* built-in top::                The universal super-type.
* built-in bottom::             The universal sub-type.
* built-in wildcard::           Wildcard annotation.
* built-in unique::             Types of unique objects.
* built-in booleans::           Type of boolean objects.
* built-in chars::              Type of character objects.
* built-in symbols::            Type of symbol objects.
* built-in keywords::           Type of keyword objects.
* built-in pointers::           Type of pointer objects.
* built-in transcoders::        Type of transcoder objects.
* built-in procedures::         Type of procedures objects.
* built-in numerics::           Type of numeric objects.
* built-in strings::            Type of string objects.
* built-in vectors::            Type of vector objects.
* built-in lists::              Type of list objects.
* built-in pairs::              Type of pair objects.
* built-in bytevectors::        Type of bytevector objects.
* built-in hashtables::         Type of hashtable objects.
* built-in structs::            Type of struct objects.
* built-in records::            Type of record objects.
* built-in conditions::         Type of condition objects.
* built-in ports::              Type of input/output ports.
* built-in enum-set::           Type of enumeration sets.
* built-in time::               Type of time objects.
* built-in promises::           Type of promise objects.
* built-in utsname::            Type of utsname objects.
* built-in memory-block::       Type of memory block objects.
* built-in reader-annotation::  Type of reader annotation objects.
* built-in stats::              Type of stats objects.
* built-in misc::               Miscellaneous built-in types.


File: vicare-typed.info,  Node: built-in void,  Next: built-in top,  Up: built-in

6.1 The type of the void value
==============================

The type '<void>' is the type of the void object returned by 'void'.  We
should never use '<void>' in a type annotation, because the only
legitimate use of the void object is as single return value of functions
returning "unspecified values" (under Vicare returning a single value is
faster than returning zero values).  If we need a unique value: we
should use the sentinel value, *note The sentinel object:
(vicare-scheme)iklib sentinel.

   Expressions of type '<void>' are deprecated as operands in function
applications and forbidden in logic predicates.  For example:

     (display (vector-set! (vector 1) 0 2))

raises an exception because 'vector-set!' returns the void value.  The
type '<void>' has no parent (it is *not* a sub-type of '<top>') and it
should be like not-a-number for numeric computations.  Here are some
consequences when the expander can determine the type of an operand:

   * Composing '<void>' with other types results in void:

          (type-annotation-syntax (or <fixnum> <void>))
          => <void>

          (type-annotation-syntax (and <fixnum> <void>))
          => <void>

          (type-annotation-syntax (not <void>))
          => <void>

   * A void expression as operand of 'and', 'or', 'xor' and test of 'if'
     will cause an expand-time syntax violation.

   * A void expression as operand of 'not' will cause an expand-time
     syntax violation.

   * Remembering that 'cond' and 'case' return void when no 'else'
     clause is present and no clause matches: when 'cond' or 'case' are
     used as operands, an 'else' clause is mandatory.

   * Remembering that 'when' and 'unless' return void when the body is
     not evaluated: 'when' and 'unless' cannot be used as operands.

   * Uses of the syntax 'set!' cannot be operand expressions.

   The only function that is allowed to have a void operand is the core
primitive 'void-object?'.

 -- Core Type: <void>
     The type of the void object.  '<void>' has no parent type.  The
     union and intersection between '<void>' and any other type is
     '<void>' itself.

 -- Constructor on '<void>': <void> type-constructor
     Return the void object.

 -- Type predicate on '<void>': <boolean> type-predicate OBJ
     The type predicate is 'void-object?'.  Return '#t' if OBJ is void;
     otherwise return '#f'.


File: vicare-typed.info,  Node: built-in top,  Next: built-in bottom,  Prev: built-in void,  Up: built-in

6.2 The universal super-type
============================

 -- Core Type: <top>
     The conventional parent of all the types, with the exception of
     '<void>'.

 -- Constructor on '<top>': <top> type-constructor OBJ
     Return OBJ itself.

 -- Type predicate on '<top>': <true> type-predicate OBJ
     Always return '#t'.


File: vicare-typed.info,  Node: built-in bottom,  Next: built-in wildcard,  Prev: built-in top,  Up: built-in

6.3 The universal sub-type
==========================

 -- Core Type: <bottom>
     A conventional type that is the sub-type of all the other types.

     We must never use '<bottom>' as type annotation for variables,
     because no value is of this type:

          (define {O <bottom>}
            123)
          error-> &expand-time-type-signature-violation

          (let (({O <bottom>} 123))
            O)
          error-> &expand-time-type-signature-violation

     casting to '<bottom>' also fails:

          (cast-signature (<bottom>) 123)
          error-> &expand-time-type-signature-violation

          (unsafe-cast-signature (<bottom>) 123)
          error-> &expand-time-type-signature-violation

     The expressions that raise a non-continuable exception have type
     '<bottom>':

          (type-of (error #f "wrong"))
          => #[signature <bottom>]

     notice that the type signature is the improper list '<bottom>',
     *not* the list '(<bottom>)'.

     As usage example, the following type annotation defines a function
     signature in which the argument can be any value:

          (define-type <my-func>
            (lambda (<bottom>) => (<string>)))

     '<bottom>' is removed from union and intersection type annotations:

          (type-annotation (and <bottom> <fixnum>))
          => #[core-type-spec #[type (<fixnum>)]]

          (type-annotation (or  <bottom> <fixnum>))
          => #[core-type-spec #[type (<fixnum>)]]


File: vicare-typed.info,  Node: built-in wildcard,  Next: built-in unique,  Prev: built-in bottom,  Up: built-in

6.4 Wildcard annotation
=======================

 -- Core Type: <wildcard>
 -- Core Type: _
     A conventional type that is both the super-type of all the other
     types and the sub-type of all the other types.  This type
     annotation is useful as type of arguments to function that are
     themselves used as arguments to functions; *note built-in
     procedures type-predicate:: for a usage example.


File: vicare-typed.info,  Node: built-in unique,  Next: built-in booleans,  Prev: built-in wildcard,  Up: built-in

6.5 Unique objects
==================

* Menu:

* built-in unique sentinel::    The '<sentinel>' type.
* built-in unique eof::         The '<eof>' type.
* built-in unique would-block:: The '<would-block>' type.


File: vicare-typed.info,  Node: built-in unique sentinel,  Next: built-in unique eof,  Up: built-in unique

6.5.1 The '<sentinel>' type
---------------------------

 -- Built-in Type: <sentinel>
 -- Parent Type: <struct>
     Type of the sentinel object.  *note The sentinel object:
     (vicare-scheme)iklib sentinel.

 -- Type constructor on '<sentinel>': <sentinel> type-constructor
     The constructor is 'sentinel'.

 -- Type predicate on '<sentinel>': <boolean> type-predicate OBJ
     The type predicate is 'sentinel?'.

 -- Equality predicate on '<sentinel>': <boolean> equality-predicate
          THIS {OBJ <sentinel>}
     The equality predicate is 'eq?'.

 -- Hash function on '<sentinel>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'sentinel-hash'.


File: vicare-typed.info,  Node: built-in unique eof,  Next: built-in unique would-block,  Prev: built-in unique sentinel,  Up: built-in unique

6.5.2 The '<eof>' type
----------------------

 -- Built-in Type: <eof>
 -- Parent Type: <struct>
     Type of the end-of-file object.  *note End-of-file object:
     (vicare-scheme)stdlib io port eof object.

 -- Type constructor on '<eof>': <eof> type-constructor
     The constructor is 'eof-object'.

 -- Type predicate on '<eof>': <boolean> type-predicate OBJ
     The type predicate is 'eof-object?'.

 -- Equality predicate on '<eof>': <boolean> equality-predicate THIS
          {OBJ <eof>}
     The equality predicate is 'eq?'.

 -- Hash function on '<eof>': <non-negative-fixnum> hash-function THIS
     The hash function is 'eof-object-hash'.


File: vicare-typed.info,  Node: built-in unique would-block,  Prev: built-in unique eof,  Up: built-in unique

6.5.3 The '<would-block>' type
------------------------------

 -- Built-in Type: <would-block>
 -- Parent Type: <struct>
     Type of the would-block object.  *note The would-block object:
     (vicare-scheme)iklib io non-blocking object.

 -- Type constructor on '<would-block>': <would-block> type-constructor
     The constructor is 'would-block-object'.

 -- Type predicate on '<would-block>': <boolean> type-predicate OBJ
     The type predicate is 'would-block?'.

 -- Equality predicate on '<would-block>': <boolean> equality-predicate
          THIS {OBJ <would-block>}
     The equality predicate is 'eq?'.

 -- Hash function on '<would-block>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'would-block-hash'.


File: vicare-typed.info,  Node: built-in booleans,  Next: built-in chars,  Prev: built-in unique,  Up: built-in

6.6 Type of boolean values
==========================

* Menu:

* built-in booleans boolean::     Type of boolean values.
* built-in booleans true::        Type of true booleans.
* built-in booleans false::       Type of false booleans.


File: vicare-typed.info,  Node: built-in booleans boolean,  Next: built-in booleans true,  Up: built-in booleans

6.6.1 Type of boolean values
----------------------------

 -- Core Type: '<boolean>'
 -- Parent Type: '<top>'
     Type of the boolean values '#t' and '#f'.

 -- Constructor on '<boolean>': <boolean> type-constructor OBJ
     Return '#t' if OBJ is true; otherwise return '#f'.

          (new <boolean> #f)      => #f
          (new <boolean> #t)      => #t
          (new <boolean> 12)      => #t

 -- Type predicate on '<boolean>': <boolean> type-predicate OBJ
     The type predicate is 'boolean?'.  Return '#t' if OBJ is '#t' or
     '#f'; otherwise return '#f'.

          (is-a? #t <boolean>)    => #t
          (is-a? #f <boolean>)    => #t
          (is-a? 12 <boolean>)    => #f

 -- Hash function on '<boolean>': <non-negative-fixnum> hash-function
          BOOL
     The hash function is 'boolean-hash'.

          (hash #f)       => 0
          (hash #t)       => 1


File: vicare-typed.info,  Node: built-in booleans true,  Next: built-in booleans false,  Prev: built-in booleans boolean,  Up: built-in booleans

6.6.2 Type of true booleans
---------------------------

 -- Core Type: '<true>'
 -- Parent Type: '<boolean>'
     Type of the boolean value '#t'.

 -- Constructor on '<true>': <true> type-constructor OBJ
     Return '#t' if OBJ is '#t'.

          (new <true> #t)         => #t
          (new <true> 12)         error-> type violation

 -- Type predicate on '<true>': <boolean> type-predicate OBJ
     The type predicate is 'true?'.  Return '#t' if OBJ is '#t'.

          (is-a? #t <true>)       => #t
          (is-a? #f <true>)       error-> type error

 -- Hash function on '<true>': <non-negative-fixnum> hash-function TRUE
     The hash function is 'boolean-hash'.

          (hash #t)       => 1


File: vicare-typed.info,  Node: built-in booleans false,  Prev: built-in booleans true,  Up: built-in booleans

6.6.3 Type of false booleans
----------------------------

 -- Core Type: <false>
 -- Parent Type: <boolean>
     Type of the boolean value '#f'.

 -- Constructor on '<false>': <false> type-constructor OBJ
     Return '#f' if OBJ is '#f'.

          (new <false> #f)         => #f
          (new <false> 12)         error-> type violation

 -- Type predicate on '<false>': <boolean> type-predicate OBJ
     The type predicate is 'false?'.  Return '#f' if OBJ is '#f'.

          (is-a? #f <false>)       => #f
          (is-a? #t <false>)       error-> type error

 -- Hash function on '<false>': <non-negative-fixnum> hash-function
          FALSE
     The hash function is 'boolean-hash'.

          (hash #f)       => 0


File: vicare-typed.info,  Node: built-in chars,  Next: built-in symbols,  Prev: built-in booleans,  Up: built-in

6.7 Type of character values
============================

 -- Core Type: <char>
 -- Parent Type: <top>
     Type of character values.

 -- Constructor on '<char>': <char> type-constructor {FX
          <non-negative-fixnum>}
     The constructor is 'integer->char'.

          (new <char> 65)         => #\A

 -- Type predicate on '<char>': <boolean> type-predicate OBJ
     The type predicate is 'char?'.  Return '#t' if OBJ is a character
     object; otherwise return '#f'.

          (is-a? #\A <char>)      => #t
          (is-a? 123 <char>)      => #f

 -- Hash function on '<char>': <non-negative-fixnum> hash-function CH
     The hash function is 'char-hash'.

          (hash #\A)      => 65

Methods
.......

 -- Method on '<char>': <string> string THIS
     Apply 'string' to the instance.

          (.string #\A)   => "A"

 -- Method on '<char>': <non-negative-fixnum> integer THIS
     Apply 'char->integer' to the instance.

          (.integer #\A)  => 65

 -- Method on '<char>': <non-negative-fixnum> fixnum THIS
     Apply 'char->fixnum' to the instance.

          (.fixnum #\A)   => 65

 -- Method on '<char>': <boolean> = THIS {CH0 <char>} {CH <char>} ...
     Apply 'char=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> != THIS {CH0 <char>} {CH <char>} ...
     Apply 'char!=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> < THIS {CH0 <char>} {CH <char>} ...
     Apply 'char<?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> > THIS {CH0 <char>} {CH <char>} ...
     Apply 'char>?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> <= THIS {CH0 <char>} {CH <char>} ...
     Apply 'char<=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> >= THIS {CH0 <char>} {CH <char>} ...
     Apply 'char>=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> ci= THIS {CH0 <char>} {CH <char>} ...
     Apply 'char-ci=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> ci!= THIS {CH0 <char>} {CH <char>} ...
     Apply 'char-ci!=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> ci< THIS {CH0 <char>} {CH <char>} ...
     Apply 'char-ci<?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> ci> THIS {CH0 <char>} {CH <char>} ...
     Apply 'char-ci>?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> ci<= THIS {CH0 <char>} {CH <char>} ...
     Apply 'char-ci<=?' to the arguments and return its return value.

 -- Method on '<char>': <boolean> ci>= THIS {CH0 <char>} {CH <char>} ...
     Apply 'char-ci>=?' to the arguments and return its return value.

 -- Method on '<char>': <char> min THIS {CH <char>} ...
     Apply 'chmin' to the arguments and return its return value.

 -- Method on '<char>': <char> max THIS {CH <char>} ...
     Apply 'chmax' to the arguments and return its return value.

 -- Method on '<char>': <char> downcase THIS
     Apply 'char-downcase' to the argument and return its return value.

 -- Method on '<char>': <char> foldcase THIS
     Apply 'char-foldcase' to the argument and return its return value.

 -- Method on '<char>': <char> titlecase THIS
     Apply 'char-titlecase' to the argument and return its return value.

 -- Method on '<char>': <char> upcase THIS
     Apply 'char-upcase' to the argument and return its return value.

 -- Method on '<char>': <symbol> general-category THIS
     Apply 'char-general-category' to the argument and return its return
     value.

 -- Method on '<char>': <boolean> alphabetic? THIS
     Apply 'char-alphabetic?' to the argument and return its return
     value.

 -- Method on '<char>': <boolean> lower-case? THIS
     Apply 'char-lower-case?' to the argument and return its return
     value.

 -- Method on '<char>': <boolean> numeric? THIS
     Apply 'char-numeric?' to the argument and return its return value.

 -- Method on '<char>': <boolean> title-case? THIS
     Apply 'char-title-case?' to the argument and return its return
     value.

 -- Method on '<char>': <boolean> upper-case? THIS
     Apply 'char-upper-case?' to the argument and return its return
     value.

 -- Method on '<char>': <boolean> whitespace? THIS
     Apply 'char-whitespace?' to the argument and return its return
     value.


File: vicare-typed.info,  Node: built-in symbols,  Next: built-in keywords,  Prev: built-in chars,  Up: built-in

6.8 Type of symbol values
=========================

* Menu:

* built-in symbols symbols::    The '<symbol>' object-type.
* built-in symbols gensyms::    The '<gensym>' object-type.


File: vicare-typed.info,  Node: built-in symbols symbols,  Next: built-in symbols gensyms,  Up: built-in symbols

6.8.1 The '<symbol>' object-type
--------------------------------

 -- Core Type: <symbol>
 -- Parent Type: <top>
     Type of symbol values (including gensyms).

 -- Constructor on '<symbol>': <symbol> type-constructor {S <string>}
     The constructor is 'string->symbol'.

 -- Type predicate on '<symbol>': <boolean> type-predicate OBJ
     The type predicate is 'symbol?'.  Return '#t' if OBJ is a symbol
     object; otherwise return '#f'.

 -- Hash function on '<symbol>': <non-negative-fixnum> hash-function SYM
     The hash function is 'symbol-hash'.

Methods
.......

 -- Method on '<symbol>': <string> string THIS
     Apply 'symbol->string' to the instance.

 -- Method on '<symbol>': <boolean> bound? THIS
     Apply 'symbol-bound?' to the instance.

 -- Method on '<symbol>': <top> value THIS
 -- Method on '<symbol>': <void> value THIS NEW-VALUE
     When called with no arguments: apply 'symbol-value' to the instance
     to retrieve the current value in the 'value' slot.  When called
     with one argument: apply 'set-symbol-value!' to the instance to
     store a new value 'value' slot.

 -- Method on '<symbol>': <boolean> member? THIS {ES <enum-set>}
     Apply 'enum-set-member?' to the arguments and return its return
     value.

Methods: comparison
...................

 -- Method on '<symbol>': <boolean> = THIS {SYM0 <symbol>} {SYM
          <symbol>} ...
     Apply 'symbol=?' to the arguments and return its return value.

 -- Method on '<symbol>': <boolean> != THIS {SYM0 <symbol>} {SYM
          <symbol>} ...
     Apply 'symbol!=?' to the arguments and return its return value.

 -- Method on '<symbol>': <boolean> < THIS {SYM0 <symbol>} {SYM
          <symbol>} ...
     Apply 'symbol<?' to the arguments and return its return value.

 -- Method on '<symbol>': <boolean> > THIS {SYM0 <symbol>} {SYM
          <symbol>} ...
     Apply 'symbol>?' to the arguments and return its return value.

 -- Method on '<symbol>': <boolean> <= THIS {SYM0 <symbol>} {SYM
          <symbol>} ...
     Apply 'symbol<=?' to the arguments and return its return value.

 -- Method on '<symbol>': <boolean> >= THIS {SYM0 <symbol>} {SYM
          <symbol>} ...
     Apply 'symbol>=?' to the arguments and return its return value.

 -- Method on '<symbol>': <symbol> min THIS {SYM <symbol>} ...
     Apply 'symbol-min' to the arguments and return its return value.

 -- Method on '<symbol>': <symbol> max THIS {SYM <symbol>} ...
     Apply 'symbol-max' to the arguments and return its return value.

Methods: property lists
.......................

 -- Method on '<symbol>': () putprop THIS (KEY <symbol>) VALUE
     Apply 'putprop' to the instance.

 -- Method on '<symbol>': <top> getprop THIS (KEY <symbol>)
     Apply 'getprop' to the instance.

 -- Method on '<symbol>': () remprop THIS (KEY <symbol>)
     Apply 'remprop' to the instance.

 -- Method on '<symbol>': <list> property-list THIS
     Apply 'property-list' to the instance.


File: vicare-typed.info,  Node: built-in symbols gensyms,  Prev: built-in symbols symbols,  Up: built-in symbols

6.8.2 The '<gensym>' object-type
--------------------------------

 -- Core Type: <gensym>
 -- Parent Type: <symbol>
     Type of gensym values.

 -- Constructor on '<gensym>': <gensym> type-constructor
 -- Constructor on '<gensym>': <gensym> type-constructor STRING
 -- Constructor on '<gensym>': <gensym> type-constructor SYMBOL
     The constructor is 'gensym'.

 -- Type predicate on '<gensym>': <boolean> type-predicate OBJ
     The type predicate is 'gensym?'.  Return '#t' if OBJ is a gensym
     object; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in keywords,  Next: built-in pointers,  Prev: built-in symbols,  Up: built-in

6.9 Type of keyword values
==========================

 -- Core Type: <keyword>
 -- Parent Type: <top>
     Type of keyword values.

 -- Constructor on '<keyword>': <keyword> type-constructor SYMBOL
     The constructor is 'symbol->keyword'.

 -- Type predicate on '<keyword>': <boolean> type-predicate OBJ
     The type predicate is 'keyword?'.  Return '#t' if OBJ is a keyword
     object; otherwise return '#f'.

 -- Hash function on '<keyword>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'keyword-hash'.

 -- Equality predicate on '<keyword>': <boolean> equality-predicate THIS
          {K <keyword>}
     The equality predicate is 'keyword=?'.

Methods
.......

 -- Method on '<keyword>': <symbol> symbol THIS
     Apply 'keyword->symbol' to the instance.

 -- Method on '<keyword>': <string> string THIS
     Apply 'keyword->string' to the instance.


File: vicare-typed.info,  Node: built-in pointers,  Next: built-in transcoders,  Prev: built-in keywords,  Up: built-in

6.10 Type of pointer values
===========================

 -- Core Type: <pointer>
 -- Parent Type: '<top>'
     Type of pointer values.

 -- Constructor on '<pointer>': <pointer> type-constructor {ADDR
          <non-negative-exact-integer>}
     The constructor is 'integer->pointer'.

 -- Type predicate on '<pointer>': <boolean> type-predicate OBJ
     The type predicate is 'pointer?'.  Return '#t' if OBJ is a pointer
     object; otherwise return '#f'.

 -- Equality predicate on '<pointer>': <boolean> equality-predicate THIS
          {K <pointer>}
     The equality predicate is 'pointer=?'.

 -- Hash function on '<pointer>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'pointer-hash'.

Methods
.......

 -- Method on '<pointer>': <boolean> null? THIS
     Apply 'pointer-null?' to the instance.

 -- Method on '<pointer>': <exact-integer> integer THIS
     Apply 'pointer->integer' to the instance.

Methods: comparison
...................

 -- Method on '<pointer>': <boolean> = THIS {PTR0 <pointer>} {PTR
          <pointer>} ...
     Apply 'pointer=?' to the arguments and return its return value.

 -- Method on '<pointer>': <boolean> != THIS {PTR0 <pointer>} {PTR
          <pointer>} ...
     Apply 'pointer!=?' to the arguments and return its return value.

 -- Method on '<pointer>': <boolean> < THIS {PTR0 <pointer>} {PTR
          <pointer>} ...
     Apply 'pointer<?' to the arguments and return its return value.

 -- Method on '<pointer>': <boolean> > THIS {PTR0 <pointer>} {PTR
          <pointer>} ...
     Apply 'pointer>?' to the arguments and return its return value.

 -- Method on '<pointer>': <boolean> <= THIS {PTR0 <pointer>} {PTR
          <pointer>} ...
     Apply 'pointer<=?' to the arguments and return its return value.

 -- Method on '<pointer>': <boolean> >= THIS {PTR0 <pointer>} {PTR
          <pointer>} ...
     Apply 'pointer>=?' to the arguments and return its return value.

Methods: arithmetics
....................

 -- Method on '<pointer>': <pointer> add THIS {DIFF <exact-integer>}
     Apply 'pointer-add' to the arguments and return its return value.

 -- Method on '<pointer>': <pointer> diff THIS {P <pointer>}
     Apply 'pointer-diff' to the arguments and return its return value.

 -- Method on '<pointer>': <pointer> clone THIS
     Apply 'pointer-clone' to the instance and return its return value.

 -- Method on '<pointer>': <void> set-null! THIS
     Apply 'set-pointer-null!' to the instance.


File: vicare-typed.info,  Node: built-in transcoders,  Next: built-in procedures,  Prev: built-in pointers,  Up: built-in

6.11 Type of transcoder values
==============================

 -- Core Type: <transcoder>
 -- Parent Type: <top>
     Type of transcoder values.

 -- Constructor on '<transcoder>': <transcoder> type-constructor CODEC
 -- Constructor on '<transcoder>': <transcoder> type-constructor CODEC
          EOL-STYLE
 -- Constructor on '<transcoder>': <transcoder> type-constructor CODEC
          EOL-STYLE HANDLING-MODE
     The constructor is 'make-transcoder'.

 -- Type predicate on '<transcoder>': <boolean> type-predicate OBJ
     The type predicate is 'transcoder?'.  Return '#t' if OBJ is a
     transcoder object; otherwise return '#f'.

 -- Hash function on '<transcoder>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'transcoder-hash'.

Methods
.......

 -- Method on '<transcoder>': <symbol> codec THIS
     Apply 'transcoder-codec' to the instance and return its return
     value.

 -- Method on '<transcoder>': <symbol> eol-style THIS
     Apply 'transcoder-eol-style' to the instance and return its return
     value.

 -- Method on '<transcoder>': <symbol> handling-mode THIS
     Apply 'transcoder-error-handling-mode' to the instance and return
     its return value.


File: vicare-typed.info,  Node: built-in procedures,  Next: built-in numerics,  Prev: built-in transcoders,  Up: built-in

6.12 Type of procedures values
==============================

* Menu:

* built-in procedures procedures::       The '<procedure>' object-type.
* built-in procedures thunk::            The '<thunk>' object-type.
* built-in procedures parameter::        The '<parameter-procedure>' object-type.

* built-in procedures type-predicate::   The '<type-predicate>' object-type.
* built-in procedures type-destructor::  The '<type-destructor>' object-type.
* built-in procedures type-printer::     The '<type-printer>' object-type.
* built-in procedures equality-predicate:: The '<equality-predicate>' object-type.
* built-in procedures comparison-procedure:: The '<comparison-procedure>' object-type.
* built-in procedures hash-function::    The '<hash-function>' object-type.
* built-in procedures type-method-retriever:: The '<type-method-retriever>' object-type.


File: vicare-typed.info,  Node: built-in procedures procedures,  Next: built-in procedures thunk,  Up: built-in procedures

6.12.1 The '<procedure>' object-type
------------------------------------

 -- Core Type: <procedure>
 -- Parent Type: <top>
     Type of closure object values.  There is no constructor.

 -- Type predicate on '<procedure>': <boolean> type-predicate OBJ
     The type predicate is 'procedure?'.  Return '#t' if OBJ is a
     closure object; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in procedures thunk,  Next: built-in procedures parameter,  Prev: built-in procedures procedures,  Up: built-in procedures

6.12.2 The '<thunk>' object-type
--------------------------------

 -- Core Type: <thunk>
     Type of procedures accepting no arguments.  The definition of this
     type is equivalent to:

          (define-type <thunk>
            (lambda () => <list>))


File: vicare-typed.info,  Node: built-in procedures parameter,  Next: built-in procedures type-predicate,  Prev: built-in procedures thunk,  Up: built-in procedures

6.12.3 The '<parameter-procedure>' object-type
----------------------------------------------

 -- Core Type: <parameter-procedure>
     Type of parameter procedures returned by 'make-parameter'.  The
     definition of this type is equivalent to:

          (define-type <parameter-procedure>
            (case-lambda
              (()			=> (<top>))
              ((<top>)		=> ())
              ((<top> <boolean>)	=> ())))


File: vicare-typed.info,  Node: built-in procedures type-predicate,  Next: built-in procedures type-destructor,  Prev: built-in procedures parameter,  Up: built-in procedures

6.12.4 The '<type-predicate>' object-type
-----------------------------------------

 -- Core Type: <type-predicate>
     Type of procedures acting as type predicates.  The definition of
     this type is equivalent to:

          (define-type <type-predicate>
            (lambda (_) => (<boolean>)))


File: vicare-typed.info,  Node: built-in procedures type-destructor,  Next: built-in procedures type-printer,  Prev: built-in procedures type-predicate,  Up: built-in procedures

6.12.5 The '<type-destructor>' object-type
------------------------------------------

 -- Core Type: <type-destructor>
     Type of procedures acting as destructors for object of a specified
     type.  The definition of this type is equivalent to:

          (define-type <type-destructor>
            (lambda (_) => <list>))


File: vicare-typed.info,  Node: built-in procedures type-printer,  Next: built-in procedures equality-predicate,  Prev: built-in procedures type-destructor,  Up: built-in procedures

6.12.6 The '<type-printer>' object-type
---------------------------------------

 -- Core Type: <type-printer>
     Type of procedures acting as custom printers for object of a
     specified type.  The definition of this type is equivalent to:

          (define-type <type-printer>
            (lambda (_ <textual-output-port> <procedure>) => <list>))


File: vicare-typed.info,  Node: built-in procedures equality-predicate,  Next: built-in procedures comparison-procedure,  Prev: built-in procedures type-printer,  Up: built-in procedures

6.12.7 The '<equality-predicate>' object-type
---------------------------------------------

 -- Core Type: <equality-predicate>
     Type of procedures acting as equality predicates.  The definition
     of this type is equivalent to:

          (define-type <equality-predicate>
            (lambda (_ _) => (<boolean>)))


File: vicare-typed.info,  Node: built-in procedures comparison-procedure,  Next: built-in procedures hash-function,  Prev: built-in procedures equality-predicate,  Up: built-in procedures

6.12.8 The '<comparison-procedure>' object-type
-----------------------------------------------

 -- Core Type: <comparison-procedure>
     Type of procedures acting as equality predicates.  The definition
     of this type is equivalent to:

          (define-type <comparison-procedure>
            (lambda (_ _) => (<fixnum>)))


File: vicare-typed.info,  Node: built-in procedures hash-function,  Next: built-in procedures type-method-retriever,  Prev: built-in procedures comparison-procedure,  Up: built-in procedures

6.12.9 The '<hash-function>' object-type
----------------------------------------

 -- Core Type: <hash-function>
     Type of procedures acting as equality predicates.  The definition
     of this type is equivalent to:

          (define-type <hash-function>
            (lambda (_) => (<non-negative-fixnum>)))


File: vicare-typed.info,  Node: built-in procedures type-method-retriever,  Prev: built-in procedures hash-function,  Up: built-in procedures

6.12.10 The '<type-method-retriever>' object-type
-------------------------------------------------

 -- Core Type: <type-method-retriever>
     Type of procedures acting as run-time method retriever for object
     of a specified type.  The definition of this type is equivalent to:

          (define-type <type-method-retriever>
            (lambda (<symbol>) => ((or <false> <procedure>))))


File: vicare-typed.info,  Node: built-in numerics,  Next: built-in strings,  Prev: built-in procedures,  Up: built-in

6.13 Type of numeric values
===========================

* Menu:

* built-in numerics number::           Type of number values.
* built-in numerics complex::          Type of complex values.
* built-in numerics real-valued::      Type of real-valued values.
* built-in numerics real::             Type of real values.
* built-in numerics rational-valued::  Type of rational-valued values.
* built-in numerics rational::         Type of rational values.
* built-in numerics integer-valued::   Type of integer-valued values.
* built-in numerics integer::          Type of integer values.
* built-in numerics exact-integer::    Type of exact-integer values.
* built-in numerics fixnums::          Type of fixnum values.
* built-in numerics bignums::          Type of bignum values.
* built-in numerics flonums::          Type of flonum values.
* built-in numerics ratnums::          Type of ratnum values.
* built-in numerics compnums::         Type of compnum values.
* built-in numerics cflonums::         Type of cflonum values.
* built-in numerics bytes::            Type of byte values.
* built-in numerics octets::           Type of octet values.
* built-in numerics exactness::        Exactness of numeric values.
* built-in numerics sign::             Sign of numeric values.


File: vicare-typed.info,  Node: built-in numerics number,  Next: built-in numerics complex,  Up: built-in numerics

6.13.1 Type of number values
----------------------------

 -- Core Type: <number>
 -- Parent Type: <top>
     Type of numeric values.

 -- Constructor on '<number>': <number> type-constructor Z
     Validate Z as number object and return Z itself.  If Z is not a
     '<number>': raise and exception.

 -- Type predicate on '<number>': <boolean> type-predicate OBJ
     The type predicate is 'number?'.  Return '#t' if OBJ is a
     '<number>' object, otherwise return '#f'.

 -- Equality predicate on '<number>': <boolean> equality-predicate THIS
          {Z <number>}
     The equality predicate is '='.

 -- Hash function on '<number>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'number-hash'.

Methods: predicates
...................

 -- Method on '<number>': <boolean> zero? THIS
     Apply 'zero?' to the argument and return its return value.

 -- Method on '<number>': <boolean> nan? THIS
     Apply 'nan?' to the argument and return its return value.

 -- Method on '<number>': <boolean> finite? THIS
 -- Method on '<number>': <boolean> infinite? THIS
     Apply 'finite?', 'infinite?' to the argument and return its return
     value.

 -- Method on '<number>': <boolean> odd? THIS
 -- Method on '<number>': <boolean> even? THIS
     Apply 'odd?', 'even?' to the argument and return its return value.

Methods: exactness
..................

 -- Method on '<number>': <number> exact THIS
     Apply 'exact' to the argument and return its return value.

 -- Method on '<number>': <number> inexact THIS
     Apply 'inexact' to the argument and return its return value.

Methods: complex numbers
........................

 -- Method on '<number>': <real> magnitude THIS
     Apply 'magnitude' to the argument and return its return value.

 -- Method on '<number>': <real> angle THIS
     Apply 'angle' to the argument and return its return value.

 -- Method on '<number>': <real> real-part THIS
     Apply 'real-part' to the argument and return its return value.

 -- Method on '<number>': <real> imag-part THIS
     Apply 'imag-part' to the argument and return its return value.

 -- Method on '<number>': <number> complex-conjugate THIS
     Apply 'complex-conjugate' to the argument and return its return
     value.

Methods: comparison
...................

 -- Method on '<number>': <boolean> = THIS {Z <number>} ...
     Apply '=' to the arguments and return its return value.

 -- Method on '<number>': <boolean> != THIS {Z <number>} ...
     Apply '!=' to the arguments and return its return value.

Methods: arithmetics
....................

 -- Method on '<number>': <number> + THIS {Z <number>} ...
     Apply '+' to the arguments and return its return value.

 -- Method on '<number>': <number> - THIS {Z <number>} ...
     Apply '-' to the arguments and return its return value.

 -- Method on '<number>': <number> * THIS {Z <number>} ...
     Apply '*' to the arguments and return its return value.

 -- Method on '<number>': <number> / THIS {Z <number>} ...
     Apply '/' to the arguments and return its return value.

 -- Method on '<number>': <number> add1 THIS
     Apply 'add1' to the arguments and return its return value.

 -- Method on '<number>': <number> sub1 THIS
     Apply 'sub1' to the arguments and return its return value.

Methods: exponentiation and logarithms
......................................

 -- Method on '<number>': <number> exp THIS
     Apply 'exp' to the argument and return its return value.

 -- Method on '<number>': <number> log THIS
 -- Method on '<number>': <number> log THIS {Z <number>}
     Apply 'log' to the arguments and return its return value.

 -- Method on '<number>': <number> expt THIS {Z <number>}
     Apply 'expt' to the arguments and return its return value.

 -- Method on '<number>': <number> square THIS
     Apply 'square' to the arguments and return its return value.

 -- Method on '<number>': <number> cube THIS
     Apply 'cube' to the arguments and return its return value.

 -- Method on '<number>': <number> sqrt THIS
     Apply 'sqrt' to the arguments and return its return value.

 -- Method on '<number>': <number> cbrt THIS
     Apply 'cbrt' to the arguments and return its return value.

Methods: trigonometric functions
................................

 -- Method on '<number>': <number> sin THIS
 -- Method on '<number>': <number> cos THIS
 -- Method on '<number>': <number> tan THIS
     Apply 'sin', 'cos', 'tan' to the argument and return its return
     value.

 -- Method on '<number>': <number> asin THIS
 -- Method on '<number>': <number> acos THIS
 -- Method on '<number>': <number> atan THIS
 -- Method on '<number>': <number> atan THIS {Z <number>}
     Apply 'asin', 'acos', 'atan' to the argument and return its return
     value.

Methods: hyperbolic functions
.............................

 -- Method on '<number>': <number> sinh THIS
 -- Method on '<number>': <number> cosh THIS
 -- Method on '<number>': <number> tanh THIS
     Apply 'sinh', 'cosh', 'tanh' to the argument and return its return
     value.

 -- Method on '<number>': <number> asinh THIS
 -- Method on '<number>': <number> acosh THIS
 -- Method on '<number>': <number> atanh THIS
     Apply 'asinh', 'acosh', 'atanh' to the argument and return its
     return value.


File: vicare-typed.info,  Node: built-in numerics complex,  Next: built-in numerics real-valued,  Prev: built-in numerics number,  Up: built-in numerics

6.13.2 Type of complex values
-----------------------------

 -- Core Type: <complex>
 -- Parent Type: <number>
     Type of complex numbers.

 -- Constructor on '<complex>': <complex> type-constructor RE IM
     Apply 'make-rectangular' to the arguments and return its return
     value.

 -- Type predicate on '<complex>': <boolean> type-predicate OBJ
     The type predicate is 'complex?'.  Return '#t' if OBJ is a
     '<complex>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics real-valued,  Next: built-in numerics real,  Prev: built-in numerics complex,  Up: built-in numerics

6.13.3 Type of real-valued values
---------------------------------

 -- Core Type: <real-valued>
 -- Parent Type: <complex>
     Type of real-valued values.

 -- Constructor on '<real-valued>': <real-valued> type-constructor OBJ
     Validate OBJ as object of type '<real-valued>' and return it.

 -- Type predicate on '<real-valued>': <boolean> type-predicate OBJ
     The type predicate is 'real-valued?'.  Return '#t' if OBJ is a
     '<real-valued>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics real,  Next: built-in numerics rational-valued,  Prev: built-in numerics real-valued,  Up: built-in numerics

6.13.4 Type of real values
--------------------------

* Menu:

* built-in numerics real base::         The '<real>' type.
* built-in numerics real positive::     The '<positive-real>' type.
* built-in numerics real negative::     The '<negative-real>' type.
* built-in numerics real zero::         The '<zero-real>' type.
* built-in numerics real non-zero::     The '<non-zero-real>' type.
* built-in numerics real non-negative:: The '<non-negative-real>' type.


File: vicare-typed.info,  Node: built-in numerics real base,  Next: built-in numerics real positive,  Up: built-in numerics real

6.13.4.1 The '<real>' type
..........................

 -- Core Type: <real>
 -- Parent Type: <real-valued>
     Type of real values.  There is no constructor.  The type predicate
     is 'real?'.

 -- Constructor on '<real>': <real> type-constructor OBJ
     Validate OBJ as object of type '<real>' and return it.

 -- Type predicate on '<real>': <boolean> type-predicate OBJ
     The type predicate is 'real?'.  Return '#t' if OBJ is a '<real>'
     object, otherwise return '#f'.

 -- Comparison procedure on '<real>': <fixnum> comparison-procedure THIS
          {X <real>}
     The comparison procedure is 'compar-real'.

Methods: predicates
...................

 -- Method on '<real>': <boolean> positive? THIS
 -- Method on '<real>': <boolean> negative? THIS
     Apply 'positive?', 'negative?' to the argument and return its
     return value.

 -- Method on '<real>': <boolean> non-positive? THIS
 -- Method on '<real>': <boolean> non-negative? THIS
     Apply 'non-positive?', 'non-negative?' to the argument and return
     its return value.

Methods: comparison
...................

 -- Method on '<real>': <boolean> < THIS {Z0 <real>} {Z <real>} ...
     Apply '<' to the arguments and return its return value.

 -- Method on '<real>': <boolean> > THIS {Z0 <real>} {Z <real>} ...
     Apply '>' to the arguments and return its return value.

 -- Method on '<real>': <boolean> <= THIS {Z0 <real>} {Z <real>} ...
     Apply '<=' to the arguments and return its return value.

 -- Method on '<real>': <boolean> <= THIS {Z0 <real>} {Z <real>} ...
     Apply '<=' to the arguments and return its return value.

Methods
.......

 -- Method on '<real>': <non-negative-real> abs THIS
     Apply 'abs' to the argument and return its return value.

 -- Method on '<real>': <real> numerator THIS
     Apply 'numerator' to the argument and return its return value.

 -- Method on '<real>': <real> denominator THIS
     Apply 'denominator' to the argument and return its return value.

 -- Method on '<real>': <real> sign THIS
     Apply 'sign' to the argument and return its return value.

Methods: rounding
.................

 -- Method on '<real>': <real> floor THIS
     Apply 'floor' to the argument and return its return value.

 -- Method on '<real>': <real> ceiling THIS
     Apply 'ceiling' to the argument and return its return value.

 -- Method on '<real>': <real> truncate THIS
     Apply 'truncate' to the argument and return its return value.

 -- Method on '<real>': <real> round THIS
     Apply 'round' to the argument and return its return value.

 -- Method on '<real>': <real> rationalize THIS {X <real>}
     Apply 'rationalize' to the arguments and return its return value.


File: vicare-typed.info,  Node: built-in numerics real positive,  Next: built-in numerics real negative,  Prev: built-in numerics real base,  Up: built-in numerics real

6.13.4.2 The '<positive-real>' type
...................................

 -- Core Type: <positive-real>
     Type of positive real values.  Its definition is equivalent to:

          (define-type <positive-real>
            (or <positive-fixnum> <positive-bignum> <positive-flonum>))


File: vicare-typed.info,  Node: built-in numerics real negative,  Next: built-in numerics real zero,  Prev: built-in numerics real positive,  Up: built-in numerics real

6.13.4.3 The '<negative-real>' type
...................................

 -- Core Type: <negative-real>
     Type of negative real values.  Its definition is equivalent to:

          (define-type <negative-real>
            (or <negative-fixnum> <negative-bignum> <negative-flonum>))


File: vicare-typed.info,  Node: built-in numerics real zero,  Next: built-in numerics real non-zero,  Prev: built-in numerics real negative,  Up: built-in numerics real

6.13.4.4 The '<zero-real>' type
...............................

 -- Core Type: <zero-real>
     Type of zero real values.  Its definition is equivalent to:

          (define-type <zero-real>
            (or <zero-fixnum> <zero-flonum>))


File: vicare-typed.info,  Node: built-in numerics real non-zero,  Next: built-in numerics real non-negative,  Prev: built-in numerics real zero,  Up: built-in numerics real

6.13.4.5 The '<non-zero-real>' type
...................................

 -- Core Type: <non-zero-real>
     Type of non-zero real values.  Its definition is equivalent to:

          (define-type <non-zero-real>
            (or <non-zero-fixnum> <bignum> <non-zero-flonum>))


File: vicare-typed.info,  Node: built-in numerics real non-negative,  Prev: built-in numerics real non-zero,  Up: built-in numerics real

6.13.4.6 The '<non-negative-real>' type
.......................................

 -- Core Type: <non-negative-real>
     Type of non-negative real values.  Its definition is equivalent to:

          (define-type <non-negative-real>
            (or <non-negative-fixnum> <positive-bignum> <positive-flonum>))


File: vicare-typed.info,  Node: built-in numerics rational-valued,  Next: built-in numerics rational,  Prev: built-in numerics real,  Up: built-in numerics

6.13.5 Type of rational-valued values
-------------------------------------

 -- Core Type: <rational-valued>
 -- Parent Type: <real>
     Type of rational-valued values.

 -- Constructor on '<rational-valued>': <rational-valued>
          type-constructor OBJ
     Validate OBJ as object of type '<rational-valued>' and return it.

 -- Type predicate on '<rational-valued>': <boolean> type-predicate OBJ
     The type predicate is 'rational-valued?'.  Return '#t' if OBJ is a
     '<rational-valued>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics rational,  Next: built-in numerics integer-valued,  Prev: built-in numerics rational-valued,  Up: built-in numerics

6.13.6 Type of rational values
------------------------------

* Menu:

* built-in numerics rational base::          The '<rational>' type.
* built-in numerics rational exact::         The '<exact-rational>' type.
* built-in numerics rational non-negative::  The '<non-negative-exact-rational>' type.
* built-in numerics rational non-zero::      The '<non-zero-exact-rational>' type.


File: vicare-typed.info,  Node: built-in numerics rational base,  Next: built-in numerics rational exact,  Up: built-in numerics rational

6.13.6.1 The '<rational>' type
..............................

 -- Core Type: <rational>
 -- Parent Type: <rational-valued>
     Type of rational values.

 -- Constructor on '<rational>': <rational> type-constructor OBJ
     Validate OBJ as object of type '<rational>' and return it.

 -- Type predicate on '<rational>': <boolean> type-predicate OBJ
     The type predicate is 'rational?'.  Return '#t' if OBJ is a
     '<rational>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics rational exact,  Next: built-in numerics rational non-negative,  Prev: built-in numerics rational base,  Up: built-in numerics rational

6.13.6.2 The '<exact-rational>' type
....................................

 -- Core Type: <exact-rational>
     Type of exact rational values.  Its definition is equivalent to:

          (define-type <exact-rational>
            (or <exact-integer> <ratnum>))


File: vicare-typed.info,  Node: built-in numerics rational non-negative,  Next: built-in numerics rational non-zero,  Prev: built-in numerics rational exact,  Up: built-in numerics rational

6.13.6.3 The '<non-negative-exact-rational>' type
.................................................

 -- Core Type: <non-negative-exact-rational>
     Type of non-negative exact rational values.  Its definition is
     equivalent to:

          (define-type <non-negative-exact-rational>
            (or <non-negative-exact-integer> <positive-ratnum>))


File: vicare-typed.info,  Node: built-in numerics rational non-zero,  Prev: built-in numerics rational non-negative,  Up: built-in numerics rational

6.13.6.4 The '<non-zero-exact-rational>' type
.............................................

 -- Core Type: <non-zero-exact-rational>
     Type of non-zero exact rational values.  Its definition is
     equivalent to:

          (define-type <non-zero-exact-rational>
            (or <non-zero-exact-integer> <ratnum>))


File: vicare-typed.info,  Node: built-in numerics integer-valued,  Next: built-in numerics integer,  Prev: built-in numerics rational,  Up: built-in numerics

6.13.7 Type of integer-valued values
------------------------------------

 -- Core Type: <integer-valued>
 -- Parent Type: <rational-valued>
     Type of integer-valued values.

 -- Constructor on '<integer-valued>': <integer-valued> type-constructor
          OBJ
     Validate OBJ as object of type '<integer-valued>' and return it.

 -- Type predicate on '<integer-valued>': <boolean> type-predicate OBJ
     The type predicate is 'integer-valued?'.  Return '#t' if OBJ is a
     '<integer-valued>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics integer,  Next: built-in numerics exact-integer,  Prev: built-in numerics integer-valued,  Up: built-in numerics

6.13.8 Type of integer values
-----------------------------

 -- Core Type: <integer>
 -- Parent Type: <rational>
     Type of integer values.

 -- Constructor on '<integer>': <integer> type-constructor OBJ
     Validate OBJ as object of type '<integer>' and return it.

 -- Type predicate on '<integer>': <boolean> type-predicate OBJ
     The type predicate is 'integer?'.  Return '#t' if OBJ is a
     '<integer>' object, otherwise return '#f'.

Methods
.......

 -- Method on '<integer>': <integer> gcd THIS {X <integer>} ...
     Apply 'gcd' to the arguments and return its return value.

 -- Method on '<integer>': <integer> lcm THIS {X <integer>} ...
     Apply 'lcm' to the arguments and return its return value.

 -- Method on '<integer>': <integer> quotient THIS {X <integer>}
     Apply 'quotient' to the arguments and return its return value.

 -- Method on '<integer>': <integer> remainder THIS {X <integer>}
     Apply 'remainder' to the arguments and return its return value.

 -- Method on '<integer>': <integer> quotient+remainder THIS {X
          <integer>}
     Apply 'quotient+remainder' to the arguments and return its return
     values.

 -- Method on '<integer>': <integer> modulo THIS {X <integer>}
     Apply 'modulo' to the arguments and return its return value.

 -- Method on '<integer>': <integer> factorial THIS {X <integer>}
     Apply 'factorial' to the argument and return its return value.


File: vicare-typed.info,  Node: built-in numerics exact-integer,  Next: built-in numerics fixnums,  Prev: built-in numerics integer,  Up: built-in numerics

6.13.9 Type of exact-integer values
-----------------------------------

* Menu:

* built-in numerics exact-integer base::          The '<exact-integer>' type.
* built-in numerics exact-integer positive::      The '<positive-exact-integer>' type.
* built-in numerics exact-integer negative::      The '<negative-exact-integer>' type.
* built-in numerics exact-integer non-zero::      The '<non-zero-exact-integer>' type.
* built-in numerics exact-integer non-positive::  The '<non-positive-exact-integer>' type.
* built-in numerics exact-integer non-negative::  The '<non-negative-exact-integer>' type.


File: vicare-typed.info,  Node: built-in numerics exact-integer base,  Next: built-in numerics exact-integer positive,  Up: built-in numerics exact-integer

6.13.9.1 The '<exact-integer>' type
...................................

 -- Core Type: <exact-integer>
 -- Parent Type: <integer>
     Type of exact integers.  There is no constructor.  The type
     predicate is 'exact-integer?'.

 -- Constructor on '<exact-integer>': <exact-integer> type-constructor
          OBJ
     Validate OBJ as object of type '<exact-integer>' and return it.

 -- Type predicate on '<exact-integer>': <boolean> type-predicate OBJ
     The type predicate is 'exact-integer?'.  Return '#t' if OBJ is a
     '<exact-integer>' object, otherwise return '#f'.

 -- Hash function on '<exact-integer>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'exact-integer-hash'.

Methods
.......

 -- Method on '<exact-integer>': <exact-integer> div THIS {N
          <exact-integer>}
     Apply 'div' to the arguments and return its return value.

 -- Method on '<exact-integer>': <exact-integer> mod THIS {N
          <exact-integer>}
     Apply 'mod' to the arguments and return its return value.

 -- Method on '<exact-integer>': <exact-integer> div-and-mod THIS {N
          <exact-integer>}
     Apply 'div-and-mod' to the arguments and return its return value.

 -- Method on '<exact-integer>': <exact-integer> div0 THIS {N
          <exact-integer>}
     Apply 'div0' to the arguments and return its return value.

 -- Method on '<exact-integer>': <exact-integer> mod0 THIS {N
          <exact-integer>}
     Apply 'mod0' to the arguments and return its return value.

 -- Method on '<exact-integer>': <exact-integer> div0-and-mod0 THIS {N
          <exact-integer>}
     Apply 'div0-and-mod0' to the arguments and return its return value.

 -- Method on '<exact-integer>': <exact-integer> exact-integer-sqrt THIS
          {N <exact-integer>}
     Apply 'exact-integer-sqrt' to the arguments and return its return
     value.


File: vicare-typed.info,  Node: built-in numerics exact-integer positive,  Next: built-in numerics exact-integer negative,  Prev: built-in numerics exact-integer base,  Up: built-in numerics exact-integer

6.13.9.2 The '<positive-exact-integer>' type
............................................

 -- Core Type: <positive-exact-integer>
     Type of positive exact integers.  Its definition is equivalent to:

          (define-type <positive-exact-integer>
            (or <positive-fixnum> <positive-bignum>))


File: vicare-typed.info,  Node: built-in numerics exact-integer negative,  Next: built-in numerics exact-integer non-zero,  Prev: built-in numerics exact-integer positive,  Up: built-in numerics exact-integer

6.13.9.3 The '<negative-exact-integer>' type
............................................

 -- Core Type: <negative-exact-integer>
     Type of negative exact integers.  Its definition is equivalent to:

          (define-type <negative-exact-integer>
            (or <negative-fixnum> <negative-bignum>))


File: vicare-typed.info,  Node: built-in numerics exact-integer non-zero,  Next: built-in numerics exact-integer non-positive,  Prev: built-in numerics exact-integer negative,  Up: built-in numerics exact-integer

6.13.9.4 The '<non-zero-exact-integer>' type
............................................

 -- Core Type: <non-zero-exact-integer>
     Type of non-zero exact integers.  Its definition is equivalent to:

          (define-type <non-zero-exact-integer>
            (or <non-zero-fixnum> <bignum>))


File: vicare-typed.info,  Node: built-in numerics exact-integer non-positive,  Next: built-in numerics exact-integer non-negative,  Prev: built-in numerics exact-integer non-zero,  Up: built-in numerics exact-integer

6.13.9.5 The '<non-positive-exact-integer>' type
................................................

 -- Core Type: <non-positive-exact-integer>
     Type of non-positive exact integers.  Its definition is equivalent
     to:

          (define-type <non-positive-exact-integer>
            (or <non-positive-fixnum> <negative-bignum>))


File: vicare-typed.info,  Node: built-in numerics exact-integer non-negative,  Prev: built-in numerics exact-integer non-positive,  Up: built-in numerics exact-integer

6.13.9.6 The '<non-negative-exact-integer>' type
................................................

 -- Core Type: <non-negative-exact-integer>
     Type of non-negative exact integers.  Its definition is equivalent
     to:

          (define-type <non-negative-exact-integer>
            (or <non-negative-fixnum> <positive-bignum>))


File: vicare-typed.info,  Node: built-in numerics fixnums,  Next: built-in numerics bignums,  Prev: built-in numerics exact-integer,  Up: built-in numerics

6.13.10 Type of fixnum values
-----------------------------

* Menu:

* built-in numerics fixnums base::          The '<fixnum>' type.
* built-in numerics fixnums positive::      The '<positive-fixnum>' type.
* built-in numerics fixnums negative::      The '<negative-fixnum>' type.
* built-in numerics fixnums zero::          The '<zero-fixnum>' type.
* built-in numerics fixnums non-positive::  The '<non-positive-fixnum>' type.
* built-in numerics fixnums non-negative::  The '<non-negative-fixnum>' type.
* built-in numerics fixnums non-zero::      The '<non-zero-fixnum>' type.


File: vicare-typed.info,  Node: built-in numerics fixnums base,  Next: built-in numerics fixnums positive,  Up: built-in numerics fixnums

6.13.10.1 The '<fixnum>' type
.............................

 -- Core Type: <fixnum>
 -- Parent Type: <exact-integer>
     Type of fixnum values.

 -- Constructor on '<fixnum>': <fixnum> type-constructor OBJ
     Validate OBJ as object of type '<fixnum>' and return it.

 -- Type predicate on '<fixnum>': <boolean> type-predicate OBJ
     The type predicate is 'fixnum?'.  Return '#t' if OBJ is a
     '<fixnum>' object, otherwise return '#f'.

 -- Hash function on '<fixnum>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'fixnum-hash'.


File: vicare-typed.info,  Node: built-in numerics fixnums positive,  Next: built-in numerics fixnums negative,  Prev: built-in numerics fixnums base,  Up: built-in numerics fixnums

6.13.10.2 The '<positive-fixnum>' type
......................................

 -- Core Type: <positive-fixnum>
 -- Parent Type: <fixnum>
     Type of positive fixnum values.

 -- Constructor on '<positive-fixnum>': <positive-fixnum>
          type-constructor OBJ
     Validate OBJ as object of type '<positive-fixnum>' and return it.

 -- Type predicate on '<positive-fixnum>': <boolean> type-predicate OBJ
     The type predicate is 'positive-fixnum?'.  Return '#t' if OBJ is a
     '<positive-fixnum>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics fixnums negative,  Next: built-in numerics fixnums zero,  Prev: built-in numerics fixnums positive,  Up: built-in numerics fixnums

6.13.10.3 The '<negative-fixnum>' type
......................................

 -- Core Type: <negative-fixnum>
 -- Parent Type: <fixnum>
     Type of negative fixnum values.

 -- Constructor on '<negative-fixnum>': <negative-fixnum>
          type-constructor OBJ
     Validate OBJ as object of type '<negative-fixnum>' and return it.

 -- Type predicate on '<negative-fixnum>': <boolean> type-predicate OBJ
     The type predicate is 'negative-fixnum?'.  Return '#t' if OBJ is a
     '<negative-fixnum>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics fixnums zero,  Next: built-in numerics fixnums non-positive,  Prev: built-in numerics fixnums negative,  Up: built-in numerics fixnums

6.13.10.4 The '<zero-fixnum>' type
..................................

 -- Core Type: <zero-fixnum>
 -- Parent Type: <fixnum>
     Type of the zero fixnum value.

 -- Constructor on '<zero-fixnum>': <zero-fixnum> type-constructor OBJ
     Validate OBJ as object of type '<zero-fixnum>' and return it.

 -- Type predicate on '<zero-fixnum>': <boolean> type-predicate OBJ
     The type predicate is 'zero-fixnum?'.  Return '#t' if OBJ is a
     '<zero-fixnum>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics fixnums non-positive,  Next: built-in numerics fixnums non-negative,  Prev: built-in numerics fixnums zero,  Up: built-in numerics fixnums

6.13.10.5 The '<non-positive-fixnum>' type
..........................................

 -- Core Type: <non-negative-fixnum>
     Type of non-negative fixnum values.  Its definition is equivalent
     to:

          (define-type <non-negative-fixnum>
            (or <zero-fixnum> <positive-fixnum>))


File: vicare-typed.info,  Node: built-in numerics fixnums non-negative,  Next: built-in numerics fixnums non-zero,  Prev: built-in numerics fixnums non-positive,  Up: built-in numerics fixnums

6.13.10.6 The '<non-negative-fixnum>' type
..........................................

 -- Core Type: <non-positive-fixnum>
     Type of non-positive fixnum values.  Its definition is equivalent
     to:

          (define-type <non-positive-fixnum>
            (or <zero-fixnum> <negative-fixnum>))


File: vicare-typed.info,  Node: built-in numerics fixnums non-zero,  Prev: built-in numerics fixnums non-negative,  Up: built-in numerics fixnums

6.13.10.7 The '<non-zero-fixnum>' type
......................................

 -- Core Type: <non-zero-fixnum>
     Type of non-zero fixnum values.  Its definition is equivalent to:

          (define-type <non-zero-fixnum>
            (or <positive-fixnum> <negative-fixnum>))


File: vicare-typed.info,  Node: built-in numerics bignums,  Next: built-in numerics flonums,  Prev: built-in numerics fixnums,  Up: built-in numerics

6.13.11 Type of bignum values
-----------------------------

* Menu:

* built-in numerics bignums base::      The '<bignum>' type.
* built-in numerics bignums positive::  The '<positive-bignum>' type.
* built-in numerics bignums negative::  The '<negative-bignum>' type.


File: vicare-typed.info,  Node: built-in numerics bignums base,  Next: built-in numerics bignums positive,  Up: built-in numerics bignums

6.13.11.1 The '<bignum>' type
.............................

 -- Core Type: <bignum>
 -- Parent Type: <exact-integer>
     Type of bignum values.  There is no constructor.  The type
     predicate is 'bignum?'.

 -- Constructor on '<bignum>': <bignum> type-constructor OBJ
     Validate OBJ as object of type '<bignum>' and return it.

 -- Type predicate on '<bignum>': <boolean> type-predicate OBJ
     The type predicate is 'bignum?'.  Return '#t' if OBJ is a
     '<bignum>' object, otherwise return '#f'.

 -- Hash function on '<bignum>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'bignum-hash'.

Methods
.......

 -- Method on '<bignum>': <bytevector> bytevector THIS
     Apply 'bignum->bytevector' to the instance and return its return
     value.

 -- Method on '<bignum>': <bytevector> odd? THIS
     Apply 'odd?' to the instance and return its return value.

 -- Method on '<bignum>': <bytevector> even? THIS
     Apply 'even?' to the instance and return its return value.


File: vicare-typed.info,  Node: built-in numerics bignums positive,  Next: built-in numerics bignums negative,  Prev: built-in numerics bignums base,  Up: built-in numerics bignums

6.13.11.2 The '<positive-bignum>' type
......................................

 -- Core Type: <positive-bignum>
 -- Parent Type: <bignum>
     Type of positive bignum values.

 -- Constructor on '<positive-bignum>': <positive-bignum>
          type-constructor OBJ
     Validate OBJ as object of type '<positive-bignum>' and return it.

 -- Type predicate on '<positive-bignum>': <boolean> type-predicate OBJ
     The type predicate is 'positive-bignum?'.  Return '#t' if OBJ is a
     '<positive-bignum>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics bignums negative,  Prev: built-in numerics bignums positive,  Up: built-in numerics bignums

6.13.11.3 The '<negative-bignum>' type
......................................

 -- Core Type: <negative-bignum>
 -- Parent Type: <bignum>
     Type of negative bignum values.

 -- Constructor on '<negative-bignum>': <negative-bignum>
          type-constructor OBJ
     Validate OBJ as object of type '<negative-bignum>' and return it.

 -- Type predicate on '<negative-bignum>': <boolean> type-predicate OBJ
     The type predicate is 'negative-bignum?'.  Return '#t' if OBJ is a
     '<negative-bignum>' object, otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics flonums,  Next: built-in numerics ratnums,  Prev: built-in numerics bignums,  Up: built-in numerics

6.13.12 Type of flonum values
-----------------------------

* Menu:

* built-in numerics flonums base::          The '<flonum>' type.
* built-in numerics flonums zero::          The '<zero-flonum>' type.
* built-in numerics flonums positive-zero:: The '<positive-zero-flonum>' type.
* built-in numerics flonums negative-zero:: The '<negative-zero-flonum>' type.
* built-in numerics flonums non-zero::      The '<non-zero-flonum>' type.
* built-in numerics flonums positive::      The '<positive-flonum>' type.
* built-in numerics flonums negative::      The '<negative-flonum>' type.
* built-in numerics flonums non-positive::  The '<non-positive-flonum>' type.
* built-in numerics flonums non-negative::  The '<non-negative-flonum>' type.


File: vicare-typed.info,  Node: built-in numerics flonums base,  Next: built-in numerics flonums zero,  Up: built-in numerics flonums

6.13.12.1 The '<flonum>' type
.............................

 -- Core Type: <flonum>
 -- Parent Type: <real>
     Type of flonum values.

 -- Constructor on '<flonum>': <flonum> type-constructor OBJ
     Validate OBJ as object of type '<flonum>'.  Return OBJ itself.

 -- Type predicate on '<flonum>': <boolean> type-predicate OBJ
     The type predicate is 'flonum?'.  Return '#t' if OBJ is an object
     of type '<flonum>'; otherwise return '#f'.

 -- Hash function on '<flonum>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'flonum-hash'.


File: vicare-typed.info,  Node: built-in numerics flonums zero,  Next: built-in numerics flonums positive-zero,  Prev: built-in numerics flonums base,  Up: built-in numerics flonums

6.13.12.2 The '<zero-flonum>' type
..................................

 -- Core Type: <zero-flonum>
 -- Parent Type: <flonum>
     Type of zero flonum values: '+0.0' and '-0.0'.

 -- Constructor on '<zero-flonum>': <zero-flonum> type-constructor OBJ
     Validate OBJ as object of type '<zero-flonum>'.  Return OBJ itself.

 -- Type predicate on '<zero-flonum>': <boolean> type-predicate OBJ
     The type predicate is 'zero-flonum?'.  Return '#t' if OBJ is an
     object of type '<zero-flonum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics flonums positive-zero,  Next: built-in numerics flonums negative-zero,  Prev: built-in numerics flonums zero,  Up: built-in numerics flonums

6.13.12.3 The '<positive-zero-flonum>' type
...........................................

 -- Core Type: <positive-zero-flonum>
 -- Parent Type: <zero-flonum>
     Type of positive zero flonum values: '+0.0'.

 -- Constructor on '<positive-zero-flonum>': <positive-zero-flonum>
          type-constructor OBJ
     Validate OBJ as object of type '<positive-zero-flonum>'.  Return
     OBJ itself.

 -- Type predicate on '<positive-zero-flonum>': <boolean> type-predicate
          OBJ
     The type predicate is 'positive-zero-flonum?'.  Return '#t' if OBJ
     is an object of type '<positive-zero-flonum>'; otherwise return
     '#f'.


File: vicare-typed.info,  Node: built-in numerics flonums negative-zero,  Next: built-in numerics flonums non-zero,  Prev: built-in numerics flonums positive-zero,  Up: built-in numerics flonums

6.13.12.4 The '<negative-zero-flonum>' type
...........................................

 -- Core Type: <negative-zero-flonum>
 -- Parent Type: <zero-flonum>
     Type of negative zero flonum values: '-0.0'.

 -- Constructor on '<negative-zero-flonum>': <negative-zero-flonum>
          type-constructor OBJ
     Validate OBJ as object of type '<negative-zero-flonum>'.  Return
     OBJ itself.

 -- Type predicate on '<negative-zero-flonum>': <boolean> type-predicate
          OBJ
     The type predicate is 'negative-zero-flonum?'.  Return '#t' if OBJ
     is an object of type '<negative-zero-flonum>'; otherwise return
     '#f'.


File: vicare-typed.info,  Node: built-in numerics flonums non-zero,  Next: built-in numerics flonums positive,  Prev: built-in numerics flonums negative-zero,  Up: built-in numerics flonums

6.13.12.5 The '<non-zero-flonum>' type
......................................

 -- Core Type: <non-zero-flonum>
     Type of non-zero flonum values.  The definition is equivalent to:

          (define-type <non-zero-flonum>
            (or <positive-flonum> <negative-flonum>))


File: vicare-typed.info,  Node: built-in numerics flonums positive,  Next: built-in numerics flonums negative,  Prev: built-in numerics flonums non-zero,  Up: built-in numerics flonums

6.13.12.6 The '<positive-flonum>' type
......................................

 -- Core Type: <positive-flonum>
 -- Parent Type: <flonum>
     Type of positive flonum values, *excluding* the positive zero
     '+0.0'.

 -- Constructor on '<positive-flonum>': <positive-flonum>
          type-constructor OBJ
     Validate OBJ as object of type '<positive-flonum>'.  Return OBJ
     itself.

 -- Type predicate on '<positive-flonum>': <boolean> type-predicate OBJ
     The type predicate is 'positive-flonum?'.  Return '#t' if OBJ is an
     object of type '<positive-flonum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics flonums negative,  Next: built-in numerics flonums non-positive,  Prev: built-in numerics flonums positive,  Up: built-in numerics flonums

6.13.12.7 The '<negative-flonum>' type
......................................

 -- Core Type: <negative-flonum>
 -- Parent Type: <flonum>
     Type of negative flonum values, *excluding* the negative zero
     '-0.0'.

 -- Constructor on '<negative-flonum>': <negative-flonum>
          type-constructor OBJ
     Validate OBJ as object of type '<negative-flonum>'.  Return OBJ
     itself.

 -- Type predicate on '<negative-flonum>': <boolean> type-predicate OBJ
     The type predicate is 'positive-flonum?'.  Return '#t' if OBJ is an
     object of type '<negative-flonum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics flonums non-positive,  Next: built-in numerics flonums non-negative,  Prev: built-in numerics flonums negative,  Up: built-in numerics flonums

6.13.12.8 The '<non-positive-flonum>' type
..........................................

 -- Core Type: <non-positive-flonum>
 -- Parent Type: <flonum>
     Type of non-positive flonum values.  This type definition is
     equivalent to:

          (define-type <non-positive-flonum>
            (or <negative-flonum> <zero-flonum>))


File: vicare-typed.info,  Node: built-in numerics flonums non-negative,  Prev: built-in numerics flonums non-positive,  Up: built-in numerics flonums

6.13.12.9 The '<non-negative-flonum>' type
..........................................

 -- Core Type: <non-negative-flonum>
 -- Parent Type: <flonum>
     Type of non-negative flonum values.  This type definition is
     equivalent to:

          (define-type <non-negative-flonum>
            (or <positive-flonum> <zero-flonum>))


File: vicare-typed.info,  Node: built-in numerics ratnums,  Next: built-in numerics compnums,  Prev: built-in numerics flonums,  Up: built-in numerics

6.13.13 Type of ratnum values
-----------------------------

* Menu:

* built-in numerics ratnums base::      The '<ratnum>' type.
* built-in numerics ratnums positive::  The '<positive-ratnum>' type.
* built-in numerics ratnums negative::  The '<negative-ratnum>' type.


File: vicare-typed.info,  Node: built-in numerics ratnums base,  Next: built-in numerics ratnums positive,  Up: built-in numerics ratnums

6.13.13.1 The '<ratnum>' type
.............................

 -- Core Type: <ratnum>
 -- Parent Type: <rational>
     Type of ratnum values.

 -- Constructor on '<ratnum>': <ratnum> type-constructor OBJ
     Validate OBJ as object of type '<ratnum>'.  Return OBJ itself.

 -- Type predicate on '<ratnum>': <boolean> type-predicate OBJ
     The type predicate is 'ratnum?'.  Return '#t' if OBJ is an object
     of type '<ratnum>'; otherwise return '#f'.

 -- Hash function on '<ratnum>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'ratnum-hash'.


File: vicare-typed.info,  Node: built-in numerics ratnums positive,  Next: built-in numerics ratnums negative,  Prev: built-in numerics ratnums base,  Up: built-in numerics ratnums

6.13.13.2 The '<positive-ratnum>' type
......................................

 -- Core Type: <positive-ratnum>
 -- Parent Type: <ratnum>
     Type of positive ratnum values.

 -- Constructor on '<positive-ratnum>': <positive-ratnum>
          type-constructor OBJ
     Validate OBJ as object of type '<positive-ratnum>'.  Return OBJ
     itself.

 -- Type predicate on '<positive-ratnum>': <boolean> type-predicate OBJ
     The type predicate is 'positive-ratnum?'.  Return '#t' if OBJ is an
     object of type '<positive-ratnum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics ratnums negative,  Prev: built-in numerics ratnums positive,  Up: built-in numerics ratnums

6.13.13.3 The '<negative-ratnum>' type
......................................

 -- Core Type: <negative-ratnum>
 -- Parent Type: <ratnum>
     Type of negative ratnum values.

 -- Constructor on '<negative-ratnum>': <negative-ratnum>
          type-constructor OBJ
     Validate OBJ as object of type '<negative-ratnum>'.  Return OBJ
     itself.

 -- Type predicate on '<negative-ratnum>': <boolean> type-predicate OBJ
     The type predicate is 'negative-ratnum?'.  Return '#t' if OBJ is an
     object of type '<negative-ratnum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics compnums,  Next: built-in numerics cflonums,  Prev: built-in numerics ratnums,  Up: built-in numerics

6.13.14 Type of compnum values
------------------------------

* Menu:

* built-in numerics compnums base::     The '<compnum>' type.
* built-in numerics compnums exact::    The '<exact-compnum>' type.
* built-in numerics compnums inexact::  The '<inexact-compnum>' type.
* built-in numerics compnums zero::     The '<zero-compnum>' type.
* built-in numerics compnums non-zero-inexact::  The '<non-zero-inexact-compnum>' type.
* built-in numerics compnums non-zero:: The '<non-zero-compnum>' type.


File: vicare-typed.info,  Node: built-in numerics compnums base,  Next: built-in numerics compnums exact,  Up: built-in numerics compnums

6.13.14.1 The '<compnum>' type
..............................

 -- Core Type: <compnum>
 -- Parent Type: <complex>
     Type of compnum values.

 -- Constructor on '<compnum>': <compnum> type-constructor OBJ
     Validate OBJ as object of type '<compnum>'.  Return OBJ itself.

 -- Type predicate on '<compnum>': <boolean> type-predicate OBJ
     The type predicate is 'compnum?'.  Return '#t' if OBJ is an object
     of type '<compnum>'; otherwise return '#f'.

 -- Hash function on '<compnum>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'compnum-hash'.


File: vicare-typed.info,  Node: built-in numerics compnums exact,  Next: built-in numerics compnums inexact,  Prev: built-in numerics compnums base,  Up: built-in numerics compnums

6.13.14.2 The '<exact-compnum>' type
....................................

 -- Core Type: <exact-compnum>
 -- Parent Type: <compnum>
     Type of compnum values having exact real and imaginary parts.

     Remembering that a compnum with exact zero as imaginary part is
     converted to a real number by the Scheme reader and the function
     'make-rectangular':

          1+0i                            => 1
          1.0+0i                          => 1.0
          (make-rectangular 1 0)          => 1
          (make-rectangular 1.0 0)        => 1.0

     it follows that a value of type '<exact-compnum>' *cannot* be zero.

 -- Constructor on '<exact-compnum>': <exact-compnum> type-constructor
          OBJ
     Validate OBJ as object of type '<exact-compnum>'.  Return OBJ
     itself.

 -- Type predicate on '<exact-compnum>': <boolean> type-predicate OBJ
     The type predicate is 'exact-compnum?'.  Return '#t' if OBJ is an
     object of type '<exact-compnum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics compnums inexact,  Next: built-in numerics compnums zero,  Prev: built-in numerics compnums exact,  Up: built-in numerics compnums

6.13.14.3 The '<inexact-compnum>' type
......................................

 -- Core Type: <inexact-compnum>
 -- Parent Type: <compnum>
     Type of compnum values having inexact real or imaginary parts.

          *NOTE* We need to remember that if a value is a compnum: only
          one among the real and imaginary parts is inexact.  If both
          are inexact: it is not a compnum, it is a cflonum.

 -- Constructor on '<inexact-compnum>': <inexact-compnum>
          type-constructor OBJ
     Validate OBJ as object of type '<inexact-compnum>'.  Return OBJ
     itself.

 -- Type predicate on '<inexact-compnum>': <boolean> type-predicate OBJ
     The type predicate is 'inexact-compnum?'.  Return '#t' if OBJ is an
     object of type '<inexact-compnum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics compnums zero,  Next: built-in numerics compnums non-zero-inexact,  Prev: built-in numerics compnums inexact,  Up: built-in numerics compnums

6.13.14.4 The '<zero-compnum>' type
...................................

 -- Core Type: <zero-compnum>
 -- Parent Type: <inexact-compnum>
     Type of compnum values having both the real part and imaginary part
     equal to zero.

     Remembering that a compnum with exact zero as imaginary part is
     converted to a real number by the Scheme reader and the function
     'make-rectangular':

          1+0i                            => 1
          1.0+0i                          => 1.0
          (make-rectangular 1 0)          => 1
          (make-rectangular 1.0 0)        => 1.0

     the compnums of type '<zero-compnum>' are '0+0.0i' and '0-0.0i'
     with the imaginary part always inexact.

          *NOTE* We need to remember that if a value is a compnum: only
          one among the real and imaginary parts is inexact.  If both
          are inexact: it is not a compnum, it is a cflonum.

 -- Constructor on '<zero-compnum>': <zero-compnum> type-constructor OBJ
     Validate OBJ as object of type '<zero-compnum>'.  Return OBJ
     itself.

 -- Type predicate on '<zero-compnum>': <boolean> type-predicate OBJ
     The type predicate is 'zero-compnum?'.  Return '#t' if OBJ is an
     object of type '<zero-compnum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics compnums non-zero-inexact,  Next: built-in numerics compnums non-zero,  Prev: built-in numerics compnums zero,  Up: built-in numerics compnums

6.13.14.5 The '<non-zero-inexact-compnum>' type
...............................................

 -- Core Type: <non-zero-inexact-compnum>
 -- Parent Type: <inexact-compnum>
     Type of inexact compnum values having either the real part or
     imaginary part different from zero.

 -- Constructor on '<non-zero-inexact-compnum>':
          <non-zero-inexact-compnum> type-constructor OBJ
     Validate OBJ as object of type '<non-zero-inexact-compnum>'.
     Return OBJ itself.

 -- Type predicate on '<non-zero-inexact-compnum>': <boolean>
          type-predicate OBJ
     The type predicate is 'non-zero-inexact-compnum?'.  Return '#t' if
     OBJ is an object of type '<non-zero-inexact-compnum>'; otherwise
     return '#f'.


File: vicare-typed.info,  Node: built-in numerics compnums non-zero,  Prev: built-in numerics compnums non-zero-inexact,  Up: built-in numerics compnums

6.13.14.6 The '<non-zero-compnum>' type
.......................................

 -- Core Type: <non-zero-compnum>
     Type of compnum values having either the real part or imaginary
     part different from zero.  Its definition is equivalent to:

          (define-type <non-zero-compnum>
            (or <exact-compnum> <non-zero-inexact-compnum>))


File: vicare-typed.info,  Node: built-in numerics cflonums,  Next: built-in numerics bytes,  Prev: built-in numerics compnums,  Up: built-in numerics

6.13.15 Type of cflonum values
------------------------------

* Menu:

* built-in numerics cflonums base::     The '<cflonum>' type.
* built-in numerics cflonums zero::     The '<zero-cflonum>' type.
* built-in numerics cflonums non-zero:: The '<non-zero-cflonum>' type.


File: vicare-typed.info,  Node: built-in numerics cflonums base,  Next: built-in numerics cflonums zero,  Up: built-in numerics cflonums

6.13.15.1 The '<cflonum>' type
..............................

 -- Core Type: <cflonum>
 -- Parent Type: <complex>
     Type of cflonum values.

 -- Constructor on '<cflonum>': <cflonum> type-constructor OBJ
     Validate OBJ as object of type '<cflonum>'.  Return OBJ itself.

 -- Type predicate on '<cflonum>': <boolean> type-predicate OBJ
     The type predicate is 'cflonum?'.  Return '#t' if OBJ is an object
     of type '<cflonum>'; otherwise return '#f'.

 -- Hash function on '<cflonum>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'cflonum-hash'.


File: vicare-typed.info,  Node: built-in numerics cflonums zero,  Next: built-in numerics cflonums non-zero,  Prev: built-in numerics cflonums base,  Up: built-in numerics cflonums

6.13.15.2 The '<zero-cflonum>' type
...................................

 -- Core Type: <zero-cflonum>
 -- Parent Type: <cflonum>
     Type of cflonum values having both the real part and imaginary part
     equal to zero.  Such values are the following:

          +0.0+0.0i       +0.0-0.0i
          -0.0+0.0i       -0.0-0.0i

 -- Constructor on '<zero-cflonum>': <zero-cflonum> type-constructor OBJ
     Validate OBJ as object of type '<zero-cflonum>'.  Return OBJ
     itself.

 -- Type predicate on '<zero-cflonum>': <boolean> type-predicate OBJ
     The type predicate is 'zero-cflonum?'.  Return '#t' if OBJ is an
     object of type '<zero-cflonum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics cflonums non-zero,  Prev: built-in numerics cflonums zero,  Up: built-in numerics cflonums

6.13.15.3 The '<non-zero-cflonum>' type
.......................................

 -- Core Type: <non-zero-cflonum>
 -- Parent Type: <cflonum>
     Type of cflonum values having either the real part or imaginary
     part different from zero.

 -- Constructor on '<non-zero-cflonum>': <non-zero-cflonum>
          type-constructor OBJ
     Validate OBJ as object of type '<non-zero-cflonum>'.  Return OBJ
     itself.

 -- Type predicate on '<non-zero-cflonum>': <boolean> type-predicate OBJ
     The type predicate is 'non-zero-cflonum?'.  Return '#t' if OBJ is
     an object of type '<non-zero-cflonum>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics bytes,  Next: built-in numerics octets,  Prev: built-in numerics cflonums,  Up: built-in numerics

6.13.16 The '<byte>' type
-------------------------

* Menu:

* built-in numerics bytes base::          The '<byte>' type.
* built-in numerics bytes zero::          The '<zero-byte>' type.
* built-in numerics bytes positive::      The '<positive-byte>' type.
* built-in numerics bytes negative::      The '<negative-byte>' type.
* built-in numerics bytes non-positive::  The '<non-positive-byte>' type.
* built-in numerics bytes non-negative::  The '<non-negative-byte>' type.


File: vicare-typed.info,  Node: built-in numerics bytes base,  Next: built-in numerics bytes zero,  Up: built-in numerics bytes

6.13.16.1 The '<byte>' type
...........................

 -- Label Type: '<byte>'
 -- Parent Type: <fixnum>
     Type of byte values.  A "byte" is a fixnum in the range [-128,
     127].

 -- Constructor on '<byte>': <byte> type-constructor OBJ
     Validate OBJ as object of type '<byte>'.  Return OBJ itself.

 -- Type predicate on '<byte>': <boolean> type-predicate OBJ
     The type predicate is 'byte-fixnum?'.  Return '#t' if OBJ is an
     object of type '<byte>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics bytes zero,  Next: built-in numerics bytes positive,  Prev: built-in numerics bytes base,  Up: built-in numerics bytes

6.13.16.2 The '<zero-byte>' type
................................

 -- Label Type: '<zero-byte>'
 -- Parent Type: <byte>
     Type of zero byte values.

 -- Constructor on '<zero-byte>': <zero-byte> type-constructor OBJ
     Validate OBJ as object of type '<zero-byte>'.  Return OBJ itself.

 -- Type predicate on '<zero-byte>': <boolean> type-predicate OBJ
     The type predicate is 'zero-byte-fixnum?'.  Return '#t' if OBJ is
     an object of type '<zero-byte>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics bytes positive,  Next: built-in numerics bytes negative,  Prev: built-in numerics bytes zero,  Up: built-in numerics bytes

6.13.16.3 The '<positive-byte>' type
....................................

 -- Label Type: '<positive-byte>'
 -- Parent Type: <byte>
     Type of positive byte values.

 -- Constructor on '<positive-byte>': <positive-byte> type-constructor
          OBJ
     Validate OBJ as object of type '<positive-byte>'.  Return OBJ
     itself.

 -- Type predicate on '<positive-byte>': <boolean> type-predicate OBJ
     The type predicate is 'positive-byte-fixnum?'.  Return '#t' if OBJ
     is an object of type '<positive-byte>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics bytes negative,  Next: built-in numerics bytes non-positive,  Prev: built-in numerics bytes positive,  Up: built-in numerics bytes

6.13.16.4 The '<negative-byte>' type
....................................

 -- Label Type: '<negative-byte>'
 -- Parent Type: <byte>
     Type of negative byte values.

 -- Constructor on '<negative-byte>': <negative-byte> type-constructor
          OBJ
     Validate OBJ as object of type '<negative-byte>'.  Return OBJ
     itself.

 -- Type predicate on '<negative-byte>': <boolean> type-predicate OBJ
     The type predicate is 'zero-byte-fixnum?'.  Return '#t' if OBJ is
     an object of type '<negative-byte>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics bytes non-positive,  Next: built-in numerics bytes non-negative,  Prev: built-in numerics bytes negative,  Up: built-in numerics bytes

6.13.16.5 The '<non-positive-byte>' type
........................................

 -- Core Type: '<non-positive-byte>'
     Type of non-positive byte values.  Its definition is equivalent to:

          (define-type <non-positive-byte>
            (or <zero-byte> <negative-byte>))


File: vicare-typed.info,  Node: built-in numerics bytes non-negative,  Prev: built-in numerics bytes non-positive,  Up: built-in numerics bytes

6.13.16.6 The '<non-negative-byte>' type
........................................

 -- Core Type: '<non-negative-byte>'
     Type of non-negative byte values.  Its definition is equivalent to:

          (define-type <non-negative-byte>
            (or <zero-byte> <positive-byte>))


File: vicare-typed.info,  Node: built-in numerics octets,  Next: built-in numerics exactness,  Prev: built-in numerics bytes,  Up: built-in numerics

6.13.17 The '<octet>' type
--------------------------

* Menu:

* built-in numerics octets base::       The '<octet>' type.
* built-in numerics octets zero::       The '<zero-octet>' type.
* built-in numerics octets positive::   The '<positive-octet>' type.


File: vicare-typed.info,  Node: built-in numerics octets base,  Next: built-in numerics octets zero,  Up: built-in numerics octets

6.13.17.1 The '<octet>' type
............................

 -- Label Type: '<octet>'
 -- Parent Type: <non-negative-fixnum>
     Type of octet values.  An "octet" is a fixnum in the range [0,
     255].

 -- Constructor on '<octet>': <octet> type-constructor OBJ
     Validate OBJ as object of type '<octet>'.  Return OBJ itself.

 -- Type predicate on '<octet>': <boolean> type-predicate OBJ
     The type predicate is 'octet-fixnum?'.  Return '#t' if OBJ is an
     object of type '<octet>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics octets zero,  Next: built-in numerics octets positive,  Prev: built-in numerics octets base,  Up: built-in numerics octets

6.13.17.2 The '<zero-octet>' type
.................................

 -- Label Type: '<zero-octet>'
 -- Parent Type: <octet>
     Type of zero octet values.

 -- Constructor on '<zero-octet>': <zero-octet> type-constructor OBJ
     Validate OBJ as object of type '<zero-octet>'.  Return OBJ itself.

 -- Type predicate on '<zero-octet>': <boolean> type-predicate OBJ
     The type predicate is 'zero-octet-fixnum?'.  Return '#t' if OBJ is
     an object of type '<zero-octet>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics octets positive,  Prev: built-in numerics octets zero,  Up: built-in numerics octets

6.13.17.3 The '<positive-octet>' type
.....................................

 -- Label Type: '<positive-octet>'
 -- Parent Type: <non-negative-fixnum>
     Type of positive octet values.

 -- Constructor on '<positive-octet>': <positive-octet> type-constructor
          OBJ
     Validate OBJ as object of type '<positive-octet>'.  Return OBJ
     itself.

 -- Type predicate on '<positive-octet>': <boolean> type-predicate OBJ
     The type predicate is 'positive-octet-fixnum?'.  Return '#t' if OBJ
     is an object of type '<positive-octet>'; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in numerics exactness,  Next: built-in numerics sign,  Prev: built-in numerics octets,  Up: built-in numerics

6.13.18 Exactness of values
---------------------------

 -- Core Type: '<exact>'
     Type of exact numeric values.  Its definition is equivalent to:

          (define-type <exact>
            (or <exact-rational> <exact-compnum>))

 -- Core Type: '<inexact>'
     Type of inexact numeric values.  Its definition is equivalent to:

          (define-type <inexact>
            (or <flonum> <cflonum> <inexact-compnum>))


File: vicare-typed.info,  Node: built-in numerics sign,  Prev: built-in numerics exactness,  Up: built-in numerics

6.13.19 Sign of numeric values
------------------------------

 -- Core Type: '<positive>'
     Type of positive numeric values.  Its definition is equivalent to:

          (define-type <positive>
            (or <positive-fixnum> <positive-bignum>
                <positive-ratnum> <positive-flonum>))

 -- Core Type: '<negative>'
     Type of negative numeric values.  Its definition is equivalent to:

          (define-type <negative>
            (or <negative-fixnum> <negative-bignum>
                <negative-ratnum> <negative-flonum>))

 -- Core Type: '<non-negative>'
     Type of non-negative numeric values.  Its definition is equivalent
     to:

          (define-type <non-negative>
            (or <non-negative-fixnum> <positive-bignum> <positive-ratnum>
                <positive-flonum> <positive-zero-flonum>))

 -- Core Type: '<non-positive>'
     Type of non-positive numeric values.  Its definition is equivalent
     to:

          (define-type <non-positive>
            (or <non-positive-fixnum> <negative-bignum> <negative-ratnum>
                <negative-flonum> <negative-zero-flonum>))

 -- Core Type: '<zero>'
     Type of zero numeric values.  Its definition is equivalent to:

          (define-type <zero>
            (or <zero-fixnum>  <zero-flonum>
                <zero-compnum> <zero-cflonum>))


File: vicare-typed.info,  Node: built-in strings,  Next: built-in vectors,  Prev: built-in numerics,  Up: built-in

6.14 Type of string values
==========================

* Menu:

* built-in strings base::         Base string type.
* built-in strings empty::        Empty string type.
* built-in strings non-empty::    Non-empty string type.


File: vicare-typed.info,  Node: built-in strings base,  Next: built-in strings empty,  Up: built-in strings

6.14.1 Base string type
-----------------------

 -- Core Type: '<string>'
 -- Parent Type: <top>
     Type of string values.

 -- Constructor on '<string>': <string> type-constructor {CH <char>} ...
     The constructor is 'string'.

 -- Type predicate on '<string>': <boolean> type-predicate OBJ
     The type predicate is 'string?'.  Return '#t' if OBJ is a string
     object; otherwise return '#f'.

 -- Equality predicate on '<string>': <boolean> equality-predicate THIS
          {STR <string>}
     The equality predicate is 'string=?'.

 -- Comparison procedure on '<string>': <fixnum> comparison-procedure
          THIS {STR <string>}
     The comparison procedure is 'compar-string'.

 -- Hash function on '<string>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'string-hash'.

Inspection
..........

 -- Method on '<string>': <boolean> empty? THIS
     Apply 'string-empty?' to the instance.

 -- Method on <string>: <non-negative-fixnum> length THIS
     Apply 'string-length' to the instance.

 -- Method on <string>: () for-each THIS FUNC STR ...
     Apply 'string-for-each' to the function FUNC, the instance and the
     arguments.  Example:

          (.for-each "ciao" display)

Constructors
............

 -- Method on <string>: <string> copy THIS
     Apply 'string-copy' to the instance and return its return value.

 -- Method on <string>: <string> append THIS {STR <string>} ...
     Apply 'string-append' to the arguments and return its return value.

Accessors and mutators
......................

 -- Method on <string>: <string> fill! THIS CHAR
     Apply 'string-fill!' to the instance.

Encoding inspection
...................

 -- Method on <string>: <boolean> ascii-encoded? THIS
     Apply 'ascii-encoded-string?' to the instance.

 -- Method on <string>: <boolean> latin1-encoded? THIS
     Apply 'latin1-encoded-string?' to the instance.

 -- Method on <string>: <boolean> octets-encoded? THIS
     Apply 'octets-encoded-string?' to the instance.

 -- Method on <string>: <boolean> uri-encoded? THIS
     Apply 'uri-encoded-string?' to the instance.

 -- Method on <string>: <boolean> pencent-encoded? THIS
     Apply 'percent-encoded-string?' to the instance.

Comparison
..........

 -- Method on <string>: <boolean> = THIS STR ...
 -- Method on <string>: <boolean> != THIS STR ...
 -- Method on <string>: <boolean> < THIS STR ...
 -- Method on <string>: <boolean> > THIS STR ...
 -- Method on <string>: <boolean> <= THIS STR ...
 -- Method on <string>: <boolean> >= THIS STR ...
     Apply 'string=?', 'string!=?', 'string<?', 'string>?', 'string<=?',
     'string>=?' to the instance and the arguments and return its return
     value.

 -- Method on <string>: <boolean> ci= THIS STR ...
 -- Method on <string>: <boolean> ci< THIS STR ...
 -- Method on <string>: <boolean> ci> THIS STR ...
 -- Method on <string>: <boolean> ci<= THIS STR ...
 -- Method on <string>: <boolean> ci>= THIS STR ...
     Apply 'string-ci=?', 'string-ci<?', 'string-ci>?', 'string-ci<=?',
     'string-ci>=?', to the instance and the arguments and return its
     return value.

Case handling
.............

 -- Method on <string>: <string> titlecase THIS
     Apply 'string-titlecase' to the instance.

 -- Method on <string>: <string> upcase THIS
     Apply 'string-upcase' to the instance.

 -- Method on <string>: <string> downcase THIS
     Apply 'string-downcase' to the instance.

 -- Method on <string>: <string> foldcase THIS
     Apply 'string-foldcase' to the instance.

Normalisation
.............

 -- Method on <string>: <string> normalize-nfc THIS
     Apply 'string-normalize-nfc' to the instance.

 -- Method on <string>: <string> normalize-nfd THIS
     Apply 'string-normalize-nfd' to the instance.

 -- Method on <string>: <string> normalize-nfkc THIS
     Apply 'string-normalize-nfkc' to the instance.

 -- Method on <string>: <string> normalize-nfkd THIS
     Apply 'string-normalize-nfkd' to the instance.

Conversion
..........

 -- Method on <string>: <flonum> flonum THIS
     Apply 'string->flonum' to the instance.

 -- Method on <string>: <number> number THIS
 -- Method on <string>: <number> number THIS RADIX
     Apply 'string->number' to the instance and the argument.

 -- Method on <string>: <bytevector> utf8 THIS
     Apply 'string->utf8' to the instance.

 -- Method on <string>: <bytevector> utf16 THIS
 -- Method on <string>: <bytevector> utf16 THIS ENDIANNESS
     Apply 'string->utf16' to the instance and the argument.

 -- Method on <string>: <bytevector> utf16be THIS
     Apply 'string->utf16be' to the instance.

 -- Method on <string>: <bytevector> utf16le THIS
     Apply 'string->utf16le' to the instance.

 -- Method on <string>: <bytevector> utf16n THIS
     Apply 'string->utf16n' to the instance.

 -- Method on <string>: <bytevector> utf32 THIS
 -- Method on <string>: <bytevector> utf32 THIS ENDIANNESS
     Apply 'string->utf32' to the instance and the argument.

 -- Method on <string>: <bytevector> bytevector THIS
 -- Method on <string>: <bytevector> bytevector THIS TRANSCODER
     Apply 'string->bytevector' to the instance and the argument.

 -- Method on <string>: <bytevector> ascii THIS
     Apply 'string->ascii' to the instance.

 -- Method on <string>: <bytevector> latin1 THIS
     Apply 'string->latin1' to the instance.

 -- Method on <string>: <bytevector> octets THIS
     Apply 'string->octets' to the instance.

 -- Method on <string>: <bytevector> percent-encoding THIS
     Apply 'string->percent-encoding' to the instance.

 -- Method on <string>: <bytevector> uri-encoding THIS
     Apply 'string->uri-encoding' to the instance.

 -- Method on <string>: <bytevector> base64->bytevector THIS
     Apply 'string-base64->bytevector' to the instance.

 -- Method on <string>: <bytevector> hex->bytevector THIS
     Apply 'string-hex->bytevector' to the instance.

 -- Method on <string>: <symbol> symbol THIS
     Apply 'string->symbol' to the instance.

 -- Method on <string>: <keyword> keyword THIS
     Apply 'string->keyword' to the instance.

 -- Method on <string>: (list-of <char>) list THIS
     Apply 'string->list' to the instance.


File: vicare-typed.info,  Node: built-in strings empty,  Next: built-in strings non-empty,  Prev: built-in strings base,  Up: built-in strings

6.14.2 Empty string type
------------------------

 -- Core Type: <empty-string>
 -- Parent Type: <string>
     Type of empty string values.

 -- Constructor on '<empty-string>': <empty-string> type-constructor
     Build and return an empty string.

 -- Type predicate on '<empty-string>': <boolean> type-predicate OBJ
     The type predicate is 'empty-string?'.  Return '#t' if OBJ is a
     '<empty-string>' object; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in strings non-empty,  Prev: built-in strings empty,  Up: built-in strings

6.14.3 Non-empty string type
----------------------------

 -- Core Type: <nestring>
 -- Parent Type: <string>
     Type of non-empty string values.

 -- Constructor on '<nestring>': <nestring> type-constructor {CH0
          <char>} {CH <char>} ...
     Build and return a non-empty string.

 -- Type predicate on '<nestring>': <boolean> type-predicate OBJ
     The type predicate is 'empty-string?'.  Return '#t' if OBJ is a
     '<nestring>' object; otherwise return '#f'.

Accessors and mutators
......................

 -- Method on '<nestring>': <char> ref THIS {IDX <non-negative-fixnum>}
     Apply 'string-ref' to the instance and the argument.

 -- Method on '<nestring>': <void> set! THIS {IDX <non-negative-fixnum>}
          {CH <char>}
     Apply 'string-set!' to the instance and the arguments.


File: vicare-typed.info,  Node: built-in vectors,  Next: built-in lists,  Prev: built-in strings,  Up: built-in

6.15 Type of vector values
==========================

* Menu:

* built-in vectors base::         Base vector type.
* built-in vectors empty::        Empty vector type.
* built-in vectors non-empty::    Non-empty vector type.


File: vicare-typed.info,  Node: built-in vectors base,  Next: built-in vectors empty,  Up: built-in vectors

6.15.1 Base vector type
-----------------------

 -- Core Type: <vector>
 -- Parent Type: <top>
     Type of vector values.

 -- Constructor on '<vector>': <vector> type-constructor OBJ ...
     The constructor is 'vector'.

 -- Type predicate on '<vector>': <boolean> type-predicate OBJ
     The type predicate is 'vector?'.  Return '#t' if OBJ is a vector
     object; otherwise return '#f'.

 -- Equality predicate on '<vector>': <boolean> equality-predicate THIS
          {VEC <vector>}
     The equality predicate is 'equal?'.

 -- Hash function on '<vector>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'vector-hash'.

Inspection
..........

 -- Method on '<vector>': <non-negative-fixnum> length THIS
     Apply 'vector-length' to the instance.

Accessors and mutators
......................

 -- Method on '<vector>': <void> fill! THIS OBJ
     Apply 'vector-fill!' to the instance and the argument.

Other constructors
..................

 -- Method on '<vector>': <vector> subvector THIS BEGIN END
     Apply 'subvector' to the instance and the arguments.

 -- Method on '<vector>': <vector> append THIS VEC ...
     Apply 'vector-append' to the instance and the arguments.

 -- Method on '<vector>': <vector> resize THIS NEW-LENGTH
 -- Method on '<vector>': <vector> resize THIS NEW-LENGTH FILL
     Apply 'vector-resize' to the instance and the arguments.

Iteration and searching
.......................

 -- Method on '<vector>': <vector> map THIS PROC VEC ...
     Apply 'vector-map' to the instance and the arguments.

 -- Method on '<vector>': <void> for-each THIS PROC VEC ...
     Apply 'vector-for-each' to the instance and the arguments.

 -- Method on '<vector>': <top> for-all THIS PROC VEC ...
     Apply 'vector-for-all' to the instance and the arguments.

 -- Method on '<vector>': <top> exists THIS PROC VEC ...
     Apply 'vector-exists' to the instance and the arguments.

 -- Method on '<vector>': <top> find THIS PROC
     Apply 'vector-find' to the instance and the argument.

 -- Method on '<vector>': <top> fold-left THIS PROC KNIL VEC ...
     Apply 'vector-fold-left' to the instance and the arguments.

 -- Method on '<vector>': <top> fold-right THIS PROC KNIL VEC ...
     Apply 'vector-fold-right' to the instance and the arguments.

Sorting
.......

 -- Method on '<vector>': <vector> sort THIS PROC
 -- Method on '<vector>': <vector> sort! THIS PROC
     Apply 'vector-sort' or 'vector-sort!' to the instance and the
     argument.

Conversion
..........

 -- Method on '<vector>': <list> list THIS
     Apply 'vector->list' to the instance.


File: vicare-typed.info,  Node: built-in vectors empty,  Next: built-in vectors non-empty,  Prev: built-in vectors base,  Up: built-in vectors

6.15.2 Empty vector type
------------------------

 -- Core Type: <empty-vector>
 -- Parent Type: <vector>
     Type of empty vector values.

 -- Constructor on '<empty-vector>': <empty-vector> type-constructor
     Return an empty vector.

 -- Type predicate on '<empty-vector>': <boolean> type-predicate OBJ
     The type predicate is 'empty-vector?'.  Return '#t' if OBJ is a
     '<empty-vector>' object; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in vectors non-empty,  Prev: built-in vectors empty,  Up: built-in vectors

6.15.3 Non-empty vector type
----------------------------

 -- Core Type: <nevector>
 -- Parent Type: <vector>
     Type of non-empty vector values.

 -- Constructor on '<nevector>': <nevector> type-constructor OBJ0 OBJ
          ...
     Return a non-empty vector.

 -- Type predicate on '<nevector>': <boolean> type-predicate OBJ
     The type predicate is 'nevector?'.  Return '#t' if OBJ is a
     '<nevector>' object; otherwise return '#f'.

Accessors and mutators
......................

 -- Method on '<nevector>': <top> ref THIS {IDX <non-negative-fixnum>}
     Apply 'vector-ref' to the instance and the argument.

 -- Method on '<nevector>': <void> set! THIS {IDX <non-negative-fixnum>}
          OBJ
     Apply 'vector-set!' to the instance and the arguments.


File: vicare-typed.info,  Node: built-in lists,  Next: built-in pairs,  Prev: built-in vectors,  Up: built-in

6.16 Type of list objects
=========================

* Menu:

* built-in lists base::       Base type of list objects.
* built-in lists null::       Type of empty lists.
* built-in lists non-empty::  Type of non-empty list objects.


File: vicare-typed.info,  Node: built-in lists base,  Next: built-in lists null,  Up: built-in lists

6.16.1 Base type of list objects
--------------------------------

 -- Core Type: <list>
 -- Parent Type: <top>
     Type of lists, whatever their structure.  The fact that a list
     structure is non-empty, non-circular, proper or improper must be
     checked at run-time.

 -- Constructor on '<list>': <list> type-constructor OBJ ...
     The constructor is 'list'.  Return a new list having the given OBJ
     arguments as items.

 -- Type predicate on '<list>': <list> type-predicate OBJ
     The type predicate is 'list?'.  Return '#t' if OBJ is null or a
     proper list object; otherwise return '#f'.

 -- Equality predicate on '<list>': <boolean> equality-predicate THIS
     The equality predicate is 'equal?'.

 -- Hash function on '<list>': <non-negative-fixnum> hash-function THIS
     The hash function is 'list-hash'.

Methods: predicates
...................

 -- Method on '<list>': <boolean> circular? THIS
     Apply 'circular-list?' to the argument and return its return value.

 -- Method on '<list>': <boolean> single-item? THIS
     Apply 'list-of-single-item?' to the argument and return its return
     value.

Methods: constructors
.....................

 -- Method on '<list>': <list> append THIS {L <list>} ...
     Apply 'append' to the arguments and return its return value.

 -- Method on '<list>': <list> reverse THIS
     Apply 'reverse' to the arguments and return its return value.


File: vicare-typed.info,  Node: built-in lists null,  Next: built-in lists non-empty,  Prev: built-in lists base,  Up: built-in lists

6.16.2 Type of empty lists
--------------------------

 -- Core Type: <null>
 -- Parent Type: <list>
     Type of the null object.

     The type '<null>' is special in that it is considered sub-type of
     both the type '<list>' and the types defined with the annotations
     '(list-of ?TYPE)'.  Notice that types defined with the annotations
     '(list ?TYPE0 ?TYPE ...)' are *not* super-types of '<null>',
     because, by definition, they contain at list one item.

 -- Constructor on '<null>': <null> type-constructor
     Return the null object.

 -- Type predicate on '<null>': <null> type-predicate OBJ
     The type predicate is 'null?'.  Return '#t' if OBJ is the null
     object; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in lists non-empty,  Prev: built-in lists null,  Up: built-in lists

6.16.3 Type of non-empty list objects
-------------------------------------

 -- Core Type: <nelist>
 -- Parent Type: <list>
     Type of non-empty lists, whatever their structure.  The fact that a
     list structure is non-circular, proper or improper must be checked
     at run-time.

 -- Constructor on '<nelist>': <nelist> type-constructor OBJ ...
     Return a new non-empty list having the given OBJ arguments as
     items.

 -- Type predicate on '<nelist>': <nelist> type-predicate OBJ
     The type predicate is 'nelist?'.  Return '#t' if OBJ is a proper
     non-empty list object; otherwise return '#f'.

Methods: accessors
..................

 -- Method on '<nelist>': <top> car THIS
     Apply 'car' to the type instance.

 -- Method on '<nelist>': <top> cdr THIS
     Apply 'cdr' to the type instance.

 -- Method on '<nelist>': <pair> last-pair THIS
     Apply 'last-pair' to the arguments and return its return value.

 -- Method on '<list>': <list> list-tail THIS {IDX
          <non-negative-exact-integer>}
     Apply 'list-tail' to the arguments and return its return value.

 -- Method on '<list>': <list> ref THIS {IDX
          <non-negative-exact-integer>}
     Apply 'list-ref' to the arguments and return its return value.


File: vicare-typed.info,  Node: built-in pairs,  Next: built-in bytevectors,  Prev: built-in lists,  Up: built-in

6.17 Type of pair objects
=========================

* Menu:

* built-in pairs base::         Type of pair objects.
* built-in pairs weak::         Type of weak pair objects.
* built-in pairs immutable::    Type of immutable pair objects.


File: vicare-typed.info,  Node: built-in pairs base,  Next: built-in pairs weak,  Up: built-in pairs

6.17.1 Type of pair objects
---------------------------

 -- Core Type: <pair>
 -- Parent Type: <top>
     Type of pair objects.

 -- Constructor on '<pair>': <pair> type-constructor A D
     The constructor is 'cons'.  Return a new pair having A and D as car
     and cdr.

 -- Type predicate on '<pair>': <boolean> type-predicate OBJ
     The type predicate is 'pair?'.  Return '#t' if OBJ is a pair
     object; otherwise return '#f'.

 -- Equality predicate on '<pair>': <boolean> equality-predicate THIS {P
          <pair>}
     The equality predicate is 'equal?'.

 -- Hash function on '<pair>': <non-negative-fixnum> hash-function THIS
     The hash function is 'pair-hash'.

Methods: accessors
..................

 -- Method on '<pair>': <top> car THIS
     Apply 'car' to the type instance.

 -- Method on '<pair>': <top> cdr THIS
     Apply 'cdr' to the type instance.


File: vicare-typed.info,  Node: built-in pairs weak,  Next: built-in pairs immutable,  Prev: built-in pairs base,  Up: built-in pairs

6.17.2 Type of weak pair objects
--------------------------------

 -- Label Type: <weak-pair>
 -- Parent Type: <pair>
     Type of weak pair objects.

 -- Constructor on '<weak-pair>': <weak-pair> type-constructor A D
     The constructor is 'weak-cons'.  Return a new weak pair having A
     and D as car and cdr.

 -- Type predicate on '<weak-pair>': <boolean> type-predicate OBJ
     The type predicate is 'weak-pair?'.  Return '#t' if OBJ is an
     immutable pair object; otherwise return '#f'.


File: vicare-typed.info,  Node: built-in pairs immutable,  Prev: built-in pairs weak,  Up: built-in pairs

6.17.3 Type of immutable pair objects
-------------------------------------

 -- Core Type: <ipair>
 -- Parent Type: <struct>
     Type of immutable pair objects.

 -- Constructor on '<ipair>': <ipair> type-constructor A D
     The constructor is 'ipair'.  Return a new immutable pair having A
     and D as car and cdr.

 -- Type predicate on '<ipair>': <boolean> type-predicate OBJ
     The type predicate is 'ipair?'.  Return '#t' if OBJ is an immutable
     pair object; otherwise return '#f'.

 -- Equality predicate on '<ipair>': <boolean> equality-predicate THIS
          {P <ipair>}
     The equality predicate is 'equal?'.

 -- Hash function on '<ipair>': <non-negative-fixnum> hash-function THIS
     The hash function is 'ipair-hash'.

Methods: accessors
..................

 -- Method on '<ipair>': <top> car THIS
     Apply 'icar' to the type instance.

 -- Method on '<ipair>': <top> cdr THIS
     Apply 'icdr' to the type instance.


File: vicare-typed.info,  Node: built-in bytevectors,  Next: built-in hashtables,  Prev: built-in pairs,  Up: built-in

6.18 Type of bytevector objects
===============================

* Menu:

* built-in bytevectors base::       The '<bytevector>' type.
* built-in bytevectors empty::      The '<empty-bytevector>' type.
* built-in bytevectors non-empty::  The '<nebytevector>' type.


File: vicare-typed.info,  Node: built-in bytevectors base,  Next: built-in bytevectors empty,  Up: built-in bytevectors

6.18.1 The '<bytevector>' type
------------------------------

 -- Core Type: <bytevector>
 -- Parent Type: <top>
     Type of bytevector objects.

 -- Constructor on '<bytevector>': <bytevector> type-constructor {LEN
          <non-negative-fixnum>}
 -- Constructor on '<bytevector>': <bytevector> type-constructor {LEN
          <non-negative-fixnum>} {FILL <fixnum>}
     The constructor is 'make-bytevector'.

 -- Type predicate on '<bytevector>': <boolean> type-predicate OBJ
     The type predicate is 'bytevector?'.

 -- Equality predicate on '<bytevector>': <boolean> equality-predicate
          THIS {BV <bytevector>}
     The equality predicate is 'bytevector=?'.

 -- Hash function on '<bytevector>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'bytevector-hash'.

Methods
.......

 -- Method on '<bytevector>': <non-negative-fixnum> length THIS
     Apply 'bytevector-length' to the instance and return its return
     value.

 -- Method on '<bytevector>': = THIS {BV <bytevector>} ...
 -- Method on '<bytevector>': != THIS {BV <bytevector>} ...
     Apply 'bytevector=?', 'bytevector!=?' to the instance and the
     arguments and return its return value.

 -- Method on '<bytevector>': <bytevector> append THIS {BV <bytevector>}
          ...
     Apply 'bytevector-append' to the arguments and return its return
     value.

 -- Method on '<bytevector>': <bytevector> copy THIS
     Apply 'bytevector-copy' to the instance and return its return
     value.

 -- Method on '<bytevector>': () copy! THIS {SRC-START
          <non-negative-fixnum>} {DST <bytevector>} {DST-START
          <non-negative-fixnum>} {K <non-negative-fixnum>}
     Apply 'bytevector-copy!' to the arguments and return its return
     value.

 -- Method on '<bytevector>': () fill! THIS {FILL <fixnum>}
     Apply 'bytevector-fill!' to the arguments and return its return
     value.


File: vicare-typed.info,  Node: built-in bytevectors empty,  Next: built-in bytevectors non-empty,  Prev: built-in bytevectors base,  Up: built-in bytevectors

6.18.2 The '<empty-bytevector>' type
------------------------------------

 -- Core Type: <empty-bytevector>
 -- Parent Type: <bytevector>
     Type of empty bytevector objects.

 -- Constructor on '<empty-bytevector>': <empty-bytevector>
          type-constructor
     Return an empty bytevector object.

 -- Type predicate on '<empty-bytevector>': <boolean> type-predicate OBJ
     The type predicate is 'empty-bytevector?'.


File: vicare-typed.info,  Node: built-in bytevectors non-empty,  Prev: built-in bytevectors empty,  Up: built-in bytevectors

6.18.3 The '<nebytevector>' type
--------------------------------

 -- Core Type: <nebytevector>
 -- Parent Type: <bytevector>
     Type of non-empty bytevector objects.

 -- Constructor on '<nebytevector>': <nebytevector> type-constructor
          {LEN <positive-fixnum>}
 -- Constructor on '<nebytevector>': <nebytevector> type-constructor
          {LEN <positive-fixnum>} {FILL <fixnum>}
     Return a non-empty bytevector object.

 -- Type predicate on '<nebytevector>': <boolean> type-predicate OBJ
     The type predicate is 'nebytevector?'.


File: vicare-typed.info,  Node: built-in hashtables,  Next: built-in structs,  Prev: built-in bytevectors,  Up: built-in

6.19 Type of hashtable objects
==============================

* Menu:

* built-in hashtables base::    The '<hashtable>' type.
* built-in hashtables eq::      The '<hashtable-eq>' type.
* built-in hashtables eqv::     The '<hashtable-eqv>' type.
* built-in hashtables equiv::   The '<hashtable-equiv>' type.
* built-in hashtables tcbucket::  The '<tcbucket>' type.


File: vicare-typed.info,  Node: built-in hashtables base,  Next: built-in hashtables eq,  Up: built-in hashtables

6.19.1 The '<hashtable>' type
-----------------------------

 -- Core Type: <hashtable>
 -- Parent Type: <top>
     Base type for hashtable objects.

 -- Constructor on '<hashtable>': <hashtable> type-constructor TABLE
     Validate TABLE as hashtable object and return it.

 -- Type predicate on '<hashtable>': <boolean> type-predicate OBJ
     The type predicate is 'hashtable?'.


File: vicare-typed.info,  Node: built-in hashtables eq,  Next: built-in hashtables eqv,  Prev: built-in hashtables base,  Up: built-in hashtables

6.19.2 The '<hashtable-eq>' type
--------------------------------

 -- Core Type: <hashtable-eq>
 -- Parent Type: <hashtable>
     Type of 'eq?' hashtables.

 -- Constructor on '<hashtable-eq>': <hashtable-eq> type-constructor
 -- Constructor on '<hashtable-eq>': <hashtable-eq> type-constructor K
     The constructor if 'make-eq-hashtable'.

 -- Type predicate on '<hashtable-eq>': <boolean> type-predicate OBJ
     The type predicate is 'hashtable-eq?'.


File: vicare-typed.info,  Node: built-in hashtables eqv,  Next: built-in hashtables equiv,  Prev: built-in hashtables eq,  Up: built-in hashtables

6.19.3 The '<hashtable-eqv>' type
---------------------------------

 -- Core Type: <hashtable-eqv>
 -- Parent Type: <hashtable>
     Type of 'eqv?' hashtables.

 -- Constructor on '<hashtable-eqv>': <hashtable-eqv> type-constructor
 -- Constructor on '<hashtable-eqv>': <hashtable-eqv> type-constructor K
     The constructor if 'make-eqv-hashtable'.

 -- Type predicate on '<hashtable-eqv>': <boolean> type-predicate OBJ
     The type predicate is 'hashtable-eqv?'.


File: vicare-typed.info,  Node: built-in hashtables equiv,  Next: built-in hashtables tcbucket,  Prev: built-in hashtables eqv,  Up: built-in hashtables

6.19.4 The '<hashtable-equiv>' type
-----------------------------------

 -- Core Type: <hashtable-equiv>
 -- Parent Type: <hashtable>
     Type of 'equal?' hashtables.

 -- Constructor on '<hashtable-equiv>': <hashtable-equiv>
          type-constructor HASH-FUNCTION EQUIV
 -- Constructor on '<hashtable-equiv>': <hashtable-equiv>
          type-constructor HASH-FUNCTION EQUIV K
     The constructor if 'make-hashtable'.

 -- Type predicate on '<hashtable-equiv>': <boolean> type-predicate OBJ
     The type predicate is 'hashtable-equiv?'.


File: vicare-typed.info,  Node: built-in hashtables tcbucket,  Prev: built-in hashtables equiv,  Up: built-in hashtables

6.19.5 The '<tcbucket>' type
----------------------------

 -- Core Type: <tcbucket>
 -- Parent Type: <top>
     Type of tail-conc objects used in the implementation of hash
     tables.

 -- Type predicate on '<tcbucket>': <boolean> type-predicate OBJ
     Return '#t' if OBJ is a '<tcbucket>' instance; otherwise return
     '#f'.

 -- Equality predicate on '<tcbucket>': <boolean> equality-predicate
          THIS {TCB <tcbucket>}
     The equality predicate is 'eq?'.


File: vicare-typed.info,  Node: built-in structs,  Next: built-in records,  Prev: built-in hashtables,  Up: built-in

6.20 Type of struct objects
===========================

* Menu:

* built-in structs base::       The '<struct>' type.
* built-in structs std::        The '<struct-type-descriptor>' type.


File: vicare-typed.info,  Node: built-in structs base,  Next: built-in structs std,  Up: built-in structs

6.20.1 The '<struct>' type
--------------------------

 -- Core Type: <struct>
 -- Parent Type: <top>
     Type of struct objects.  There is no constructor.  The type
     predicate is 'struct?'.

 -- Constructor on '<struct>': <struct> type-constructor STRU
     Validate STRU as struct object and return it.

 -- Type predicate on '<struct>': <boolean> type-predicate OBJ
     The type predicate is 'struct?'.

 -- Equality predicate on '<struct>': <boolean> equality-predicate THIS
          {STRU <struct>}
     The equality predicate is 'struct=?'.

 -- Hash function on '<struct>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'struct-hash'.

Methods: inspection
...................

 -- Method on '<struct>': <struct-type-descriptor> std THIS
     Apply 'struct-std' to the instance and return its return value.

 -- Method on '<struct>': <nestring> name THIS
     Apply 'struct-name' to the instance and return its return value.

 -- Method on '<struct>': <non-negative-fixnum> length THIS
     Apply 'struct-length' to the instance and return its return value.

 -- Method on '<struct>': (list-of <symbol>) field-names THIS
     Apply 'struct-field-names' to the instance and return its return
     value.

 -- Method on '<struct>': <type-printer> printer THIS
     Apply 'struct-printer' to the instance and return its return value.

 -- Method on '<struct>': <type-destructor> destructor THIS
     Apply 'struct-destructor' to the instance and return its return
     value.

Methods: comparison
...................

 -- Method on '<struct>': <boolean> = THIS {STRU <struct>} ...
     Apply 'struct=?' to the arguments and return its return value.

 -- Method on '<struct>': <boolean> != THIS {STRU <struct>} ...
     Apply 'struct!=?' to the arguments and return its return value.

Methods: accessors and mutators
...............................

 -- Method on '<struct>': <top> ref THIS {IDX <non-negative-fixnum>}
     Apply 'struct-ref' to the arguments and return its return value.

 -- Method on '<struct>': () set! THIS {IDX <non-negative-fixnum>} OBJ
     Apply 'struct-set!' to the arguments and return its return value.

 -- Method on '<struct>': () reset THIS
     Apply 'struct-reset!' to the arguments and return its return value.


File: vicare-typed.info,  Node: built-in structs std,  Prev: built-in structs base,  Up: built-in structs

6.20.2 The '<struct-type-descriptor>' type
------------------------------------------

 -- Core Type: <struct-type-descriptor>
 -- Parent Type: <struct>
     Type of struct-type descriptor objects.

 -- Constructor on '<struct-type-descriptor>': <struct-type-descriptor>
          type-constructor NAME FIELDS
 -- Constructor on '<struct-type-descriptor>': <struct-type-descriptor>
          type-constructor NAME FIELDS UID
     The constructor if 'make-struct-type'.

 -- Type predicate on '<struct-type-descriptor>': '<boolean>'
          type-predicate OBJ
     The type predicate is 'struct-type-descriptor?'.

methods
.......

 -- Method on '<struct-type-descriptor>': <string> name THIS
     Apply 'struct-type-name' to the instance and return its return
     value.

 -- Method on '<struct-type-descriptor>': <symbol> uid THIS
     Apply 'struct-type-symbol' to the instance and return its return
     value.

 -- Method on '<struct-type-descriptor>': (list-of <symbol>) field-names
          THIS
     Apply 'struct-type-field-names' to the instance and return its
     return value.

 -- Method on '<struct-type-descriptor>': <procedure> constructor THIS
     Apply 'struct-type-constructor' to the instance and return its
     return value.

 -- Method on '<struct-type-descriptor>': <type-predicate> predicate
          THIS
     Apply 'struct-type-predicate' to the instance and return its return
     value.

 -- Method on '<struct-type-descriptor>': <type-printer> printer THIS
     Apply 'struct-type-printer' to the instance and return its return
     value.

 -- Method on '<struct-type-descriptor>': <type-destructor> destructor
          THIS
     Apply 'struct-type-destructor' to the instance and return its
     return value.

 -- Method on '<struct-type-descriptor>': <procedure> field-accessor
          THIS {IDX <non-negative-fixnum>}
 -- Method on '<struct-type-descriptor>': <procedure> field-accessor
          THIS {NAME <symbol>}
     Apply 'struct-type-field-accessor' to the instance and return its
     return value.

 -- Method on '<struct-type-descriptor>': <procedure> field-mutator THIS
          {IDX <non-negative-fixnum>}
 -- Method on '<struct-type-descriptor>': <procedure> field-mutator THIS
          {NAME <symbol>}
     Apply 'struct-type-field-mutator' to the instance and return its
     return value.

 -- Method on '<struct-type-descriptor>': <procedure> field-method THIS
          {IDX <non-negative-fixnum>}
 -- Method on '<struct-type-descriptor>': <procedure> field-method THIS
          {NAME <symbol>}
     Apply 'struct-type-field-method' to the instance and return its
     return value.


File: vicare-typed.info,  Node: built-in records,  Next: built-in conditions,  Prev: built-in structs,  Up: built-in

6.21 Type of record objects
===========================

* Menu:

* built-in records base::       The '<record>' type.
* built-in records rtd::        The '<record-type-descriptor>' type.
* built-in records rcd::        The '<record-constructor-descriptor>' type.


File: vicare-typed.info,  Node: built-in records base,  Next: built-in records rtd,  Up: built-in records

6.21.1 The '<record>' type
--------------------------

 -- Core Type: <record>
 -- Parent Type: <struct>
     Type of record objects.

 -- Constructor on '<record>': <record> type-constructor RECO
     Validate RECO as record object and return it.

 -- Type predicate on '<record>': <boolean> type-predicate OBJ
     The type predicate is 'record?'.

 -- Equality predicate on '<record>': <boolean> equality-predicate THIS
          {RECO <record>}
     The equality predicate is 'record=?'.

 -- Hash function on '<record>': <non-negative-fixnum> hash-function
          THIS
     The hash function is 'record-hash'.

Methods: comparison
...................

 -- Method on '<record>': <boolean> = THIS {RECO <record>} ...
     Apply 'record=?' to the arguments and return its return value.

 -- Method on '<record>': <boolean> != THIS {RECO <record>} ...
     Apply 'record!=?' to the arguments and return its return value.

Methods: accessors and mutators
...............................

 -- Method on '<record>': <top> ref THIS {IDX <non-negative-fixnum>}
     Apply 'record-ref' to the arguments and return its return value.

 -- Method on '<record>': () reset THIS
     Apply 'record-reset!' to the arguments and return its return value.


File: vicare-typed.info,  Node: built-in records rtd,  Next: built-in records rcd,  Prev: built-in records base,  Up: built-in records

6.21.2 The '<record-type-descriptor>' type
------------------------------------------

 -- Core Type: <record-type-descriptor>
 -- Parent Type: <struct>
     Type of record-type descriptor objects.

 -- Constructor on '<record-type-descriptor>': <record-type-descriptor>
          type-constructor NAME PARENT UID SEALED? OPAQUE? FIELDS
     The constructor is 'make-record-type-descriptor'.

 -- Type predicate on '<record-type-descriptor>': <boolean>
          type-predicate OBJ
     The type predicate is 'record-type-descriptor?'.

Methods: inspection
...................

 -- Method on '<record-type-descriptor>': <symbol> name THIS
     Apply 'record-type-name' to the instance and return its return
     value.

 -- Method on '<record-type-descriptor>': (or <false>
          <record-type-descriptor>) parent THIS
     Apply 'record-type-parent' to the instance and return its return
     value.

 -- Method on '<record-type-descriptor>': <symbol> uid THIS
     Apply 'record-type-uid' to the instance and return its return
     value.

 -- Method on '<record-type-descriptor>': <boolean> generative? THIS
     Apply 'record-type-generative?' to the instance and return its
     return value.

 -- Method on '<record-type-descriptor>': <boolean> sealed? THIS
     Apply 'record-type-sealed?' to the instance and return its return
     value.

 -- Method on '<record-type-descriptor>': <boolean> opaque? THIS
     Apply 'record-type-opaque?' to the instance and return its return
     value.

 -- Method on '<record-type-descriptor>': <boolean> generative? THIS
     Apply 'record-type-generative?' to the instance and return its
     return value.

 -- Method on '<record-type-descriptor>': (vector-of <symbol>)
          field-names THIS
     Apply 'record-type-field-names' to the instance and return its
     return value.

 -- Method on '<record-type-descriptor>': (vector-of <symbol>)
          all-field-names THIS
     Apply 'record-type-all-field-names' to the instance and return its
     return value.

 -- Method on '<record-type-descriptor>': (nelist-of <symbol>) uids-list
          THIS
     Apply 'record-type-uids-list' to the instance and return its return
     value.

 -- Method on '<record-type-descriptor>': (or <false> (vector-of (pair
          <symbol> <type-method-retriever>))) implemented-interfaces
          THIS
     Apply 'record-type-implemented-interfaces' to the instance and
     return its return value.


File: vicare-typed.info,  Node: built-in records rcd,  Prev: built-in records rtd,  Up: built-in records

6.21.3 The '<record-constructor-descriptor>' type
-------------------------------------------------

 -- Core Type: <record-constructor-descriptor>
 -- Parent Type: <struct>
     Type of record-constructor descriptor objects.

 -- Constructor on '<record-constructor-descriptor>':
          <record-constructor-descriptor> type-constructor RTD
          PARENT-CONSTRUCTOR-DESCRIPTOR PROTOCOL
     The constructor is 'make-record-type-descriptor'.  *Note
     make-record-type-descriptor: (vicare-scheme)stdlib records
     procedural layer.

 -- Type predicate on '<record-constructor-descriptor>': <boolean>
          type-predicate OBJ
     The type predicate is 'record-constructor-descriptor?'.  *Note
     record-constructor-descriptor?: (vicare-scheme)iklib records rcd.

Methods: inspection
...................

 -- Method on '<record-constructor-descriptor>':
          <record-type-descriptor> rtd THIS
     Apply 'rcd-rtd' to the instance and return its return value.  *Note
     rcd-rtd: (vicare-scheme)iklib records rcd.

 -- Method on '<record-constructor-descriptor>': (or <false>
          <record-constructor-descriptor>) parent THIS
     Apply 'rcd-parent-rcd' to the instance and return its return value.
     *Note rcd-parent-rcd: (vicare-scheme)iklib records rcd.


File: vicare-typed.info,  Node: built-in conditions,  Next: built-in ports,  Prev: built-in records,  Up: built-in

6.22 Type of condition objects
==============================

* Menu:

* built-in conditions base::      The '<condition>' type.
* built-in conditions compound::  The '<compound-condition>' type.


File: vicare-typed.info,  Node: built-in conditions base,  Next: built-in conditions compound,  Up: built-in conditions

6.22.1 The '<condition>' type
-----------------------------

 -- Core Type: <condition>
 -- Parent Type: <record>
     Type of condition objects.  This is the root of all the condition
     object types, both simple and compound.  All the simple condition
     types are derived from '&condition'.

 -- Constructor on '<condition>': <condition> type-constructor CND
     Validate CND as object of type '<condition>' and return it.

 -- Type predicate on '<condition>': <boolean> type-predicate OBJ
     The type predicate is 'condition?'.

Methods
.......

 -- Method on '<condition>': <void> print THIS
 -- Method on '<condition>': <void> print THIS {P <textual-output-port>}
     Apply 'print-condition' to the instance.


File: vicare-typed.info,  Node: built-in conditions compound,  Prev: built-in conditions base,  Up: built-in conditions

6.22.2 The '<compound-condition>' type
--------------------------------------

 -- Core Type: <compound-condition>
 -- Parent Type: <condition>
     Type of compound condition objects.

 -- Constructor on '<compound-condition>': <compound-condition>
          type-constructor CND ...
     The constructor is 'condition'.

 -- Type predicate on '<compound-condition>': <boolean> type-predicate
          OBJ
     The type predicate is 'compound-condition?'.


File: vicare-typed.info,  Node: built-in ports,  Next: built-in enum-set,  Prev: built-in conditions,  Up: built-in

6.23 Type of input/output ports
===============================

* Menu:

* built-in ports base::         Base ports type.
* built-in ports texin::        Textual input-only ports.
* built-in ports texou::        Textual output-only ports.
* built-in ports texio::        Textual input/output ports.
* built-in ports binin::        Binary input-only ports.
* built-in ports binou::        Binary output-only port.
* built-in ports binio::        Binary input/output port.
* built-in ports labels::       Input/output port labels.
* built-in ports misc::         Miscellaneous types.


File: vicare-typed.info,  Node: built-in ports base,  Next: built-in ports texin,  Up: built-in ports

6.23.1 Base ports type
----------------------

 -- Core Type: <port>
 -- Parent Type: <top>
     Base type for input, output and input/output ports.

 -- Constructor on '<port>': <port> type-constructor PORT
     Validate PORT as port object and return it.

 -- Type predicate on '<port>': <boolean> type-predicate OBJ
     The type predicate is 'port?'.

 -- Equality predicate on '<port>': <boolean> equality-predicate THIS
          {PORT <port>}
     The equality predicate is 'eq?'.

 -- Hash function on '<port>': <non-negative-fixnum> hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<port>': <boolean> open? THIS
 -- Method on '<port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<port>': () set-non-blocking-mode THIS
 -- Method on '<port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<port>': <non-negative-exact-integer> position THIS
 -- Method on '<port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<port>': (or <false> <file-descriptor>) fd THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<port>': (or <transcoder> <false>) transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<port>': () putprop THIS {KEY <symbol>} VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<port>': (alist <symbol> <top>) property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.


File: vicare-typed.info,  Node: built-in ports texin,  Next: built-in ports texou,  Prev: built-in ports base,  Up: built-in ports

6.23.2 Textual input-only ports
-------------------------------

 -- Core Type: <textual-input-only-port>
 -- Parent Type: <port>
     Type of textual input-only ports.

 -- Constructor on '<textual-input-only-port>': <port> type-constructor
          PORT
     Validate PORT as instance of '<textual-input-only-port>' and return
     it.

 -- Type predicate on '<textual-input-only-port>': <boolean>
          type-predicate OBJ
     The type predicate is 'textual-input-only-port?'.

Methods
.......

 -- Method on '<textual-input-only-port>': <reader-input-port-mode> mode
          THIS
 -- Method on '<textual-input-only-port>': () mode THIS {MODE
          <reader-input-port-mode>}
     Accessor and mutator for the port reader mode.  The accessor
     applies 'port-mode' to the argument; the mutator applies
     'set-port-mode!' to the arguments.

 -- Method on '<textual-input-only-port>': &source-position
          textual-position THIS
     Apply 'port-textual-position' to the argument and return its return
     value.

 -- Method on '<textual-input-only-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.


File: vicare-typed.info,  Node: built-in ports texou,  Next: built-in ports texio,  Prev: built-in ports texin,  Up: built-in ports

6.23.3 Textual output-only ports
--------------------------------

 -- Core Type: <textual-output-only-port>
 -- Parent Type: <port>
     Type of textual output-only ports.

 -- Constructor on '<textual-output-only-port>': <port> type-constructor
          PORT
     Validate PORT as instance of '<textual-output-only-port>' and
     return it.

 -- Type predicate on '<textual-output-only-port>': <boolean>
          type-predicate OBJ
     The type predicate is 'textual-output-only-port?'.

Methods
.......

 -- Method on '<textual-output-only-port>': <output-port-buffer-mode>
          buffer-mode THIS
 -- Method on '<textual-output-only-port>': () buffer-mode THIS
          {BUFFER-MODE <output-port-buffer-mode>}
     Accessor and mutator for the port buffer mode.  The accessor
     applies 'output-port-buffer-mode' to the argument; the mutator
     applies 'set-port-buffer-mode!' to the arguments.

 -- Method on '<textual-output-only-port>': () flush THIS
     Apply 'flush-output-port' to the instance.

 -- Method on '<textual-output-only-port>': &source-position
          textual-position THIS
     Apply 'port-textual-position' to the argument and return its return
     value.


File: vicare-typed.info,  Node: built-in ports texio,  Next: built-in ports binin,  Prev: built-in ports texou,  Up: built-in ports

6.23.4 Textual input/output ports
---------------------------------

 -- Core Type: <textual-input/output-port>
 -- Parent Type: <port>
     Type of textual input/output ports.

 -- Constructor on '<textual-input/output-port>': <port>
          type-constructor PORT
     Validate PORT as instance of '<textual-input/output-port>' and
     return it.

 -- Type predicate on '<textual-input/output-port>': <boolean>
          type-predicate OBJ
     The type predicate is 'textual-input/output-port?'.

Methods: input side
...................

 -- Method on '<textual-input/output-port>': <reader-input-port-mode>
          mode THIS
 -- Method on '<textual-input/output-port>': () mode THIS {MODE
          <reader-input-port-mode>}
     Accessor and mutator for the port reader mode.  The accessor
     applies 'port-mode' to the argument; the mutator applies
     'set-port-mode!' to the arguments.

 -- Method on '<textual-input/output-port>': &source-position
          textual-position THIS
     Apply 'port-textual-position' to the argument and return its return
     value.

 -- Method on '<textual-input/output-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.

Methods: output side
....................

 -- Method on '<textual-input/output-port>': <output-port-buffer-mode>
          buffer-mode THIS
 -- Method on '<textual-input/output-port>': () buffer-mode THIS
          {BUFFER-MODE <output-port-buffer-mode>}
     Accessor and mutator for the port buffer mode.  The accessor
     applies 'output-port-buffer-mode' to the argument; the mutator
     applies 'set-port-buffer-mode!' to the arguments.

 -- Method on '<textual-input/output-port>': () flush THIS
     Apply 'flush-output-port' to the instance.

 -- Method on '<textual-input/output-port>': &source-position
          textual-position THIS
     Apply 'port-textual-position' to the argument and return its return
     value.


File: vicare-typed.info,  Node: built-in ports binin,  Next: built-in ports binou,  Prev: built-in ports texio,  Up: built-in ports

6.23.5 Binary input-only ports
------------------------------

 -- Core Type: <binary-input-only-port>
 -- Parent Type: <port>
     Type of binary input ports.

 -- Constructor on '<binary-input-only-port>': <port> type-constructor
          PORT
     Validate PORT as instance of '<binary-input-only-port>' and return
     it.

 -- Type predicate on '<binary-input-only-port>': <boolean>
          type-predicate OBJ
     The type predicate is 'binary-input-only-port?'.

Methods
.......

 -- Method on '<binary-input-only-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.


File: vicare-typed.info,  Node: built-in ports binou,  Next: built-in ports binio,  Prev: built-in ports binin,  Up: built-in ports

6.23.6 Binary output-only ports
-------------------------------

 -- Core Type: <binary-output-only-port>
 -- Parent Type: <port>
     Type of binary output ports.

 -- Constructor on '<binary-output-only-port>': <port> type-constructor
          PORT
     Validate PORT as instance of '<binary-output-only-port>' and return
     it.

 -- Type predicate on '<binary-output-only-port>': <boolean>
          type-predicate OBJ
     The type predicate is 'binary-output-only-port?'.

Methods
.......

 -- Method on '<binary-output-only-port>': () flush THIS
     Apply 'flush-output-port' to the instance.


File: vicare-typed.info,  Node: built-in ports binio,  Next: built-in ports labels,  Prev: built-in ports binou,  Up: built-in ports

6.23.7 Binary input/output ports
--------------------------------

 -- Core Type: <binary-input/output-port>
 -- Parent Type: <port>
     Type of binary input/output ports.

 -- Constructor on '<binary-input/output-port>': <port> type-constructor
          PORT
     Validate PORT as instance of '<binary-input/output-port>' and
     return it.

 -- Type predicate on '<binary-input/output-port>': <boolean>
          type-predicate OBJ
     The type predicate is 'binary-input/output-port?'.

Methods: input side
...................

 -- Method on '<binary-input/output-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.

Methods: output side
....................

 -- Method on '<binary-input/output-port>': () flush THIS
     Apply 'flush-output-port' to the instance.


File: vicare-typed.info,  Node: built-in ports labels,  Next: built-in ports misc,  Prev: built-in ports binio,  Up: built-in ports

6.23.8 Input/output port labels
-------------------------------

* Menu:

* built-in ports labels input::         Input port labels.
* built-in ports labels output::        Output port labels.
* built-in ports labels input/output::  Input/output port labels.
* built-in ports labels binary::        Binary port labels.
* built-in ports labels textual::       Textual port labels.
* built-in ports labels binin::         Binary input port labels.
* built-in ports labels binou::         Binary output port labels.
* built-in ports labels texin::         Textual input port labels.
* built-in ports labels texou::         Textual output port labels.


File: vicare-typed.info,  Node: built-in ports labels input,  Next: built-in ports labels output,  Up: built-in ports labels

6.23.8.1 Input port labels
..........................

 -- Label Type: <input-port>
     Label-type for all the input ports.  Its parent is the type
     annotation:

          (or <binary-input-only-port> <binary-input/output-port>
              <textual-input-only-port> <textual-input/output-port>)

 -- Constructor on '<input-port>': <input-port> type-constructor PORT
     Validate PORT as instance of '<input-port>' and return it.

 -- Type predicate on '<input-port>': <boolean> type-predicate OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<input-port>': <boolean> equality-predicate
          THIS {PORT <input-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<input-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<input-port>': <boolean> open? THIS
 -- Method on '<input-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<input-port>': () set-non-blocking-mode THIS
 -- Method on '<input-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<input-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<input-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<input-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<input-port>': <non-negative-exact-integer> position THIS
 -- Method on '<input-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<input-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<input-port>': (or <false> <file-descriptor>) fd THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<input-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<input-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<input-port>': (or <transcoder> <false>) transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<input-port>': () putprop THIS {KEY <symbol>} VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<input-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<input-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<input-port>': (alist <symbol> <top>) property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<input-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<input-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: input ports
....................

 -- Method on '<input-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.


File: vicare-typed.info,  Node: built-in ports labels output,  Next: built-in ports labels input/output,  Prev: built-in ports labels input,  Up: built-in ports labels

6.23.8.2 Output port labels
...........................

 -- Label Type: <output-port>
     Label-type for all the output ports.  Its parent is the type
     annotation:

          (or <binary-output-only-port> <binary-input/output-port>
              <textual-output-only-port> <textual-input/output-port>)

 -- Constructor on '<output-port>': <output-port> type-constructor PORT
     Validate PORT as instance of '<output-port>' and return it.

 -- Type predicate on '<output-port>': <boolean> type-predicate OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<output-port>': <boolean> equality-predicate
          THIS {PORT <output-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<output-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<output-port>': <boolean> open? THIS
 -- Method on '<output-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<output-port>': () set-non-blocking-mode THIS
 -- Method on '<output-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<output-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<output-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<output-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<output-port>': <non-negative-exact-integer> position
          THIS
 -- Method on '<output-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<output-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<output-port>': (or <false> <file-descriptor>) fd THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<output-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<output-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<output-port>': (or <transcoder> <false>) transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<output-port>': () putprop THIS {KEY <symbol>} VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<output-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<output-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<output-port>': (alist <symbol> <top>) property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<output-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<output-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: output ports
.....................

 -- Method on '<output-port>': () flush THIS
     Apply 'flush-output-port' to the instance.


File: vicare-typed.info,  Node: built-in ports labels input/output,  Next: built-in ports labels binary,  Prev: built-in ports labels output,  Up: built-in ports labels

6.23.8.3 Input/output port labels
.................................

 -- Label Type: <input/output-port>
     Label-type for all the input/output ports.  Its parent is the type
     annotation:

          (or <binary-input/output-port> <textual-input/output-port>)

 -- Constructor on '<input/output-port>': <input/output-port>
          type-constructor PORT
     Validate PORT as instance of '<input/output-port>' and return it.

 -- Type predicate on '<input/output-port>': <boolean> type-predicate
          OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<input/output-port>': <boolean>
          equality-predicate THIS {PORT <input/output-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<input/output-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<input/output-port>': <boolean> open? THIS
 -- Method on '<input/output-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<input/output-port>': () set-non-blocking-mode THIS
 -- Method on '<input/output-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<input/output-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<input/output-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<input/output-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<input/output-port>': <non-negative-exact-integer>
          position THIS
 -- Method on '<input/output-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<input/output-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<input/output-port>': (or <false> <file-descriptor>) fd
          THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<input/output-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<input/output-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<input/output-port>': (or <transcoder> <false>)
          transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<input/output-port>': () putprop THIS {KEY <symbol>}
          VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<input/output-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<input/output-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<input/output-port>': (alist <symbol> <top>)
          property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<input/output-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<input/output-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: input ports
....................

 -- Method on '<input/output-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.

Methods: output ports
.....................

 -- Method on '<input/output-port>': () flush THIS
     Apply 'flush-output-port' to the instance.


File: vicare-typed.info,  Node: built-in ports labels binary,  Next: built-in ports labels textual,  Prev: built-in ports labels input/output,  Up: built-in ports labels

6.23.8.4 Binary port labels
...........................

 -- Label Type: <binary-port>
     Label-type for all the binary ports.  Its parent is the type
     annotation:

          (or <binary-input-only-port> <binary-output-only-port>
              <binary-input/output-port>)

 -- Constructor on '<binary-port>': <binary-port> type-constructor PORT
     Validate PORT as instance of '<binary-port>' and return it.

 -- Type predicate on '<binary-port>': <boolean> type-predicate OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<binary-port>': <boolean> equality-predicate
          THIS {PORT <binary-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<binary-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<binary-port>': <boolean> open? THIS
 -- Method on '<binary-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<binary-port>': () set-non-blocking-mode THIS
 -- Method on '<binary-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<binary-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<binary-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<binary-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<binary-port>': <non-negative-exact-integer> position
          THIS
 -- Method on '<binary-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<binary-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<binary-port>': (or <false> <file-descriptor>) fd THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<binary-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<binary-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<binary-port>': (or <transcoder> <false>) transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<binary-port>': () putprop THIS {KEY <symbol>} VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<binary-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<binary-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<binary-port>': (alist <symbol> <top>) property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<binary-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<binary-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.


File: vicare-typed.info,  Node: built-in ports labels textual,  Next: built-in ports labels binin,  Prev: built-in ports labels binary,  Up: built-in ports labels

6.23.8.5 Textual port labels
............................

 -- Label Type: <textual-port>
     Label-type for all the textual ports.  Its parent is the type
     annotation:

          (or <textual-input-only-port> <textual-output-only-port>
              <textual-input/output-port>)

 -- Constructor on '<textual-port>': <textual-port> type-constructor
          PORT
     Validate PORT as instance of '<textual-port>' and return it.

 -- Type predicate on '<textual-port>': <boolean> type-predicate OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<textual-port>': <boolean> equality-predicate
          THIS {PORT <textual-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<textual-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<textual-port>': <boolean> open? THIS
 -- Method on '<textual-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<textual-port>': () set-non-blocking-mode THIS
 -- Method on '<textual-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<textual-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<textual-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<textual-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<textual-port>': <non-negative-exact-integer> position
          THIS
 -- Method on '<textual-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<textual-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<textual-port>': (or <false> <file-descriptor>) fd THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<textual-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<textual-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<textual-port>': (or <transcoder> <false>) transcoder
          THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<textual-port>': () putprop THIS {KEY <symbol>} VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<textual-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<textual-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<textual-port>': (alist <symbol> <top>) property-list
          THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<textual-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<textual-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.


File: vicare-typed.info,  Node: built-in ports labels binin,  Next: built-in ports labels binou,  Prev: built-in ports labels textual,  Up: built-in ports labels

6.23.8.6 Binary input port labels
.................................

 -- Label Type: <binary-input-port>
     Label-type for all the binary ports.  Its parent is the type
     annotation:

          (or <binary-input-only-port> <binary-input/output-port>)

 -- Constructor on '<binary-input-port>': <binary-input-port>
          type-constructor PORT
     Validate PORT as instance of '<binary-input-port>' and return it.

 -- Type predicate on '<binary-input-port>': <boolean> type-predicate
          OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<binary-input-port>': <boolean>
          equality-predicate THIS {PORT <binary-input-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<binary-input-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<binary-input-port>': <boolean> open? THIS
 -- Method on '<binary-input-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<binary-input-port>': () set-non-blocking-mode THIS
 -- Method on '<binary-input-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<binary-input-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<binary-input-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<binary-input-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<binary-input-port>': <non-negative-exact-integer>
          position THIS
 -- Method on '<binary-input-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<binary-input-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<binary-input-port>': (or <false> <file-descriptor>) fd
          THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<binary-input-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<binary-input-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<binary-input-port>': (or <transcoder> <false>)
          transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<binary-input-port>': () putprop THIS {KEY <symbol>}
          VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<binary-input-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<binary-input-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<binary-input-port>': (alist <symbol> <top>)
          property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<binary-input-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<binary-input-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: input ports
....................

 -- Method on '<binary-input-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.


File: vicare-typed.info,  Node: built-in ports labels binou,  Next: built-in ports labels texin,  Prev: built-in ports labels binin,  Up: built-in ports labels

6.23.8.7 Binary output port labels
..................................

 -- Label Type: <binary-input-port>
     Label-type for all the binary ports.  Its parent is the type
     annotation:

          (or <binary-input-only-port> <binary-input/output-port>)

 -- Constructor on '<binary-input-port>': <binary-input-port>
          type-constructor PORT
     Validate PORT as instance of '<binary-input-port>' and return it.

 -- Type predicate on '<binary-input-port>': <boolean> type-predicate
          OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<binary-input-port>': <boolean>
          equality-predicate THIS {PORT <binary-input-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<binary-input-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<binary-output-port>': <boolean> open? THIS
 -- Method on '<binary-output-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<binary-output-port>': () set-non-blocking-mode THIS
 -- Method on '<binary-output-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<binary-output-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<binary-output-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<binary-output-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<binary-output-port>': <non-negative-exact-integer>
          position THIS
 -- Method on '<binary-output-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<binary-output-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<binary-output-port>': (or <false> <file-descriptor>) fd
          THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<binary-output-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<binary-output-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<binary-output-port>': (or <transcoder> <false>)
          transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<binary-output-port>': () putprop THIS {KEY <symbol>}
          VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<binary-output-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<binary-output-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<binary-output-port>': (alist <symbol> <top>)
          property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<binary-output-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<binary-output-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: output ports
.....................

 -- Method on '<binary-output-port>': () flush THIS
     Apply 'flush-output-port' to the instance.


File: vicare-typed.info,  Node: built-in ports labels texin,  Next: built-in ports labels texou,  Prev: built-in ports labels binou,  Up: built-in ports labels

6.23.8.8 Textual input port labels
..................................

 -- Label Type: <textual-input-port>
     Label-type for all the textual ports.  Its parent is the type
     annotation:

          (or <textual-input-only-port> <textual-input/output-port>)

 -- Constructor on '<textual-input-port>': <textual-input-port>
          type-constructor PORT
     Validate PORT as instance of '<textual-input-port>' and return it.

 -- Type predicate on '<textual-input-port>': <boolean> type-predicate
          OBJ
     The type predicate is built combining the parent types' type
     predicates.

 -- Equality predicate on '<textual-input-port>': <boolean>
          equality-predicate THIS {PORT <textual-input-port>}
     The equality predicate is 'eq?'.

 -- Type predicate on '<textual-input-port>': <non-negative-fixnum>
          hash-function THIS
     The hash function is 'port-hash'.

Methods: predicates
...................

 -- Method on '<textual-input-port>': <boolean> open? THIS
 -- Method on '<textual-input-port>': <boolean> closed? THIS
     Return '#t' if THIS is, respectively, open or closed; otherwise
     return '#f'.

Methods: configuration
......................

 -- Method on '<textual-input-port>': () set-non-blocking-mode THIS
 -- Method on '<textual-input-port>': () unset-non-blocking-mode THIS
     Apply 'port-set-non-blocking-mode!' or
     'port-unset-non-blocking-mode!' to the argument and return its
     return value.

 -- Method on '<textual-input-port>': <boolean> non-blocking-mode? THIS
     Apply 'port-in-non-blocking-mode?' to the argument and return its
     return value.

Methods: position
.................

 -- Method on '<textual-input-port>': <boolean> has-position? THIS
     Apply 'port-has-port-position?' to the argument and return its
     return value.

 -- Method on '<textual-input-port>': <boolean> has-set-position? THIS
     Apply 'port-has-set-port-position!?' to the argument and return its
     return value.

 -- Method on '<textual-input-port>': <non-negative-exact-integer>
          position THIS
 -- Method on '<textual-input-port>': () position THIS {POS
          <non-negative-exact-integer>}
     Apply 'port-position' or 'set-port-position!' to the arguments and
     return its return value.

Methods: inspection
...................

 -- Method on '<textual-input-port>': <string> id THIS
     Apply 'port-id!' to the argument and return its return value.

 -- Method on '<textual-input-port>': (or <false> <file-descriptor>) fd
          THIS
     Apply 'port-fd' to the argument and return its return value.

 -- Method on '<textual-input-port>': <gensym> uid THIS
     Apply 'port-uid' to the argument and return its return value.

 -- Method on '<textual-input-port>': () dump-status THIS
     Apply 'port-dump-status' to the argument and return its return
     value.

 -- Method on '<textual-input-port>': (or <transcoder> <false>)
          transcoder THIS
     Apply 'port-transcoder' to the argument and return its return
     value.

Methods: properties
...................

 -- Method on '<textual-input-port>': () putprop THIS {KEY <symbol>}
          VALUE
     Apply 'port-putprop' to the arguments and return its return value.

 -- Method on '<textual-input-port>': <top> getprop THIS {KEY <symbol>}
     Apply 'port-getprop' to the arguments and return its return value.

 -- Method on '<textual-input-port>': () remprop THIS {KEY <symbol>}
     Apply 'port-remprop' to the arguments and return its return value.

 -- Method on '<textual-input-port>': (alist <symbol> <top>)
          property-list THIS
     Apply 'port-property-list' to the arguments and return its return
     value.

Methods: miscellaneous
......................

 -- Method on '<textual-input-port>': () close THIS
     Apply 'port-close' to the argument.

 -- Method on '<textual-input-port>': <boolean> reset THIS
     Apply 'reset-input-port!' or 'reset-output-port!' to the argument.

Methods: input ports
....................

 -- Method on '<textual-input-port>': <boolean> eof? THIS
     Apply 'port-eof?' to the instance and return its return value.

