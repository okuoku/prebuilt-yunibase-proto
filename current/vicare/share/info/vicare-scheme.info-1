This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: Top,  Next: overview,  Up: (dir)

Vicare Scheme
*************

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.

* Menu:

* overview::                    Overview of Vicare Scheme.
* using::                       Using the program.
* scheme::                      The Scheme language.
* baselib::                     Base library.
* stdlib::                      Standard libraries.
* iklib::                       Language extensions.
* libutils::                    Scheme libraries utilities.
* progutils::                   Scheme programs utilities.
* includes::                    Loading include files.
* foreign::                     Interfacing with adapting foreign
                                libraries.
* ffi::                         Foreign functions interface.
* syslib::                      Low level, fast, unsafe operations.

Internals

* objects::                     Built in Scheme objects.
* debug int::                   Debug mode.
* expander::                    Expander internals.
* machinery::                   Introduction to execution machinery.
* compiler::                    Wild notes on the compiler internals.
* boot image::                  Anatomy of the boot image.

Appendices

* missing::                     Missing Features.
* building::                    Building infrastructure.
* credits::                     Credits for this document.
* dynamic environment::         Notes on the dynamic environment.
* resources::                   Allocating and releasing resources.
* unicode::                     On Unicode and UTF encodings.
* fasl::                        Handling FASL files.
* shmem::                       Interprocess shared memory.
* binfmt::                      Launching programs directly on GNU+Linux.
* file-magic::                  Installing 'file' magic file.
* notes::                       Miscellaneous notes on everything.
* Package License::             GNU General Public License.
* history::                     History.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* types: (vicare-typed).        The typed language.
* libs: (vicare-libs).          Bundled libraries for Vicare Scheme.
* libffi: (libffi).             Libffi documentation.


File: vicare-scheme.info,  Node: overview,  Next: using,  Prev: Top,  Up: Top

1 Overview of Vicare Scheme
***************************

Scheme is a statically scoped and properly tail-recursive dialect of the
Lisp programming language invented by Guy Lewis Steele Jr.  and Gerald
Jay Sussman.  It was designed to have an exceptionally clear and simple
semantics and few different ways to form expressions.

   The "Revised^6 Report on the Algorithmic Language Scheme" (R6RS)
gives a defining description of the programming language Scheme.  The
report is the work of many people in the course of many years; revision
6 was edited by Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   Ikarus Scheme is an almost R6RS compliant implementation of the
Scheme programming language; it is the creation of Abdulaziz Ghuloum.

   Vicare Scheme is an R6RS compliant fork of Ikarus Scheme, aiming at
becoming a native compiler producing single threaded programs running on
Intel x86 32-bit and 64-bit processors.  _Vicare_ is pronounced the
etruscan way.

* Menu:

* overview original::           Original Ikarus Scheme.
* overview tech::               Technology overview.
* overview resources::          Resources.
* overview system::             System requirements.
* overview install::            Installation and uninstallation.
* overview restrictions::       Implementation restrictions.
* overview extensions::         Implementation extensions.
* overview repl::               The read-eval-print loop.
* overview foreign::            Built in interface to external
                                libraries.


File: vicare-scheme.info,  Node: overview original,  Next: overview tech,  Up: overview

1.1 Original Ikarus Scheme
==========================

The original Ikarus Scheme package is distributed under the terms of the
GNU General Public License (GPL) and can be downloaded from:

                    <http://www.ikarus-scheme.org/>

or:

                    <https://launchpad.net/ikarus>

   It was developed by Abdulaziz Ghuloum until the beginning of year
2010; at that time the Vicare fork was started.


File: vicare-scheme.info,  Node: overview tech,  Next: overview resources,  Prev: overview original,  Up: overview

1.2 Technology overview
=======================

Vicare Scheme provides the programmer with many advantages:

*Optimizing code generator*
     The compiler's backend employs state of the art technologies in
     code generation that produce fast, efficient, machine code.  When
     developing computationally intensive programs, one is not
     constrained by using a slow interpreter.

*Fast incremental compilation*
     Every library and script is quickly compiled to native machine
     code.  When developing large software, one is not constrained by
     how slow the batch compiler runs.

*Robust and fine-tuned standard libraries*
     The standard libraries are written such that they perform as much
     error checking as required to provide a safe and fast runtime
     environment.

*Multi-generational garbage collector*
     The BiBOP based garbage collector used in Vicare allows the runtime
     system to expand its memory footprint as needed.  The entire 32-bit
     virtual address space could be used and unneeded memory is released
     back to the operating system.

*Supports many operating systems*
     Vicare runs on GNU+Linux; it should work on POSIX platforms, but
     not on Cygwin.


File: vicare-scheme.info,  Node: overview resources,  Next: overview system,  Prev: overview tech,  Up: overview

1.3 Resources
=============

The Vicare Scheme package is distributed under the terms of the GNU
General Public License (GPL) and can be downloaded from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

              <http://marcomaggi.github.com/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

   Newcomers to Scheme should refer to <http://www.schemers.org>, which
contains listings of tutorials and books that are helpful in learning
the language.

   This document is a supplement to the _Revised^6 Report on the
Algorithmic Language Scheme_, found at <http://www.r6rs.org>.  Kent
Dybvig's _The Scheme Programming Language_, Fourth Edition, is an
excellent tutorial and reference for R6RS.  Some extended features of
Vicare have been inspired by similar features in _Chez Scheme_; the
_Chez Scheme User's Guide_ can be found at the same site.


File: vicare-scheme.info,  Node: overview system,  Next: overview install,  Prev: overview resources,  Up: overview

1.4 System requirements
=======================

To run Vicare Scheme, we will need a system with a relatively recent
Intel _x86_ processor; Vicare requires a Unix/Linux operating system (or
emulation), and some prerequisite libraries.

* Menu:

* overview system hardware::    Hardware requirements.
* overview system software::    Software requirements.


File: vicare-scheme.info,  Node: overview system hardware,  Next: overview system software,  Up: overview system

1.4.1 Hardware requirements
---------------------------

Vicare Scheme runs on the IA-32 (_x86_) architecture supporting SSE2
extensions.  This includes the Athlon 64, Sempron 64, and Turion 64
processors from AMD and the Pentium 4, Xeon, Celeron, Pentium M, Core,
and Core2 processors from Intel.  The system does not run on Intel
Pentium III or earlier processors.

   The Vicare compiler generates SSE2 instructions to handle Scheme's
IEEE floating point representation (_flonums_) for inexact numbers.


File: vicare-scheme.info,  Node: overview system software,  Prev: overview system hardware,  Up: overview system

1.4.2 Software requirements
---------------------------

We will need some additional libraries and tools to build Vicare Scheme.

*GMP*
     Vicare uses the GNU Multiple Precision Arithmetic Library (GMP) for
     some bignum arithmetic operations.  To build Vicare from scratch,
     GMP version 4.2 or better must be installed along with the required
     header files.  Pre-built GMP packages are available for most
     operating systems.  Alternatively, GMP can be downloaded from
     <http://gmplib.org/>.

     The GMP web page points out that GMP has revealed subtle bugs in
     many C compilers.  Although the GMP build process includes a
     comprehensive self-test (which we absolutely must run if building
     it ourselves), we may still prefer to obtain a prebuilt binary
     version for our system, if one is available.

          *NOTE* Vicare runs in 32-bit mode only.  To run it in 64-bit
          environments, we will have to obtain the 32-bit version of
          GMP, or compile it ourselves after adding 'ABI=32' to its
          configuration options.

*libffi*
     We will probably need 'libffi', a C library that simplifies
     run-time calls to arbitrary C functions.  Vicare will operate
     without 'libffi', but will not be able to call foreign procedures
     (those written in C). 'libffi' can be downloaded from
     <http://sourceware.org/libffi>.

*GCC*
     The GNU C Compiler is required to build the Vicare executable (e.g.
     the garbage collector, loader, and OS-related runtime).  GCC
     versions 4.1 and 4.2 were successfully used to build Vicare.  It
     may be possible to build Vicare using other C compilers.

*Autoconf and Automake*
     The GNU Autoconf (version 2.61) and GNU Automake (version 1.10)
     tools are required if one wishes to modify the Vicare source base.
     They are not required to build the official release of Vicare.

     Prebuilt packages for these tools have been created for most
     Unix/Linux systems; if we prefer, we can download the source code
     from <http://www.gnu.org/software/autoconf> and
     <http://www.gnu.org/software/automake> respectively, and build them
     ourselves.

*Texinfo*
     This document is provided in Texinfo format.  Texinfo is available
     as an installable package for most Unix/Linux systems.
     Alternatively, we can download the source package
     <http://www.gnu.org/software/texinfo>.


File: vicare-scheme.info,  Node: overview install,  Next: overview restrictions,  Prev: overview system,  Up: overview

1.5 Installation and uninstallation
===================================

There are two ways to install Vicare Scheme on our system: we can either
install a prebuilt package, if one is available for our operating
system, or we can build it from source.  There are two reasons to prefer
the "build from source" approach: first, not all Unix/Linux package
repositories have an Vicare Scheme package at all; second, prebuilt
packages often lag current revisions to the system by a considerable
amount.  Therefore, the version we install from a package repository
might not even have some of the features documented in this manual.

   We will assume in this section that we are building Vicare Scheme
ourselves.  Vicare uses the standard installation method found in most
other Unix software.  Thus we will follow the usual steps.

  1. Download the software.

  2. Set configuration options.

  3. Build and install

* Menu:

* overview install quick::              Quick installation guide.
* overview install prerequisites::      Installing the prerequisites.
* overview install details::            Installation details.
* overview install uninstall::          Uninstalling Vicare.


File: vicare-scheme.info,  Node: overview install quick,  Next: overview install prerequisites,  Up: overview install

1.5.1 Quick installation guide
------------------------------

If familiar with installing Unix software on our system, then all we
need to know is that Vicare uses the standard installation method found
in most other Unix software.  Simply run the following commands from the
shell:

     $ tar -xvzf vicare-n.n.n.tar.gz
     $ cd vicare-n.n.n
     $ ./configure [--prefix=path] [CFLAGS=-I/dir] [LDFLAGS=-L/dir]
     $ make
     $ make install

*note overview install details:: for how to enable the foreign functions
interface.

   After installation, under the directory '$libexecdir/vicare-scheme',
scripts with names like 'compile-all.sps' can be executed to precompile
the installed libraries; for example:

     $ sudo vicare --compile-dependencies \
        /usr/local/libexec/vicare-scheme/compile-all.sps

   To uninstall Vicare Scheme, use the following steps:

     $ cd path/to/vicare-n.n.n
     $ make uninstall

   The rest of this section gives more detail on building, installing,
and uninstalling Vicare Scheme.


File: vicare-scheme.info,  Node: overview install prerequisites,  Next: overview install details,  Prev: overview install quick,  Up: overview install

1.5.2 Installing the prerequisites
----------------------------------

The first step is to ensure that we have GMP and Libffi installed; we
should generally use our system's package manager for these.  Note where
the include ('.h') and library ('.a') files for each of these packages
are installed.  (Typically this will be in either '/usr/include' and
'/usr/lib', or '/usr/local/include' and '/usr/local/lib'.)

   If we choose to download these as source and build them ourselves,
refer to the installation instructions found in each package.  If we are
installing GMP from source, it is _essential_ that we run the self-tests
after building, and verify that no errors were detected.  We do this by
issuing the command 'make check'; see the documentation for details.


File: vicare-scheme.info,  Node: overview install details,  Next: overview install uninstall,  Prev: overview install prerequisites,  Up: overview install

1.5.3 Installation details
--------------------------

We have two choices for downloading the Vicare Scheme source: we can
either download a distribution from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

or we can checkout a revision from the GitHub repository:

                <http://github.com/marcomaggi/vicare/>

   * Vicare Scheme source distributions are tarballs named
     'vicare-N.N.N.tar.gz', where 'N.N.N' is a 3-component ID indicating
     the current revision.

     If we downloaded a distribution, unpack it.  From the shell prompt:

          $ tar -xvzf vicare-N.N.N.tar.gz

     this creates the base directory 'vicare-N.N.N'.

   * If we downloaded a bleeding-edge snapshot, no unpacking is needed.

   We configure the build system by running the 'configure' script
located in the base directory.  To do this, type the following commands:

     $ cd vicare-N.N.N
     $ ./configure
     checking build system type... i386-apple-darwin8.10.1
     checking host system type... i386-apple-darwin8.10.1
     ...
     configure: creating ./config.status
     config.status: creating Makefile
     config.status: creating src/Makefile
     config.status: creating scheme/Makefile
     config.status: creating doc/Makefile
     config.status: executing depfiles commands

   This configures the system to be built then installed in the
system-wide location (binaries are normally installed in
'/usr/local/bin').  To install it in another location (e.g.  in your
home directory), provide a '--prefix' location to 'configure' as
follows:

     $ ./configure --prefix=/opt/sw

this will install the executable in '/opt/sw/bin', libraries in
'/opt/sw/lib/ikarus', and documentation in '/opt/sw/share/doc/ikarus'.

   To install Vicare Scheme for personal use (thus not requiring root
permissions to install), specify '--prefix=$HOME/local', which installs
everything in a 'local' directory of our home directory.

   'configure' allows us to fine-tune where things are installed, though
this is rarely necessary or useful.  Do './configure --help' for a full
list of options.

   The most common 'configure' options are as follows.

'--prefix'
     Specify the location in the file system where Vicare Scheme will be
     installed.

'--enable-ffi'
     Include Vicare Scheme's Foreign Function Interface, so that Vicare
     code can invoke C code, and vice versa; requires Libffi.

'--disable-arguments-validation'
     Disable arguments validation for the functions in Vicare's boot
     image; use with care: an invalid argument will cause undefined
     behaviour (most likely a process crash).

     This setting can be overridden by setting the environment variable
     'VICARE_ARGUMENTS_VALIDATION'; *note Enabling or disabling
     arguments validation: (vicare-libs)args config. for details.

'CFLAGS'
     Specify options to be used while compiling Vicare's C code.

'CPPFLAGS'
     Specify options to be used while preprocessing Vicare's C code.

'LDFLAGS'
     Specify options to be used while linking Vicare.

   'configure' will fail if it cannot find the location where GMP is
installed.  The script will also fail if we have specified
'--enable-ffi' and it can't find Libffi.  If running 'configure' fails
to locate either of these libraries, we will need to provide their
locations.  Use the 'CPPFLAGS' and 'LDFLAGS' options to specify the
locations of the header and library files.

   For example, assume that we have installed GMP and Libffi in
subdirectories of '/opt/sw', and we wish to support foreign
functions.(1)

     ./configure                                                  \
       --prefix=$HOME/local                                       \
       --enable-ffi                                               \
       CPPFLAGS="-I/opt/sw/gmp/include -I/opt/sw/libffi/include"  \
       LDFLAGS="-L/opt/sw/gmp/lib -L/opt/sw/libffi/lib"

   We can use the 'CFLAGS' and 'LDFLAGS' variables to select more
specialized compilation and linking options; refer to the compiler
documentation for more details.

   We can now build the system by running the command 'make', with no
arguments; this performs two tasks:

  1. It builds the 'vicare' executable from the C files located in the
     'src' directory.

  2. It uses the 'vicare' executable and the pre-built
     'ikarus.boot.orig' boot file to rebuild the Scheme boot image file
     'vicare.boot' from the Scheme sources located in the 'scheme'
     directory.

   The final stage is to install Vicare via the command 'make install'.
If we're installing Vicare in a system-wide location, we probably need
to have administrator privileges (use the 'sudo' or 'su' commands); if
that's not feasible, then we need to reconfigure to install within a
directory tree under our home directory.

   Finally, try a small session, to verify that everything installed
properly.

     $ vicare
     Vicare Scheme version 0.1d0+ \
       (revision master/d844c006eb9ada1a047be3893d0dd40f8ae6204a, \
       build 2010-05-02)
     Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors

     > (display "hello, world!\n")
     hello, world!
     > (define twice (lambda (f) (lambda (x) (f (f x)))))
     > ((twice add1) 3)
     5

   If we get the first '>' prompt, then Vicare was successfully
installed on the system.  We may need to update the 'PATH' variable in
environment to contain the directory in which the 'vicare' executable
was installed.

   Finally, do 'make clean' to get rid of executables, object files, and
other build products in the 'vicare-N.N.N' directory.  Do not delete the
directory itself: it will be needed if we ever want to uninstall Vicare.

   After installation, under the directory '$libexecdir/vicare-scheme',
scripts with names like 'compile-all.sps' can be executed to precompile
the installed libraries; for example:

     $ sudo vicare --compile-dependencies \
        /usr/local/libexec/vicare-scheme/compile-all.sps

   ---------- Footnotes ----------

   (1) The 'configure' command shown here is very imposing, and anyone
can easily make mistakes.  In general, it's a good idea to create a
shell script that has the sequence of 'configure' and 'make' commands
needed to configure, build, and install a package; this not only allows
us to re-install easily, but also gives us a concrete indication of what
options we used to build the software the last time.  Of course, we
should put this script somewhere other than in the actual Vicare
software directory!


File: vicare-scheme.info,  Node: overview install uninstall,  Prev: overview install details,  Up: overview install

1.5.4 Uninstalling Vicare
-------------------------

To uninstall Vicare Scheme, go to the directory we built Vicare in (not
the directory where you installed it), and do 'make uninstall'.

     $ cd path/to/vicare-N.N.N
     $ make uninstall


File: vicare-scheme.info,  Node: overview restrictions,  Next: overview extensions,  Prev: overview install,  Up: overview

1.6 Implementation restrictions
===============================

Here is a list of implementation constraints which may be non-compliant
with R6RS.

  1. Scheme strings can hold at most '(greatest-fixnum)' characters; the
     length of a string and all the valid indexes into strings are
     representable as fixnums.

  2. Scheme bytevectors can hold at most '(greatest-fixnum)' bytes; the
     length of a bytevector and all the valid indexes into bytevectors
     are representable as fixnums.

  3. The last argument to 'apply' can be a list of at most 8192 values.
     This is an artificially set limit to avoid problems with huge
     values (it could be greater than this).  As comparison: LispWorks
     for Unix sets this value to 300, LispWorks for Windows and
     LispWorks for Linux set this value to 255 (last verified from its
     online documenattion in November, 2011).

  4. R6RS mandates that illegal references to bindings established by
     'letrec' and 'letrec*' are detected at run time and cause an
     assertion violation to be raised.  Vicare detects them at
     compile-time, so some fully R6RS-compliant code will not work under
     Vicare.

     For example, the following program will run under a R6RS-compliant
     implementation:

          (import (rnrs))
          (letrec ((x (if (eq? (cons 1 2)
                               (cons 1 2))
                          x
                        1)))
            x)

     because the form 'x' in reference position in the right-hand side
     of the binding is never evaluated; under Vicare this code will
     rather raise a syntax violation at compile time.

  5. The following functions accept only non-negative fixnums as offset
     argument:

          bitwise-arithmetic-shift-left
          bitwise-arithmetic-shift-right

  6. The function 'bitwise-arithmetic-shift' accepts only fixnums as
     offset argument.


File: vicare-scheme.info,  Node: overview extensions,  Next: overview repl,  Prev: overview restrictions,  Up: overview

1.7 Implementation extensions
=============================

Here is a list of implementation extensions which may be non-compliant
with R6RS.

  1. According to R6RS: if the parent of a record type has a custom
     protocol function, the record type itself must have a custom
     protocol function; that is:

          (import (rnrs))

          (define-record-type alpha
            (fields a)
            (protocol (lambda (A) ---)))

          ;; this is good
          (define-record-type beta
            (parent alpha)
            (fields b)
            (protocol (lambda (A B) ---)))

          ;; this is bad according to R6RS!!!
          (define-record-type gamma
            (parent alpha)
            (fields b))

     This restriction is violated by Vicare, which allows the following:

          (import (rnrs))

          (define-record-type alpha
            (fields a)
            (protocol (lambda (A) ---)))

          ;; this is good in Vicare!!!
          (define-record-type beta
            (parent alpha)
            (fields b))

     Vicare just expects the parent protocol function to have the same
     interface of a default protocol function.

  2. If 'vicare' is run *without* the option '--strict-r6rs': the syntax
     'define-record-type' automatically generates unsafe field accessor
     and mutator syntaxes; in the following example:

          (define-record-type color
            (fields (mutable red)
                    (mutable green)
                    (mutable blue)))

     in addition to the safe accessor and mutator definitions for:

          color-red           color-red-set!
          color-green         color-green-set!
          color-blue          color-blue-set!

     unsafe accessors and mutator definitions for:

          $color-red          $color-red-set!
          $color-green        $color-green-set!
          $color-blue         $color-blue-set!

     are generated with code like:

          (define-syntax $color-red
            (syntax-rules ()
              ((_ x)
               ($struct-ref x 0))))

          (define-syntax $color-red-set!
            (syntax-rules ()
              ((_ x v)
               ($struct-set! x 0 v))))

     Notice that the name of the unsafe accessors and mutators is always
     built from the field name, *not* from the custom names given in the
     definition; for example:

          (import (rnrs))

          (define-record-type color
            (fields (mutable red   the-red   set-the-red!)
                    (mutable green the-green set-the-green!)
                    (mutable blue  the-blue  set-the-blue!)))

          (define X
            (make-color 1 2 3))

          (define Y
            (make-color 1 2 3))

          (set-the-red!   X 10)
          (set-the-green! X 20)
          (set-the-blue!  X 30)
          (list (the-red   X)
                (the-green X)
                (the-blue  X)))
          => (10 20 30)

          ($color-red-set!   Y 10)
          ($color-green-set! Y 20)
          ($color-blue-set!  Y 30)
          (list ($color-red   Y)
                ($color-green Y)
                ($color-blue  Y)))
          => (10 20 30)

  3. R6RS records can be automatically finalised whenever the garbage
     collector reclaims them.  It is possible to register a destructor
     function in the R6RS record-type descriptor; whenever a record is
     instantiated and its record-type descriptor has a destructor
     function: the record is registered in an internal guardian.  The
     guardian has an associated post garbage collection hook which
     applies the destructor to the record.  *note iklib records final::
     for details.


File: vicare-scheme.info,  Node: overview repl,  Next: overview foreign,  Prev: overview extensions,  Up: overview

1.8 The read-eval-print loop
============================

Scheme implementations compliant with R6RS live in a somewhat uneasy
tension with a standard Scheme REPL (read-eval-print loop), which the
Report effectively does not define.

   In particular, the effect of reimporting a module, as you might do
when reloading and rerunning a program, isn't well-defined by R6RS.
This is a limitation caused by the particular design choices made in
R6RS.

   Accordingly, the interactive mode is intended for quick experimenting
with the built in features.  It is intended neither for developing
applications nor for writing any substantial piece of code.


File: vicare-scheme.info,  Node: overview foreign,  Prev: overview repl,  Up: overview

1.9 Built in interface to external libraries
============================================

Vicare comes with some interface to external libraries built into the
'vicare' C language executable itself; this is done only for some
particular libraries which especially benefit from a dedicated interface
inconvenient to implement with the FFI.  At the Scheme level the API is
exported by libraries *not* included in Vicare's boot image.

   Such interfaces are excluded by default, they must be explicitly
requested at installation-time with command line options for the
'configure' script.

* Menu:

* overview foreign readline::   Interface to GNU Readline.


File: vicare-scheme.info,  Node: overview foreign readline,  Up: overview foreign

1.9.1 Interface to GNU Readline
-------------------------------

GNU Readline is a library implementing advanced command line editing
features for programs providing a REPL interface.  When given the
'--with-readline' configuration option, the 'configure' script will
search for GNU Readline or a compatible library and, if found, the
interface will be enabled.  *note iklib readline:: for the API
documentation.

   The home page of GNU Readline is at:

                <http://www.gnu.org/software/readline/>

a compatible alternative is Editline:

                    <http://www.s11n.net/editline/>

and another possible replacement is Libedit:

              <http://sourceforge.net/projects/libedit/>


File: vicare-scheme.info,  Node: using,  Next: scheme,  Prev: overview,  Up: Top

2 Using Vicare
**************

Once Vicare Scheme is properly installed, we can invoke it either in an
interactive terminal session or as the interpreter for invoking a
script.

* Menu:

* using interactive::           Interactive sessions.
* using invoking::              Command line arguments.
* using scripts::               Executing Scheme scripts.
* using libraries::             R6RS libraries and extensions.
* using programs::              Compiling Scheme programs.
* using rlwrap::                Using 'rlwrap'.


File: vicare-scheme.info,  Node: using interactive,  Next: using invoking,  Up: using

2.1 Interactive sessions
========================

If we want an interactive session, use a bare 'vicare' command, with no
options.

     $ vicare
     Vicare Scheme version 0.3d0
     Revision devel/a59ec3abedf0a80e07d011269ba9aeb134227e41
     Build 2013-04-13

     Copyright (c) 2011-2016 Marco Maggi
     Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors

     vicare> (+ 2 2)
     4

end-of-file (<Ctrl-D> in a typical terminal window) will terminate the
session.


File: vicare-scheme.info,  Node: using invoking,  Next: using scripts,  Prev: using interactive,  Up: using

2.2 Command line arguments
==========================

The synopsis of the executable program 'vicare' is as follows:

     vicare [OPTIONS] [PROGRAM]              [-- [PROGOPTS]]
     vicare [OPTIONS] --r6rs-script     FILE [-- [PROGOPTS]]
     vicare [OPTIONS] --binary-program  FILE [-- [PROGOPTS]]
     vicare [OPTIONS] --compile-program PROGFILE
     vicare [OPTIONS] --compile-library LIBFILE
     vicare [OPTIONS] --compile FILE
     vicare [OPTIONS] --compile-dependencies PROGRAM

the OPTIONS are interpreted by 'vicare', PROGOPTS can be obtained using
the 'command-line' procedure in the '(rnrs programs)' library; when
running the REPL: the first element of the returned list will be the
string '*interactive*', corresponding to the script name in R6RS-script
mode.

   The 'vicare' executable recognises a few command line switches that
influence how Vicare Scheme starts; the following are the main options,
driving the execution mode.  It is an error to put on the command line
two or more of these options.

'--r6rs-script PROGRAM'
     Start Vicare in R6RS-script mode.  The PROGRAM file is handled as
     an R6RS program.  Example:

          $ cat test.sps
          (import (rnrs))
          (write (command-line))
          (newline)
          (flush-output-port (current-output-port))

          $ vicare --r6rs-script test.sps -- hi there
          ("test.sps" "hi" "there")

'--binary-program PROGRAM'
     Start Vicare in compiled-program mode.  The PROGRAM file is handled
     as a serialised R6RS binary program: it is loaded and executed.

'--compile-program PROGRAM'
     Load the source R6RS program PROGRAM, compile it and store a
     serialised version of it into an output file.  PROGRAM itself is
     not evaluated.

     If the option '--output' is used: its value is the pathname of the
     output file; otherwise the output file pathname is built from
     PROGRAM and the binary file is placed in the same directory of the
     source.

     If the option '--library-locator' is not used: using
     '--compile-program' will automatically select the compile-time
     library locator.

'--compile-dependencies IMPORTS-FILE'
     Load the R6RS program IMPORTS-FILE, compile all the libraries upon
     which it depends and store them in the build directory selected by
     '--build-directory'.  IMPORTS-FILE itself is not evaluated.

     If the option '--library-locator' is not used: using
     '--compile-dependencies' will automatically select the compile-time
     library locator.

'--compile-library LIBFILE'
     Load the R6RS library source LIBFILE, compile it and serialise it
     in an output file.

     If the option '--output' is used: its value is the pathname of the
     output file; otherwise the output pathname is automatically
     generated under the build directory selected by
     '--build-directory'.

     If the option '--library-locator' is not used: using
     '--compile-library' will automatically select the compile-time
     library locator.

'-c FILE'
'--compile FILE'
     Load the selected FILE and recognise it as program or library by
     the file extension ('.sps' or '.sls'); the behave as if the option
     '--compile-program' or '--compile-library' had been given.

   When none of these options is given, but a standalone PROGRAM
argument is present on the command line: act as if the option
'--r6rs-script' is present with the given file name.

   If no standalone PROGRAM argument is present: enter the REPL.  When
neither the option '--rcfile' nor the option '--no-rcfile' is used:
before entering the REPL, the default run-command file '~/.vicarerc' is
loaded.

   The rest of the command line arguments are recognised by the standard
Scheme run time system.

'-b path/to/boot/file.boot'
'--boot path/to/boot/file.boot'
     Use the specified boot file as the initial system boot file.  The
     boot file is a binary file that contains all the code and data of
     the Scheme system.  In the absence of the '-b' flag, the executable
     will use the default boot file.  Running 'vicare' with the '-h'
     option shows the location where the default boot file was
     installed.

'--no-rcfile'
     Disable loading of run-command files.

'--rcfile FILE'
     Load and evaluate FILE as an R6RS program at start up, before
     loading libraries and running the main program.  This option can be
     used multiple times.

     When the execution mode is to enter the REPL: using this option
     disables loading the default file '~/.vicarerc'; only the selected
     FILE scripts are loaded.

'-o OFILE'
'--output OFILE'
     Select the pathname of an output file.  This selection has multiple
     purposes and it is ignored when irrelevant.  OFILE is used as:
     output FASL file name when compiling individual library files;
     output FASL file name when compiling program files.

'-l LIBFILE'
'--load-library LIBFILE'
     Load the source file LIBFILE expecting it to contain one or more
     R6RS libraries; after executing the RC files, load the libraries in
     the internal collection, but do not add them to any environment.
     This option can be used multiple times.

'--A DIRECTORY'
'--source-path DIRECTORY'
     Append DIRECTORY to the source libraries search path.  This option
     can be used multiple times.

'-I DIRECTORY'
     Prepend DIRECTORY to the source libraries search path.  This option
     can be used multiple times.

'-L DIRECTORY'
'--library-path DIRECTORY'
     Add DIRECTORY to the binary libraries search path.  This option can
     be used multiple times.

'--library-locator NAME'
     Select a Scheme library locator.  NAME can be one among:
     'run-time', 'compile-time', 'source'.  For details on searching
     libraries *note Library search algorithms: using libraries
     searching.  For details on the built-in library locators API *note
     Locating libraries: libutils locating.

'--build-directory DIRECTORY'
     Select DIRECTORY as pathname under which compiled library files are
     temporarily stored before being installed.  When used multiple
     times: the last one wins.

'--more-file-extensions'
     Rather than searching only libraries with extension '.vicare.sls'
     and '.sls', search also for '.vicare.ss', '.ss', '.vicare.scm',
     '.scm' and the 'main' file.  *note using libraries searching:: for
     more details.

'--prompt STRING'
     Use STRING as prompt for the REPL.  Defaults to 'vicare', to which
     the character '>' is appended for each nested REPL level.  *note
     iklib cafe:: for more details.

'--repl-on-sigint'
     When this option is used an interprocess signal handler is
     registered at program start up to enter a debugging REPL whenever a
     'SIGINT' signal is received.

'--raw-repl'
     Do not create a readline console input port even if the readline
     interface is available.

'-d'
'-g'
     Turn on debugging mode.  With this option: unhandled exceptions in
     the program will result in starting the debugger, which allows
     stack trace inspection.

'--option OPTION-NAME'
     Turn on or off compiler and expander options; OPTION-NAME must be a
     string among:

     'strict-r6rs'
     'no-strict-r6rs'
          The first option causes Vicare to strictly follow R6RS
          specifications, disabling extensions.  The default is to
          enable extensions.

     'debug'
     'no-debug'
          Turn on or off debugging mode.  With this option: unhandled
          exceptions in the program will result in starting the
          debugger, which allows stack trace inspection.  Using
          '--option debug' is equivalent to using the options '-d' and
          '-g'.

     'drop-assertions'
     'no-drop-assertions'
          The first option causes every 'assert' macro to be expanded
          into its expression, dropping the assertions.  The second
          option expands uses of the 'assert' syntax as full assertions;
          this is the default.

          Specifically, when 'drop-assertions' is used:

               (assert ?EXPR)

          is expanded into:

               ?EXPR

          so that side effects in ?EXPR are performed and the resulting
          value is returned.  The default is to include the full
          assertion.

     'check-compiler-pass-preconditions'
     'no-check-compiler-pass-preconditions'
          The first option enables performing additional compiler passes
          to validate generated code.  To be used when debugging
          Vicare's compiler.  The default is *not* to perform such
          compiler passes.

     'gc-integrity-checks'
     'no-gc-integrity-checks'
          The first option enables garbage collection integrity checks.
          This slows down the garbage collection.  The default is to
          disable garbage collection integrity checks.

     'print-assembly'
          Print to the current error port the assembly instructions
          generated when compiling code.

     'print-optimizer'
     'print-optimiser'
          Print to the current error port a symbolic expression which
          results from running the optimiser.

     'print-loaded-libraries'
     'no-print-loaded-libraries'
          Whenever a library file is loaded: the first option causes a
          message to be printed on the console error port.  This is for
          debugging purposes.  When used together with
          'library-debug-messages': even more detailed messages are
          generated for library related actions.

     'debug-messages'
     'no-debug-messages'
          Be more verbose about undertaken actions.  This is for
          debugging purposes.

     'library-debug-messages'
     'no-library-debug-messages'
          Be more verbose about undertaken library-related actions.
          This is for debugging purposes.

     'expander-descriptive-gensyms'
          Instruct the expander to generate descriptive lexical and
          storage location gensyms.

     'expander-descriptive-marks'
          Instruct the expander to generate descriptive mark objects.

     'compiler-descriptive-labels'
          Instruct the compiler to generate descriptive labels.

     'compiler-core-type-inference'
     'no-compiler-core-type-inference'
          Instruct the compiler to perform core type inference or not;
          the default is to perform it.  Disabling core type inference
          automatically disables substitution of core primitive calls
          with unsafe core primitive calls.

     'compiler-introduce-primrefs'
     'no-compiler-introduce-primrefs'
          Instruct the compiler to perform substitution between core
          primitive calls and unsafe core primitive calls, when the
          correctness of the operand is determined at compile-time; the
          default is to perform it.

     'enable-automatic-gc'
     'disable-automatic-gc'
          Enable or disable automatic garbage collection.  When
          automatic garbage collection is disabled:

             * Memory allocation for Scheme objects is performed by
               enlarging, when needed, the Scheme heap's nursery.

             * We can still run garbage collection by explicitly
               invoking 'collect' (*note collect: iklib gc.).

          We can programmatically change this setting with
          'automatic-garbage-collection' (*note
          automatic-garbage-collection: iklib gc.).

     'enable-runtime-messages'
     'disable-runtime-messages'
          Enable or disable printing to the standard error file
          descriptor some debugging messages from the C language
          run-time program.

     'basic-letrec-pass'
     'waddell-letrec-pass'
     'scc-letrec-pass'
          Select which algorithm to use when optimising 'letrec' and
          'letrec*' syntaxes.  Accepted values: 'scc', 'waddell',
          'basic'.  Defaults to 'scc'.

'-Wall'
     Enable all the expander and compiler common warnings.  It is
     equivalent to using the following options:

          -Wlogic-constants -Wnot-returning -Wunused-variables

'-Wextra'
     Enable all the expander and compiler extra warnings.  It is
     equivalent to using the following options:

          -Woverloaded-function-late-binding

'-Wlogic-constants'
'-Wno-logic-constants'
     Enable or disable raising a '&warning' exception when an operand in
     a logic expression ('if' test, 'and', 'or', ...) always returns
     false or non-false.  By default this warning is disabled.

'-Wnot-returning'
'-Wno-not-returning'
     Enable or disable raising a '&warning' exception when an operand
     evaluated for its return values is typed as not returning.  By
     default this warning is disabled.

'-Wunused-variables'
'-Wno-unused-variables'
     Enable or disable raising a '&warning' exception when a local
     lexical variable is defined but never used.  By default this
     warning is disabled.

'-Woverloaded-function-late-binding'
'-Wno-overloaded-function-late-binding'
     Enable or disable raising a '&warning' exception when an overloaded
     function has to default to late binding because the early binding
     code was unable to find a matching specialised function.  By
     default this warning is disabled.

'--scheme-heap-nursery-size NUM-OF-BYTES'
     Configure the Scheme heap's nursery hot memory block size.  The
     value NUM-OF-BYTES must be a positive exact integer fitting a
     'signed long' data type, greater than 3 Vicare's page sizes, 4096 *
     3 = 12288.  The given NUM-OF-BYTES value is normalised by rounding
     it to the least exact multiple of 4096 greater than NUM-OF-BYTES.

'--scheme-stack-size NUM-OF-BYTES'
     Configure the Scheme stack size.  The value NUM-OF-BYTES must be a
     positive exact integer fitting a 'signed long' data type, greater
     than 3 Vicare's page sizes, 4096 * 3 = 12288.  The given
     NUM-OF-BYTES value is normalised by rounding it to the least exact
     multiple of 4096 greater than NUM-OF-BYTES.

'-O0'
     Disable the use of the compiler's source optimiser.

'-O1'
'-O2'
'-O3'
     Enable the use of the compiler's source optimiser at various
     levels.  The default optimisation level is equivalent to '-O2'.

'--optimizer-passes-count COUNT'
     Specify how many passes to perform with the source optimizer.  Must
     be a positive fixnum.  Defaults to 1.

'-V'
'--version'
     Display the version message then exit.

'--version-only'
     Display only the version number on the standard error port,
     followed by a newline, then exit.

'--license'
     Display the license message then exit.

'-h'
'--help'
     Display the help message then exit.

'--'
     Mark the end of 'vicare' options; all the arguments after this
     marker can be obtained by calling the 'command-line' procedure.

'-v'
'--verbose'
     Turn on verbose messages describing expander and compiler
     operations.

'--silent'
     Turn off verbose messages describing compiler operations.


File: vicare-scheme.info,  Node: using scripts,  Next: using libraries,  Prev: using invoking,  Up: using

2.3 Executing Scheme scripts
============================

Scheme scripts can be executed using the following command:

     vicare --r6rs-script PROGRAM

or the shorter:

     vicare PROGRAM

   Vicare Scheme follows the R6RS recommendations to install a wrapper
program called 'scheme-script' only when the 'configure' option
'--enable-scheme-script' is used at package configuration time; this is
to avoid conflicts with other Scheme implementations.  In this scenario,
it is possible to execute Scheme scripts as follows:

     scheme-script PROGRAM [program options]

where the optional program options can be retrieved with 'command-line',
*note command-line: stdlib programlib.  When using 'scheme-script' it is
impossible to select command arguments to be passed to Vicare rather
than to the script.

   Here is a sample script (Pig Latin--"Igpay Atinlay"--is a code that
was at one time popular among very young North American children).

     (import (rnrs))

     ;;; Convert a string to its Pig Latin equivalent.
     ;;;
     ;;; If the first character is a vowel, append "yay".
     ;;; "egg" -> "eggyay"
     ;;;
     ;;; If the first character is a consonant, remove it,
     ;;; and append it plus "ay" to the string.
     ;;; "foo" -> "oofay"

     (define pig-latin
       (lambda (str)
         (let ((first (string-ref str 0)))
           (if (memv first '(#\a #\e #\i #\o #\u))
     	  (string-append str "yay")
     	  (string-append
      	    (substring str 1 (string-length str))
     	    (string first) "ay")))))

     (display
      (map pig-latin
          (cdr (command-line))))
     (newline)
     (flush-output-port (current-output-port))

   Assuming we have stored the script in the file 'demo.sps', we can
invoke this script via 'vicare':

     $ vicare --r6rs-script demo.sps ice cream after dinner
     (iceyay reamcay afteryay innerday)

   On Unix/Linux systems, scripts generally start with a "shebang" line
(_sh_arp plus _bang_) which names an interpreter for the script.  All
modern systems have the 'env' command which searches for a command in
the user's path.

     #!/usr/bin/env vicare --r6rs-script
     (import (rnrs))

     ...

   Now we can make the file executable, and use it directly.

     $ chmod +x demo.sps
     $ ./demo.sps ice cream after dinner
     (iceyay reamcay afteryay innerday)

   There are a few fine points.

   * If the first two bytes of a script represent the sequence '#!' in
     ASCII encoding: the first line is discarded and not parsed as
     Scheme code.  This allows scripts on Unix systems to start with the
     command line needed to use them; notice that this will discard
     valid sharp-bang comments (like '#!r6rs') if they are at the very
     beginning of a file.

   * Under Mac OS X, if a script name ends with the '.command'
     extension, then it can be executed from the Finder by
     double-clicking on it.  This brings up a terminal window in which
     the script is executed.  The '.command' extension can be hidden
     from the _Get Info_ item from the Finder's File menu.


File: vicare-scheme.info,  Node: using libraries,  Next: using programs,  Prev: using scripts,  Up: using

2.4 R6RS libraries and extensions
=================================

A library exports features that can be imported into programs and other
libraries; a library is named by a list of symbols, for example
'(nausicaa uri pathname)'.  The core features of the R6RS language is
provided in the library '(rnrs)'; the full Vicare features are provided
by the library '(vicare)'.

* Menu:

* using libraries intro::       Introduction to Vicare libraries.
* using libraries filenames::   File names from library references.
* using libraries paths::       Library search paths.
* using libraries searching::   Library search algorithms.
* using libraries compiling::   Compiling libraries in binary format.
* using libraries examples::    Examples of libraries usage.


File: vicare-scheme.info,  Node: using libraries intro,  Next: using libraries filenames,  Up: using libraries

2.4.1 Introduction to libraries
-------------------------------

A library consists of a "file" (some assemblage of text) that contains a
library form, which might look like this:

     (library (sample)
       (export cube)
       (import (rnrs))
       (define cube
         (lambda (x)
           (* x x x))))

notice the 'import' clause.  No library is imported by default;
therefore, if we want to write some general purpose code, we have to
import at least one library that exports enough features to compose a
programming language; there multiple libraries of this kind, for example
'(rnrs)' and '(vicare)'.

   We can import '(sample)' into another library, a script, or a Vicare
top-level session:

     > (import (sample))
     > (cube 3)
     27

   Library names are lists, thus allowing the writer of one or more
libraries to group related libraries together.  For example, Vicare
installs a whole hierarchy of libraries under '(vicare
language-extensions)':

     (vicare language-extensions amb)
     (vicare language-extensions conditions-and-restarts))
     ...

Vicare's own Scheme libraries are under the hierarchies: '(vicare ---)',
'(srfi ---)' and '(nausicaa ---)'.

   Vicare's boot image and distributed libraries are installed in the
directory:

     $(libdir)/vicare-scheme

on 32-bit GNU+Linux systems:

     /usr/local/lib/vicare-scheme

on 64-bit GNU+Linux systems:

     /usr/local/lib64/vicare-scheme

for example the library '(vicare ffi)' on 32-bit GNU+Linux systems is
installed as:

     /usr/local/lib/vicare-scheme/vicare/ffi.fasl


File: vicare-scheme.info,  Node: using libraries filenames,  Next: using libraries paths,  Prev: using libraries intro,  Up: using libraries

2.4.2 File names from library references
----------------------------------------

A library is a file with the same name as the last component of the
library name.  For example, the library '(sample)' will correspond to a
source file named 'sample.vicare.sls' or 'sample.sls' and a binary file
named 'sample.fasl' somewhere in the file system.  The file extension
'.sls' stands for "Scheme Library Source" and '.fasl' stands for "FASt
Loading".

     *NOTE* For source libraries written for Vicare: the file extension
     to be preferred is '.vicare.sls'.  For source libraries written for
     R6RS implementations: the file extension to be preferred is '.sls'.

     *NOTE* Vicare will also accept the extensions '.ss' and '.scm' when
     the command line option '--more-file-extensions' is used.

   Here is an example of each case:

   * Importing '(sample)' causes Vicare to look for a binary file named
     'sample.fasl' and a source file named 'sample.vicare.sls' or
     'sample.sls'.

   * Importing '(yoyodyne sample)' causes Vicare to look for a directory
     named 'yoyodyne', and within that a binary file named 'sample.fasl'
     and a source file named 'sample.vicare.sls' or 'sample.sls'.  The
     'library' form for this library must still specify the library name
     as '(yoyodyne sample)', not '(sample)'.

   By default, Vicare attempts to import the library '(a b c)' in binary
format as follows: build the file "stem" '/a/b/c' then append the string
'.fasl' to the stem.  It attempts to import the library '(a b c)' from
source as follows: build the file "stem" '/a/b/c' then append each of
the following strings to the stem: '.vicare.sls', '.sls'.  Directories
from the search paths are prepended to the file stem plus extension and
searched on the file system, stopping at the first match.

   There are two refinements of the library search algorithm for source
libraries, which are performed when the '--more-file-extensions' command
line option is used.

   * A common pattern is to distribute a main library along with a
     number of additional extensions: we might have a main library named
     '(lib)', and additional optional extensions named '(lib extras)'
     and '(lib frills)'.

     Although the previous packaging method can be used, Vicare allows
     us to use a simpler technique where the main library is stored in
     'lib/main.sls', and the extensions are stored in 'lib/extras.sls'
     and 'lib/frills.sls', respectively.

   * When searching for source libraries: Vicare will also look in
     'lib/main.vicare.sls' before trying 'lib/main.sls'; this allows us
     to provide a Vicare-specific implementation as well as a generic
     implementation.  When searching for binary libraries: only the file
     'lib/main.fasl' is searched.

   When the the command line option '--more-file-extensions' is used and
the library '(a b c)' is imported in source form:

  1. The file "stem" is built: '/a/b/c'.

  2. Each of the following strings is appended to the stem, in order,
     until a matching file is found:

          /main.vicare.sls
          /main.vicare.ss
          /main.vicare.scm
          /main.sls
          /main.ss
          /main.scm
          .vicare.sls
          .vicare.ss
          .vicare.scm
          .sls
          .ss
          .scm

if there is no match, then the import request fails.

   Whenever the library name component 'main' appears as last and not
unique component: when building the file stem such component is "quoted"
by appending an underscore character; examples:

     (alpha beta main)       => "alpha/beta/main_"
     (main alpha)            => "main/alpha"
     (main)                  => "main"


File: vicare-scheme.info,  Node: using libraries paths,  Next: using libraries searching,  Prev: using libraries filenames,  Up: using libraries

2.4.3 Library search paths
--------------------------

Vicare has a search algorithm for libraries that is similar to those
used in other languages.  Vicare's search path comprises a series of
directories; when we try to import a library whose name contains just
one component, Vicare will examine each directory in the search path for
a file with a matching name.  Importing a library whose name is a list
of components causes Vicare to look for a series of subdirectories with
matching names.

   There are two search paths, one for binary libraries and one for
source libraries:

   * The source libraries search path is stored in the parameter
     'library-source-search-path'; *note library-source-search-path:
     libutils file-system paths.

   * The binary libraries search path is stored in the parameter
     'library-binary-search-path'; *note library-binary-search-path:
     libutils file-system paths.

both these parameters are meant to contain lists of strings representing
directory pathnames and can be updated as necessary.

   In programs intended to be distributed, we should resist the urge to
set 'library-binary-search-path' and 'library-source-search-path', as
the user's file hierarchies might not match ours; for most libraries,
simply telling the user to install the files in one of the directories
on the search path is good enough.


File: vicare-scheme.info,  Node: using libraries searching,  Next: using libraries compiling,  Prev: using libraries paths,  Up: using libraries

2.4.4 Library search algorithms
-------------------------------

In the typical scenario: packages compile source libraries in binary
format and store them in FASL files; then such FASL files are installed
in one of the directory referenced by the parameter
'library-binary-search-path'; finally, when running an application,
imported libraries are loaded in binary form from FASL files.

   There are other situations.  For this reason Vicare implements
"library locators": different procedures to locate a library in the file
system and other sources.  There are 3 predefined library locators:
run-time, compile-time, source; the default is the run-time locator.
*note Library file locators: libutils file-system locators.


File: vicare-scheme.info,  Node: using libraries compiling,  Next: using libraries examples,  Prev: using libraries searching,  Up: using libraries

2.4.5 Compiling libraries in binary format
------------------------------------------

* Menu:

* using libraries compiling lib::   Compiling a single library.
* using libraries compiling deps::  Compiling all the dependencies.


File: vicare-scheme.info,  Node: using libraries compiling lib,  Next: using libraries compiling deps,  Up: using libraries compiling

2.4.5.1 Compiling a single library
..................................

This library compilation strategy is implemented by a proper execution
mode of Vicare enabled by the command line option '--compile-library' of
'vicare'.  In this mode:

   * The compile-time library locator is selected, *note Compile-time
     libraries search: using libraries searching.

   * A R6RS library is loaded from an explicitly selected source file,
     compiled, and possibly invoked and visited.

   * It is assumed that all the library's dependency libraries are
     available in binary format.

   * The loaded library is serialised to a FASL file in an explicitly
     selected output file or in the selected
     'compiled-library-build-directory'.

   Let's say we have the libraries:

     (alpha beta (1 0))
     (alpha gamma (1 2))

in the files:

     $(srcdir)/lib/alpha/beta.sls
     $(srcdir)/lib/alpha/gamma.sls

we want to compile them to:

     $(builddir)/lib/alpha/beta.fasl
     $(builddir)/lib/alpha/gamma.fasl

and '(alpha gamma (1 2))' imports '(alpha beta (1 0))'.  We have
multiple options:

   * We explicitly execute (in the correct order) the commands that
     compile one library at a time, explicitly selecting the source and
     binary file pathnames.  First, to compile '(alpha beta (1 0))', we
     do:

          vicare \
            --compile-library $(srcdir)/lib/alpha/beta.sls \
            --output $(builddir)/lib/alpha/beta.fasl

     then, to compile '(alpha gamma (1 2))', we do:

          vicare \
            --build-directory $(builddir)/lib \
            --compile-library $(srcdir)/lib/alpha/gamma.sls \
            --output $(builddir)/lib/alpha/gamma.fasl

     when the option '--compile-library' is used and no library locator
     is explicitly selected with the option '--library-locator': the
     compile-time library locator is automatically selected.

   * We explicitly execute (in the correct order) the commands that
     compile one library at a time, explicitly selecting the build
     directory.  First, to compile '(alpha beta (1 0))', we do:

          vicare \
            --build-directory $(builddir)/lib \
            --compile-library $(srcdir)/lib/alpha/beta.sls

     then, to compile '(alpha gamma (1 2))', we do:

          vicare \
            --build-directory $(builddir)/lib \
            --compile-library $(srcdir)/lib/alpha/gamma.sls

   This compilation strategy is useful when compiling a "big" number of
libraries with a traditional 'Makefile':

   * It allows compiling only libraries for which the source is newer
     than the binary.

   * It allows running the compilation commands in parallel when
     possible, using, for example, the '-j' option of GNU Make.

   To use this strategy effectively we need to write all the compilation
commands, correctly tracking the dependencies; this is tedious, but
there are ways to automatically generate the needed commands.


File: vicare-scheme.info,  Node: using libraries compiling deps,  Prev: using libraries compiling lib,  Up: using libraries compiling

2.4.5.2 Compiling all the dependencies of a program
...................................................

This library compilation strategy is implemented by a proper execution
mode of Vicare enabled by the command line option
'--compile-dependencies' of 'vicare'; when using this mode the command
line option '--output' is *ignored*.  In this mode:

   * The compile-time library locator is selected, *note Compile-time
     libraries search: using libraries searching.

   * A R6RS program is loaded from a file but *not* executed.

   * All the program's dependency libraries are loaded, compiled, and
     possibly invoked and visited.

   * All the libraries loaded from a source file are serialised to FASL
     files in the selected 'compiled-library-build-directory'; all the
     libraries loaded from a FASL file are left untouched.

   Let's say we have the libraries:

     (alpha beta (1 0))
     (alpha gamma (1 2))

in the files:

     $(srcdir)/lib/alpha/beta.sls
     $(srcdir)/lib/alpha/gamma.sls

and we want to compile them to:

     $(builddir)/lib/alpha/beta.fasl
     $(builddir)/lib/alpha/gamma.fasl

we prepare a Scheme script for this purpose, containing the required
'import' forms:

     ;; compile-all.sps --
     ;;

     (import (only (alpha beta))
             (only (alpha beta)))

     ;;; end of file

and we execute it as follows:

     vicare \
        --source-path     $(srcdir)/lib   \
        --build-directory $(builddir)/lib \
        --compile-dependencies compile-all.sps

if the option '--library-locator' is not used: using
'--compile-dependencies' will automatically select the compile-time
library locator.

   If a selected library depends on the other selected library: Vicare
will automatically take care of generating the appropriate binary
formats.  If a selected library depends on other libraries, not
explicitly selected by the script: Vicare will automatically take care
of generating the appropriate binary formats and FASL files in the
selected 'compiled-library-build-directory'.


File: vicare-scheme.info,  Node: using libraries examples,  Prev: using libraries compiling,  Up: using libraries

2.4.6 Examples of library usage
-------------------------------

Consider a program using the procedure 'pretty-print' to format some
code, and suppose further that pretty printing is just a nice add-on
(e.g.  using 'write' suffices, but pretty-printing is _just prettier_).

   Vicare exports a good pretty-printing facility in its '(vicare)'
library.  However, since 'pretty-print' is not a standard procedure, a
program that uses it would be rendered unportable to other R6RS Scheme
implementations.

   The programmer can put the '.vicare.sls' extension to use in this
situation, by writing two versions of a '(pretty-printing)' library: one
for use by Vicare, and one portable for other implementations.

     ;; pretty-printing.vicare.sls --
     ;;
     ;; Can be used only by Vicare Scheme.

     (library (pretty-printing)
       (export pretty-print)
       (import (only (vicare) pretty-print)))

     ;;; end of file

     ;; pretty-printing.sls --
     ;;
     ;; For any other Scheme implementation, portable though
     ;; not very pretty.

     (library (pretty-printing)
       (export pretty-print)
       (import (rnrs))
       (define (pretty-print x port)
         (write x port)
         (newline port)))

     ;;; end of file


File: vicare-scheme.info,  Node: using programs,  Next: using rlwrap,  Prev: using libraries,  Up: using

2.5 Compiling Scheme programs
=============================

Scheme programs can be executed by Vicare from both source and binary
formats.

   * To run a Scheme script (a program in source form) we invoke the
     executable 'vicare' using the option '--r6rs-script' to select the
     pathname of the file:

          vicare --r6rs-script path/to/script.sps

   * To run a compiled Scheme program, we invoke the executable 'vicare'
     using the option '--binary-program' to select the pathname of the
     file:

          vicare --binary-program path/to/program

   On GNU+Linux platforms it is possible to execute programs directly
without explicitly invoking the executable, *note Launching programs
directly on GNU+Linux: binfmt.

   To compile a source program into binary form, we can use the specific
command line option '--compile-program' or the general command line
option '--compile' (which can be abbreviated as '-c').

   To compile 'script.sps' into 'script.fasl' we can do:

     vicare --compile-program script.sps --output script.fasl

the option '--compile' recognises input files with extension '.sps' as
programs, so we can also do:

     vicare --compile script.sps --output script.fasl

or with short options:

     vicare -c script.sps -o script.fasl

   There is no need to use the extension '.fasl' for binary programs, so
it is recommended to just do:

     vicare -o script -c script.sps

or, even shorter:

     vicare -c script.sps

which will automatically build the output file name by stripping '.sps'
from the input file name; the output file name is created in the same
directory of the input file name.

     *NOTE* If the option '--library-locator' is not used: using
     '--compile-program' or '--compile' will automatically select the
     compile-time library locator.


File: vicare-scheme.info,  Node: using rlwrap,  Prev: using programs,  Up: using

2.6 Using 'rlwrap'
==================

While Vicare comes with an interface to GNU Readline or compatible
library, the REPL interaction offers only very basic editing
capabilities.  For this reason it is suggested to use 'rlwrap':

               <http://utopia.knoware.nl/~hlub/rlwrap/>

to run Vicare's REPL through this shell script:

     #!/bin/sh
     #
     # Vicare Scheme GNU Readline wrapper using Rlwrap.

     ## Configuration variables.

     vicare_PROGRAM=$(type -p vicare)
     rlwrap_PROGRAM=$(type -p rlwrap)

     COMPLETIONS_FILE=~/.vicare_completions
     COMPLETIONS_OPTION=--file=${COMPLETIONS_FILE}

     ## Data variables.

     # Do NOT include '\!' and '?' in this string.
     BREAK_CHARS="\"#'(),;\`\\|[]{}"

     ## Check programs and data files existence.

     function error () {
         local MESSAGE=${1:?}
         printf 'vie error: %s\n' "${MESSAGE}" >&2
         exit 2
     }
     function warning () {
         local MESSAGE=${1:?}
         printf 'vie warning: %s\n' "${MESSAGE}" >&2
     }

     test -x "${rlwrap_PROGRAM}" || \
       error "cannot find program 'rlwrap'"
     test -x "${vicare_PROGRAM}" || \
       error "cannot find program 'vicare'"

     if ! test -f "${COMPLETIONS_FILE}" ; then
         warning "cannot find completions file '${COMPLETIONS_FILE}'"
         COMPLETIONS_OPTION=
     fi

     ## Run.

     exec "${rlwrap_PROGRAM}"                    \
         --ansi-colour-aware                     \
         --break-chars=${BREAK_CHARS}            \
         --complete-filenames                    \
         --history-no-dupes=2                    \
         --multi-line                            \
         --prompt-colour='1;31'                  \
         --quote-characters='"'                  \
         --remember                              \
         ${COMPLETIONS_OPTION}                   \
         "${vicare_PROGRAM}" --raw-repl "$@"

     ### end of file


File: vicare-scheme.info,  Node: scheme,  Next: baselib,  Prev: using,  Up: Top

3 The Scheme language
*********************

* Menu:

* scheme overview::             Overview of Scheme.
* scheme requirements::         Requirement levels.
* scheme numbers::              Numbers.
* scheme lex::                  Lexical syntax and datum syntax.
* scheme basic::                Semantic concepts.
* scheme entry::                Entry format.
* scheme library::              Libraries.
* scheme programs::             Top-level programs.
* scheme syntax::               Primitive syntax.
* scheme expansion::            Expansion process.
* scheme derived::              Sample definitions for derived forms.


File: vicare-scheme.info,  Node: scheme overview,  Next: scheme requirements,  Up: scheme

3.1 Overview of Scheme
======================

* Menu:

* scheme overview intro::         Introduction.
* scheme overview overview::      Overview.
* scheme overview basic types::   Basic types.
* scheme overview expressions::   Expressions.
* scheme overview variables::     Variables and binding.
* scheme overview definitions::   Definitions.
* scheme overview forms::         Forms.
* scheme overview procedures::    Procedures.
* scheme overview syntax::        Procedure calls and syntactic keywords.
* scheme overview assignment::    Assignment.
* scheme overview macros::        Derived forms and macros.
* scheme overview data::          Syntactic data and datum values.
* scheme overview continuations:: Continuations.
* scheme overview libraries::     Libraries.
* scheme overview programs::      Top-level programs.


File: vicare-scheme.info,  Node: scheme overview intro,  Next: scheme overview overview,  Up: scheme overview

3.1.1 Introduction
------------------

Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make
additional features appear necessary.  Scheme demonstrates that a very
small number of rules for forming expressions, with no restrictions on
how they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most of the
major programming paradigms in use today.

   Scheme was one of the first programming languages to incorporate
first-class procedures as in the lambda calculus, thereby proving the
usefulness of static scope rules and block structure in a dynamically
typed language.

   Scheme was the first major dialect of Lisp to distinguish procedures
from lambda expressions and symbols, to use a single lexical environment
for all variables, and to evaluate the operator position of a procedure
call in the same way as an operand position.

   By relying entirely on procedure calls to express iteration, Scheme
emphasised the fact that tail-recursive procedure calls are essentially
gotos that pass arguments.

   Scheme was the first widely used programming language to embrace
first-class escape procedures, from which all previously known
sequential control structures can be synthesised.

   A subsequent version of Scheme introduced the concept of exact and
inexact number objects, an extension of Common Lisp's generic
arithmetic.

   More recently, Scheme became the first programming language to
support hygienic macros, which permit the syntax of a block-structured
language to be extended in a consistent and reliable manner.

Guiding principles
..................

To help guide the standardisation effort, the R6RS editors have adopted
a set of principles, presented below.  Like the Scheme language defined
in Revised^5 Report on the Algorithmic Language Scheme, the language
described in the R6RS report is intended to:

   * allow programmers to read each other's code, and allow development
     of portable programs that can be executed in any conforming
     implementation of Scheme;

   * derive its power from simplicity, a small number of generally
     useful core syntactic forms and procedures, and no unnecessary
     restrictions on how they are composed;

   * allow programs to define new procedures and new hygienic syntactic
     forms;

   * support the representation of program source code as data;

   * make procedure calls powerful enough to express any form of
     sequential control, and allow programs to perform non-local control
     operations without the use of global program transformations;

   * allow interesting, purely functional programs to run indefinitely
     without terminating or running out of memory on finite-memory
     machines;

   * allow educators to use the language to teach programming
     effectively, at various levels and with a variety of pedagogical
     approaches;

   * allow researchers to use the language to explore the design,
     implementation, and semantics of programming languages.

   In addition, the R6RS report is intended to:

   * allow programmers to create and distribute substantial programs and
     libraries, e.g., implementations of Scheme Requests for
     Implementation, that run without modification in a variety of
     Scheme implementations;

   * support procedural, syntactic, and data abstraction more fully by
     allowing programs to define hygiene-bending and hygiene-breaking
     syntactic abstractions and new unique datatypes along with
     procedures and hygienic macros in any scope;

   * allow programmers to rely on a level of automatic run-time type and
     bounds checking sufficient to ensure type safety;

   * allow implementations to generate efficient code, without requiring
     programmers to use implementation-specific operators or
     declarations.

   While it was possible to write portable programs in Scheme as
described in Revised^5 Report on the Algorithmic Language Scheme, and
indeed portable Scheme programs were written prior to the R6RS report,
many Scheme programs were not, primarily because of the lack of
substantial standardised libraries and the proliferation of
implementation-specific language additions.

   In general, Scheme should include building blocks that allow a wide
variety of libraries to be written, include commonly used user-level
features to enhance portability and readability of library and
application code, and exclude features that are less commonly used and
easily implemented in separate libraries.

   The language described in the R6RS report is intended to also be
backward compatible with programs written in Scheme as described in
Revised^5 Report on the Algorithmic Language Scheme to the extent
possible without compromising the above principles and future viability
of the language.  With respect to future viability, the editors have
operated under the assumption that many more Scheme programs will be
written in the future than exist in the present, so the future programs
are those with which we should be most concerned.


File: vicare-scheme.info,  Node: scheme overview overview,  Next: scheme overview basic types,  Prev: scheme overview intro,  Up: scheme overview

3.1.2 Overview
--------------

This chapter gives an overview of Scheme's semantics.  The purpose of
this overview is to explain enough about the basic concepts of the
language to facilitate understanding of the subsequent chapters of the
report, which are organized as a reference manual.  Consequently, this
overview is neither a complete introduction to the language, nor precise
in all respects, nor normative in any way.

   Following Algol, Scheme is a statically scoped programming language.
Each use of a variable is associated with a lexically apparent binding
of that variable.

   Scheme has "latent" as opposed to "manifest" types.  Types are
associated with objects (also called values) rather than with variables.
(Some authors refer to languages with latent types as untyped, weakly
typed or dynamically typed languages.)  Other languages with latent
types are Python, Ruby, Smalltalk, and other dialects of Lisp.
Languages with manifest types (sometimes referred to as strongly typed
or statically typed languages) include Algol 60, C, C#, Java, Haskell,
and ML.

   All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.  No Scheme object
is ever destroyed.  The reason that implementations of Scheme do not
(usually!)  run out of storage is that they are permitted to reclaim the
storage occupied by an object if they can prove that the object cannot
possibly matter to any future computation.  Other languages in which
most objects have unlimited extent include C#, Java, Haskell, most Lisp
dialects, ML, Python, Ruby, and Smalltalk.

   Implementations of Scheme must be properly tail-recursive.  This
allows the execution of an iterative computation in constant space, even
if the iterative computation is described by a syntactically recursive
procedure.  Thus with a properly tail-recursive implementation,
iteration can be expressed using the ordinary procedure-call mechanics,
so that special iteration constructs are useful only as syntactic sugar.

   Scheme was one of the first languages to support procedures as
objects in their own right.  Procedures can be created dynamically,
stored in data structures, returned as results of procedures, and so on.
Other languages with these properties include Common Lisp, Haskell, ML,
Ruby, and Smalltalk.

   One distinguishing feature of Scheme is that continuations, which in
most other languages only operate behind the scenes, also have
"first-class" status.  First-class continuations are useful for
implementing a wide variety of advanced control constructs, including
non-local exits, backtracking, and coroutines.

   In Scheme, the argument expressions of a procedure call are evaluated
before the procedure gains control, whether the procedure needs the
result of the evaluation or not.  C, C#, Common Lisp, Python, Ruby, and
Smalltalk are other languages that always evaluate argument expressions
before invoking a procedure.  This is distinct from the lazy-evaluation
semantics of Haskell, or the call-by-name semantics of Algol 60, where
an argument expression is not evaluated unless its value is needed by
the procedure.

   Scheme's model of arithmetic provides a rich set of numerical types
and operations on them.  Furthermore, it distinguishes "exact" and
"inexact" number objects: Essentially, an exact number object
corresponds to a number exactly, and an inexact number object is the
result of a computation that involved rounding or other errors.


File: vicare-scheme.info,  Node: scheme overview basic types,  Next: scheme overview expressions,  Prev: scheme overview overview,  Up: scheme overview

3.1.3 Basic types
-----------------

Scheme programs manipulate "objects", which are also referred to as
"values".  Scheme objects are organized into sets of values called
"types".  This section gives an overview of the fundamentally important
types of the Scheme language.  More types are described in later
chapters.

     *NOTE* As Scheme is latently typed, the use of the term _type_ in
     this report differs from the use of the term in the context of
     other languages, particularly those with manifest typing.

Booleans
........

A boolean is a truth value, and can be either true or false.  In Scheme,
the object for "false" is written '#f'.  The object for "true" is
written '#t'.  In most places where a truth value is expected, however,
any object different from '#f' counts as true.

Numbers
.......

Scheme supports a rich variety of numerical data types, including
objects representing integers of arbitrary precision, rational numbers,
complex numbers, and inexact numbers of various kinds.  *note Numbers:
scheme numbers.

Characters
..........

Scheme characters mostly correspond to textual characters.  More
precisely, they are isomorphic to the "scalar values" of the Unicode
standard.

Strings
.......

Strings are finite sequences of characters with fixed length and thus
represent arbitrary Unicode texts.

Symbols
.......

A symbol is an object representing a string, the symbol's "name".
Unlike strings, two symbols whose names are spelled the same way are
never distinguishable.  Symbols are useful for many applications; for
instance, they may be used the way enumerated values are used in other
languages.

Pairs and lists
...............

A pair is a data structure with two components.  The most common use of
pairs is to represent (singly linked) lists, where the first component
(the "car") represents the first element of the list, and the second
component (the "cdr") the rest of the list.  Scheme also has a
distinguished empty list, which is the last cdr in a chain of pairs that
form a list.

Vectors
.......

Vectors, like lists, are linear data structures representing finite
sequences of arbitrary objects.  Whereas the elements of a list are
accessed sequentially through the chain of pairs representing it, the
elements of a vector are addressed by integer indices.  Thus, vectors
are more appropriate than lists for random access to elements.

Procedures
..........

Procedures are values in Scheme.


File: vicare-scheme.info,  Node: scheme overview expressions,  Next: scheme overview variables,  Prev: scheme overview basic types,  Up: scheme overview

3.1.4 Expressions
-----------------

The most important elements of Scheme code are "expressions".
Expressions can be "evaluated", producing a "value".  (Actually, any
number of values.  *note Multiple return values: scheme basic multiple
return values.)

   The most fundamental expressions are literal expressions:

     #t => #t
     23 => 23

this notation means that the expression '#t' evaluates to '#t', that is,
the value for "true", and that the expression '23' evaluates to a number
object representing the number 23.

   Compound expressions are formed by placing parentheses around their
subexpressions.  The first subexpression identifies an operation; the
remaining subexpressions are operands to the operation:

     (+ 23 42)               => 65
     (+ 14 (* 23 42))        => 980

in the first of these examples, '+' is the name of the built-in
operation for addition, and '23' and '42' are the operands.  The
expression '(+ 23 42)' reads as "the sum of 23 and 42".  Compound
expressions can be nested--the second example reads as "the sum of 14
and the product of 23 and 42".

   As these examples indicate, compound expressions in Scheme are always
written using the same prefix notation.  As a consequence, the
parentheses are needed to indicate structure.  Consequently,
"superfluous" parentheses, which are often permissible in mathematical
notation and also in many programming languages, are not allowed in
Scheme.

   As in many other languages, whitespace (including line endings) is
not significant when it separates subexpressions of an expression, and
can be used to indicate structure.


File: vicare-scheme.info,  Node: scheme overview variables,  Next: scheme overview definitions,  Prev: scheme overview expressions,  Up: scheme overview

3.1.5 Variables and binding
---------------------------

Scheme allows identifiers to stand for locations containing values.
These identifiers are called variables.  In many cases, specifically
when the location's value is never modified after its creation, it is
useful to think of the variable as standing for the value directly.

     (let ((x 23)
           (y 42))
       (+ x y))
     => 65

   In this case, the expression starting with 'let' is a binding
construct.  The parenthesized structure following the 'let' lists
variables alongside expressions: the variable 'x' alongside '23', and
the variable 'y' alongside '42'.  The 'let' expression binds 'x' to
'23', and 'y' to '42'.  These bindings are available in the _body_ of
the 'let' expression, '(+ x y)', and only there.


File: vicare-scheme.info,  Node: scheme overview definitions,  Next: scheme overview forms,  Prev: scheme overview variables,  Up: scheme overview

3.1.6 Definitions
-----------------

The variables bound by a 'let' expression are _local_, because their
bindings are visible only in 'let''s body.  Scheme also allows creating
top-level bindings for identifiers as follows:

     (define x 23)
     (define y 42)
     (+ x y) => 65

these are actually "top-level" in the body of a top-level program or
library.  *note Libraries: scheme library.

   The first two parenthesized structures are "definitions"; they create
top-level bindings, binding 'x' to '23' and 'y' to '42'.  Definitions
are not expressions, and cannot appear in all places where an expression
can occur.  Moreover, a definition has no value.

   Bindings follow the lexical structure of the program: When several
bindings with the same name exist, a variable refers to the binding that
is "closest" to it, starting with its occurrence in the program and
going from inside to outside, and referring to a top-level binding if no
local binding can be found along the way:

     (define x 23)
     (define y 42)
     (let ((y 43))
       (+ x y)) => 66

     (let ((y 43))
       (let ((y 44))
         (+ x y))) => 67


File: vicare-scheme.info,  Node: scheme overview forms,  Next: scheme overview procedures,  Prev: scheme overview definitions,  Up: scheme overview

3.1.7 Forms
-----------

While definitions are not expressions, compound expressions and
definitions exhibit similar syntactic structure:

     (define x 23)
     (* x 2)

   While the first line contains a definition, and the second an
expression, this distinction depends on the bindings for 'let' and '*'.
At the purely syntactical level, both are "forms", and "form" is the
general name for a syntactic part of a Scheme program.  In particular,
'23' is a _subform_ of the form '(define x 23)'.


File: vicare-scheme.info,  Node: scheme overview procedures,  Next: scheme overview syntax,  Prev: scheme overview forms,  Up: scheme overview

3.1.8 Procedures
----------------

Definitions can also be used to define procedures:

     (define (f x)
       (+ x 42))

     (f 23) => 65

   A procedure is, slightly simplified, an abstraction of an expression
over objects.  In the example, the first definition defines a procedure
called 'f'.  (Note the parentheses around 'f x', which indicate that
this is a procedure definition.)  The expression '(f 23)' is a procedure
call, meaning, roughly, "evaluate '(+ x 42)' (the body of the procedure)
with 'x' bound to '23'".

   As procedures are objects, they can be passed to other procedures:

     (define (f x)
       (+ x 42))

     (define (g p x)
       (p x))

     (g f 23) => 65

In this example, the body of 'g' is evaluated with P bound to 'f' and
'x' bound to '23', which is equivalent to '(f 23)', which evaluates to
'65'.

   In fact, many predefined operations of Scheme are provided not by
syntax, but by variables whose values are procedures.  The '+'
operation, for example, which receives special syntactic treatment in
many other languages, is just a regular identifier in Scheme, bound to a
procedure that adds number objects.  The same holds for '*' and many
others:

     (define (h op x y)
       (op x y))

     (h + 23 42) => 65
     (h * 23 42) => 966

   Procedure definitions are not the only way to create procedures.  A
'lambda' expression creates a new procedure as an object, with no need
to specify a name:

     ((lambda (x) (+ x 42)) 23) => 65

   The entire expression in this example is a procedure call; '(lambda
(x) (+ x 42))', evaluates to a procedure that takes a single number
object and adds 42 to it.


File: vicare-scheme.info,  Node: scheme overview syntax,  Next: scheme overview assignment,  Prev: scheme overview procedures,  Up: scheme overview

3.1.9 Procedure calls and syntactic keywords
--------------------------------------------

Whereas '(+ 23 42)', '(f 23)', and '((lambda (x) (+ x 42)) 23)' are all
examples of procedure calls, 'lambda' and 'let' expressions are not.
This is because 'let', even though it is an identifier, is not a
variable, but is instead a "syntactic keyword".  A form that has a
syntactic keyword as its first subexpression obeys special rules
determined by the keyword.  The 'let' identifier in a definition is also
a syntactic keyword.  Hence, definitions are also not procedure calls.

   The rules for the 'lambda' keyword specify that the first subform is
a list of parameters, and the remaining subforms are the body of the
procedure.  In 'let' expressions, the first subform is a list of binding
specifications, and the remaining subforms constitute a body of
expressions.

   Procedure calls can generally be distinguished from these "special
forms" by looking for a syntactic keyword in the first position of a
form: if the first position does not contain a syntactic keyword, the
expression is a procedure call.  (So-called _identifier macros_ allow
creating other kinds of special forms, but are comparatively rare.)  The
set of syntactic keywords of Scheme is fairly small, which usually makes
this task fairly simple.  It is possible, however, to create new
bindings for syntactic keywords.  *note Derived forms and macros: scheme
overview macros.


File: vicare-scheme.info,  Node: scheme overview assignment,  Next: scheme overview macros,  Prev: scheme overview syntax,  Up: scheme overview

3.1.10 Assignment
-----------------

Scheme variables bound by definitions or 'let' or 'lambda' expressions
are not actually bound directly to the objects specified in the
respective bindings, but to locations containing these objects.  The
contents of these locations can subsequently be modified destructively
via "assignment":

     (let ((x 23))
       (set! x 42)
       x) => 42

   In this case, the body of the 'let' expression consists of two
expressions which are evaluated sequentially, with the value of the
final expression becoming the value of the entire 'let' expression.  The
expression '(set! x 42)' is an assignment, saying "replace the object in
the location referenced by 'x' with '42'".  Thus, the previous value of
'x', '23', is replaced by '42'.


File: vicare-scheme.info,  Node: scheme overview macros,  Next: scheme overview data,  Prev: scheme overview assignment,  Up: scheme overview

3.1.11 Derived forms and macros
-------------------------------

Many of the special forms specified in this report can be translated
into more basic special forms.  For example, a 'let' expression can be
translated into a procedure call and a 'lambda' expression.  The
following two expressions are equivalent:

     (let ((x 23)
           (y 42))
       (+ x y))
     => 65

     ((lambda (x y) (+ x y)) 23 42)
     => 65

   Special forms like 'let' expressions are called "derived forms"
because their semantics can be derived from that of other kinds of forms
by a syntactic transformation.  Some procedure definitions are also
derived forms.  The following two definitions are equivalent:

     (define (f x)
       (+ x 42))

     (define f
       (lambda (x)
         (+ x 42)))

   In Scheme, it is possible for a program to create its own derived
forms by binding syntactic keywords to macros:

     (define-syntax def
       (syntax-rules ()
         ((def f (p ...) body)
          (define (f p ...)
            body))))

     (def f (x)
       (+ x 42))

   The 'define-syntax' construct specifies that a parenthesized
structure matching the pattern '(def f (p ...) body)', where 'f', 'p',
and 'body' are pattern variables, is translated to '(define (f p ...)
body)'.  Thus, the 'def' form appearing in the example gets translated
to:

     (define (f x)
       (+ x 42))

   The ability to create new syntactic keywords makes Scheme extremely
flexible and expressive, allowing many of the features built into other
languages to be derived forms in Scheme.


File: vicare-scheme.info,  Node: scheme overview data,  Next: scheme overview continuations,  Prev: scheme overview macros,  Up: scheme overview

3.1.12 Syntactic data and datum values
--------------------------------------

A subset of the Scheme objects is called "datum values".  These include
booleans, number objects, characters, symbols, and strings as well as
lists and vectors whose elements are data.  Each datum value may be
represented in textual form as a "syntactic datum", which can be written
out and read back in without loss of information.  A datum value may be
represented by several different syntactic data.  Moreover, each datum
value can be trivially translated to a literal expression in a program
by prepending a ''' (single quote) to a corresponding syntactic datum:

     '23             => 23
     '#t             => #t
     'foo            => foo
     '(1 2 3)        => (1 2 3)
     '#(1 2 3)       => #(1 2 3)

   The ''' shown in the previous examples is not needed for
representations of number objects or booleans.  The syntactic datum
'foo' represents a symbol with name "foo", and ''foo' is a literal
expression with that symbol as its value.  '(1 2 3)' is a syntactic
datum that represents a list with elements '1', '2', and '3', and ''(1 2
3)' is a literal expression with this list as its value.  Likewise, '#(1
2 3)' is a syntactic datum that represents a vector with elements '1',
'2' and '3', and ''#(1 2 3)' is the corresponding literal.

   The syntactic data are a superset of the Scheme forms.  Thus, data
can be used to represent Scheme forms as data objects.  In particular,
symbols can be used to represent identifiers.

     '(+ 23 42)                 => (+ 23 42)
     '(define (f x) (+ x 42))   => (define (f x) (+ x 42))

   This facilitates writing programs that operate on Scheme source code,
in particular interpreters and program transformers.


File: vicare-scheme.info,  Node: scheme overview continuations,  Next: scheme overview libraries,  Prev: scheme overview data,  Up: scheme overview

3.1.13 Continuations
--------------------

Whenever a Scheme expression is evaluated there is a "continuation"
wanting the result of the expression.  The continuation represents an
entire (default) future for the computation.  For example, informally
the continuation of '3' in the expression

     (+ 1 3)

adds 1 to it.  Normally these ubiquitous continuations are hidden behind
the scenes and programmers do not think much about them.  On rare
occasions, however, a programmer may need to deal with continuations
explicitly.

   The 'call-with-current-continuation' procedure allows Scheme
programmers to do that by creating a procedure that reinstates the
current continuation.  *note Control features: baselib control.

   The 'call-with-current-continuation' procedure accepts a procedure,
calls it immediately with an argument that is an _escape procedure_.
This escape procedure can then be called with an argument that becomes
the result of the call to 'call-with-current-continuation'.  That is,
the escape procedure abandons its own continuation, and reinstates the
continuation of the call to 'call-with-current-continuation'.

   In the following example, an escape procedure representing the
continuation that adds '1' to its argument is bound to 'escape', and
then called with '3' as an argument.  The continuation of the call to
'escape' is abandoned, and instead the '3' is passed to the continuation
that adds '1':

     (+ 1 (call-with-current-continuation
            (lambda (escape)
              (+ 2 (escape 3)))))
     => 4

   An escape procedure has unlimited extent: It can be called after the
continuation it captured has been invoked, and it can be called multiple
times.  This makes 'call-with-current-continuation' significantly more
powerful than typical non-local control constructs such as exceptions in
other languages.


File: vicare-scheme.info,  Node: scheme overview libraries,  Next: scheme overview programs,  Prev: scheme overview continuations,  Up: scheme overview

3.1.14 Libraries
----------------

Scheme code can be organized in components called "libraries".  Each
library contains definitions and expressions.  It can import definitions
from other libraries and export definitions to other libraries.

   The following library called '(hello)' exports a definition called
'hello-world', and imports the base library and the simple I/O library.
The 'hello-world' export is a procedure that displays 'Hello World' on a
separate line:

     (library (hello)
       (export hello-world)
       (import (rnrs base)
               (rnrs io simple))
       (define (hello-world)
         (display "Hello World")
         (newline)))


File: vicare-scheme.info,  Node: scheme overview programs,  Prev: scheme overview libraries,  Up: scheme overview

3.1.15 Top-level programs
-------------------------

A Scheme program is invoked via a "top-level program".  Like a library,
a top-level program contains imports, definitions and expressions, and
specifies an entry point for execution.  Thus a top-level program
defines, via the transitive closure of the libraries it imports, a
Scheme program.

   The following top-level program obtains the first argument from the
command line via the 'command-line' procedure from the '(rnrs programs
(6))' library.  It then opens the file using 'open-file-input-port',
yielding a _port_, i.e.  a connection to the file as a data source, and
calls the 'get-bytes-all' procedure to obtain the contents of the file
as binary data.  It then uses 'put-bytes' to output the contents of the
file to standard output:

     #!r6rs
     (import (rnrs base)
             (rnrs io ports)
             (rnrs programs))
     (let ((p (standard-output-port)))
       (put-bytevector p
                       (call-with-port
                           (open-file-input-port
                             (cadr (command-line)))
                         get-bytevector-all))
       (close-port p))


File: vicare-scheme.info,  Node: scheme requirements,  Next: scheme numbers,  Prev: scheme overview,  Up: scheme

3.2 Requirement levels
======================

The key words "must", "must not", "should", "should not", "recommended",
"may", and "optional" in this report are to be interpreted as described
in RFC 2119.  Specifically:

*must*
     This word means that a statement is an absolute requirement of the
     specification.

*must not*
     This phrase means that a statement is an absolute prohibition of
     the specification.

*should*
     This word, or the adjective "recommended", means that valid reasons
     may exist in particular circumstances to ignore a statement, but
     that the implications must be understood and weighed before
     choosing a different course.

*should not*
     This phrase, or the phrase "not recommended", means that valid
     reasons may exist in particular circumstances when the behavior of
     a statement is acceptable, but that the implications should be
     understood and weighed before choosing the course described by the
     statement.

*may*
     This word, or the adjective "optional", means that an item is truly
     optional.

   In particular, this report occasionally uses "should" to designate
circumstances that are outside the specification of this report, but
cannot be practically detected by an implementation.  *note Arguments
checking: scheme basic argument checking.  In such circumstances, a
particular implementation may allow the programmer to ignore the
recommendation of the report and even exhibit reasonable behavior.
However, as the report does not specify the behavior, these programs may
be unportable, that is, their execution might produce different results
on different implementations.

   Moreover, this report occasionally uses the phrase "not required" to
note the absence of an absolute requirement.


File: vicare-scheme.info,  Node: scheme numbers,  Next: scheme lex,  Prev: scheme requirements,  Up: scheme

3.3 Numbers
===========

This chapter describes Scheme's model for numbers.  It is important to
distinguish between the mathematical numbers, the Scheme objects that
attempt to model them, the machine representations used to implement the
numbers, and notations used to write numbers.

   In this report, the term "number" refers to a mathematical number,
and the term "number object" refers to a Scheme object representing a
number.  This report uses the types "complex", "real", "rational", and
"integer" to refer to both mathematical numbers and number objects.  The
"fixnum" and "flonum" types refer to special subsets of the number
objects, as determined by common machine representations, as explained
below.

* Menu:

* scheme numbers tower::        Numerical tower.
* scheme numbers exactness::    Exactness.
* scheme numbers fix flo::      Fixnums and flonums.
* scheme numbers requirements:: Implementation requirements.
* scheme numbers inf nan::      Infinities and NaNs.
* scheme numbers minus zero::   Distinguished -0.0.


File: vicare-scheme.info,  Node: scheme numbers tower,  Next: scheme numbers exactness,  Up: scheme numbers

3.3.1 Numerical tower
---------------------

Numbers may be arranged into a tower of subsets in which each level is a
subset of the level above it:

     number
       complex
       real
       rational
       integer

   For example, 5 is an integer.  Therefore 5 is also a rational, a
real, and a complex.  The same is true of the number objects that model
5.

   Number objects are organized as a corresponding tower of subtypes
defined by the predicates 'number?', 'complex?', 'real?', 'rational?',
and 'integer?'.  *note Numerical types predicates: baselib math ops type
pred.  Integer number objects are also called "integer objects".

   There is no simple relationship between the subset that contains a
number and its representation inside a computer.  For example, the
integer 5 may have several representations.  Scheme's numerical
operations treat number objects as abstract data, as independent of
their representation as possible.  Although an implementation of Scheme
may use many different representations for numbers, this should not be
apparent to a casual programmer writing simple programs.


File: vicare-scheme.info,  Node: scheme numbers exactness,  Next: scheme numbers fix flo,  Prev: scheme numbers tower,  Up: scheme numbers

3.3.2 Exactness
---------------

It is useful to distinguish between number objects that are known to
correspond to a number exactly, and those number objects whose
computation involved rounding or other errors.  For example, index
operations into data structures may need to know the index exactly, as
may some operations on polynomial coefficients in a symbolic algebra
system.  On the other hand, the results of measurements are inherently
inexact, and irrational numbers may be approximated by rational and
therefore inexact approximations.  In order to catch uses of numbers
known only inexactly where exact numbers are required, Scheme explicitly
distinguishes _exact_ from _inexact_ number objects.  This distinction
is orthogonal to the dimension of type.

   A number object is exact if it is the value of an exact numerical
literal or was derived from exact number objects using only exact
operations.  Exact number objects correspond to mathematical numbers in
the obvious way.

   Conversely, a number object is inexact if it is the value of an
inexact numerical literal, or was derived from inexact number objects,
or was derived using inexact operations.  Thus inexactness is
contagious.

   Exact arithmetic is reliable in the following sense: If exact number
objects are passed to any of the arithmetic procedures described in
*note Propagation of exactness and inexactness: baselib math exactness,
and an exact number object is returned, then the result is
mathematically correct.  This is generally not true of computations
involving inexact number objects because approximate methods such as
floating-point arithmetics may be used, but it is the duty of each
implementation to make the result as close as practical to the
mathematically ideal result.


File: vicare-scheme.info,  Node: scheme numbers fix flo,  Next: scheme numbers requirements,  Prev: scheme numbers exactness,  Up: scheme numbers

3.3.3 Fixnums and flonums
-------------------------

A "fixnum" is an exact integer object that lies within a certain
implementation-dependent subrange of the exact integer objects.  *note
Fixnums: stdlib arithmetic fixnums.

   Likewise, every implementation must designate a subset of its inexact
real number objects as "flonums", and to convert certain external
representations into flonums.  *note Flonums: stdlib arithmetic flonums.

   Note that this does not imply that an implementation must use
floating-point representations.


File: vicare-scheme.info,  Node: scheme numbers requirements,  Next: scheme numbers inf nan,  Prev: scheme numbers fix flo,  Up: scheme numbers

3.3.4 Implementation requirements
---------------------------------

Implementations of Scheme must support number objects for the entire
tower of subtypes given in *note Numerical tower: scheme numbers tower.
Moreover, implementations must support exact integer objects and exact
rational number objects of practically unlimited size and precision, and
to implement certain procedures (listed in *note Propagation of
exactness and inexactness: baselib math exactness.), so they always
return exact results when given exact arguments.  ("Practically
unlimited" means that the size and precision of these numbers should
only be limited by the size of the available memory.)

   Implementations may support only a limited range of inexact number
objects of any type, subject to the requirements of this section.  For
example, an implementation may limit the range of the inexact real
number objects (and therefore the range of inexact integer and rational
number objects) to the dynamic range of the flonum format.  Furthermore
the gaps between the inexact integer objects and rationals are likely to
be very large in such an implementation as the limits of this range are
approached.

   An implementation may use floating point and other approximate
representation strategies for _inexact_ numbers.  This report
recommends, but does not require, that the IEEE floating-point standards
be followed by implementations that use floating-point representations,
and that implementations using other representations should match or
exceed the precision achievable using these floating-point standards.

   In particular, implementations that use floating-point
representations must follow these rules: A floating-point result must be
represented with at least as much precision as is used to express any of
the inexact arguments to that operation.  Potentially inexact operations
such as 'sqrt', when applied to exact arguments, should produce exact
answers whenever possible (for example the square root of an exact 4
ought to be an exact 2).  However, this is not required.  If, on the
other hand, an exact number object is operated upon so as to produce an
inexact result (as by 'sqrt'), and if the result is represented in
floating point, then the most precise floating-point format available
must be used; but if the result is represented in some other way then
the representation must have at least as much precision as the most
precise floating-point format available.

   It is the programmer's responsibility to avoid using inexact number
objects with magnitude or significand too large to be represented in the
implementation.


File: vicare-scheme.info,  Node: scheme numbers inf nan,  Next: scheme numbers minus zero,  Prev: scheme numbers requirements,  Up: scheme numbers

3.3.5 Infinities and NaNs
-------------------------

Some Scheme implementations, specifically those that follow the IEEE
floating-point standards, distinguish special number objects called
"positive infinity", "negative infinity" and "NaN".

   Positive infinity is regarded as an inexact real (but not rational)
number object that represents an indeterminate number greater than the
numbers represented by all rational number objects.  Negative infinity
is regarded as an inexact real (but not rational) number object that
represents an indeterminate number less than the numbers represented by
all rational numbers.

   A NaN is regarded as an inexact real (but not rational) number object
so indeterminate that it might represent any real number, including
positive or negative infinity, and might even be greater than positive
infinity or less than negative infinity.


File: vicare-scheme.info,  Node: scheme numbers minus zero,  Prev: scheme numbers inf nan,  Up: scheme numbers

3.3.6 Distinguished -0.0
------------------------

Some Scheme implementations, specifically those that follow the IEEE
floating-point standards, distinguish between number objects for 0.0 and
-0.0, i.e., positive and negative inexact zero.  This report will
sometimes specify the behavior of certain arithmetic operations on these
number objects.  These specifications are marked with "if -0.0 is
distinguished" or "implementations that distinguish -0.0".


File: vicare-scheme.info,  Node: scheme lex,  Next: scheme basic,  Prev: scheme numbers,  Up: scheme

3.4 Lexical syntax and datum syntax
===================================

* Menu:

* scheme lex intro::            Introduction.
* scheme lex notation::         Notation.
* scheme lex syntax::           Lexical syntax.
* scheme lex datum::            Datum syntax.


File: vicare-scheme.info,  Node: scheme lex intro,  Next: scheme lex notation,  Up: scheme lex

3.4.1 Introduction
------------------

The syntax of Scheme code is organized in three levels:

  1. The "lexical syntax" that describes how a program text is split
     into a sequence of lexemes.

  2. The "datum syntax", formulated in terms of the lexical syntax, that
     structures the lexeme sequence as a sequence of "syntactic data",
     where a syntactic datum is a recursively structured entity.

  3. The "program syntax" formulated in terms of the datum syntax,
     imposing further structure and assigning meaning to syntactic data.

   Syntactic data (also called "external representations") double as a
notation for objects, and Scheme's '(rnrs io ports (6))' library
provides the 'get-datum' and 'put-datum' procedures for reading and
writing syntactic data, converting between their textual representation
and the corresponding objects.  *note Port input/output: stdlib io port.
Each syntactic datum represents a corresponding _datum value_.  A
syntactic datum can be used in a program to obtain the corresponding
datum value using 'quote'.  *note Quotation: baselib expressions
quotation.

   Scheme source code consists of syntactic data and (non-significant)
comments.  Syntactic data in Scheme source code are called _forms_.  (A
form nested inside another form is called a _subform_.)  Consequently,
Scheme's syntax has the property that any sequence of characters that is
a form is also a syntactic datum representing some object.  This can
lead to confusion, since it may not be obvious out of context whether a
given sequence of characters is intended to be a representation of
objects or the text of a program.  It is also a source of power, since
it facilitates writing programs such as interpreters or compilers that
treat programs as objects (or vice versa).

   A datum value may have several different external representations.
For example, both '#e28.000' and '#x1c' are syntactic data representing
the exact integer object 28, and the syntactic data '(8 13)', '( 08 13
)', '(8 . (13 . ()))' all represent a list containing the exact integer
objects 8 and 13.  Syntactic data that represent equal objects (in the
sense of 'equal?'; *note baselib predicates::) are always equivalent as
forms of a program.

   Because of the close correspondence between syntactic data and datum
values, this report sometimes uses the term _datum_ for either a
syntactic datum or a datum value when the exact meaning is apparent from
the context.

   An implementation must not extend the lexical or datum syntax in any
way, with one exception: it need not treat the syntax '#!<identifier>',
for any <identifier> (*note scheme lex syntax identifiers::) that is not
'r6rs', as a syntax violation, and it may use specific '#!'-prefixed
identifiers as flags indicating that subsequent input contains
extensions to the standard lexical or datum syntax.  The syntax '#!r6rs'
may be used to signify that the input afterward is written with the
lexical syntax and datum syntax described by this report.  '#!r6rs' is
otherwise treated as a comment; *note scheme lex syntax whitespace and
comments::.


File: vicare-scheme.info,  Node: scheme lex notation,  Next: scheme lex syntax,  Prev: scheme lex intro,  Up: scheme lex

3.4.2 Notation
--------------

The formal syntax for Scheme is written in an extended BNF.
Non-terminals are written as ?NON-TERMINAL.  Case is insignificant for
non-terminal names.

   All spaces in the grammar are for legibility.  ?EMPTY stands for the
empty string.

   The following extensions to BNF are used to make the description more
concise: ?THING* means zero or more occurrences of ?THING, and ?THING+
means at least one ?THING.

   Some non-terminal names refer to the Unicode scalar values of the
same name: ?CHARACTER-TABULATION (U+0009), ?LINEFEED (U+000A),
?CARRIAGE-RETURN (U+000D), ?LINE-TABULATION (U+000B), ?FORM-FEED
(U+000C), ?SPACE (U+0020), ?NEXT-LINE (U+0085), ?LINE-SEPARATOR
(U+2028), and ?PARAGRAPH-SEPARATOR (U+2029).


File: vicare-scheme.info,  Node: scheme lex syntax,  Next: scheme lex datum,  Prev: scheme lex notation,  Up: scheme lex

3.4.3 Lexical syntax
--------------------

The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non-significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the Unicode standard.  Some of the lexemes, such as identifiers,
representations of number objects, strings etc., of the lexical syntax
are syntactic data in the datum syntax, and thus represent objects.
Besides the formal account of the syntax, this section also describes
what datum values are represented by these syntactic data.

   The lexical syntax, in the description of comments, contains a
forward reference to ?DATUM, which is described as part of the datum
syntax.  Being comments, however, these ?DATUMs do not play a
significant role in the syntax.

   Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, '#x1A' and '#X1a' are equivalent.  The identifier 'Foo' is,
however, distinct from the identifier 'FOO'.

* Menu:

* scheme lex syntax formal account::           Formal account.
* scheme lex syntax line endings::             Line endings.
* scheme lex syntax whitespace and comments::  Whitespace and comments.
* scheme lex syntax identifiers::              Identifiers.
* scheme lex syntax booleans::                 Booleans.
* scheme lex syntax characters::               Characters.
* scheme lex syntax strings::                  Strings.
* scheme lex syntax numbers::                  Numbers.


File: vicare-scheme.info,  Node: scheme lex syntax formal account,  Next: scheme lex syntax line endings,  Up: scheme lex syntax

3.4.3.1 Formal account
......................

?INTERLEXEME-SPACE may occur on either side of any lexeme, but not
within a lexeme.

   ?IDENTIFIERs, '.', ?NUMBERs, ?CHARACTERs, and ?BOOLEANs, must be
terminated by a ?DELIMITER or by the end of the input.

   The following two characters are reserved for future extensions to
the language: '{ }'

     <lexeme> -> <identifier> | <boolean> | <number>
              | <character> | <string>
              | ( | ) | [ | ] | #( | #vu8( | ' | ` | , | ,@ | .
              | #' | #` | #, | #,@
     <delimiter> -> ( | ) | [ | ] | " | ; | #
              | <whitespace>
     <whitespace> -> <character tabulation>
              | <linefeed> | <line tabulation> | <form feed>
              | <carriage return> | <next line>
              | <any character whose category is Zs, Zl, or Zp>
     <line ending> -> <linefeed> | <carriage return>
              | <carriage return> <linefeed> | <next line>
              | <carriage return> <next line> | <line separator>
     <comment> -> ; <all subsequent characters up to a <line ending>
                     or <paragraph separator> >
              | <nested comment>
              | #; <interlexeme space> <datum>
              | #!r6rs
     <nested comment> -> #| <comment text>
              <comment cont>* |#
     <comment text> -> character sequence not containing #| or |#
     <comment cont> -> <nested comment> <comment text>
     <atmosphere> -> <whitespace> | <comment>
     <interlexeme space> -> <atmosphere>*

     <identifier> -> <initial> <subsequent>*
              | <peculiar identifier>
     <initial> -> <constituent> | <special initial>
              | <inline hex escape>
     <letter> -> a | b | c | ... | z
              | A | B | C | ... | Z
     <constituent> -> <letter>
              | <any character whose Unicode scalar value is greater than
                  127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
                  Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co>
     <special initial> -> ! | $ | % | & | * | / | : | < | =
              | > | ? | ^ | _ | ~
     <subsequent> -> <initial> | <digit>
              | <any character whose category is Nd, Mc, or Me>
              | <special subsequent>
     <digit> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
     <hex digit> -> <digit>
              | a | A | b | B | c | C | d | D | e | E | f | F
     <special subsequent> -> + | - | . | @
     <inline hex escape> -> \x<hex scalar value>;
     <hex scalar value> -> <hex digit>+
     <peculiar identifier> -> + | - | ... | -> <subsequent>*
     <boolean> -> #t | #T | #f | #F
     <character> -> #\<any character>
              | #\<character name>
              | #\x<hex scalar value>
     <character name> -> nul | alarm | backspace | tab
              | linefeed | newline | vtab | page | return
              | esc | space | delete
     <string> -> " <string element>* "
     <string element> -> <any character other than " or \>
              | \a | \b | \t | \n | \v | \f | \r
              | \" | \\
              | \<intraline whitespace>* <line ending>
                 <intraline whitespace>*
              | <inline hex escape>
     <intraline whitespace> -> <character tabulation>
              | <any character whose category is Zs>

   A ?HEX-SCALAR-VALUE represents a Unicode scalar value between '0' and
'#x10FFFF', excluding the range '[#xD800, #xDFFF]'.

   The rules for ?NUM-R, ?COMPLEX-R, ?REAL-R, ?UREAL-R, ?UINTEGER-R, and
?PREFIX-R below should be replicated for R = 2, 8, 10, and 16.  There
are no rules for ?DECIMAL-2, ?DECIMAL-8, and ?DECIMAL-16, which means
that number representations containing decimal points or exponents must
be in decimal radix.

     <number> -> <num 2> | <num 8>
              | <num 10> | <num 16>
     <num R> -> <prefix R> <complex R>
     <complex R> -> <real R> | <real R> @ <real R>
              | <real R> + <ureal R> i | <real R> - <ureal R> i
              | <real R> + <naninf> i | <real R> - <naninf> i
              | <real R> + i | <real R> - i
              | + <ureal R> i | - <ureal R> i
              | + <naninf> i | - <naninf> i
              | + i | - i
     <real R> -> <sign> <ureal R>
              | + <naninf> | - <naninf>
     <naninf> -> nan.0 | inf.0
     <ureal R> -> <uinteger R>
              | <uinteger R> / <uinteger R>
              | <decimal R> <mantissa width>
     <decimal 10> -> <uinteger 10> <suffix>
              | . <digit 10>+ <suffix>
              | <digit 10>+ . <digit 10>* <suffix>
              | <digit 10>+ . <suffix>
     <uinteger R> -> <digit R>+
     <prefix R> -> <radix R> <exactness>
              | <exactness> <radix R>

     <suffix> -> <empty>
              | <exponent marker> <sign> <digit 10>+
     <exponent marker> -> e | E | s | S | f | F
              | d | D | l | L
     <mantissa width> -> <empty>
              | \| <digit 10>+
     <sign> -> <empty> | + | -
     <exactness> -> <empty>
              | #i| #I | #e| #E
     <radix 2> -> #b| #B
     <radix 8> -> #o| #O
     <radix 10> -> <empty> | #d | #D
     <radix 16> -> #x| #X
     <digit 2> -> 0 | 1
     <digit 8> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
     <digit 10> -> <digit>
     <digit 16> -> <hex digit>


File: vicare-scheme.info,  Node: scheme lex syntax line endings,  Next: scheme lex syntax whitespace and comments,  Prev: scheme lex syntax formal account,  Up: scheme lex syntax

3.4.3.2 Line endings
....................

Line endings are significant in Scheme in single-line comments (*note
scheme lex syntax whitespace and comments::) and within string literals.
In Scheme source code, any of the line endings in ?LINE-ENDING marks the
end of a line.  Moreover, the two-character line endings
?CARRIAGE-RETURN ?LINEFEED and ?CARRIAGE-RETURN ?NEXT-LINE each count as
a single line ending.

   In a string literal, a ?LINE-ENDING not preceded by a '\' stands for
a linefeed character, which is the standard line-ending character of
Scheme.


File: vicare-scheme.info,  Node: scheme lex syntax whitespace and comments,  Next: scheme lex syntax identifiers,  Prev: scheme lex syntax line endings,  Up: scheme lex syntax

3.4.3.3 Whitespace and comments
...............................

_Whitespace_ characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

   The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

   A semicolon (';') indicates the start of a line comment.  The comment
continues to the end of the line on which the semicolon appears.

   Another way to indicate a comment is to prefix a ?DATUM (cf.  section
"Formal account") with '#;', possibly with ?INTERLEXEME-SPACE before the
?DATUM.  The comment consists of the comment prefix '#;' and the ?DATUM
together.  This notation is useful for "commenting out" sections of
code.

   Block comments may be indicated with properly nested '#|' and '|#'
pairs.

     #|
        The FACT procedure computes the factorial of a
        non-negative integer.
     |#
     (define fact
       (lambda (n)
         ;; base case
         (if (= n 0)
             #;(= n 1)
             1       ; identity of *
             (* n (fact (- n 1))))))

   The lexeme '#!r6rs', which signifies that the program text that
follows is written with the lexical and datum syntax described in this
report, is also otherwise treated as a comment.


File: vicare-scheme.info,  Node: scheme lex syntax identifiers,  Next: scheme lex syntax booleans,  Prev: scheme lex syntax whitespace and comments,  Up: scheme lex syntax

3.4.3.4 Identifiers
...................

Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
"extended alphabetic characters" is an identifier when it begins with a
character that cannot begin a representation of a number object.  In
addition, '+', '-', and '...' are identifiers, as is a sequence of
letters, digits, and extended alphabetic characters that begins with the
two-character sequence '->'.  Here are some examples of identifiers:

     lambda         q                soup
     list->vector   +                V17a
     <=             a34kTMNs         ->-
     the-word-recursion-has-many-meanings

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

     ! $ % & * + - . / : < = > ? @ ^ _ ~

   Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified via an ?INLINE-HEX-ESCAPE.  For example, the
identifier 'H\x65;llo' is the same as the identifier 'Hello'.

   Any identifier may be used as a variable or as a syntactic keyword
(*note scheme basic variables keywords regions:: and *note scheme syntax
macros::) in a Scheme program.  Any identifier may also be used as a
syntactic datum, in which case it represents a _symbol_ (*note baselib
symbols::).


File: vicare-scheme.info,  Node: scheme lex syntax booleans,  Next: scheme lex syntax characters,  Prev: scheme lex syntax identifiers,  Up: scheme lex syntax

3.4.3.5 Booleans
................

The standard boolean objects for true and false have external
representations '#t' and '#f'.


File: vicare-scheme.info,  Node: scheme lex syntax characters,  Next: scheme lex syntax strings,  Prev: scheme lex syntax booleans,  Up: scheme lex syntax

3.4.3.6 Characters
..................

Characters are represented using the notation '#\<character>' or
'#\<character name>' or '#\x<hex scalar value>'.

   For example:

     #\a             lower case letter a
     #\A             upper case letter A
     #\(             left parenthesis
     #\              space character
     #\nul           U+0000
     #\alarm         U+0007
     #\backspace     U+0008
     #\tab           U+0009
     #\linefeed      U+000A
     #\newline       U+000A
     #\vtab          U+000B
     #\page          U+000C
     #\return        U+000D
     #\esc           U+001B
     #\space         U+0020 preferred way to write a space
     #\delete        U+007F
     #\xFF           U+00FF
     #\x03BB         U+03BB
     #\x00006587     U+6587
     #\x0001z        &lexical exception
     #\alarmx        &lexical exception
     #\alarm x       U+0007 followed by x
     #\Alarm         &lexical exception
     #\alert         &lexical exception
     #\xA            U+000A
     #\xFF           U+00FF
     #\xff           U+00FF
     #\x ff          U+0078 followed by another datum, ff
     #\x(ff)         U+0078 followed by another datum, a parenthesized ff
     #\(x)           &lexical exception
     #\(x            &lexical exception
     #\((x)          U+0028 followed by another datum, parenthesized x
     #\x00110000     &lexical exception out of range
     #\x000000001    U+0001
     #\xD800         &lexical exception in excluded range

   (The notation '&lexical' means that the line in question is a lexical
syntax violation.)

   Case is significant in '#\<character>', and in '#\<character name>',
but not in the '<hex scalar value>' of '#\x<hex scalar value>'.  A
?CHARACTER must be followed by a ?DELIMITER or by the end of the input.
This rule resolves various ambiguous cases involving named characters,
requiring, for example, the sequence of characters '#\space' to be
interpreted as the space character rather than as the character '#\s'
followed by the identifier 'pace'.

     *NOTE* The '#\newline' notation is retained for backward
     compatibility.  Its use is deprecated; '#\linefeed' should be used
     instead.


File: vicare-scheme.info,  Node: scheme lex syntax strings,  Next: scheme lex syntax numbers,  Prev: scheme lex syntax characters,  Up: scheme lex syntax

3.4.3.7 Strings
...............

String are represented by sequences of characters enclosed within
doublequotes ('"').  Within a string literal, various escape sequences
represent characters other than themselves.  Escape sequences always
start with a backslash ('\'):

'\a'
     alarm, U+0007
'\b'
     backspace, U+0008
'\t'
     character tabulation, U+0009
'\n'
     linefeed, U+000A
'\v'
     line tabulation, U+000B
'\f'
     formfeed, U+000C
'\r'
     return, U+000D
'\"'
     doublequote, U+0022
'\'
     backslash, U+005C
'\<intraline whitespace><line ending> <intraline whitespace>'
     nothing
'\x<hex scalar value>;'
     specified character (note the terminating semi-colon).

   These escape sequences are case-sensitive, except that the alphabetic
digits of a ?HEX-SCALAR-VALUE can be uppercase or lowercase.

   Any other character in a string after a backslash is a syntax
violation.  Except for a line ending, any character outside of an escape
sequence and not a doublequote stands for itself in the string literal.
A line ending that does not follow a backslash stands for a linefeed
character.

   Examples:

     "abc"           U+0061, U+0062, U+0063
     "\x41;bc"       "Abc" ; U+0041, U+0062, U+0063
     "\x41; bc"      "A bc"
                     U+0041, U+0020, U+0062, U+0063
     "\x41bc;"       U+41BC
     "\x41"          &lexical exception
     "\x;"           &lexical exception
     "\x41bx;"       &lexical exception
     "\x00000041;"   "A" ; U+0041
     "\x0010FFFF;"   U+10FFFF
     "\x00110000;"   &lexical exception
                     out of range
     "\x000000001;"  U+0001
     "\xD800;"       &lexical exception
                     in excluded range
     "A
     bc"             U+0041, U+000A, U+0062, U+0063
                     if no space occurs after the A


File: vicare-scheme.info,  Node: scheme lex syntax numbers,  Prev: scheme lex syntax strings,  Up: scheme lex syntax

3.4.3.8 Numbers
...............

The syntax of external representations for number objects is described
formally by the ?NUMBER rule in the formal grammar.  Case is not
significant in external representations of number objects.

   A representation of a number object may be written in binary, octal,
decimal, or hexadecimal by the use of a radix prefix.  The radix
prefixes are '#b' (binary), '#o' (octal), '#d' (decimal), and '#x'
(hexadecimal).  With no radix prefix, a representation of a number
object is assumed to be expressed in decimal.

   A representation of a number object may be specified to be either
exact or inexact by a prefix.  The prefixes are '#e' for exact, and '#i'
for inexact.  An exactness prefix may appear before or after any radix
prefix that is used.  If the representation of a number object has no
exactness prefix, the constant is inexact if it contains a decimal
point, an exponent, or a nonempty mantissa width; otherwise it is exact.

   In systems with inexact number objects of varying precisions, it may
be useful to specify the precision of a constant.  For this purpose,
representations of number objects may be written with an exponent marker
that indicates the desired precision of the inexact representation.  The
letters 's', 'f', 'd', and 'l' specify the use of _short_, _single_,
_double_, and _long_ precision, respectively.  (When fewer than four
internal inexact representations exist, the four size specifications are
mapped onto those available.  For example, an implementation with two
internal representations may map short and single together and long and
double together.)  In addition, the exponent marker 'e' specifies the
default precision for the implementation.  The default precision has at
least as much precision as _double_, but implementations may wish to
allow this default to be set by the user.

     3.1415926535898F0
            Round to single, perhaps 3.141593
     0.6L0
            Extend to long, perhaps .600000000000000

   A representation of a number object with nonempty mantissa width,
'x|p', represents the best binary floating-point approximation of _x_
using a _p_-bit significand.  For example, '1.1|53' is a representation
of the best approximation of 1.1 in IEEE double precision.  If _x_ is an
external representation of an inexact real number object that contains
no vertical bar, then its numerical value should be computed as though
it had a mantissa width of 53 or more.

   Implementations that use binary floating-point representations of
real number objects should represent 'x|p' using a _p_-bit significand
if practical, or by a greater precision if a _p_-bit significand is not
practical, or by the largest available precision if _p_ or more bits of
significand are not practical within the implementation.

     _Note_ The precision of a significand should not be confused with
     the number of bits used to represent the significand.  In the IEEE
     floating-point standards, for example, the significand's most
     significant bit is implicit in single and double precision but is
     explicit in extended precision.  Whether that bit is implicit or
     explicit does not affect the mathematical precision.  In
     implementations that use binary floating point, the default
     precision can be calculated by calling the following procedure:

          (define (precision)
            (do ([n 0 (+ n 1)]
                 [x 1.0 (/ x 2.0)])
              ((= 1.0 (+ 1.0 x)) n)))

     _Note_ When the underlying floating-point representation is IEEE
     double precision, the '|p' suffix should not always be omitted:
     Denormalized floating-point numbers have diminished precision, and
     therefore their external representations should carry a '|p' suffix
     with the actual width of the significand.

   The literals '+inf.0' and '-inf.0' represent positive and negative
infinity, respectively.  The '+nan.0' literal represents the NaN that is
the result of '(/ 0.0 0.0)', and may represent other NaNs as well.  The
'-nan.0' literal also represents a NaN.

   If _x_ is an external representation of an inexact real number object
and contains no vertical bar and no exponent marker other than 'e', the
inexact real number object it represents is a flonum (see library
section "Flonums").  Some or all of the other external representations
of inexact real number objects may also represent flonums, but that is
not required by this report.


File: vicare-scheme.info,  Node: scheme lex datum,  Prev: scheme lex syntax,  Up: scheme lex

3.4.4 Datum syntax
------------------

The datum syntax describes the syntax of syntactic data in terms of a
sequence of ?LEXEMEs, as defined in the lexical syntax.

   Syntactic data include the lexeme data described in the previous
section as well as the following constructs for forming compound data:

   * pairs and lists, enclosed by '( )' or '[ ]';

   * vectors;

   * bytevectors.

* Menu:

* scheme lex datum formal account::  Formal account.
* scheme lex datum pairs and lists:: Pairs and lists.
* scheme lex datum vectors::         Vectors.
* scheme lex datum bytevectors::     Bytevectors.
* scheme lex datum abbreviations::   Abbreviations.


File: vicare-scheme.info,  Node: scheme lex datum formal account,  Next: scheme lex datum pairs and lists,  Up: scheme lex datum

3.4.4.1 Formal account
......................

The following grammar describes the syntax of syntactic data in terms of
various kinds of lexemes defined in the grammar in *note Lexical Syntax:
scheme lex syntax.

     <datum> -> <lexeme datum>
              | <compound datum>
     <lexeme datum> -> <boolean> | <number>
              | <character> | <string> | <symbol>
     <symbol> -> <identifier>
     <compound datum> -> <list> | <vector> | <bytevector>
     <list> -> (<datum>*) | [<datum>*]
              | (<datum>+ . <datum>) | [<datum>+ . <datum>]
              | <abbreviation>
     <abbreviation> -> <abbrev prefix> <datum>
     <abbrev prefix> -> ' | ` | , | ,@
              | #' | #` | #, | #,@
     <vector> -> #(<datum>*)
     <bytevector> -> #vu8(<u8>*)
     <u8> -> <any <number> representing an exact integer in {0, ..., 255}>


File: vicare-scheme.info,  Node: scheme lex datum pairs and lists,  Next: scheme lex datum vectors,  Prev: scheme lex datum formal account,  Up: scheme lex datum

3.4.4.2 Pairs and lists
.......................

List and pair data, representing pairs and lists of values are
represented using parentheses or brackets.  Matching pairs of brackets
that occur in the rules of ?LIST are equivalent to matching pairs of
parentheses.

   The most general notation for Scheme pairs as syntactic data is the
"dotted" notation '(?DATUM1 . ?DATUM2)' where ?DATUM1 is the
representation of the value of the car field and ?DATUM2 is the
representation of the value of the cdr field.  For example '(4 . 5)' is
a pair whose car is 4 and whose cdr is 5.

   A more streamlined notation can be used for lists: the elements of
the list are simply enclosed in parentheses and separated by spaces.
The empty list is represented by '( )'.  For example,

     (a b c d e)

and:

     (a . (b . (c . (d . (e . ())))))

are equivalent notations for a list of symbols.

   The general rule is that, if a dot is followed by an open
parenthesis, the dot, open parenthesis, and matching closing parenthesis
can be omitted in the external representation.

   The sequence of characters '(4 . 5)' is the external representation
of a pair, not an expression that evaluates to a pair.  Similarly, the
sequence of characters '(+ 2 6)' is _not_ an external representation of
the integer 8, even though it _is_ an expression (in the language of the
'(rnrs base (6))' library) evaluating to the integer 8; rather, it is a
syntactic datum representing a three-element list, the elements of which
are the symbol '+' and the integers 2 and 6.


File: vicare-scheme.info,  Node: scheme lex datum vectors,  Next: scheme lex datum bytevectors,  Prev: scheme lex datum pairs and lists,  Up: scheme lex datum

3.4.4.3 Vectors
...............

Vector data, representing vectors of objects, are represented using the
notation '#(<datum> ...)'.  For example, a vector of length 3 containing
the number object for zero in element 0, the list '(2 2 2 2)' in element
1, and the string '"Anna"' in element 2 can be represented as follows:

     #(0 (2 2 2 2) "Anna")

   This is the external representation of a vector, not an expression
that evaluates to a vector.


File: vicare-scheme.info,  Node: scheme lex datum bytevectors,  Next: scheme lex datum abbreviations,  Prev: scheme lex datum vectors,  Up: scheme lex datum

3.4.4.4 Bytevectors
...................

Bytevector data, representing bytevectors (*note stdlib bytevector::),
are represented using the notation '#vu8(<u8> ...)', where the ?U8s
represent the octets of the bytevector.  For example, a bytevector of
length 3 containing the octets 2, 24, and 123 can be represented as
follows:

     #vu8(2 24 123)

   This is the external representation of a bytevector, and also an
expression that evaluates to a bytevector.


File: vicare-scheme.info,  Node: scheme lex datum abbreviations,  Prev: scheme lex datum bytevectors,  Up: scheme lex datum

3.4.4.5 Abbreviations
.....................

      '<datum>        `<datum>        ,<datum>
     ,@<datum>       #'<datum>       #`<datum>
     #,<datum>      #,@<datum>

   Each of these is an abbreviation:

''<datum>'
     for '(quote <datum>)',

'`<datum>'
     for '(quasiquote <datum>)',

',<datum>'
     for '(unquote <datum>)',

',@<datum>'
     for '(unquote-splicing <datum>)',

'#'<datum>'
     for '(syntax <datum>)',

'#`<datum>'
     for '(quasisyntax <datum>)',

'#,<datum>'
     for '(unsyntax <datum>)', and

'#,@<datum>'
     for '(unsyntax-splicing <datum>)'.

   Notice that it is the source code _reader_ (the lexer and parser)
which builds the symbolic expression:

     (quote (a b c))

from the sequence of characters:

     '(a b c)

and this happens before any library is loaded, so the source code
expander only sees the symbolic expression with the 'quote' symbol in
it.  So, while the following program works because the library '(rnrs)'
exports the 'quote' identifier:

     #!r6rs
     (import (rnrs))
     (write '(a b c))

the following program will fail:

     #!r6rs
     (import (except (rnrs) quote))
     (write '(a b c))

in exactly the same way the following program will fail:

     #!r6rs
     (import (except (rnrs) quote))
     (write (quote (a b c)))

because we have explicitly excluded 'quote' from the import set.  The
same happens with 'syntax' and the other abbreviations.

   Summary: once our eyes have adapted to use the abbreviations, and it
may take a while, they are of friendly usage; but we have to remember to
import libraries exporting 'quote', 'syntax' and the other abbreviated
identifiers.


File: vicare-scheme.info,  Node: scheme basic,  Next: scheme entry,  Prev: scheme lex,  Up: scheme

3.5 Semantic concepts
=====================

* Menu:

* scheme basic programs and libraries::      Programs and libraries.
* scheme basic variables keywords regions::  Variables, keywords,
                                             and regions.
* scheme basic exceptions::                  Exceptional situations.
* scheme basic argument checking::           Argument checking.
* scheme basic syntax violations::           Syntax violations.
* scheme basic safety::                      Safety.
* scheme basic boolean values::              Boolean values.
* scheme basic multiple return values::      Multiple return values.
* scheme basic unspecified behavior::        Unspecified behavior.
* scheme basic storage model::               Storage model.
* scheme basic proper tail recursion::       Proper tail recursion.
* scheme basic dynamic extent::              Dynamic extent and the
                                             dynamic environment.


File: vicare-scheme.info,  Node: scheme basic programs and libraries,  Next: scheme basic variables keywords regions,  Up: scheme basic

3.5.1 Programs and libraries
----------------------------

A Scheme program consists of a _top-level_ program together with a set
of _libraries_, each of which defines a part of the program connected to
the others through explicitly specified exports and imports.

   * A library consists of a set of export and import specifications and
     a body, which consists of definitions, and expressions.

   * A top-level program is similar to a library, but has no export
     specifications.

   Chapters "Libraries" and "Top-level programs" describe the syntax and
semantics of libraries and top-level programs, respectively.  Chapter
"Base library" describes a base library that defines many of the
constructs traditionally associated with Scheme.  A separate report
describes the various _standard libraries_ provided by a Scheme system.

   The division between the base library and the other standard
libraries is based on use, not on construction.  In particular, some
facilities that are typically implemented as "primitives" by a compiler
or the run-time system rather than in terms of other standard procedures
or syntactic forms are not part of the base library, but are defined in
separate libraries.  Examples include the fixnums and flonums libraries,
the exceptions and conditions libraries, and the libraries for records.


File: vicare-scheme.info,  Node: scheme basic variables keywords regions,  Next: scheme basic exceptions,  Prev: scheme basic programs and libraries,  Up: scheme basic

3.5.2 Variables, keywords, and regions
--------------------------------------

Within the body of a library or top-level program, an identifier may
name a kind of syntax, or it may name a location where a value can be
stored.  An identifier that names a kind of syntax is called a
"keyword", and is said to be "bound" to that kind of syntax (or, in the
case of a syntactic abstraction, a "transformer" that translates the
syntax into more primitive forms).  An identifier that names a location
is called a "variable" and is said to be "bound" to that location.  At
each point within a top-level program or a library, a specific, fixed
set of identifiers is bound; the set of these identifiers, the set of
_visible bindings_, is known as the "environment" in effect at that
point.

   Certain forms are used to create syntactic abstractions and to bind
keywords to transformers for those new syntactic abstractions, while
other forms create new locations and bind variables to those locations;
collectively, these forms are called "binding constructs".  Some binding
constructs take the form of _definitions_, while others are
_expressions_.  With the exception of exported library bindings, a
binding created by a definition is visible only within the body in which
the definition appears, e.g.  the body of a library, top-level program,
or 'lambda' expression.  Exported library bindings are also visible
within the bodies of the libraries and top-level programs that import
them.

   Expressions that bind variables include the 'lambda', 'let', 'let*',
'letrec', 'letrec*', 'let-values', and 'let*-values' forms from the base
library.  Of these, 'lambda' is the most fundamental.  Variable
definitions appearing within the body of such an expression, or within
the bodies of a library or top-level program, are treated as a set of
'letrec*' bindings.  In addition, for library bodies, the variables
exported from the library can be referenced by importing libraries and
top-level programs.

   Expressions that bind keywords include the 'let-syntax' and
'letrec-syntax' forms.  A 'define' form is a definition that creates a
variable binding, and a 'define-syntax' form is a definition that
creates a keyword binding.

   Scheme is a statically scoped language with block structure.  To each
place in a top-level program or library body where an identifier is
bound there corresponds a "region" of code within which the binding is
visible.  The region is determined by the particular binding construct
that establishes the binding; if the binding is established by a
'lambda' expression, for example, then its region is the entire 'lambda'
expression.  Every mention of an identifier refers to the binding of the
identifier that establishes the innermost of the regions containing the
use.  If a use of an identifier appears in a place where none of the
surrounding expressions contains a binding for the identifier, the use
may refer to a binding established by a definition or import at the top
of the enclosing library or top-level program.  If there is no binding
for the identifier, it is said to be "unbound".


File: vicare-scheme.info,  Node: scheme basic exceptions,  Next: scheme basic argument checking,  Prev: scheme basic variables keywords regions,  Up: scheme basic

3.5.3 Exceptional situations
----------------------------

A variety of exceptional situations are distinguished in this report,
among them violations of syntax, violations of a procedure's
specification, violations of implementation restrictions, and
exceptional situations in the environment.  When an exceptional
situation is detected by the implementation, an _exception is raised_,
which means that a special procedure called the _current exception
handler_ is called.  A program can also raise an exception, and override
the current exception handler; *note stdlib exceptions::.

   When an exception is raised, an object is provided that describes the
nature of the exceptional situation.  The report uses the condition
system described in library section "Conditions" to describe exceptional
situations, classifying them by condition types.

   Some exceptional situations allow continuing the program if the
exception handler takes appropriate action.  The corresponding
exceptions are called _continuable_.  For most of the exceptional
situations described in this report, portable programs cannot rely upon
the exception being continuable at the place where the situation was
detected.  For those exceptions, the exception handler that is invoked
by the exception should not return.  In some cases, however, continuing
is permissible, and the handler may return.  *note stdlib exceptions::

   Implementations must raise an exception when they are unable to
continue correct execution of a correct program due to some
_implementation restriction_.  For example, an implementation that does
not support infinities must raise an exception with condition type
'&implementation-restriction' when it evaluates an expression whose
result would be an infinity.

   Some possible implementation restrictions such as the lack of
representations for NaNs and infinities are anticipated by this report,
and implementations typically must raise an exception of the appropriate
condition type if they encounter such a situation.

   This report uses the phrase "an exception is raised" synonymously
with "an exception must be raised".  This report uses the phrase "an
exception with condition type T" to indicate that the object provided
with the exception is a condition object of the specified type.  The
phrase "a continuable exception is raised" indicates an exceptional
situation that permits the exception handler to return.


File: vicare-scheme.info,  Node: scheme basic argument checking,  Next: scheme basic syntax violations,  Prev: scheme basic exceptions,  Up: scheme basic

3.5.4 Argument checking
-----------------------

Many procedures specified in this report or as part of a standard
library restrict the arguments they accept.  Typically, a procedure
accepts only specific numbers and types of arguments.  Many syntactic
forms similarly restrict the values to which one or more of their
subforms can evaluate.  These restrictions imply responsibilities for
both the programmer and the implementation.  Specifically, the
programmer is responsible for ensuring that the values indeed adhere to
the restrictions described in the specification.  The implementation
must check that the restrictions in the specification are indeed met, to
the extent that it is reasonable, possible, and necessary to allow the
specified operation to complete successfully.

   Note that it is not always possible for an implementation to
completely check the restrictions set forth in a specification.  For
example, if an operation is specified to accept a procedure with
specific properties, checking of these properties is undecidable in
general.  Similarly, some operations accept both lists and procedures
that are called by these operations.  Since lists can be mutated by the
procedures through the '(rnrs mutable-pairs (6))' library, an argument
that is a list when the operation starts may become a non-list during
the execution of the operation.

   Also, the procedure might escape to a different continuation,
preventing the operation from performing more checks.  Requiring the
operation to check that the argument is a list after each call to such a
procedure would be impractical.  Furthermore, some operations that
accept lists only need to traverse these lists partially to perform
their function; requiring the implementation to traverse the remainder
of the list to verify that all specified restrictions have been met
might violate reasonable performance assumptions.  For these reasons,
the programmer's obligations may exceed the checking obligations of the
implementation.

   When an implementation detects a violation of a restriction for an
argument, it must raise an exception with condition type '&assertion' in
a way consistent with the safety of execution as described in section
"Safety".


File: vicare-scheme.info,  Node: scheme basic syntax violations,  Next: scheme basic safety,  Prev: scheme basic argument checking,  Up: scheme basic

3.5.5 Syntax violations
-----------------------

The subforms of a special form usually need to obey certain syntactic
restrictions.  As forms may be subject to macro expansion, which may not
terminate, the question of whether they obey the specified restrictions
is undecidable in general.

   When macro expansion terminates, however, implementations must detect
violations of the syntax.  A _syntax violation_ is an error with respect
to the syntax of library bodies, top-level bodies, or the "syntax"
entries in the specification of the base library or the standard
libraries.  Moreover, attempting to assign to an immutable variable
(i.e.  the variables exported by a library) is also considered a syntax
violation.

   If a top-level or library form in a program is not syntactically
correct, then the implementation must raise an exception with condition
type '&syntax', and execution of that top-level program or library must
not be allowed to begin.


File: vicare-scheme.info,  Node: scheme basic safety,  Next: scheme basic boolean values,  Prev: scheme basic syntax violations,  Up: scheme basic

3.5.6 Safety
------------

The standard libraries whose exports are described by this document are
said to be _safe libraries_.  Libraries and top-level programs that
import only from safe libraries are also said to be safe.

   As defined by this document, the Scheme programming language is safe
in the following sense: The execution of a safe top-level program cannot
go so badly wrong as to crash or to continue to execute while behaving
in ways that are inconsistent with the semantics described in this
document, unless an exception is raised.

   Violations of an implementation restriction must raise an exception
with condition type '&implementation-restriction', as must all
violations and errors that would otherwise threaten system integrity in
ways that might result in execution that is inconsistent with the
semantics described in this document.

   The above safety properties are guaranteed only for top-level
programs and libraries that are said to be safe.  In particular,
implementations may provide access to unsafe libraries in ways that
cannot guarantee safety.


File: vicare-scheme.info,  Node: scheme basic boolean values,  Next: scheme basic multiple return values,  Prev: scheme basic safety,  Up: scheme basic

3.5.7 Boolean values
--------------------

Although there is a separate boolean type, any Scheme value can be used
as a boolean value for the purpose of a conditional test.  In a
conditional test, all values count as true in such a test except for
'#f'.  This report uses the word "true" to refer to any Scheme value
except '#f', and the word "false" to refer to '#f'.


File: vicare-scheme.info,  Node: scheme basic multiple return values,  Next: scheme basic unspecified behavior,  Prev: scheme basic boolean values,  Up: scheme basic

3.5.8 Multiple return values
----------------------------

A Scheme expression can evaluate to an arbitrary finite number of
values.  These values are passed to the expression's continuation.

   Not all continuations accept any number of values.  For example, a
continuation that accepts the argument to a procedure call is guaranteed
to accept exactly one value.  The effect of passing some other number of
values to such a continuation is unspecified.  The 'call-with-values'
procedure makes it possible to create continuations that accept
specified numbers of return values.  If the number of return values
passed to a continuation created by a call to 'call-with-values' is not
accepted by its consumer that was passed in that call, then an exception
is raised.  A more complete description of the number of values accepted
by different continuations and the consequences of passing an unexpected
number of values is given in the description of the 'values' procedure.

   A number of forms in the base library have sequences of expressions
as subforms that are evaluated sequentially, with the return values of
all but the last expression being discarded.  The continuations
discarding these values accept any number of values.


File: vicare-scheme.info,  Node: scheme basic unspecified behavior,  Next: scheme basic storage model,  Prev: scheme basic multiple return values,  Up: scheme basic

3.5.9 Unspecified behavior
--------------------------

If an expression is said to "return unspecified values", then the
expression must evaluate without raising an exception, but the values
returned depend on the implementation; this report explicitly does not
say how many or what values should be returned.  Programmers should not
rely on a specific number of return values or the specific values
themselves.


File: vicare-scheme.info,  Node: scheme basic storage model,  Next: scheme basic proper tail recursion,  Prev: scheme basic unspecified behavior,  Up: scheme basic

3.5.10 Storage model
--------------------

Variables and objects such as pairs, vectors, bytevectors, strings,
hashtables, and records implicitly refer to locations or sequences of
locations.  A string, for example, contains as many locations as there
are characters in the string.  (These locations need not correspond to a
full machine word.)  A new value may be stored into one of these
locations using the 'string-set!' procedure, but the string contains the
same locations as before.

   An object fetched from a location, by a variable reference or by a
procedure such as 'car', 'vector-ref', or 'string-ref', is equivalent in
the sense of 'eqv?' to the object last stored in the location before the
fetch.

   Every location is marked to show whether it is in use.  No variable
or object ever refers to a location that is not in use.  Whenever this
report speaks of storage being allocated for a variable or object, what
is meant is that an appropriate number of locations are chosen from the
set of locations that are not in use, and the chosen locations are
marked to indicate that they are now in use before the variable or
object is made to refer to them.

   It is desirable for constants (i.e.  the values of literal
expressions) to reside in read-only memory.  To express this, it is
convenient to imagine that every object that refers to locations is
associated with a flag telling whether that object is mutable.  Literal
constants, the strings returned by 'symbol->string', records with no
mutable fields, and other values explicitly designated as immutable are
immutable objects, while all objects created by the other procedures
listed in this report are mutable.  An attempt to store a new value into
a location referred to by an immutable object should raise an exception
with condition type '&assertion'.


File: vicare-scheme.info,  Node: scheme basic proper tail recursion,  Next: scheme basic dynamic extent,  Prev: scheme basic storage model,  Up: scheme basic

3.5.11 Proper tail recursion
----------------------------

Implementations of Scheme must be _properly tail-recursive_.  Procedure
calls that occur in certain syntactic contexts called _tail contexts_
are _tail calls_.

   A Scheme implementation is properly tail-recursive if it supports an
unbounded number of active tail calls.  A call is _active_ if the called
procedure may still return.  Note that this includes regular returns as
well as returns through continuations captured earlier by
'call-with-current-continuation' that are later invoked.  In the absence
of captured continuations, calls could return at most once and the
active calls would be those that had not yet returned.  A formal
definition of proper tail recursion can be found in Clinger's paper
"Proper tail recursion and and space efficiency".  The rules for
identifying tail calls in constructs from the '(rnrs base (6))' library
are described in section "Tail calls and tail contexts".


File: vicare-scheme.info,  Node: scheme basic dynamic extent,  Prev: scheme basic proper tail recursion,  Up: scheme basic

3.5.12 Dynamic extent and the dynamic environment
-------------------------------------------------

For a procedure call, the time between when it is initiated and when it
returns is called its _dynamic extent_.  In Scheme,
'call-with-current-continuation' allows reentering a dynamic extent
after its procedure call has returned.  Thus, the dynamic extent of a
call may not be a single, connected time period.

   Some operations described in the report acquire information in
addition to their explicit arguments from the _dynamic environment_.
For example, 'call-with-current-continuation' accesses an implicit
context established by 'dynamic-wind', and the 'raise' procedure
accesses the current exception handler.

   The operations that modify the dynamic environment do so dynamically,
for the dynamic extent of a call to a procedure like 'dynamic-wind' or
'with-exception-handler'.  When such a call returns, the previous
dynamic environment is restored.  The dynamic environment can be thought
of as part of the dynamic extent of a call.  Consequently, it is
captured by 'call-with-current-continuation', and restored by invoking
the escape procedure it creates.


File: vicare-scheme.info,  Node: scheme entry,  Next: scheme library,  Prev: scheme basic,  Up: scheme

3.6 Entry format
================

The chapters that describe bindings in the base library and the standard
libraries are organized into entries.  Each entry describes one language
feature or a group of related features, where a feature is either a
syntactic construct or a built-in procedure.  An entry begins with one
or more header lines of the form

 -- Category: template
     ...

   The _Category_ defines the kind of binding described by the entry,
typically either "Syntax" or "Procedure".  An entry may specify various
restrictions on subforms or arguments.

* Menu:

* scheme entry syntax::              Syntax entries.
* scheme entry procedure::           Procedure entries.
* scheme entry implementation resp:: Implementation responsibilities.
* scheme entry other kinds::         Other kinds of entries.
* scheme entry equivalent::          Equivalent entries.
* scheme entry evaluation examples:: Evaluation examples.
* scheme entry naming conventions::  Naming conventions.


File: vicare-scheme.info,  Node: scheme entry syntax,  Next: scheme entry procedure,  Up: scheme entry

3.6.1 Syntax entries
--------------------

If _category_ is "Syntax", the entry describes a special syntactic
construct, and the template gives the syntax of the forms of the
construct.  The template is written in a notation similar to a
right-hand side of the BNF rules in chapter "Lexical syntax and datum
syntax", and describes the set of forms equivalent to the forms matching
the template as syntactic data.  Some "Syntax" entries carry a suffix
('expand'), specifying that the syntactic keyword of the construct is
exported with level 1.  Otherwise, the syntactic keyword is exported
with level 0; *note scheme library import export::.

   Components of the form described by a template are designated by
syntactic variables, which are written using angle brackets, for
example, ?EXPRESSION, ?VARIABLE.  Case is insignificant in syntactic
variables.  Syntactic variables stand for other forms, or sequences of
them.  A syntactic variable may refer to a non-terminal in the grammar
for syntactic data, in which case only forms matching that non-terminal
are permissible in that position.  For example, ?IDENTIFIER stands for a
form which must be an identifier.  Also, ?EXPRESSION stands for any form
which is a syntactically valid expression.  Other non-terminals that are
used in templates are defined as part of the specification.

   The notation

     ?THING1 ...

indicates zero or more occurrences of a ?THING, and

     ?THING1 ?THING2 ...

indicates one or more occurrences of a ?THING.

   It is the programmer's responsibility to ensure that each component
of a form has the shape specified by a template.  Descriptions of syntax
may express other restrictions on the components of a form.  Typically,
such a restriction is formulated as a phrase of the form "?X must be a
...".  Again, these specify the programmer's responsibility.  It is the
implementation's responsibility to check that these restrictions are
satisfied, as long as the macro transformers involved in expanding the
form terminate.  If the implementation detects that a component does not
meet the restriction, an exception with condition type '&syntax' is
raised.


File: vicare-scheme.info,  Node: scheme entry procedure,  Next: scheme entry implementation resp,  Prev: scheme entry syntax,  Up: scheme entry

3.6.2 Procedure entries
-----------------------

If _Category_ is "Procedure", then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Parameter
names in the template are shown like this: PARM.  Thus the header line:

 -- Procedure: vector-ref VECTOR K
     ...

indicates that the built-in procedure 'vector-ref' takes two arguments,
a vector VECTOR and an exact non-negative integer object K (see below).
The header lines:

 -- Procedure: procname K
     ...

 -- Procedure: procname K FILL
     ...

indicate that the 'make-vector' procedure takes either one or two
arguments.  The parameter names are case-insensitive.

   As with syntax templates, an ellipsis ... at the end of a header
line, as in:

 -- Procedure: the-proc Z1 Z2 Z3 ...
     ...

indicates that the procedure takes arbitrarily many arguments of the
same type as specified for the last parameter name.  In this case, '='
accepts two or more arguments that must all be complex number objects.

   A procedure that detects an argument that it is not specified to
handle must raise an exception with condition type '&assertion'.  Also,
the argument specifications are exhaustive: if the number of arguments
provided in a procedure call does not match any number of arguments
accepted by the procedure, an exception with condition type '&assertion'
must be raised.

   For succinctness, the report follows the convention that if a
parameter name is also the name of a type, then the corresponding
argument must be of the named type.  For example, the header line for
'vector-ref' given above dictates that the first argument to
'vector-ref' must be a vector.  The following naming conventions imply
type restrictions:

OBJ
     any object;

Z
     complex number object;

X
     real number object;

Y
     real number object;

Q
     rational number object;

N
     integer object;

K
     exact non-negative integer object;

BOOL
     boolean ('#f' or '#t');

OCTET
     exact integer object in {0, ..., 255};

BYTE
     exact integer object in {-128, ..., 127};

CHAR
     character;

PAIR
     pair;

VECTOR
     vector;

STRING
     string;

CONDITION
     condition;

BYTEVECTOR
     bytevector;

PROC
     procedure.

   Other type restrictions are expressed through parameter-naming
conventions that are described in specific chapters.  For example,
library chapter "Arithmetic" uses a number of special parameter
variables for the various subsets of the numbers.

   With the listed type restrictions, it is the programmer's
responsibility to ensure that the corresponding argument is of the
specified type.  It is the implementation's responsibility to check for
that type.

   A parameter called LIST means that it is the programmer's
responsibility to pass an argument that is a list.  It is the
implementation's responsibility to check that the argument is
appropriately structured for the operation to perform its function, to
the extent that this is possible and reasonable.  The implementation
must at least check that the argument is either an empty list or a pair.

   Descriptions of procedures may express other restrictions on the
arguments of a procedure.  Typically, such a restriction is formulated
as a phrase of the form "X must be a ..." (or otherwise using the word
"must").


File: vicare-scheme.info,  Node: scheme entry implementation resp,  Next: scheme entry other kinds,  Prev: scheme entry procedure,  Up: scheme entry

3.6.3 Implementation responsibilities
-------------------------------------

In addition to the restrictions implied by naming conventions, an entry
may list additional explicit restrictions.  These explicit restrictions
usually describe both the programmer's responsibilities, who must ensure
that the subforms of a form are appropriate, or that an appropriate
argument is passed, and the implementation's responsibilities, which
must check that subform adheres to the specified restrictions (if macro
expansion terminates), or if the argument is appropriate.

   A description may explicitly list the implementation's
responsibilities for some arguments or subforms in a paragraph labeled
"Implementation responsibilities".  In this case, the responsibilities
specified for these subforms or arguments in the rest of the description
are only for the programmer.  A paragraph describing implementation
responsibility does not affect the implementation's responsibilities for
checking subforms or arguments not mentioned in the paragraph.


File: vicare-scheme.info,  Node: scheme entry other kinds,  Next: scheme entry equivalent,  Prev: scheme entry implementation resp,  Up: scheme entry

3.6.4 Other kinds of entries
----------------------------

If _Category_ is something other than "Syntax" and "Procedure", then the
entry describes a non-procedural value, and the _category_ describes the
type of that value.  The header line:

 -- Condition Type: &who
     ...

indicates that '&who' is a condition type.  The header line:

 -- Auxiliary Syntax: unquote
     ...

indicates that 'unquote' is a syntax binding that may occur only as part
of specific surrounding expressions.  Any use as an independent
syntactic construct or identifier is a syntax violation.  As with
"Syntax" entries, some "Auxiliary Syntax" entries carry a suffix
('expand'), specifying that the syntactic keyword of the construct is
exported with level 1.


File: vicare-scheme.info,  Node: scheme entry equivalent,  Next: scheme entry evaluation examples,  Prev: scheme entry other kinds,  Up: scheme entry

3.6.5 Equivalent entries
------------------------

The description of an entry occasionally states that it is _the same_ as
another entry.  This means that both entries are equivalent.
Specifically, it means that if both entries have the same name and are
thus exported from different libraries, the entries from both libraries
can be imported under the same name without conflict.


File: vicare-scheme.info,  Node: scheme entry evaluation examples,  Next: scheme entry naming conventions,  Prev: scheme entry equivalent,  Up: scheme entry

3.6.6 Evaluation examples
-------------------------

The symbol '=>' used in program examples can be read "evaluates to".
For example:

     (* 5 8)
     => 40

means that the expression '(* 5 8)' evaluates to the object '40'.  Or,
more precisely: the expression given by the sequence of characters '(* 5
8)' evaluates, in an environment that imports the relevant library, to
an object that may be represented externally by the sequence of
characters '40'.

   The '=>' symbol is also used when the evaluation of an expression
causes a violation.  For example:

     (integer->char #xD800)
     => &assertion exception

means that the evaluation of the expression '(integer->char #xD800)'
must raise an exception with condition type '&assertion'.

   Moreover, the '=>' symbol is also used to explicitly say that the
value of an expression in unspecified.  For example:

     (eqv? "" "")
     => unspecified

   Mostly, examples merely illustrate the behavior specified in the
entry.  In some cases, however, they disambiguate otherwise ambiguous
specifications and are thus normative.  Note that, in some cases,
specifically in the case of inexact number objects, the return value is
only specified conditionally or approximately.  For example:

     (atan -inf.0)
     => -1.5707963267948965 ; approximately


File: vicare-scheme.info,  Node: scheme entry naming conventions,  Prev: scheme entry evaluation examples,  Up: scheme entry

3.6.7 Naming conventions
------------------------

By convention, the names of procedures that store values into previously
allocated locations usually end in '!'.

   By convention, '->' appears within the names of procedures that take
an object of one type and return an analogous object of another type.
For example, 'list->vector' takes a list and returns a vector whose
elements are the same as those of the list.

   By convention, the names of predicates (procedures that always return
a boolean value) end in '?' when the name contains any letters;
otherwise, the predicate's name does not end with a question mark.

   By convention, the components of compound names are separated by '-'.
In particular, prefixes that are actual words or can be pronounced as
though they were actual words are followed by a hyphen, except when the
first character following the hyphen would be something other than a
letter, in which case the hyphen is omitted.  Short, unpronounceable
prefixes ('fx' and 'fl') are not followed by a hyphen.

   By convention, the names of condition types start with '&'.


File: vicare-scheme.info,  Node: scheme library,  Next: scheme programs,  Prev: scheme entry,  Up: scheme

3.7 Libraries
=============

Libraries are parts of a program that can be distributed independently.
The library system supports macro definitions within libraries, macro
exports, and distinguishes the phases in which definitions and imports
are needed.  This chapter defines the notation for libraries and a
semantics for library expansion and execution.

* Menu:

* scheme library form::           Library form.
* scheme library import export::  Import and export levels.
* scheme library examples::       Examples.


File: vicare-scheme.info,  Node: scheme library form,  Next: scheme library import export,  Up: scheme library

3.7.1 Library form
------------------

A library definition must have the following form:

     (library ?LIBRARY-NAME
       (export ?EXPORT-SPEC ...)
       (import ?IMPORT-SPEC ...)
       ?LIBRARY-BODY)

   It is a syntax violation if a constraint given in this section is not
met.

* Menu:

* scheme library form decl::      Library declaration.
* scheme library form names::     Library names.
* scheme library form export::    The export specification.
* scheme library form import::    The import specification.
* scheme library form version::   The version reference.
* scheme library form conflicts:: Handling conflicts.
* scheme library form body::      Library bodies.


File: vicare-scheme.info,  Node: scheme library form decl,  Next: scheme library form names,  Up: scheme library form

3.7.1.1 Library declaration
...........................

A library declaration contains the following elements:

   * The ?LIBRARY-NAME specifies the name of the library (possibly with
     version).

   * The 'export' subform specifies a list of exports, which names a
     subset of the bindings defined within or imported into the library.

   * The 'import' subform specifies the imported bindings as a list of
     import dependencies, where each dependency specifies:

        - The imported library's name, and, optionally, constraints on
          its version.

        - The relevant levels, e.g.  expand or run time.

        - The subset of the library's exports to make available within
          the importing library, and the local names to use within the
          importing library for each of the library's exports.

   * The ?LIBRARY-BODY is the library body, consisting of a sequence of
     definitions followed by a sequence of expressions.  The definitions
     may be both for local (unexported) and exported bindings, and the
     expressions are initialization expressions to be evaluated for
     their effects.

   An identifier can be imported with the same local name from two or
more libraries or for two levels from the same library only if the
binding exported by each library is the same (i.e., the binding is
defined in one library, and it arrives through the imports only by
exporting and re-exporting).  Otherwise, no identifier can be imported
multiple times, defined multiple times, or both defined and imported.
No identifiers are visible within a library except for those explicitly
imported into the library or defined within the library.


File: vicare-scheme.info,  Node: scheme library form names,  Next: scheme library form export,  Prev: scheme library form decl,  Up: scheme library form

3.7.1.2 Library names
.....................

A ?LIBRARY-NAME uniquely identifies a library within an implementation,
and is globally visible in the 'import' clauses of all other libraries
within an implementation.  A ?LIBRARY-NAME has the following form:

     (?IDENTIFIER1 ?IDENTIFIER2 ... ?VERSION)

where ?VERSION is empty or has the following form:

     (?SUB-VERSION ...)

   Each ?SUB-VERSION must represent an exact nonnegative integer object.
An empty ?VERSION is equivalent to '()'.


File: vicare-scheme.info,  Node: scheme library form export,  Next: scheme library form import,  Prev: scheme library form names,  Up: scheme library form

3.7.1.3 The export specification
................................

An ?EXPORT-SPEC names a set of imported and locally defined bindings to
be exported, possibly with different external names.  An ?EXPORT-SPEC
must have one of the following forms:

     ?IDENTIFIER
     (rename (?IDENTIFIER1 ?IDENTIFIER2)
             ...)

   In an ?EXPORT-SPEC, an ?IDENTIFIER names a single binding defined
within or imported into the library, where the external name for the
export is the same as the name of the binding within the library.  A
'rename' spec exports the binding named by ?IDENTIFIER1 in each
'(?IDENTIFIER1 ?IDENTIFIER2)' pairing, using ?IDENTIFIER2 as the
external name.


File: vicare-scheme.info,  Node: scheme library form import,  Next: scheme library form version,  Prev: scheme library form export,  Up: scheme library form

3.7.1.4 The import specification
................................

Each ?IMPORT-SPEC specifies a set of bindings to be imported into the
library, the levels at which they are to be available, and the local
names by which they are to be known.  An ?IMPORT-SPEC must be one of the
following:

     ?IMPORT-SET
     (for ?IMPORT-SET ?IMPORT-LEVEL ...)

   An ?IMPORT-LEVEL is one of the following:

     run
     expand
     (meta ?LEVEL)

where ?LEVEL represents an exact integer object.

   As an ?IMPORT-LEVEL, 'run' is an abbreviation for '(meta 0)', and
'expand' is an abbreviation for '(meta 1)'.

   An ?IMPORT-SET names a set of bindings from another library and
possibly specifies local names for the imported bindings.  It must be
one of the following:

     ?LIBRARY-REFERENCE
     (library ?LIBRARY-REFERENCE)
     (only ?IMPORT-SET ?IDENTIFIER ...)
     (except ?IMPORT-SET ?IDENTIFIER ...)
     (prefix ?IMPORT-SET ?IDENTIFIER)
     (rename ?IMPORT-SET (?IDENTIFIER1 ?IDENTIFIER2) ...)

   A ?LIBRARY-REFERENCE identifies a library by its name and optionally
by its version.  It has one of the following forms:

     (?IDENTIFIER1 ?IDENTIFIER2 ...)
     (?IDENTIFIER1 ?IDENTIFIER2 ... ?VERSION-REFERENCE)

   A ?LIBRARY-REFERENCE whose first ?IDENTIFIER is 'for', 'library',
'only', 'except', 'prefix', or 'rename' is permitted only within a
'(library ?LIBRARY-REFERENCE)' ?IMPORT-SET.  The ?IMPORT-SET '(library
?LIBRARY-REFERENCE)' is otherwise equivalent to ?LIBRARY-REFERENCE.

   A ?LIBRARY-REFERENCE with no ?VERSION-REFERENCE (first form above) is
equivalent to a ?LIBRARY-REFERENCE with a ?VERSION-REFERENCE of '()'.


File: vicare-scheme.info,  Node: scheme library form version,  Next: scheme library form conflicts,  Prev: scheme library form import,  Up: scheme library form

3.7.1.5 The version reference
.............................

A ?VERSION-REFERENCE specifies a set of ?VERSIONs that it matches.  The
?LIBRARY-REFERENCE identifies all libraries of the same name and whose
version is matched by the ?VERSION-REFERENCE.  A ?VERSION-REFERENCE has
the following form:

     (?SUB-VERSION-REFERENCE1 ... ?SUB-VERSION-REFERENCEN)
     (and ?VERSION-REFERENCE ...)
     (or ?VERSION-REFERENCE ...)
     (not ?VERSION-REFERENCE)

   A ?VERSION-REFERENCE of the first form matches a ?VERSION with at
least N elements, whose ?SUB-VERSION-REFERENCEs match the corresponding
?SUB-VERSIONs.  An 'and' ?VERSION REFERENCE matches a version if all
?VERSION-REFERENCES following the 'and' match it.  Correspondingly, an
'or' ?VERSION-REFERENCE matches a version if one of ?VERSION-REFERENCES
following the 'or' matches it, and a 'not' ?VERSION-REFERENCE matches a
version if the ?VERSION-REFERENCE following it does not match it.

   A ?SUB-VERSION-REFERENCE has one of the following forms:

     ?SUB-VERSION
     (>= ?SUB-VERSION)
     (<= ?SUB-VERSION)
     (and ?SUB-VERSION-REFERENCE ...)
     (or ?SUB-VERSION-REFERENCE ...)
     (not ?SUB-VERSION-REFERENCE)

   A ?SUB-VERSION-REFERENCE of the first form matches a ?SUB-VERSION if
it is equal to it.  A '>=' ?SUB-VERSION-REFERENCE of the first form
matches a sub-version if it is greater or equal to the ?SUB-VERSION
following it; analogously for '<='.  An 'and' ?SUB-VERSION-REFERENCE
matches a sub-version if all of the subsequent ?SUB-VERSION-REFERENCEs
match it.

   Correspondingly, an 'or' ?SUB-VERSION-REFERENCE matches a sub-version
if one of the subsequent ?SUB-VERSION-REFERENCEs matches it, and a 'not'
?SUB-VERSION-REFERENCE matches a sub-version if the subsequent
?SUB-VERSION-REFERENCE does not match it.

   Examples:

version reference       version     match?
---------------------------------------------
'()'                    '(1)'       yes
'(1)'                   '(1)'       yes
'(1)'                   '(2)'       no
'(2 3)'                 '(2)'       no
'(2 3)'                 '(2 3)'     yes
'(2 3)'                 '(2 3 5)'   yes
'(or (1 (>= 1)) (2))'   '(2)'       yes
'(or (1 (>= 1)) (2))'   '(1 1)'     yes
'(or (1 (>= 1)) (2))'   '(1 0)'     no
'((or 1 2 3))'          '(1)'       yes
'((or 1 2 3))'          '(2)'       yes
'((or 1 2 3))'          '(3)'       yes
'((or 1 2 3))'          '(4)'       no


File: vicare-scheme.info,  Node: scheme library form conflicts,  Next: scheme library form body,  Prev: scheme library form version,  Up: scheme library form

3.7.1.6 Handling conflicts
..........................

When more than one library is identified by a library reference, the
choice of libraries is determined in some implementation-dependent
manner.

   To avoid problems such as incompatible types and replicated state,
implementations should prohibit the two libraries whose library names
consist of the same sequence of identifiers but whose versions do not
match to co-exist in the same program.

   By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the
bindings by the imported library.  The precise set of bindings to be
imported and the names of those bindings can be adjusted with the
'only', 'except', 'prefix', and 'rename' forms as described below.

'only'
     Produces a subset of the bindings from another ?IMPORT-SET,
     including only the listed ?IDENTIFIERs.  The included ?IDENTIFIERs
     must be in the original ?IMPORT-SET.

'except'
     Produces a subset of the bindings from another ?IMPORT-SET,
     including all but the listed ?IDENTIFIERs.  All of the excluded
     ?IDENTIFIERs must be in the original ?IMPORT SET.

'prefix'
     Adds the ?IDENTIFIER prefix to each name from another ?IMPORT-SET.

'rename'
     Used as:

          (rename (?IDENTIFIER1 ?IDENTIFIER2)
                  ...)

     removes the bindings for '?IDENTIFIER1 ...' to form an intermediate
     ?IMPORT-SET, then adds the bindings back for the corresponding
     '?IDENTIFIER2 ...' to form the final ?IMPORT-SET.  Each
     ?IDENTIFIER1 must be in the original ?IMPORT-SET, each ?IDENTIFIER2
     must not be in the intermediate ?IMPORT-SET, and the ?IDENTIFIER2s
     must be distinct.


File: vicare-scheme.info,  Node: scheme library form body,  Prev: scheme library form conflicts,  Up: scheme library form

3.7.1.7 Library bodies
......................

The ?LIBRARY-BODY of a 'library' form consists of forms that are
classified as _definitions_ or _expressions_.  Which forms belong to
which class depends on the imported libraries and the result of
expansion.  Generally, forms that are not definitions are expressions.

   A ?LIBRARY-BODY is like a ?BODY except that a ?LIBRARY-BODYs need not
include any expressions.  It must have the following form:

     ?DEFINITION ... ?EXPRESSION ...

   When 'begin', 'let-syntax', or 'letrec-syntax' forms occur in a
top-level body prior to the first expression, they are spliced into the
body.  Some or all of the body, including portions wrapped in 'begin',
'let-syntax', or 'letrec-syntax' forms, may be specified by a syntactic
abstraction.

   The transformer expressions and bindings are evaluated and created
from left to right, as described in *note Expansion process: scheme
expansion. The expressions of variable definitions are evaluated from
left to right, as if in an implicit 'letrec*', and the body expressions
are also evaluated from left to right after the expressions of the
variable definitions.  A fresh location is created for each exported
variable and initialized to the value of its local counterpart.  The
effect of returning twice to the continuation of the last body
expression is unspecified.

     *NOTE* The names 'library', 'export', 'import', 'for', 'run',
     'expand', 'meta', 'import', 'export', 'only', 'except', 'prefix',
     'rename', 'and', 'or', 'not', '>=', and '<=' appearing in the
     library syntax are part of the syntax and are not reserved, i.e.,
     the same names can be used for other purposes within the library or
     even exported from or imported into a library with different
     meanings, without affecting their use in the 'library' form.

   Bindings defined with a library are not visible in code outside of
the library, unless the bindings are explicitly exported from the
library.  An exported macro may, however, _implicitly export_ an
otherwise unexported identifier defined within or imported into the
library.  That is, it may insert a reference to that identifier into the
output code it produces.

   All explicitly exported variables are immutable in both the exporting
and importing libraries.  It is thus a syntax violation if an explicitly
exported variable appears on the left-hand side of a 'set!' expression,
either in the exporting or importing libraries.

   All implicitly exported variables are also immutable in both the
exporting and importing libraries.  It is thus a syntax violation if a
variable appears on the left-hand side of a 'set!' expression in any
code produced by an exported macro outside of the library in which the
variable is defined.  It is also a syntax violation if a reference to an
assigned variable appears in any code produced by an exported macro
outside of the library in which the variable is defined, where an
assigned variable is one that appears on the left-hand side of a 'set!'
expression in the exporting library.

   All other variables defined within a library are mutable.


File: vicare-scheme.info,  Node: scheme library import export,  Next: scheme library examples,  Prev: scheme library form,  Up: scheme library

3.7.2 Import and export levels
------------------------------

Expanding a library may require run-time information from another
library.  For example, if a macro transformer calls a procedure from
library A, then the library A must be instantiated before expanding any
use of the macro in library B. Library A may not be needed when library
B is eventually run as part of a program, or it may be needed for run
time of library B, too.  The library mechanism distinguishes these times
by phases, which are explained in this section.

   Every library can be characterized by expand-time information
(minimally, its imported libraries, a list of the exported keywords, a
list of the exported variables, and code to evaluate the transformer
expressions) and run-time information (minimally, code to evaluate the
variable definition right-hand-side expressions, and code to evaluate
the body expressions).  The expand-time information must be available to
expand references to any exported binding, and the run-time information
must be available to evaluate references to any exported variable
binding.

   A _phase_ is a time at which the expressions within a library are
evaluated.  Within a library body, top-level expressions and the
right-hand sides of 'define' forms are evaluated at run time, i.e.
phase 0, and the right-hand sides of 'define-syntax' forms are evaluated
at expand time, i.e.  phase 1.  When 'define-syntax', 'let-syntax', or
'letrec-syntax' forms appear within code evaluated at phase n, the
right-hand sides are evaluated at phase n+1.

   These phases are relative to the phase in which the library itself is
used.  An _instance_ of a library corresponds to an evaluation of its
variable definitions and expressions in a particular phase relative to
another library--a process called _instantiation_.  For example, if a
top-level expression in a library B refers to a variable export from
another library A, then it refers to the export from an instance of A at
phase 0 (relative to the phase of B). But if a phase 1 expression within
B refers to the same binding from A, then it refers to the export from
an instance of A at phase 1 (relative to the phase of B).

   A _visit_ of a library corresponds to the evaluation of its syntax
definitions in a particular phase relative to another library; a process
called _visiting_.  For example, if a top-level expression in a library
B refers to a macro export from another library A, then it refers to the
export from a visit of A at phase 0 (relative to the phase of B), which
corresponds to the evaluation of the macro's transformer expression at
phase 1.

   A _level_ is a lexical property of an identifier that determines in
which phases it can be referenced.  The level for each identifier bound
by a definition within a library is 0; that is, the identifier can be
referenced only at phase 0 within the library.  The level for each
imported binding is determined by the enclosing 'for' form of the
'import' in the importing library, in addition to the levels of the
identifier in the exporting library.  Import and export levels are
combined by pairwise addition of all level combinations.  For example,
references to an imported identifier exported for levels p_a and p_b and
imported for levels q_a, q_b, and q_c are valid at levels p_a + q_a, p_a
+ q_b, p_a + q_c, p_b + q_a, p_b + q_b, and p_b + q_c.  An ?IMPORT-SET
without an enclosing 'for' is equivalent to '(for ?IMPORT-SET run)',
which is the same as '(for ?IMPORT-SET (meta 0))'.

   The export level of an exported binding is 0 for all bindings that
are defined within the exporting library.  The export levels of a
reexported binding, i.e.  an export imported from another library, are
the same as the effective import levels of that binding within the
reexporting library.

   For the libraries defined in the library report, the export level is
0 for nearly all bindings.  The exceptions are 'syntax-rules',
'identifier-syntax', '...', and '_' from the '(rnrs base (6))' library,
which are exported with level 1, 'set!' from the '(rnrs base (6))'
library, which is exported with levels 0 and 1, and all bindings from
the composite '(rnrs (6))' library, which are exported with levels 0 and
1.

   Macro expansion within a library can introduce a reference to an
identifier that is not explicitly imported into the library.  In that
case, the phase of the reference must match the identifier's level as
shifted by the difference between the phase of the source library (i.e.,
the library that supplied the identifier's lexical context) and the
library that encloses the reference.  For example, suppose that
expanding a library invokes a macro transformer, and the evaluation of
the macro transformer refers to an identifier that is exported from
another library (so the phase 1 instance of the library is used);
suppose further that the value of the binding is a syntax object
representing an identifier with only a level n binding; then, the
identifier must be used only at phase n+1 in the library being expanded.
This combination of levels and phases is why negative levels on
identifiers can be useful, even though libraries exist only at
non-negative phases.

   If any of a library's definitions are referenced at phase 0 in the
expanded form of a program, then an instance of the referenced library
is created for phase 0 before the program's definitions and expressions
are evaluated.  This rule applies transitively: if the expanded form of
one library references at phase 0 an identifier from another library,
then before the referencing library is instantiated at phase n, the
referenced library must be instantiated at phase n.  When an identifier
is referenced at any phase n greater than 0, in contrast, then the
defining library is instantiated at phase n at some unspecified time
before the reference is evaluated.  Similarly, when a macro keyword is
referenced at phase n during the expansion of a library, then the
defining library is visited at phase n at some unspecified time before
the reference is evaluated.

   An implementation may distinguish instances/visits of a library for
different phases or to use an instance/visit at any phase as an
instance/visit at any other phase.  An implementation may further expand
each 'library' form with distinct visits of libraries in any phase
and/or instances of libraries in phases above 0.  An implementation may
create instances/visits of more libraries at more phases than required
to satisfy references.  When an identifier appears as an expression in a
phase that is inconsistent with the identifier's level, then an
implementation may raise an exception either at expand time or run time,
or it may allow the reference.  Thus, a library whose meaning depends on
whether the instances of a library are distinguished or shared across
phases or 'library' expansions may be unportable.


File: vicare-scheme.info,  Node: scheme library examples,  Prev: scheme library import export,  Up: scheme library

3.7.3 Examples
--------------

Examples for various ?IMPORT-SPECs and ?EXPORT-SPECs:

     (library (stack)
       (export make push! pop! empty!)
       (import (rnrs)
               (rnrs mutable-pairs))

       (define (make)
         (list '()))
       (define (push! s v)
         (set-car! s (cons v (car s))))
       (define (pop! s)
         (let ([v (caar s)])
           (set-car! s (cdar s))
           v))
       (define (empty! s)
         (set-car! s '())))

     (library (balloons)
       (export make push pop)
       (import (rnrs))

       (define (make w h)
         (cons w h))
       (define (push b amt)
         (cons (- (car b) amt)
               (+ (cdr b) amt)))
       (define (pop b)
         (display "Boom! ")
         (display (* (car b) (cdr b)))
         (newline)))

     (library (party)
       ;; Total exports:
       ;; make, push, push!, make-party, pop!
       (export (rename (balloon:make make)
                       (balloon:push push))
               push!
               make-party
               (rename (party-pop! pop!)))
       (import (rnrs)
               (only (stack) make push! pop!) ; not empty!
               (prefix (balloons) balloon:))

       ;; Creates a party as a stack of balloons,
       ;; starting with two balloons
       (define (make-party)
         (let ([s (make)]) ; from stack
           (push! s (balloon:make 10 10))
           (push! s (balloon:make 12 9))
           s))
       (define (party-pop! p)
         (balloon:pop (pop! p))))


     (library (main)
       (export)
       (import (rnrs) (party))

       (define p (make-party))
       (pop! p)        ; displays "Boom! 108"
       (push! p (push (make 5 5) 1))
       (pop! p))       ; displays "Boom! 24"

   Examples for macros and phases:

     (library (my-helpers id-stuff)
       (export find-dup)
       (import (rnrs))

       (define (find-dup l)
         (and (pair? l)
              (let loop ((rest (cdr l)))
                (cond
                 [(null? rest) (find-dup (cdr l))]
                 [(bound-identifier=? (car l) (car rest))
                  (car rest)]
                 [else (loop (cdr rest))])))))

     (library (my-helpers values-stuff)
       (export mvlet)
       (import (rnrs) (for (my-helpers id-stuff) expand))

       (define-syntax mvlet
         (lambda (stx)
           (syntax-case stx ()
             [(_ [(id ...) expr] body0 body ...)
              (not (find-dup (syntax (id ...))))
              (syntax
                (call-with-values
                    (lambda () expr)
                  (lambda (id ...) body0 body ...)))]))))

     (library (let-div)
       (export let-div)
       (import (rnrs)
               (my-helpers values-stuff)
               (rnrs r5rs))

       (define (quotient+remainder n d)
         (let ([q (quotient n d)])
           (values q (- n (* q d)))))
       (define-syntax let-div
         (syntax-rules ()
           [(_ n d (q r) body0 body ...)
            (mvlet [(q r) (quotient+remainder n d)]
              body0 body ...)])))


File: vicare-scheme.info,  Node: scheme programs,  Next: scheme syntax,  Prev: scheme library,  Up: scheme

3.8 Top-level programs
======================

A "top-level program" specifies an entry point for defining and running
a Scheme program.  A top-level program specifies a set of libraries to
import and code to run.  Through the imported libraries, whether
directly or through the transitive closure of importing, a top-level
program defines a complete Scheme program.

* Menu:

* scheme programs syntax::      Top-level program syntax.
* scheme programs semantics::   Top-level program semantics.


File: vicare-scheme.info,  Node: scheme programs syntax,  Next: scheme programs semantics,  Up: scheme programs

3.8.1 Top-level program syntax
------------------------------

A top-level program is a delimited piece of text, typically a file, that
has the following form:

     ?IMPORT-FORM ?TOP-LEVEL-BODY

   An ?IMPORT-FORM has the following form:

     (import ?IMPORT-SPEC ...)

   A ?TOP-LEVEL-BODY has the following form:

     ?TOP-LEVEL-BODY-FORM ...

   A ?TOP-LEVEL BODY FORM is either a ?DEFINITION or an ?EXPRESSION.

   The ?IMPORT-FORM is identical to the import clause in libraries, and
specifies a set of libraries to import.  A ?TOP-LEVEL-BODY is like a
?LIBRARY-BODY, except that definitions and expressions may occur in any
order.  Thus, the syntax specified by ?TOP-LEVEL-BODY-FORM refers to the
result of macro expansion.

   When uses of 'begin', 'let-syntax', or 'letrec-syntax' from the
'(rnrs base (6))' library occur in a top-level body prior to the first
expression, they are spliced into the body.  Some or all of the body,
including portions wrapped in 'begin', 'let-syntax', or 'letrec-syntax'
forms, may be specified by a syntactic abstraction.


File: vicare-scheme.info,  Node: scheme programs semantics,  Prev: scheme programs syntax,  Up: scheme programs

3.8.2 Top-level program semantics
---------------------------------

A top-level program is executed by treating the program similarly to a
library, and evaluating its definitions and expressions.  The semantics
of a top-level body may be roughly explained by a simple translation
into a library body: Each ?EXPRESSION that appears before a definition
in the top-level body is converted into a dummy definition

     (define ?VARIABLE
       (begin ?EXPRESSION ?UNSPECIFIED))

   where ?VARIABLE is a fresh identifier and ?UNSPECIFIED is a
side-effect-free expression returning an unspecified value.  (It is
generally impossible to determine which forms are definitions and
expressions without concurrently expanding the body, so the actual
translation is somewhat more complicated.)

   On platforms that support it, a top-level program may access its
command line by calling the 'command-line' procedure, *note Command line
access and exit values: stdlib programlib.


File: vicare-scheme.info,  Node: scheme syntax,  Next: scheme expansion,  Prev: scheme programs,  Up: scheme

3.9 Primitive syntax
====================

After the 'import' form within a 'library' form or a top-level program,
the forms that constitute the body of the library or the top-level
program depend on the libraries that are imported.  In particular,
imported syntactic keywords determine the available syntactic
abstractions and whether each form is a definition or expression.  A few
form types are always available independent of imported libraries,
however, including constant literals, variable references, procedure
calls, and macro uses.

* Menu:

* scheme syntax primitive::     Primitive expression types.
* scheme syntax macros::        Macros.


File: vicare-scheme.info,  Node: scheme syntax primitive,  Next: scheme syntax macros,  Up: scheme syntax

3.9.1 Primitive expression types
--------------------------------

The entries in this section all describe expressions, which may occur in
the place of ?EXPRESSION syntactic variables.

Constant literals
.................

 -- Syntax: ?NUMBER
 -- Syntax: ?BOOLEAN
 -- Syntax: ?CHARACTER
 -- Syntax: ?STRING
 -- Syntax: ?BYTEVECTOR
     An expression consisting of a representation of a number object, a
     boolean, a character, a string, or a bytevector, evaluates "to
     itself".

          145932          =>  145932
          #t              =>  #t
          "abc"           =>  "abc"
          #vu8(2 24 123)  => #vu8(2 24 123)

     The value of a literal expression is immutable, *note Storage
     model: scheme basic storage model.

Variable references
...................

 -- Syntax: ?VARIABLE
     An expression consisting of a variable is a variable reference if
     it is not a macro use (see below).  The value of the variable
     reference is the value stored in the location to which the variable
     is bound.  It is a syntax violation to reference an unbound
     variable.

     The following example assumes the base library has been imported:

          (define x 28)
          x => 28

Procedure calls
...............

 -- Syntax: ?OPERATOR ?OPERAND1 ...
     A procedure call consists of expressions for the procedure to be
     called and the arguments to be passed to it, with enclosing
     parentheses.  A form in an expression context is a procedure call
     if ?OPERATOR is not an identifier bound as a syntactic keyword.

     When a procedure call is evaluated, the operator and operand
     expressions are evaluated (in an unspecified order) and the
     resulting procedure is passed the resulting arguments.

     The following examples assume the '(rnrs base (6))' library has
     been imported:

          (+ 3 4)                 => 7
          ((if #f + *) 3 4)       => 12

     If the value of ?OPERATOR is not a procedure, an exception with
     condition type '&assertion' is raised.  Also, if ?OPERATOR does not
     accept as many arguments as there are ?OPERANDs, an exception with
     condition type '&assertion' is raised.

          *NOTE* In contrast to other dialects of Lisp, the order of
          evaluation is unspecified, and the operator expression and the
          operand expressions are always evaluated with the same
          evaluation rules.

          Although the order of evaluation is otherwise unspecified, the
          effect of any concurrent evaluation of the operator and
          operand expressions is constrained to be consistent with some
          sequential order of evaluation.  The order of evaluation may
          be chosen differently for each procedure call.

          *NOTE* In many dialects of Lisp, the form '()' is a legitimate
          expression.  In Scheme, expressions written as list/pair forms
          must have at least one subexpression, so '()' is not a
          syntactically valid expression.


File: vicare-scheme.info,  Node: scheme syntax macros,  Prev: scheme syntax primitive,  Up: scheme syntax

3.9.2 Macros
------------

Libraries and top-level programs can define and use new kinds of derived
expressions and definitions called "syntactic abstractions" or "macros".
A syntactic abstraction is created by binding a keyword to a "macro
transformer" or, simply, "transformer".

   The transformer determines how a use of the macro (called a "macro
use") is transcribed into a more primitive form.

   Most macro uses have the form:

     (?KEYWORD ?DATUM ...)

where ?KEYWORD is an identifier that uniquely determines the kind of
form.  This identifier is called the "syntactic keyword", or simply
"keyword".  The number of ?DATUMs and the syntax of each depends on the
syntactic abstraction.

   Macro uses can also take the form of improper lists, singleton
identifiers, or 'set!' forms, where the second subform of the 'set!' is
the keyword:

     (?KEYWORD ?DATUM ... . ?DATUM)
     ?KEYWORD
     (set! ?KEYWORD ?DATUM)

   The 'define-syntax', 'let-syntax' and 'letrec-syntax' forms create
bindings for keywords, associate them with macro transformers, and
control the scope within which they are visible.

   The 'syntax-rules' and 'identifier-syntax' forms create transformers
via a pattern language.  Moreover, the 'syntax-case' form allows
creating transformers via arbitrary Scheme code.

   Keywords occupy the same name space as variables.  That is, within
the same scope, an identifier can be bound as a variable or keyword, or
neither, but not both, and local bindings of either kind may shadow
other bindings of either kind.

   Macros defined using 'syntax-rules' and 'identifier-syntax' are
"hygienic" and "referentially transparent" and thus preserve Scheme's
lexical scoping.

   * If a macro transformer inserts a binding for an identifier
     (variable or keyword) not appearing in the macro use, the
     identifier is in effect renamed throughout its scope to avoid
     conflicts with other identifiers.

   * If a macro transformer inserts a free reference to an identifier,
     the reference refers to the binding that was visible where the
     transformer was specified, regardless of any local bindings that
     may surround the use of the macro.

   Macros defined using the 'syntax-case' facility are also hygienic
unless 'datum->syntax' is used.


File: vicare-scheme.info,  Node: scheme expansion,  Next: scheme derived,  Prev: scheme syntax,  Up: scheme

3.10 Expansion process
======================

Macro uses are expanded into "core forms" at the start of evaluation
(before compilation or interpretation) by a syntax "expander".  The set
of core forms is implementation-dependent, as is the representation of
these forms in the expander's output.

   * If the expander encounters a syntactic abstraction, it invokes the
     associated transformer to expand the syntactic abstraction, then
     repeats the expansion process for the form returned by the
     transformer.

   * If the expander encounters a core form, it recursively processes
     its subforms that are in expression or definition context, if any,
     and reconstructs the form from the expanded subforms.

   Information about identifier bindings is maintained during expansion
to enforce lexical scoping for variables and keywords.

   To handle definitions, the expander processes the initial forms in a
?BODY or ?LIBRARY-BODY from left to right.  How the expander processes
each form encountered depends upon the kind of form.

macro use
     The expander invokes the associated transformer to transform the
     macro use, then recursively performs whichever of these actions are
     appropriate for the resulting form.

'define-syntax' form
     The expander expands and evaluates the right-hand-side expression
     and binds the keyword to the resulting transformer.

'define' form
     The expander records the fact that the defined identifier is a
     variable but defers expansion of the right-hand-side expression
     until after all of the definitions have been processed.

'begin' form
     The expander splices the subforms into the list of body forms it is
     processing.

'let-syntax' or 'letrec-syntax' form
     The expander splices the inner body forms into the list of (outer)
     body forms it is processing, arranging for the keywords bound by
     the 'let-syntax' and 'letrec-syntax' to be visible only in the
     inner body forms.

expression, i.e., nondefinition
     The expander completes the expansion of the deferred
     right-hand-side expressions and the current and remaining
     expressions in the body, and then creates the equivalent of a
     'letrec*' form from the defined variables, expanded right-hand-side
     expressions, and expanded body expressions.

   For the right-hand side of the definition of a variable, expansion is
deferred until after all of the definitions have been seen.
Consequently, each keyword and variable reference within the right-hand
side resolves to the local binding, if any.

   A definition in the sequence of forms must not define any identifier
whose binding is used to determine the meaning of the undeferred
portions of the definition or any definition that precedes it in the
sequence of forms.  For example, the bodies of the following expressions
violate this restriction.

     (let ()
       (define define 17)
       (list define))

     (let-syntax ((def0 (syntax-rules ()
                          ((_ x) (define x 0)))))
       (let ((z 3))
         (def0 z)
         (define def0 list)
         (list z)))

     (let ()
       (define-syntax foo
         (lambda (e)
           (+ 1 2)))
       (define + 2)
       (foo))

   The following do not violate the restriction.

     (let ((x 5))
       (define lambda list)
       (lambda x x))         =>  (5 5)

     (let-syntax ((def0 (syntax-rules ()
                          ((_ x) (define x 0)))))
       (let ((z 3))
         (define def0 list)
         (def0 z)
         (list z)))          =>  (3)

     (let ()
       (define-syntax foo
         (lambda (e)
           (let ((+ -)) (+ 1 2))))
       (define + 2)
       (foo))                =>  -1

   The implementation should treat a violation of the restriction as a
syntax violation.

   Note that this algorithm does not directly reprocess any form.  It
requires a single left-to-right pass over the definitions followed by a
single pass (in any order) over the body expressions and deferred
right-hand sides.

   Example:

     (lambda (x)
       (define-syntax defun
         (syntax-rules ()
           ((_ x a e) (define x (lambda a e)))))
       (defun even? (n) (or (= n 0) (odd? (- n 1))))
       (define-syntax odd?
         (syntax-rules () ((_ n) (not (even? n)))))
       (odd? (if (odd? x) (* x x) x)))

   In the example:

  1. The definition of 'defun' is encountered first, and the keyword
     'defun' is associated with the transformer resulting from the
     expansion and evaluation of the corresponding right-hand side.

  2. A use of 'defun' is encountered next and expands into a 'define'
     form.  Expansion of the right-hand side of this 'define' form is
     deferred.

  3. The definition of 'odd?' is next and results in the association of
     the keyword 'odd?' with the transformer resulting from expanding
     and evaluating the corresponding right-hand side.

  4. A use of 'odd?' appears next and is expanded; the resulting call to
     'not' is recognized as an expression because 'not' is bound as a
     variable.

  5. At this point, the expander completes the expansion of the current
     expression (the call to 'not') and the deferred right-hand side of
     the 'even?' definition; the uses of 'odd?' appearing in these
     expressions are expanded using the transformer associated with the
     keyword 'odd?'.

  6. The final output is the equivalent of:

          (lambda (x)
            (letrec* ((even? (lambda (n)
                               (or (= n 0)
                                   (not (even? (- n 1)))))))
              (not (even? (if (not (even? x))
                              (* x x)
                            x)))))

     although the structure of the output is implementation-dependent.

   Because definitions and expressions can be interleaved in a
?TOP-LEVEL-BODY, the expander's processing of a ?TOP-LEVEL-BODY is
somewhat more complicated.  It behaves as described above for a ?BODY or
?LIBRARY-BODY with the following exceptions:

   * When the expander finds a nondefinition, it defers its expansion
     and continues scanning for definitions.

   * Once it reaches the end of the set of forms, it processes the
     deferred right-hand-side and body expressions, then generates the
     equivalent of a 'letrec*' form from the defined variables, expanded
     right-hand-side expressions, and expanded body expressions.

   * For each body expression ?EXPRESSION that appears before a variable
     definition in the body, a dummy binding is created at the
     corresponding place within the set of 'letrec*' bindings, with a
     fresh temporary variable on the left-hand side and the equivalent
     of:

          (begin ?EXPRESSION ?UNSPECIFIED)

     where ?UNSPECIFIED is a side-effect-free expression returning an
     unspecified value, on the right-hand side, so that left-to-right
     evaluation order is preserved.  The 'begin' wrapper allows
     ?EXPRESSION to evaluate to an arbitrary number of values.


File: vicare-scheme.info,  Node: scheme derived,  Prev: scheme expansion,  Up: scheme

3.11 Sample definitions for derived forms
=========================================

This appendix contains sample definitions for some of the keywords
described in this report in terms of simpler forms:

'cond'
......

The 'cond' keyword could be defined in terms of 'if', 'let' and 'begin'
using 'syntax-rules' as follows:

     (define-syntax cond
       (syntax-rules (else =>)
         ((cond (else result1 result2 ...))
          (begin result1 result2 ...))
         ((cond (test => result))
          (let ((temp test))
            (if temp (result temp))))
         ((cond (test => result) clause1 clause2 ...)
          (let ((temp test))
            (if temp
                (result temp)
                (cond clause1 clause2 ...))))
         ((cond (test)) test)
         ((cond (test) clause1 clause2 ...)
          (let ((temp test))
            (if temp
                temp
                (cond clause1 clause2 ...))))
         ((cond (test result1 result2 ...))
          (if test (begin result1 result2 ...)))
         ((cond (test result1 result2 ...)
                clause1 clause2 ...)
          (if test
              (begin result1 result2 ...)
              (cond clause1 clause2 ...)))))

'case'
......

The 'case' keyword could be defined in terms of 'let', 'cond', and
'memv' using 'syntax-rules' as follows:

     (define-syntax case
       (syntax-rules (else)
         ((case expr0
            ((key ...) res1 res2 ...)
            ...
            (else else-res1 else-res2 ...))
          (let ((tmp expr0))
            (cond
              ((memv tmp '(key ...)) res1 res2 ...)
              ...
              (else else-res1 else-res2 ...))))
         ((case expr0
            ((keya ...) res1a res2a ...)
            ((keyb ...) res1b res2b ...)
            ...)
          (let ((tmp expr0))
            (cond
              ((memv tmp '(keya ...)) res1a res2a ...)
              ((memv tmp '(keyb ...)) res1b res2b ...)
              ...)))))

'let*'
......

The 'let*' keyword could be defined in terms of 'let' using
'syntax-rules' as follows:

     (define-syntax let*
       (syntax-rules ()
         ((let* () body1 body2 ...)
          (let () body1 body2 ...))
         ((let* ((name1 expr1) (name2 expr2) ...)
            body1 body2 ...)
          (let ((name1 expr1))
            (let* ((name2 expr2) ...)
              body1 body2 ...)))))

'letrec'
........

The 'letrec' keyword could be defined approximately in terms of 'let'
and 'set!' using 'syntax-rules', using a helper to generate the
temporary variables needed to hold the values before the assignments are
made, as follows:

     (define-syntax letrec
       (syntax-rules ()
         ((letrec () body1 body2 ...)
          (let () body1 body2 ...))
         ((letrec ((var init) ...) body1 body2 ...)
          (letrec-helper
            (var ...)
            ()
            ((var init) ...)
            body1 body2 ...))))

     (define-syntax letrec-helper
       (syntax-rules ()
         ((letrec-helper
            ()
            (temp ...)
            ((var init) ...)
            body1 body2 ...)
          (let ((var <undefined>) ...)
            (let ((temp init) ...)
              (set! var temp)
              ...)
            (let () body1 body2 ...)))
         ((letrec-helper
            (x y ...)
            (temp ...)
            ((var init) ...)
            body1 body2 ...)
          (letrec-helper
            (y ...)
            (newtemp temp ...)
            ((var init) ...)
            body1 body2 ...))))

   The syntax '<undefined>' represents an expression that returns
something that, when stored in a location, causes an exception with
condition type '&assertion' to be raised if an attempt to read from or
write to the location occurs before the assignments generated by the
'letrec' transformation take place.  (No such expression is defined in
Scheme.)

'letrec*'
.........

The 'letrec*' keyword could be defined approximately in terms of 'let'
and 'set!' using 'syntax-rules' as follows:

     (define-syntax letrec*
       (syntax-rules ()
         ((letrec* ((var1 init1) ...) body1 body2 ...)
          (let ((var1 <undefined>) ...)
            (set! var1 init1)
            ...
            (let () body1 body2 ...)))))

   The syntax '<undefined>' is as in the definition of 'letrec' above.

'let-values'
............

The following definition of 'let-values' using 'syntax-rules' employs a
pair of helpers to create temporary names for the formals.

     (define-syntax let-values
       (syntax-rules ()
         ((let-values (binding ...) body1 body2 ...)
          (let-values-helper1
            ()
            (binding ...)
            body1 body2 ...))))

     (define-syntax let-values-helper1
       ;; map over the bindings
       (syntax-rules ()
         ((let-values
            ((id temp) ...)
            ()
            body1 body2 ...)
          (let ((id temp) ...) body1 body2 ...))
         ((let-values
            assocs
            ((formals1 expr1) (formals2 expr2) ...)
            body1 body2 ...)
          (let-values-helper2
            formals1
            ()
            expr1
            assocs
            ((formals2 expr2) ...)
            body1 body2 ...))))

     (define-syntax let-values-helper2
       ;; create temporaries for the formals
       (syntax-rules ()
         ((let-values-helper2
            ()
            temp-formals
            expr1
            assocs
            bindings
            body1 body2 ...)
          (call-with-values
            (lambda () expr1)
            (lambda temp-formals
              (let-values-helper1
                assocs
                bindings
                body1 body2 ...))))
         ((let-values-helper2
            (first . rest)
            (temp ...)
            expr1
            (assoc ...)
            bindings
            body1 body2 ...)
          (let-values-helper2
            rest
            (temp ... newtemp)
            expr1
            (assoc ... (first newtemp))
            bindings
            body1 body2 ...))
         ((let-values-helper2
            rest-formal
            (temp ...)
            expr1
            (assoc ...)
            bindings
            body1 body2 ...)
          (call-with-values
            (lambda () expr1)
            (lambda (temp ... . newtemp)
              (let-values-helper1
                (assoc ... (rest-formal newtemp))
                bindings
                body1 body2 ...))))))

'let*-values'
.............

The following macro defines 'let*-values' in terms of 'let' and
'let-values' using 'syntax-rules':

     (define-syntax let*-values
       (syntax-rules ()
         ((let*-values () body1 body2 ...)
          (let () body1 body2 ...))
         ((let*-values (binding1 binding2 ...)
            body1 body2 ...)
          (let-values (binding1)
            (let*-values (binding2 ...)
              body1 body2 ...)))))

'let'
.....

The 'let' keyword could be defined in terms of 'lambda' and 'letrec'
using 'syntax-rules' as follows:

     (define-syntax let
       (syntax-rules ()
         ((let ((name val) ...) body1 body2 ...)
          ((lambda (name ...) body1 body2 ...)
           val ...))
         ((let tag ((name val) ...) body1 body2 ...)
          ((letrec ((tag (lambda (name ...)
                           body1 body2 ...)))
             tag)
           val ...))))


File: vicare-scheme.info,  Node: baselib,  Next: stdlib,  Prev: scheme,  Up: Top

4 Base library
**************

This chapter describes Scheme's '(rnrs base (6))' library, which exports
many of the procedure and syntax bindings that are traditionally
associated with Scheme.

* Menu:

* baselib types::               Base types.
* baselib definitions::         Definitions.
* baselib bodies::              Bodies.
* baselib expressions::         Expressions.
* baselib predicates::          Equivalence and procedure predicates.
* baselib math::                Mathematics.
* baselib booleans::            Booleans.
* baselib lists::               Pairs and lists.
* baselib symbols::             Symbols.
* baselib characters::          Characters.
* baselib strings::             Strings.
* baselib vectors::             Vectors.
* baselib errors::              Errors and violations.
* baselib control::             Control features.
* baselib iteration::           Iteration.
* baselib quasiquotation::      Quasiquotation.
* baselib syntax binding::      Binding constructs for syntactic keywords.
* baselib transformers::        Macro transformers.
* baselib tail call::           Tail calls and tail contexts.


File: vicare-scheme.info,  Node: baselib types,  Next: baselib definitions,  Up: baselib

4.1 Base types
==============

No object satisfies more than one of the following predicates:

     boolean?          pair?
     symbol?           number?
     char?             string?
     vector?           procedure?
     null?

   These predicates define the base types _boolean_, _pair_, _symbol_,
_number_, _char_ (or _character_), _string_, _vector_, and _procedure_.
Moreover, the empty list is a special object of its own type.

   Note that, although there is a separate boolean type, any Scheme
value can be used as a boolean value for the purpose of a conditional
test.


File: vicare-scheme.info,  Node: baselib definitions,  Next: baselib bodies,  Prev: baselib types,  Up: baselib

4.2 Definitions
===============

Definitions may appear within a ?TOP-LEVEL-BODY, at the top of a
?LIBRARY-BODY, or at the top of a ?BODY.

   A ?DEFINITION may be a variable definition or keyword definition.
Macro uses that expand into definitions or groups of definitions
(packaged in a 'begin', 'let-syntax', or 'letrec-syntax' form) may also
appear wherever other definitions may appear.

* Menu:

* baselib definitions variables::  Variables definitions.
* baselib definitions syntax::     Syntax definitions.


File: vicare-scheme.info,  Node: baselib definitions variables,  Next: baselib definitions syntax,  Up: baselib definitions

4.2.1 Variables definitions
---------------------------

The 'define' form described in this section is a ?DEFINITION used to
create variable bindings and may appear anywhere other definitions may
appear.

 -- Syntax: define ?VARIABLE ?EXPRESSION
 -- Syntax: define ?VARIABLE
 -- Syntax: define (?VARIABLE ?FORMALS) ?BODY
 -- Syntax: define (?VARIABLE . ?FORMAL) ?BODY
     The first from of 'define' binds ?VARIABLE to a new location before
     assigning the value of ?EXPRESSION to it.

          (define add3
            (lambda (x) (+ x 3)))
          (add3 3)                            =>  6
          (define first car)
          (first '(1 2))                      =>  1

     The continuation of ?EXPRESSION should not be invoked more than
     once.

     *Implementation responsibilities:* Implementations should detect
     that the continuation of ?EXPRESSION is invoked more than once.  If
     the implementation detects this, it must raise an exception with
     condition type '&assertion'.

     The second form of 'define' is equivalent to:

          (define ?VARIABLE ?UNSPECIFIED)

     where ?UNSPECIFIED is a side-effect-free expression returning an
     unspecified value.

     In the third form of 'define', ?FORMALS must be either a sequence
     of zero or more variables, or a sequence of one or more variables
     followed by a dot '.' and another variable (as in a lambda
     expression).  This form is equivalent to:

          (define ?VARIABLE
            (lambda (?FORMALS) ?BODY))

     In the fourth form of 'define', ?FORMAL must be a single variable.
     This form is equivalent to:

          (define ?VARIABLE
            (lambda ?FORMAL ?BODY))


File: vicare-scheme.info,  Node: baselib definitions syntax,  Prev: baselib definitions variables,  Up: baselib definitions

4.2.2 Syntax definitions
------------------------

The 'define-syntax' form described in this section is a ?DEFINITION used
to create keyword bindings and may appear anywhere other definitions may
appear.

 -- Syntax: define-syntax ?KEYWORD ?EXPRESSION
     Binds ?KEYWORD to the value of ?EXPRESSION, which must evaluate, at
     macro-expansion time, to a transformer.  Macro transformers can be
     created using the 'syntax-rules' and 'identifier-syntax' forms.

     Keyword bindings established by 'define-syntax' are visible
     throughout the body in which they appear, except where shadowed by
     other bindings, and nowhere else, just like variable bindings
     established by 'define'.  All bindings established by a set of
     definitions, whether keyword or variable definitions, are visible
     within the definitions themselves.

     *Implementation responsibilities:* The implementation should detect
     if the value of ?EXPRESSION cannot possibly be a transformer.

     Example:

          (let ()
            (define even?
              (lambda (x)
                (or (= x 0) (odd? (- x 1)))))
            (define-syntax odd?
              (syntax-rules ()
                ((odd?  x) (not (even? x)))))
            (even? 10))
          => #t

     An implication of the left-to-right processing order is that one
     definition can affect whether a subsequent form is also a
     definition.

     Example:

          (let ()
            (define-syntax bind-to-zero
              (syntax-rules ()
                ((bind-to-zero id) (define id 0))))
            (bind-to-zero x)
            x)
          => 0

     The behavior is unaffected by any binding for 'bind-to-zero' that
     might appear outside of the 'let' expression.


File: vicare-scheme.info,  Node: baselib bodies,  Next: baselib expressions,  Prev: baselib definitions,  Up: baselib

4.3 Bodies
==========

The ?BODY of a 'lambda', 'let', 'let*', 'let-values', 'let*-values',
'letrec', or 'letrec*' expression, or that of a definition with a body
consists of zero or more definitions followed by one or more
expressions:

     ?DEFINITION ... ?EXPRESSION1 ?EXPRESSION2 ...

   Each identifier defined by a ?DEFINITION is local to the ?BODY; that
is, the identifier is bound, and the region of the binding is the entire
?BODY.

   Example:

     (let ((x 5))
       (define foo (lambda (y) (bar x y)))
       (define bar (lambda (a b) (+ (* a b) a)))
       (foo (+ x 3)))
     =>  45

   When 'begin', 'let-syntax', or 'letrec-syntax' forms occur in a body
prior to the first expression, they are spliced into the body.  Some or
all of the body, including portions wrapped in 'begin', 'let-syntax', or
'letrec-syntax' forms, may be specified by a macro use.

   An expanded ?BODY containing variable definitions can always be
converted into an equivalent 'letrec*' expression.  For example, the
'let' expression in the above example is equivalent to

     (let ((x 5))
       (letrec* ((foo (lambda (y) (bar x y)))
                 (bar (lambda (a b) (+ (* a b) a))))
         (foo (+ x 3))))


File: vicare-scheme.info,  Node: baselib expressions,  Next: baselib predicates,  Prev: baselib bodies,  Up: baselib

4.4 Expressions
===============

The entries in this section describe the expressions of the '(rnrs base
(6))' library, which may occur in the position of the ?EXPRESSION
syntactic variable in addition to the primitive expression types.

* Menu:

* baselib expressions quotation::       Quotation.
* baselib expressions procedures::      Procedures.
* baselib expressions conditionals::    Conditionals.
* baselib expressions assignments::     Assignments.
* baselib expressions derived cond::    Derived conditionals.
* baselib expressions binding::         Binding constructs.
* baselib expressions sequencing::      Sequencing.


File: vicare-scheme.info,  Node: baselib expressions quotation,  Next: baselib expressions procedures,  Up: baselib expressions

4.4.1 Quotation
---------------

 -- Syntax: quote ?DATUM
     ?DATUM should be a syntactic datum.  '(quote ?DATUM)' evaluates to
     the datum value represented by ?DATUM.  This notation is used to
     include constants.

          (quote a)               => a
          (quote #(a b c))        => #(a b c)
          (quote (+ 1 2))         => (+ 1 2)

     '(quote ?DATUM)' may be abbreviated as ''?DATUM':

          '"abc"               => "abc"
          '145932              => 145932
          'a                   => a
          '#(a b c)            => #(a b c)
          '()                  => ()
          '(+ 1 2)             => (+ 1 2)
          '(quote a)           => (quote a)
          ''a                  => (quote a)

     Constants are immutable.

          *NOTE* Different constants that are the value of a 'quote'
          expression may share the same locations.


File: vicare-scheme.info,  Node: baselib expressions procedures,  Next: baselib expressions conditionals,  Prev: baselib expressions quotation,  Up: baselib expressions

4.4.2 Procedures
----------------

 -- Syntax: lambda ?FORMALS ?BODY
     ?FORMALS must be a formal parameter list as described below, and
     ?BODY must be as described in *note baselib bodies::.

     A 'lambda' evaluates to a procedure.  The environment in effect
     when the 'lambda' is evaluated is remembered as part of the
     procedure.  When the procedure is later called with some arguments,
     the environment in which the 'lambda' was evaluated is extended by
     binding the variables in the parameter list to fresh locations, and
     the resulting argument values are stored in those locations.  Then,
     the expressions in the body of the 'lambda' (which may contain
     definitions and thus represent a 'letrec*' form) are evaluated
     sequentially in the extended environment.  The results of the last
     expression in the body are returned as the results of the procedure
     call.

          (lambda (x) (+ x x))      => a procedure
          ((lambda (x) (+ x x)) 4)  => 8

          ((lambda (x)
             (define (p y)
               (+ y 1))
             (+ (p x) x))
           5) => 11

          (define reverse-subtract
            (lambda (x y) (- y x)))
          (reverse-subtract 7 10)         => 3

          (define add4
            (let ((x 4))
              (lambda (y) (+ x y))))
          (add4 6)                        => 10

     ?FORMALS must have one of the following forms:

     '(?VARIABLE1 ...)'
          The procedure takes a fixed number of arguments; when the
          procedure is called, the arguments are stored in the bindings
          of the corresponding variables.

     '?VARIABLE'
          The procedure takes any number of arguments; when the
          procedure is called, the sequence of arguments is converted
          into a newly allocated list, and the list is stored in the
          binding of the ?VARIABLE.

     '(?VARIABLE1 ... ?VARIABLEN . ?VARIABLEN+1)'
          If a period '.' precedes the last variable, then the procedure
          takes N or more arguments, where N is the number of parameters
          before the period (there must be at least one).  The value
          stored in the binding of the last variable is a newly
          allocated list of the arguments left over after all the other
          arguments have been matched up against the other parameters.

               ((lambda x x) 3 4 5 6)          => (3 4 5 6)
               ((lambda (x y . z) z)
                3 4 5 6)                       => (5 6)

     Any ?VARIABLE must not appear more than once in ?FORMALS.


File: vicare-scheme.info,  Node: baselib expressions conditionals,  Next: baselib expressions assignments,  Prev: baselib expressions procedures,  Up: baselib expressions

4.4.3 Conditionals
------------------

 -- Syntax: if ?TEST ?CONSEQUENT ?ALTERNATE
 -- Syntax: if ?TEST ?CONSEQUENT
     ?TEST, ?CONSEQUENT, and ?ALTERNATE must be expressions.

     When the syntax use has both the ?CONSEQUENT and the ?ALTERNATE
     forms: ?TEST is evaluated; if it yields a true value, the
     ?CONSEQUENT is evaluated and its return values are returned;
     otherwise the ?ALTERNATE is evaluated and its return values are
     returned.  The ?CONSEQUENT and ?ALTERNATE expressions are in tail
     context if the 'if' expression itself is.  The ?CONSEQUENT and
     ?ALTERNATE are required to return the same number of values, unless
     they raise an exception.

     When the syntax use has only the ?CONSEQUENT form: ?TEST is
     evaluated; if it yields a true value, the ?CONSEQUENT is evaluated
     and its return values are discarded.  In this case the syntax use
     always returns zero values.

          *NOTE* The specification of the one-armed 'if' expression
          breaks compliance with R6RS.  According to the standard: when
          ?TEST returns a true value the return value of ?CONSEQUENT is
          returned; otherwise the expression returns unspecified values.

          (if (> 3 2) 'yes 'no)           => yes
          (if (> 2 3) 'yes 'no)           => no
          (if (> 3 2)
              (- 3 2)
              (+ 3 2))                    => 1

          (if #t #t)                      => no values
          (if #f #f)                      => no values


File: vicare-scheme.info,  Node: baselib expressions assignments,  Next: baselib expressions derived cond,  Prev: baselib expressions conditionals,  Up: baselib expressions

4.4.4 Assignments
-----------------

 -- Syntax: set! ?VARIABLE ?EXPRESSION
     ?EXPRESSION is evaluated, and the resulting value is stored in the
     location to which ?VARIABLE is bound.  ?VARIABLE must be bound
     either in some region expression or at the top level.  A syntax use
     of 'set!' returns zero values.

          (let ((x 2))
            (+ x 1)
            (set! x 4)
            (+ x 1)) => 5

     It is a syntax violation if ?VARIABLE refers to an immutable
     binding.

          *NOTE* The identifier 'set!' is exported with level _1_ as
          well.


File: vicare-scheme.info,  Node: baselib expressions derived cond,  Next: baselib expressions binding,  Prev: baselib expressions assignments,  Up: baselib expressions

4.4.5 Derived conditionals
--------------------------

 -- Syntax: cond ?COND-CLAUSE1 ?COND-CLAUSE2 ...
 -- Auxiliary Syntax: =>
 -- Auxiliary Syntax: else
     Each ?COND-CLAUSE must be of the form:

          (?TEST ?EXPRESSION1 ...)

     where ?TEST is an expression.  Alternatively, a ?COND-CLAUSE may be
     of the form:

          (?TEST => ?EXPRESSION)

     The last ?COND-CLAUSE may be an 'else' clause, which has the form:

          (else ?EXPRESSION1 ?EXPRESSION2 ...)

     When the a 'cond' syntax use has the 'else' form, a 'cond'
     expression is evaluated as follows:

        * The ?TEST expressions of successive ?COND-CLAUSEs are
          evaluated in order until one of them evaluates to a true
          value.  When a ?TEST evaluates to a true value, then the
          remaining ?EXPRESSIONs in its ?COND-CLAUSE are evaluated in
          order, and the results of the last ?EXPRESSION in the ?COND
          CLAUSE are returned as the results of the entire 'cond'
          expression.

        * If the selected ?COND-CLAUSE contains only the ?TEST and no
          ?EXPRESSIONs, then the value of the ?TEST is returned as the
          result.  If the selected ?COND-CLAUSE uses the '=>' alternate
          form, then the ?EXPRESSION is evaluated.  Its value must be a
          procedure.  This procedure should accept one argument; it is
          called on the value of the ?TEST and the values returned by
          this procedure are returned by the 'cond' expression.

        * If all ?TESTs evaluate to '#f' then ?EXPRESSIONs in the 'else'
          clause are evaluated, and the values of the last one are
          returned.

        * For a ?COND-CLAUSE of one of the following forms:

               (?TEST ?EXPRESSION1 ...)
               (else ?EXPRESSION1 ?EXPRESSION2 ...)

          the last ?EXPRESSION is in tail context if the 'cond' form
          itself is.  For a ?COND-CLAUSE of the form:

               (?TEST => ?EXPRESSION)

          the (implied) call to the procedure that results from the
          evaluation of ?EXPRESSION is in a tail context if the 'cond'
          form itself is.

        * All clauses are required to return the same number of values,
          unless they raise an exception.

     When the a 'cond' syntax use does *not* have the 'else' form, a
     'cond' expression is evaluated as above but the return values are
     always discarded; such a 'cond' syntax use always returns zero
     values.

          *NOTE* The specification for the syntax use without 'else'
          clause breaks compliance with R6RS.  According to the
          standard: when no 'else' is present, the expression returns
          either the return values of the selected clause, or
          unspecified values if all the ?TEST expressions return '#f'.

     Usage examples:

          (cond ((> 3 2) 'greater)
                ((< 3 2) 'less))          => greater

          (cond ((> 3 3) 'greater)
                ((< 3 3) 'less)
                (else 'equal))            => equal

          (cond ('(1 2 3) => cadr)
                (else #f))                => 2

 -- Syntax: case ?KEY ?CASE-CLAUSE1 ?CASE-CLAUSE ...
 -- Auxiliary Syntax: =>
 -- Auxiliary Syntax: else
     ?KEY must be an expression.  Each ?CASE-CLAUSE must have one of the
     following forms:

          ((?DATUM1 ...) ?EXPRESSION1 ?EXPRESSION2 ...)
          (else ?EXPRESSION1 ?EXPRESSION2 ...)
          ((?DATUM1 ...) => ?EXPRESSION)
          (else => ?EXPRESSION)

     The arrow forms are only available in non-strict R6RS mode, *note
     '--no-strict-r6rs': using invoking.  The 'else' clause may only
     appear as the last ?CASE-CLAUSE.  Each ?DATUM is an external
     representation of some object.  The data represented by the ?DATUMs
     need not be distinct.

     When the 'else' clause is present, a 'case' expression is evaluated
     as follows:

        * ?KEY is evaluated and its result is compared using 'eqv?'
          against the data represented by the ?DATUMs of each
          ?CASE-CLAUSE in turn, proceeding in order from left to right
          through the set of clauses.

        * If the result of evaluating ?KEY is equivalent to a datum of a
          ?CASE-CLAUSE, the corresponding ?EXPRESSIONs are evaluated
          from left to right and the results of the last expression in
          the ?CASE-CLAUSE are returned as the results of the 'case'
          expression.  Otherwise, the comparison process continues.

        * If the selected ?CASE-CLAUSE uses the '=>' alternate form,
          then the ?EXPRESSION is evaluated; its value must be a
          procedure; this procedure should accept one argument.  It is
          called on the value of the ?KEY and the values returned by
          this procedure are returned by the 'case' expression.

        * If the result of evaluating ?KEY is different from every datum
          in each set, then the expressions in the 'else' clause are
          evaluated and the results of the last are the results of the
          'case' expression

        * The last ?EXPRESSION of a ?CASE-CLAUSE is in tail context if
          the 'case' expression itself is.

     When the a 'case' syntax use does *not* have the 'else' form, a
     'case' expression is evaluated as above but the return values are
     always discarded; such a 'case' syntax use always returns zero
     values.

          *NOTE* The specification for the syntax use without 'else'
          clause breaks compliance with R6RS.  According to the
          standard: when no 'else' is present, the expression returns
          either the return values of the selected clause, or
          unspecified values if the result of evaluating ?KEY is
          different from every datum in each set.

     Usage examples:

          (case (* 2 3)
            ((2 3 5 7) 'prime)
            ((1 4 6 8 9) 'composite))     => composite

          (case (car '(c d))
            ((a) 'a)
            ((b) 'b))                     => no values

          (case (car '(c d))
            ((a e i o u) 'vowel)
            ((w y) 'semivowel)
            (else 'consonant))            => consonant

          (case 2
            ((a b c)      'symbol)
            ((1 2 3)      => (lambda (N) (vector N)))
            (else         'else))
          => #(2)

          (case 9
            ((a b c)      'symbol)
            ((1 2 3)      'number)
            (else         => (lambda (N) (vector N))))
          => #(9)

 -- Syntax: and ?TEST1 ...
     The ?TESTs must be expressions.

     If there are no ?TESTs, '#t' is returned.  Otherwise, the ?TEST
     expressions are evaluated from left to right until a ?TEST returns
     '#f' or the last ?TEST is reached.  In the former case, the 'and'
     expression returns '#f' without evaluating the remaining
     expressions.  In the latter case, the last expression is evaluated
     and its values are returned.

          (and (= 2 2) (> 2 1))           =>  #t
          (and (= 2 2) (< 2 1))           =>  #f
          (and 1 2 'c '(f g))             =>  (f g)
          (and)                           =>  #t

     The 'and' keyword could be defined in terms of 'if' using
     'syntax-rules' as follows:

          (define-syntax and
            (syntax-rules ()
              ((and) #t)
              ((and test) test)
              ((and test1 test2 ...)
               (if test1 (and test2 ...) #t))))

     The last ?TEST expression is in tail context if the 'and'
     expression itself is.

 -- Syntax: or ?TEST1 ...
     The ?TESTs must be expressions.

     If there are no ?TESTs, '#f' is returned.  Otherwise, the ?TEST
     expressions are evaluated from left to right until a ?TEST returns
     a true value VAL or the last ?TEST is reached.  In the former case,
     the 'or' expression returns VAL without evaluating the remaining
     expressions.  In the latter case, the last expression is evaluated
     and its values are returned.

          (or (= 2 2) (> 2 1))            => #t
          (or (= 2 2) (< 2 1))            => #t
          (or #f #f #f)                   => #f
          (or '(b c) (/ 3 0))             => (b c)

     The 'or' keyword could be defined in terms of 'if' using
     'syntax-rules' as follows:

          (define-syntax or
            (syntax-rules ()
              ((or) #f)
              ((or test) test)
              ((or test1 test2 ...)
               (let ((x test1))
                 (if x x (or test2 ...))))))

     The last ?TEST expression is in tail context if the 'or' expression
     itself is.


File: vicare-scheme.info,  Node: baselib expressions binding,  Next: baselib expressions sequencing,  Prev: baselib expressions derived cond,  Up: baselib expressions

4.4.6 Binding constructs
------------------------

The binding constructs described in this section create local bindings
for variables that are visible only in a delimited region.  The syntax
of the constructs 'let', 'let*', 'letrec', and 'letrec*' is identical,
but they differ in the regions they establish for their variable
bindings and in the order in which the values for the bindings are
computed.

   * In a 'let' expression, the initial values are computed before any
     of the variables become bound; in a 'let*' expression, the bindings
     and evaluations are performed sequentially.

   * In a 'letrec' or 'letrec*' expression, all the bindings are in
     effect while their initial values are being computed, thus allowing
     mutually recursive definitions.

   * In a 'letrec' expression, the initial values are computed before
     being assigned to the variables; in a 'letrec*', the evaluations
     and assignments are performed sequentially.

   In addition, the binding constructs 'let-values' and 'let*-values'
generalize 'let' and 'let*' to allow multiple variables to be bound to
the results of expressions that evaluate to multiple values.  They are
analogous to 'let' and 'let*' in the way they establish regions: in a
'let-values' expression, the initial values are computed before any of
the variables become bound; in a 'let*-values' expression, the bindings
are performed sequentially.

 -- Syntax: let ?BINDINGS ?BODY
     ?BINDINGS must have the form:

          ((?VARIABLE1 ?INIT1) ...)

     where each ?INIT is an expression, and ?BODY is as described in
     *note baselib bodies::.  Any variable must not appear more than
     once in the ?VARIABLEs.

     The ?INITs are evaluated in the current environment (in some
     unspecified order), the ?VARIABLEs are bound to fresh locations
     holding the results, the ?BODY is evaluated in the extended
     environment, and the values of the last expression of ?BODY are
     returned.  Each binding of a ?VARIABLE has ?BODY as its region.

          (let ((x 2) (y 3))
            (* x y))                      => 6

          (let ((x 2) (y 3))
            (let ((x 7)
                  (z (+ x y)))
              (* z x)))                   => 35

     See also named 'let'.

 -- Syntax: let* ?BINDINGS ?BODY
     ?BINDINGS must have the form:

          ((?VARIABLE1 ?INIT1) ...)

     where each ?INIT is an expression, and ?BODY is as described in
     *note baselib bodies::.

     The 'let*' form is similar to 'let', but the ?INITs are evaluated
     and bindings created sequentially from left to right, with the
     region of each binding including the bindings to its right as well
     as ?BODY.  Thus the second ?INIT is evaluated in an environment in
     which the first binding is visible and initialized, and so on.

          (let ((x 2) (y 3))
            (let* ((x 7)
                   (z (+ x y)))
              (* z x)))             => 70

          *NOTE* While the variables bound by a 'let' expression must be
          distinct, the variables bound by a 'let*' expression need not
          be distinct.

 -- Syntax: letrec ?BINDINGS ?BODY
     ?BINDINGS must have the form:

          ((?VARIABLE1 ?INIT1) ...)

     where each ?INIT is an expression, and ?BODY is as described in
     *note baselib bodies::.  Any variable must not appear more than
     once in the ?VARIABLEs.

     The ?VARIABLEs are bound to fresh locations, the ?INITs are
     evaluated in the resulting environment (in some unspecified order),
     each ?VARIABLE is assigned to the result of the corresponding
     ?INIT, the ?BODY is evaluated in the resulting environment, and the
     values of the last expression in ?BODY are returned.  Each binding
     of a ?VARIABLE has the entire 'letrec' expression as its region,
     making it possible to define mutually recursive procedures.

          (letrec ((even?
                    (lambda (n)
                      (if (zero? n)
                          #t
                          (odd? (- n 1)))))
                   (odd?
                    (lambda (n)
                      (if (zero? n)
                          #f
                          (even? (- n 1))))))
            (even? 88))
          => #t

     It should be possible to evaluate each ?INIT without assigning or
     referring to the value of any ?VARIABLE.  In the most common uses
     of 'letrec', all the ?INITs are 'lambda's and the restriction is
     satisfied automatically.  Another restriction is that the
     continuation of each ?INIT should not be invoked more than once.

     *Implementation responsibilities:* Implementations must detect
     references to a ?VARIABLE during the evaluation of the ?INIT
     expressions (using one particular evaluation order and order of
     evaluating the ?INIT expressions).  If an implementation detects
     such a violation of the restriction, it must raise an exception
     with condition type '&assertion'.  Implementations may or may not
     detect that the continuation of each ?INIT is invoked more than
     once.  However, if the implementation detects this, it must raise
     an exception with condition type '&assertion'.

 -- Syntax: letrec* ?BINDINGS ?BODY
     ?BINDINGS must have the form:

          ((?VARIABLE1 ?INIT1) ...)

     where each ?INIT is an expression, and ?BODY is as described in
     *note baselib bodies::.  Any variable must not appear more than
     once in the ?VARIABLEs.

     The ?VARIABLEs are bound to fresh locations, each ?VARIABLE is
     assigned in left-to-right order to the result of evaluating the
     corresponding ?INIT, the ?BODY is evaluated in the resulting
     environment, and the values of the last expression in ?BODY are
     returned.  Despite the left-to-right evaluation and assignment
     order, each binding of a ?VARIABLE has the entire 'letrec*'
     expression as its region, making it possible to define mutually
     recursive procedures.

          (letrec* ((p
                     (lambda (x)
                       (+ 1 (q (- x 1)))))
                    (q
                     (lambda (y)
                       (if (zero? y)
                           0
                           (+ 1 (p (- y 1))))))
                    (x (p 5))
                    (y x))
            y)
          =>  5

     It must be possible to evaluate each ?INIT without assigning or
     referring to the value of the corresponding ?VARIABLE or the
     ?VARIABLE of any of the bindings that follow it in ?BINDINGS.
     Another restriction is that the continuation of each ?INIT should
     not be invoked more than once.

     *Implementation responsibilities:* Implementations must, during the
     evaluation of an ?INIT expression, detect references to the value
     of the corresponding ?VARIABLE or the ?VARIABLE of any of the
     bindings that follow it in ?BINDINGS.  If an implementation detects
     such a violation of the restriction, it must raise an exception
     with condition type '&assertion'.  Implementations may or may not
     detect that the continuation of each ?INIT is invoked more than
     once.  However, if the implementation detects this, it must raise
     an exception with condition type '&assertion'.

 -- Syntax: let-values ?MV-BINDINGS ?BODY
     ?MV-BINDINGS must have the form:

          ((?FORMALS1 ?INIT1) ...)

     where each ?INIT is an expression, and ?BODY is as described in
     *note baselib bodies::.  Any variable must not appear more than
     once in the set of ?FORMALS.

     The ?INITs are evaluated in the current environment (in some
     unspecified order), and the variables occurring in the ?FORMALS are
     bound to fresh locations containing the values returned by the
     ?INITs, where the ?FORMALS are matched to the return values in the
     same way that the ?FORMALS in a 'lambda' are matched to the
     arguments in a procedure call.  Then, the ?BODY is evaluated in the
     extended environment, and the values of the last expression of
     ?BODY are returned.  Each binding of a variable has ?BODY as its
     region.  If the ?FORMALS do not match, an exception with condition
     type '&assertion' is raised.

          (let-values (((a b) (values 1 2))
                       ((c d) (values 3 4)))
            (list a b c d))
          => (1 2 3 4)

          (let-values (((a b . c) (values 1 2 3 4)))
            (list a b c))
          => (1 2 (3 4))

          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (let-values (((a b) (values x y))
                         ((x y) (values a b)))
              (list a b x y)))
          => (x y a b)

     Notice the following special case:

          (let-values ((all (values 1 2 3)))
            all)
          => (1 2 3)

     which corresponds to the 'lambda' formals:

          (define f
            (lambda all
              all))

          (f 1 2 3)       => (1 2 3)

 -- Syntax: let*-values ?MV-BINDINGS ?BODY
     ?MV-BINDINGS must have the form:

          ((?FORMALS1 ?INIT1) ...)

     where each ?INIT is an expression, and ?BODY is as described in
     *note baselib bodies::.  In each ?FORMALS, any variable must not
     appear more than once.

     The 'let*-values' form is similar to 'let-values', but the ?INITs
     are evaluated and bindings created sequentially from left to right,
     with the region including the bindings to its right as well as
     ?BODY.  Thus the second ?INIT is evaluated in an environment in
     which the bindings of the first ?FORMALS is visible and
     initialized, and so on.

          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (let*-values (((a b) (values x y))
                          ((x y) (values a b)))
              (list a b x y)))
          => (x y x y)

          *NOTE* While all of the variables bound by a 'let-values'
          expression must be distinct, the variables bound by different
          ?FORMALS of a 'let*-values' expression need not be distinct.


File: vicare-scheme.info,  Node: baselib expressions sequencing,  Prev: baselib expressions binding,  Up: baselib expressions

4.4.7 Sequencing
----------------

 -- Syntax: begin ?FORM ...
 -- Syntax: begin ?EXPRESSION ?EXPRESSION ...
     The ?BEGIN keyword has two different roles, depending on its
     context:

        * It may appear as a form in a ?BODY, ?LIBRARY-BODY, or
          ?TOP-LEVEL-BODY, or directly nested in a 'begin' form that
          appears in a body.  In this case, the 'begin' form must have
          the shape specified in the first header line.  This use of
          'begin' acts as a _splicing_ form: the forms inside the ?BODY
          are spliced into the surrounding body, as if the 'begin'
          wrapper were not actually present.

          A 'begin' form in a ?BODY or ?LIBRARY-BODY must be non-empty
          if it appears after the first ?EXPRESSION within the body.

        * It may appear as an ordinary expression and must have the
          shape specified in the second header line.  In this case, the
          ?EXPRESSIONs are evaluated sequentially from left to right,
          and the values of the last ?EXPRESSION are returned.  This
          expression type is used to sequence side effects such as
          assignments or input and output.

          (define x 0)

          (begin (set! x 5)
                 (+ x 1))
          =>  6

          (begin (display "4 plus 1 equals ")
                 (display (+ 4 1)))
          => unspecified
          -| 4 plus 1 equals 5


File: vicare-scheme.info,  Node: baselib predicates,  Next: baselib math,  Prev: baselib expressions,  Up: baselib

4.5 Equivalence and procedure predicates
========================================

A _predicate_ is a procedure that always returns a boolean value ('#t'
or '#f').  An _equivalence predicate_ is the computational analogue of a
mathematical equivalence relation (it is symmetric, reflexive, and
transitive).  Of the equivalence predicates described in this section,
'eq?' is the finest or most discriminating, and 'equal?' is the
coarsest.  The 'eqv?' predicate is slightly less discriminating than
'eq?'.

 -- Procedure: eqv? OBJ1 OBJ2
     The 'eqv?' procedure defines a useful equivalence relation on
     objects.  Briefly, it returns '#t' if OBJ1 and OBJ2 should normally
     be regarded as the same object and '#f' otherwise.  This relation
     is left slightly open to interpretation, but the following partial
     specification of 'eqv?' must hold for all implementations.

     The 'eqv?' procedure returns '#t' if one of the following holds:

        * OBJ1 and OBJ2 are both booleans and are the same according to
          the 'boolean=?' procedure.

        * OBJ1 and OBJ2 are both symbols and are the same according to
          the 'symbol=?' procedure.

        * OBJ1 and OBJ2 are both exact number objects and are
          numerically equal (see '=').

        * OBJ1 and OBJ2 are both inexact number objects, are numerically
          equal (see '='), and yield the same results (in the sense of
          'eqv?') when passed as arguments to any other procedure that
          can be defined as a finite composition of Scheme's standard
          arithmetic procedures.

        * OBJ1 and OBJ2 are both characters and are the same character
          according to the 'char=?' procedure.

        * Both OBJ1 and OBJ2 are the empty list.

        * OBJ1 and OBJ2 are objects such as pairs, vectors, bytevectors
          (library chapter "Bytevectors"), strings, records (library
          chapter "Records"), ports (library section "Port I/O"), or
          hashtables (library chapter "Hash tables") that refer to the
          same locations in the store.

        * OBJ1 and OBJ2 are record-type descriptors that are specified
          to be 'eqv?' in library section "Procedural layer".

     The 'eqv?' procedure returns '#f' if one of the following holds:

        * OBJ1 and OBJ2 are of different types.

        * OBJ1 and OBJ2 are booleans for which the 'boolean=?' procedure
          returns '#f'.

        * OBJ1 and OBJ2 are symbols for which the 'symbol=?' procedure
          returns '#f'.

        * One of OBJ1 and OBJ2 is an exact number object but the other
          is an inexact number object.

        * OBJ1 and OBJ2 are rational number objects for which the '='
          procedure returns '#f'.

        * OBJ1 and OBJ2 yield different results (in the sense of 'eqv?')
          when passed as arguments to any other procedure that can be
          defined as a finite composition of Scheme's standard
          arithmetic procedures.

        * OBJ1 and OBJ2 are characters for which the 'char=?' procedure
          returns '#f'.

        * One of OBJ1 and OBJ2 is the empty list, but the other is not.

        * OBJ1 and OBJ2 are objects such as pairs, vectors, bytevectors
          (library chapter "Bytevectors"), strings, records (library
          chapter "Records"), ports (library section "Port I/O"), or
          hashtables (library chapter "Hashtables") that refer to
          distinct locations.

        * OBJ1 and OBJ2 are pairs, vectors, strings, or records, or
          hashtables, where the applying the same accessor (i.e.  'car',
          'cdr', 'vector-ref', 'string-ref', or record accessors) to
          both yields results for which 'eqv?' returns '#f'.

        * OBJ1 and OBJ2 are procedures that would behave differently
          (return different values or have different side effects) for
          some arguments.

          *NOTE* The 'eqv?' procedure returning '#t' when OBJ1 and OBJ2
          are number objects does not imply that '=' would also return
          '#t' when called with OBJ1 and OBJ2 as arguments.

          (eqv? 'a 'a)                     => #t
          (eqv? 'a 'b)                     => #f
          (eqv? 2 2)                       => #t
          (eqv? '() '())                   => #t
          (eqv? 100000000 100000000)       => #t
          (eqv? (cons 1 2) (cons 1 2))     => #f
          (eqv? (lambda () 1)
                (lambda () 2))             => #f
          (eqv? #f 'nil)                   => #f

     The following examples illustrate cases in which the above rules do
     not fully specify the behavior of 'eqv?'.  All that can be said
     about such cases is that the value returned by 'eqv?' must be a
     boolean.

          (let ((p (lambda (x) x)))
            (eqv? p p))                   => unspecified

          (eqv? "" "")                    => unspecified

          (eqv? '#() '#())                => unspecified

          (eqv? (lambda (x) x)
                (lambda (x) x))           => unspecified

          (eqv? (lambda (x) x)
                (lambda (y) y))           => unspecified

          (eqv? +nan.0 +nan.0)            => unspecified

     The next set of examples shows the use of 'eqv?' with procedures
     that have local state.  Calls to 'gen-counter' must return a
     distinct procedure every time, since each procedure has its own
     internal counter.  Calls to 'gen-loser' return procedures that
     behave equivalently when called.  However, 'eqv?' may not detect
     this equivalence.

          (define gen-counter
            (lambda ()
              (let ((n 0))
                (lambda () (set! n (+ n 1)) n))))
          (let ((g (gen-counter)))
            (eqv? g g))           =>  unspecified
          (eqv? (gen-counter) (gen-counter))
                                  =>  #f
          (define gen-loser
            (lambda ()
              (let ((n 0))
                (lambda () (set! n (+ n 1)) 27))))
          (let ((g (gen-loser)))
            (eqv? g g))           =>  unspecified
          (eqv? (gen-loser) (gen-loser))
                                  =>  unspecified

          (letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
                   (g (lambda () (if (eqv? f g) 'both 'g))))
            (eqv? f g)) => unspecified

          (letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
                   (g (lambda () (if (eqv? f g) 'g 'both))))
            (eqv? f g)) => #f

     Implementations may share structure between constants where
     appropriate.  Furthermore, a constant may be copied at any time by
     the implementation so as to exist simultaneously in different sets
     of locations.  Thus the value of 'eqv?' on constants is sometimes
     implementation-dependent.

          (eqv? '(a) '(a))                 => unspecified
          (eqv? "a" "a")                   => unspecified
          (eqv? '(b) (cdr '(a b)))         => unspecified
          (let ((x '(a)))
            (eqv? x x))                    => #t

 -- Procedure: eq? OBJ1 OBJ2
     The 'eq?' predicate is similar to 'eqv?' except that in some cases
     it is capable of discerning distinctions finer than those
     detectable by 'eqv?'.

     The 'eq?' and 'eqv?' predicates are guaranteed to have the same
     behavior on symbols, booleans, the empty list, pairs, procedures,
     non-empty strings, bytevectors, vectors, and records.  The behavior
     of 'eq?' on number objects and characters is
     implementation-dependent, but it always returns either '#t' or
     '#f', and returns '#t' only when 'eqv?' would also return '#t'.
     The 'eq?' predicate may also behave differently from 'eqv?' on
     empty vectors, empty bytevectors, and empty strings.

          (eq? 'a 'a)                     => #t
          (eq? '(a) '(a))                 => unspecified
          (eq? (list 'a) (list 'a))       => #f
          (eq? "a" "a")                   => unspecified
          (eq? "" "")                     => unspecified
          (eq? '() '())                   => #t
          (eq? 2 2)                       => unspecified
          (eq? #\A #\A)                   => unspecified
          (eq? car car)                   => #t
          (let ((n (+ 2 3)))
            (eq? n n))                    => unspecified
          (let ((x '(a)))
            (eq? x x))                    => #t
          (let ((x '#()))
            (eq? x x))                    => unspecified
          (let ((p (lambda (x) x)))
            (eq? p p))                    => unspecified

 -- Procedure: equal? OBJ1 OBJ2
     The 'equal?' predicate returns '#t' if and only if the (possibly
     infinite) unfoldings of its arguments into regular trees are equal
     as ordered trees.

     The 'equal?' predicate treats pairs and vectors as nodes with
     outgoing edges, uses 'string=?' to compare strings, uses
     'bytevector=?' to compare bytevectors (*note stdlib bytevector::),
     and uses 'eqv?' to compare other nodes.

          (equal? 'a 'a)                  =>  #t

          (equal? '(a) '(a))              =>  #t

          (equal? '(a (b) c)
                  '(a (b) c))             =>  #t

          (equal? "abc" "abc")            =>  #t

          (equal? 2 2)                    =>  #t

          (equal? (make-vector 5 'a)
                  (make-vector 5 'a))     =>  #t

          (equal? '#vu8(1 2 3 4 5)
                  (u8-list->bytevector
                   '(1 2 3 4 5))          =>  #t

          (equal? (lambda (x) x)
                  (lambda (y) y))         =>  unspecified

          (let* ((x (list 'a))
                 (y (list 'a))
                 (z (list x y)))
            (list (equal? z (list y x))
                  (equal? z (list x x)))) =>  (#t #t)

          *NOTE* As Vicare extensions: structs are compared with
          'struct=?' and R6RS records are compared with 'record=?'.

          *NOTE* The 'equal?' procedure must always terminate, even if
          its arguments contain cycles.

Procedure predicate
...................

 -- Procedure: procedure? OBJ
     Return '#t' if OBJ is a procedure, otherwise return '#f'.

          (procedure? car)                        => #t
          (procedure? 'car)                       => #f
          (procedure? (lambda (x) (* x x)))       => #t
          (procedure? '(lambda (x) (* x x)))      => #f


File: vicare-scheme.info,  Node: baselib math,  Next: baselib booleans,  Prev: baselib predicates,  Up: baselib

4.6 Mathematics
===============

The procedures described here implement arithmetic that is generic over
the numerical tower.  The generic procedures described in this section
accept both exact and inexact number objects as arguments, performing
coercions and selecting the appropriate operations as determined by the
numeric subtypes of their arguments.

* Menu:

* baselib math exactness::      Propagation of exactness and inexactness.
* baselib math infinities::     Representability of infinities and NaNs.
* baselib math semantics::      Semantics of common operations.
* baselib math ops::            Numerical operations.
* baselib math string::         Numerical input and output.


File: vicare-scheme.info,  Node: baselib math exactness,  Next: baselib math infinities,  Up: baselib math

4.6.1 Propagation of exactness and inexactness
----------------------------------------------

The procedures listed below must return the mathematically correct exact
result provided all their arguments are exact:

     +            -            *
     max          min          abs
     numerator    denominator  gcd
     lcm          floor        ceiling
     truncate     round        rationalize
     real-part    imag-part    make-rectangular

   The procedures listed below must return the correct exact result
provided all their arguments are exact, and no divisors are zero:

     /
     div          mod           div-and-mod
     div0         mod0          div0-and-mod0

   Moreover, the procedure 'expt' must return the correct exact result
provided its first argument is an exact real number object and its
second argument is an exact integer object.

   The general rule is that the generic operations return the correct
exact result when all of their arguments are exact and the result is
mathematically well-defined, but return an inexact result when any
argument is inexact.  Exceptions to this rule include:

     sqrt            exp             log
     sin             cos             tan
     asin            acos            atan
     expt            make-polar      magnitude
     angle

which may (but are not required to) return inexact results even when
given exact arguments, as indicated in the specification of these
procedures.

   One general exception to the rule above is that an implementation may
return an exact result despite inexact arguments if that exact result
would be the correct result for all possible substitutions of exact
arguments for the inexact ones.  An example is '(* 1.0 0)' which may
return either 0 (exact) or 0.0 (inexact).


File: vicare-scheme.info,  Node: baselib math infinities,  Next: baselib math semantics,  Prev: baselib math exactness,  Up: baselib math

4.6.2 Representability of infinities and NaNs
---------------------------------------------

The specification of the numerical operations is written as though
infinities and NaNs are representable, and specifies many operations
with respect to these number objects in ways that are consistent with
the IEEE 754 standard for binary floating-point arithmetic.

   An implementation of Scheme may or may not represent infinities and
NaNs; however, an implementation must raise a continuable exception with
condition type '&no-infinities' or '&no-nans' (respectively; *note
stdlib arithmetic flonums::) whenever it is unable to represent an
infinity or NaN as specified.  In this case, the continuation of the
exception handler is the continuation that otherwise would have received
the infinity or NaN value.  This requirement also applies to conversions
between number objects and external representations, including the
reading of program source code.


File: vicare-scheme.info,  Node: baselib math semantics,  Next: baselib math ops,  Prev: baselib math infinities,  Up: baselib math

4.6.3 Semantics of common operations
------------------------------------

Some operations are the semantic basis for several arithmetic
procedures.  The behavior of these operations is described in this
section for later reference.

* Menu:

* baselib math semantics integer::      Integer division.
* baselib math semantics trascend::     Transcendental functions.


File: vicare-scheme.info,  Node: baselib math semantics integer,  Next: baselib math semantics trascend,  Up: baselib math semantics

4.6.3.1 Integer division
........................

Scheme's operations for performing integer division rely on mathematical
operations div, mod, div_0, and mod_0, that are defined as follows:

   * div, mod, div_0, and mod_0 each accept two real numbers x_1 and x_2
     as operands, where x_2 must be nonzero.

   * div returns an integer, and mod returns a real.  Their results are
     specified by:

          x_1 div x_2 = n_d
          x_1 mod x_2 = x_m

     where:

          x_1 = n_d * x_2 + x_m
          0  <= x_m < |x_2|

     Examples:

           123 div  10 =  12
           123 mod  10 =   3
           123 div -10 = -12
           123 mod -10 =   3
          -123 div  10 = -13
          -123 mod  10 =   7
          -123 div -10 =  13
          -123 mod -10 =   7

   * div_0 and mod_0 are like div and mod, except the result of mod_0
     lies within a half-open interval centered on zero.  The results are
     specified by:

          x_1 div_0 x_2 = n_d
          x_1 mod_0 x_2 = x_m

     where:

          x_1 = n_d * x_2 + x_m
          -|x_2/2| <= x_m < |x_2/2|

     Examples:

           123 div_0  10 =  12
           123 mod_0  10 =   3
           123 div_0 -10 = -12
           123 mod_0 -10 =   3
          -123 div_0  10 = -12
          -123 mod_0  10 =  -3
          -123 div_0 -10 =  12
          -123 mod_0 -10 =  -3


File: vicare-scheme.info,  Node: baselib math semantics trascend,  Prev: baselib math semantics integer,  Up: baselib math semantics

4.6.3.2 Transcendental functions
................................

In general, the transcendental functions \log, \sin^{-1} (arcsine),
\cos^{-1} (arccosine), and \tan^{-1} are multiply defined.  The value of
\log z is defined to be the one whose imaginary part lies in the range
from -\pi (inclusive if -0.0 is distinguished, exclusive otherwise) to
\pi (inclusive).  \log 0 is undefined.

   The value of \log z for non-real z is defined in terms of log on real
numbers as:

     \log z = \log |z| + (\angle z) i

where \angle z is the angle of z = a * e^{(i * b)} specified as:

     \angle z = b + 2 \pi n

with -\pi <= \angle z <= \pi and \angle z = b + 2 \pi n for some integer
n.

   With the one-argument version of \log defined this way, the values of
the two-argument-version of \log z, \sin^{-1} z, \cos^{-1} z, \tan^{-1}
z, and the two-argument version of \tan^{-1} are according to the
following formulae:

     \log_b z = (\log z)/(\log b)
     \sin^(-1) z = -i \log (i z + \sqrt(1 - z^2))
     \cos^(-1) z = \pi/2 - sin^(-1) z
     \tan^(-1) z = (\log (1 + i z) - \log (1 - i z)) / (2 i)
     \tan^(-1) (x, y) = \angle(x + yi)

   The range of \tan^{-1} (x, y) is as in the following table; the
asterisk ('*') indicates that the entry applies to implementations that
distinguish minus zero.

    y condition   x condition   range of result r
----------------------------------------------------
    y = 0.0       x > 0.0       0.0
*   y = +0.0      x > 0.0       +0.0
*   y = -0.0      x > 0.0       -0.0
    y > 0.0       x > 0.0       0.0 < r < \pi/2
    y > 0.0       x = 0.0       \pi/2
    y > 0.0       x < 0.0       \pi/2 < r < \pi
    y = 0.0       x < 0         \pi
*   y = +0.0      x < 0.0       \pi
*   y = -0.0      x < 0.0       -\pi
    y < 0.0       x < 0.0       -\pi< r < -\pi/2
    y < 0.0       x = 0.0       -\pi/2
    y < 0.0       x > 0.0       -\pi/2 < r < 0.0
    y = 0.0       x = 0.0       undefined
*   y = +0.0      x = +0.0      +0.0
*   y = -0.0      x = +0.0      -0.0
*   y = +0.0      x = -0.0      \pi
*   y = -0.0      x = -0.0      -\pi
*   y = +0.0      x = 0         \pi/2
*   y = -0.0      x = 0         -\pi/2


File: vicare-scheme.info,  Node: baselib math ops,  Next: baselib math string,  Prev: baselib math semantics,  Up: baselib math

4.6.4 Numerical operations
--------------------------

* Menu:

* baselib math ops type pred::          Numerical type predicates.
* baselib math ops exactness::          Generic conversion.
* baselib math ops value pred::         Value predicates.
* baselib math ops comparison::         Comparison.
* baselib math ops arithmetic::         Arithmetic operations.
* baselib math ops part::               Part separation.
* baselib math ops trascend::           Trascendental functions.
* baselib math ops exponentiation::     Exponentiation functions.
* baselib math ops complex::            Complex numbers functions.


File: vicare-scheme.info,  Node: baselib math ops type pred,  Next: baselib math ops exactness,  Up: baselib math ops

4.6.4.1 Numerical type predicates
.................................

 -- Procedure: number? OBJ
 -- Procedure: complex? OBJ
 -- Procedure: real? OBJ
 -- Procedure: rational? OBJ
 -- Procedure: integer? OBJ
     These numerical type predicates can be applied to any kind of
     argument.  They return '#t' if the object is a number object of the
     named type, and '#f' otherwise.  In general, if a type predicate is
     true of a number object then all higher type predicates are also
     true of that number object.  Consequently, if a type predicate is
     false of a number object, then all lower type predicates are also
     false of that number object.

     If Z is a complex number object, then '(real? Z)' is true if and
     only if '(zero? (imag-part Z))' and '(exact? (imag-part Z))' are
     both true.

     If X is a real number object, then '(rational? X)' is true if and
     only if there exist exact integer objects K1 and K2 such that '(= X
     (/ K1 K2))' and '(= (numerator X) K1)' and '(= (denominator X) K2)'
     are all true.  Thus infinities and NaNs are not rational number
     objects.

     If Q is a rational number object, then '(integer? Q)' is true if
     and only if '(= (denominator Q) 1)' is true.  If Q is not a
     rational number object, then '(integer? Q)' is '#f'.

     Notice that the comparison function '=' does not care about the
     exactness of its arguments:

          (= 1 1.1)       => #t
          (= 1 #i1.1)     => #t

     so, with the given definition, the only real numbers (according to
     'real?') that are not also rational numbers (according to
     'rational?') are infinities and NaNs.  For the same reason, numbers
     are integers (according to 'integer?') without respect for
     exactness.

          (complex? 3+4i)                        => #t
          (complex? 3)                           => #t
          (real? 3)                              => #t
          (real? -2.5+0.0i)                      => #f
          (real? -2.5+0i)                        => #t
          (real? -2.5)                           => #t
          (real? #e1e10)                         => #t
          (rational? 6/10)                       => #t
          (rational? 6/3)                        => #t
          (rational? 2)                          => #t
          (integer? 3+0i)                        => #t
          (integer? 3.0)                         => #t
          (integer? 8/4)                         => #t

          (number? +nan.0)                       => #t
          (complex? +nan.0)                      => #t
          (real? +nan.0)                         => #t
          (rational? +nan.0)                     => #f
          (complex? +inf.0)                      => #t
          (real? -inf.0)                         => #t
          (rational? -inf.0)                     => #f
          (integer? -inf.0)                      => #f

     Notice that '3.0+0i' is an integer number according to 'integer?',
     because the imaginary part is exact zero.  '3.0+0.0i' is a complex
     number because the imaginary part is inexact zero, and it is equal
     to '#i3.0+0i'; '3.0+0.0i' is not integer according to 'integer?',
     but it is 'integer-valued?'.

          (integer? 3.0+0i)                       => #t
          (integer? 3.0+0.0i)                     => #f
          (integer? #i3.0+0i)                     => #f

          (integer-valued? 3.0+0.0i)              => #t
          (integer-valued? #i3.0+0i)              => #t

          *NOTE* Except for 'number?', the behavior of these type
          predicates on inexact number objects is unreliable, because
          any inaccuracy may affect the result.

 -- Procedure: real-valued? OBJ
 -- Procedure: rational-valued? OBJ
 -- Procedure: integer-valued? OBJ
     These numerical type predicates can be applied to any kind of
     argument.  The 'real-valued?' procedure returns '#t' if the object
     is a number object and is equal in the sense of '=' to some real
     number object, or if the object is a NaN, or a complex number
     object whose real part is a NaN and whose imaginary part is zero in
     the sense of 'zero?'.  The 'rational-valued?' and 'integer-valued?'
     procedures return '#t' if the object is a number object and is
     equal in the sense of '=' to some object of the named type, and
     otherwise they return '#f'.

          (real-valued? +nan.0)                  => #t
          (real-valued? +nan.0+0i)               => #t
          (real-valued? -inf.0)                  => #t
          (real-valued? 3)                       => #t
          (real-valued? -2.5+0.0i)               => #t
          (real-valued? -2.5+0i)                 => #t
          (real-valued? -2.5)                    => #t
          (real-valued? #e1e10)                  => #t

          (rational-valued? +nan.0)              => #f
          (rational-valued? -inf.0)              => #f
          (rational-valued? 6/10)                => #t
          (rational-valued? 6/10+0.0i)           => #t
          (rational-valued? 6/10+0i)             => #t
          (rational-valued? 6/3)                 => #t

          (integer-valued? 3+0i)                 => #t
          (integer-valued? 3+0.0i)               => #t
          (integer-valued? 3.0)                  => #t
          (integer-valued? 3.0+0.0i)             => #t
          (integer-valued? 8/4)                  => #t

          *NOTE* These procedures test whether a given number object can
          be coerced to the specified type without loss of numerical
          accuracy.  Specifically, the behavior of these predicates
          differs from the behavior of 'real?', 'rational?', and
          'integer?' on complex number objects whose imaginary part is
          inexact zero.

          *NOTE* The behavior of these type predicates on inexact number
          objects is unreliable, because any inaccuracy may affect the
          result.

 -- Procedure: exact? Z
 -- Procedure: inexact? Z
     These numerical predicates provide tests for the exactness of a
     quantity.  For any number object, precisely one of these predicates
     is true.

          (exact? 5)                   => #t
          (inexact? +inf.0)            => #t
          (inexact? +nan.0)            => #t


File: vicare-scheme.info,  Node: baselib math ops exactness,  Next: baselib math ops value pred,  Prev: baselib math ops type pred,  Up: baselib math ops

4.6.4.2 Exactness conversion
............................

These procedures implement the natural one-to-one correspondence between
exact and inexact integer objects throughout an implementation-dependent
range.  The 'inexact' and 'exact' procedures are idempotent.

 -- Procedure: inexact Z
     The 'inexact' procedure returns an inexact representation of Z.  If
     inexact number objects of the appropriate type have bounded
     precision, then the value returned is an inexact number object that
     is nearest to the argument.  If an exact argument has no reasonably
     close inexact equivalent, an exception with condition type
     '&implementation-restriction-violation' may be raised.

          *NOTE* For a real number object whose magnitude is finite but
          so large that it has no reasonable finite approximation as an
          inexact number, a reasonably close inexact equivalent may be
          '+inf.0' or '-inf.0'.  Similarly, the inexact representation
          of a complex number object whose components are finite may
          have infinite components.

 -- Procedure: exact Z
     The 'exact' procedure returns an exact representation of Z.  The
     value returned is the exact number object that is numerically
     closest to the argument; in most cases, the result of this
     procedure should be numerically equal to its argument.  If an
     inexact argument has no reasonably close exact equivalent, an
     exception with condition type
     '&implementation-restriction-violation' may be raised.


File: vicare-scheme.info,  Node: baselib math ops value pred,  Next: baselib math ops comparison,  Prev: baselib math ops exactness,  Up: baselib math ops

4.6.4.3 Value predicates
........................

 -- Procedure: = Z1 Z2 Z3 ...
 -- Procedure: < X1 X2 X3 ...
 -- Procedure: > X1 X2 X3 ...
 -- Procedure: <= X1 X2 X3 ...
 -- Procedure: >= X1 X2 X3 ...
     These procedures return '#t' if their arguments are (respectively):
     equal, monotonically increasing, monotonically decreasing,
     monotonically nondecreasing, or monotonically nonincreasing, and
     '#f' otherwise.

     Examples:

          (= +inf.0 +inf.0)               => #t
          (= -inf.0 +inf.0)               => #f
          (= -inf.0 -inf.0)               => #t

     for any real number object X that is neither infinite nor NaN:

          (< -inf.0 X +inf.0)       => #t
          (> +inf.0 X -inf.0)       => #t

     for any number object Z:

          (= +nan.0 Z)              => #f

     For any real number object X:

          (< +nan.0 X)              => #f
          (> +nan.0 X)              => #f

     These predicates must be transitive.

          *NOTE* The traditional implementations of these predicates in
          Lisp-like languages are not transitive.

          *NOTE* While it is possible to compare inexact number objects
          using these predicates, the results may be unreliable because
          a small inaccuracy may affect the result; this is especially
          true of '=' and 'zero?' (below).

          When in doubt, consult a numerical analyst.

 -- Procedure: zero? Z
 -- Procedure: positive? X
 -- Procedure: negative? X
 -- Procedure: odd? N
 -- Procedure: even? N
 -- Procedure: finite? X
 -- Procedure: infinite? X
 -- Procedure: nan? X
     These numerical predicates test a number object for a particular
     property, returning '#t' or '#f'.

     'zero?'
          Tests if the number object is '=' to zero.

     'positive?'
          Tests whether it is greater than zero.

     'negative?'
          Tests whether it is less than zero.

     'odd?'
          Tests whether it is odd.

     'even?'
          Tests whether it is even.

     'finite?'
          Tests whether it is not an infinity and not a NaN.

     'infinite?'
          Tests whether it is an infinity.

     'nan?'
          Tests whether it is a NaN.

          (zero? +0.0)                  => #t
          (zero? -0.0)                  => #t
          (zero? +nan.0)                => #f
          (positive? +inf.0)            => #t
          (negative? -inf.0)            => #t
          (positive? +nan.0)            => #f
          (negative? +nan.0)            => #f
          (finite? +inf.0)              => #f
          (finite? 5)                   => #t
          (finite? 5.0)                 => #t
          (infinite? 5.0)               => #f
          (infinite? +inf.0)            => #t

          *NOTE* As with the predicates above, the results may be
          unreliable because a small inaccuracy may affect the result.


File: vicare-scheme.info,  Node: baselib math ops comparison,  Next: baselib math ops arithmetic,  Prev: baselib math ops value pred,  Up: baselib math ops

4.6.4.4 Comparison
..................

 -- Procedure: max X1 X2 ...
 -- Procedure: min X1 X2 ...
     These procedures return the maximum or minimum of their arguments.

          (max 3 4)               => 4
          (max 3.9 4)             => 4.0

     For any real number object X that is not a NaN:

          (max +inf.0 X)    => +inf.0
          (min -inf.0 X)    => -inf.0

          *NOTE* If any argument is inexact, then the result is also
          inexact (unless the procedure can prove that the inaccuracy is
          not large enough to affect the result, which is possible only
          in unusual implementations).  If 'min' or 'max' is used to
          compare number objects of mixed exactness, and the numerical
          value of the result cannot be represented as an inexact number
          object without loss of accuracy, then the procedure may raise
          an exception with condition type
          '&implementation-restriction'.


File: vicare-scheme.info,  Node: baselib math ops arithmetic,  Next: baselib math ops part,  Prev: baselib math ops comparison,  Up: baselib math ops

4.6.4.5 Arithmetic operations
.............................

 -- Procedure: + Z1 ...
 -- Procedure: * Z1 ...
     These procedures return the sum or product of their arguments.

          (+ 3 4)                 =>  7
          (+ 3)                   =>  3
          (+)                     =>  0
          (+ +inf.0 +inf.0)       =>  +inf.0
          (+ +inf.0 -inf.0)       =>  +nan.0

          (* 4)                   =>  4
          (*)                     =>  1
          (* 5 +inf.0)            =>  +inf.0
          (* -5 +inf.0)           =>  -inf.0
          (* +inf.0 +inf.0)       =>  +inf.0
          (* +inf.0 -inf.0)       =>  -inf.0
          (* 0 +inf.0)            =>  0 or +nan.0
          (* 0 +nan.0)            =>  0 or +nan.0
          (* 1.0 0)               =>  0 or 0.0

     For any real number object X that is neither infinite nor NaN:

          (+ +inf.0 x)            =>  +inf.0
          (+ -inf.0 x)            =>  -inf.0

     For any real number object X:

          (+ +nan.0 x)            =>  +nan.0

     For any real number object X that is not an exact 0:

          (* +nan.0 x)            =>  +nan.0

     If any of these procedures are applied to mixed non-rational real
     and non-real complex arguments, they either raise an exception with
     condition type '&implementation-restriction' or return an
     unspecified number object.

     Implementations that distinguish '-0.0' should adopt behavior
     consistent with the following examples:

          (+  0.0 -0.0)           =>  0.0
          (+ -0.0  0.0)           =>  0.0
          (+  0.0  0.0)           =>  0.0
          (+ -0.0 -0.0)           => -0.0

 -- Procedure: - Z
 -- Procedure: - Z1 Z2 Z3 ...
     With two or more arguments, this procedures returns the difference
     of its arguments, associating to the left.  With one argument,
     however, it returns the additive inverse of its argument.

          (- 3 4)                 => -1
          (- 3 4 5)               => -6
          (- 3)                   => -3
          (- +inf.0 +inf.0)       => +nan.0

     If this procedure is applied to mixed non-rational real and
     non-real complex arguments, it either raises an exception with
     condition type '&implementation-restriction' or returns an
     unspecified number object.

     Implementations that distinguish -0.0 should adopt behavior
     consistent with the following examples:

          (-  0.0)                => -0.0
          (- -0.0)                =>  0.0
          (-  0.0 -0.0)           =>  0.0
          (- -0.0  0.0)           => -0.0
          (-  0.0  0.0)           =>  0.0
          (- -0.0 -0.0)           =>  0.0

 -- Procedure: / Z
 -- Procedure: / Z1 Z2 Z3 ...
     If all of the arguments are exact, then the divisors must all be
     nonzero.  With two or more arguments, this procedure returns the
     quotient of its arguments, associating to the left.  With one
     argument, however, it returns the multiplicative inverse of its
     argument.

          (/ 3 4 5)               => 3/20
          (/ 3)                   => 1/3
          (/ 0.0)                 => +inf.0
          (/ 1.0 0)               => +inf.0
          (/ -1 0.0)              => -inf.0
          (/ +inf.0)              => 0.0
          (/ 0 0)                 => exception &assertion
          (/ 3 0)                 => exception &assertion
          (/ 0 3.5)               => 0.0
          (/ 0 0.0)               => +nan.0
          (/ 0.0 0)               => +nan.0
          (/ 0.0 0.0)             => +nan.0

     If this procedure is applied to mixed non-rational real and
     non-real complex arguments, it either raises an exception with
     condition type '&implementation-restriction' or returns an
     unspecified number object.

 -- Procedure: abs X
     Returns the absolute value of its argument.

          (abs -7)                 =>  7
          (abs -inf.0)             =>  +inf.0

 -- Procedure: div-and-mod X1 X2
 -- Procedure: div X1 X2
 -- Procedure: mod X1 X2
 -- Procedure: div0-and-mod0 X1 X2
 -- Procedure: div0 X1 X2
 -- Procedure: mod0 X1 X2
     These procedures implement number-theoretic integer division and
     return the results of the corresponding mathematical operations
     specified in *note baselib math semantics integer::.  If X1 and X2
     are exact, X2 must be nonzero.  In the cases where the mathematical
     requirements in *note baselib math semantics integer:: cannot be
     satisfied by any number object, either an exception is raised with
     condition type '&implementation-restriction', or unspecified number
     objects (one for for 'div', 'mod', 'div0' and 'mod0', two for
     'div-and-mod' and 'div0-and-mod0') are returned.

          (div x1 x2)        => x1 div x2
          (mod x1 x2)        => x1 mod x2

          (div-and-mod x1 x2)
          => x1 div x2,
             x1 mod x2 ;; two return values

          (div0 x1 x2)       => x1 div_0 x2
          (mod0 x1 x2)       => x1 mod_0 x2

          (div0-and-mod0 x1 x2)
          => x1 div_0 x2,
             x1 mod_0 x2 ;; two return values

 -- Procedure: gcd N1 ...
 -- Procedure: lcm N1 ...
     These procedures return the greatest common divisor or least common
     multiple of their arguments.  The result is always non-negative.

          (gcd 32 -36)                    => 4
          (gcd)                           => 0
          (lcm 32 -36)                    => 288
          (lcm 32.0 -36)                  => 288.0
          (lcm)                           => 1


File: vicare-scheme.info,  Node: baselib math ops part,  Next: baselib math ops trascend,  Prev: baselib math ops arithmetic,  Up: baselib math ops

4.6.4.6 Part separation
.......................

 -- Procedure: numerator Q
 -- Procedure: denominator Q
     These procedures return the numerator or denominator of their
     argument; the result is computed as if the argument was represented
     as a fraction in lowest terms.  The denominator is always positive.
     The denominator of '0' is defined to be '1'.

          (numerator   (/ 6 4))           => 3
          (denominator (/ 6 4))           => 2
          (denominator (inexact (/ 6 4))) => 2.0

 -- Procedure: floor X
 -- Procedure: ceiling X
 -- Procedure: truncate X
 -- Procedure: round X
     These procedures return inexact integer objects for inexact
     arguments that are not infinities or NaNs, and exact integer
     objects for exact rational arguments.

     'floor'
          Returns the largest integer object not larger than X.

     'ceiling'
          Returns the smallest integer object not smaller than X.

     'truncate'
          Returns the integer object closest to X whose absolute value
          is not larger than the absolute value of X.

     'round'
          Returns the closest integer object to X, rounding to even when
          X represents a number halfway between two integers (this
          conforms to IEEE 754 round to nearest mode).

     If the argument to one of these procedures is inexact, then the
     result is also inexact.  If an exact value is needed, the result
     should be passed to the 'exact' procedure.

     Although infinities and NaNs are not integer objects, these
     procedures return an infinity when given an infinity as an
     argument, and a NaN when given a NaN.

          (floor -4.3)            => -5.0
          (ceiling -4.3)          => -4.0
          (truncate -4.3)         => -4.0
          (round -4.3)            => -4.0

          (floor 3.5)             => 3.0
          (ceiling 3.5)           => 4.0
          (truncate 3.5)          => 3.0
          (round 3.5)             => 4.0

          (round 7/2)             => 4
          (round 7)               => 7

          (floor +inf.0)          => +inf.0
          (ceiling -inf.0)        => -inf.0
          (round +nan.0)          => +nan.0

 -- Procedure: rationalize X1 X2
     The 'rationalize' procedure returns a number object representing
     the _simplest_ rational number differing from X1 by no more than
     X2.

     A rational number r_1 is _simpler_ than another rational number r_2
     if r_1 = p_1/q_1 and r_2 = p_2/q_2 (in lowest terms) and |p_1| <=
     |p_2| and |q_1| <= |q_2|.  Thus 3/5 is simpler than 4/7.

     Although not all rationals are comparable in this ordering
     (consider 2/7 and 3/5) any interval contains a rational number that
     is simpler than every other rational number in that interval (the
     simpler 2/5 lies between 2/7 and 3/5).

     Note that 0 = 0/1 is the simplest rational of all.

          (rationalize (exact .3) 1/10)   => 1/3
          (rationalize .3 1/10)           => #i1/3 ; approximately

          (rationalize +inf.0 3)          => +inf.0
          (rationalize +inf.0 +inf.0)     => +nan.0
          (rationalize 3 +inf.0)          => 0.0

     The first two examples hold only in implementations whose inexact
     real number objects have sufficient precision.

