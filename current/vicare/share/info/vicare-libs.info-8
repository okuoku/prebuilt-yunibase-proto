This is vicare-libs.info, produced by makeinfo version 6.5 from
vicare-libs.texi.

This document describes the libraries distributed along with version
0.4.1-devel.3 of Vicare Scheme, an R6RS compliant native compiler for
the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

   The documentation of the libraries '(vicare parser-tools silex ---)'
are derived form the documentation of SILex.  Copyright (C) 2001, 2009
Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-libs: (vicare-libs).   Libraries for Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-libs.info,  Node: strings select,  Next: strings pad,  Prev: strings fold,  Up: strings

25.10 Selection
===============

 -- Macro: substring* S
     Wrapper for 'substring' accepting a string view as argument.

 -- Function: %string-copy* STR START PAST
 -- Macro: string-copy* S
     The function '%string-copy*' is an alias for 'substring'; the macro
     'string-copy*' is an alias for 'substring*'.

          These exist for symmetry with the '(vicare containers
          vectors)' library; they allow more confidence in converting a
          vector function into a string function, and vice versa, by
          just replacing the string 'vector' with the string 'string',
          and vice versa.

 -- Function: %string-reverse-copy* STR START PAST
 -- Macro: string-reverse-copy* S
     Like '%string-copy*', but copy the elements in the reverse order
     from the selected substring of STR.

          (string-reverse-copy* (view "543210")
                                  (start 1)
                                  (past  5)))
          => "1234"

 -- Function: %string-copy*! DST-STR DST-START SRC-STR SRC-START
          SRC-PAST
 -- Macro: string-copy*! DST-S SRC-S
     Write the selected source substring into the selected destination
     substring.  This function is the side-effecting variant of
     'substring' and 'substring*'.  This function supports copying over
     the same string.

     The selected destination substring starts at DST-START in DST-STR
     and may extend until the end of the string.  In the destination
     string view DST-S: If a past index is specified, it is ignored.

 -- Function: %string-reverse-copy*! DST-STR DST-START SRC-STR SRC-START
          SRC-PAST
 -- Macro: string-reverse-copy*! S-DST S-SRC
     Like '%string-copy*!', but this copies the elements in the reverse
     order.  This function supports copying over the same string.

 -- Function: %string-take NCHARS STR START PAST
 -- Function: %string-take-right NCHARS STR START PAST
 -- Macro: string-take S NCHARS
 -- Macro: string-take-right S NCHARS
     Return the first or last NCHARS of the selected substring.  These
     functions always return a newly allocated string.

 -- Function: %string-drop NCHARS STR START PAST
 -- Function: %string-drop-right NCHARS STR START PAST
 -- Macro: string-drop S NCHARS
 -- Macro: string-drop-right S NCHARS
     Drop the first or last NCHARS of the selected substring and return
     the resulting string.  These functions always return a newly
     allocated string.


File: vicare-libs.info,  Node: strings pad,  Next: strings prefix,  Prev: strings select,  Up: strings

25.11 Padding and trimming
==========================

 -- Function: %string-pad REQUESTED-LEN FILL-CHAR STR START PAST
 -- Function: %string-pad-right REQUESTED-LEN FILL-CHAR STR START PAST
 -- Macro: string-pad S REQUESTED-LEN
 -- Macro: string-pad S REQUESTED-LEN FILL-CHAR
 -- Macro: string-pad-right S REQUESTED-LEN
 -- Macro: string-pad-right S REQUESTED-LEN FILL-CHAR
     Build a string of length REQUESTED-LEN comprised of STR padded on
     the left or right by as many occurrences of the character FILL-CHAR
     as needed.  Always return a newly allocated string.

     If STR has more than REQUESTED-LEN chars, it is truncated on the
     left or right to length REQUESTED-LEN.  For the macros: FILL-CHAR
     defaults to '#\space'.

     Examples:

          (string-pad     "325" 5) => "  325"
          (string-pad   "71325" 5) => "71325"
          (string-pad "8871325" 5) => "71325"

 -- Function: %string-trim CHAR/CHAR-SET/PRED STR START PAST
 -- Function: %string-trim-right CHAR/CHAR-SET/PRED STR START PAST
 -- Function: %string-trim-both CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-trim S CHAR/CHAR-SET/PRED
 -- Macro: string-trim-right S CHAR/CHAR-SET/PRED
 -- Macro: string-trim-both S CHAR/CHAR-SET/PRED
     Trim STR by skipping over all characters on the left/on the
     right/on both sides that satisfy the second parameter
     CHAR/CHAR-SET/PRED:

        * If it is a character CHAR, characters equal to CHAR are
          trimmed.

        * If it is a char set CHAR-SET, characters contained in CHAR-SET
          are trimmed.

        * If it is a predicate PRED, it is a test predicate that is
          applied to the characters in S; a character causing it to
          return true is skipped.

     Always return a newly allocated string.


File: vicare-libs.info,  Node: strings prefix,  Next: strings search,  Prev: strings pad,  Up: strings

25.12 Prefixes and suffixes
===========================

 -- Function: %string-prefix-length STR1 START1 PAST1 STR2 START2 PAST2
 -- Function: %string-prefix-length-ci STR1 START1 PAST1 STR2 START2
          PAST2
 -- Macro: string-prefix-length S1 S2
 -- Macro: string-prefix-length-ci S1 S2
     Return the length of the longest common prefix of the two
     substrings.  This is equivalent to the "mismatch index" for the
     strings (modulo the start index offsets).

 -- Function: %string-suffix-length STR1 START1 PAST1 STR2 START2 PAST2
 -- Function: %string-suffix-length-ci STR1 START1 PAST1 STR2 START2
          PAST2
 -- Macro: string-suffix-length S1 S2
 -- Macro: string-suffix-length-ci S1 S2
     Return the length of the longest common suffix of the two
     substrings.

 -- Function: %string-prefix? STR1 START1 PAST1 STR2 START2 PAST2
 -- Function: %string-prefix-ci? STR1 START1 PAST1 STR2 START2 PAST2
 -- Macro: string-prefix? S1 S2
 -- Macro: string-prefix-ci? S1 S2
     Return '#t' if the selected substring of STR1 is a prefix of the
     selected substring of STR2, otherwise return '#f'.  Notice that the
     empty string is a prefix of every string.

 -- Function: %string-suffix? STR1 START1 PAST1 STR2 START2 PAST2
 -- Function: %string-suffix-ci? STR1 START1 PAST1 STR2 START2 PAST2
 -- Macro: string-suffix? S1 S2
 -- Macro: string-suffix-ci? S1 S2
     Return '#t' if the selected substring of STR1 is a suffix of the
     selected substring of STR2, otherwise return '#f'.  Notice that the
     empty string is *not* a suffix of every string.


File: vicare-libs.info,  Node: strings search,  Next: strings filter,  Prev: strings prefix,  Up: strings

25.13 Searching
===============

 -- Function: %string-index CHAR/CHAR-SET/PRED STR START PAST
 -- Function: %string-index-right CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-index S CHAR/CHAR-SET/PRED
 -- Macro: string-index-right S CHAR/CHAR-SET/PRED
     Search through the string from the left or right, returning the
     index of the first occurrence of a character which:

        * Equals CHAR/CHAR-SET/PRED if it is a character.

        * Is in CHAR/CHAR-SET/PRED if it is a character set.

        * Satisfies the predicate CHAR/CHAR-SET/PRED if it is a
          procedure.

     If no match is found: Return '#f'.

 -- Function: %string-skip CHAR/CHAR-SET/PRED STR START PAST
 -- Function: %string-skip-right CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-skip S CHAR/CHAR-SET/PRED
 -- Macro: string-skip-right S CHAR/CHAR-SET/PRED
     Search through the string from the left or right, returning the
     index of the first occurrence of a character which:

        * Does not equal CHAR/CHAR-SET/PRED if it is a character.

        * Is not in CHAR/CHAR-SET/PRED if it is a character set.

        * Does not satisfy the predicate CHAR/CHAR-SET/PRED if it is a
          procedure.

     If no match is found: Return '#f'.

 -- Function: %string-count CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-count S CHAR/CHAR-SET/PRED
     Return a count of the number of characters in STR that satisfy the
     CHAR/CHAR-SET/PRED argument:

        * If it is a procedure, it is applied to the character as a
          predicate.

        * If it is a character set, the character is tested for
          membership.

        * If it is a character, it is used in an equality test.

 -- Function: %string-contains STR1 START1 PAST1 STR2 START2 PAST2
 -- Function: %string-contains-ci STR1 START1 PAST1 STR2 START2 PAST2
 -- Macro: string-contains S1 S2
 -- Macro: string-contains-ci S1 S2
     Return true if the selected substring of STR1 contains the selected
     substring of STR2, else return '#f'.  The return value is the index
     in STR1 where the substring of STR2 occurs.

 -- Function: %string-search-and-replace SRC START1 PAST1 PATTERN START2
          PAST2 REPLACE START3 PAST3 MAX-REPLACEMENT-COUNT
 -- Function: %string-search-and-replace-ci SRC START1 PAST1 PATTERN
          START2 PAST2 REPLACE START3 PAST3 MAX-REPLACEMENT-COUNT
 -- Macro: string-search-and-replace SRC PATTERN REPLACE
          MAX-REPLACEMENT-COUNT
 -- Macro: string-search-and-replace-ci SRC PATTERN REPLACE
          MAX-REPLACEMENT-COUNT
     Build and return a copy of the selected substring of SRC, in which
     the occurrences of the selected substring of PATTERN are replaced
     with the selected substring of REPLACE.

     At most MAX-REPLACEMENT-COUNT occurrences are replaced: if it is
     zero, the selected substring of SRC is returned; if it is '+inf.0',
     all the occurrences are replaced.


File: vicare-libs.info,  Node: strings filter,  Next: strings list,  Prev: strings search,  Up: strings

25.14 Filtering and deleting
============================

 -- Function: %string-filter CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-filter S CHAR/CHAR-SET/PRED
     Filter the selected substring, retaining only those characters that
     satisfy the CHAR/CHAR-SET/PRED argument:

        * If it is a procedure, it is applied to the character as a
          predicate.

        * If it is a character set, the character is tested for
          membership.

        * If it is a character, it is used in an equality test.

     Always return a newly allocated string.

 -- Function: %string-delete CHAR/CHAR-SET/PRED STR START PAST
 -- Macro: string-delete S CHAR/CHAR-SET/PRED
     Filter the selected substring, retaining only those characters that
     do *not* satisfy the CHAR/CHAR-SET/PRED argument:

        * If it is a procedure, it is applied to the character as a
          predicate.

        * If it is a character set, the character is tested for
          membership.

        * If it is a character, it is used in an equality test.

     Always return a newly allocated string.


File: vicare-libs.info,  Node: strings list,  Next: strings replicate,  Prev: strings filter,  Up: strings

25.15 List and string conversion
================================

 -- Function: %string->list* STR START PAST
 -- Macro: string->list* S
     Return a newly allocated list of the characters that make up the
     given substring.  This is an extension of the 'string->list'
     function that adds support for substrings.

 -- Function: %reverse-string->list STR START PAST
 -- Macro: reverse-string->list S
     Like '%string->list*' but reverses the order of the characters from
     the substring.

 -- Function: reverse-list->string CHAR-LIST
     Reverse the given list of characters, then compose a string with
     the result.

          (reverse-list->string '(#\a #\B #\c))
          => "cBa"

 -- Function: %string-tokenize TOKEN-SET STR START PAST
 -- Function: %string-tokenise TOKEN-SET STR START PAST
 -- Macro: string-tokenize S TOKEN-SET
 -- Macro: string-tokenise S TOKEN-SET
     Split the selected substring into a list of strings, where each
     string is a maximal, non-empty, contiguous sequence of characters
     from the character set TOKEN-SET.

          (string-tokenize "Help make programs run, run, RUN!"
                           (char-set-complement (char-set #\space)
                                                char-set:ascii))
          => ("Help" "make" "programs" "run," "run," "RUN!")

          This function provides a minimal parsing facility for simple
          applications.  More sophisticated parsers that handle quoting
          and backslash effects can easily be constructed using
          regular-expression systems; be careful not to use
          'string-tokenize' in contexts where more serious parsing is
          needed.

 -- Function: string-join STRING-LIST
 -- Function: string-join STRING-LIST DELIMITER
 -- Function: string-join STRING-LIST DELIMITER GRAMMAR
 -- Function: %string-join STRING-LIST DELIMITER GRAMMAR
     This procedure is a simple unparser: It pastes strings together
     using the DELIMITER string.  DELIMITER defaults to a single white
     space.  GRAMMAR is a symbol that determines how the delimiter is
     used, and defaults to 'infix'.  Supported values for GRAMMAR are:

     'infix'
          Means an infix or separator grammar: Insert the delimiter
          between list elements.  An empty list will produce an empty
          string.

               *Note*: Parsing an empty string with an infix grammar is
               ambiguous.  Is it an empty list, or a list of one
               element, the empty string?

     'strict-infix'
          Means the same as 'infix', but will raise an error if given an
          empty list.

     'suffix'
          Means a suffix or terminator grammar: Insert the delimiter
          after every list element.  This grammar has no ambiguities.

     'prefix'
          Means a prefix grammar: Insert the delimiter before every list
          element.  This grammar has no ambiguities.

     The delimiter is the string used to delimit elements; it defaults
     to a single space.

     Examples:

          (string-join '("foo" "bar" "baz") ":")
          => "foo:bar:baz"

          (string-join '("foo" "bar" "baz") ":" 'suffix)
          => "foo:bar:baz:"

          ;; Infix grammar is ambiguous wrt empty list vs. empty string,
          (string-join '()   ":") => ""
          (string-join '("") ":") => ""

          (string-join '("") "," 'strict-infix) => ""
          (string-join '("") "," 'suffix) => ","
          (string-join '("") "," 'prefix) => ","


File: vicare-libs.info,  Node: strings replicate,  Next: strings mutate,  Prev: strings list,  Up: strings

25.16 Replicate and rotate
==========================

 -- Function: %xsubstring FROM TO STR START PAST
 -- Macro: xsubstring S FROM TO
     Extended substring procedure replicating the selected substring "up
     and down" index space, in both the positive and negative
     directions.

     The call:

          (%xsubstring from to "abcdefg" 3 6)

     selects the substring '"def"' and defines the conceptual
     bidirectionally-infinite string:

          ...  e  f  d  e  f  d  e  f  d  e  f ...
          ... -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 ...
                              ^

     that is 'def' repeated in both directions.  '%xsubstring' returns
     the substring of this string beginning at index FROM, and ending at
     TO.

     We can use this function to perform a variety of tasks:

        * To replicate a string:

               (xsubstring "abc" 0 7) => "abcabca"

        * To rotate a string left:

               (xsubstring "abcdef" 1  7) => "bcdefa"
               (xsubstring "abcdef" 2  8) => "cdefab"
               (xsubstring "abcdef" 3  9) => "defabc"
               (xsubstring "abcdef" 4 10) => "efabcd"
               (xsubstring "abcdef" 5 11) => "fabcde"

        * To rotate a string right:

               (xsubstring "abcdef" -1 5) => "fabcde"
               (xsubstring "abcdef" -2 4) => "efabcd"
               (xsubstring "abcdef" -3 3) => "defabc"
               (xsubstring "abcdef" -4 2) => "cdefab"
               (xsubstring "abcdef" -5 1) => "bcdefa"

     Note that:

        * The FROM/TO indices give a half-open range; the characters
          from index FROM up to, but not including, index TO.

        * The FROM/TO indices are not in terms of the index space for
          string STR.  They are in terms of the replicated index space
          of the substring defined by STR, START, and PAST.

     It is an error if START equals PAST.

 -- Function: xstring-xcopy! FROM TO TARGET TARGET-START SOURCE
          SOURCE-START SOURCE-PAST
 -- Macro: string-xcopy! TARGET-S SOURCE-S FROM TO
     Exactly the same as '%xsubstring', but the extracted text is
     written into the selected substring of TARGET.

     This operation is not defined if '(eq? target start)'; we cannot
     copy a string on top of itself.


File: vicare-libs.info,  Node: strings mutate,  Next: strings misc,  Prev: strings replicate,  Up: strings

25.17 Mutators
==============

 -- Function: string-swap! STR I J
     Swap the characters in STR at positions I and J.

 -- Function: %string-fill*! FILL-CHAR STR START PAST
 -- Macro: string-fill*! S FILL-CHAR
     Fill the selected substring with FILL-CHAR, modifying the original
     string.


File: vicare-libs.info,  Node: strings misc,  Next: strings rabin-karp,  Prev: strings mutate,  Up: strings

25.18 Miscellaneous functions
=============================

 -- Function: %string-replace STR1 START1 PAST1 STR2 START2 PAST2
 -- Macro: string-replace S1 S2
     Replace the selected string in STR1 with the selected string in
     STR2.  Return a newly allocated string.

 -- Function: %string-reverse STR START PAST
 -- Function: %string-reverse! STR START PAST
 -- Macro: string-reverse S
 -- Macro: string-reverse! S
     Reverse the string.  '%string-reverse' returns the result string
     and does not alter its STR parameter.  '%string-reverse!' is the
     in-place side-effecting variant.

 -- Function: word-frequency GETTER-FUNC
     Count the number of occurrences of words in the sequence returned
     by successive invocations of GETTER-FUNC, return a hashtable
     associating words to counts.  GETTER-FUNC must return a Scheme
     string at each invocation or '#f' when no more strings are
     available.

          (import (vicare)
            (vicare containers strings)
            (vicare containers char-sets))

          (let* ((line   "ciao ciao hello salut ciao salut")
                 (words  (string-tokenize line char-set:ascii/letter))
                 (getter (let ((words words))
                           (lambda ()
                             (if (null? words)
                                 #f
                               (begin0
                                   (car words)
                                 (set! words (cdr words)))))))
                 (result (word-frequency getter)))
            (hashtable-ref result "ciao"  0)      => 3
            (hashtable-ref result "hello" 0)      => 1
            (hashtable-ref result "salut" 0))     => 2


File: vicare-libs.info,  Node: strings rabin-karp,  Prev: strings misc,  Up: strings

25.19 Rabin-Karp string search
==============================

The library '(vicare containers strings rabin-karp)' implements the
Rabin-Karp string search algorithm.

 -- Opaque Object Type: 'rabin-karp'
     Scheme object type, disjoint from all the other types, holding the
     state for repeated string searches using the same pattern over
     different texts.

 -- Function: make-rabin-karp PATTERN
 -- Function: make-rabin-karp PATTERN BASE
 -- Function: make-rabin-karp PATTERN BASE PRIME
     Build and return a new 'rabin-karp' object.  PATTERN must be a
     Scheme string representing the pattern to search for.  BASE must be
     a fixnum used in the rolling hash algorithm (when in doubt use
     256); it defaults to '256'.  PRIME must be a "large" prime fixnum
     (when in doubt use 472882049); it defaults to '472882049'.

 -- Function: rabin-karp? OBJ
     Return '#t' if OBJ is a 'rabin-karp' object, otherwise return '#f'.

 -- Validation Clause: rabin-karp OBJ
     Validation clause to be used with the facilities of the library
     '(vicare arguments validation)'.  Succeed if OBJ satisfies the
     predicate 'rabin-karp?'.

 -- Function: rabin-karp-search RABIN-KARP TEXT
     Perform the search of a pattern over TEXT, which must be a Scheme
     string.  If successful: return the offset of the first character of
     the first occurrence of pattern in TEXT; else return '#f'.

   Examples:

     #!r6rs
     (import (vicare)
       (vicare containers strings rabin-karp))

     (define S (make-rabin-karp "ciao"))
     (rabin-karp-search S "012345ciao")      => 6
     (rabin-karp-search S "hello world")     => #f


File: vicare-libs.info,  Node: char-sets,  Next: bytevectors,  Prev: strings,  Up: Top

26 Character sets
*****************

The library '(vicare containers char-sets)' handles sets of characters.

   A "character" is every value for which the application of 'char?'
returns '#t'; "character sets" are values of disjoint type 'char-set'
representing a number of character in the available Unicode ranges,
*note Unicode: (vicare-scheme)stdlib unicode.

* Menu:

* char-sets conv::              Arguments naming conventions.
* char-sets make::              Constructors.
* char-sets pred::              Predicates.
* char-sets inspect::           Inspection.
* char-sets ops::               Operations.
* char-sets sets::              Predefined character sets.


File: vicare-libs.info,  Node: char-sets conv,  Next: char-sets make,  Up: char-sets

26.1 Arguments naming conventions
=================================

In the following procedure specifications:

CS
     Is a character set.

STR
     Is a string.

CHAR
     Is a character.

RANGE
     Is a pair of characters interpreted as double-closed range of
     characters, the car being the lower-limit and the cdr being the
     upper-limit.

CHAR-LIST
     Is a list of characters.

PRED
     Is a unary character predicate procedure, returning a boolean value
     when applied to a character.

OBJ
     May be any value at all.

   A parameter followed by '...' means zero-or-more elements.

   Unless otherwise noted in the specification of a procedure,
procedures always return character sets that are distinct from the
parameter character sets.


File: vicare-libs.info,  Node: char-sets make,  Next: char-sets pred,  Prev: char-sets conv,  Up: char-sets

26.2 Constructors
=================

 -- Function: char-set CHAR/RANGE ...
     Build and return a new 'char-set'.  The CHAR/RANGE arguments may be
     the empty list or a mixed list of characters and ranges.

 -- Function: char-set-copy CS
     Return a newly allocated 'char-set' holding a copy of CS.

 -- Function: char-set-add CS CHAR/RANGE ...
 -- Function: char-set-adjoin CS CHAR/RANGE ...
     Add values to an existing 'char-set'.  CHAR/RANGE can be a single
     character or a range.  Return a new instance of 'char-set'; the
     returned set may share some structure with the arguments.

 -- Function: char-set-add! CS CHAR/RANGE ...
 -- Function: char-set-adjoin! CS CHAR/RANGE ...
     Add values to an existing 'char-set'.  CHAR/RANGE can be a single
     character or a range.  Return CS itself; the returned set may share
     some structure with the arguments.

 -- Function: char-set-delete CS CHAR/RANGE ...
     Delete the CHAR/RANGE from the character set CS.

          (char-set-delete (char-set #\a #\b) #\b)
          => (char-set #\a)

 -- Constant: char-set-lower-bound
 -- Constant: char-set-upper-bound
 -- Constant: char-set-inner-upper-bound
 -- Constant: char-set-inner-lower-bound
     The character sets are defined by the Scheme standard to be in the
     ranges '[0, #xD800)' and '(#xDFFF, #x10FFFF]'.  '(vicare containers
     char-sets)' exports these symbols, defined as follows:

          (define char-set-lower-bound
            (integer->char 0))

          (define char-set-inner-upper-bound
            (integer->char (- #xD800 1)))

          (define char-set-inner-lower-bound
            (integer->char (+ 1 #xDFFF)))

          (define char-set-upper-bound
            (integer->char #x10FFFF))


File: vicare-libs.info,  Node: char-sets pred,  Next: char-sets inspect,  Prev: char-sets make,  Up: char-sets

26.3 Predicates
===============

 -- Function: char-set? OBJ
     Return '#t' if OBJ is an object of type 'char-set', else return
     '#f'.

 -- Function: char-set?/internals OBJ
     Return '#t' if OBJ is an object of type 'char-set' and its internal
     representation is valid; otherwise return '#f'.  This function is
     more time-consuming than 'char-set?', and it is meant for debugging
     purposes.

 -- Function: char-set-empty? CS
     Return '#t' if the 'char-set' is empty, else return '#f'.

 -- Function: char-set-contains? CS CHAR
     Return '#t' if CHAR is an element of CS.

 -- Function: char-set=? CS ...
     Return '#t' if the arguments represent the same 'char-set', else
     return '#f'.  When called with no arguments: return '#t'.  When
     called with one argument: return '#t'.

 -- Function: char-set<? CS ...
     Return '#t' if all the elements of CS are strictly less than all
     the elements of the subsequent CS, else return '#f'.  Empty sets
     cannot be ordered, so if an argument is empty the return value is
     '#f'.  When called with no arguments: return '#t'.  When called
     with one argument: return '#t'.

 -- Function: char-set<=? CS ...
     Return '#t' if all the elements of CS are non-strictly less than
     all the elements of the subsequent CS, else return '#f'.  Empty
     sets cannot be ordered, so if an argument is empty the return value
     is '#f'.  When called with no arguments: return '#t'.  When called
     with one argument: return '#t'.

 -- Function: char-set-subset? CS ...
 -- Function: char-set-subset?/strict CS ...
     Return '#t' if the arguments, in the given order, are subsets of
     each other or strict subsets of each other, else return '#f'.  When
     called with zero or one argument: return '#t'.

 -- Function: char-set-superset? CS ...
 -- Function: char-set-superset?/strict CS ...
     Return '#t' if the arguments, in the given order, are supersets of
     each other or strict supersets of each other, else return '#f'.
     When called with zero or one argument: return '#t'.


File: vicare-libs.info,  Node: char-sets inspect,  Next: char-sets ops,  Prev: char-sets pred,  Up: char-sets

26.4 Inspection
===============

 -- Function: char-set-size CS
     Return an exact integer representing the number of characters in
     CS.

 -- Function: char-set-count PRED CS
     Return the number of characters in CS for which the predicate
     function PRED returns non-false.

 -- Function: char-set-write CS
 -- Function: char-set-write CS PORT
     Write to PORT a chunk of Scheme code that, when evaluated,
     generates CS.  When not given, PORT defaults to
     '(current-output-port)'.

 -- Function: char-set-hash CS
 -- Function: char-set-hash CS BOUND
     Compute a hash value for the character set CS.  The optional
     argument BOUND is a non-negative exact integer specifying the range
     of the hash function; a positive value restricts the return value
     to the range '[0, BOUND)'.

     If bound is either zero or not given: the implementation may use an
     implementation-specific default value, chosen to be as large as is
     efficiently practical.  For instance, the default range might be
     chosen for a given implementation to map all strings into the range
     of integers that can be represented with a single machine word.

     Invariant:

          (char-set=? cs1 cs2) => (= (char-set-hash cs1 b)
                                     (char-set-hash cs2 b))


File: vicare-libs.info,  Node: char-sets ops,  Next: char-sets sets,  Prev: char-sets inspect,  Up: char-sets

26.5 Operations
===============

 -- Function: char-set-intersection CS ...
     Return a new set representing the intersection of the arguments;
     the intersection is the set of characters present in all the
     arguments.  When called with no arguments: return a new 'char-set'
     representing all the characters in Unicode.

     The returned set may share some structure with the arguments.

 -- Function: char-set-union CS ...
     Return a new set representing the union of the arguments; the union
     is the set of characters present in one and/or more arguments.
     When called with no arguments: return a new empty 'char-set'.

     The returned set may share some structure with the arguments.

 -- Function: char-set-difference CS0 CS ...
     Return a new set representing the difference between the arguments;
     the difference is the set of characters from CS0 not present in any
     of the CS 'char-set' objects.

     The returned set may share some structure with the arguments.

 -- Function: char-set-difference+intersection CS0 CS ...
     Return two values: the difference and the intersection of the
     arguments; it partitions its first argument.  It is equivalent to:

          (values (char-set-difference cs1 cs2 ...)
                  (char-set-intersection cs1 (char-set-union cs2 ...)))

 -- Function: char-set-xor CS ...
     Return a new set representing the exclusive difference between the
     arguments: it is the set of characters in only one of the
     arguments.  When called with no arguments: return the empty set.

     The returned set may share some structure with the arguments.

 -- Function: char-set-complement CS
 -- Function: char-set-complement CS CS-UNIVERSE
     Return a new set representing the complement of CS in CS-UNIVERSE.
     The complement is the set of characters present in CS-UNIVERSE,
     which are not present in CS.

     If omitted, CS-UNIVERSE defaults to 'char-set:full'.

     The returned set may share some structure with the arguments.

 -- Function: char-set-for-each PROC CS
     Apply PROC to each character in CS.

 -- Function: char-set-map PROC CS
     Apply PROC to each character in CS; PROC must return a character.
     Return a new 'char-set' holding all the characters returned by
     PROC.

 -- Function: char-set-filter PRED CS
     Apply PRED to each character in CS.  Return a new 'char-set'
     holding all the characters from CS for which PRED returned
     non-false.

 -- Function: char-set-every PROC CS
     Apply PROC to each character in the set and return true if all the
     return values are true.  The application stops at the first '#f'
     return value.

 -- Function: char-set-any PROC CS
     Apply PROC to each character in the set and return true if at least
     one of the returned values is true.  The application stops at the
     first true return value.

 -- Function: char-set-fold KONS KNIL CS
     Fold KONS over the characters in the set.  KONS must accept two
     arguments: The next character from the set and the return value of
     the previous invocation of KONS.  At the first application the
     second argument to KONS is KNIL.

 -- Function: char-set->list CS
     Return a list holding all the characters in the set.  Beware that
     for some character sets the resulting list can be big.

 -- Function: list->char-set LIST-OF-CHARS
 -- Function: list->char-set LIST-OF-CHARS BASE-CS
     Return a new 'char-set' holding the characters in the given list
     and the characters in the given BASE-CS.

 -- Function: string->char-set STRING
 -- Function: string->char-set STRING BASE-CS
     Return a new character set holding all the characters in STRING and
     the characters in BASE-CS.

 -- Function: char-set->string CS
     Return a new string object holding all the characters from CS.  The
     order in which the characters appear is undefined.

 -- Function: char-set-cursor CS
 -- Function: char-set-ref CURSOR
 -- Function: char-set-cursor-next CURSOR
 -- Function: end-of-char-set? CURSOR
     Cursors are a low-level facility for iterating over the characters
     in a set; a cursor is a value that indexes a character in a char
     set.

     'char-set-cursor' returns a new cursor object associated to the
     character set CS.  There can be multiple cursors associated to the
     same character set.

     'char-set-ref' returns a character object representing the set
     element currently indexed by a cursor.

     'char-set-cursor-next' increments a cursor index and returns a new
     cursor indexing the next character in the set; in this way, code
     can step through every character in a char set.

     Stepping a cursor "past the end" of a char set produces a cursor
     that answers true to 'end-of-char-set?'.  It is an error to pass
     such a cursor to 'char-set-ref' or to 'char-set-cursor-next'.

     A cursor value may not be used in conjunction with a different
     character set; if it is passed to 'char-set-ref' or
     'char-set-cursor-next' with a character set other than the one used
     to create it, the results and effects are undefined.

     Cursor values are not necessarily distinct from other types: they
     may be integers, linked lists, records, procedures or other values.

     Note that these primitives are necessary to export an iteration
     facility for char sets to loop macros.

     Example:

          (define cs (char-set #\G #\a #\T #\e #\c #\h))

          ;; Collect elts of CS into a list.
          (let lp ((cur (char-set-cursor cs)) (ans '()))
            (if (end-of-char-set? cur) ans
                (lp (char-set-cursor-next cs cur)
                    (cons (char-set-ref cs cur) ans))))
            => (#\G #\T #\a #\c #\e #\h)

          ;; Equivalently, using a list unfold (from SRFI 1):
          (unfold-right end-of-char-set?
                       (curry char-set-ref cs)
                (curry char-set-cursor-next cs)
                (char-set-cursor cs))
            => (#\G #\T #\a #\c #\e #\h)


File: vicare-libs.info,  Node: char-sets sets,  Prev: char-sets ops,  Up: char-sets

26.6 Predefined character sets
==============================

Several character sets are predefined for convenience by '(vicare
containers char-sets)' and other auxiliary libraries.  They are meant to
satisfy the simplest needs.

* Menu:

* char-sets sets intro::        Introduction.
* char-sets sets how::          How predefined sets were defined.
* char-sets sets basic::        Basic character sets.
* char-sets sets ascii::        Sets of ASCII characters.
* char-sets sets blocks::       Sets corresponding to Unicode blocks.
* char-sets sets categories::   Sets corresponding to Unicode general
                                categories.


File: vicare-libs.info,  Node: char-sets sets intro,  Next: char-sets sets how,  Up: char-sets sets

26.6.1 Introduction
-------------------

Unicode assigns a single number to each code element defined by the
Standard.  Each of these numbers is called a "code point" and, when
referred to in text, is listed in hexadecimal form following the prefix
'U+'.  For example, the code point 'U+0041' is the hexadecimal number
'0041' (equal to the decimal number '65'); it represents the character
'A' in the Unicode Standard.

   Each character is also assigned a unique name that specifies it and
no other.  For example, 'U+0041' is assigned the character name 'LATIN
CAPITAL LETTER A'.  'U+0A1B' is assigned the character name 'GURMUKHI
LETTER CHA'.  These Unicode names are identical to the ISO/IEC 10646
names for the same characters.

   For a general overview of the Unicode Standard see(1):

                <http://en.wikipedia.org/wiki/Unicode>

   For the complete reference of Unicode code points we should inspect
the Unicode Characters Database(2):

        <ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt>
           <ftp://ftp.unicode.org/Public/UNIDATA/Blocks.txt>

which is partly and introductorily documented by(3):

            <ftp://ftp.unicode.org/Public/UNIDATA/UCD.html>

the same directory on the <unicode.org> site offers other documents on
the interpretation of the database.

   For an explanation of ASCII coding, see(4):

                 <http://en.wikipedia.org/wiki/Ascii>

   ---------- Footnotes ----------

   (1) URL last verified Tue Jun 23, 2009.

   (2) URLs last verified Tue Jun 23, 2009.

   (3) URL last verified Tue Jun 23, 2009.

   (4) URL last verified Tue Jun 23, 2009.


File: vicare-libs.info,  Node: char-sets sets how,  Next: char-sets sets basic,  Prev: char-sets sets intro,  Up: char-sets sets

26.6.2 How predefined sets were defined
---------------------------------------

The following methods were employed to define the character sets.

   * The ASCII-related sets were composed by hand reading the ASCII
     description; they are exported by the '(vicare containers
     char-sets)' library itself.

   * All the ranges defined by the 'Blocks.txt' database file have been
     converted to a set by hand; they are exported by the '(vicare
     containers char-sets blocks)' library (there are a lot of them).

   * Each general category ('Ll', 'Lu', etc.)  has been converted to a
     set; they are exported by the '(vicare containers char-sets
     categories)' library (there are a lot of them).  Notice that not
     all the code points accepted by 'char=?' are part of a general
     category, so the union of the category sets is different from the
     full character set.

Inspecting the database
.......................

On a Unix-like system, the following commands can be used to inspect the
'UnicodeData.txt' database:

'wc -l <UnicodeData.txt'
     Count the lines in the database: One line for each code point.
     Notice that not all the code points have a line in this file; the
     file format allows ranges, so some pairs of lines represent ranges
     of characters.

'cut -d';' -f3 <UnicodeData.txt | sort | uniq'
     Print the category codes in the database (use 'sort' first, because
     'uniq' removes repeated lines only if they are adjacent).  Notice
     that the 'Cs' category (surrogate characters) is present in the
     database, but excluded from the Vicare libraries, because it
     describes the range '[#xD800, #xDFFF]' forbidden by R6RS.

'grep ';Cs;' <UnicodeData.txt'
     Print only the lines describing the surrogate characters.  They are
     six lines representing the three ranges:

     '[#xD800, #xDB7F]'
          Non private use high surrogate.

     '[#xDB80, #xDBFF]'
          Private use high surrogate.

     '[#xDC00, #xDFFF]'
          Low surrogate.

     Notice that these ranges are adjacent and their union is the range
     '[#xD800, #xDFFF]'.

'grep -v ';Cs;' <UnicodeData.txt | wc -l'
     Count the lines excluding the surrogate characters.  The count
     should be 19330 (last verified with the database downloaded Wed Jun
     23, 2009).

'grep ';Ll;' <UnicodeData.txt'
     Extract all the lines describing the 'Ll' category.

'grep ', *\(First\|Last\)>' <UnicodeData.txt'
     Extract all the lines describing the inclusive limit of a range of
     characters.

'grep -v ', *\(First\|Last\)>' <UnicodeData.txt'
     Extract all the lines describing a single code point, excluding the
     lines describing the limit of a range of characters.

   The following Bourne shell script processes the 'UnicodeData.txt'
database and prints a Scheme program that, when evaluated, prints the
definitions of category character sets.  The output script program makes
use of the '(vicare containers char-sets)' library itself.

     # unicode-database-extract-category-code-points.sh --
     #

     DATABASE=${1:?'missing UnicodeData.txt pathname'}

     CATEGORY_CODES=$(cut -d';' -f3 <"$DATABASE" | sort | uniq | grep -v Cs)

     echo '(import (rnrs) (vicare containers char-sets))'

     for CATEGORY in $CATEGORY_CODES
     do
         echo processing category $CATEGORY >&2
         echo -n "(define category-$CATEGORY (quote ("
         {
             grep ";$CATEGORY;" <"$DATABASE"   | \
                 grep -v ', *\(First\|Last\)>' | \
                 cut -d';' -f1                 | \
                 while read
             do echo -n "#\x$REPLY "
             done

             grep ";$CATEGORY;" <"$DATABASE"   | \
                 grep ', *\(First\|Last\)>'    | \
                 cut -d';' -f1                 | \
                 while read
             do
                 FIRST=$REPLY
                 read
                 LAST=$REPLY
                 echo -n "(#\x$FIRST . #\x$LAST) "
             done
         }
         echo ')))'
         echo "(display \"(define char-set:category/$CATEGORY\")(newline)"
         echo "(char-set-write (apply char-set category-$CATEGORY))(newline)"
         echo '(display ")")(newline)'
         echo
     done

     ### end of file

For example, the output for the 'Co' category, which has only ranges, is
(reformatted to look human readable):

     (define category-Co (quote ((#\xE000 . #\xF8FF)
                                 (#\xF0000 . #\xFFFFD)
                                 (#\x100000 . #\x10FFFD))))

     (display "(define char-set:category/Co")
     (newline)
     (char-set-write (apply char-set category-Co))
     (newline)
     (display ")")
     (newline)


File: vicare-libs.info,  Node: char-sets sets basic,  Next: char-sets sets ascii,  Prev: char-sets sets how,  Up: char-sets sets

26.6.3 Basic character sets
---------------------------

The following character sets are defined and exported by the '(vicare
containers char-sets)' library.

 -- Character Set: char-set:full
     Contains all the characters recognised by the R6RS standard.

 -- Character Set: char-set:empty
     The empty set.


File: vicare-libs.info,  Node: char-sets sets ascii,  Next: char-sets sets blocks,  Prev: char-sets sets basic,  Up: char-sets sets

26.6.4 Sets of ASCII characters
-------------------------------

The following character sets are defined and exported by the '(vicare
containers char-sets)' library.

 -- Character Set: char-set:ascii
     All the characters in the ASCII set.  It is the set of all the
     characters whose numeric code is between 0 and 127, both included.

 -- Character Set: char-set:ascii/lower-case
     All the lower-case letters between '#\a' and '#\z', included.

 -- Character Set: char-set:ascii/upper-case
     All the upper-case letters between '#\A' and '#\Z', included.

 -- Character Set: char-set:ascii/letter
     All the letters: It is the union of 'char-set:ascii/lower-case' and
     'char-set:ascii/upper-case'.

 -- Character Set: char-set:ascii/digit
 -- Character Set: char-set:ascii/dec-digit
     All the decimal digits:

          #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9

 -- Character Set: char-set:ascii/oct-digit
     All the octal digits:

          #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7

 -- Character Set: char-set:ascii/hex-digit
     All the hexadecimal digits:

          #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
          #\a #\b #\c #\d #\e #\f
          #\A #\B #\C #\D #\E #\F

 -- Character Set: char-set:ascii/letter+digit
     All the letters and decimal digits: It is the union of
     'char-set:ascii/letter' and 'char-set:ascii/dec-digit'.

 -- Character Set: char-set:ascii/punctuation
     All the punctuation characters whose numeric code is in the range
     [0, 127]:

          #\!  #\"  #\#  #\%  #\&  #\'  #\(  #\)  #\*  #\,  #\-  #\.

          #\/  #\:  #\;  #\?  #\@  #\[  #\\  #\]  #\_  #\{  #\}

 -- Character Set: char-set:ascii/symbol
     All the symbol characters whose numeric code is in the range [0,
     127]:

          #\$  #\+  #\<  #\=  #\>  #\^  #\`  #\|  #\~

 -- Character Set: char-set:ascii/whitespace
     All the characters representing white space:

          #x0009  #\tab       ; HORIZONTAL TABULATION
          #x000A  #\linefeed  ; LINE FEED
          #x000B  #\vtab      ; VERTICAL TABULATION
          #x000C  #\page      ; FORM FEED
          #x000D  #\return    ; CARRIAGE RETURN
          #x0020  #\space     ; SPACE

 -- Character Set: char-set:ascii/blank
     A set holding '#\tab' and '#\space'.

 -- Character Set: char-set:ascii/graphic
     The set of all characters that put ink on the page.  It is the
     union of 'char-set:ascii/letter+digit',
     'char-set:ascii/punctuation' and 'char-set:ascii/symbol'.

 -- Character Set: char-set:ascii/printable
     The set of all the printable characters.  It is the union of
     'char-set:ascii/whitespace' and 'char-set:ascii/graphic'.

 -- Character Set: char-set:ascii/control
     All the characters whose numeric code is in the range [0, 31] plus
     127.

 -- Character Set: char-set:ascii/vowels
 -- Character Set: char-set:ascii/consonants
 -- Character Set: char-set:ascii/vowels/lower-case
 -- Character Set: char-set:ascii/consonants/lower-case
 -- Character Set: char-set:ascii/vowels/upper-case
 -- Character Set: char-set:ascii/consonants/upper-case
     Sets of vowels and consonants.  Notice that lower case vowels are:
     '#\a', '#\e', '#\i', '#\o', '#\u'.


File: vicare-libs.info,  Node: char-sets sets blocks,  Next: char-sets sets categories,  Prev: char-sets sets ascii,  Up: char-sets sets

26.6.5 Sets corresponding to Unicode blocks
-------------------------------------------

The following character sets are defined and exported by the '(vicare
containers char-sets blocks)' library.

 -- Character Set: char-set:block/basic-latin
 -- Character Set: char-set:block/latin-1-supplement
 -- Character Set: char-set:block/latin-extended-a
 -- Character Set: char-set:block/latin-extended-b
 -- Character Set: char-set:block/ipa-extensions
 -- Character Set: char-set:block/spacing-modifier-letters
 -- Character Set: char-set:block/combining-diacritical-marks
 -- Character Set: char-set:block/greek-and-coptic
 -- Character Set: char-set:block/cyrillic
 -- Character Set: char-set:block/cyrillic-supplement
 -- Character Set: char-set:block/armenian
 -- Character Set: char-set:block/hebrew
 -- Character Set: char-set:block/arabic
 -- Character Set: char-set:block/syriac
 -- Character Set: char-set:block/arabic-supplement
 -- Character Set: char-set:block/thaana
 -- Character Set: char-set:block/nko
 -- Character Set: char-set:block/devanagari
 -- Character Set: char-set:block/bengali
 -- Character Set: char-set:block/gurmukhi
 -- Character Set: char-set:block/gujarati
 -- Character Set: char-set:block/oriya
 -- Character Set: char-set:block/tamil
 -- Character Set: char-set:block/telugu
 -- Character Set: char-set:block/kannada
 -- Character Set: char-set:block/malayalam
 -- Character Set: char-set:block/sinhala
 -- Character Set: char-set:block/thai
 -- Character Set: char-set:block/lao
 -- Character Set: char-set:block/tibetan
 -- Character Set: char-set:block/myanmar
 -- Character Set: char-set:block/georgian
 -- Character Set: char-set:block/hangul-jamo
 -- Character Set: char-set:block/ethiopic
 -- Character Set: char-set:block/ethiopic-supplement
 -- Character Set: char-set:block/cherokee
 -- Character Set: char-set:block/unified-canadian-aboriginal-syllabics
 -- Character Set: char-set:block/ogham
 -- Character Set: char-set:block/runic
 -- Character Set: char-set:block/tagalog
 -- Character Set: char-set:block/hanunoo
 -- Character Set: char-set:block/buhid
 -- Character Set: char-set:block/tagbanwa
 -- Character Set: char-set:block/khmer
 -- Character Set: char-set:block/mongolian
 -- Character Set: char-set:block/limbu
 -- Character Set: char-set:block/tai-le
 -- Character Set: char-set:block/new-tai-lue
 -- Character Set: char-set:block/khmer-symbols
 -- Character Set: char-set:block/buginese
 -- Character Set: char-set:block/balinese
 -- Character Set: char-set:block/sundanese
 -- Character Set: char-set:block/lepcha
 -- Character Set: char-set:block/ol-chiki
 -- Character Set: char-set:block/phonetic-extensions
 -- Character Set: char-set:block/phonetic-extensions-supplement
 -- Character Set: char-set:block/combining-diacritical-marks-supplement
 -- Character Set: char-set:block/latin-extended-additional
 -- Character Set: char-set:block/greek-extended
 -- Character Set: char-set:block/general-punctuation
 -- Character Set: char-set:block/superscripts-and-subscripts
 -- Character Set: char-set:block/currency-symbols
 -- Character Set: char-set:block/combining-diacritical-mark-for-symbols
 -- Character Set: char-set:block/letterlike-symbols
 -- Character Set: char-set:block/number-forms
 -- Character Set: char-set:block/arrows
 -- Character Set: char-set:block/mathematical-operators
 -- Character Set: char-set:block/miscellaneous-technical
 -- Character Set: char-set:block/control-pictures
 -- Character Set: char-set:block/optical-character-recognition
 -- Character Set: char-set:block/enclosed-alphanumerics
 -- Character Set: char-set:block/box-drawing
 -- Character Set: char-set:block/block-elements
 -- Character Set: char-set:block/geometric-shapes
 -- Character Set: char-set:block/miscellaneous-symbols
 -- Character Set: char-set:block/dingbats
 -- Character Set: char-set:block/miscellaneous-mathematical-symbols-a
 -- Character Set: char-set:block/supplemental-arrows-a
 -- Character Set: char-set:block/braille-patterns
 -- Character Set: char-set:block/supplemental-arrows-b
 -- Character Set: char-set:block/miscellaneous-mathematical-symbols-b
 -- Character Set: char-set:block/supplemental-mathematical-operators
 -- Character Set: char-set:block/miscellaneous-symbols-and-arrows
 -- Character Set: char-set:block/glagolitic
 -- Character Set: char-set:block/latin-extended-c
 -- Character Set: char-set:block/coptic
 -- Character Set: char-set:block/georgian-supplement
 -- Character Set: char-set:block/tifinagh
 -- Character Set: char-set:block/ethiopic-extended
 -- Character Set: char-set:block/cyrillic-extended-a
 -- Character Set: char-set:block/supplemental-punctuation
 -- Character Set: char-set:block/cjk-radicals-supplement
 -- Character Set: char-set:block/kangxi-radicals
 -- Character Set: char-set:block/ideographic-description-characters
 -- Character Set: char-set:block/cjk-symbols-and-punctuation
 -- Character Set: char-set:block/hiragana
 -- Character Set: char-set:block/katakana
 -- Character Set: char-set:block/bopomofo
 -- Character Set: char-set:block/hangul-compatibility-jamo
 -- Character Set: char-set:block/kanbun
 -- Character Set: char-set:block/bopomofo-extended
 -- Character Set: char-set:block/cjk-strokes
 -- Character Set: char-set:block/katakana-phonetic-extensions
 -- Character Set: char-set:block/enclosed-cjk-letters-and-months
 -- Character Set: char-set:block/cjk-compatibility
 -- Character Set: char-set:block/cjk-unified-Ideographs-extension-a
 -- Character Set: char-set:block/yijing-hexagram-symbols
 -- Character Set: char-set:block/cjk-unified-ideographs
 -- Character Set: char-set:block/yi-syllables
 -- Character Set: char-set:block/yi-radicals
 -- Character Set: char-set:block/vai
 -- Character Set: char-set:block/cyrillic-extended-b
 -- Character Set: char-set:block/modifier-tone-letters
 -- Character Set: char-set:block/latin-extended-d
 -- Character Set: char-set:block/syloti-nagri
 -- Character Set: char-set:block/phags-pa
 -- Character Set: char-set:block/saurashtra
 -- Character Set: char-set:block/kayah-li
 -- Character Set: char-set:block/Rejang
 -- Character Set: char-set:block/cham
 -- Character Set: char-set:block/hangul-syllables
 -- Character Set: char-set:block/private-use-area
 -- Character Set: char-set:block/cjk-compatibility-ideographs
 -- Character Set: char-set:block/alphabetic-presentation-forms
 -- Character Set: char-set:block/arabic-presentation-forms-a
 -- Character Set: char-set:block/variation-selectors
 -- Character Set: char-set:block/vertical-forms
 -- Character Set: char-set:block/combining-half-marks
 -- Character Set: char-set:block/cjk-compatibility-forms
 -- Character Set: char-set:block/small-form-variants
 -- Character Set: char-set:block/arabic-presentation-forms-b
 -- Character Set: char-set:block/halfwidth-and-fullwidth-forms
 -- Character Set: char-set:block/specials
 -- Character Set: char-set:block/linear-b-syllabary
 -- Character Set: char-set:block/linear-b-ideograms
 -- Character Set: char-set:block/aegean-numbers
 -- Character Set: char-set:block/ancient-greek-numbers
 -- Character Set: char-set:block/ancient-symbols
 -- Character Set: char-set:block/phaistos-disc
 -- Character Set: char-set:block/lycian
 -- Character Set: char-set:block/carian
 -- Character Set: char-set:block/old-italic
 -- Character Set: char-set:block/gothic
 -- Character Set: char-set:block/ugaritic
 -- Character Set: char-set:block/old-persian
 -- Character Set: char-set:block/deseret
 -- Character Set: char-set:block/shavian
 -- Character Set: char-set:block/osmanya
 -- Character Set: char-set:block/cypriot-syllabary
 -- Character Set: char-set:block/phoenician
 -- Character Set: char-set:block/lydian
 -- Character Set: char-set:block/kharoshthi
 -- Character Set: char-set:block/cuneiform
 -- Character Set: char-set:block/cuneiform-numbers-and-punctuation
 -- Character Set: char-set:block/byzantine-musical-symbols
 -- Character Set: char-set:block/musical-symbols
 -- Character Set: char-set:block/ancient-greek-musical-notation
 -- Character Set: char-set:block/tai-xuan-jing-symbols
 -- Character Set: char-set:block/counting-rod-numerals
 -- Character Set: char-set:block/mathematical-alphanumeric-symbols
 -- Character Set: char-set:block/mahjong-tiles
 -- Character Set: char-set:block/domino-tiles
 -- Character Set: char-set:block/cjk-unified-ideographs-extension-b
 -- Character Set:
          char-set:block/cjk-compatibility-ideographs-supplement
 -- Character Set: char-set:block/tags
 -- Character Set: char-set:block/variation-selectors-supplement
 -- Character Set: char-set:block/supplementary-private-use-area-a
 -- Character Set: char-set:block/supplementary-private-use-area-b
     These are the character sets corresponding to the ranges defined in
     the 'Blocks.txt' file of the Unicode Character Database.


File: vicare-libs.info,  Node: char-sets sets categories,  Prev: char-sets sets blocks,  Up: char-sets sets

26.6.6 Sets corresponding to Unicode general categories
-------------------------------------------------------

The following character sets are defined and exported by the '(vicare
containers char-sets categories)' library.

   Notice that not all the code points accepted by 'char=?' are part of
a general category, so the union of the category sets is different from
the full character set 'char-set:full'.

   Categories are disjoint, so the intersection of the category sets is
the empty set.

 -- Character Set: char-set:category/letter-uppercase
 -- Character Set: char-set:category/letter-lowercase
 -- Character Set: char-set:category/letter-titlecase
 -- Character Set: char-set:category/letter-modifier
 -- Character Set: char-set:category/letter-other
 -- Character Set: char-set:category/mark-nospacing
 -- Character Set: char-set:category/mark-spacing-combining
 -- Character Set: char-set:category/mark-enclosing
 -- Character Set: char-set:category/number-decimal-digit
 -- Character Set: char-set:category/number-letter
 -- Character Set: char-set:category/number-other
 -- Character Set: char-set:category/puncutation-connector
 -- Character Set: char-set:category/punctuation-dash
 -- Character Set: char-set:category/punctuation-open
 -- Character Set: char-set:category/punctuation-close
 -- Character Set: char-set:category/punctuation-initial-quote
 -- Character Set: char-set:category/punctuation-final-quote
 -- Character Set: char-set:category/punctuation-other
 -- Character Set: char-set:category/symbol-math
 -- Character Set: char-set:category/symbol-currency
 -- Character Set: char-set:category/symbol-modifier
 -- Character Set: char-set:category/symbol-other
 -- Character Set: char-set:category/separator-space
 -- Character Set: char-set:category/separator-line
 -- Character Set: char-set:category/separator-paragraph
 -- Character Set: char-set:category/control
 -- Character Set: char-set:category/format
 -- Character Set: char-set:category/surrogate
 -- Character Set: char-set:category/private-use
 -- Character Set: char-set:category/not-assigned
     One set for each general category defined by the Unicode Standard.


File: vicare-libs.info,  Node: bytevectors,  Next: bytevector compounds,  Prev: char-sets,  Up: Top

27 Bytevectors
**************

* Menu:

* bytevectors utils::           Additional bytevector utilities.
* bytevectors 8::               Bytevectors of signed and
                                unsigned bytes.


File: vicare-libs.info,  Node: bytevectors utils,  Next: bytevectors 8,  Up: bytevectors

27.1 Additional bytevector utilities
====================================

The library '(vicare containers bytevectors)' exports bindings for
additional bytevector handling utilities.

* Menu:

* bytevectors utils setget::    Single-identifier setters and getters.
* bytevectors utils scaled::    Scaled setters and getters.


File: vicare-libs.info,  Node: bytevectors utils setget,  Next: bytevectors utils scaled,  Up: bytevectors utils

27.1.1 Single-identifier setters and getters
--------------------------------------------

The following syntaxes are wrappers for 'bytevector-*-ref' and
'bytevector-*-set!' specifying the endiannes in their name, without the
need of an additional argument (useful in macros).  The following
bindings are exported by the library '(vicare containers bytevectors)'.

Words of 8-bit
..............

The 8-bit setters and getters exist with the only purpose of having
8-bit identifiers with the same naming scheme of the others; this is
useful when building identifiers in macros.

 -- Syntax: bytevector-u8-litend-set! BV IDX VAL
     Setter for unsigned 8-bit words.  An alias for
     'bytevector-u8-set!'.

 -- Syntax: bytevector-u8-bigend-set! BV IDX VAL
     Setter for unsigned 8-bit words.  An alias for
     'bytevector-u8-set!'.

 -- Syntax: bytevector-u8-litend-ref BV IDX VAL
     Getter for unsigned 8-bit words.  An alias for 'bytevector-u8-ref'.

 -- Syntax: bytevector-u8-bigend-ref BV IDX VAL
     Getter for unsigned 8-bit words.  An alias for 'bytevector-u8-ref'.

 -- Syntax: bytevector-s8-litend-set! BV IDX VAL
     Setter for signed 8-bit words.  An alias for 'bytevector-s8-set!'.

 -- Syntax: bytevector-s8-bigend-set! BV IDX VAL
     Setter for signed 8-bit words.  An alias for 'bytevector-s8-set!'.

 -- Syntax: bytevector-s8-litend-ref BV IDX VAL
     Getter for signed 8-bit words.  An alias for 'bytevector-s8-ref'.

 -- Syntax: bytevector-s8-bigend-ref BV IDX VAL
     Getter for signed 8-bit words.  An alias for 'bytevector-s8-ref'.

Words of 16-bit
...............

 -- Syntax: bytevector-u16-litend-set! BV IDX VAL
     Setter for unsigned 16-bit little-endian words.

 -- Syntax: bytevector-u16-bigend-set! BV IDX VAL
     Setter for unsigned 16-bit big-endian words.

 -- Syntax: bytevector-u16-litend-ref BV IDX VAL
     Getter for unsigned 16-bit little-endian words.

 -- Syntax: bytevector-u16-bigend-ref BV IDX VAL
     Getter for unsigned 16-bit big-endian words.

 -- Syntax: bytevector-s16-litend-set! BV IDX VAL
     Setter for signed 16-bit little-endian words.

 -- Syntax: bytevector-s16-bigend-set! BV IDX VAL
     Setter for signed 16-bit big-endian words.

 -- Syntax: bytevector-s16-litend-ref BV IDX VAL
     Getter for signed 16-bit little-endian words.

 -- Syntax: bytevector-s16-bigend-ref BV IDX VAL
     Getter for signed 16-bit big-endian words.

Words of 32-bit
...............

 -- Syntax: bytevector-u32-litend-set! BV IDX VAL
     Setter for unsigned 32-bit little-endian words.

 -- Syntax: bytevector-u32-bigend-set! BV IDX VAL
     Setter for unsigned 32-bit big-endian words.

 -- Syntax: bytevector-u32-litend-ref BV IDX VAL
     Getter for unsigned 32-bit little-endian words.

 -- Syntax: bytevector-u32-bigend-ref BV IDX VAL
     Getter for unsigned 32-bit big-endian words.

 -- Syntax: bytevector-s32-litend-set! BV IDX VAL
     Setter for signed 32-bit little-endian words.

 -- Syntax: bytevector-s32-bigend-set! BV IDX VAL
     Setter for signed 32-bit big-endian words.

 -- Syntax: bytevector-s32-litend-ref BV IDX VAL
     Getter for signed 32-bit little-endian words.

 -- Syntax: bytevector-s32-bigend-ref BV IDX VAL
     Getter for signed 32-bit big-endian words.

Words of 64-bit
...............

 -- Syntax: bytevector-u64-litend-set! BV IDX VAL
     Setter for unsigned 64-bit little-endian words.

 -- Syntax: bytevector-u64-bigend-set! BV IDX VAL
     Setter for unsigned 64-bit big-endian words.

 -- Syntax: bytevector-u64-litend-ref BV IDX VAL
     Getter for unsigned 64-bit little-endian words.

 -- Syntax: bytevector-u64-bigend-ref BV IDX VAL
     Getter for unsigned 64-bit big-endian words.

 -- Syntax: bytevector-s64-litend-set! BV IDX VAL
     Setter for signed 64-bit little-endian words.

 -- Syntax: bytevector-s64-bigend-set! BV IDX VAL
     Setter for signed 64-bit big-endian words.

 -- Syntax: bytevector-s64-litend-ref BV IDX VAL
     Getter for signed 64-bit little-endian words.

 -- Syntax: bytevector-s64-bigend-ref BV IDX VAL
     Getter for signed 64-bit big-endian words.

Single-precision floating-point numbers
.......................................

 -- Syntax: bytevector-ieee-single-litend-set! BV IDX VAL
     Setter for single-precision floating-point little-endian words.

 -- Syntax: bytevector-ieee-single-bigend-set! BV IDX VAL
     Setter for single-precision floating-point big-endian words.

 -- Syntax: bytevector-ieee-single-litend-ref BV IDX VAL
     Getter for single-precision floating-point little-endian words.

 -- Syntax: bytevector-ieee-single-bigend-ref BV IDX VAL
     Getter for single-precision floating-point big-endian words.

Double precision floating-point numbers
.......................................

 -- Syntax: bytevector-ieee-double-litend-set! BV IDX VAL
     Setter for double-precision floating-point little-endian words.

 -- Syntax: bytevector-ieee-double-bigend-set! BV IDX VAL
     Setter for double-precision floating-point big-endian words.

 -- Syntax: bytevector-ieee-double-litend-ref BV IDX VAL
     Getter for double-precision floating-point little-endian words.

 -- Syntax: bytevector-ieee-double-bigend-ref BV IDX VAL
     Getter for double-precision floating-point big-endian words.


File: vicare-libs.info,  Node: bytevectors utils scaled,  Prev: bytevectors utils setget,  Up: bytevectors utils

27.1.2 Scaled setters and getters
---------------------------------

The following syntaxes are wrappers for 'bytevector-*-ref' and
'bytevector-*-set!' specifying the endiannes in their name, without the
need of an additional argument (useful in macros), and scaling the index
with the size of the word.  The following bindings are exported by the
library '(vicare containers bytevectors)'.

Unsigned words of 8-bit
.......................

The 8-bit setters and getters exist with the only purpose of having
8-bit identifiers with the same naming scheme of the others; this is
useful when building identifiers in macros.

 -- Syntax: bytevector-u8-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u8-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u8-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-u8-litend-scaled-ref BV IDX
 -- Syntax: bytevector-u8-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-u8-native-scaled-ref BV IDX
     Scaled getters.

Signed words of 8-bit
.....................

The 8-bit setters and getters exist with the only purpose of having
8-bit identifiers with the same naming scheme of the others; this is
useful when building identifiers in macros.

 -- Syntax: bytevector-s8-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s8-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s8-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-s8-litend-scaled-ref BV IDX
 -- Syntax: bytevector-s8-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-s8-native-scaled-ref BV IDX
     Scaled getters.

Unsigned words of 16-bit
........................

 -- Syntax: bytevector-u16-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u16-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u16-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-u16-litend-scaled-ref BV IDX
 -- Syntax: bytevector-u16-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-u16-native-scaled-ref BV IDX
     Scaled getters.

Signed words of 16-bit
......................

 -- Syntax: bytevector-s16-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s16-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s16-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-s16-litend-scaled-ref BV IDX
 -- Syntax: bytevector-s16-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-s16-native-scaled-ref BV IDX
     Scaled getters.

Unsigned words of 32-bit
........................

 -- Syntax: bytevector-u32-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u32-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u32-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-u32-litend-scaled-ref BV IDX
 -- Syntax: bytevector-u32-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-u32-native-scaled-ref BV IDX
     Scaled getters.

Signed words of 32-bit
......................

 -- Syntax: bytevector-s32-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s32-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s32-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-s32-litend-scaled-ref BV IDX
 -- Syntax: bytevector-s32-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-s32-native-scaled-ref BV IDX
     Scaled getters.

Unsigned words of 64-bit
........................

 -- Syntax: bytevector-u64-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u64-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-u64-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-u64-litend-scaled-ref BV IDX
 -- Syntax: bytevector-u64-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-u64-native-scaled-ref BV IDX
     Scaled getters.

Signed words of 64-bit
......................

 -- Syntax: bytevector-s64-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s64-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-s64-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-s64-litend-scaled-ref BV IDX
 -- Syntax: bytevector-s64-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-s64-native-scaled-ref BV IDX
     Scaled getters.

Single-precision floating-point words
.....................................

 -- Syntax: bytevector-ieee-single-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-ieee-single-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-ieee-single-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-ieee-single-litend-scaled-ref BV IDX
 -- Syntax: bytevector-ieee-single-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-ieee-single-native-scaled-ref BV IDX
     Scaled getters.

Double-precision floating-point words
.....................................

 -- Syntax: bytevector-ieee-double-litend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-ieee-double-bigend-scaled-set! BV IDX VAL
 -- Syntax: bytevector-ieee-double-native-scaled-set! BV IDX VAL
     Scaled setters.

 -- Syntax: bytevector-ieee-double-litend-scaled-ref BV IDX
 -- Syntax: bytevector-ieee-double-bigend-scaled-ref BV IDX
 -- Syntax: bytevector-ieee-double-native-scaled-ref BV IDX
     Scaled getters.


File: vicare-libs.info,  Node: bytevectors 8,  Prev: bytevectors utils,  Up: bytevectors

27.2 Bytevectors of signed and unsigned bytes
=============================================

The libraries '(vicare containers bytevectors s8)', '(vicare containers
bytevectors u8)', '(vicare containers bytevectors s8low)' and '(vicare
containers bytevectors u8low)' extend the bytevector operations
available in the base library; *note Bytevectors: (vicare-scheme)stdlib
bytevector.

   While '(vicare containers bytevectors s8)' and '(vicare containers
bytevectors u8)' are high level interfaces, '(vicare containers
bytevectors s8low)' and '(vicare containers bytevectors u8low)' are low
level interfaces with the same functionalities; there is special support
for bytevectors representing strings in ASCII encoding.

   To avoid identifiers collision: it is suggested to import these
libraries with the prefix 'bv.', as in:

     (import (vicare)
       (prefix (vicare containers bytevectors u8) bv.))

* Menu:

* bytevectors 8 intro::         Introduction.
* bytevectors 8 convention::    Interface conventions.
* bytevectors 8 views::         Views over bytevectors.
* bytevectors 8 cons::          Constructors.
* bytevectors 8 pred::          Predicates.
* bytevectors 8 compar::        Comparison.
* bytevectors 8 map::           Mapping functions.
* bytevectors 8 case::          Case mapping.
* bytevectors 8 fold::          Fold and unfold.
* bytevectors 8 select::        Selection.
* bytevectors 8 pad::           Padding and trimming.
* bytevectors 8 prefix::        Prefixes and suffixes.
* bytevectors 8 search::        Searching.
* bytevectors 8 filter::        Filtering and deleting.
* bytevectors 8 list::          List and bytevector conversion.
* bytevectors 8 replicate::     Replicate and rotate.
* bytevectors 8 mutate::        Mutators.
* bytevectors 8 misc::          Miscellaneous functions.


File: vicare-libs.info,  Node: bytevectors 8 intro,  Next: bytevectors 8 convention,  Up: bytevectors 8

27.2.1 Introduction
-------------------

Library organisation
....................

The functions are split in a high level library, '(vicare containers
bytevectors s8)' and '(vicare containers bytevectors u8)', and a low
level one, '(vicare containers bytevectors s8low)' and '(vicare
containers bytevectors u8low)'.  The main difference between the two
layers is that the high level library makes heavy usage of macros to
implement the "bytevector views", which allow accessing subvectors using
a friendly syntax.

   All the functions in the low level library are bound to identifiers
starting with '%'; for example: 'bytevector-u8-prefix?' is a high level
macro, '%bytevector-u8-prefix?' is its low level function homologous.

Direction of iteration
......................

The library accesses the bytes of a vector in left-to-right or
right-to-left order depending on the convenience of the algorithm.

Handling side effects
.....................

Care must be taken when using functions with side effects.  One reason
for this is that some of the supported Scheme implementations may
collapse equal datum bytevectors in the source code to the same
bytevector in the program.  Mutating such a bytevector in a point of the
program, will make the change visible to other points in the program.


File: vicare-libs.info,  Node: bytevectors 8 convention,  Next: bytevectors 8 views,  Prev: bytevectors 8 intro,  Up: bytevectors 8

27.2.2 Interface conventions
----------------------------

The following conventions hold:

   * Procedures whose names end in '-ci' are case-insensitive variants;
     they interpret bytevectors as strings of characters in ASCII
     encoding: when doing comparisons they use 'char-ci=?' and
     'char-ci<?' and the like.

   * Procedures whose names end in '!' are side-effecting variants.
     What values these procedures return is usually not specified.

   * The order of common arguments is consistent across the different
     procedures in the high level library, and consistent across the
     different procedures in the low level library.  Arguments to some
     functions in the high level library have different order from the
     ones of the homologous low level functions.

   * Procedures that have left/right directional variants use the
     following convention:

     Direction       Suffix
     -------------------------
     left-to-right   ?NONE
     right-to-left   -right
     both            -both

   In the procedure specifications:

   * A B argument is a bytevector view, which is expanded by a macro in
     a triplet of values: the bytevector, the index of the first byte in
     the selected subvector, the index of the byte past the last in the
     selected position; *note bytevectors 8 views:: for details.

   * A BV argument is a bytevector.

   * A BYTE argument is an exact integer representing an unsigned byte,
     that is in the range [0, 256).

   * A CHAR argument is a character.

   * The START and PAST arguments are half-open bytevector indices
     specifying a subvector within a bytevector argument; when
     unspecified, they default to zero and the length of the bytevector,
     respectively.  When specified, it must be the case that:

          0 <= start <= past <= (bytevector-length bv)

     for the corresponding argument BV.  They typically restrict a
     procedure's action to the indicated subvector; when START equals
     PAST the selected subvector is the empty bytevector.

   * A PRED argument is a unary predicate procedure, returning a
     true/false value when applied to an exact integer representing a
     byte.

   * A CRITERION orn BYTE/CHAR/CHAR-SET/PRED argument is a value used to
     select/search for a byte in a bytevector:

        - If it is a byte, it is used in an equality test with '='.

        - If it is a character, it is used in an equality test with '='
          after having been converted to an exact integer with
          'char->integer'.

        - If it is a character set, it is used in a membership test
          after the byte has been converted to a character with
          'integer->char'.

        - If it is a procedure, it is applied to the bytes as a test
          predicate.

   * An I or K argument is an exact non-negative integer specifying an
     index into a bytevector.

   * The LEN and NBYTES arguments are exact non-negative integers
     specifying a length of a bytevector or some number of bytes.

   * An OBJ argument can be any value.

   An argument followed by '...' means zero-or-more elements.  So the
procedure with the signature:

     sum-squares x ...

takes zero or more arguments (X, ...), while the procedure with
signature:

     spell-check doc dict1 dict2 ...

takes two mandatory arguments (DOC and DICT1) and zero or more optional
arguments (DICT2 ...).

   If a procedure is said to return "unspecified", this means that
nothing at all is known about what the procedure returns; such a
procedure is not even required to be consistent from call to call; it is
simply required to return a value (or values) that may be passed to a
command continuation, e.g.  as the value of an expression appearing as a
non-terminal subform of a begin expression.

   Unless explicitly stated: comparison is simply done on individual
bytes of the bytevector, case-insensitive comparison is done converting
the bytes to characters with 'integer->char' and then using the
functions:

     char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?

provided by the underlying implementation, or by case-folding characters
with the operation:

     (char-downcase (char-upcase (integer->char byte)))

where the two case-mapping operations are assumed to work for characters
in the range allowed by ASCII encoding.


File: vicare-libs.info,  Node: bytevectors 8 views,  Next: bytevectors 8 cons,  Prev: bytevectors 8 convention,  Up: bytevectors 8

27.2.3 Views over bytevectors
-----------------------------

Bytevector views are syntactic sugar to allow subvector specification
with minimum overhead; views make use of auxiliary syntaxes exported by
the '(vicare containers auxiliary-syntaxes)' library and reexported by
the '(vicare containers bytevectors u8)' library.  Many low level
bytevector functions act on subvectors specified with triplets of
arguments:

   * The full bytevector.

   * The "start index": the index of the first byte included in the
     selected subvector.

   * The "past index": the index of the byte past the last byte included
     in the selected subvector.

   To select the subvector '#vu8(6 7 8 9)' from the bytevector '#vu8(0 1
2 3 4 5 6 7 8 9)' we have to determine the half-open range of bytes,
which is [6, 10), then apply a function to the arguments:

     (%the-function '#vu8(0 1 2 3 4 5 6 7 8 9) 6 10)

while to select the whole bytevector we can do:

     (%the-function '#vu8(0 1 2 3 4 5 6 7 8 9) 0 10)

or:

     (let ((bv '#vu8(0 1 2 3 4 5 6 7 8 9)))
       (%the-function bv 0 (bytevector-length bv)))

   With the bytevector views implemented by '(vicare containers
bytevectors u8)', the low level function is wrapped by a high level
syntax which can be invoked as:

     (the-function '#vu8(0 1 2 3 4 5 6 7 8 9))
             ; select the whole bytevector

     (the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)))
             ; select the whole bytevector

     (the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)
                     (start 6)))
             ; select the subvector [6, 10)

     (the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)
                     (start  6)
                     (past  11)))
             ; select the subvector [6, 10)

     (the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)
                     (past 10)))
             ; select the subvector [0, 10)

instead of a triplet of arguments, the bytevector view is a single
argument that can be:

'?BYTEVECTOR'
'(view ?BYTEVECTOR)'
     The bytevector itself or an unquoted list holding the bytevector
     itself, prefixed by the 'view' auxiliary syntax: it selects the
     whole bytevector.

'(view ?BYTEVECTOR (start ?START-INDEX))'
     An unquoted list holding the bytevector and the start index, with
     auxiliary syntaxes 'view' and 'start': it selects the subvector
     from the start index to the end.

'(view ?BYTEVECTOR (past ?PAST-INDEX))'
     An unquoted list holding the bytevector and the past index, with
     auxiliary syntaxes 'view' and 'past': it selects the subvector from
     zero to the selected past index.

'(view ?BYTEVECTOR (start ?START-INDEX) (past ?PAST-INDEX))'
     An unquoted list holding the bytevector, the start index and the
     past index, with auxiliary syntaxes 'view', 'start' and 'past': it
     selects the subvector between the start and past indexes.

?BYTEVECTOR, ?START-INDEX and ?PAST-INDEX can be arbitrary Scheme
expressions.  High level macros accepting two or more subvectors as
arguments, support bytevector views for all of them.  When we are
concerned with the overhead of bytevector views, we can use the low
level functions directly.

   In the following documentation: low level functions and high level
macros are documented together; only the meaning of arguments to the low
level function are described, the meaning of high level arguments is
obvious.


File: vicare-libs.info,  Node: bytevectors 8 cons,  Next: bytevectors 8 pred,  Prev: bytevectors 8 views,  Up: bytevectors 8

27.2.4 Constructors
-------------------

 -- Function: bytevector-s8-append BV0 BV ...
 -- Function: bytevector-u8-append BV0 BV ...
     Return a newly allocated bytevector whose bytes form the
     concatenation of the given bytevectors.

 -- Function: bytevector-u8-concatenate BVS-LIST
 -- Function: bytevector-s8-concatenate BVS-LIST
     Append the elements of BVS-LIST together into a single bytevector.
     Guaranteed to return a freshly allocated bytevector.

 -- Function: %bytevector-s8-concatenate-reverse BVS-LIST FINAL-BV
          NBYTES
 -- Function: %bytevector-u8-concatenate-reverse BVS-LIST FINAL-BV
          NBYTES
 -- Macro: bytevector-s8-concatenate-reverse BVS-LIST
 -- Macro: bytevector-u8-concatenate-reverse BVS-LIST
 -- Macro: bytevector-s8-concatenate-reverse BVS-LIST FINAL-BV
 -- Macro: bytevector-u8-concatenate-reverse BVS-LIST FINAL-BV
 -- Macro: bytevector-s8-concatenate-reverse BVS-LIST FINAL-BV NBYTES
 -- Macro: bytevector-u8-concatenate-reverse BVS-LIST FINAL-BV NBYTES
     Reverse BVS-LIST then concatenate the elements, which must be
     bytevectors.  The first NBYTES bytes in FINAL-BV are consed onto
     the beginning of BVS-LIST before performing the reversal and
     concatenation operations.

     FINAL-BV defaults to the empty bytevector and NBYTES defaults to
     the length of FINAL-BV.

     This procedure is useful in the construction of procedures that
     accumulate byte data into lists of byte buffers, and wish to
     convert the accumulated data into a single bytevector when done.

 -- Function: bytevector-s8-tabulate INTEGER->BYTE LEN
 -- Function: bytevector-u8-tabulate INTEGER->BYTE LEN
     Construct a bytevector of size LEN by applying INTEGER->BYTE to
     each index in the range [0, LEN) to produce the corresponding byte
     element.  The order in which INTEGER->BYTE is applied to the
     indices is not specified.


File: vicare-libs.info,  Node: bytevectors 8 pred,  Next: bytevectors 8 compar,  Prev: bytevectors 8 cons,  Up: bytevectors 8

27.2.5 Predicates
-----------------

 -- Function: bytevector-u8-null? OBJ
     Return '#t' if OBJ is the empty bytevector, otherwise return '#f'.

 -- Function: %bytevector-s8-every BYTE/CHAR/CHAR-SET/PRED BV START PAST
 -- Function: %bytevector-u8-every BYTE/CHAR/CHAR-SET/PRED BV START PAST
 -- Function: %bytevector-s8-any BYTE/CHAR/CHAR-SET/PRED BV START PAST
 -- Function: %bytevector-u8-any BYTE/CHAR/CHAR-SET/PRED BV START PAST
 -- Macro: bytevector-s8-every BYTE/CHAR/CHAR-SET/PRED B
 -- Macro: bytevector-u8-every BYTE/CHAR/CHAR-SET/PRED B
 -- Macro: bytevector-s8-any BYTE/CHAR/CHAR-SET/PRED B
 -- Macro: bytevector-u8-any BYTE/CHAR/CHAR-SET/PRED B
     Check to see if the given criteria is true on every/any byte in BV,
     proceeding from left (index START) to right (index PAST).

     If the selected subvector is empty: the return value is '#f'.

     If BYTE/CHAR/CHAR-SET/PRED is a byte, it is tested for equality
     with the elements of B.

     If BYTE/CHAR/CHAR-SET/PRED is a character, it is tested for
     equality with the elements of B.

     If BYTE/CHAR/CHAR-SET/PRED is a character set, the elements of B
     are tested for membership in the set.

     If BYTE/CHAR/CHAR-SET/PRED is a predicate procedure, it is applied
     to the elements of B.  The predicate is "witness-generating":

        * If 'bytevector-u8-any' returns true, the returned true value
          is the one produced by the application of the predicate.

        * If 'bytevector-u8-every' returns true, the returned true value
          is the one produced by the application of the predicate to the
          last byte in the subvector.

     If the predicate is applied to the final element of the selected
     subvector, that final application is a tail call.

     The names of these procedures do not end with a question mark; this
     is to indicate that, in the predicate case, they do not return a
     simple boolean ('#t' or '#f'), but a general value.


File: vicare-libs.info,  Node: bytevectors 8 compar,  Next: bytevectors 8 map,  Prev: bytevectors 8 pred,  Up: bytevectors 8

27.2.6 Comparison
-----------------

* Menu:

* bytevectors 8 compar lexi::        Lexicographic comparison.
* bytevectors 8 compar dict::        String dictionary comparison.
* bytevectors 8 compar number::      String and numeric parts
                                     lexicographic comparison.
* bytevectors 8 compar dictnumber::  String and numeric parts
                                     dictionary comparison.


File: vicare-libs.info,  Node: bytevectors 8 compar lexi,  Next: bytevectors 8 compar dict,  Up: bytevectors 8 compar

27.2.6.1 Lexicographic comparison
.................................

 -- Function: %bytevector-s8-compare BV1 BEG1 PAST1 BV2 BEG2 PAST2 PROC<
          PROC= PROC>
 -- Function: %bytevector-u8-compare BV1 BEG1 PAST1 BV2 BEG2 PAST2 PROC<
          PROC= PROC>
 -- Function: %bytevector-s8-compare-ci BV1 BEG1 PAST1 BV2 BEG2 PAST2
          PROC< PROC= PROC>
 -- Function: %bytevector-u8-compare-ci BV1 BEG1 PAST1 BV2 BEG2 PAST2
          PROC< PROC= PROC>
 -- Macro: bytevector-s8-compare B1 B2 PROC< PROC= PROC>
 -- Macro: bytevector-u8-compare B1 B2 PROC< PROC= PROC>
 -- Macro: bytevector-s8-compare-ci B1 B2 PROC< PROC= PROC>
 -- Macro: bytevector-u8-compare-ci B1 B2 PROC< PROC= PROC>
     Determine the "mismatch index" between the two subvectors: the
     largest index i such that for every 0 <= j < i, bv1[j] = bv2[j];
     that is, i is the first position that does not match.

     The mismatch index is always an index into BV1; in the case of
     equal bytevectorss, it is always PAST1; the functions observe the
     protocol in this redundant case for uniformity.

     PROC<, PROC=, or PROC> are applied to the mismatch index (not
     byte), depending upon whether the subvector of BV1 is less than,
     equal to, or greater than the subvector of BV2.  The result of the
     application is returned.

     If we just want to have the mismatch index as return value: we can
     use 'values' as value for PROC<, PROC= and PROC>.  Another
     interesting option is to use '(lambda (mismatch-index) #f)' or
     '(lambda (mismatch-index) #t)'.

     Examples:

          (define S string->utf8)

          (bytevector-u8-compare (S "abcd") (S "abcd")
                                 values values values)
          => 4

          (bytevector-u8-compare (S "abcd") (S "abcd12")
                                 values values values)
          => 4

 -- Function: %bytevector-s8= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-s8-ci= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8-ci= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Macro: bytevector-s8= B1 B2
 -- Macro: bytevector-u8= B1 B2
 -- Macro: bytevector-s8-ci= B1 B2
 -- Macro: bytevector-u8-ci= B1 B2
     Compare two subvectors: return true if they are equal, '#f'
     otherwise.

 -- Function: %bytevector-s8<> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8<> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-s8-ci<> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8-ci<> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Macro: bytevector-s8<> B1 B1
 -- Macro: bytevector-u8<> B1 B1
 -- Macro: bytevector-s8-ci<> B1 B2
 -- Macro: bytevector-u8-ci<> B1 B2
     Compare two subvectors: return '#f' if they are equal, true
     otherwise.

   The following predicates are the lexicographic extensions of the
corresponding integer and character predicates.  A bytevector BV1 is
"lexicographically" less than BV2 if, after conversion to strings in
ASCII encoding, BV1 would come first in a dictionary.

 -- Function: %bytevector-s8< BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8< BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-s8-ci< BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8-ci< BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Macro: bytevector-s8< B1 B2
 -- Macro: bytevector-u8< B1 B2
 -- Macro: bytevector-s8-ci< B1 B2
 -- Macro: bytevector-u8-ci< B1 B2
     Compare two subvectors: return true if the first is
     lexicographically less than the second, '#f' otherwise.  If BV2 is
     longer than BV1 but the subvectors are equal up to the end of BV1:
     return '#t'.

 -- Function: %bytevector-s8<= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8<= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-s8-ci<= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8-ci<= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Macro: bytevector-s8<= B1 B2
 -- Macro: bytevector-u8<= B1 B2
 -- Macro: bytevector-s8-ci<= B1 B2
 -- Macro: bytevector-u8-ci<= B1 B2
     Compare two subvectors: return true if the first is
     lexicographically less than, or equal to, the second; '#f'
     otherwise.  If BV2 is longer than BV1 but the subvectors are equal
     up to the end of BV1: return '#t'.

 -- Function: %bytevector-s8> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-s8-ci> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8-ci> BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Macro: bytevector-s8> B1 B2
 -- Macro: bytevector-u8> B1 B2
 -- Macro: bytevector-s8-ci> B1 B2
 -- Macro: bytevector-u8-ci> B1 B2
     Compare two subvectors: return true if the first is
     lexicographically greater than the second, '#f' otherwise.  If BV1
     is longer than BV2 but the subvectors are equal up to the end of
     BV2: return '#t'.

 -- Function: %bytevector-s8>= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8>= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-s8-ci>= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Function: %bytevector-u8-ci>= BV1 BEG1 PAST1 BV2 BEG2 PAST2
 -- Macro: bytevector-s8>= B1 B2
 -- Macro: bytevector-u8>= B1 B2
 -- Macro: bytevector-s8-ci>= B1 B2
 -- Macro: bytevector-u8-ci>= B1 B2
     Compare two subvectors: return true if the first is
     lexicographically greater than, or equal to, the second; '#f'
     otherwise.  If BV1 is longer than BV2 but the subvectors are equal
     up to the end of BV2: return '#t'.


File: vicare-libs.info,  Node: bytevectors 8 compar dict,  Next: bytevectors 8 compar number,  Prev: bytevectors 8 compar lexi,  Up: bytevectors 8 compar

27.2.6.2 Bytevector dictionary comparison
.........................................

Dictionary comparison is like lexicographic bytevector comparison, but
bytes representing white space characters in ASCII encoding are ignored.
Recognised white spaces are:

     #\space         #\tab           #\vtab
     #\linefeed      #\return        #\page

that is bytes with value:

     32              9               11
     10              13              12

 -- Function: bytevector-s8-dictionary-compare BV1 BV2
 -- Function: bytevector-u8-dictionary-compare BV1 BV2
 -- Function: %bytevector-s8-dictionary-compare BV1 BV2
 -- Function: %bytevector-u8-dictionary-compare BV1 BV2
     Compare the bytevector arguments and return a ternary result: '-1'
     if BV1 is less than BV2, '0' if BV1 is equal to BV2, '+1' if BV1 is
     greater than BV2.  The comparison is case sensitive.

 -- Function: bytevector-s8-dictionary=? BV1 BV2
 -- Function: bytevector-u8-dictionary=? BV1 BV2
 -- Function: bytevector-s8-dictionary<>? BV1 BV2
 -- Function: bytevector-u8-dictionary<>? BV1 BV2
 -- Function: bytevector-s8-dictionary<? BV1 BV2
 -- Function: bytevector-u8-dictionary<? BV1 BV2
 -- Function: bytevector-s8-dictionary<=? BV1 BV2
 -- Function: bytevector-u8-dictionary<=? BV1 BV2
 -- Function: bytevector-s8-dictionary>? BV1 BV2
 -- Function: bytevector-u8-dictionary>? BV1 BV2
 -- Function: bytevector-s8-dictionary>=? BV1 BV2
 -- Function: bytevector-u8-dictionary>=? BV1 BV2
 -- Function: %bytevector-s8-dictionary=? BV1 BV2
 -- Function: %bytevector-u8-dictionary=? BV1 BV2
 -- Function: %bytevector-s8-dictionary<>? BV1 BV2
 -- Function: %bytevector-u8-dictionary<>? BV1 BV2
 -- Function: %bytevector-s8-dictionary<? BV1 BV2
 -- Function: %bytevector-u8-dictionary<? BV1 BV2
 -- Function: %bytevector-s8-dictionary<=? BV1 BV2
 -- Function: %bytevector-u8-dictionary<=? BV1 BV2
 -- Function: %bytevector-s8-dictionary>? BV1 BV2
 -- Function: %bytevector-u8-dictionary>? BV1 BV2
 -- Function: %bytevector-s8-dictionary>=? BV1 BV2
 -- Function: %bytevector-u8-dictionary>=? BV1 BV2
     Return '#t' or '#f', depending on whether the arguments comply with
     the predicate.  The comparison is case sensitive.

 -- Function: bytevector-s8-dictionary-compare-ci BV1 BV2
 -- Function: bytevector-u8-dictionary-compare-ci BV1 BV2
 -- Function: %bytevector-s8-dictionary-compare-ci BV1 BV2
 -- Function: %bytevector-u8-dictionary-compare-ci BV1 BV2
     Compare the bytevector arguments and return a ternary result: '-1'
     if BV1 is less than BV2, '0' if BV1 is equal to BV2, '+1' if BV1 is
     greater than BV2.  The comparison is case insensitive.

 -- Function: bytevector-s8-dictionary-ci=? BV1 BV2
 -- Function: bytevector-u8-dictionary-ci=? BV1 BV2
 -- Function: bytevector-s8-dictionary-ci<>? BV1 BV2
 -- Function: bytevector-u8-dictionary-ci<>? BV1 BV2
 -- Function: bytevector-s8-dictionary-ci<? BV1 BV2
 -- Function: bytevector-u8-dictionary-ci<? BV1 BV2
 -- Function: bytevector-s8-dictionary-ci>? BV1 BV2
 -- Function: bytevector-u8-dictionary-ci>? BV1 BV2
 -- Function: bytevector-s8-dictionary-ci<=? BV1 BV2
 -- Function: bytevector-u8-dictionary-ci<=? BV1 BV2
 -- Function: bytevector-s8-dictionary-ci>=? BV1 BV2
 -- Function: bytevector-u8-dictionary-ci>=? BV1 BV2
 -- Function: %bytevector-s8-dictionary-ci=? BV1 BV2
 -- Function: %bytevector-u8-dictionary-ci=? BV1 BV2
 -- Function: %bytevector-s8-dictionary-ci<>? BV1 BV2
 -- Function: %bytevector-u8-dictionary-ci<>? BV1 BV2
 -- Function: %bytevector-s8-dictionary-ci<? BV1 BV2
 -- Function: %bytevector-u8-dictionary-ci<? BV1 BV2
 -- Function: %bytevector-s8-dictionary-ci>? BV1 BV2
 -- Function: %bytevector-u8-dictionary-ci>? BV1 BV2
 -- Function: %bytevector-s8-dictionary-ci<=? BV1 BV2
 -- Function: %bytevector-u8-dictionary-ci<=? BV1 BV2
 -- Function: %bytevector-s8-dictionary-ci>=? BV1 BV2
 -- Function: %bytevector-u8-dictionary-ci>=? BV1 BV2
     Return '#t' or '#f', depending on whether the arguments comply with
     the predicate.  The comparison is case insensitive.


File: vicare-libs.info,  Node: bytevectors 8 compar number,  Next: bytevectors 8 compar dictnumber,  Prev: bytevectors 8 compar dict,  Up: bytevectors 8 compar

27.2.6.3 Bytevector and numeric parts lexicographic comparison
..............................................................

Bytevector/numbers comparison splits the bytevectors to compare into
their numeric and non-numeric parts and compares the parts one by one;
numeric parts are sequences of bytes which correspond to number digits
in ASCII encoding.  For example, the string 'foo4bar3zab10' is the
bytevector:

     #vu8(102 111 111 52 98 97 114 51 122 97 98 49 48)

and it is split into the following list:

     (#vu8(102 111 111) 4
      #vu8(98 97 114)   3
      #vu8(122 97 98)   10)

in which non-numeric parts are retained as Scheme bytevectors and
numeric parts become exact integers; numeric parts only become *exact*
integer, never flonums.  Bytevector parts are compared with the ordinary
lexicographic operators 'bytevector-u8<' and 'bytevector=?' (or
'bytevector-u8-ci<' and 'bytevector-u8-ci='), while numeric parts are
compared with the ordinary '<' and '=' operators; a bytevector part and
a numeric part are compared by comparing the bytevectors.

 -- Function: bytevector-s8/numbers-compare BV1 BV2
 -- Function: bytevector-u8/numbers-compare BV1 BV2
 -- Function: %bytevector-s8/numbers-compare BV1 BV2
 -- Function: %bytevector-u8/numbers-compare BV1 BV2
     Compare the bytevector and numeric parts of the arguments and
     return a ternary result: '-1' if BV1 is less than BV2, '0' if BV1
     is equal to BV2, '+1' if BV1 is greater than BV2.  The comparison
     is case sensitive.

 -- Function: bytevector-s8/numbers=? BV1 BV2
 -- Function: bytevector-u8/numbers=? BV1 BV2
 -- Function: bytevector-s8/numbers<>? BV1 BV2
 -- Function: bytevector-u8/numbers<>? BV1 BV2
 -- Function: bytevector-s8/numbers<? BV1 BV2
 -- Function: bytevector-u8/numbers<? BV1 BV2
 -- Function: bytevector-s8/numbers<=? BV1 BV2
 -- Function: bytevector-u8/numbers<=? BV1 BV2
 -- Function: bytevector-s8/numbers>? BV1 BV2
 -- Function: bytevector-u8/numbers>? BV1 BV2
 -- Function: bytevector-s8/numbers>=? BV1 BV2
 -- Function: bytevector-u8/numbers>=? BV1 BV2
 -- Function: %bytevector-s8/numbers=? BV1 BV2
 -- Function: %bytevector-u8/numbers=? BV1 BV2
 -- Function: %bytevector-s8/numbers<>? BV1 BV2
 -- Function: %bytevector-u8/numbers<>? BV1 BV2
 -- Function: %bytevector-s8/numbers<? BV1 BV2
 -- Function: %bytevector-u8/numbers<? BV1 BV2
 -- Function: %bytevector-s8/numbers<=? BV1 BV2
 -- Function: %bytevector-u8/numbers<=? BV1 BV2
 -- Function: %bytevector-s8/numbers>? BV1 BV2
 -- Function: %bytevector-u8/numbers>? BV1 BV2
 -- Function: %bytevector-s8/numbers>=? BV1 BV2
 -- Function: %bytevector-u8/numbers>=? BV1 BV2
     Return '#t' or '#f', depending on whether the arguments comply with
     the predicate.

 -- Function: bytevector-s8/numbers-compare-ci BV1 BV2
 -- Function: bytevector-u8/numbers-compare-ci BV1 BV2
 -- Function: %bytevector-s8/numbers-compare-ci BV1 BV2
 -- Function: %bytevector-u8/numbers-compare-ci BV1 BV2
     Compare the string and numeric parts of the arguments and return a
     ternary result: '-1' if BV1 is less than BV2, '0' if BV1 is equal
     to BV2, '+1' if BV1 is greater than BV2.  The comparison is case
     insensitive.

 -- Function: bytevector-s8/numbers-ci=? BV1 BV2
 -- Function: bytevector-u8/numbers-ci=? BV1 BV2
 -- Function: bytevector-s8/numbers-ci<>? BV1 BV2
 -- Function: bytevector-u8/numbers-ci<>? BV1 BV2
 -- Function: bytevector-s8/numbers-ci<? BV1 BV2
 -- Function: bytevector-u8/numbers-ci<? BV1 BV2
 -- Function: bytevector-s8/numbers-ci>? BV1 BV2
 -- Function: bytevector-u8/numbers-ci>? BV1 BV2
 -- Function: bytevector-s8/numbers-ci<=? BV1 BV2
 -- Function: bytevector-u8/numbers-ci<=? BV1 BV2
 -- Function: bytevector-s8/numbers-ci>=? BV1 BV2
 -- Function: bytevector-u8/numbers-ci>=? BV1 BV2
 -- Function: %bytevector-s8/numbers-ci=? BV1 BV2
 -- Function: %bytevector-u8/numbers-ci=? BV1 BV2
 -- Function: %bytevector-s8/numbers-ci<>? BV1 BV2
 -- Function: %bytevector-u8/numbers-ci<>? BV1 BV2
 -- Function: %bytevector-s8/numbers-ci<? BV1 BV2
 -- Function: %bytevector-u8/numbers-ci<? BV1 BV2
 -- Function: %bytevector-s8/numbers-ci>? BV1 BV2
 -- Function: %bytevector-u8/numbers-ci>? BV1 BV2
 -- Function: %bytevector-s8/numbers-ci<=? BV1 BV2
 -- Function: %bytevector-u8/numbers-ci<=? BV1 BV2
 -- Function: %bytevector-s8/numbers-ci>=? BV1 BV2
 -- Function: %bytevector-u8/numbers-ci>=? BV1 BV2
     Return '#t' or '#f', depending on whether the arguments comply with
     the predicate.  The comparison is case insensitive.


File: vicare-libs.info,  Node: bytevectors 8 compar dictnumber,  Prev: bytevectors 8 compar number,  Up: bytevectors 8 compar

27.2.6.4 Bytevector and numeric parts dictionary comparison
...........................................................

Bytevector/numbers dictionary comparison is like bytevector/numbers
comparison, but white space characters in the bytevector arguments are
ignored.  White spaces are:

     #\space         #\tab           #\vtab
     #\linefeed      #\return        #\page

 -- Function: bytevector-s8/numbers-dictionary-compare BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-compare BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-compare BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-compare BV1 BV2
     Compare the bytevector and numeric parts of the arguments and
     return a ternary result: '-1' if BV1 is less than BV2, '0' if BV1
     is equal to BV2, '+1' if BV1 is greater than BV2.  The comparison
     is case sensitive.

 -- Function: bytevector-s8/numbers-dictionary=? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary=? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary<>? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary<>? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary<? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary<? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary<=? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary<=? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary>? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary>? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary>=? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary>=? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary=? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary=? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary<>? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary<>? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary<? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary<? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary<=? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary<=? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary>? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary>? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary>=? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary>=? BV1 BV2
     Return '#t' or '#f', depending on whether the arguments comply with
     the predicate.

 -- Function: bytevector-s8/numbers-dictionary-compare-ci BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-compare-ci BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-compare-ci BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-compare-ci BV1 BV2
     Compare the bytevector and numeric parts of the arguments and
     return a ternary result: '-1' if BV1 is less than BV2, '0' if BV1
     is equal to BV2, '+1' if BV1 is greater than BV2.  The comparison
     is case insensitive.

 -- Function: bytevector-s8/numbers-dictionary-ci=? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-ci=? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary-ci<>? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-ci<>? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary-ci<? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-ci<? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary-ci>? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-ci>? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary-ci<=? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-ci<=? BV1 BV2
 -- Function: bytevector-s8/numbers-dictionary-ci>=? BV1 BV2
 -- Function: bytevector-u8/numbers-dictionary-ci>=? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-ci=? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-ci=? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-ci<>? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-ci<>? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-ci<? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-ci<? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-ci>? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-ci>? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-ci<=? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-ci<=? BV1 BV2
 -- Function: %bytevector-s8/numbers-dictionary-ci>=? BV1 BV2
 -- Function: %bytevector-u8/numbers-dictionary-ci>=? BV1 BV2
     Return '#t' or '#f', depending on whether the arguments comply with
     the predicate.  The comparison is case insensitive.


File: vicare-libs.info,  Node: bytevectors 8 map,  Next: bytevectors 8 case,  Prev: bytevectors 8 compar,  Up: bytevectors 8

27.2.7 Mapping functions
------------------------

 -- Function: bytevector-s8-map PROC BV0 BV ...
 -- Function: bytevector-u8-map PROC BV0 BV ...
     Build and return a newly-allocated bytevector mapping PROC over all
     the bytes of the bytevector arguments, from zero to the end in
     increasing order.  It is an error if the bytevectorss have
     different length.

     PROC must return an exact integer representing a byte and it is
     applied to the elements as:

          (PROC IDX
            (bytevector-u8-ref BV0 IDX)
            (bytevector-u8-ref BV  IDX)
            ...)

     where IDX is the current index.

 -- Function: bytevector-s8-map! PROC BV0 BV ...
 -- Function: bytevector-u8-map! PROC BV0 BV ...
 -- Function: bytevector-s8-map*! PROC BV0 BV ...
 -- Function: bytevector-u8-map*! PROC BV0 BV ...
     Mutate bytevector BV0 mapping PROC over all the elements of the
     bytevector arguments, from zero to the end in increasing order.

     'bytevector-u8-map!' must be applied to bytevectorss of the same
     length; 'bytevector-u8-map*!' accepts bytevectorss of different
     length and iterates until the end of the shorter is reached.

     PROC is applied to the elements as:

          (PROC IDX
            (bytevector-u8-ref BV0 IDX)
            (bytevector-u8-ref BV  IDX)
            ...)

     where IDX is the current index.

 -- Function: bytevector-s8-for-each* PROC BV0 BV ...
 -- Function: bytevector-u8-for-each* PROC BV0 BV ...
     Apply PROC over all the elements of the bytevector arguments, from
     zero to the end in increasing order.  This function accepts
     bytevectorss of different length and iterates until the end of the
     shorter is reached.

     PROC is applied to the elements as:

          (PROC IDX
            (bytevector-u8-ref BV0 IDX)
            (bytevector-u8-ref BV  IDX)
            ...)

     where IDX is the current index.

Mapping over subvectors
.......................

 -- Function: %subbytevector-s8-map PROC BV START PAST
 -- Function: %subbytevector-u8-map PROC BV START PAST
 -- Macro: subbytevector-s8-map PROC B
 -- Macro: subbytevector-u8-map PROC B
     Build and return a new bytevector mapping PROC over the bytes in
     the selected subvector of BV, from index START to index PAST in
     increasing order.  PROC must be a byte-to-byte procedure.

 -- Function: %subbytevector-s8-map! PROC BV START PAST
 -- Function: %subbytevector-u8-map! PROC BV START PAST
 -- Macro: subbytevector-s8-map! PROC B
 -- Macro: subbytevector-u8-map! PROC B
     Mutate the selected subvector of BV, mapping PROC over its bytes
     from index START to index PAST in increasing order.  PROC must be a
     byte-to-byte procedure.

 -- Function: %subbytevector-s8-for-each PROC BV START PAST
 -- Function: %subbytevector-u8-for-each PROC BV START PAST
 -- Macro: subbytevector-s8-for-each PROC B
 -- Macro: subbytevector-u8-for-each PROC B
     Apply PROC to each byte in the selected subvector of BV, from index
     START to index PAST in increasing order.

 -- Function: %subbytevector-s8-for-each-index PROC BV START PAST
 -- Function: %subbytevector-u8-for-each-index PROC BV START PAST
 -- Macro: subbytevector-s8-for-each-index PROC B
 -- Macro: subbytevector-u8-for-each-index PROC B
     Apply PROC to each index in the selected subvector of BV, from
     index START to index PAST in increasing order.  This is simply a
     method of looping over a bytevector that is guaranteed to be safe
     and correct.


File: vicare-libs.info,  Node: bytevectors 8 case,  Next: bytevectors 8 fold,  Prev: bytevectors 8 map,  Up: bytevectors 8

27.2.8 Case mapping
-------------------

 -- Function: %bytevector-s8-titlecase*! BV START PAST
 -- Function: %bytevector-u8-titlecase*! BV START PAST
 -- Macro: bytevector-s8-titlecase* B
 -- Macro: bytevector-u8-titlecase* B
 -- Macro: bytevector-s8-titlecase*! B
 -- Macro: bytevector-u8-titlecase*! B
     For every byte b, interpreted in ASCII encoding, in the selected
     range of B: if b is preceded by a byte representing a cased
     character in ASCII encoding, b is downcased; otherwise it is
     titlecased.

     'bytevector-u8-titlecase*' returns the result string and does not
     alter its argument.  'bytevector-u8-titlecase!' is the in-place
     side-effecting variant.

     Note that the byte preceding 'bv[start]' has no effect on the
     titlecase decision for byte 'bv[start]'.

 -- Macro: bytevector-s8-upcase* B
 -- Macro: bytevector-u8-upcase* B
 -- Macro: bytevector-s8-upcase*! B
 -- Macro: bytevector-u8-upcase*! B
 -- Macro: bytevector-s8-downcase* B
 -- Macro: bytevector-u8-downcase* B
 -- Macro: bytevector-s8-downcase*! B
 -- Macro: bytevector-u8-downcase*! B
     Interpret the bytes in the selected subvector in ASCII encoding:
     raise or lower the case of the alphabetic characters.  There are no
     low level functions for these macros because they are just wrappers
     for '%bytevector-u8-map' and '%bytevector-u8-map!'.

     'bytevector-u8-upcase' and 'bytevector-u8-downcase' return the
     result string and do not alter their argument.
     'bytevector-u8-upcase!' and 'bytevector-u8-downcase!' are the
     in-place side-effecting variants.


File: vicare-libs.info,  Node: bytevectors 8 fold,  Next: bytevectors 8 select,  Prev: bytevectors 8 case,  Up: bytevectors 8

27.2.9 Fold and unfold
----------------------

 -- Function: bytevector-s8-fold-left KONS KNIL BV0 BV ...
 -- Function: bytevector-u8-fold-left KONS KNIL BV0 BV ...
 -- Function: bytevector-s8-fold-right KONS KNIL BV0 BV ...
 -- Function: bytevector-u8-fold-right KONS KNIL BV0 BV ...
     The fundamental bytevector iterator.  The bytevector arguments must
     have the same length.

     KONS is iterated left-to-right over each index in all of the
     bytevectors, stopping at the end of the shortest; KONS is applied
     as:

          (KONS IDX STATE
            (bytevector-u8-ref BV0 IDX)
            (bytevector-u8-ref BV  IDX)
            )

     where STATE is the current state value; the current state value
     begins with KNIL, and becomes whatever KONS returned at the
     respective iteration; IDX is the current index.

     'bytevector-u8-fold-right' is similar to 'bytevector-u8-fold', but
     it iterates right-to-left.

          Notice that to allow for an unspecified number of arguments,
          these folds hand the state as first argument to KONS, as
          opposed to the usual fold arguments.

 -- Function: bytevector-s8-fold-left* KONS KNIL BV0 BV ...
 -- Function: bytevector-u8-fold-left* KONS KNIL BV0 BV ...
 -- Function: bytevector-s8-fold-right* KONS KNIL BV0 BV ...
 -- Function: bytevector-u8-fold-right* KONS KNIL BV0 BV ...
     Like 'bytevector-u8-fold' and 'bytevector-u8-unfold' but accept
     bytevectors of different length, iterating until the end of the
     shortest one.

 -- Function: %subbytevector-s8-fold-left KONS KNIL BV START PAST
 -- Function: %subbytevector-u8-fold-left KONS KNIL BV START PAST
 -- Function: %subbytevector-s8-fold-right KONS KNIL BV START PAST
 -- Function: %subbytevector-u8-fold-right KONS KNIL BV START PAST
 -- Macro: bytevector-s8-fold KONS KNIL S
 -- Macro: bytevector-u8-fold KONS KNIL S
 -- Macro: bytevector-s8-fold-right KONS KNIL S
 -- Macro: bytevector-u8-fold-right KONS KNIL S
     Fundamental iterators for subvectors.  KONS is iterated over each
     byte of the selected subvector:

          (KONS
            (bytevector-u8-ref BV (+ START IDX))
            STATE)

     where STATE is the current state value; the current state value
     begins with KNIL, and becomes whatever KONS returned at the
     respective iteration; IDX is the current index.

     The left-fold iterator, '%subbytevector-u8-fold-left', builds the
     return value as:

          (KONS
            (bytevector-u8-ref BV (- PAST 1))
            (KONS
              (bytevector-u8-ref BV (- PAST 2))
              ...
                (KONS
                  (bytevector-u8-ref BV (+ START 2))
                  (KONS
                     (bytevector-u8-ref BV (+ START 1))
                     (KONS
                        (bytevector-u8-ref BV START)
                        KNIL)))))

     The right-fold iterator, '%subbytevector-u8-fold-right', builds the
     return value as:

          (KONS
            (bytevector-u8-ref BV START
            (KONS
              (bytevector-u8-ref BV (+ START 1))
              ...
                (KONS
                  (bytevector-u8-ref BV (- PAST 3))
                  (KONS
                     (bytevector-u8-ref BV (- PAST 2))
                     (KONS
                        (bytevector-u8-ref BV (- PAST 1))
                        KNIL)))))

 -- Function: bytevector-s8-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
 -- Function: bytevector-u8-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
 -- Function: bytevector-s8-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-BV
 -- Function: bytevector-u8-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-BV
 -- Function: bytevector-s8-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-BV MAKE-FINAL
 -- Function: bytevector-u8-unfold STOP? SEED->CHAR MAKE-SEED FIRST-SEED
          BASE-BV MAKE-FINAL
     This is a fundamental constructor for bytevectors.  Arguments
     description follows.

     MAKE-SEED
          A map function used to generate a series of "seed" values from
          the initial seed:

               FIRST-SEED
               (MAKE-SEED FIRST-SEED)            => seed2
               (MAKE-SEED seed2)                 => seed3
               (MAKE-SEED seed3)                 => seed4
               ...

     STOP?
          A predicate function telling when to stop generating bytes;
          when it returns true when applied to one of the seed values.

     SEED->CHAR
          Map function mapping each seed value to the corresponding byte
          in the result bytevector.  These bytes are assembled into the
          bytevector in a left-to-right order.

     BASE-BV
          An optional bytevector which is used as initial/leftmost
          portion of the constructed bytevector.  Defaults to the empty
          bytevector.

     MAKE-FINAL
          Optional function applied to the terminal seed value (on which
          STOP? returns true) to produce the final/rightmost portion of
          the constructed bytevector.  Defaults to '(lambda (x) "")'.

     The final bytevector constructed does not share storage with either
     BASE-BV or the value produced by MAKE-FINAL.

 -- Function: bytevector-s8-unfold-right STOP? SEED->CHAR MAKE-SEED
          FIRST-SEED
 -- Function: bytevector-u8-unfold-right STOP? SEED->CHAR MAKE-SEED
          FIRST-SEED
 -- Function: bytevector-s8-unfold-right STOP? SEED->CHAR MAKE-SEED
          FIRST-SEED BASE-BV
 -- Function: bytevector-u8-unfold-right STOP? SEED->CHAR MAKE-SEED
          FIRST-SEED BASE-BV
 -- Function: bytevector-s8-unfold-right STOP? SEED->CHAR MAKE-SEED
          FIRST-SEED BASE-BV MAKE-FINAL
 -- Function: bytevector-u8-unfold-right STOP? SEED->CHAR MAKE-SEED
          FIRST-SEED BASE-BV MAKE-FINAL
     This is a fundamental constructor for bytevectors.  The arguments
     are like the ones of 'bytevector-u8-unfold'.  The difference from
     'bytevector-u8-unfold' is that this function builds the bytevector
     from right to left.

     The final bytevector constructed does not share storage with either
     BASE-BV or the value produced by MAKE-FINAL.


File: vicare-libs.info,  Node: bytevectors 8 select,  Next: bytevectors 8 pad,  Prev: bytevectors 8 fold,  Up: bytevectors 8

27.2.10 Selection
-----------------

 -- Function: subbytevector-s8 BV START PAST
 -- Function: subbytevector-u8 BV START PAST
     Build and return a new bytevector holding a copy of the subvector
     selected in BV.

 -- Macro: subbytevector-s8* B
 -- Macro: subbytevector-u8* B
     Wrapper for 'subbytevector-u8' accepting a bytevector view as
     argument.

 -- Function: %bytevector-s8-copy* BV START PAST
 -- Function: %bytevector-u8-copy* BV START PAST
 -- Macro: bytevector-s8-copy* B
 -- Macro: bytevector-u8-copy* B
     The function '%bytevector-u8-copy*' is an alias for
     'subbytevector-u8'; the macro 'bytevector-u8-copy*' is an alias for
     'subbytevector-u8*'.

          These exist for symmetry with the '(vicare containers
          vectors)' library; they allow more confidence in converting a
          vector function into a bytevector function, and vice versa, by
          just replacing the string 'vector' in the function names with
          the string 'bytevector-u8', and vice versa.

 -- Function: %bytevector-s8-reverse-copy* BV START PAST
 -- Function: %bytevector-u8-reverse-copy* BV START PAST
 -- Macro: bytevector-s8-reverse-copy* B
 -- Macro: bytevector-u8-reverse-copy* B
     Like '%bytevector-u8-copy*', but copy the elements in the reverse
     order from the selected subvector.

 -- Function: %bytevector-s8-copy*! DST-BV DST-START SRC-BV SRC-START
          SRC-PAST
 -- Function: %bytevector-u8-copy*! DST-BV DST-START SRC-BV SRC-START
          SRC-PAST
 -- Macro: bytevector-s8-copy*! DST-S SRC-S
 -- Macro: bytevector-u8-copy*! DST-S SRC-S
     Write the selected source subvector into the selected destination
     subvector.  This function is the side-effecting variant of
     'subbytevector-u8' and 'subbytevector-u8*'.  This function supports
     copying over the same bytevector.

     The selected destination subvector starts at DST-START in DST-BV
     and may extend until the end of the bytevector.  In the destination
     bytevector view DST-S: if a past index is specified, it is ignored.

 -- Function: %bytevector-s8-reverse-copy*! DST-BV DST-START SRC-BV
          SRC-START SRC-PAST
 -- Function: %bytevector-u8-reverse-copy*! DST-BV DST-START SRC-BV
          SRC-START SRC-PAST
 -- Macro: bytevector-s8-reverse-copy*! B-DST B-SRC
 -- Macro: bytevector-u8-reverse-copy*! B-DST B-SRC
     Like '%bytevector-u8-copy*!', but this copies the elements in the
     reverse order.  This function supports copying over the same
     bytevector.

 -- Function: %bytevector-s8-take NBYTES BV START PAST
 -- Function: %bytevector-u8-take NBYTES BV START PAST
 -- Function: %bytevector-s8-take-right NBYTES BV START PAST
 -- Function: %bytevector-u8-take-right NBYTES BV START PAST
 -- Macro: bytevector-s8-take B NBYTES
 -- Macro: bytevector-u8-take B NBYTES
 -- Macro: bytevector-s8-take-right B NBYTES
 -- Macro: bytevector-u8-take-right B NBYTES
     Return the first or last NBYTES of the selected subvector.  These
     functions always return a newly allocated bytevector.

 -- Function: %bytevector-s8-drop NBYTES BV START PAST
 -- Function: %bytevector-u8-drop NBYTES BV START PAST
 -- Function: %bytevector-s8-drop-right NBYTES BV START PAST
 -- Function: %bytevector-u8-drop-right NBYTES BV START PAST
 -- Macro: bytevector-s8-drop B NBYTES
 -- Macro: bytevector-u8-drop B NBYTES
 -- Macro: bytevector-s8-drop-right B NBYTES
 -- Macro: bytevector-u8-drop-right B NBYTES
     Drop the first or last NBYTES of the selected subvector and return
     the resulting bytevector.  These functions always return a newly
     allocated bytevector.


File: vicare-libs.info,  Node: bytevectors 8 pad,  Next: bytevectors 8 prefix,  Prev: bytevectors 8 select,  Up: bytevectors 8

27.2.11 Padding and trimming
----------------------------

 -- Function: %bytevector-s8-pad REQUESTED-LEN FILL BV START PAST
 -- Function: %bytevector-u8-pad REQUESTED-LEN FILL BV START PAST
 -- Function: %bytevector-s8-pad-right REQUESTED-LEN FILL BV START PAST
 -- Function: %bytevector-u8-pad-right REQUESTED-LEN FILL BV START PAST
 -- Macro: bytevector-s8-pad B REQUESTED-LEN
 -- Macro: bytevector-u8-pad B REQUESTED-LEN
 -- Macro: bytevector-s8-pad B REQUESTED-LEN FILL
 -- Macro: bytevector-u8-pad B REQUESTED-LEN FILL
 -- Macro: bytevector-s8-pad-right B REQUESTED-LEN
 -- Macro: bytevector-u8-pad-right B REQUESTED-LEN
 -- Macro: bytevector-s8-pad-right B REQUESTED-LEN FILL
 -- Macro: bytevector-u8-pad-right B REQUESTED-LEN FILL
     Build a bytevector of length REQUESTED-LEN comprised of BV padded
     on the left or right by as many occurrences of the byte or
     character FILL as needed.  Always return a newly allocated
     bytevector.

     If BV has more than REQUESTED-LEN bytes, it is truncated on the
     left or right to length REQUESTED-LEN.  For the macros: FILL
     defaults to the byte representing '#\space' in ASCII encoding.

 -- Function: %bytevector-s8-trim BYTE/CHAR/CHAR-SET/PRED BV START PAST
 -- Function: %bytevector-u8-trim BYTE/CHAR/CHAR-SET/PRED BV START PAST
 -- Function: %bytevector-s8-trim-right BYTE/CHAR/CHAR-SET/PRED BV START
          PAST
 -- Function: %bytevector-u8-trim-right BYTE/CHAR/CHAR-SET/PRED BV START
          PAST
 -- Function: %bytevector-s8-trim-both BYTE/CHAR/CHAR-SET/PRED BV START
          PAST
 -- Function: %bytevector-u8-trim-both BYTE/CHAR/CHAR-SET/PRED BV START
          PAST
 -- Macro: bytevector-s8-trim B BYTE/CHAR/CHAR-SET/PRED
 -- Macro: bytevector-u8-trim B BYTE/CHAR/CHAR-SET/PRED
 -- Macro: bytevector-s8-trim-right B BYTE/CHAR/CHAR-SET/PRED
 -- Macro: bytevector-u8-trim-right B BYTE/CHAR/CHAR-SET/PRED
 -- Macro: bytevector-s8-trim-both B BYTE/CHAR/CHAR-SET/PRED
 -- Macro: bytevector-u8-trim-both B BYTE/CHAR/CHAR-SET/PRED
     Trim BV by skipping over all bytes on the left/on the right/on both
     sides that satisfy the second parameter BYTE/CHAR/CHAR-SET/PRED:

        * If it is an exact integer BYTE, bytes equal to BYTE are
          trimmed.

        * If it is a character CHAR, bytes equal to the ASCII
          representation of CHAR are trimmed.

        * If it is a char set CHAR-SET, bytes representing ASCII
          characters contained in CHAR-SET are trimmed.

        * If it is a predicate PRED, it is a test predicate that is
          applied to the bytes in B; a byte causing it to return true is
          skipped.

     Always return a newly allocated bytevector.


File: vicare-libs.info,  Node: bytevectors 8 prefix,  Next: bytevectors 8 search,  Prev: bytevectors 8 pad,  Up: bytevectors 8

27.2.12 Prefixes and suffixes
-----------------------------

 -- Function: %bytevector-s8-prefix-length BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-u8-prefix-length BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-s8-prefix-length-ci BV1 START1 PAST1 BV2
          START2 PAST2
 -- Function: %bytevector-u8-prefix-length-ci BV1 START1 PAST1 BV2
          START2 PAST2
 -- Macro: bytevector-s8-prefix-length B1 B2
 -- Macro: bytevector-u8-prefix-length B1 B2
 -- Macro: bytevector-s8-prefix-length-ci B1 B2
 -- Macro: bytevector-u8-prefix-length-ci B1 B2
     Return the length of the longest common prefix of the two
     subvectors.  This is equivalent to the "mismatch index" for the
     bytevectors (modulo the start index offsets).

 -- Function: %bytevector-s8-suffix-length BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-u8-suffix-length BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-s8-suffix-length-ci BV1 START1 PAST1 BV2
          START2 PAST2
 -- Function: %bytevector-u8-suffix-length-ci BV1 START1 PAST1 BV2
          START2 PAST2
 -- Macro: bytevector-s8-suffix-length B1 B2
 -- Macro: bytevector-u8-suffix-length B1 B2
 -- Macro: bytevector-s8-suffix-length-ci B1 B2
 -- Macro: bytevector-u8-suffix-length-ci B1 B2
     Return the length of the longest common suffix of the two
     subvectors.

 -- Function: %bytevector-s8-prefix? BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-u8-prefix? BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-s8-prefix-ci? BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-u8-prefix-ci? BV1 START1 PAST1 BV2 START2
          PAST2
 -- Macro: bytevector-s8-prefix? B1 B2
 -- Macro: bytevector-u8-prefix? B1 B2
 -- Macro: bytevector-s8-prefix-ci? B1 B2
 -- Macro: bytevector-u8-prefix-ci? B1 B2
     Return '#t' if the subvector B1 is a prefix of the subvector B2,
     otherwise return '#f'.  Notice that the empty bytevector is a
     prefix of every bytevector.

 -- Function: %bytevector-s8-suffix? BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-u8-suffix? BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-s8-suffix-ci? BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-u8-suffix-ci? BV1 START1 PAST1 BV2 START2
          PAST2
 -- Macro: bytevector-s8-suffix? B1 B2
 -- Macro: bytevector-u8-suffix? B1 B2
 -- Macro: bytevector-s8-suffix-ci? B1 B2
 -- Macro: bytevector-u8-suffix-ci? B1 B2
     Return '#t' if the subvector B1 is a suffix of the subvector B2,
     otherwise return '#f'.  Notice that the empty bytevector is *not* a
     suffix of every bytevector.


File: vicare-libs.info,  Node: bytevectors 8 search,  Next: bytevectors 8 filter,  Prev: bytevectors 8 prefix,  Up: bytevectors 8

27.2.13 Searching
-----------------

 -- Function: %bytevector-s8-index CRITERION BV START PAST
 -- Function: %bytevector-u8-index CRITERION BV START PAST
 -- Function: %bytevector-s8-index-right CRITERION BV START PAST
 -- Function: %bytevector-u8-index-right CRITERION BV START PAST
 -- Macro: bytevector-s8-index B CRITERION
 -- Macro: bytevector-u8-index B CRITERION
 -- Macro: bytevector-s8-index-right B CRITERION
 -- Macro: bytevector-u8-index-right B CRITERION
     Search through the bytevector from the left or right, returning the
     index of the first occurrence of a byte which matches the
     CRITERION:

        * If CRITERION is an exact integer: the byte has to be equal to
          it.

        * If CRITERION is a character: the byte has to be equal to it.

        * If CRITERION is a character set: the byte, interpreted as
          ASCII character, has to be contained in it.

        * If CRITERION is a procedure: the procedure applied to the byte
          must return true.

     If no match is found: return '#f'.

 -- Function: %bytevector-s8-skip CRITERION BV START PAST
 -- Function: %bytevector-u8-skip CRITERION BV START PAST
 -- Function: %bytevector-s8-skip-right CRITERION BV START PAST
 -- Function: %bytevector-u8-skip-right CRITERION BV START PAST
 -- Macro: bytevector-s8-skip B CRITERION
 -- Macro: bytevector-u8-skip B CRITERION
 -- Macro: bytevector-s8-skip-right B CRITERION
 -- Macro: bytevector-u8-skip-right B CRITERION
     Search through the bytevector from the left or right, returning the
     index of the first occurrence of a byte which does not match the
     CRITERION:

        * If CRITERION is an exact integer: the byte has to be different
          from it.

        * If CRITERION is a character: the byte has to be different from
          it.

        * If CRITERION is a character set: the byte, interpreted as
          ASCII character, must not be contained in it.

        * If CRITERION is a procedure: the procedure applied to the byte
          must return false.

     If no match is found: Return '#f'.

 -- Function: %bytevector-s8-count CRITERION BV START PAST
 -- Function: %bytevector-u8-count CRITERION BV START PAST
 -- Macro: bytevector-s8-count B CRITERION
 -- Macro: bytevector-u8-count B CRITERION
     Return a count of the number of bytes in BV that satisfy the
     CRITERION argument:

        * If CRITERION is an exact integer: the byte has to be equal to
          it.

        * If CRITERION is a character: the byte has to be equal to it.

        * If CRITERION is a character set: the byte, interpreted as
          ASCII character, has to be contained in it.

        * If CRITERION is a procedure: the procedure applied to the byte
          must return true.

 -- Function: %bytevector-s8-contains BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-u8-contains BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-s8-contains-ci BV1 START1 PAST1 BV2 START2
          PAST2
 -- Function: %bytevector-u8-contains-ci BV1 START1 PAST1 BV2 START2
          PAST2
 -- Macro: bytevector-s8-contains B1 B2
 -- Macro: bytevector-u8-contains B1 B2
 -- Macro: bytevector-s8-contains-ci B1 B2
 -- Macro: bytevector-u8-contains-ci B1 B2
     Return true if the subvector B1 contains the subvector B2, else
     return '#f'.  The return value is the index in the bytevector, not
     in the subvector.


File: vicare-libs.info,  Node: bytevectors 8 filter,  Next: bytevectors 8 list,  Prev: bytevectors 8 search,  Up: bytevectors 8

27.2.14 Filtering and deleting
------------------------------

 -- Function: %bytevector-s8-filter CRITERION BV START PAST
 -- Function: %bytevector-u8-filter CRITERION BV START PAST
 -- Macro: bytevector-s8-filter B CRITERION
 -- Macro: bytevector-u8-filter B CRITERION
     Filter the selected subvector, retaining only those bytes that
     satisfy the CRITERION argument; a byte is retained when:

        * If CRITERION is an exact integer: the byte has to be equal to
          it.

        * If CRITERION is a character: the byte has to be equal to it.

        * If CRITERION is a character set: the byte, interpreted as
          ASCII character, has to be contained in it.

        * If CRITERION is a procedure: the procedure applied to the byte
          must return true.

     Always return a newly allocated bytevector.

 -- Function: %bytevector-s8-delete CRITERION BV START PAST
 -- Function: %bytevector-u8-delete CRITERION BV START PAST
 -- Macro: bytevector-s8-delete B CRITERION
 -- Macro: bytevector-u8-delete B CRITERION
     Filter the selected subvector, retaining only those bytes that do
     *not* satisfy the CRITERION argument; a byte is deleted when:

        * If CRITERION is an exact integer: the byte has to be different
          from it.

        * If CRITERION is a character: the byte has to be different from
          it.

        * If CRITERION is a character set: the byte, interpreted as
          ASCII character, must not be contained in it.

        * If CRITERION is a procedure: the procedure applied to the byte
          must return false.

     Always return a newly allocated bytevector.


File: vicare-libs.info,  Node: bytevectors 8 list,  Next: bytevectors 8 replicate,  Prev: bytevectors 8 filter,  Up: bytevectors 8

27.2.15 List and string conversion
----------------------------------

 -- Function: %bytevector->s8-list* BV START PAST
 -- Function: %bytevector->u8-list* BV START PAST
 -- Macro: bytevector->s8-list* B
 -- Macro: bytevector->u8-list* B
     Return a newly allocated list of the bytes that make up the given
     subvector.

 -- Function: %reverse-bytevector->s8-list BV START PAST
 -- Function: %reverse-bytevector->u8-list BV START PAST
 -- Macro: reverse-bytevector->s8-list B
 -- Macro: reverse-bytevector->u8-list B
     Like '%bytevector->u8-list*' but reverses the order of the bytes
     from the subvector.

 -- Function: reverse-s8-list->bytevector-u8 CHAR-LIST
 -- Function: reverse-u8-list->bytevector-u8 CHAR-LIST
     Reverse the given list of characters, then compose a bytevector
     with the result.

 -- Function: %bytevector-s8-tokenize TOKEN-SET BV START PAST
 -- Function: %bytevector-u8-tokenize TOKEN-SET BV START PAST
 -- Function: %bytevector-s8-tokenise TOKEN-SET BV START PAST
 -- Function: %bytevector-u8-tokenise TOKEN-SET BV START PAST
 -- Macro: bytevector-s8-tokenize B TOKEN-SET
 -- Macro: bytevector-u8-tokenize B TOKEN-SET
 -- Macro: bytevector-s8-tokenise B TOKEN-SET
 -- Macro: bytevector-u8-tokenise B TOKEN-SET
     Split the selected subvector into a list of bytevectors, where each
     bytevector is a maximal, non-empty, contiguous sequence of bytes
     whose character interpretation in ASCII encoding is in the
     character set TOKEN-SET.

 -- Function: bytevector-s8-join BYTEVECTOR-U8-LIST
 -- Function: bytevector-u8-join BYTEVECTOR-U8-LIST
 -- Function: bytevector-s8-join BYTEVECTOR-U8-LIST DELIMITER
 -- Function: bytevector-u8-join BYTEVECTOR-U8-LIST DELIMITER
 -- Function: bytevector-s8-join BYTEVECTOR-U8-LIST DELIMITER GRAMMAR
 -- Function: bytevector-u8-join BYTEVECTOR-U8-LIST DELIMITER GRAMMAR
 -- Function: %bytevector-s8-join BYTEVECTOR-U8-LIST DELIMITER GRAMMAR
 -- Function: %bytevector-u8-join BYTEVECTOR-U8-LIST DELIMITER GRAMMAR
     This procedure is a simple unparser: it pastes strings together
     using the DELIMITER bytevector.  DELIMITER defaults to a single
     byte representing a white space in ASCII encoding.  GRAMMAR is a
     symbol that determines how the delimiter is used, and defaults to
     'infix'.  Supported values for GRAMMAR are:

     'infix'
          Means an infix or separator grammar: insert the delimiter
          between list elements.  An empty list will produce an empty
          string.

               *Note*: Parsing an empty string with an infix grammar is
               ambiguous.  Is it an empty list, or a list of one
               element, the empty string?

     'strict-infix'
          Means the same as 'infix', but will raise an error if given an
          empty list.

     'suffix'
          Means a suffix or terminator grammar: insert the delimiter
          after every list element.  This grammar has no ambiguities.

     'prefix'
          Means a prefix grammar: insert the delimiter before every list
          element.  This grammar has no ambiguities.


File: vicare-libs.info,  Node: bytevectors 8 replicate,  Next: bytevectors 8 mutate,  Prev: bytevectors 8 list,  Up: bytevectors 8

27.2.16 Replicate and rotate
----------------------------

 -- Function: %xsubbytevector-s8 FROM TO STR START PAST
 -- Function: %xsubbytevector-u8 FROM TO STR START PAST
 -- Macro: xsubbytevector-s8 S FROM TO
 -- Macro: xsubbytevector-u8 S FROM TO
     Extended subvector procedure replicating the selected subvector "up
     and down" index space, in both the positive and negative
     directions.

     The call:

          (%xsubstring from to 'vu8(0 1 2 3 4 5 6) 3 6)

     selects the subvector '3 4 5' and defines the conceptual
     bidirectionally-infinite bytevector:

          ...  4  5  3  4  5  3  4  5  3  4  5 ...
          ... -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 ...
                              ^

     that is '3 4 5' repeated in both directions.  This function returns
     the subvector of this bytevector beginning at index FROM, and
     ending at TO.

     Note that:

        * The FROM/TO indices give a half-open range; the bytes from
          index FROM up to, but not including, index TO.

        * The FROM/TO indices are not in terms of the index space for
          the bytevector BV.  They are in terms of the replicated index
          space of the subvector defined by BV, START, and PAST.

     It is an error if START equals PAST.

 -- Function: xbytevector-s8-xcopy! FROM TO TARGET TARGET-START SOURCE
          SOURCE-START SOURCE-PAST
 -- Function: xbytevector-u8-xcopy! FROM TO TARGET TARGET-START SOURCE
          SOURCE-START SOURCE-PAST
 -- Macro: bytevector-s8-xcopy! TARGET-B SOURCE-B FROM TO
 -- Macro: bytevector-u8-xcopy! TARGET-B SOURCE-B FROM TO
     Exactly the same as '%xsubbytevector-u8', but the extracted data is
     written into the selected subvector of TARGET.

     This operation is not defined if '(eq? target start)'; we cannot
     copy a bytevector on top of itself.


File: vicare-libs.info,  Node: bytevectors 8 mutate,  Next: bytevectors 8 misc,  Prev: bytevectors 8 replicate,  Up: bytevectors 8

27.2.17 Mutators
----------------

 -- Function: bytevector-s8-swap! BV I J
 -- Function: bytevector-u8-swap! BV I J
     Swap the bytes in BV at positions I and J.

 -- Function: %bytevector-s8-fill*! FILL BV START PAST
 -- Function: %bytevector-u8-fill*! FILL BV START PAST
 -- Macro: bytevector-s8-fill*! B FILL
 -- Macro: bytevector-u8-fill*! B FILL
     Fill the selected subvector with FILL, a byte or character,
     modifying the original bytevector.


File: vicare-libs.info,  Node: bytevectors 8 misc,  Prev: bytevectors 8 mutate,  Up: bytevectors 8

27.2.18 Miscellaneous functions
-------------------------------

 -- Function: %bytevector-s8-replace BV1 START1 PAST1 BV2 START2 PAST2
 -- Function: %bytevector-u8-replace BV1 START1 PAST1 BV2 START2 PAST2
 -- Macro: bytevector-s8-replace B1 B2
 -- Macro: bytevector-u8-replace B1 B2
     Replace the subvector in B1 with the selected subvector in B2.
     Return a newly allocated bytevector.

 -- Function: %bytevector-s8-reverse BV START PAST
 -- Function: %bytevector-u8-reverse BV START PAST
 -- Function: %bytevector-s8-reverse! BV START PAST
 -- Function: %bytevector-u8-reverse! BV START PAST
 -- Macro: bytevector-s8-reverse B
 -- Macro: bytevector-u8-reverse B
 -- Macro: bytevector-s8-reverse! B
 -- Macro: bytevector-u8-reverse! B
     Reverse the bytevector.  '%bytevector-u8-reverse' returns the
     result bytevector and does not alter its BV argument.
     '%bytevector-u8-reverse!' is the in-place side-effecting variant.


File: vicare-libs.info,  Node: bytevector compounds,  Next: kmp,  Prev: bytevectors,  Up: Top

28 Bytevector compounds
***********************

A "bytevector compound" is a sequence of octets split into a sequence of
bytevectors.  Bytevector compounds have a special API to handle the
sequence of octets as a First-in First-out queue.  Bytevector compounds
are defined by the library '(vicare containers bytevector-compounds)'.

* Menu:

* bytevector compounds types::    Data type definitions.
* bytevector compounds inspect::  Inspecting bytevector compounds.
* bytevector compounds queue::    Queue programming interface.
* bytevector compounds access::   Accessors and mutators.


File: vicare-libs.info,  Node: bytevector compounds types,  Next: bytevector compounds inspect,  Up: bytevector compounds

28.1 Data type definitions
==========================

The following bindings are exported by the library '(vicare containers
bytevector-compounds)'.

 -- R6RS Record Type: bytevector-compound
     Record type representing a bytevector compound.  When instances of
     this type are used as arguments to functions: this documentation
     identifies them as BVCOM.

 -- Function: bytevector-compound? OBJ
     Return '#t' if OBJ is an instance of 'bytevector-compound', else
     return '#f'.

Validation clauses
..................

The following bindings are to be used with the facilities of the library
'(vicare arguments validation)', *note Optional function arguments
validation: args.

 -- Validation Clause: bytevector-compound OBJ
 -- Validation Clause: false-or-bytevector-compound OBJ
     Succeed if OBJ is an instance of 'bytevector-compound'.  The second
     clause accepts also '#f'.

 -- Validation Clause: bytevector-compound/filled OBJ
     Succeed if OBJ is an instance of 'bytevector-compound' and it
     contains at least one octet.


File: vicare-libs.info,  Node: bytevector compounds inspect,  Next: bytevector compounds queue,  Prev: bytevector compounds types,  Up: bytevector compounds

28.2 Inspecting bytevector compounds
====================================

The following bindings are exported by the library '(vicare containers
bytevector-compounds)'.

 -- Function: bytevector-compound-empty? BVCOM
     Return '#t' if BVCOM has no octets in it, else return '#f'.

 -- Function: bytevector-compound-filled? BVCOM
     Return '#t' if BVCOM has at least one octet in it, else return
     '#f'.

 -- Function: bytevector-compound-length BVCOM
     Return a non-negative exact integer representing the number of
     octets currently in BVCOM.

 -- Function: bytevector-compound-total-length BVCOM
     Return a non-negative exact integer representing the number of
     octets in BVCOM, including the ones in the bytevectors that have
     been already dequeued.

 -- Function: bytevector-compound-data BVCOM
     Return the list of bytevectors in BVCOM.  Mutating the return value
     results in undefined behaviour.


File: vicare-libs.info,  Node: bytevector compounds queue,  Next: bytevector compounds access,  Prev: bytevector compounds inspect,  Up: bytevector compounds

28.3 Queue programming interface
================================

The following bindings are exported by the library '(vicare containers
bytevector-compounds)'.

 -- Function: bytevector-compound-enqueue! BVCOM ITEM
     Enqueue the bytevector ITEM into BVCOM.  Return unspecified values.

 -- Function: bytevector-compound-dequeue! BVCOM
     Dequeue the next bytevector from BVCOM and return it; return '#f'
     if BVCOM is empty.


File: vicare-libs.info,  Node: bytevector compounds access,  Prev: bytevector compounds queue,  Up: bytevector compounds

28.4 Accessors and mutators
===========================

The following bindings are exported by the library '(vicare containers
bytevector-compounds)'.

 -- Function: bytevector-compound-u8-set! BVCOM IDX OCTET
 -- Function: bytevector-compound-u8-ref BVCOM IDX
     Accessor and mutator for non-negative exact integers in the range
     [0, 255].

 -- Function: bytevector-compound-s8-set! BVCOM IDX BYTE
 -- Function: bytevector-compound-s8-ref BVCOM IDX
     Accessor and mutator for non-negative exact integers in the range
     [-128, 127].


File: vicare-libs.info,  Node: kmp,  Next: levenshtein,  Prev: bytevector compounds,  Up: Top

29 Knuth-Morris-Pratt searching
*******************************

The Knuth-Morris-Pratt (KMP) sequence-search algorithm is a method of
rapidly scanning a sequence of values for the occurrence of some fixed
pattern.  It has the advantage of never requiring backtracking; hence,
it is useful for searching sequences that do not support backtracking or
random-access, such as input ports.

   For an explanation of the algorithm:

      <http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm>

   The following routines package up the initialisation and searching
phases of the algorithm for general use in the library '(vicare
containers knuth-morris-pratt)'.  They also support searching through
sequences that arrive in buffered chunks, in that intermediate search
state can be carried across applications of the search loop from the end
of one buffer application to the next.

   A second critical property of KMP search is that it requires the
allocation of auxiliary memory proportional to the length of the
pattern, but constant in the size of the value type.  Alternate
searching algorithms frequently require the construction of a table with
an entry for every possible value, which can be prohibitively expensive,
for example, in a 16-bit or 32-bit character representation.

   The algorithm is especially suited to search patterns of characters
in text, so many examples are given for strings.  However the library
supports searching any values in any sequence.

* Menu:

* kmp intro::                   Introduction.
* kmp conv::                    Conventions.
* kmp vector::                  The restart vector.
* kmp step::                    Single step of the search.
* kmp partial::                 Partial search.
* kmp full::                    Full sequence search.


File: vicare-libs.info,  Node: kmp intro,  Next: kmp conv,  Up: kmp

29.1 Introduction
=================

When searching for a pattern string in a text string:

     (define pattern "ciao")
     (define text    "Oh, ciao!")

we start looking for the first char in the pattern:

     (define match-start
       (let loop ((i 0))
         (if (char=? (string-ref text i)
                     (string-ref pattern 0))
             i
           (loop (+ 1 i)))))
     => 3

now that we know a match for the first char, we go on looking for the
full pattern:

     (define match-past
       (let loop ((pi 1)                     ;; pattern index
                  (ti (+ 1 match-start)))    ;; text index
         (cond
          ((= pi (string-length pattern)) pi)    ;; found
          ((= ti (string-length text))    #f)    ;; not found
          (else
           (if (char=? (string-ref ti text)
                       (string-ref pi pattern))
               (loop (+ 1 pi) (+ 1 ti))
             #f)))))                             ;; not found

we have the following possible outcomes:

   * 'match-past' is true: We have found a match in the substring
     '[match-start, match-past)' of 'text'.

   * 'match-past' is false: We have to restart matching 'pattern' from
     character '(+ 1 match-start)' of 'text'.

   The action "restart matching" involves backtracking (to go back) in
the 'text' string; this can be avoided if we do the following
considerations.

   * Let's say we have to perform the search:

          (define pattern "ciao mamma")
          (define text    "Oh, ciao papa e ciao mamma!")

          ;;               0123456789012345678901234567
          ;;               0         1         2

     we notice that the first char 'c' is never repeated in the pattern;
     so after we have matched the first occurrence of '"ciao "' in the
     substring [4, 9) of 'text', we do not need to restart from index 5,
     we just try to match 'pattern' from index 10 of 'text'.

   * Let's say we have to perform the search:

          (define pattern "ciao ciao mamma")
          (define text    "Oh, ciao ciao ciao mamma!")

          ;;               01234567890123456789012345
          ;;               0         1         2

     after we have matched the first occurrence of '"ciao ciao "' in the
     substring [4, 14) of 'text', we find a 'c' rather than a 'm'; we
     could restart matching 'pattern' from index 5, but we notice that
     we already have matched substring [0, 5) of 'pattern' in substring
     [9, 14) of 'text'; so we can avoid backtracking and go on matching
     index 5 of 'pattern' with index 14 of 'text'.

   Summary: We can implement an efficient algorithm if we precompute
where to restart from, after a partial match.  Of course, since the
algorithm needs no backtracking, we can also search for multiple
patterns in "parallel".


File: vicare-libs.info,  Node: kmp conv,  Next: kmp vector,  Prev: kmp intro,  Up: kmp

29.2 Conventions
================

The following conventions for arguments documentation hold:

PATTERN
     It is the sequence of elements to search for.  It must support
     random access by indexing.

PATTERN-START
PATTERN-PAST
     The half-open range of elements in PATTERN to search for.
     PATTERN-START is the index of the first (included) element;
     PATTERN-PAST is the index of the last (excluded) element.

TEXT
     It is a fixed sequence in which to do the search.  It must support
     random access by indexing.

TEXT-START
TEXT-PAST
     The half-open range of elements in TEXT in which to do the search.
     TEXT-START is the index of the first (included) element; TEXT-PAST
     is the index of the last (excluded) element.

ITEM=
     It is an equality function used to construct the restart vector;
     for characters it is typically 'char=?' or 'char-ci=?', while for
     numbers it is '='.

ITEM-REF
     It is an element extraction function to be applied to PATTERN to
     retrieve an element by index; if PATTERN is a string, it is
     'string-ref'; if PATTERN is a vector it is 'vector-ref'; if PATTERN
     is a list it is 'list-ref'.

RESTART-VECTOR
     It is the KMP restart vector for PATTERN, as constructed by
     '%kmp-make-restart-vector'.


File: vicare-libs.info,  Node: kmp vector,  Next: kmp step,  Prev: kmp conv,  Up: kmp

29.3 The restart vector
=======================

 -- Function: %kmp-make-restart-vector ITEM= ITEM-REF PATTERN
          PATTERN-START PATTERN-PAST
     Build a "restart vector", to be used to search sequences for the
     occurrence of the selected subsequence of PATTERN.

     The definition of the restart vector V for string P is: If we have
     matched elements 0 ... i-1 of P against some search sequence T:

          P[i-1] = T[k]
          P[i-2] = T[k-1]
          ...
          P[0] = T[k-(i-1)]

     and P[i] does not match T[k], then reset i := V[i], and try again
     to match T[k].  If V[i] = -1: move on to T[k+1] and P[0].


File: vicare-libs.info,  Node: kmp step,  Next: kmp partial,  Prev: kmp vector,  Up: kmp

29.4 Single step of the search
==============================

 -- Function: %kmp-step ITEM= ITEM-REF RESTART-VECTOR
          NEXT-VALUE-FROM-TEXT NEXT-INDEX-IN-PATTERN PATTERN
          PATTERN-START
     This function encapsulates the work performed by one step of the
     KMP search.  Return the new index in the pattern; that is, how much
     of the pattern we have matched, including the given value from
     text.

   Searching for the pattern '"hello"' in the text '"ciao hello salut"'
looks like this:

     (let* ((text          "ciao hello salut")
            ;;              01234567890123456
            ;;              0         1
            (text-past     (string-length text))

            (pattern       "ciao")
            (pattern-start 0)
            (pattern-past  (string-length pattern))

            (rv            (%kmp-make-restart-vector char=? string-ref
                              pattern pattern-start pattern-past)))
       (let loop ((ti 0)
                  (pi pattern-start))
         (or (and (= pi pattern-past) ti) ; found
             (and (not (= ti text-past))  ; not found
                  (loop (+ 1 ti)
                        (%kmp-step char=? string-ref rv
                                   (string-ref text ti)
                                   pi pattern pattern-start))))))
     => 10

if the pattern was not found the return value is '#f'; if the pattern
was found the return value is the index in the text of the character
past the last matched one.

   Abstracting the search from a string to a generic source of
characters, we can write the following function, whose return value is
the same as the loop above:

     (define (return-match-past end-of-text? get-next-char
                                pattern pattern-start pattern-past)
       (let ((rv (%kmp-make-restart-vector char=? string-ref
                    pattern pattern-start pattern-past)))
         (let loop ((ti 0)
                    (pi pattern-start))
           (or (and (= pi pattern-past) ti) ; found
               (and (not (end-of-text?))    ; not found
                    (loop (+ 1 ti)
                          (%kmp-step char=? string-ref rv
                             (get-next-char)
                             pi pattern pattern-start)))))))

a usage example with a string looks like this:

     (let* ((text           "ciao hello salut")
            ;;               01234567890123456
            ;;               0         1
            (pattern        "hello")
            (ti             0)
            (end-of-text?   (lambda ()
                              (= ti (string-length text))))
            (get-next-char  (lambda ()
                              (begin0
                                  (string-ref text ti)
                                (set! ti (+ 1 ti))))))
       (return-match-past end-of-text? get-next-char
                          pattern 0 (string-length pattern)))
     => 10

a usage example with an input port looks like this:

     (let* ((text           "ciao hello salut")
            ;;               01234567890123456
            ;;               0         1
            (pattern        "salut")
            (port           (open-string-input-port text))
            (end-of-text?   (lambda ()
                              (eof-object? (peek-char port))))
            (get-next-char  (lambda ()
                              (read-char port))))
       (return-match-past end-of-text? get-next-char
                          pattern 0 (string-length pattern)))
     => 16


File: vicare-libs.info,  Node: kmp partial,  Next: kmp full,  Prev: kmp step,  Up: kmp

29.5 Partial search
===================

 -- Function: %kmp-partial-search ITEM= ITEM-REF RESTART-VECTOR
          NEXT-INDEX-IN-PATTERN TEXT TEXT-START TEXT-END PATTERN
          PATTERN-START
     Using this function is equivalent to apply '%kmp-step' across the
     selected subsequence of TEXT in search of the selected subsequence
     of PATTERN; the pattern is '(vector-length rv)' characters long.

        * If the pattern is found: Return -j (a strictly negative
          integer) where j is the index of the value past the one that
          last matched the pattern in TEXT.

        * If the pattern is not found: Return the index in the restart
          vector (a non negative integer) to be used in the next call to
          this function.

     This utility is designed to allow searching for occurrences of a
     fixed sequence that might extend across multiple buffers of data.
     Notice that, in this case, when the returned value is negative: It
     is the index in the last buffer, not in the whole text.

   A simple one-shot search over a given string looks like the
following:

     (let* ((text            "ciao hello salut")
            ;;                01234567890123456
            ;;                0         1
            (text-start      0)
            (text-past       (string-length text))

            (pattern         "hello")
            (pattern-start   0)
            (pattern-past    (string-length pattern))

            (restart-vector  (%kmp-make-restart-vector
                                char=? string-ref
                                pattern pattern-start pattern-past)))
       (let ((i (%kmp-partial-search
                   char=? string-ref restart-vector pattern-start
                   text text-start text-past
                   pattern pattern-start)))
         (or (<= 0 i) ;; not found
             (- i)))) ;; found, return match past index
     => 10

if the pattern was not found: Return '#f'.  If the pattern was found:
Return the index in the string of the character past the one that
matched the end of the pattern.

   Generalising this to a generic source of strings (represented by a
list of strings):

     (let* ((strings         '("ciao h " "he hel h"
                               "ell hel" "lo salut"))
            (end-of-data?    (lambda ()
                               (null? strings)))
            (get-next-chunk  (lambda ()
                               (begin0
                                   (car strings)
                                 (set! strings (cdr strings))))))

       (let* ((pattern         "hello")
              (pattern-start   0)
              (pattern-past    (string-length pattern))

              (restart-vector  (%kmp-make-restart-vector char=? string-ref
                                  pattern pattern-start pattern-past)))

         (let loop ((pi 0))
           (and (not (end-of-data?))          ; not found
                (let* ((buf (get-next-chunk))
                       (pi  (%kmp-partial-search
                               char=? string-ref
                               restart-vector pi
                               buf 0 (string-length buf)
                               pattern pattern-start)))
                  (if (< pi 0)
                      (cons buf (- pi)) ; found
                    (loop pi)))))))
     => ("lo salut" . 2)

if the pattern was not found: Return '#f'.  If the pattern was found:
Return a cons whose car is the string chunk holding the end of the text
that matched, and whose cdr is the index in the chunk of the character
past the one that matched the end of the pattern.


File: vicare-libs.info,  Node: kmp full,  Prev: kmp partial,  Up: kmp

29.6 Full sequence search
=========================

 -- Function: %kmp-search ITEM= ITEM-REF TEXT TEXT-START TEXT-PAST
          PATTERN PATTERN-START PATTERN-PAST
     Search the selected subsequence of TEXT for the selected
     subsequence of PATTERN.  Return the index of the *first* value in
     TEXT that matched the *first* value in the pattern.

     This function is like '%string-contains' and '%string-contains-ci',
     in facts those are implemented as:

          (define (%string-contains text text-beg text-past
                                    pattern pattern-beg pattern-past)
            (%kmp-search char=? string-ref
                         text text-beg text-past
                         pattern pattern-beg pattern-past))

          (define (%string-contains-ci text text-beg text-past
                                       pattern pattern-beg pattern-past)
            (%kmp-search char-ci=? string-ref
                         text text-beg text-past
                         pattern pattern-beg pattern-past))


File: vicare-libs.info,  Node: levenshtein,  Next: wtables,  Prev: kmp,  Up: Top

30 Levenshtein distance metric
******************************

The library '(vicare containers levenshtein)' is a Scheme implementation
of the "Levenshtein Distance" algorithm, which is an "edit distance"
metric of string similarity, due to Vladimir Levenshtein.  The
Levenshtein Distance is a function of two strings that represents a
count of single-character insertions, deletions, and substitions that
will change the first string to the second.  More information is
available in NIST DADS (http://www.nist.gov/dads/HTML/Levenshtein.html)
and the Michael Gilleland article, "Levenshtein Distance in Three
Flavors (http://www.merriampark.com/ld.htm)."

     This implementation is modeled after a space-efficient Perl
     implementation (http://www.mgilleland.com/ld/ldperl2.htm) by Jorge
     Mas Trullenque.  It has been written in Scheme by Neil Van Dyke,
     and extended to support heterogeneous combinations of Scheme types
     (strings, lists, vectors), user-supplied predicate functions, and
     optionally reusable scratch vectors.

* Menu:

* levenshtein basic::           Basic comparisons.
* levenshtein coerce::          Type-coercing comparisons.


File: vicare-libs.info,  Node: levenshtein basic,  Next: levenshtein coerce,  Up: levenshtein

30.1 Basic comparisons
======================

In the current implementation, all comparisons are done internally via
vectors.

 -- Function: vector-levenshtein/predicate/get-scratch A B PRED
          GET-SCRATCH
     Few, if any, programs will use this procedure directly.  This is
     like 'vector-levenshtein/predicate', but allows GET-SCRATCH to be
     specified.  GET-SCRATCH is a procedure of one term, n, that yields
     a vector of length n or greater, which is used for record-keeping
     during execution of the Levenshtein algorithm.  'make-vector' can
     be used for GET-SCRATCH, although some programs comparing a large
     size or quantity of vectors may wish to reuse a record-keeping
     vector, rather than each time allocating a new one that will need
     to be garbage-collected.

 -- Function: vector-levenshtein/predicate A B PRED
 -- Function: vector-levenshtein/eq A B
 -- Function: vector-levenshtein/eqv A B
 -- Function: vector-levenshtein/equal A B
 -- Function: vector-levenshtein A B
     Calculate the Levenshtein Distance of vectors A and B.  PRED is the
     predicate procedure for determining if two elements are equal.  The
     '/eq', '/eqv', and '/equal' variants correspond to the standard
     equivalence predicates, 'eq?', 'eqv?', and 'equal?'.
     'vector-levenshtein' is an alias for 'vector-levenshtein/equal'.

          (vector-levenshtein '#(6 6 6) '#(6 35 6 24 6 32)) => 3

 -- Function: list-levenshtein/predicate A B PRED
 -- Function: list-levenshtein/eq A B
 -- Function: list-levenshtein/eqv A B
 -- Function: list-levenshtein/equal A B
 -- Function: list-levenshtein A B
     Calculate the Levenshtein Distance of lists A and B.  PRED is the
     predicate procedure for determining if two elements are equal.  The
     '/eq', '/eqv', and '/equal' variants correspond to the standard
     equivalence predicates, 'eq?', 'eqv?', and 'equal?'.
     'list-levenshtein' is an alias for 'list-levenshtein/equal'.  Note
     that comparison of lists is less efficient than comparison of
     vectors.

          (list-levenshtein/eq '(b c e x f y) '(a b c d e f)) => 4

 -- Function: string-levenshtein A B
     Calculate the Levenshtein Distance of strings A and B.

          (string-levenshtein "adresse" "address") => 2


File: vicare-libs.info,  Node: levenshtein coerce,  Prev: levenshtein basic,  Up: levenshtein

30.2 Type-coercing comparisons
==============================

Procedures 'levenshtein' and 'levenshtein/predicate' provide a
convenient interface for comparing a combination of vectors, lists, and
strings, the types of which might not be known until runtime.

 -- Function: levenshtein/predicate A B PRED
     Calculate the Levenshtein Distance of two objects A and B, which
     are vectors, lists, or strings.  A and B need not be of the same
     type.  PRED is the element equivalence predicate used.

          (levenshtein/predicate '#(#\A #\B #\C #\D)
                                 "aBXcD"
                                 char-ci=?)
          => 1

 -- Function: levenshtein A B
     Calculate the Levenshtein Distance of A and B, in a similar manner
     as using 'levenshtein/predicate' with 'equal?' as the predicate.

          (define g '#(#\g #\u #\m #\b #\o))

          (levenshtein g "gambol")  => 2
          (levenshtein g "dumbo")   => 1
          (levenshtein g "umbrage") => 5


File: vicare-libs.info,  Node: wtables,  Next: object-properties,  Prev: levenshtein,  Up: Top

31 Weak hashtables
******************

Weak hashtables are association containers whose keys are held by weak
references: registering a key into a weak hashtable does not prevent its
garbage collection.  A weak hashtable is a Scheme vector holding nulls
or association lists; each vector slot is called "bucket"; the
association lists have the spine composed of strong pairs, while the
entries are weak pairs:

     |-----|-----|-----|-----|-----| vector of buckets
              |
              v
           |-----|-----|strong pair
              |      |
              |       ------------> |-----|-----|strong pair
              |                        |     |
           |-----|-----|weak pair      |      -------> null
             key  value                v
                                    |-----|-----| weak pair
                                      key  value

   Whenever a key in a weak hashtable is garbage collected: the
corresponding location in the weak pair is set to the BWP object (a
special unique object that has this exact purpose, BWP stands for
"broken weak pointer"); whenever a bucket is accessed, it is first
cleared of weak pairs holding BWP in key position.

     *NOTE* Immediate values (those that fit into a single machine word:
     '#t', '#f', nil, fixnums, characters, etc.) and interned symbols
     are *never* garbage collected.  If we use them as weak hashtable
     keys: the associated entries will never be removed from the table
     unless we explicitly do it with 'weak-hashtable-delete!' or
     'weak-hashtable-clear!'.

   When the number of collected objects equals the number of buckets
(whatever the distribution of elements), the table is enlarged doubling
the number of buckets; the table is *never* restricted by reducing the
number of buckets.

   At present, weak hashtables are subjected to the following
constraints:

   * The number of buckets is always an exact power of 2.

   * The maximum number of buckets is the value of '(greatest-fixnum)'.

   * The maximum number of entries is the value of '(greatest-fixnum)'.

   The API of weak hashtables is similar to the API of R6RS hashtables.
The following bindings are exported by the library '(vicare containers
weak-hashtables)'.

 -- Function: make-weak-hashtable HASH-FUNCTION EQUIV-FUNCTION
 -- Function: make-weak-hashtable HASH-FUNCTION EQUIV-FUNCTION DIMENSION
     Build and return a new weak hashtable using HASH-FUNCTION as hash
     function for keys and EQUIV-FUNCTION as comparison function between
     keys.  When DIMENSION is used: it is approximately the initial
     number of buckets; when not used it defaults to 16.

 -- Function: weak-hashtable? OBJ
     Return '#t' if OBJ is a weak hashtable, otherwise '#f'.  Weak
     hashtables are disjoint values.

 -- Validation Clause: weak-hashtable OBJ
     Validation clause to be used with the facilities of the library
     '(vicare arguments validation)'.  Succeed if OBJ is an instance of
     'weak-hashtable'.

 -- Function: weak-hashtable-set! TABLE KEY VALUE
     Add an entry to TABLE holding KEY and VALUE.  Return unspecified
     values.

 -- Function: weak-hashtable-ref TABLE KEY DEFAULT
     Search for KEY in TABLE; if found: return the corresponding value,
     else return DEFAULT.

 -- Function: weak-hashtable-contains? TABLE KEY
     Return '#t' if TABLE contains an entry for KEY, else return '#f'.

 -- Function: weak-hashtable-delete! TABLE KEY
     If KEY is in TABLE: remove it, else do nothing.  Return unspecified
     values.

 -- Function: weak-hashtable-size TABLE
     Return the approximate number of entries in TABLE.  The returned
     value can be incorrect if some keys have been garbage collected but
     the corresponding entries in the table are not yet removed.

 -- Function: weak-hashtable-clear! TABLE
     Remove all the entries from TABLE.  The number of buckets is reset
     to the its initial value.  Return unspecified values.

 -- Function: weak-hashtable-keys TABLE
     Return a vector holding the keys in TABLE.

 -- Function: weak-hashtable-entries TABLE
     Return two values: a vector holding the keys in TABLE, a vector
     holding the values in TABLE.

 -- Function: weak-hashtable-update! TABLE KEY PROC DEFAULT
     If no entry exists for KEY in TABLE: create a new entry associating
     KEY to the result of applying PROC to DEFAULT.

     If an entry exists for KEY in TABLE: replace its value with the
     result of applying PROC to the old value.


File: vicare-libs.info,  Node: object-properties,  Next: one-dimension,  Prev: wtables,  Up: Top

32 Object properties
********************

An "object property" is a convenient interface to a weak hashtable,
*note Weak hashtables: wtables.  It is a function that can be called
with one or two arguments:

   * When called with two arguments: the first is an object and the
     second is its property value; they are stored in the hashtable,
     with the object being the key.

   * When called with one argument: the hashtable is queried using the
     argument as key, and the value is returned.

   Object properties are implemented by the library '(vicare containers
object-properties)'.

     *NOTE* The idea of object properties implemented in this library
     comes from Guile, the GNU Ubiquitous Interface Language for
     Extensions.

 -- Function: make-object-property HASH-FUNCTION EQUIV-FUNCTION
     Build and return a new object property.  The arguments
     HASH-FUNCTION and EQUIV-FUNCTION are handed to the weak hashtable
     constructor 'make-weak-hashtable', *note make-weak-hashtable:
     wtables.

 -- Parameter: object-property-initial-capacity
     An integer representing the suggested initial number of buckets in
     the hashtable.  The default value is 16.

 -- Parameter: object-property-default-value
     The value to return if the property is queried for an object that
     was not registered before.  The default value is the one bound to
     the sentinel (*note The sentinel object: (vicare-scheme)iklib
     sentinel.).


File: vicare-libs.info,  Node: one-dimension,  Next: arrays,  Prev: object-properties,  Up: Top

33 One dimensional extended ranges
**********************************

The one-dimension libraries implement low level operations over
generalised ranges of a coordinate.  They can be used to operate on
ranges of numbers or characters or whatever objects upon which we can
define an ordering.  There are two versions of the library:

'(vicare containers one-dimension-co)'
     Represents domains of values using disjoint half-open ranges; each
     range has a lower-included and an upper-excluded limit.

'(vicare containers one-dimension-cc)'
     Represents domains of values using disjoint double-closed ranges;
     each range has a lower-included and an upper-included limit.

   Both libraries have the same API, meaning that the functions names
and arguments are the same; the only difference in semantics is that
'(vicare containers one-dimension-co)' interprets argument ranges as
half-open, while '(vicare containers one-dimension-cc)' interprets
argument ranges as double-closed.

* Menu:

* one-dimension intro::         Data types and conventions.
* one-dimension make::          Constructors.
* one-dimension pred::          Predicates.
* one-dimension inspect::       Inspection.
* one-dimension ops::           Operations.


File: vicare-libs.info,  Node: one-dimension intro,  Next: one-dimension make,  Up: one-dimension

33.1 Data types and conventions
===============================

A "range" is a pair representing a half-open interval of items.  The car
of the pair if the included lower-limit, called START; the cdr is the
excluded upper-limit, called PAST, or the included upper-limit, called
LAST.  Empty ranges are *not* valid.

   A "domain" is a sorted list of ranges.  Empty domains are empty
lists.  Ranges in a domain do not overlap and are not contiguous.  A
domain of half-open ranges has the following format:

     ((start1 . past1) (start2 . past2) (start3 . past3) ...)

with the constraints:

     start1 < past1 < start2 < past2 < start3 < past3 < ...

a domain of double-closed ranges has the following format:

     ((start1 . last1) (start2 . last2) (start3 . last3) ...)

with the constraints:

     start1 <= last1 < start2 <= last2 < start3 <= last3 < ...

   The range and domain functions accept the following arguments:

OBJ
     Any object.

ITEM
     An object that satisfies the ITEM? predicate of the selected type.

RANGE
     A valid range according to '%range?'.

DOMAIN
     A valid domain according to '%domain?'.

START
     The included left-limit of a range.

PAST
     The excluded lower-limit of a range.

LAST
     The included upper-limit of a range.

ITEM?
     A unary predicate returning '#t' if the argument is a valid item.
     For integers it can be 'integer?', while for characters it can be
     'char?'.

     If we need to exclude some range of values, we can do it by
     properly define this function.  For example, to exclude the
     integers in the half-open range [10, 23) we can use:

          (lambda (n)
            (and (integer? n)
                 (<= 10  n)
                 (<   n 23)))

ITEM=?
     An n-ary predicate returning '#t' if the all the arguments are
     equal.  'char=?' is an example of such a function.

ITEM<?
     An n-ary predicate returning '#t' if the all the arguments, in the
     given order, are in strict increasing order.  'char<?' is an
     example of such a function.

ITEM<=?
     An n-ary predicate returning '#t' if the all the arguments, in the
     given order, are in non-strict increasing order.  'char<=?' is an
     example of such a function.

ITEM-MIN
     An n-ary function returning the minimum between its arguments.  For
     numbers it can be 'min', for characters we can use:

          (lambda (a b) (if (char<? a b) a b))

ITEM-MAX
     An n-ary function returning the maximum between its arguments.  For
     numbers it can be 'max', for characters we can use:

          (lambda (a b) (if (char<? a b) b a))

ITEM-PREV
     A binary function accepting an item and a range, or false, as
     arguments.  The second argument can be '#f', meaning that no range
     is specified, or a pair whose car is the left-limit and whose cdr
     is the right-limit; when the range is true, it is guaranteed that
     the item is inside the range.

     This function must return the value previous to item inside the
     range; if it is not possible to compute the previous value, because
     the lower bound has been reached: The function must return '#f'.

     For integers it can be:

          (lambda (x range)       ; with both (one-dimension-cc)
            (let ((x (- x 1)))    ; and (one-dimension-co)
              (if range
                  (and (<= (car range) x)
                       x)
                x)))

     for characters it can be:

          (lambda (ch range)      ; with (one-dimension-cc)
            (let* ((x  (- (char->integer ch) 1)))
              (and (number-in-range? x)
                   (let ((ch (integer->char x)))
                     (if range
                         (and (<= x (char->integer (car range)))
                              ch)
                       ch)))))

          (define (number-in-range? x)
            (or (and (<= 0 x)
                     (<  x #xD800))
                (and (<  #xDFFF x)
                     (<= x #x10FFFF))))

ITEM-NEXT
     A binary function accepting an item and a range, or false, as
     arguments.  The second argument can be '#f', meaning that no range
     is specified, or a pair whose car is the left-limit and whose cdr
     is the right-limit; when the range is true, it is guaranteed that
     the item is inside the range.

     This function must return the value next to item inside the range;
     if it is not possible to compute the next value, because the upper
     bound has been reached: The function must return '#f'.

     For integers it can be:

          (lambda (x range)       ; with (one-dimension-cc)
            (let ((x (+ 1 x)))
              (if range
                  (and (<= x (cdr range))
                       x)
                x)))

          (lambda (x range)       ; with (one-dimension-co)
            (let ((x (+ 1 x)))
              (if range
                  (and (< x (cdr range))
                       x)
                x)))

     for characters it can be:

          (lambda (ch range)      ; with (one-dimension-cc)
            (let* ((x  (+ 1 (char->integer c))))
              (and (number-in-range? x)
                   (let ((ch (integer->char x)))
                     (if range
                         (and (<= x (char->integer (cdr range)))
                              ch)
                       ch)))))

          (define (number-in-range? x)
            (or (and (<= 0 x)
                     (<  x #xD800))
                (and (<  #xDFFF x)
                     (<= x #x10FFFF))))

ITEM-MINUS
     A binary function:

        * For half-open ranges: It must return the number of items
          between the first argument included and the second argument
          excluded.

        * For double-closed ranges: It must return the number of items
          between the first argument included and the second argument
          included.

     The arithmetic '-' applied to integers is an example of such a
     function for half-open ranges; for characters and double-closed
     ranges we can use:

          (lambda (past start)
            (+ 1 (- (char->integer past)
                    (char->integer start))))

ITEM-COPY
     A unary function returning a copy of an item.  For ranges holding
     atomic values (like characters or integers) it is fine to use
     '(lambda (x) x)'.

TYPE
     A record used as type descriptor for collected items.  It is used
     as first arguments to all almost all the functions.  Type
     descriptors are built by '%make-type-descriptor'.


File: vicare-libs.info,  Node: one-dimension make,  Next: one-dimension pred,  Prev: one-dimension intro,  Up: one-dimension

33.2 Constructors
=================

 -- Function: %make-type-descriptor ITEM? ITEM=? ITEM<? ITEM<=? ITEM-MIN
          ITEM-MAX ITEM-PREV ITEM-NEXT ITEM-MINUS ITEM-COPY
     Build and return a new type descriptor.

 -- Function: %make-range TYPE START PAST
 -- Function: %make-range TYPE START LAST
     Compose START and PAST/LAST into a range.  This function validates
     the arguments to make sure the resulting range is valid.

 -- Function: %range-copy TYPE RANGE
     Return a clone of RANGE.

 -- Function: %make-domain TYPE ITEM/RANGE ...
     Build and return a new domain.  The list of ITEM/RANGE may be the
     empty list or a mixed list of items and ranges.  See
     '%domain-add-item' and '%domain-add-range' for details.

 -- Function: %domain-copy TYPE DOMAIN
     Return a newly allocated domain holding a copy of DOMAIN.

 -- Function: %domain-add-item TYPE DOMAIN OBJ
     Add the single value OBJ to DOMAIN, return the new domain.  The
     returned domain may share some structure with DOMAIN.  If OBJ does
     not satisfy the ITEM? function of TYPE: An assertion violation is
     raised.

     OBJ is interpreted as lower limit of a range and the ITEM-NEXT
     function of TYPE is used to generate the corresponding upper limit.
     If generating the next item fails: An assertion violation is
     raised.

 -- Function: %domain-add-range TYPE DOMAIN RANGE
     Add RANGE to DOMAIN, return the new domain.  The returned domain
     may share some structure with DOMAIN.

     RANGE is a pair of items; it is interpreted as double-closed range
     by '(vicare containers one-dimension-cc)' and as half-open range by
     '(vicare containers one-dimensionc-co)'.


File: vicare-libs.info,  Node: one-dimension pred,  Next: one-dimension inspect,  Prev: one-dimension make,  Up: one-dimension

33.3 Predicates
===============

Range predicates
................

 -- Function: %range? TYPE OBJ
     Return '#t' if OBJ is a valid range.

 -- Function: %range-contains? TYPE RANGE OBJ
     Return '#t' if OBJ is a member of RANGE.

 -- Function: %range=? TYPE RANGE-A RANGE-B
     Return '#t' if the ranges are equal.

 -- Function: %range<? TYPE RANGE-A RANGE-B
     Return '#t' if RANGE-A has all members less than all members of
     RANGE-B.

 -- Function: %range<=? TYPE RANGE-A RANGE-B
     Return '#t' if RANGE-A has all members less than, or equal to, all
     members of RANGE-B.

 -- Function: %range-start<? TYPE RANGE-A RANGE-B
     Return '#t' if the start of RANGE-A is less than the start of
     RANGE-B.

 -- Function: %range-start<=? TYPE RANGE-A RANGE-B
     Return '#t' if the start of RANGE-A is less than, or equal to, the
     start of RANGE-B.

 -- Function: %range-past<? TYPE RANGE-A RANGE-B
 -- Function: %range-last<? TYPE RANGE-A RANGE-B
     Return '#t' if the past/last of RANGE-A is less than the past of
     RANGE-B.

 -- Function: %range-last<=? TYPE RANGE-A RANGE-B
 -- Function: %range-past<=? TYPE RANGE-A RANGE-B
     Return '#t' if the past/last of RANGE-A is less than, or equal to,
     the past of RANGE-B.

 -- Function: %range-contiguous? TYPE RANGE-A RANGE-B
     Return '#t' if RANGE-A and RANGE-B are contiguous.  It does not
     matter which range has start less than the other.

 -- Function: %range-overlapping? TYPE RANGE-A RANGE-B
     Return '#t' if the ranges have some elements in common.

 -- Function: %range-superset? TYPE RANGE-A RANGE-B
 -- Function: %range-superset?/strict TYPE RANGE-A RANGE-B
     Return '#t' if RANGE-A is a superset or a strict superset of
     RANGE-A.

 -- Function: %range-subset? TYPE RANGE-A RANGE-B
 -- Function: %range-subset?/strict TYPE RANGE-A RANGE-B
     Return '#t' if RANGE-A is a subset or a strict subset of RANGE-A.

Domain predicates
.................

 -- Function: %domain? TYPE DOMAIN
     Return true if DOMAIN is a valid domain.

 -- Function: %domain-empty? DOMAIN
     Return true if the domain is empty.

 -- Function: %domain-contains? TYPE DOMAIN OBJ
     Return true if OBJ is an element of DOMAIN.

 -- Function: %domain=? TYPE DOMAIN-A DOMAIN-B
     Return true if the arguments represent the same domain.

 -- Function: %domain<? TYPE DOMAIN-A DOMAIN-B
     Return true if all the elements of DOMAIN-A are strictly less than
     all the elements of DOMAIN-B.  Empty domains cannot be ordered, so
     if an argument is empty the return value is '#f'.

 -- Function: %domain-subset? TYPE DOMAIN-A DOMAIN-B
 -- Function: %domain-subset?/strict TYPE DOMAIN-A DOMAIN-B
     Return '#t' if DOMAIN-A is a subset or strict subset of DOMAIN-B.

 -- Function: %domain-superset? TYPE DOMAIN-A DOMAIN-B
 -- Function: %domain-superset?/strict TYPE DOMAIN-A DOMAIN-B
     Return '#t' if DOMAIN-A is a superset or strict superset of
     DOMAIN-B.


File: vicare-libs.info,  Node: one-dimension inspect,  Next: one-dimension ops,  Prev: one-dimension pred,  Up: one-dimension

33.4 Inspection
===============

 -- Function: %range-length TYPE RANGE
     Return the number of items in the range.

 -- Function: %domain-size TYPE DOMAIN
     Return the number of items in the domain.


File: vicare-libs.info,  Node: one-dimension ops,  Prev: one-dimension inspect,  Up: one-dimension

33.5 Operations
===============

Set operations
..............

 -- Function: %range-intersection TYPE RANGE-A RANGE-B
     Return a range representing the intersection of the argument
     ranges.  It does not matter which range has start less than the
     other.

     Intersection is a closed operation on the space of ranges: The
     intersection of two ranges is a range (possibly empty).  If the
     ranges are not overlapping return '#f' to represent the empty
     range.

 -- Function: %range-union TYPE RANGE-A RANGE-B
     Return two values representing the union of the argument ranges.
     It does not matter which range has start less than the other.

     Union is *not* a closed operation on the space of ranges: The union
     of two contiguous or overlapping ranges is a single range, but the
     union of two disjoint ranges is the set holding the two argument
     ranges.

     If the argument ranges are disjoint and non-contiguous: Return two
     values being RANGE-A and RANGE-B.  If the argument ranges are
     contiguous or overlapping: Return two values being '#f' and a new
     range representing the union.

     This function should be called like this:

          (let-values (((head tail) (%range-union type r-a r-b)))
            (when head ---)
            (when tail ---))

 -- Function: %range-difference TYPE RANGE-A RANGE-B
     Return two values representing the difference between the argument
     ranges; the difference is the set of elements present in one range
     and not in the other.  It does not matter which range has start
     less than the other.

     Difference is *not* a closed operation on the space of ranges: In
     genreral the result is a couple of ranges.  The first one
     represents values which are all less than the values in the second
     one.  Both the returned values can be '#f'.

     This function should be called like this:

          (let-values (((head tail) (%range-difference type r-a r-b)))
            (when head ---)
            (when tail ---))

 -- Function: %range-in-first-only TYPE RANGE-A RANGE-B
     Return two values representing the elements of RANGE-A that are not
     in RANGE-B.

     This operation is *not* a closed operation on the space of ranges:
     In genreral the result is a couple of ranges.  The first one
     represents values which are all less than the values in the second
     one.  Both the returned values can be '#f'.

     This function should be called like this:

          (let-values (((head tail) (%range-in-first-only type r-a r-b)))
            (when head ---)
            (when tail ---))

 -- Function: %domain-intersection TYPE DOMAIN-A DOMAIN-B
     Return a new domain representing the intersection of the arguments.
     The intersection is the set of values present in both the
     arguments.

     The returned value may share some structure with the arguments.

 -- Function: %domain-union TYPE DOMAIN-A DOMAIN-B
     Return a new domain representing the union of the arguments.  The
     union is the set of values present in one and/or the other
     argument.

     The returned value may share some structure with the arguments.

 -- Function: %domain-difference TYPE DOMAIN-A DOMAIN-B
     Return a new domain representing the difference of the arguments.
     The difference is the set of values present in one or the other
     argument.

     The returned value may share some structure with the arguments.

 -- Function: %domain-complement TYPE DOMAIN DOMAIN-UNIVERSE
     Return a new domain representing the complement of DOMAIN in the
     space defined by DOMAIN-UNIVERSE.  The returned value holds all the
     items from DOMAIN-UNIVERSE that are not in DOMAIN.

     The returned value may share some structure with the arguments.

List operations
...............

 -- Function: %range-for-each TYPE PROC RANGE
     Apply PROC to each value in the range.

 -- Function: %range-every TYPE PROC RANGE
     Apply PROC to each value in the range and return true if all the
     return values are true.  The application stops at the first '#f'
     return value.

 -- Function: %range-any TYPE PROC RANGE
     Apply PROC to each value in the range and return true if at least
     one of the returned values is true.  The application stops at the
     first true return value.

 -- Function: %range-fold TYPE KONS KNIL RANGE
     Fold KONS over the values in the range.

 -- Function: %range->list TYPE RANGE
     Return a list holding all the elements in the range.

 -- Function: %domain-for-each TYPE PROC DOMAIN
     Apply PROC to each element of DOMAIN.

 -- Function: %domain-every TYPE PROC DOMAIN
     Apply PROC to each value in the domain and return true if all the
     return values are true.  The application stops at the first '#f'
     return value.

 -- Function: %domain-any TYPE PROC DOMAIN
     Apply PROC to each value in the domain and return true if at least
     one of the returned values is true.  The application stops at the
     first true return value.

 -- Function: %domain-fold TYPE KONS KNIL DOMAIN
     Fold KONS over the values in the domain.

 -- Function: %domain->list TYPE DOMAIN
     Return a list holding all the elements in the domain.

Miscellaneous operations
........................

 -- Function: %range-concatenate TYPE RANGE-A RANGE-B
     Concatenate the ranges and return the resulting range.  It does not
     matter which range has start less than the other.  It makes sense
     to apply this function to ranges that satisfy '%range-contiguous?'.

     The returned range may share some value with the original ranges.


File: vicare-libs.info,  Node: arrays,  Next: chains,  Prev: one-dimension,  Up: Top

34 Multidimensional arrays
**************************

* Menu:

* arrays coordinates::          Array item coordinates.
* arrays positions::            Array item positions.
* arrays shapes::               Array shapes.
* arrays arrays::               Arrays.
* arrays misc::                 Miscellaneous utilities.


File: vicare-libs.info,  Node: arrays coordinates,  Next: arrays positions,  Up: arrays

34.1 Array item coordinates
===========================

A single element coordinate in a multidimensional array is a
non-negative fixnum.  The following bindings are exported by the library
'(vicare containers arrays)'.

 -- Function: coordinate? OBJ
     Return '#t' if OBJ is valid as multidimensional array coordinate;
     otherwise return '#f'.

Arguments validation
....................

The following bindings are validation clauses to be used with the
facilities of the library '(vicare arguments validation)'.

 -- Validation Clause: coordinate OBJ
 -- Validation Clause: coordinate/false OBJ
     Succeed if OBJ is acceptable as multidimensional array coordinate;
     the second form accepts also '#f'.

 -- Validation Clause: list-of-coordinates OBJ
     Succeed if OBJ is a proper list of items, each acceptable as
     multidimensional array coordinate.

 -- Validation Clause: vector-of-coordinates OBJ
     Succeed if OBJ is a built-in Scheme vector, and each item is
     acceptable as multidimensional array coordinate.


File: vicare-libs.info,  Node: arrays positions,  Next: arrays shapes,  Prev: arrays coordinates,  Up: arrays

34.2 Array item positions
=========================

A single element position in a multidimensional array is described by a
'position' object; 'position' objects are disjoint from all the other
Scheme objects.

   The following bindings are exported by the library '(vicare
containers arrays)'.  Bindings prefixed by '$' are unsafe operations:
they do not validate their arguments.

Constructors
............

 -- Function: position COORD0 COORD ...
 -- Function: $position COORD0 COORD ...
     Build and return a new multidimensional array 'position' object
     containing the specified coordinates.

 -- Function: make-position DIM
 -- Function: $make-position DIM
     Build and return a new multidimensional array 'position' object of
     the specified dimension containing all '0' as coordinates.

 -- Function: vector->position VEC
 -- Function: $vector->position VEC
     Build and return a new multidimensional array 'position' object
     having the items in the given vector argument as coordinates.

 -- Function: list->position ELL
 -- Function: $list->position ELL
     Build and return a new multidimensional array 'position' object
     having the items in the given proper list argument as coordinates.

 -- Function: position-copy POS
 -- Function: $position-copy POS
     Build and return a copy of the 'position' object POS.

Predicates
..........

 -- Function: position? OBJ
     Return '#t' if OBJ is a 'position' object; otherwise return '#f'.

 -- Function: position-index? POS OBJ
 -- Function: $position-index? POS OBJ
     Return '#t' if OBJ is a valid index to select a coordinate in the
     'position' object POS; otherwise return '#f'.

     With 'position-index?': it is an error if POS is not a 'position'
     object.  With '$position-index?': the argument POS is not validated
     befor accessing it as 'position' object.

Accessors and mutators
......................

 -- Function: position-dimension POS
 -- Function: $position-dimension POS
     Return the number of coordinates of the element 'position' object
     POS.

 -- Function: position-ref POS IDX
 -- Function: $position-ref POS IDX
     Return the coordinate at index IDX in the 'position' object POS.

 -- Function: position-set! POS IDX COORD
 -- Function: $position-set! POS IDX COORD
     Store a new coordinate COORD at index IDX in the 'position' object
     POS

Comparison functions
....................

 -- Function: position=? POS0 POS ...
 -- Function: $position=? POS1 POS2
     Return '#t' if all the arguments are 'position' objects and their
     coordinates are equal.

Arguments validation
....................

The following bindings are validation clauses to be used with the
facilities of the library '(vicare arguments validation)'.

 -- Validation Clause: position OBJ
 -- Validation Clause: position/false OBJ
     Succeed if OBJ is a 'position' object; the second clause accepts
     also '#f'.

 -- Validation Clause: position-index POS OBJ
     Assuming POS is a 'position' object (this argument is *not*
     validated): succeed if OBJ is a valid index to select a coordinate
     in POS.

 -- Validation Clause: list-of-positions OBJ
     Succeed if OBJ is a proper list of items, each being a
     multidimensional array 'position' object.


File: vicare-libs.info,  Node: arrays shapes,  Next: arrays arrays,  Prev: arrays positions,  Up: arrays

34.3 Array shapes
=================


File: vicare-libs.info,  Node: arrays arrays,  Next: arrays misc,  Prev: arrays shapes,  Up: arrays

34.4 Arrays
===========


File: vicare-libs.info,  Node: arrays misc,  Prev: arrays arrays,  Up: arrays

34.5 Miscellaneous utilities
============================

Arguments validation
....................

The following bindings are validation clauses to be used with the
facilities of the library '(vicare arguments validation)'.

 -- Validation Clause: number-of-dimensions OBJ
     Succeed if OBJ is acceptable as number of dimensions for 'position'
     and 'shape' objects.


File: vicare-libs.info,  Node: chains,  Next: stacks,  Prev: arrays,  Up: Top

35 Chains of objects
********************

The library '(vicare containers chains)' implements doubly-linked lists
holding arbitrary Scheme objects.  The library '(vicare containers
chains sort)' implements a sorting algorithm.

* Menu:

* chains intro::                Introduction to chains.
* chains objects::              Chain objects.
* chains inspection::           Inspecting chain objects.
* chains access::               Chain accessors and mutators.
* chains ops::                  Basic operations on chains.
* chains folding::              Folding chains.
* chains mapping::              Mapping chains.
* chains searching::            Searching in chains.
* chains filtering::            Filtering in chains.
* chains conversion::           Converting chains to other objects.
* chains sort::                 Sorting chains.
* chains iteration thunks::     Chain iteration thunks.


File: vicare-libs.info,  Node: chains intro,  Next: chains objects,  Up: chains

35.1 Introduction to chains
===========================

To understand the chains API we need to understand the following terms:
previous link, next link, first link, last link, front link, rear link,
forwards direction, backwards direction.  Here is an explicative
picture:

     first          prev     this    next           last
      v               v       v       v               v
      O <---> O <---> O <---> O <---> O <---> O <---> O
      ^                                               ^
     front                                          rear

                      forwards direction
                    ---------------------->

                      backwards direction
                    <----------------------

   Every link in a chain is an instance of R6RS record of type
'<chain-link>'.  Every link references its previous link and next link.
Empty chains are represented by the built-in null object.


File: vicare-libs.info,  Node: chains objects,  Next: chains inspection,  Prev: chains intro,  Up: chains

35.2 Chain objects
==================

Chains are doubly-linked lists composed of '<chain-link>' instances.  In
this documentation: chain objects arguments to functions are indicated
as CHAIN, and they can be either null or instances of '<chain-link>'.

   The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- R6RS Record Type: <chain-link>
     Record type representing a link in a chain.  The '<chain-link>'
     type is non-generative and available for subtyping.  In this
     documentation '<chain-link>' object arguments to functions are
     indicated as LINK.

 -- Function: make-chain-link OBJ
     Build and return a new instance of '<chain-link>' referencing OBJ
     as payload object.

 -- Function: chain-link? OBJ
     Return '#t' if OBJ is an instance of '<chain-link>'; otherwise
     return '#f'.

 -- Function: chain OBJ ...
     Build and return a new chain holding the given objects, which are
     pushed on the chain from right to left.  If no arguments are given:
     return null.

 -- Function: chain? OBJ
     Return '#t' if OBJ is null or a a record of type '<chain-link>';
     otherwise return '#f'.

 -- Function: chain-link-ref LINK
 -- Function: $chain-link-ref LINK
     Return the payload object referenced by LINK.

 -- Function: chain-link-set! LINK NEW-OBJ
 -- Function: $chain-link-set! LINK NEW-OBJ
     Store a new object as payload for LINK.

Object properties
.................

 -- Function: chain-link-putprop LINK KEY VALUE
 -- Function: $chain-link-putprop LINK KEY VALUE
     Add a new property KEY to the property list of LINK; KEY must be a
     symbol.  If KEY is already set: the old entry is mutated to
     reference the new VALUE.

 -- Function: chain-link-getprop LINK KEY
 -- Function: $chain-link-getprop LINK KEY
     Return the value of the property KEY in the property list of LINK;
     if KEY is not set: return '#f'.  KEY must be a symbol.

 -- Function: chain-link-remprop LINK KEY
 -- Function: $chain-link-remprop LINK KEY
     Remove the property KEY from the property list of LINK; if KEY is
     not set: nothing happens.  KEY must be a symbol.

 -- Function: chain-link-property-list LINK
 -- Function: $chain-link-property-list LINK
     Return a new association list representing the property list of
     LINK.  The order of the entries is the same as the property
     creation order.

Other operations
................

 -- Function: chain-link-hash LINK
 -- Function: $chain-link-hash LINK
     Return an exact integer to be used as hashtable key for LINK.
     Hashtables having a '<chain-link>' as key can be instantiated as
     follows:

          (make-hashtable chain-link-hash eq?)


File: vicare-libs.info,  Node: chains inspection,  Next: chains access,  Prev: chains objects,  Up: chains

35.3 Inspecting chain objects
=============================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-length? CHAIN
 -- Function: $chain-length? CHAIN
     Return a non-negative exact integer representing the number of
     objects in CHAIN.  In counting the links: proceed both in forwards
     and backwards directions.  Circular chains are forbidden.

 -- Function: chain-forwards-length? CHAIN
 -- Function: $chain-forwards-length? CHAIN
     Return a non-negative exact integer representing the number of
     objects in CHAIN in the forwards direction, including CHAIN.
     Circular chains are forbidden.

 -- Function: chain-backwards-length? CHAIN
 -- Function: $chain-backwards-length? CHAIN
     Return a non-negative exact integer representing the number of
     objects in CHAIN in the backwards direction, including CHAIN.
     Circular chains are forbidden.


File: vicare-libs.info,  Node: chains access,  Next: chains ops,  Prev: chains inspection,  Up: chains

35.4 Chain accessors and mutators
=================================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-link-next LINK
 -- Function: $chain-link-next LINK
     Accessor for the next link in the forwards direction.  Return null
     or an instance of '<chain-link>'.

 -- Function: chain-link-prev LINK
 -- Function: $chain-link-prev LINK
     Accessor for the next link in the backwards direction.  Return null
     or an instance of '<chain-link>'.

 -- Function: chain-link-next-set! LINK CHAIN
 -- Function: $chain-link-next-set! LINK CHAIN
     Set the next link of LINK in the forwards direction; CHAIN can be
     null or an instance of '<chain-link>'.  If CHAIN is an instance of
     '<chain-link>': CHAIN is mutated to reference LINK as its previous
     link.

 -- Function: chain-link-prev-set! LINK CHAIN
 -- Function: $chain-link-prev-set! LINK CHAIN
     Set the next link of LINK in the backwards direction; CHAIN can be
     null or an instance of '<chain-link>'.  If CHAIN is an instance of
     '<chain-link>': CHAIN is mutated to reference LINK as its next
     link.

 -- Function: chain-front CHAIN
 -- Function: $chain-front CHAIN
     Return the first link in the chain of which CHAIN is a link; return
     the last link in the backwards direction.  Return CHAIN itself if
     CHAIN is null or the first link.  Circular chains are forbidden.

 -- Function: chain-rear CHAIN
 -- Function: $chain-rear CHAIN
     Return the last link in the chain of which CHAIN is a link; return
     the last link in the forwards direction.  Return CHAIN itself if
     CHAIN is null or the last link.  Circular chains are forbidden.

 -- Function: chain-push-front! CHAIN NEW-FRONT-LINK
 -- Function: $chain-push-front! CHAIN NEW-FRONT-LINK
     Prepend a new chain link to the chain of which CHAIN is a link;
     return NEW-FRONT-LINK itself.  If CHAIN is null: do nothing and
     return NEW-FRONT-LINK itself.

 -- Function: chain-push-rear! CHAIN NEW-REAR-LINK
 -- Function: $chain-push-rear! CHAIN NEW-REAR-LINK
     Append a new chain link to the chain of which CHAIN is a link;
     return NEW-REAR-LINK itself.  If CHAIN is null: do nothing and
     return NEW-REAR-LINK itself.

 -- Function: chain-pop-front! CHAIN
 -- Function: $chain-pop-front! CHAIN
     Remove the first link in CHAIN and return 2 values: the removed
     '<chain-link>' instance and the new first link in the chain.  If
     CHAIN is null: raise an assertion violation.  If CHAIN has only one
     link: return that link and null.

 -- Function: chain-pop-rear! CHAIN
 -- Function: $chain-pop-rear! CHAIN
     Remove the last link in CHAIN and return 2 values: the removed
     '<chain-link>' instance and the new first link in the chain.  If
     CHAIN is null: raise an assertion violation.  If CHAIN has only one
     link: return that link and null.

 -- Function: chain-link-remove! LINK
 -- Function: $chain-link-remove! LINK
     Extract LINK from its chain and return it.  The previous and next
     links, if any, are chained together.

          (let* ((A (chain 0 1 2 3 4))
                 (B (chain-link-next A))
                 (C (chain-link-next B))
                 (D (chain-link-next C))
                 (E (chain-link-next D)))
            (chain-link-remove! C)
            (values (chain->list A)
                    (chain->list C)
                    (chain->list E)))
          => (0 1 3 4) (2) (0 1 3 4)

 -- Function: chain-index-forwards! CHAIN IDX
 -- Function: $chain-index-forwards! CHAIN IDX
     Return the object referenced by the link in CHAIN at index IDX.
     IDX must be a non-negative exact integer representing a zero-based
     index; the count starts from the link CHAIN and proceeds in the
     forwards direction.

          (define C
            (chain-link-next
               (chain-link-next
                  (chain 10 11 12 13 14))))

          (chain-index-forwards C 2)      => 14

 -- Function: chain-index-backwards! CHAIN IDX
 -- Function: $chain-index-backwards! CHAIN IDX
     Return the object referenced by the link in CHAIN at index IDX.
     IDX must be a non-negative exact integer representing a zero-based
     index; the count starts from the link CHAIN and proceeds in the
     backwards direction.

          (define C
            (chain-link-next
               (chain-link-next
                  (chain 10 11 12 13 14))))

          (chain-index-backwards C 2)     => 10


File: vicare-libs.info,  Node: chains ops,  Next: chains folding,  Prev: chains access,  Up: chains

35.5 Basic operations on chains
===============================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-copy-forwards CHAIN
 -- Function: $chain-copy-forwards CHAIN
     Build and return a new chain holding all the objects from CHAIN in
     the same order.  The iteration starts at the link given as
     argument, then it proceeds in the forwards direction.

 -- Function: chain-reverse-forwards CHAIN
 -- Function: $chain-reverse-forwards CHAIN
     Build and return a new chain holding all the objects from CHAIN in
     reverse order.  The iteration starts at the link given as argument,
     then it proceeds in the forwards direction.

 -- Function: chain-append-forwards CHAIN ...
 -- Function: $chain-append-forwards CHAIN ...
     Build and return a new chain holding all the objects from the CHAIN
     arguments left-to-right order.  The iteration starts at the link
     given as argument, then it proceeds in the forwards direction.


File: vicare-libs.info,  Node: chains folding,  Next: chains mapping,  Prev: chains ops,  Up: chains

35.6 Folding chains
===================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-fold-left-forwards KONS KNIL CHAIN
 -- Function: $chain-fold-left-forwards KONS KNIL CHAIN
     Perform a 'fold-left' style iteration over the objects in CHAIN.
     The iteration starts at CHAIN and proceeds forwards.

          (chain-fold-left-forwards
              (lambda (knil obj)
                (cons obj knil))
            '()
            (chain 0 1 2 3 4))
          => (4 3 2 1 0)

          (chain-fold-left-forwards
              (lambda (knil obj)
                (cons obj knil))
            '()
            (chain-link-next
               (chain-link-next
                  (chain 0 1 2 3 4))))
          => (4 3 2)

 -- Function: chain-fold-right-forwards KONS KNIL CHAIN
 -- Function: $chain-fold-right-forwards KONS KNIL CHAIN
     Perform a 'fold-right' style iteration over the objects in CHAIN.
     The iteration starts at the last link in the forwards direction and
     proceeds up to and including CHAIN.

          (chain-fold-right-forwards
              (lambda (obj knil)
                (cons obj knil))
            '()
            (chain 0 1 2 3 4))
          => (0 1 2 3 4)

          (chain-fold-right-forwards
              (lambda (obj knil)
                (cons obj knil))
            '()
            (chain-link-next
               (chain-link-next
                  (chain 0 1 2 3 4))))
          => (2 3 4)

 -- Function: chain-fold-left-backwards KONS KNIL CHAIN
 -- Function: $chain-fold-left-backwards KONS KNIL CHAIN
     Perform a 'fold-left' style iteration over the objects in CHAIN.
     The iteration starts at CHAIN and proceeds backwards.

          (chain-fold-left-backwards
              (lambda (knil obj)
                (cons obj knil))
            '()
            (chain-rear (chain 0 1 2 3 4)))
          => (0 1 2 3 4)

          (chain-fold-left-backwards
              (lambda (knil obj)
                (cons obj knil))
            '()
            (chain-link-prev
               (chain-link-prev
                  (chain-rear (chain 0 1 2 3 4)))))
          => (0 1 2)

 -- Function: chain-fold-right-backwards KONS KNIL CHAIN
 -- Function: $chain-fold-right-backwards KONS KNIL CHAIN
     Perform a 'fold-right' style iteration over the objects in CHAIN.
     The iteration starts at the last link in the backwards direction
     and proceeds up to and including CHAIN.

          (chain-fold-right-backwards (lambda (obj knil)
                                        (cons obj knil))
            '()
            (chain-rear (chain 0 1 2 3 4)))
          => (4 3 2 1 0)

          (chain-fold-right-backwards (lambda (obj knil)
                                        (cons obj knil))
            '()
            (chain-link-prev
               (chain-link-prev
                  (chain-rear (chain 0 1 2 3 4)))))
          => (2 1 0)


File: vicare-libs.info,  Node: chains mapping,  Next: chains searching,  Prev: chains folding,  Up: chains

35.7 Mapping chains
===================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-map-forwards FUN CHAIN0 CHAIN ...
 -- Function: $chain-map-forwards FUN CHAIN0 CHAIN ...
     Map the procedure FUN over the chain arguments; build and return a
     new chain holding the results of the application.  The iteration
     starts from the link given as argument, then it proceeds in the
     forwards direction; the iteration stops when reaching the end of
     one of the chain arguments.

 -- Function: chain-for-each-forwards FUN CHAIN0 CHAIN ...
 -- Function: $chain-for-each-forwards FUN CHAIN0 CHAIN ...
     Apply the procedure FUN over the chain arguments; discard the
     results.  The last procedure application is performed in tail
     position, so its return value is the return value of the iteration;
     if one of the arguments is null: the return value is '#!void'.  The
     iteration starts from the link given as argument, then it proceeds
     in the forwards direction; the iteration stops when reaching the
     end of one of the chain arguments.


File: vicare-libs.info,  Node: chains searching,  Next: chains filtering,  Prev: chains mapping,  Up: chains

35.8 Searching in chains
========================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-for-all-forwards FUN CHAIN0 CHAIN ...
 -- Function: $chain-for-all-forwards FUN CHAIN0 CHAIN ...
     Apply the procedure FUN over the chain arguments; stop at the first
     application returning '#f' and return '#f'.  If the iteration
     reaches the end of one argument: the last procedure application is
     performed in tail position, so its return value is the return value
     of the iteration; if one of the arguments is null: the return value
     is '#t'.  The iteration starts from the link given as argument,
     then it proceeds in the forwards direction; the iteration stops
     when reaching the end of one of the chain arguments.

 -- Function: chain-exists-forwards FUN CHAIN0 CHAIN ...
 -- Function: $chain-exists-forwards FUN CHAIN0 CHAIN ...
     Apply the procedure FUN over the chain arguments; stop at the first
     application returning true and return the returned value.  If the
     iteration reaches the end of one argument: the last procedure
     application is performed in tail position, so its return value is
     the return value of the iteration; if one of the arguments is null:
     the return value is '#f'.  The iteration starts from the link given
     as argument, then it proceeds in the forwards direction; the
     iteration stops when reaching the end of one of the chain
     arguments.

 -- Function: chain-find-forwards FUN CHAIN
 -- Function: chain-find-forwards FUN CHAIN NOT-FOUND-RV
 -- Function: $chain-find-forwards FUN CHAIN NOT-FOUND-RV
     Apply the procedure FUN to the objects in CHAIN: stop at the first
     true value and return the object from CHAIN that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

     The iteration starts from the link given as argument, then it
     proceeds in the forwards direction; the iteration stops when
     reaching the end of one of the chain arguments.

          (chain-find-forwards
              even?
            (chain 1 3 5 7)
            'not-found)
          => not-found

          (chain-find-forwards
              even?
            (chain 1 3 5 7))
          => #f

          (chain-find-forwards
              even?
            (chain 1 3 5 6 7)
            'not-found)
          => 6


File: vicare-libs.info,  Node: chains filtering,  Next: chains conversion,  Prev: chains searching,  Up: chains

35.9 Filtering in chains
========================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-filter-forwards PRED CHAIN
 -- Function: chain-filter-forwards PRED CHAIN
     Build and return a new chain.  Iterate over the objects in CHAIN,
     starting from CHAIN and proceeding forwards, apply PRED to them,
     push on the rear of the return value the ones for which PRED
     returns true.

 -- Function: chain-partition-forwards PRED CHAIN
 -- Function: chain-partition-forwards PRED CHAIN
     Build and return two new chains: the matching one and the
     not-matching one.  Iterate over the objects in CHAIN, starting from
     CHAIN and proceeding forwards, and apply PRED to them: if the
     return value is true, push the object on the rear of the matching
     chain; if the return value is '#f', push the object on the rear of
     the not-matching chaing.


File: vicare-libs.info,  Node: chains conversion,  Next: chains sort,  Prev: chains filtering,  Up: chains

35.10 Converting chains to other objects
========================================

The following syntactic bindings are exported by the library '(vicare
containers chains)'.  The bindings whose name is prefixed with '$' are
unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain->list CHAIN
 -- Function: $chain->list CHAIN
 -- Function: list->chain LIST
 -- Function: $list->chain LIST
     Convert to and from a chain and a proper list.

 -- Function: chain->vector CHAIN
 -- Function: $chain->vector CHAIN
 -- Function: vector->chain VECTOR
 -- Function: $vector->chain VECTOR
     Convert to and from a chain and a vector.


File: vicare-libs.info,  Node: chains sort,  Next: chains iteration thunks,  Prev: chains conversion,  Up: chains

35.11 Sorting chains
====================

The following syntactic bindings are exported by the library '(vicare
containers chains sort)'.  The bindings whose name is prefixed with '$'
are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: chain-sort-forwards ITEM< CHAIN
 -- Function: $chain-sort-forwards ITEM< CHAIN
     Build and return a new chain holding all the objects from CHAIN
     sorted from the lesser to the greater according to the comparison
     procedure ITEM<.  The objects from CHAIN are the ones in the
     forwards direction.

     ITEM< must be a procedure accepting two objects from CHAIN and
     returning true if the first argument is less than the second
     argument.

          (let* ((C1 (chain 0 4 3 1 2 5))
                 (C2 (chain-sort-forwards < C1)))
            (chain->list C2))
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: chains iteration thunks,  Prev: chains sort,  Up: chains

35.12 Chain iteration thunks
============================

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers chains)'.

 -- Function: make-chain-forwards-iteration-thunk CHAIN
     Build and return a new iteration thunk visiting the objects from
     CHAIN.  The iteration proceeds forwards from CHAIN.

          (import (vicare)
            (vicare containers chains)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-chain-forwards-iteration-thunks (chain)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-chain-forwards-iteration-thunks (chain 0 1 2 3 4 5)))
          => (5 4 3 2 1 0)

 -- Function: make-chain-backwards-iteration-thunk CHAIN
     Build and return a new iteration thunk visiting the objects from
     CHAIN.  The iteration proceeds backwards from CHAIN.

          (import (vicare)
            (vicare containers chains)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-chain-backwards-iteration-thunks (chain)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-chain-backwards-iteration-thunks
               (chain-rear (chain 0 1 2 3 4 5))))
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: stacks,  Next: queues,  Prev: chains,  Up: Top

36 Stacks of objects
********************

The library '(vicare containers stacks)' implements stacks holding
arbitrary Scheme objects and designed for efficient last-in/first-out
operations.

* Menu:

* stacks objects::              Stack objects.
* stacks inspection::           Inspecting stack objects.
* stacks access::               Stack accessors and mutators.
* stacks folding::              Folding over stacks.
* stacks mapping::              Mapping over stacks.
* stacks searching::            Searching in stacks.
* stacks filtering::            Filtering in stacks.
* stacks conversion::           Converting stacks to other objects.
* stacks iteration thunks::     Stack iteration thunks.
* stacks misc::                 Miscellaneous operations on stacks.


File: vicare-libs.info,  Node: stacks objects,  Next: stacks inspection,  Up: stacks

36.1 Stack objects
==================

Stacks are implemented as doubly-linked lists of vector objects; each
vector acts as buffer for contained objects; all the vectors have the
same length.

   The following syntactic bindings are exported by the library '(vicare
containers stacks)'.

 -- R6RS Record Type: <stack>
     Record type representing a stack object.  The '<stack>' type is
     non-generative and available for subtyping.  In this documentation
     '<stack>' object arguments to functions are indicated as STACK.

 -- Function: make-stack
 -- Function: make-stack BUFFER-LENGTH
     Build and return a new '<stack>' object.  The optional argument
     BUFFER-LENGTH must be a non-negative fixnum representing the number
     of slots in the internal object buffers; when not given, it
     defaults to 15.

 -- Function: stack? OBJ
     Return '#t' if OBJ is a record of type '<stack>'; otherwise return
     '#f'.

 -- Function: stack OBJ ...
     Build and return a '<stack>' object holding the given objects,
     which are pushed on the stack right-to-left from the bottom side.
     The size of the internal buffers is set to the default.

          (define D
            (stack 0 1 2))

          (stack-top D)         => 0

Object properties
.................

 -- Function: stack-putprop STACK KEY VALUE
 -- Function: $stack-putprop STACK KEY VALUE
     Add a new property KEY to the property list of STACK; KEY must be a
     symbol.  If KEY is already set: the old entry is mutated to
     reference the new VALUE.

 -- Function: stack-getprop STACK KEY
 -- Function: $stack-getprop STACK KEY
     Return the value of the property KEY in the property list of STACK;
     if KEY is not set: return '#f'.  KEY must be a symbol.

 -- Function: stack-remprop STACK KEY
 -- Function: $stack-remprop STACK KEY
     Remove the property KEY from the property list of STACK; if KEY is
     not set: nothing happens.  KEY must be a symbol.

 -- Function: stack-property-list STACK
 -- Function: $stack-property-list STACK
     Return a new association list representing the property list of
     STACK.  The order of the entries is the same as the property
     creation order.

Other operations
................

 -- Function: stack-hash STACK
 -- Function: $stack-hash STACK
     Return an exact integer to be used as hashtable key for STACK.
     Hashtables having a '<stack>' as key can be instantiated as
     follows:

          (make-hashtable stack-hash eq?)


File: vicare-libs.info,  Node: stacks inspection,  Next: stacks access,  Prev: stacks objects,  Up: stacks

36.2 Inspecting stack objects
=============================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-empty? STACK
 -- Function: $stack-empty? STACK
     Return '#t' if STACK is empty; otherwise return '#f'.

 -- Function: stack-not-empty? STACK
 -- Function: $stack-not-empty? STACK
     Return '#t' if STACK is *not* empty; otherwise return '#f'.

 -- Function: stack-size? STACK
 -- Function: $stack-size? STACK
     Return an exact integer representing the number of objects in
     STACK.


File: vicare-libs.info,  Node: stacks access,  Next: stacks folding,  Prev: stacks inspection,  Up: stacks

36.3 Stack accessors and mutators
=================================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-top STACK
 -- Function: $stack-top STACK
     Return the object at the top of the stack.  Raise an assertion
     violation if STACK is empty.

 -- Function: stack-push! STACK OBJ
 -- Function: $stack-push! STACK OBJ
     Push OBJ on the top of the STACK.

 -- Function: stack-pop! STACK
 -- Function: $stack-pop! STACK
     Remove the object at the top of the stack and return it.  Raise an
     assertion violation if STACK is empty.

 -- Function: stack-purge! STACK
 -- Function: $stack-purge! STACK
     Remove all the elements from STACK.


File: vicare-libs.info,  Node: stacks folding,  Next: stacks mapping,  Prev: stacks access,  Up: stacks

36.4 Folding over stacks
========================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-fold-left KONS KNIL STACK
 -- Function: $stack-fold-left KONS KNIL STACK
     Analogous to 'fold-left' for lists.  Fold the procedure KONS over
     the objects from STACK, starting from the top.

          (define D
            (stack 0 1 2 3 4 5))

          (stack-fold-left (lambda (knil obj)
                             (cons obj knil))
            '() D)
          => (5 4 3 2 1 0)

 -- Function: stack-fold-right KONS KNIL STACK
 -- Function: $stack-fold-right KONS KNIL STACK
     Analogous to 'fold-right' for lists.  Fold the procedure KONS over
     the objects from STACK, starting from the bottom.

          (define D
            (stack 0 1 2 3 4 5))

          (stack-fold-right (lambda (obj knil)
                              (cons obj knil))
            '() D)
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: stacks mapping,  Next: stacks searching,  Prev: stacks folding,  Up: stacks

36.5 Mapping over stacks
========================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-map-left DST-STACK FUN SRC-STACK
 -- Function: $stack-map-left DST-STACK FUN SRC-STACK
     Iterate over all the objects in SRC-STACK, starting from the top
     side, apply FUN to them, push the result of the application in the
     bottom side of DST-STACK.

          (stack->list
            (stack-map-left (stack) - (stack 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-STACK argument allows us to build the destination stack
     with the desired configuration parameters.

 -- Function: stack-map-right DST-STACK FUN SRC-STACK
 -- Function: $stack-map-right DST-STACK FUN SRC-STACK
     Iterate over all the objects in SRC-STACK, starting from the bottom
     side, apply FUN to them, push the result of the application in the
     top side of DST-STACK.

          (stack->list
            (stack-map-right (stack) - (stack 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-STACK argument allows us to build the destination stack
     with the desired configuration parameters.

 -- Function: stack-map FUN STACK
 -- Function: $stack-map FUN STACK
     Aliases for 'stack-map-left' and '$stack-map-left'.

 -- Function: stack-for-each-left FUN STACK
 -- Function: $stack-for-each-left FUN STACK
     Iterate over all the objects in STACK, starting from the top side,
     and apply FUN to them discarding the return value.

 -- Function: stack-for-each-right FUN STACK
 -- Function: $stack-for-each-right FUN STACK
     Iterate over all the objects in STACK, starting from the bottom
     side, and apply FUN to them discarding the return value.

 -- Function: stack-for-each FUN STACK
 -- Function: $stack-for-each FUN STACK
     Aliases for 'stack-for-each-left' and '$stack-for-each-left'.


File: vicare-libs.info,  Node: stacks searching,  Next: stacks filtering,  Prev: stacks mapping,  Up: stacks

36.6 Searching in stacks
========================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-for-all FUN STACK
 -- Function: $stack-for-all FUN STACK
     Apply the procedure FUN over the objects in STACK, starting from
     the top side; stop at the first application returning '#f' and
     return '#f'.  If the iteration reaches the end of the stack: the
     return value is the result of applying FUN to the last object in
     the stack.  If the stack is empty: the return value is '#t'.

 -- Function: stack-exists-left FUN STACK
 -- Function: $stack-exists-left FUN STACK
     Apply the procedure FUN over the objects in STACK, starting from
     the top side; stop at the first application returning true and
     return the returned value.  If the stack is empty: the return value
     is '#f'.

 -- Function: stack-exists-right FUN STACK
 -- Function: $stack-exists-right FUN STACK
     Apply the procedure FUN over the objects in STACK, starting from
     the bottom side; stop at the first application returning true and
     return the returned value.  If the stack is empty: the return value
     is '#f'.

 -- Function: stack-exists FUN STACK
 -- Function: $stack-exists FUN STACK
     Aliases for 'stack-exists-left' and '$stack-exists-left'.

 -- Function: stack-find-left FUN STACK
 -- Function: stack-find-left FUN STACK NOT-FOUND-RV
 -- Function: $stack-find-left FUN STACK NOT-FOUND-RV
     Apply the procedure FUN to the objects in STACK, starting from the
     top side: stop at the first true value and return the object from
     STACK that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

          (stack-find-left
              even?
            (stack 1 3 5 7)
            'not-found)
          => not-found

          (stack-find-left
              even?
            (stack 1 3 5 7))
          => #f

          (stack-find-left
              even?
            (stack 1 3 5 6 7)
            'not-found)
          => 6

 -- Function: stack-find-right FUN STACK
 -- Function: stack-find-right FUN STACK NOT-FOUND-RV
 -- Function: $stack-find-right FUN STACK NOT-FOUND-RV
     Apply the procedure FUN to the objects in STACK, starting from the
     bottom side: stop at the first true value and return the object
     from STACK that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

 -- Function: stack-find FUN STACK
 -- Function: stack-find FUN STACK NOT-FOUND-RV
 -- Function: $stack-find FUN STACK NOT-FOUND-RV
     Aliases for 'stack-find-left' and '$stack-find-left'.


File: vicare-libs.info,  Node: stacks filtering,  Next: stacks conversion,  Prev: stacks searching,  Up: stacks

36.7 Filtering in stacks
========================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-filter DST-STACK PRED SRC-STACK
 -- Function: $stack-filter DST-STACK PRED SRC-STACK
     Iterate over the objects in SRC-STACK starting from the top side,
     apply PRED to them, push on the bottom of DST-STACK the ones for
     which PRED returns true.  Return DST-STACK itself.

     The argument DST-STACK allows us to build and configure a stack
     with the needed parameters.

 -- Function: stack-partition MATCH-STACK NO-MATCH-STACK PRED SRC-STACK
 -- Function: $stack-partition MATCH-STACK NO-MATCH-STACK PRED SRC-STACK
     Iterate over the objects in SRC-STACK, starting from the top side,
     and apply PRED to them: if the return value is true, push the
     object on the bottom of MATCH-STACK; if the return value is '#f',
     push the object on the bottom of NO-MATCH-STACK.  Return two
     values: MATCH-STACK and NO-MATCH-STACK.

     The arguments MATCH-STACK and NO-MATCH-STACK allow us to build and
     configure stacks with the needed parameters.


File: vicare-libs.info,  Node: stacks conversion,  Next: stacks iteration thunks,  Prev: stacks filtering,  Up: stacks

36.8 Converting stacks to other objects
=======================================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack->list STACK
 -- Function: $stack->list STACK
 -- Function: list->stack LIST
 -- Function: $list->stack LIST
     Convert to and from a stack and a proper list.  Objects from the
     list are pushed on the stack left-to-right from the bottom side.

          (define D
            (list->stack '(0 1 2)))

          (stack-top   D)        => 0
          (stack->list D)        => (0 1 2)

 -- Function: stack->vector STACK
 -- Function: $stack->vector STACK
 -- Function: vector->stack VECTOR
 -- Function: $vector->stack VECTOR
     Convert to and from a stack and a vector.  Objects from the vector
     are pushed on the stack left-to-right from the bottom side.

          (define D
            (vector->stack '#(0 1 2)))

          (stack-top     D)       => 0
          (stack->vector D)       => #(0 1 2)


File: vicare-libs.info,  Node: stacks iteration thunks,  Next: stacks misc,  Prev: stacks conversion,  Up: stacks

36.9 Stack iteration thunks
===========================

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers stacks)'.

 -- Function: make-stack-iteration-thunk STACK
     Build and return a new iteration thunk popping the objects from
     STACK.

          (import (vicare)
            (vicare containers stacks)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-stack-iteration-thunks (stack)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-stack-iteration-thunks (stack 0 1 2 3 4 5)))
          => (5 4 3 2 1 0)


File: vicare-libs.info,  Node: stacks misc,  Prev: stacks iteration thunks,  Up: stacks

36.10 Miscellaneous operations on stacks
========================================

The following syntactic bindings are exported by the library '(vicare
containers stacks)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: stack-copy! DST-STACK SRC-STACK
 -- Function: $stack-copy! DST-STACK SRC-STACK
     Iterate over all the objects in SRC-STACK, starting from the top
     side, and push them in the bottom side of DST-STACK.  This is a
     shallow copy: the very objects from the source stack are added to
     the destination stack; if we need to duplicate the objects, we can
     use the map operation.

     The DST-STACK argument allows us to build the destination stack
     with the desired configuration parameters.

 -- Function: stack-reverse! DST-STACK SRC-STACK
 -- Function: $stack-reverse! DST-STACK SRC-STACK
     Iterate over the objects in SRC-STACK, starting from the top side,
     and push them in the top side of DST-STACK.  Return DST-STACK.

     The DST-STACK argument allows us to build the destination stack
     with the desired configuration parameters.


File: vicare-libs.info,  Node: queues,  Next: deques,  Prev: stacks,  Up: Top

37 Simple queues
****************

The library '(vicare containers queues)' implements queues (pronounced
"kews") holding arbitrary Scheme objects and designed for efficient
first-in/first-out operations.

* Menu:

* queues objects::              Queue objects.
* queues inspection::           Inspecting queue objects.
* queues access::               Queue accessors and mutators.
* queues folding::              Folding over queues.
* queues mapping::              Mapping over queues.
* queues searching::            Searching in queues.
* queues filtering::            Filtering in queues.
* queues conversion::           Converting queues to other objects.
* queues iteration thunks::     Queue iteration thunks.
* queues misc::                 Miscellaneous operations on queues.


File: vicare-libs.info,  Node: queues objects,  Next: queues inspection,  Up: queues

37.1 Queue objects
==================

Queues are implemented as doubly-linked lists of vector objects; each
vector acts as buffer for contained objects; all the vectors have the
same length.

   The following syntactic bindings are exported by the library '(vicare
containers queues)'.

 -- R6RS Record Type: <queue>
     Record type representing a queue object.  The '<queue>' type is
     non-generative and available for subtyping.  In this documentation
     '<queue>' object arguments to functions are indicated as QUEUE.

 -- Function: make-queue
 -- Function: make-queue BUFFER-LENGTH
     Build and return a new '<queue>' object.  The optional argument
     BUFFER-LENGTH must be a non-negative fixnum representing the number
     of slots in the internal object buffers; when not given, it
     defaults to 15.

 -- Function: queue? OBJ
     Return '#t' if OBJ is a record of type '<queue>'; otherwise return
     '#f'.

 -- Function: queue OBJ ...
     Build and return a '<queue>' object holding the given objects,
     which are pushed on the queue left to right from the rear side.
     The size of the internal buffers is set to the default.

          (define D
            (queue 0 1 2))

          (queue-front D)         => 0
          (queue-rear  D)         => 2

Object properties
.................

 -- Function: queue-putprop QUEUE KEY VALUE
 -- Function: $queue-putprop QUEUE KEY VALUE
     Add a new property KEY to the property list of QUEUE; KEY must be a
     symbol.  If KEY is already set: the old entry is mutated to
     reference the new VALUE.

 -- Function: queue-getprop QUEUE KEY
 -- Function: $queue-getprop QUEUE KEY
     Return the value of the property KEY in the property list of QUEUE;
     if KEY is not set: return '#f'.  KEY must be a symbol.

 -- Function: queue-remprop QUEUE KEY
 -- Function: $queue-remprop QUEUE KEY
     Remove the property KEY from the property list of QUEUE; if KEY is
     not set: nothing happens.  KEY must be a symbol.

 -- Function: queue-property-list QUEUE
 -- Function: $queue-property-list QUEUE
     Return a new association list representing the property list of
     QUEUE.  The order of the entries is the same as the property
     creation order.

Other operations
................

 -- Function: queue-hash QUEUE
 -- Function: $queue-hash QUEUE
     Return an exact integer to be used as hashtable key for QUEUE.
     Hashtables having a '<queue>' as key can be instantiated as
     follows:

          (make-hashtable queue-hash eq?)


File: vicare-libs.info,  Node: queues inspection,  Next: queues access,  Prev: queues objects,  Up: queues

37.2 Inspecting queue objects
=============================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-empty? QUEUE
 -- Function: $queue-empty? QUEUE
     Return '#t' if QUEUE is empty; otherwise return '#f'.

 -- Function: queue-not-empty? QUEUE
 -- Function: $queue-not-empty? QUEUE
     Return '#t' if QUEUE is *not* empty; otherwise return '#f'.

 -- Function: queue-size? QUEUE
 -- Function: $queue-size? QUEUE
     Return an exact integer representing the number of objects in
     QUEUE.


File: vicare-libs.info,  Node: queues access,  Next: queues folding,  Prev: queues inspection,  Up: queues

37.3 Queue accessors and mutators
=================================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-front QUEUE
 -- Function: $queue-front QUEUE
     Return the object at the front of the queue.  Raise an assertion
     violation if QUEUE is empty.

 -- Function: queue-rear QUEUE
 -- Function: $queue-rear QUEUE
     Return the object at the front of the queue.  Raise an assertion
     violation if QUEUE is empty.

 -- Function: queue-push! QUEUE OBJ
 -- Function: $queue-push! QUEUE OBJ
     Push OBJ on the front of the QUEUE.

 -- Function: queue-pop! QUEUE
 -- Function: $queue-pop! QUEUE
     Remove the object at the rear of the queue and return it.  Raise an
     assertion violation if QUEUE is empty.

 -- Function: queue-purge! QUEUE
 -- Function: $queue-purge! QUEUE
     Remove all the elements from QUEUE.


File: vicare-libs.info,  Node: queues folding,  Next: queues mapping,  Prev: queues access,  Up: queues

37.4 Folding over queues
========================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-fold-left KONS KNIL QUEUE
 -- Function: $queue-fold-left KONS KNIL QUEUE
     Analogous to 'fold-left' for lists.  Fold the procedure KONS over
     the objects from QUEUE, starting from the front.

          (define D
            (queue 0 1 2 3 4 5))

          (queue-fold-left (lambda (knil obj)
                             (cons obj knil))
            '() D)
          => (5 4 3 2 1 0)

 -- Function: queue-fold-right KONS KNIL QUEUE
 -- Function: $queue-fold-right KONS KNIL QUEUE
     Analogous to 'fold-right' for lists.  Fold the procedure KONS over
     the objects from QUEUE, starting from the rear.

          (define D
            (queue 0 1 2 3 4 5))

          (queue-fold-right (lambda (obj knil)
                              (cons obj knil))
            '() D)
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: queues mapping,  Next: queues searching,  Prev: queues folding,  Up: queues

37.5 Mapping over queues
========================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-map-left DST-QUEUE FUN SRC-QUEUE
 -- Function: $queue-map-left DST-QUEUE FUN SRC-QUEUE
     Iterate over all the objects in SRC-QUEUE, starting from the front
     side, apply FUN to them, push the result of the application in the
     rear side of DST-QUEUE.

          (queue->list
            (queue-map-left (queue) - (queue 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-QUEUE argument allows us to build the destination queue
     with the desired configuration parameters.

 -- Function: queue-map-right DST-QUEUE FUN SRC-QUEUE
 -- Function: $queue-map-right DST-QUEUE FUN SRC-QUEUE
     Iterate over all the objects in SRC-QUEUE, starting from the rear
     side, apply FUN to them, push the result of the application in the
     front side of DST-QUEUE.

          (queue->list
            (queue-map-right (queue) - (queue 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-QUEUE argument allows us to build the destination queue
     with the desired configuration parameters.

 -- Function: queue-map FUN QUEUE
 -- Function: $queue-map FUN QUEUE
     Aliases for 'queue-map-left' and '$queue-map-left'.

 -- Function: queue-for-each-left FUN QUEUE
 -- Function: $queue-for-each-left FUN QUEUE
     Iterate over all the objects in QUEUE, starting from the front
     side, and apply FUN to them discarding the return value.

 -- Function: queue-for-each-right FUN QUEUE
 -- Function: $queue-for-each-right FUN QUEUE
     Iterate over all the objects in QUEUE, starting from the rear side,
     and apply FUN to them discarding the return value.

 -- Function: queue-for-each FUN QUEUE
 -- Function: $queue-for-each FUN QUEUE
     Aliases for 'queue-for-each-left' and '$queue-for-each-left'.


File: vicare-libs.info,  Node: queues searching,  Next: queues filtering,  Prev: queues mapping,  Up: queues

37.6 Searching in queues
========================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-for-all FUN QUEUE
 -- Function: $queue-for-all FUN QUEUE
     Apply the procedure FUN over the objects in QUEUE, starting from
     the front side; stop at the first application returning '#f' and
     return '#f'.  If the iteration reaches the end of the queue: the
     return value is the result of applying FUN to the last object in
     the queue.  If the queue is empty: the return value is '#t'.

 -- Function: queue-exists-left FUN QUEUE
 -- Function: $queue-exists-left FUN QUEUE
     Apply the procedure FUN over the objects in QUEUE, starting from
     the front side; stop at the first application returning true and
     return the returned value.  If the queue is empty: the return value
     is '#f'.

 -- Function: queue-exists-right FUN QUEUE
 -- Function: $queue-exists-right FUN QUEUE
     Apply the procedure FUN over the objects in QUEUE, starting from
     the rear side; stop at the first application returning true and
     return the returned value.  If the queue is empty: the return value
     is '#f'.

 -- Function: queue-exists FUN QUEUE
 -- Function: $queue-exists FUN QUEUE
     Aliases for 'queue-exists-left' and '$queue-exists-left'.

 -- Function: queue-find-left FUN QUEUE
 -- Function: queue-find-left FUN QUEUE NOT-FOUND-RV
 -- Function: $queue-find-left FUN QUEUE NOT-FOUND-RV
     Apply the procedure FUN to the objects in QUEUE, starting from the
     front side: stop at the first true value and return the object from
     QUEUE that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

          (queue-find-left
              even?
            (queue 1 3 5 7)
            'not-found)
          => not-found

          (queue-find-left
              even?
            (queue 1 3 5 7))
          => #f

          (queue-find-left
              even?
            (queue 1 3 5 6 7)
            'not-found)
          => 6

 -- Function: queue-find-right FUN QUEUE
 -- Function: queue-find-right FUN QUEUE NOT-FOUND-RV
 -- Function: $queue-find-right FUN QUEUE NOT-FOUND-RV
     Apply the procedure FUN to the objects in QUEUE, starting from the
     rear side: stop at the first true value and return the object from
     QUEUE that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

 -- Function: queue-find FUN QUEUE
 -- Function: queue-find FUN QUEUE NOT-FOUND-RV
 -- Function: $queue-find FUN QUEUE NOT-FOUND-RV
     Aliases for 'queue-find-left' and '$queue-find-left'.


File: vicare-libs.info,  Node: queues filtering,  Next: queues conversion,  Prev: queues searching,  Up: queues

37.7 Filtering in queues
========================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-filter DST-QUEUE PRED SRC-QUEUE
 -- Function: $queue-filter DST-QUEUE PRED SRC-QUEUE
     Iterate over the objects in SRC-QUEUE starting from the front side,
     apply PRED to them, push on the rear of DST-QUEUE the ones for
     which PRED returns true.  Return DST-QUEUE itself.

     The argument DST-QUEUE allows us to build and configure a queue
     with the needed parameters.

 -- Function: queue-partition MATCH-QUEUE NO-MATCH-QUEUE PRED SRC-QUEUE
 -- Function: $queue-partition MATCH-QUEUE NO-MATCH-QUEUE PRED SRC-QUEUE
     Iterate over the objects in SRC-QUEUE, starting from the front
     side, and apply PRED to them: if the return value is true, push the
     object on the rear of MATCH-QUEUE; if the return value is '#f',
     push the object on the rear of NO-MATCH-QUEUE.  Return two values:
     MATCH-QUEUE and NO-MATCH-QUEUE.

     The arguments MATCH-QUEUE and NO-MATCH-QUEUE allow us to build and
     configure queues with the needed parameters.


File: vicare-libs.info,  Node: queues conversion,  Next: queues iteration thunks,  Prev: queues filtering,  Up: queues

37.8 Converting queues to other objects
=======================================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue->list QUEUE
 -- Function: $queue->list QUEUE
 -- Function: list->queue LIST
 -- Function: $list->queue LIST
     Convert to and from a queue and a proper list.  Objects from the
     list are pushed on the queue left-to-right from the rear side.

          (define D
            (list->queue '(0 1 2)))

          (queue-front D)         => 0
          (queue-rear  D)         => 2
          (queue->list D)         => (0 1 2)

 -- Function: queue->vector QUEUE
 -- Function: $queue->vector QUEUE
 -- Function: vector->queue VECTOR
 -- Function: $vector->queue VECTOR
     Convert to and from a queue and a vector.  Objects from the vector
     are pushed on the queue left-to-right from the rear side.

          (define D
            (vector->queue '#(0 1 2)))

          (queue-front   D)       => 0
          (queue-rear    D)       => 2
          (queue->vector D)       => #(0 1 2)


File: vicare-libs.info,  Node: queues iteration thunks,  Next: queues misc,  Prev: queues conversion,  Up: queues

37.9 Queue iteration thunks
===========================

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers queues)'.

 -- Function: make-queue-iteration-thunk QUEUE
     Build and return a new iteration thunk popping the objects from
     QUEUE.

          (import (vicare)
            (vicare containers queues)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-queue-iteration-thunks (queue)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-queue-iteration-thunks (queue 0 1 2 3 4 5)))
          => (5 4 3 2 1 0)


File: vicare-libs.info,  Node: queues misc,  Prev: queues iteration thunks,  Up: queues

37.10 Miscellaneous operations on queues
========================================

The following syntactic bindings are exported by the library '(vicare
containers queues)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: queue-copy! DST-QUEUE SRC-QUEUE
 -- Function: $queue-copy! DST-QUEUE SRC-QUEUE
     Iterate over all the objects in SRC-QUEUE, starting from the front
     side, and push them in the rear side of DST-QUEUE.  This is a
     shallow copy: the very objects from the source queue are added to
     the destination queue; if we need to duplicate the objects, we can
     use the map operation.

     The DST-QUEUE argument allows us to build the destination queue
     with the desired configuration parameters.

 -- Function: queue-reverse! DST-QUEUE SRC-QUEUE
 -- Function: $queue-reverse! DST-QUEUE SRC-QUEUE
     Iterate over the objects in SRC-QUEUE, starting from the front
     side, and push them in the front side of DST-QUEUE.  Return
     DST-QUEUE.

     The DST-QUEUE argument allows us to build the destination queue
     with the desired configuration parameters.


File: vicare-libs.info,  Node: deques,  Next: binary heaps,  Prev: queues,  Up: Top

38 Double-ended queues of objects
*********************************

The library '(vicare containers deques)' implements deques (pronounced
"decks") holding arbitrary Scheme objects and designed for efficient
insertion and removal at both ends.

* Menu:

* deques objects::              Deque objects.
* deques inspection::           Inspecting deque objects.
* deques access::               Deque accessors and mutators.
* deques folding::              Folding over deques.
* deques mapping::              Mapping over deques.
* deques searching::            Searching in deques.
* deques filtering::            Filtering in deques.
* deques conversion::           Converting deques to other objects.
* deques iteration thunks::     Deque iteration thunks.
* deques misc::                 Miscellaneous operations on deques.


File: vicare-libs.info,  Node: deques objects,  Next: deques inspection,  Up: deques

38.1 Deque objects
==================

Deques are implemented as doubly-linked lists of vector objects; each
vector acts as buffer for contained objects; all the vectors have the
same length.

   The following syntactic bindings are exported by the library '(vicare
containers deques)'.

 -- R6RS Record Type: <deque>
     Record type representing a deque object.  The '<deque>' type is
     non-generative and available for subtyping.  In this documentation
     '<deque>' object arguments to functions are indicated as DEQUE.

 -- Function: make-deque
 -- Function: make-deque BUFFER-LENGTH
     Build and return a new '<deque>' object.  The optional argument
     BUFFER-LENGTH must be a non-negative fixnum representing the number
     of slots in the internal object buffers; when not given, it
     defaults to 15.

 -- Function: deque? OBJ
     Return '#t' if OBJ is a record of type '<deque>'; otherwise return
     '#f'.

 -- Function: deque OBJ ...
     Build and return a '<deque>' object holding the given objects,
     which are pushed on the deque left to right from the rear side.
     The size of the internal buffers is set to the default.

          (define D
            (deque 0 1 2))

          (deque-front D)         => 0
          (deque-rear  D)         => 2

Object properties
.................

 -- Function: deque-putprop DEQUE KEY VALUE
 -- Function: $deque-putprop DEQUE KEY VALUE
     Add a new property KEY to the property list of DEQUE; KEY must be a
     symbol.  If KEY is already set: the old entry is mutated to
     reference the new VALUE.

 -- Function: deque-getprop DEQUE KEY
 -- Function: $deque-getprop DEQUE KEY
     Return the value of the property KEY in the property list of DEQUE;
     if KEY is not set: return '#f'.  KEY must be a symbol.

 -- Function: deque-remprop DEQUE KEY
 -- Function: $deque-remprop DEQUE KEY
     Remove the property KEY from the property list of DEQUE; if KEY is
     not set: nothing happens.  KEY must be a symbol.

 -- Function: deque-property-list DEQUE
 -- Function: $deque-property-list DEQUE
     Return a new association list representing the property list of
     DEQUE.  The order of the entries is the same as the property
     creation order.

Other operations
................

 -- Function: deque-hash DEQUE
 -- Function: $deque-hash DEQUE
     Return an exact integer to be used as hashtable key for DEQUE.
     Hashtables having a '<deque>' as key can be instantiated as
     follows:

          (make-hashtable deque-hash eq?)


File: vicare-libs.info,  Node: deques inspection,  Next: deques access,  Prev: deques objects,  Up: deques

38.2 Inspecting deque objects
=============================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-empty? DEQUE
 -- Function: $deque-empty? DEQUE
     Return '#t' if DEQUE is empty; otherwise return '#f'.

 -- Function: deque-not-empty? DEQUE
 -- Function: $deque-not-empty? DEQUE
     Return '#t' if DEQUE is *not* empty; otherwise return '#f'.

 -- Function: deque-size? DEQUE
 -- Function: $deque-size? DEQUE
     Return an exact integer representing the number of objects in
     DEQUE.


File: vicare-libs.info,  Node: deques access,  Next: deques folding,  Prev: deques inspection,  Up: deques

38.3 Deque accessors and mutators
=================================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-front DEQUE
 -- Function: $deque-front DEQUE
     Return the object at the front of the deque.  Raise an assertion
     violation if DEQUE is empty.

 -- Function: deque-rear DEQUE
 -- Function: $deque-rear DEQUE
     Return the object at the rear of the deque.  Raise an assertion
     violation if DEQUE is empty.

 -- Function: deque-push-front! DEQUE OBJ
 -- Function: $deque-push-front! DEQUE OBJ
     Push OBJ on the front of the DEQUE.

 -- Function: deque-push-rear! DEQUE OBJ
 -- Function: $deque-push-rear! DEQUE OBJ
     Push OBJ on the rear of the DEQUE.

 -- Function: deque-pop-front! DEQUE
 -- Function: $deque-pop-front! DEQUE
     Remove the object at the front of the deque and return it.  Raise
     an assertion violation if DEQUE is empty.

 -- Function: deque-pop-rear! DEQUE
 -- Function: $deque-pop-rear! DEQUE
     Remove the object at the rear of the deque and return it.  Raise an
     assertion violation if DEQUE is empty.

 -- Function: deque-purge! DEQUE
 -- Function: $deque-purge! DEQUE
     Remove all the elements from DEQUE.


File: vicare-libs.info,  Node: deques folding,  Next: deques mapping,  Prev: deques access,  Up: deques

38.4 Folding over deques
========================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-fold-left KONS KNIL DEQUE
 -- Function: $deque-fold-left KONS KNIL DEQUE
     Analogous to 'fold-left' for lists.  Fold the procedure KONS over
     the objects from DEQUE, starting from the front.

          (define D
            (deque 0 1 2 3 4 5))

          (deque-fold-left (lambda (knil obj)
                             (cons obj knil))
            '() D)
          => (5 4 3 2 1 0)

 -- Function: deque-fold-right KONS KNIL DEQUE
 -- Function: $deque-fold-right KONS KNIL DEQUE
     Analogous to 'fold-right' for lists.  Fold the procedure KONS over
     the objects from DEQUE, starting from the rear.

          (define D
            (deque 0 1 2 3 4 5))

          (deque-fold-right (lambda (obj knil)
                              (cons obj knil))
            '() D)
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: deques mapping,  Next: deques searching,  Prev: deques folding,  Up: deques

38.5 Mapping over deques
========================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-map-left DST-DEQUE FUN SRC-DEQUE
 -- Function: $deque-map-left DST-DEQUE FUN SRC-DEQUE
     Iterate over all the objects in SRC-DEQUE, starting from the front
     side, apply FUN to them, push the result of the application in the
     rear side of DST-DEQUE.

          (deque->list
            (deque-map-left (deque) - (deque 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-DEQUE argument allows us to build the destination deque
     with the desired configuration parameters.

 -- Function: deque-map-right DST-DEQUE FUN SRC-DEQUE
 -- Function: $deque-map-right DST-DEQUE FUN SRC-DEQUE
     Iterate over all the objects in SRC-DEQUE, starting from the rear
     side, apply FUN to them, push the result of the application in the
     front side of DST-DEQUE.

          (deque->list
            (deque-map-right (deque) - (deque 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-DEQUE argument allows us to build the destination deque
     with the desired configuration parameters.

 -- Function: deque-map FUN DEQUE
 -- Function: $deque-map FUN DEQUE
     Aliases for 'deque-map-left' and '$deque-map-left'.

 -- Function: deque-for-each-left FUN DEQUE
 -- Function: $deque-for-each-left FUN DEQUE
     Iterate over all the objects in DEQUE, starting from the front
     side, and apply FUN to them discarding the return value.

 -- Function: deque-for-each-right FUN DEQUE
 -- Function: $deque-for-each-right FUN DEQUE
     Iterate over all the objects in DEQUE, starting from the rear side,
     and apply FUN to them discarding the return value.

 -- Function: deque-for-each FUN DEQUE
 -- Function: $deque-for-each FUN DEQUE
     Aliases for 'deque-for-each-left' and '$deque-for-each-left'.


File: vicare-libs.info,  Node: deques searching,  Next: deques filtering,  Prev: deques mapping,  Up: deques

38.6 Searching in deques
========================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-for-all FUN DEQUE
 -- Function: $deque-for-all FUN DEQUE
     Apply the procedure FUN over the objects in DEQUE, starting from
     the front side; stop at the first application returning '#f' and
     return '#f'.  If the iteration reaches the end of the deque: the
     return value is the result of applying FUN to the last object in
     the deque.  If the deque is empty: the return value is '#t'.

 -- Function: deque-exists-left FUN DEQUE
 -- Function: $deque-exists-left FUN DEQUE
     Apply the procedure FUN over the objects in DEQUE, starting from
     the front side; stop at the first application returning true and
     return the returned value.  If the deque is empty: the return value
     is '#f'.

 -- Function: deque-exists-right FUN DEQUE
 -- Function: $deque-exists-right FUN DEQUE
     Apply the procedure FUN over the objects in DEQUE, starting from
     the rear side; stop at the first application returning true and
     return the returned value.  If the deque is empty: the return value
     is '#f'.

 -- Function: deque-exists FUN DEQUE
 -- Function: $deque-exists FUN DEQUE
     Aliases for 'deque-exists-left' and '$deque-exists-left'.

 -- Function: deque-find-left FUN DEQUE
 -- Function: deque-find-left FUN DEQUE NOT-FOUND-RV
 -- Function: $deque-find-left FUN DEQUE NOT-FOUND-RV
     Apply the procedure FUN to the objects in DEQUE, starting from the
     front side: stop at the first true value and return the object from
     DEQUE that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

          (deque-find-left
              even?
            (deque 1 3 5 7)
            'not-found)
          => not-found

          (deque-find-left
              even?
            (deque 1 3 5 7))
          => #f

          (deque-find-left
              even?
            (deque 1 3 5 6 7)
            'not-found)
          => 6

 -- Function: deque-find-right FUN DEQUE
 -- Function: deque-find-right FUN DEQUE NOT-FOUND-RV
 -- Function: $deque-find-right FUN DEQUE NOT-FOUND-RV
     Apply the procedure FUN to the objects in DEQUE, starting from the
     rear side: stop at the first true value and return the object from
     DEQUE that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

 -- Function: deque-find FUN DEQUE
 -- Function: deque-find FUN DEQUE NOT-FOUND-RV
 -- Function: $deque-find FUN DEQUE NOT-FOUND-RV
     Aliases for 'deque-find-left' and '$deque-find-left'.


File: vicare-libs.info,  Node: deques filtering,  Next: deques conversion,  Prev: deques searching,  Up: deques

38.7 Filtering in deques
========================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-filter DST-DEQUE PRED SRC-DEQUE
 -- Function: $deque-filter DST-DEQUE PRED SRC-DEQUE
     Iterate over the objects in SRC-DEQUE starting from the front side,
     apply PRED to them, push on the rear of DST-DEQUE the ones for
     which PRED returns true.  Return DST-DEQUE itself.

     The argument DST-QUEUE allows us to build and configure a deque
     with the needed parameters.

 -- Function: deque-partition MATCH-DEQUE NO-MATCH-DEQUE PRED SRC-DEQUE
 -- Function: $deque-partition MATCH-DEQUE NO-MATCH-DEQUE PRED SRC-DEQUE
     Iterate over the objects in SRC-DEQUE, starting from the front
     side, and apply PRED to them: if the return value is true, push the
     object on the rear of MATCH-DEQUE; if the return value is '#f',
     push the object on the rear of NO-MATCH-DEQUE.  Return two values:
     MATCH-DEQUE and NO-MATCH-DEQUE.

     The arguments MATCH-DEQUE and NO-MATCH-DEQUE allow us to build and
     configure deques with the needed parameters.


File: vicare-libs.info,  Node: deques conversion,  Next: deques iteration thunks,  Prev: deques filtering,  Up: deques

38.8 Converting deques to other objects
=======================================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque->list DEQUE
 -- Function: $deque->list DEQUE
 -- Function: list->deque LIST
 -- Function: $list->deque LIST
     Convert to and from a deque and a proper list.  Objects from the
     list are pushed on the deque left-to-right from the rear side.

          (define D
            (list->deque '(0 1 2)))

          (deque-front D)         => 0
          (deque-rear  D)         => 2
          (deque->list D)         => (0 1 2)

 -- Function: deque->vector DEQUE
 -- Function: $deque->vector DEQUE
 -- Function: vector->deque VECTOR
 -- Function: $vector->deque VECTOR
     Convert to and from a deque and a vector.  Objects from the vector
     are pushed on the deque left-to-right from the rear side.

          (define D
            (vector->deque '#(0 1 2)))

          (deque-front   D)       => 0
          (deque-rear    D)       => 2
          (deque->vector D)       => #(0 1 2)


File: vicare-libs.info,  Node: deques iteration thunks,  Next: deques misc,  Prev: deques conversion,  Up: deques

38.9 Deque iteration thunks
===========================

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers deques)'.

 -- Function: make-deque-front-iteration-thunk DEQUE
     Build and return a new iteration thunk popping the objects from the
     front of DEQUE.

          (import (vicare)
            (vicare containers deques)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-deque-front-iteration-thunks (deque)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-deque-front-iteration-thunks (deque 0 1 2 3 4 5)))
          => (5 4 3 2 1 0)

 -- Function: make-deque-rear-iteration-thunk DEQUE
     Build and return a new iteration thunk popping the objects from the
     rear of DEQUE.

          (import (vicare)
            (vicare containers deques)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-deque-rear-iteration-thunks (deque)))
          => ()

          (iteration-thunk-fold
              xcons
            '()
            (make-deque-rear-iteration-thunks (deque 0 1 2 3 4 5)))
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: deques misc,  Prev: deques iteration thunks,  Up: deques

38.10 Miscellaneous operations on deques
========================================

The following syntactic bindings are exported by the library '(vicare
containers deques)'.  The syntactic bindings whose name is prefixed with
'$' are unsafe operations: they do *not* validate their arguments before
accessing them.

 -- Function: deque-copy! DST-DEQUE SRC-DEQUE
 -- Function: $deque-copy! DST-DEQUE SRC-DEQUE
     Iterate over all the objects in SRC-DEQUE, starting from the front
     side, and push them in the rear side of DST-DEQUE.  This is a
     shallow copy: the very objects from the source deque are added to
     the destination deque; if we need to duplicate the objects, we can
     use the map operation.

     The DST-DEQUE argument allows us to build the destination deque
     with the desired configuration parameters.

 -- Function: deque-reverse! DST-DEQUE SRC-DEQUE
 -- Function: $deque-reverse! DST-DEQUE SRC-DEQUE
     Iterate over the objects in SRC-QUEUE, starting from the front
     side, and push them in the front side of DST-QUEUE.  Return
     DST-QUEUE.

     The DST-DEQUE argument allows us to build the destination deque
     with the desired configuration parameters.


File: vicare-libs.info,  Node: binary heaps,  Next: dynamic arrays,  Prev: deques,  Up: Top

39 Binary heaps
***************

The library '(vicare containers binary-heaps)' implements binary heaps
holding arbitrary Scheme objects.

* Menu:

* binary heaps objects::        Heap objects.
* binary heaps inspection::     Inspecting heap objects.
* binary heaps access::         Heap accessors and mutators.
* binary heaps sorting::        Sorting using binary heaps.
* binary heaps iterthunks::     Iteration thunks.
* binary heaps misc::           Miscellaneous operations on heaps.


File: vicare-libs.info,  Node: binary heaps objects,  Next: binary heaps inspection,  Up: binary heaps

39.1 Heap objects
=================

The following bindings are exported by the library '(vicare containers
binary-heaps)'.  The bindings whose name is prefixed with '$' are unsafe
operations: they do *not* validate their arguments before accessing
them.

 -- R6RS Record Type: <binary-heap>
     Record type representing a binary heap object.  The '<binary-heap>'
     type is non-generative and available for subtyping.  In this
     documentation '<binary-heap>' object arguments to functions are
     indicated as HEAP.

 -- Function: make-binary-heap ITEM<
 -- Function: make-binary-heap ITEM< INITIAL-ARRAY-SIZE
     Build and return a new instance of '<binary-heap>'.  ITEM< must be
     a procedure implementing a "less than" comparison predicate.  The
     optional INITIAL-ARRAY-SIZE must be a non-negative fixnum
     representing the initial size of the underlying vector used as
     storage for the heap implementation.

 -- Function: binary-heap? OBJ
     Return '#t' if OBJ is a record of type '<binary-heap>'; otherwise
     return '#f'.

Object properties
.................

 -- Function: binary-heap-putprop HEAP KEY VALUE
 -- Function: $binary-heap-putprop HEAP KEY VALUE
     Add a new property KEY to the property list of HEAP; KEY must be a
     symbol.  If KEY is already set: the old entry is mutated to
     reference the new VALUE.

 -- Function: binary-heap-getprop HEAP KEY
 -- Function: $binary-heap-getprop HEAP KEY
     Return the value of the property KEY in the property list of HEAP;
     if KEY is not set: return '#f'.  KEY must be a symbol.

 -- Function: binary-heap-remprop HEAP KEY
 -- Function: $binary-heap-remprop HEAP KEY
     Remove the property KEY from the property list of HEAP; if KEY is
     not set: nothing happens.  KEY must be a symbol.

 -- Function: binary-heap-property-list HEAP
 -- Function: $binary-heap-property-list HEAP
     Return a new association list representing the property list of
     HEAP.  The order of the entries is the same as the property
     creation order.

Other operations
................

 -- Function: binary-heap-hash HEAP
 -- Function: $binary-heap-hash HEAP
     Return an exact integer to be used as hashtable key for HEAP.
     Hashtables having a '<binary-heap>' as key can be instantiated as
     follows:

          (make-hashtable binary-heap-hash eq?)


File: vicare-libs.info,  Node: binary heaps inspection,  Next: binary heaps access,  Prev: binary heaps objects,  Up: binary heaps

39.2 Inspecting heap objects
============================

The following bindings are exported by the library '(vicare containers
binary-heaps)'.  The bindings whose name is prefixed with '$' are unsafe
operations: they do *not* validate their arguments before accessing
them.

 -- Function: binary-heap-empty? HEAP
 -- Function: $binary-heap-empty? HEAP
     Return '#t' if HEAP is empty; otherwise return '#f'.

 -- Function: binary-heap-not-empty? HEAP
 -- Function: $binary-heap-not-empty? HEAP
     Return '#t' if HEAP is *not* empty; otherwise return '#f'.

 -- Function: binary-heap-size? HEAP
 -- Function: $binary-heap-size? HEAP
     Return a non-negative fixnum representing the number of objects in
     HEAP.


File: vicare-libs.info,  Node: binary heaps access,  Next: binary heaps sorting,  Prev: binary heaps inspection,  Up: binary heaps

39.3 Heap accessors and mutators
================================

The following bindings are exported by the library '(vicare containers
binary-heaps)'.  The bindings whose name is prefixed with '$' are unsafe
operations: they do *not* validate their arguments before accessing
them.

 -- Function: binary-heap-top HEAP
 -- Function: $binary-heap-top HEAP
     Return the object at the root of the heap.  Raise an assertion
     violation if HEAP is empty.

 -- Function: binary-heap-push! HEAP OBJ
 -- Function: $binary-heap-push! HEAP OBJ
     Push OBJ on the HEAP.

 -- Function: binary-heap-pop! HEAP
 -- Function: $binary-heap-pop! HEAP
     Remove the object at the root of the heap and return it.  Raise an
     assertion violation if HEAP is empty.

 -- Function: binary-heap-fill! HEAP ITEM*
 -- Function: $binary-heap-fill! HEAP ITEM*
     Push on the heap the list of objects ITEM*.

 -- Function: binary-heap-purge! HEAP
 -- Function: $binary-heap-purge! HEAP
     Remove all the elements from HEAP.


File: vicare-libs.info,  Node: binary heaps sorting,  Next: binary heaps iterthunks,  Prev: binary heaps access,  Up: binary heaps

39.4 Sorting using binary heaps
===============================

The following bindings are exported by the library '(vicare containers
binary-heaps)'.  The bindings whose name is prefixed with '$' are unsafe
operations: they do *not* validate their arguments before accessing
them.

 -- Function: binary-heap-sort-to-list! HEAP
 -- Function: $binary-heap-sort-to-list! HEAP
     Build and return a list holding all the objects in HEAP sorted from
     the lesser to the greater.  The heap is left empty.


File: vicare-libs.info,  Node: binary heaps iterthunks,  Next: binary heaps misc,  Prev: binary heaps sorting,  Up: binary heaps

39.5 Iteration thunks
=====================

Iteration thunks are procedures accepting no arguments and returning an
item from a collection; when the iteration finishes: the return value is
the void object.  Iteration thunks can be used with the facilities of
the library '(vicare containers iteration-thunks)' (*note iteration
thunks::).  The following syntactic bindings are exported by the library
'(vicare containers binary-heaps)'.

 -- Function: make-binary-heap-iteration-thunk HEAP
     Build and return a new iteration thunk popping the objects from
     STACK.

          (import (vicare)
            (vicare containers binary-heaps)
            (vicare containers iteration-thunks))

          (define (xcons a b)
            (cons b a))

          (iteration-thunk-fold
              xcons
            '()
            (make-binary-heap-iteration-thunk (make-binary-heap <)))
          => ()

          (let ((H (make-binary-heap <)))
            (binary-heap-fill! H '(3 5 7 0 6 5 34 3 6 9 67 5 4 4 3 1 2 3))
            (iteration-thunk-fold
                xcons
              '()
              (make-binary-heap-iteration-thunk H)))
          => (67 34 9 7 6 6 5 5 5 4 4 3 3 3 3 2 1 0)


File: vicare-libs.info,  Node: binary heaps misc,  Prev: binary heaps iterthunks,  Up: binary heaps

39.6 Miscellaneous operations on heaps
======================================

The following bindings are exported by the library '(vicare containers
binary-heaps)'.  The bindings whose name is prefixed with '$' are unsafe
operations: they do *not* validate their arguments before accessing
them.

 -- Function: binary-heap-copy HEAP
 -- Function: $binary-heap-copy HEAP
     Build and return a new instance of '<binary-heap>' using the same
     comparison predicate of HEAP and containing the same objects of
     HEAP.

 -- Function: binary-heap-fold! KONS KNIL HEAP
 -- Function: $binary-heap-fold! KONS KNIL HEAP
     While the HEAP is not empty: apply KONS to KNIL and the next top
     object; the return value of the application becomes the new KNIL;
     return the return value of the last application.  After a call to
     this function: the heap is left empty.

          (binary-heap-fold!
              (lambda (knil obj)
                (cons obj knil))
            '()
            (fold-left (lambda (heap obj)
                         (binary-heap-push! heap obj)
                         heap)
              (make-binary-heap <)
              '(2 4 0 1 3)))
          => (4 3 2 1 0)

 -- Function: binary-heap-merge HEAP1 HEAP2
 -- Function: $binary-heap-merge HEAP1 HEAP2
     Build and return a new instance of '<binary-heap>' using the same
     comparison predicate of HEAP1 and containing the same objects of
     both HEAP1 and HEAP2.  The arguments HEAP1 and HEAP2 are left
     unchanged.

 -- Function: binary-heap-blend! HEAP1 HEAP2
 -- Function: $binary-heap-blend! HEAP1 HEAP2
     Destructively extract all the objects from HEAP2 and add them to
     HEAP1.  Return HEAP1 itself.


File: vicare-libs.info,  Node: dynamic arrays,  Next: bst,  Prev: binary heaps,  Up: Top

40 Dynamic arrays
*****************

The library '(vicare containers dynamic-arrays)' implements array
objects holding arbitrary Scheme objects and designed for efficient
dynamic resizing.  The library '(vicare containers dynamic-arrays sort)'
implements sorting algorithms.

* Menu:

* dynamic arrays objects::      Dynamic vector objects.
* dynamic arrays inspection::   Inspecting stack objects.
* dynamic arrays access::       Stack accessors and mutators.
* dynamic arrays folding::      Folding over dynamic vectors.
* dynamic arrays mapping::      Mapping over dynamic vectors.
* dynamic arrays searching::    Searching in dynamic vectors.
* dynamic arrays filtering::    Filtering in dynamic vectors.
* dynamic arrays conversion::   Converting dynamic vectors to
                                other objects.
* dynamic arrays misc::         Miscellaneous operations on
                                dynamic vectors.
* dynamic arrays sort::         Sorting dynamic arrays.
* dynamic arrays iterthunks::   Iteration thunks.


File: vicare-libs.info,  Node: dynamic arrays objects,  Next: dynamic arrays inspection,  Up: dynamic arrays

40.1 Dynamic-Arrays objects
===========================

Dynamic arrays are implemented as built-in vector objects of which only
a subrange of slots is used:

       left span       used slots     right span
     |...........|...................|...........|

     |---|---|---|+++|+++|+++|+++|+++|---|---|---| vector
                   0   1   2   3   4

when a new object is inserted: if there is room at the beginning or end
of the vector, that room is consumed.  Indexing in dynamic arrays is
zero-based, with index '0' referencing the first used slot.

   The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.

 -- R6RS Record Type: <dynamic-array>
     Record type representing a dynamic-arrays object.  The
     '<dynamic-array>' type is non-generative and available for
     subtyping.  In this documentation '<dynamic-array>' objects used as
     arguments to functions are indicated as ARRY.

 -- Function: make-dynamic-array
 -- Function: make-dynamic-array FULL-LENGTH LEFT-SPAN
     Build and return a new '<dynamic-array>' object.

     The optional argument FULL-LENGTH must be a non-negative fixnum
     representing the number of slots in the internal vector object;
     when not used, it defaults to '15'.  The optional argument
     LEFT-SPAN must be a non-negative fixnum representing the number of
     slots to initially leave unused at the left; when not used, it
     defaults to '7'.

 -- Function: dynamic-array? OBJ
     Return '#t' if OBJ is a record of type '<dynamic-array>'; otherwise
     return '#f'.

 -- Function: dynamic-array OBJ ...
     Build and return a '<dynamic-array>' object holding the given
     objects, which are pushed on the dynamic-array left to right from
     the rear side.  The size of the internal vector is set to the
     default.

          (define D
            (dynamic-array 0 1 2))

          (dynamic-array-front D)         => 0
          (dynamic-array-rear  D)         => 2

Object properties
.................

 -- Function: dynamic-array-putprop ARRY KEY VALUE
 -- Function: $dynamic-array-putprop ARRY KEY VALUE
     Add a new property KEY to the property list of ARRY; KEY must be a
     symbol.  If KEY is already set: the old entry is mutated to
     reference the new VALUE.

 -- Function: dynamic-array-getprop ARRY KEY
 -- Function: $dynamic-array-getprop ARRY KEY
     Return the value of the property KEY in the property list of ARRY;
     if KEY is not set: return '#f'.  KEY must be a symbol.

 -- Function: dynamic-array-remprop ARRY KEY
 -- Function: $dynamic-array-remprop ARRY KEY
     Remove the property KEY from the property list of ARRY; if KEY is
     not set: nothing happens.  KEY must be a symbol.

 -- Function: dynamic-array-property-list ARRY
 -- Function: $dynamic-array-property-list ARRY
     Return a new association list representing the property list of
     ARRY.  The order of the entries is the same as the property
     creation order.

Other operations
................

 -- Function: dynamic-array-hash ARRY
 -- Function: $dynamic-array-hash ARRY
     Return an exact integer to be used as hashtable key for ARRY.
     Hashtables having a '<dynamic-array>' as key can be instantiated as
     follows:

          (make-hashtable dynamic-array-hash eq?)


File: vicare-libs.info,  Node: dynamic arrays inspection,  Next: dynamic arrays access,  Prev: dynamic arrays objects,  Up: dynamic arrays

40.2 Inspecting dynamic array objects
=====================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-empty? ARRY
 -- Function: $dynamic-array-empty? ARRY
     Return '#t' if ARRY is empty; otherwise return '#f'.

 -- Function: dynamic-array-not-empty? ARRY
 -- Function: $dynamic-array-not-empty? ARRY
     Return '#t' if ARRY is *not* empty; otherwise return '#f'.

 -- Function: dynamic-array-length ARRY
 -- Function: $dynamic-array-length ARRY
     Return a non-negative fixnum representing the number of objects in
     ARRY.

 -- Function: dynamic-array-size ARRY
 -- Function: $dynamic-array-size ARRY
     Aliases for 'dynamic-array-length' and '$dynamic-array-length'.


File: vicare-libs.info,  Node: dynamic arrays access,  Next: dynamic arrays folding,  Prev: dynamic arrays inspection,  Up: dynamic arrays

40.3 Dynamic-Arrays accessors and mutators
==========================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-ref ARRY IDX
 -- Function: $dynamic-array-ref ARRY IDX
     Return the object at IDX in the dynamic array.  Raise an assertion
     violation if ARRY is empty.

 -- Function: dynamic-array-set! ARRY IDX OBJ
 -- Function: $dynamic-array-set! ARRY IDX OBJ
     Store a new value at IDX in the dynamic array, overwriting the old
     value.

 -- Function: dynamic-array-insert! ARRY IDX OBJ
 -- Function: $dynamic-array-insert! ARRY IDX OBJ
     Insert a new value at IDX in the dynamic array.  The objects in the
     array are shifted to make room for the new one.

     The argument IDX must be a non-negative fixnum in the range [0, N)
     where N is the number of objects in the array; as special cases:

        * If IDX is -1: the new object is prepended to the beginning of
          the array; in this case the insertion operation is equivalent
          to a "push to the front side".

        * If IDX equals the number of objects in the array: the new
          object is appended to the end of the array; in this case the
          insertion operation is equivalent to a "push to the rear
          side".

          (let ((D (dynamic-array 0 1 2 3)))
            (dynamic-array-insert! D 0 9)
            (dynamic-array->list D))
          => (9 0 1 2 3)

          (let ((D (dynamic-array 0 1 2 3)))
            (dynamic-array-insert! D 3 9)
            (dynamic-array->list D))
          => (0 1 2 9 3)

 -- Function: dynamic-array-remove! ARRY IDX
 -- Function: $dynamic-array-remove! ARRY IDX
     Remove the object at index IDX in ARRY.

          (let ((D (dynamic-array 0 1 2 3 4)))
            (dynamic-array-remove! D 2)
            (dynamic-array->list D))
          => (0 1 3 4)

 -- Function: dynamic-array-front ARRY
 -- Function: $dynamic-array-front ARRY
     Return the object at the front of the dynamic array.  Raise an
     assertion violation if ARRY is empty.

 -- Function: dynamic-array-rear ARRY
 -- Function: $dynamic-array-rear ARRY
     Return the object at the rear of the dynamic array.  Raise an
     assertion violation if ARRY is empty.

 -- Function: dynamic-array-push-front! ARRY OBJ
 -- Function: $dynamic-array-push-front! ARRY OBJ
     Push OBJ on the front of ARRY.

 -- Function: dynamic-array-push-rear! ARRY OBJ
 -- Function: $dynamic-array-push-rear! ARRY OBJ
     Push OBJ on the rear of ARRY.

 -- Function: dynamic-array-pop-front! ARRY
 -- Function: $dynamic-array-pop-front! ARRY
     Remove the object at the front of the dynamic array and return it.
     Raise an assertion violation if ARRY is empty.

 -- Function: dynamic-array-pop-rear! ARRY
 -- Function: $dynamic-array-pop-rear! ARRY
     Remove the object at the rear of the dynamic array and return it.
     Raise an assertion violation if ARRY is empty.

 -- Function: dynamic-array-purge! ARRY
 -- Function: $dynamic-array-purge! ARRY
     Remove all the elements from ARRY.


File: vicare-libs.info,  Node: dynamic arrays folding,  Next: dynamic arrays mapping,  Prev: dynamic arrays access,  Up: dynamic arrays

40.4 Folding over dynamic-arrays
================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-fold-left KONS KNIL ARRY
 -- Function: $dynamic-array-fold-left KONS KNIL ARRY
     Analogous to 'fold-left' for lists.  Fold the procedure KONS over
     the objects from ARRY, starting from the front.

          (define D
            (dynamic-array 0 1 2 3 4 5))

          (dynamic-array-fold-left
              (lambda (knil obj)
                (cons obj knil))
            '() D)
          => (5 4 3 2 1 0)

 -- Function: dynamic-array-fold-right KONS KNIL ARRY
 -- Function: $dynamic-array-fold-right KONS KNIL ARRY
     Analogous to 'fold-right' for lists.  Fold the procedure KONS over
     the objects from ARRY, starting from the rear.

          (define D
            (dynamic-array 0 1 2 3 4 5))

          (dynamic-array-fold-right
              (lambda (obj knil)
                (cons obj knil))
            '() D)
          => (0 1 2 3 4 5)


File: vicare-libs.info,  Node: dynamic arrays mapping,  Next: dynamic arrays searching,  Prev: dynamic arrays folding,  Up: dynamic arrays

40.5 Mapping over dynamic arrays
================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-map-left DST-ARRY FUN SRC-ARRY
 -- Function: $dynamic-array-map-left DST-ARRY FUN SRC-ARRY
     Iterate over all the objects in SRC-ARRY, starting from the front
     side, apply FUN to them, push the result of the application in the
     rear side of DST-ARRY.

          (dynamic-array->list
            (dynamic-array-map-left
               (dynamic-array)
               -
               (dynamic-array 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-ARRY argument allows us to build the destination dynamic
     array with the desired configuration parameters.

 -- Function: dynamic-array-map-right DST-ARRY FUN SRC-ARRY
 -- Function: $dynamic-array-map-right DST-ARRY FUN SRC-ARRY
     Iterate over all the objects in SRC-ARRY, starting from the rear
     side, apply FUN to them, push the result of the application in the
     front side of DST-ARRY.

          (dynamic-array->list
            (dynamic-array-map-right
               (dynamic-array)
               -
               (dynamic-array 0 1 2 3)))
          => (0 -1 -2 -3)

     The DST-ARRY argument allows us to build the destination dynamic
     array with the desired configuration parameters.

 -- Function: dynamic-array-map FUN ARRY
 -- Function: $dynamic-array-map FUN ARRY
     Aliases for 'dynamic-array-map-left' and '$dynamic-array-map-left'.

 -- Function: dynamic-array-for-each-left FUN ARRY
 -- Function: $dynamic-array-for-each-left FUN ARRY
     Iterate over all the objects in ARRY, starting from the front side,
     and apply FUN to them discarding the return value.

 -- Function: dynamic-array-for-each-right FUN ARRY
 -- Function: $dynamic-array-for-each-right FUN ARRY
     Iterate over all the objects in ARRY, starting from the rear side,
     and apply FUN to them discarding the return value.

 -- Function: dynamic-array-for-each FUN ARRY
 -- Function: $dynamic-array-for-each FUN ARRY
     Aliases for 'dynamic-array-for-each-left' and
     '$dynamic-array-for-each-left'.


File: vicare-libs.info,  Node: dynamic arrays searching,  Next: dynamic arrays filtering,  Prev: dynamic arrays mapping,  Up: dynamic arrays

40.6 Searching in dynamic arrays
================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-for-all FUN ARRY
 -- Function: $dynamic-array-for-all FUN ARRY
     Apply the procedure FUN over the objects in ARRY, starting from the
     left side; stop at the first application returning '#f' and return
     '#f'.  If the iteration reaches the end of the dynamic array: the
     return value is the result of applying FUN to the last object in
     the dynamic array.  If the dynamic array is empty: the return value
     is '#t'.

 -- Function: dynamic-array-exists-left FUN ARRY
 -- Function: $dynamic-array-exists-left FUN ARRY
     Apply the procedure FUN over the objects in ARRY, starting from the
     left side; stop at the first application returning true and return
     the returned value.  If the dynamic array is empty: the return
     value is '#f'.

 -- Function: dynamic-array-exists-right FUN ARRY
 -- Function: $dynamic-array-exists-right FUN ARRY
     Apply the procedure FUN over the objects in ARRY, starting from the
     right side; stop at the first application returning true and return
     the returned value.  If the dynamic-arrays is empty: the return
     value is '#f'.

 -- Function: dynamic-array-exists FUN ARRY
 -- Function: $dynamic-array-exists FUN ARRY
     Aliases for 'dynamic-array-exists-left' and
     '$dynamic-array-exists-left'.

 -- Function: dynamic-array-find-left FUN ARRY
 -- Function: dynamic-array-find-left FUN ARRY NOT-FOUND-RV
 -- Function: $dynamic-array-find-left FUN ARRY NOT-FOUND-RV
     Apply the procedure FUN to the objects in ARRY, starting from the
     front side: stop at the first true value and return the object from
     ARRY that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

          (dynamic-array-find-left
              even?
            (dynamic-array 1 3 5 7)
            'not-found)
          => not-found

          (dynamic-array-find-left
              even?
            (dynamic-array 1 3 5 7))
          => #f

          (dynamic-array-find-left
              even?
            (dynamic-array 1 3 5 6 7)
            'not-found)
          => 6

 -- Function: dynamic-array-find-right FUN ARRY
 -- Function: dynamic-array-find-right FUN ARRY NOT-FOUND-RV
 -- Function: $dynamic-array-find-right FUN ARRY NOT-FOUND-RV
     Apply the procedure FUN to the objects in ARRY, starting from the
     right side: stop at the first true value and return the object from
     ARRY that generated it.

     When NOT-FOUND-RV is not used: if all the applications return '#f',
     the return value is '#f'.

     When NOT-FOUND-RV is used: if all the applications return '#f', the
     return value is NOT-FOUND-RV.

 -- Function: dynamic-array-find FUN ARRY
 -- Function: dynamic-array-find FUN ARRY NOT-FOUND-RV
 -- Function: $dynamic-array-find FUN ARRY NOT-FOUND-RV
     Aliases for 'dynamic-array-find-left' and
     '$dynamic-array-find-left'.


File: vicare-libs.info,  Node: dynamic arrays filtering,  Next: dynamic arrays conversion,  Prev: dynamic arrays searching,  Up: dynamic arrays

40.7 Filtering in dynamic arrays
================================

The following syntactic bindings are exported by the library '(vicare
containers dynamic-arrays)'.  The syntactic bindings whose name is
prefixed with '$' are unsafe operations: they do *not* validate their
arguments before accessing them.

 -- Function: dynamic-array-filter DST-ARRY PRED SRC-ARRY
 -- Function: $dynamic-array-filter DST-ARRY PRED SRC-ARRY
     Iterate over the objects in SRC-ARRY starting from the left side,
     apply PRED to them, push on the right of DST-ARRY the ones for
     which PRED returns true.  Return DST-ARRY itself.

     The argument DST-QUEUE allows us to build and configure a dynamic
     array with the needed parameters.

 -- Function: dynamic-array-partition MATCH-ARRY NO-MATCH-ARRY PRED
          SRC-ARRY
 -- Function: $dynamic-array-partition MATCH-ARRY NO-MATCH-ARRY PRED
          SRC-ARRY
     Iterate over the objects in SRC-ARRY, starting from the left side,
     and apply PRED to them: if the return value is true, push the
     object on the right of MATCH-ARRY; if the return value is '#f',
     push the object on the right of NO-MATCH-ARRY.  Return two values:
     MATCH-ARRY and NO-MATCH-ARRY.

     The arguments MATCH-ARRY and NO-MATCH-ARRY allow us to build and
     configure dynamic arrays with the needed parameters.

