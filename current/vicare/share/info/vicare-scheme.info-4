This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: iklib conditions proccon,  Next: iklib conditions exprret,  Prev: iklib conditions rvarg,  Up: iklib conditions

6.12.14 Procedure argument consistency violations
-------------------------------------------------

 -- Condition Type: &procedure-arguments-consistency-violation
     Condition object type representing a set of inconsistent arguments
     to a procedure application; it is derived from
     '&procedure-precondition-violation'.

 -- Function: make-procedure-arguments-consistency-violation
     Build and return a new condition object of type
     '&procedure-arguments-consistency-violation'.

 -- Function: procedure-arguments-consistency-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&procedure-arguments-consistency-violation'; otherwise return
     '#f'.

 -- Function: procedure-arguments-consistency-violation WHO MESSAGE
          IRRITANT ...
     Raise a non-continuable exception with compound condition object
     holding components of type: '&who', '&message', '&irritants',
     '&procedure-arguments-consistency-violation'.

 -- Function:
          procedure-arguments-consistency-violation/failed-expression
          WHO MESSAGE FAILED-EXPRESSION IRRITANT ...
     Like 'procedure-arguments-consistency-violation' and in addition
     attach to the raised condition object a component with type
     '&failed-expression', using the symbolic FAILED-EXPRESSION as
     argument.


File: vicare-scheme.info,  Node: iklib conditions exprret,  Next: iklib conditions non-reinst,  Prev: iklib conditions proccon,  Up: iklib conditions

6.12.15 Expression return value violations
------------------------------------------

 -- Condition Type: &expression-return-value-violation
     Condition object type representing invalid values returned from an
     expression; it is derived from '&assertion'.

 -- Function: make-expression-return-value-violation
     Build and return a new condition object of type
     '&expression-return-value-violation'.

 -- Function: expression-return-value-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&expression-return-value-violation'; otherwise return '#f'.

 -- Function: expression-return-value-violation WHO MESSAGE RETVAL-INDEX
          IRRITANT ...
     Raise a compound condition object as non-continuable exception with
     component types: '&who', '&message', '&irritants',
     '&expression-return-value-violation',
     '&one-based-return-value-index'.


File: vicare-scheme.info,  Node: iklib conditions non-reinst,  Next: iklib conditions late-bind,  Prev: iklib conditions exprret,  Up: iklib conditions

6.12.16 Non-reinstatable continuations
--------------------------------------

 -- Condition Type: &non-reinstatable
     Condition object type representing an attempt to reinstate a
     continuation in an invalid context; it is derived from
     '&violation'.

 -- Function: make-non-reinstatable-violation
     Build and return a new condition object of type
     '&non-reinstatable'.

 -- Function: non-reinstatable-violation? OBJ
     Return '#t' if OBJ is a condition object of type
     '&non-reinstatable'; otherwise return '#f'.

 -- Function: non-reinstatable-violation WHO MESSAGE IRRITANT ...
     Raise a compound condition object with components: '&who',
     '&message', '&irritants', '&non-reinstatable'.


File: vicare-scheme.info,  Node: iklib conditions late-bind,  Next: iklib conditions string,  Prev: iklib conditions non-reinst,  Up: iklib conditions

6.12.17 Late binding conditions
-------------------------------

* Menu:

* iklib conditions late-bind base::     Base of late binding conditions.
* iklib conditions late-bind method::   Method late binding conditions.
* iklib conditions late-bind overload:: Overloaded function late binding
                                        conditions.


File: vicare-scheme.info,  Node: iklib conditions late-bind base,  Next: iklib conditions late-bind method,  Up: iklib conditions late-bind

6.12.17.1 Base of late binding conditions
.........................................

 -- Condition Type: &late-binding-error
     Condition object type representing an error while attempting late
     binding in a procedure application: no specialised function matches
     the given operands; it is derived from '&error'.

 -- Function: make-late-binding-error
     Build and return a new condition object of type
     '&late-binding-error'.

 -- Function: late-binding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&late-binding-error'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions late-bind method,  Next: iklib conditions late-bind overload,  Prev: iklib conditions late-bind base,  Up: iklib conditions late-bind

6.12.17.2 Method late binding conditions
........................................

 -- Condition Type: &method-late-binding-error
     Condition object type representing an error while attempting late
     binding in a method application: no specialised function matches
     the given operands; it is derived from '&late-binding-error'.

 -- Function: make-method-late-binding-error
     Build and return a new condition object of type
     '&method-late-binding-error'.

 -- Function: method-late-binding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&method-late-binding-error'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions late-bind overload,  Prev: iklib conditions late-bind method,  Up: iklib conditions late-bind

6.12.17.3 Overloaded function late binding conditions
.....................................................

 -- Condition Type: &overloaded-function-late-binding-error
     Condition object type representing an error while attempting late
     binding in a method application: no specialised function matches
     the given operands; it is derived from '&late-binding-error'.

 -- Function: make-overloaded-function-late-binding-error
     Build and return a new condition object of type
     '&overloaded-function-late-binding-error'.

 -- Function: overloaded-function-late-binding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&overloaded-function-late-binding-error'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions string,  Next: iklib conditions wfs,  Prev: iklib conditions late-bind,  Up: iklib conditions

6.12.18 String encoding and decoding
------------------------------------

* Menu:

* iklib conditions string generic::     Generic string encoding condition types.
* iklib conditions string utf8::        UTF-8 string encoding condition types.
* iklib conditions string utf16::       UTF-16 string encoding condition types.
* iklib conditions string utf32::       UTF-32 string encoding condition types.


File: vicare-scheme.info,  Node: iklib conditions string generic,  Next: iklib conditions string utf8,  Up: iklib conditions string

6.12.18.1 Generic string encoding condition types
.................................................

Encoding strings
................

 -- Condition Type: &string-encoding
     Condition object type representing an error while encoding a string
     into a bytevector; it is derived from '&error'.

 -- Function: make-string-encoding-error
     Build and return a new condition object of type '&string-encoding'.

 -- Function: string-encoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&string-encoding'; otherwise return '#f'.

Decoding strings
................

 -- Condition Type: &string-decoding
     Condition object type representing an error while encoding a
     bytevector into a string; it is derived from '&error'.

 -- Function: make-string-decoding-error
     Build and return a new condition object of type '&string-decoding'.

 -- Function: string-decoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&string-decoding'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions string utf8,  Next: iklib conditions string utf16,  Prev: iklib conditions string generic,  Up: iklib conditions string

6.12.18.2 UTF-8 string encoding condition types
...............................................

Encoding strings into UTF-8 bytevectors
.......................................

 -- Condition Type: &utf8-string-encoding
     Condition object type representing an error while encoding a string
     into a UTF-8 bytevector; it is derived from '&string-encoding'.

 -- Function: make-utf8-string-encoding-error
     Build and return a new condition object of type
     '&utf8-string-encoding'.

 -- Function: utf8-string-encoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-encoding'; otherwise return '#f'.

Decoding strings from UTF-8 bytevectors
.......................................

 -- Condition Type: &utf8-string-decoding
     Condition object type representing an error while decoding a UTF-8
     bytevector into a string; it is derived from '&string-decoding'.

 -- Function: make-utf8-string-decoding-error
     Build and return a new condition object of type
     '&utf8-string-decoding'.

 -- Function: utf8-string-decoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding'; otherwise return '#f'.

Invalid octet in UTF-8 bytevector
.................................

 -- Condition Type: &utf8-string-decoding-invalid-octet
     Condition object type representing an invalid octet in a UTF-8
     bytevector; it is derived from '&utf8-string-decoding'.  It has the
     following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the offending octet.

     'octets'
          A list holding the offending octet.

 -- Function: make-utf8-string-decoding-invalid-octet BYTEVECTOR INDEX
          OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-invalid-octet'.

 -- Function: utf8-string-decoding-invalid-octet? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-invalid-octet'; otherwise return '#f'.

 -- Function: utf8-string-decoding-invalid-octet.bytevector CND
 -- Function: utf8-string-decoding-invalid-octet.index CND
 -- Function: utf8-string-decoding-invalid-octet.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-invalid-octet'.

Invalid 2-octets sequence in UTF-8 bytevector
.............................................

 -- Condition Type: &utf8-string-decoding-invalid-2-tuple
     Condition object type representing an invalid 2-octets sequence in
     a UTF-8 bytevector: the first octet is valid, the second one is
     invalid.  It is derived from '&utf8-string-decoding'.  It has the
     following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the offending octet.

     'octets'
          A list holding the offending octets.

 -- Function: make-utf8-string-decoding-invalid-2-tuple BYTEVECTOR INDEX
          OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-invalid-2-tuple'.

 -- Function: utf8-string-decoding-invalid-2-tuple? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-invalid-2-tuple'; otherwise return '#f'.

 -- Function: utf8-string-decoding-invalid-2-tuple.bytevector CND
 -- Function: utf8-string-decoding-invalid-2-tuple.index CND
 -- Function: utf8-string-decoding-invalid-2-tuple.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-invalid-2-tuple'.

Invalid 3-octets sequence in UTF-8 bytevector
.............................................

 -- Condition Type: &utf8-string-decoding-invalid-3-tuple
     Condition object type representing an invalid 3-octets sequence in
     a UTF-8 bytevector: the first octet is valid, the second and/or
     third ones are invalid.  It is derived from
     '&utf8-string-decoding'.  It has the following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the offending octet.

     'octets'
          A list holding the offending octets.

 -- Function: make-utf8-string-decoding-invalid-3-tuple BYTEVECTOR INDEX
          OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-invalid-3-tuple'.

 -- Function: utf8-string-decoding-invalid-3-tuple? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-invalid-3-tuple'; otherwise return '#f'.

 -- Function: utf8-string-decoding-invalid-3-tuple.bytevector CND
 -- Function: utf8-string-decoding-invalid-3-tuple.index CND
 -- Function: utf8-string-decoding-invalid-3-tuple.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-invalid-3-tuple'.

Invalid 4-octets sequence in UTF-8 bytevector
.............................................

 -- Condition Type: &utf8-string-decoding-invalid-4-tuple
     Condition object type representing an invalid 4-octets sequence in
     a UTF-8 bytevector: the first octet is valid, one or more among the
     second, third and fourth ones are invalid.  It is derived from
     '&utf8-string-decoding'.  It has the following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the offending octet.

     'octets'
          A list holding the offending octets.

 -- Function: make-utf8-string-decoding-invalid-4-tuple BYTEVECTOR INDEX
          OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-invalid-4-tuple'.

 -- Function: utf8-string-decoding-invalid-4-tuple? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-invalid-4-tuple'; otherwise return '#f'.

 -- Function: utf8-string-decoding-invalid-4-tuple.bytevector CND
 -- Function: utf8-string-decoding-invalid-4-tuple.index CND
 -- Function: utf8-string-decoding-invalid-4-tuple.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-invalid-4-tuple'.

Incomplete 2-octets sequence in UTF-8 bytevector
................................................

 -- Condition Type: &utf8-string-decoding-incomplete-2-tuple
     Condition object type representing an incomplete 2-octets sequence
     in a UTF-8 bytevector: the first octet is present, the second one
     is missing because we are at the end of the bytevector.  It is
     derived from '&utf8-string-decoding'.  It has the following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the first octet in the
          incomplete sequence.

     'octets'
          A list holding the incomplete sequence of octets.

 -- Function: make-utf8-string-decoding-incomplete-2-tuple BYTEVECTOR
          INDEX OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-incomplete-2-tuple'.

 -- Function: utf8-string-decoding-incomplete-2-tuple? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-incomplete-2-tuple'; otherwise return '#f'.

 -- Function: utf8-string-decoding-incomplete-2-tuple.bytevector CND
 -- Function: utf8-string-decoding-incomplete-2-tuple.index CND
 -- Function: utf8-string-decoding-incomplete-2-tuple.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-incomplete-2-tuple'.

Incomplete 3-octets sequence in UTF-8 bytevector
................................................

 -- Condition Type: &utf8-string-decoding-incomplete-3-tuple
     Condition object type representing an incomplete 3-octets sequence
     in a UTF-8 bytevector: the first octet is present, the second
     and/or third ones are missing because we are at the end of the
     bytevector.  It is derived from '&utf8-string-decoding'.  It has
     the following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the first octet in the
          incomplete sequence.

     'octets'
          A list holding the incomplete sequence of octets.

 -- Function: make-utf8-string-decoding-incomplete-3-tuple BYTEVECTOR
          INDEX OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-incomplete-3-tuple'.

 -- Function: utf8-string-decoding-incomplete-3-tuple? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-incomplete-3-tuple'; otherwise return '#f'.

 -- Function: utf8-string-decoding-incomplete-3-tuple.bytevector CND
 -- Function: utf8-string-decoding-incomplete-3-tuple.index CND
 -- Function: utf8-string-decoding-incomplete-3-tuple.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-incomplete-3-tuple'.

Incomplete 4-octets sequence in UTF-8 bytevector
................................................

 -- Condition Type: &utf8-string-decoding-incomplete-4-tuple
     Condition object type representing an incomplete 4-octets sequence
     in a UTF-8 bytevector: the first octet is present, one or more
     among the second, third and fourth ones are missing because we are
     at the end of the bytevector.  It is derived from
     '&utf8-string-decoding'.  It has the following fields:

     'bytevector'
          The UTF-8 bytevector.

     'index'
          The index in the bytevector of the first octet in the
          incomplete sequence.

     'octets'
          A list holding the incomplete sequence of octets.

 -- Function: make-utf8-string-decoding-incomplete-4-tuple BYTEVECTOR
          INDEX OCTETS
     Build and return a condition object of type
     '&utf8-string-decoding-incomplete-4-tuple'.

 -- Function: utf8-string-decoding-incomplete-4-tuple? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf8-string-decoding-incomplete-4-tuple'; otherwise return '#f'.

 -- Function: utf8-string-decoding-incomplete-4-tuple.bytevector CND
 -- Function: utf8-string-decoding-incomplete-4-tuple.index CND
 -- Function: utf8-string-decoding-incomplete-4-tuple.octets CND
     Field accessors for condition objects of type
     '&utf8-string-decoding-incomplete-4-tuple'.


File: vicare-scheme.info,  Node: iklib conditions string utf16,  Next: iklib conditions string utf32,  Prev: iklib conditions string utf8,  Up: iklib conditions string

6.12.18.3 UTF-16 string encoding condition types
................................................

Encoding strings into UTF-16 bytevectors
........................................

 -- Condition Type: &utf16-string-encoding
     Condition object type representing an error while encoding a string
     into a UTF-16 bytevector; it is derived from '&string-encoding'.

 -- Function: make-utf16-string-encoding-error
     Build and return a new condition object of type
     '&utf16-string-encoding'.

 -- Function: utf16-string-encoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf16-string-encoding'; otherwise return '#f'.

Decoding strings from UTF-16 bytevectors
........................................

 -- Condition Type: &utf16-string-decoding
     Condition object type representing an error while decoding a UTF-16
     bytevector into a string; it is derived from '&string-decoding'.

 -- Function: make-utf16-string-decoding-error
     Build and return a new condition object of type
     '&utf16-string-decoding'.

 -- Function: utf16-string-decoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf16-string-decoding'; otherwise return '#f'.

Invalid first word in UTF-16 bytevectors
........................................

 -- Condition Type: &utf16-string-decoding-invalid-first-word
     Condition object type representing an invalid 16-bit word in the
     position of standalone word or first word of a surrogate pair; it
     is derived from '&utf16-string-decoding'.  It has the following
     fields:

     'bytevector'
          The bytevector object.

     'index'
          The index of the offending word.

     'word'
          The offending word.

 -- Function: make-utf16-string-decoding-invalid-first-word BYTEVECTOR
          INDEX WORD
     Build and return a new condition object of type
     '&utf16-string-decoding-invalid-first-word'.

 -- Function: utf16-string-decoding-invalid-first-word? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf16-string-decoding-invalid-first-word'; otherwise return '#f'.

 -- Function: utf16-string-decoding-invalid-first-word.bytevector CND
 -- Function: utf16-string-decoding-invalid-first-word.index CND
 -- Function: utf16-string-decoding-invalid-first-word.word CND
     Field accessors for condition objects of type
     '&utf16-string-decoding-invalid-first-word'.

Invalid second word in UTF-16 bytevectors
.........................................

 -- Condition Type: &utf16-string-decoding-invalid-second-word
     Condition object type representing an invalid 16-bit word in the
     position of second word of a surrogate pair; it is derived from
     '&utf16-string-decoding'.  It has the following fields:

     'bytevector'
          The bytevector object.

     'index'
          The index of the offending second word.

     'first-word'
          The correct first word.

     'second-word'
          The offending second word.

 -- Function: make-utf16-string-decoding-invalid-second-word BYTEVECTOR
          INDEX FIRST-WORD SECOND-WORD
     Build and return a new condition object of type
     '&utf16-string-decoding-invalid-second-word'.

 -- Function: utf16-string-decoding-invalid-second-word? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf16-string-decoding-invalid-second-word'; otherwise return
     '#f'.

 -- Function: utf16-string-decoding-invalid-second-word.bytevector CND
 -- Function: utf16-string-decoding-invalid-second-word.index CND
 -- Function: utf16-string-decoding-invalid-second-word.first-word CND
 -- Function: utf16-string-decoding-invalid-second-word.second-word CND
     Field accessors for condition objects of type
     '&utf16-string-decoding-invalid-second-word'.

Missing second word in UTF-16 bytevectors
.........................................

 -- Condition Type: &utf16-string-decoding-missing-second-word
     Condition object type representing a missing 16-bit word in the
     position of second word of a surrogate pair; it is derived from
     '&utf16-string-decoding'.  It has the following fields:

     'bytevector'
          The bytevector object.

     'index'
          The index of the correct first word.

     'word'
          The correct first word.

 -- Function: make-utf16-string-decoding-missing-second-word BYTEVECTOR
          INDEX WORD
     Build and return a new condition object of type
     '&utf16-string-decoding-missing-second-word'.

 -- Function: utf16-string-decoding-missing-second-word? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf16-string-decoding-missing-second-word'; otherwise return
     '#f'.

 -- Function: utf16-string-decoding-missing-second-word.bytevector CND
 -- Function: utf16-string-decoding-missing-second-word.index CND
 -- Function: utf16-string-decoding-missing-second-word.word CND
     Field accessors for condition objects of type
     '&utf16-string-decoding-missing-second-word'.

Standalone octet in UTF-16 bytevectors
......................................

 -- Condition Type: &utf16-string-decoding-standalone-octet
     Condition object type representing a standalone octet at the end of
     the byte vector; it is derived from '&utf16-string-decoding'.  It
     has the following fields:

     'bytevector'
          The bytevector object.

     'index'
          The index of the octet.

     'octet'
          The offending octet.

 -- Function: make-utf16-string-decoding-standalone-octet BYTEVECTOR
          INDEX OCTET
     Build and return a new condition object of type
     '&utf16-string-decoding-standalone-octet'.

 -- Function: utf16-string-decoding-standalone-octet? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf16-string-decoding-standalone-octet'; otherwise return '#f'.

 -- Function: utf16-string-decoding-standalone-octet.bytevector CND
 -- Function: utf16-string-decoding-standalone-octet.index CND
 -- Function: utf16-string-decoding-standalone-octet.octet CND
     Field accessors for condition objects of type
     '&utf16-string-decoding-standalone-octet'.


File: vicare-scheme.info,  Node: iklib conditions string utf32,  Prev: iklib conditions string utf16,  Up: iklib conditions string

6.12.18.4 UTF-32 string encoding condition types
................................................

Encoding strings into UTF-32 bytevectors
........................................

 -- Condition Type: &utf32-string-encoding
     Condition object type representing an error while encoding a string
     into a UTF-32 bytevector; it is derived from '&string-encoding'.

 -- Function: make-utf32-string-encoding-error
     Build and return a new condition object of type
     '&utf32-string-encoding'.

 -- Function: utf32-string-encoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf32-string-encoding'; otherwise return '#f'.

Decoding strings from UTF-32 bytevectors
........................................

 -- Condition Type: &utf32-string-decoding
     Condition object type representing an error while decoding a UTF-32
     bytevector into a string; it is derived from '&string-decoding'.

 -- Function: make-utf32-string-decoding-error
     Build and return a new condition object of type
     '&utf32-string-decoding'.

 -- Function: utf32-string-decoding-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf32-string-decoding'; otherwise return '#f'.

Invalid 32-bit word in UTF-32 bytevectors
.........................................

 -- Condition Type: &utf32-string-decoding-invalid-word
     Condition object type representing an invalid 32-bit word; it is
     derived from '&utf32-string-decoding'.  It has the following
     fields:

     'bytevector'
          The bytevector object.

     'index'
          The index of the offending word.

     'word'
          The offending word.

 -- Function: make-utf32-string-decoding-invalid-word BYTEVECTOR INDEX
          WORD
     Build and return a new condition object of type
     '&utf32-string-decoding-invalid-word'.

 -- Function: utf32-string-decoding-invalid-word? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf32-string-decoding-invalid-word'; otherwise return '#f'.

 -- Function: utf32-string-decoding-invalid-word.bytevector CND
 -- Function: utf32-string-decoding-invalid-word.index CND
 -- Function: utf32-string-decoding-invalid-word.word CND
     Field accessors for condition objects of type
     '&utf32-string-decoding-invalid-word'.

Orphan octets at end of UTF-32 bytevectors
..........................................

 -- Condition Type: &utf32-string-decoding-orphan-octets
     Condition object type representing the presence of 1, 2 or 3 orphan
     octets at the end of the UTF-32 bytevector; it is derived from
     '&utf32-string-decoding'.  It has the following fields:

     'bytevector'
          The bytevector object.

     'index'
          The index of the first octet.

     'octets'
          A list of fixnums representing the octets.

 -- Function: make-utf32-string-decoding-orphan-octets BYTEVECTOR INDEX
          OCTETS
     Build and return a new condition object of type
     '&utf32-string-decoding-orphan-octets'.

 -- Function: utf32-string-decoding-orphan-octets? OBJ
     Return '#t' if OBJ is a condition object of type
     '&utf32-string-decoding-orphan-octets'; otherwise return '#f'.

 -- Function: utf32-string-decoding-orphan-octets.bytevector CND
 -- Function: utf32-string-decoding-orphan-octets.index CND
 -- Function: utf32-string-decoding-orphan-octets.octets CND


File: vicare-scheme.info,  Node: iklib conditions wfs,  Next: iklib conditions misc,  Prev: iklib conditions string,  Up: iklib conditions

6.12.19 Wrong FASL header
-------------------------

 -- Condition Type: &i/o-wrong-fasl-header-error
     Condition object type representing an error while reading a FASL
     file: the header of the file is wrong; it is derived from '&i/o'.

 -- Function: make-i/o-wrong-fasl-header-error-error
     Build and return a new condition object of type
     '&i/o-wrong-fasl-header-error'.

 -- Function: i/o-wrong-fasl-header-error-error? OBJ
     Return '#t' if OBJ is a condition object of type
     '&i/o-wrong-fasl-header-error'; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib conditions misc,  Prev: iklib conditions wfs,  Up: iklib conditions

6.12.20 Miscellaneous primitives
--------------------------------

 -- Function: compound-condition? OBJ
     Return '#t' if OBJ is a compound condition object; otherwise return
     '#f'.

          (compound-condition? (make-error))
          => #f

          (compound-condition? (condition (make-error)
                                          (make-warning)))
          => #t

          (compound-condition? "ciao")
          => #f

 -- Function: condition-and-rtd? OBJ RTD
     Return '#t' if OBJ is either a simple condition object of type RTD
     or a compound condition object containing a simple condition object
     of type RTD; otherwise return '#f'.  RTD must be the record-type
     descriptor of a condition object type.

          (condition-and-rtd? (make-error)
                              (record-type-descriptor &error))
          => #t

          (condition-and-rtd? (condition (make-error)
                                         (make-warning))
                              (record-type-descriptor &error))
          => #t

          (condition-and-rtd? "ciao"
                              (record-type-descriptor &error))
          => #f

 -- Function: print-condition CND
 -- Function: print-condition CND PORT
     Print a human readable serialisation of a condition object to the
     given PORT, which must be a textual output port.  When not given:
     PORT defaults to the return value of '(console-error-port)'.


File: vicare-scheme.info,  Node: iklib reader,  Next: iklib expander,  Prev: iklib conditions,  Up: iklib

6.13 Reader
===========

* Menu:

* iklib reader mode::           Textual input port modes.
* iklib reader bv::             Additional bytevector syntaxes.
* iklib reader chars::          Custom named characters.
* iklib reader annotations::    Reader annotations.
* iklib reader misc::           Miscellaneous additional syntaxes.
* iklib reader extensions::     Extending the reader with
                                custom syntaxes.


File: vicare-scheme.info,  Node: iklib reader mode,  Next: iklib reader bv,  Up: iklib reader

6.13.1 Textual input port modes
-------------------------------

 -- Reader Syntax: #!vicare
 -- Reader Syntax: #!ikarus
     Vicare extends Scheme's lexical syntax (R6RS Chapter 4) in a
     variety of ways including:

        * End-of-file marker, '#!eof'.

        * Void object, '#!void'.

        * Would-block object, '#!would-block'.

        * Unbound object, '#!unbound'.

        * BWP object, '#!bwp'.

        * Gensym syntax, '#{gensym}'.

        * Shared structures graph notation: '#nn=', '#nn#'.

        * Special symbols: '++', '--'.

        * Special symbol '|', which is a standalone vertical bar.

        * Special symbols beginning with '+g' and '-g', to allow reading
          symbols starting with '+greek-pi' and '-greek-pi'.

        * Brace lists '{ ... }' are read as '(brace ...)', *note brace:
          iklib syntaxes misc.

     The syntax extensions are made available by default on all input
     ports, until the token '#!r6rs' is read; thus, reading the token
     '#!r6rs' disables all extensions to the lexical syntax on the
     specific port, and the token '#!vicare' enables them again.

     When writing code that is intended to be portable across different
     Scheme implementations, we should add the token '#!r6rs' to the top
     of every script and library that we write; this allows Vicare to
     alert us when using non-portable features.  When writing code
     that's intended to be Vicare-specific, we should add the token
     '#!vicare' in order to get an immediate error when the code is run
     under other implementations.

     The comment '#!ikarus' is accepted for backwards compatibility with
     Ikarus Scheme.

 -- Procedure: port-mode INPUT-PORT
     Accept an input port as argument and return a symbol among: 'r6rs',
     'vicare'.  All input ports start under 'vicare' mode and thus
     accept Vicare-specific reader extensions.  When the token '#!r6rs'
     is read from a port: its mode changes to 'r6rs'.

          > (port-mode (current-input-port))
          vicare
          > #!r6rs (port-mode (current-input-port))
          r6rs
          > #!vicare (port-mode (current-input-port))
          vicare

 -- Procedure: set-port-mode! INPUT-PORT MODE
     Modifiy the lexical syntax accepted by subsequent calls to 'read'
     on the input port.  The mode is a symbol among 'r6rs' and 'vicare'.
     The effect of setting the port mode is similar to that of reading
     the token '#!r6rs' or '#!vicare' from that port.

          > (set-port-mode! (current-input-port) 'r6rs)
          > (port-mode (current-input-port))
          r6rs


File: vicare-scheme.info,  Node: iklib reader bv,  Next: iklib reader chars,  Prev: iklib reader mode,  Up: iklib reader

6.13.2 Additional bytevector syntaxes
-------------------------------------

The following syntaxes are available only when the input port mode is
set to 'vicare'.

 -- Reader Syntax: #vs8(BYTE ...)
     Read a bytevector as '#vu8(OCTECT ...)' would do, but allow BYTE to
     be in the range [-128, 127].

 -- Reader Syntax: #vu16l(WORD ...)
 -- Reader Syntax: #vu16b(WORD ...)
 -- Reader Syntax: #vu16n(WORD ...)
     Read a bytevector of 16-bit unsigned words stored in little, big
     and native endianness.

 -- Reader Syntax: #vs16l(WORD ...)
 -- Reader Syntax: #vs16b(WORD ...)
 -- Reader Syntax: #vs16n(WORD ...)
     Read a bytevector of 16-bit signed words stored in little, big and
     native endianness.

 -- Reader Syntax: #vu32l(WORD ...)
 -- Reader Syntax: #vu32b(WORD ...)
 -- Reader Syntax: #vu32n(WORD ...)
     Read a bytevector of 32-bit unsigned words stored in little, big
     and native endianness.

 -- Reader Syntax: #vs32l(WORD ...)
 -- Reader Syntax: #vs32b(WORD ...)
 -- Reader Syntax: #vs32n(WORD ...)
     Read a bytevector of 32-bit signed words stored in little, big and
     native endianness.

 -- Reader Syntax: #vu64l(WORD ...)
 -- Reader Syntax: #vu64b(WORD ...)
 -- Reader Syntax: #vu64n(WORD ...)
     Read a bytevector of 64-bit unsigned words stored in little, big
     and native endianness.

 -- Reader Syntax: #vs64l(WORD ...)
 -- Reader Syntax: #vs64b(WORD ...)
 -- Reader Syntax: #vs64n(WORD ...)
     Read a bytevector of 64-bit signed words stored in little, big and
     native endianness.

 -- Reader Syntax: #vf4l(FLONUM ...)
 -- Reader Syntax: #vf4b(FLONUM ...)
 -- Reader Syntax: #vf4n(FLONUM ...)
     Read a bytevector of single-precision flonums stored in little, big
     and native endianness.

 -- Reader Syntax: #vf8l(FLONUM ...)
 -- Reader Syntax: #vf8b(FLONUM ...)
 -- Reader Syntax: #vf8n(FLONUM ...)
     Read a bytevector of double-precision flonums stored in little, big
     and native endianness.

 -- Reader Syntax: #vc4l(CFLONUM ...)
 -- Reader Syntax: #vc4b(CFLONUM ...)
 -- Reader Syntax: #vc4n(CFLONUM ...)
     Read a bytevector of single-precision cflonums stored in little,
     big and native endianness, real part first.

 -- Reader Syntax: #vc8l(CFLONUM ...)
 -- Reader Syntax: #vc8b(CFLONUM ...)
 -- Reader Syntax: #vc8n(CFLONUM ...)
     Read a bytevector of double-precision cflonums stored in little,
     big and native endianness, real part first.

 -- Reader Syntax: #ve(ENCODING DATA)
     Read a bytevector in some encoding which is supposed to be easy to
     type for human beings.  ENCODING is a symbol representing the
     encoding format, DATA is a datum to convert to bytevector.  At
     present the following encodings are supported:

     'ascii'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->ascii'.

     'latin1'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->latin1'.

     'utf8'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->utf8'.

     'utf16be'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->utf16be'.

     'utf16le'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->utf16le'.

     'utf16n'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->utf16n'.

     'hex'
          Convert the Scheme string DATA to a bytevector using the
          function 'string-hex->bytevector'.

     'base64'
          Convert the Scheme string DATA to a bytevector using the
          function 'string-base64->bytevector'.

     'percent-encoding'
          Convert the Scheme string DATA to a bytevector using the
          function 'string->percent-encoding'.


File: vicare-scheme.info,  Node: iklib reader chars,  Next: iklib reader annotations,  Prev: iklib reader bv,  Up: iklib reader

6.13.3 Custom named characters
------------------------------

The following syntaxes are available only when the input port mode is
set to 'vicare'.

 -- Reader Syntax: #!(char-names (?NAME . ?CHAR) ...)
     Add new custom named characters to the internal table for the
     current reading operation.  Each ?NAME must be a Scheme identifier
     starting with a ?CONSTITUENT character as defined by R6RS; each
     ?CHAR must be a Scheme character.

          #!(char-names
              (lambda . #\x0EBB))

 -- Reader Syntax: #\{?NAME}
     Reader syntax for standalone custom named characters.  ?NAME must
     be an identifier previously defined with the 'char-names' comment
     list defined above.

          #\{lambda}            => #\xEBB

 -- Reader Syntax: \{?NAME}
     Reader syntax for custom named characters embedded in strings.
     ?NAME must be an identifier previously defined with the
     'char-names' comment list defined above.

          "\{lambda}"           => "\xEBB;"


File: vicare-scheme.info,  Node: iklib reader annotations,  Next: iklib reader misc,  Prev: iklib reader chars,  Up: iklib reader

6.13.4 Reader annotations
-------------------------

The Scheme source code reader allows us to annotate source code read
from a textual input with informations about the position of an
expression in the input.  For example:

     (import (vicare))

     (define port  (open-string-input-port "(list var)"))
     (define datum (get-annotated-datum port))
     (pretty-print datum)
     -| #[reader-annotation
             expression=#<omitted>
             stripped=(list var)
             textual-position=#[record: &source-position
                                   port-id="*string-input-port*"
                                   byte=0
                                   character=0
                                   line=1
                                   column=1]]

   The following bindings are exported by the library '(vicare)'.

 -- Function: get-annotated-datum PORT
     Like 'get-datum', but rather than returning a datum return a
     hierarchy of '<reader-annotation>' objects with the same hierarchy
     of the datum and embedding the datum itself.

 -- Function: reader-annotation? OBJ
     Return '#t' if OBJ is an '<reader-annotation>' object, else return
     '#f'.

 -- Function: reader-annotation-expression ANN
     Return a list, vector, identifier, what-have-you that may contain
     further annotations.

 -- Function: reader-annotation-stripped ANN
     Return the same symbolic expression of the 'expression' field with
     no annotations.

 -- Function: reader-annotation-textual-position ANN
     Return a condition object of type '&source-position' representing
     the position of the expression in the source code.

 -- Function: reader-annotation-source ANN
     Return a pair whose car is the port identifier and whose cdr is the
     offset of the first character of the source expression in the
     textual input.


File: vicare-scheme.info,  Node: iklib reader misc,  Next: iklib reader extensions,  Prev: iklib reader annotations,  Up: iklib reader

6.13.5 Miscellaneous additional syntaxes
----------------------------------------

The following syntaxes are available only when the input port mode is
set to 'vicare'.

 -- Reader Syntax: |SYMBOL|
     The vertical bars can be used to specify symbols whose name does
     not comply with the R6RS specifications; this syntax is available
     only when the port mode is '#!vicare'.  Examples:

          (define port (open-string-input-port "|123|"))
          (set-port-mode! port 'vicare)
          (define sym (read port))

          (symbol? sym)           => #t
          (symbol->string sym)    => "123"

     backslash sequences are allowed in bar symbols:

          (define port (open-string-input-port "|123-\x41;\x42;\x43;|"))
          (set-port-mode! port 'vicare)
          (define sym (read port))

          (symbol? sym)           => #t
          (symbol->string sym)    => "123-\x41;\x42;\x43;"

     notice that the sequence of characters '|ciao|hello|' is split into
     'ciao', 'hello', '|' and the ending vertical bar would cause an
     error if read:

          (define port (open-string-input-port "|ciao|hello|"))
          (set-port-mode! port 'vicare)

          (read port)             => ciao
          (read port)             => hello
          (port-eof? port)        => #f
          (get-char port)         => #\|
          (port-eof? port)        => #t

 -- Reader Syntax: #{unique-name}
 -- Reader Syntax: #{pretty-name unique-name}
     Vicare's 'read' and 'write' procedures extend the lexical syntax of
     Scheme by the ability to read and write gensyms using one of these
     three forms.

     '#{unique-name}' constructs, at read time, a gensym whose unique
     name is the one specified.  If a gensym with the same unique name
     already exists in the system's symbol table, that gensym is
     returned.

          > '#{some-long-name}
          #{g0 |some-long-name|}
          > (gensym? '#{some-long-unique-name})
          #t
          > (eq? '#{another-unique-name} '#{another-unique-name})
          #t

     The two-part '#{pretty-name unique-name}' gensym syntax is similar
     to the syntax shown above with the exception that if a new gensym
     is constructed (that is, if the gensym did not already exist in the
     symbol table), the pretty name of the constructed gensym is set to
     'pretty-name'.

          > '#{foo unique-identifier}
          #{foo |unique-identifier|}
          > '#{unique-identifier}
          #{foo |unique-identifier|}
          > '#{bar unique-identifier}
          #{foo |unique-identifier|}

 -- Reader Syntax: #:SYMBOL
     Read a keyword object using SYMBOL as symbol.  SYMBOL must be a
     symbol object as defined by R6RS.  *note Keyword objects: iklib
     keywords.

 -- Reader Syntax: #!eof
     The end-of-file marker, '#!eof', is an extension to the R6RS
     syntax.  The primary utility of the '#!eof' marker is to stop the
     reader (e.g.  'read' and 'get-datum') from reading the rest of the
     file.

          (import (vicare))
          <some code>
          (display "goodbye\n")

          #!eof
          <some junk>

     The '#!eof' marker also serves as a datum in Vicare, much like '#t'
     and '#f', when it is found inside other expressions.

          > (eof-object)
          #!eof
          > (read (open-input-string ""))
          #!eof
          > (read (open-input-string "#!eof"))
          #!eof
          > (quote #!eof)
          #!eof
          > (eof-object? '#!eof)
          #t
          > #!r6rs #!eof
          Unhandled exception
           Condition components:
             1. &lexical
             2. &i/o-read
             3. &message: "invalid syntax"
             4. &irritants: ("#!eof")
             5. &source-position:
                 port-id: "*stdin*"
                 ...
          > #!vicare #!eof
          $

 -- Reader Syntax: #ci FORM
 -- Reader Syntax: #cs FORM
     Switch between case sensitive and case insensitive identifiers; the
     default for R6RS source code is case sensitive.  When '#ci' is
     read: the next form read has case insensitive identifiers.  When
     '#cs' is read: the next form read has case sensitive identifiers.

          #ci(1 2 3)              => (1 2 3)
          #cs(1 2 3)              => (1 2 3)

          #ci(1 A 3)              => (1 a 3)
          #cs(1 A 3)              => (1 A 3)

          #ci CIAO #cs CIAO       => ciao CIAO
          #ci CIAO CIAO           => ciao CIAO

          #ci(A #csB C)           => (a B c)
          #ci(A #cs B C)          => (a B c)


File: vicare-scheme.info,  Node: iklib reader extensions,  Prev: iklib reader misc,  Up: iklib reader

6.13.6 Extending the reader with custom syntaxes
------------------------------------------------

When the source code reader is in '#!vicare' mode, it is possible to
include "here documents" processed (at read-time) by custom functions.
This feature works only when reading source code for libraries or
programs, at present it does *not* work at the REPL.

   Let's see how it works.  Assuming the following library is in the
search path:

     (library (libdemo)
       (export doit)
       (import (rnrs))
       (define (doit input-string)
         (read (open-string-input-port input-string))))

let's consider this program file:

     #!vicare
     (reader-import (libdemo))
     (program (demo)
       (import (rnrs))
       (display #<doit 456>#)
       (newline)
       (flush-output-port (current-output-port)))

we see that *at the beginning* of a program file (before the 'program'
form) we have:

     (reader-import (libdemo))

and in the body of the program we have the block:

     #<doit 456>#

such block is converted by the reader to the form:

     (doit "456")

notice that whitespace characters after the symbol "doit" are discarded.
Such form is handed to 'eval' and evaluated in the context of the
lexical environment resulting from importing '(libdemo)'; the result of
the evaluation is returned to the reader for inclusion in its output.
So the reader gets the symbolic expression '456'.

 -- Reader Syntax: reader-import ?IMPORT-SET0 ?IMPORT-SET ...
     This symbolic expression supports the same format of 'import'; it
     is not a syntactic binding, rather it is a symbolic expression
     processed by the source code reader.  This expression can be
     present only at the beginning of a program or library file, before
     the 'program' or 'library' form; it is recognised only when the
     input port is in '#!vicare' mode.

     The import sets are used to initialise an interaction environment
     for subsequent code evaluation.

 -- Reader Syntax: #<?SYMBOL ?CHARACTERS>#
     A reader syntax recognised only when the input port is in
     '#!vicare' mode.  The argument ?SYMBOL must be a symbol.  The
     argument ?CHARACTERS, up to and excluding '>#', are read to compose
     an input string.

     The argument ?SYMBOL must be:

        * The symbol 'begin'.  In this case the: the input string is
          interpreted as a list of Scheme forms representing definitions
          and expressions to be evaluated in the interaction environment
          established by the 'reader-import' syntax.

        * The name of a function or syntax defined in the interaction
          environment generated by the 'reader-import' syntax.  In this
          case: the input string is handed to the ?SYMBOL function or
          syntax as single operand; the result of such application must
          be a single return value which becomes a datum for the reader.


File: vicare-scheme.info,  Node: iklib expander,  Next: iklib shared,  Prev: iklib reader,  Up: iklib

6.14 Interface to the expander
==============================

* Menu:

* iklib expander language::         Language selection.
* iklib expander transformers::     Syntax transformers facilities.
* iklib expander export specs::     Additional export specifications.
* iklib expander import specs::     Additional import specifications.
* iklib expander local import::     Local library imports.
* iklib expander extended export::  Extended library exports.
* iklib expander fluids::           Fluid syntaxes.
* iklib expander etv::              Expand-time values.
* iklib expander parameters::       Expand-time parameters.
* iklib expander synonym::          Synonym transformers.


File: vicare-scheme.info,  Node: iklib expander language,  Next: iklib expander transformers,  Up: iklib expander

6.14.1 Language selection
-------------------------

 -- Function: typed-language-enabled?
 -- Function: typed-language-enabled? OBJ
     Enable or disable typed language support.  This function is meant
     to be called at the REPL, it *does not* modify the expander's
     behaviour when expanding programs, libraries and standalone 'eval'
     expressions.

        * When called with no arguments: do nothing.  Return a boolean
          value: '#t' if typed language support is enabled; '#f'
          otherwise.

        * When called with one argument: if OBJ is non-false, enable
          typed language support; otherwise disable it.  Return a
          boolean value: '#t' if typed language support is enabled after
          the call; '#f' otherwise.

 -- Function: strict-r6rs-enabled?
 -- Function: strict-r6rs-enabled? OBJ
     Enable or disable strict R6RS support.  This function is meant to
     be called at the REPL, it *does not* modify the expander's
     behaviour when expanding programs, libraries and standalone 'eval'
     expressions.

        * When called with no arguments: do nothing.  Return a boolean
          value: '#t' if strict R6RS support is enabled; '#f' otherwise.

        * When called with one argument: if OBJ is non-false, enable
          strict R6RS support; otherwise disable it.  Return a boolean
          value: '#t' if typed language support is enabled after the
          call; '#f' otherwise.


File: vicare-scheme.info,  Node: iklib expander transformers,  Next: iklib expander export specs,  Prev: iklib expander language,  Up: iklib expander

6.14.2 Syntax transformers facilities
-------------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: make-variable-transformer FUNC
     Defined by R6RS.  Build and return a "special" value that, when
     used as right-hand side of a syntax definition, is recognised by
     the expander as a variable transformer as opposed to a normal
     transformer or a compile-time value.

     'func' must be the transformer function.

 -- Function: variable-transformer? OBJ
     Return '#t' if OBJ is recognised by the expander as a variable
     transformer as opposed to a normal transformer or a compile-time
     value; otherwise return '#f'.

 -- Function: variable-transformer-procedure VAR-TRASF
     If VAR-TRASF is recognised by the expander as a variable
     transformer: return the actual transformer function, otherwise
     raise an assertion violation.


File: vicare-scheme.info,  Node: iklib expander export specs,  Next: iklib expander import specs,  Prev: iklib expander transformers,  Up: iklib expander

6.14.3 Additional export specifications
---------------------------------------

 -- Export Spec: prefix (?INTERNAL ...) ?PREFIX
     Prepend the specified prefix to the selected internal symbols and
     add the result to the export list.  This clause is forbidden when
     running with the command line option '--strict-r6rs'.

          (library (demo)
            (export
              (prefix (these those) yeah.))
            (import (rnrs))
            (define (these) "these")
            (define (those) "those"))

 -- Export Spec: deprefix (?INTERNAL ...) ?PREFIX
     Remove the specified prefix from the selected internal symbols and
     add the result to the export list.  This clause is forbidden when
     running with the command line option '--strict-r6rs'.

          (library (demo)
            (export
              (deprefix (yeah.this yeah.that) yeah.))
            (import (rnrs))
            (define (yeah.this) "this")
            (define (yeah.that) "that"))

 -- Export Spec: suffix (?INTERNAL ...) ?SUFFIX
     Append the specified suffix to the selected internal symbols and
     add the result to the export list.  This clause is forbidden when
     running with the command line option '--strict-r6rs'.

          (library (demo)
            (export
              (suffix (these those) _yeah))
            (import (rnrs))
            (define (these) "these")
            (define (those) "those"))

 -- Export Spec: desuffix (?INTERNAL ...) ?SUFFIX
     Remove the specified suffix from the selected internal symbols and
     add the result to the export list.  This clause is forbidden when
     running with the command line option '--strict-r6rs'.

          (library (demo)
            (export
              (desuffix (this_yeah that_yeah) _yeah))
            (import (rnrs))
            (define (this_yeah) "this")
            (define (that_yeah) "that"))


File: vicare-scheme.info,  Node: iklib expander import specs,  Next: iklib expander local import,  Prev: iklib expander export specs,  Up: iklib expander

6.14.4 Additional import specifications
---------------------------------------

 -- Import Spec: deprefix ?IMPORT-SPEC ?PREFIX
     Similar to the import specification 'prefix', but remove a prefix
     rather than add it.  This clause is forbidden when running with the
     command line option '--strict-r6rs'.

          (import (rnrs)
            (rnrs eval))

          (eval '(str.length "ciao")
                (environment
                 '(prefix
                   (deprefix (only (rnrs)
                                   string-length
                                   string-append)
                             string-)
                   str.)))
          => 4

 -- Import Spec: suffix ?IMPORT-SPEC ?SUFFIX
     Similar to the import specification 'prefix', but append a suffix
     rather than a prefix.  This clause is forbidden when running with
     the command line option '--strict-r6rs'.

 -- Import Spec: desuffix ?IMPORT-SPEC ?SUFFIX
     Similar to the import specification 'deprefix', but remove a suffix
     rather than a prefix.  This clause is forbidden when running with
     the command line option '--strict-r6rs'.


File: vicare-scheme.info,  Node: iklib expander local import,  Next: iklib expander extended export,  Prev: iklib expander import specs,  Up: iklib expander

6.14.5 Local library imports
----------------------------

Local 'import' forms are useful for the following reasons:

  1. They minimize the namespace clutter that usually occurs when many
     libraries are imported at the top level.

  2. They limit the scope of the import and thus help modularize a
     library's dependencies.

  3. They allow conditional importing of libraries, and so importing
     alternative libraries according to some expand-time test.

   Let's suppose we are constructing a large library and at some point
we realize that a procedure needs to make use of some other library to
performing a specific task; importing that library at top level makes it
available for the entire library.  Consequently, even if that library is
no longer used anywhere in the code (say when the code that uses it is
deleted), it becomes very hard to delete the import without first
examiniming the entire library body for potential usage leaks.  By
locally importing a library into the appropriate scope, we gain the
ability to delete the 'import' form when the procedure that was using it
is deleted.

 -- Syntax: import ?IMPORT-SPEC ...
     This syntax can be used anywhere definitions can occur:

       1. In a script body.

       2. At library's top-level.

       3. In internal definitions context.

     The syntax of the local 'import' form is similar to the 'import'
     that appears at the top of a library or a script form, and carries
     with it the same restrictions:

        * No identifier name may be imported twice unless it denotes the
          same identifier.

        * No identifier may be both imported and defined.

        * Imported identifiers are immutable.

     Each ?IMPORT-SPEC can be as defined by R6RS or a symbol
     representing the name of a module; notice that module import
     specifications support all the renaming facilities.

   In the following example we import a library in the body of a
function:

     ;;; file "alpha.sls"
     (library (alpha)
       (export doit)
       (import (vicare))
       (define (doit)
         (fprintf (current-error-port) "From alpha!\n")))

     ;;; file "beta.sls"
     (library (beta)
       (export doit)
       (import (vicare))
       (define (doit)
         (fprintf (current-error-port) "From beta!\n")))

     ;;; file "program.sps"
     (import (vicare)
       (alpha))
     (define (do-that)
       (import (beta))
       (doit))
     (doit)
     (do-that)
     -| From alpha!
     -| From beta!

   In the following example we import bindings from a module in the body
of a function:

     (import (vicare))

     (define (doit)
       (fprintf (current-error-port) "From body!\n"))

     (module do-stuff
       (doit)
       (define (doit)
         (fprintf (current-error-port) "From module!\n")))

     (define (do-that)
       (import do-stuff)
       (doit))

     (doit)
     (do-that)
     -| From body!
     -| From module!

   In the following example: if SRFI-13 is available, import
'string-concatenate' from it; otherwise define a custom version of the
function.

     #!r6rs
     (import (vicare)
       (srfi :0))

     (cond-expand
      ((srfi :13)
       (import (only (srfi :13)
                     string-concatenate)))
      (else
       (define (string-concatenate strs)
         (receive (port getter)
             (open-string-output-port)
           (for-each-in-order (lambda (str)
                                (display str port))
             strs)
           (getter)))))

     (display (string-concatenate '("a" "b" "c")))
     (newline)
     (flush-output-port (current-output-port))


File: vicare-scheme.info,  Node: iklib expander extended export,  Next: iklib expander fluids,  Prev: iklib expander local import,  Up: iklib expander

6.14.6 Extended library exports
-------------------------------

Vicare allows the 'export' syntax to appear at the top level of a
library among the definitions, not only as third form of a 'library'
form.

 -- Syntax: export ?EXPORT-SPEC ...
     Export the specified bidings from the current library or module.
     When 'export' appears at the top level of a library: it exports the
     specified bindings from the library.  When 'export' appears in the
     body of a module: it exports the specified bindings from the module
     (*not* from the enclosing library).

   Here is an example of library exporting a binding with a 'export' at
the end:

     ;;; file "alpha.sls"
     (library (alpha)
       (export red)
       (import (vicare))
       (define (blue)
         'blue)
       (define (red)
         'red)
       (export blue))

     ;;; file "program.sps"
     (import (vicare)
       (alpha))
     (pretty-print (red)  (current-error-port))
     (pretty-print (blue) (current-error-port))

   Here is an example of module exporting a binding with 'export':

     (import (vicare))

     (module (green)
       (define (green) 'green)
       (define (yellow) 'yellow)
       (export yellow))

     (list (green) (yellow)) => (green yellow)


File: vicare-scheme.info,  Node: iklib expander fluids,  Next: iklib expander etv,  Prev: iklib expander extended export,  Up: iklib expander

6.14.7 Fluid syntaxes
---------------------

Fluid syntaxes are macro bindings that can be temporarily redefined
while expanding a sequence of forms:

     (import (vicare))

     (define-fluid-syntax ciao
       (identifier-syntax "ciao"))

     ciao    => "ciao"

     (fluid-let-syntax ((ciao (identifier-syntax "hello")))
       ciao) => "hello"

     (fluid-let-syntax ((ciao (identifier-syntax "ohayo")))
       ciao) => "ohayo"

     ciao    => "ciao"

 -- Syntax: define-fluid-syntax ?KEYWORD ?EXPR
     Like 'define-syntax' define a new syntax binding the transformer to
     ?KEYWORD, but mark ?KEYWORD as fluid so that later it can be
     rebound by 'fluid-let-syntax'.

 -- Syntax: fluid-let-syntax ((?KEYWORD ?EXPR) ...) ?BODY0 ?BODY ...
     Similar, but not equal, to 'let-syntax'; rather than defining new
     ?KEYWORD bindings, temporarily rebind the keywords to new
     transformers while expanding the ?BODY forms.  The given ?KEYWORD
     must be already bound to fluid syntaxes defined by
     'define-fluid-syntax'.

     There are two differences between 'fluid-let-syntax' and
     'let-syntax': 'fluid-let-syntax' must appear in expression context
     only; the internal ?BODY forms are *not* spliced in the enclosing
     body.


File: vicare-scheme.info,  Node: iklib expander etv,  Next: iklib expander parameters,  Prev: iklib expander fluids,  Up: iklib expander

6.14.8 expand-time values
-------------------------

It is sometimes useful to precompute a value at expand-time and push it
on the lexical environment to be later retrieved.  Here is an example of
simple expand-time value computation, retrieval and insertion in which
the value is a self-evaluating fixnum:

     (import (vicare))

     (define-syntax obj1
       (make-expand-time-value (+ 1 2 3)))

     (define-syntax get-obj1
       (lambda (stx)
         (retrieve-expand-time-value #'obj1)))

     (get-obj1) ==> 6

here is an example of simple expand-time value computation, retrieval
and insertion in which the value is a non-self-evaluating vector:

     (import (vicare))

     (define-syntax obj2
       (make-expand-time-value (vector 1 2 3)))

     (define-syntax get-obj2
       (lambda (stx)
         #`(quote #,(retrieve-expand-time-value #'obj2))))

     (get-obj2) ==> (quote #(1 2 3))

we see that to produce an expand-time value we define a syntax keyword
bound to the result of 'make-expand-time-value'.

 -- Function: make-expand-time-value OBJ
     Build and return a "special" object that is recognised by the
     expander as holding OBJ as a precomputed expand-time object.

 -- Function: expand-time-value? OBJ
     Return '#t' if OBJ is a "special" object that is recognised by the
     expander as holding a precomputed expand-time object.

 -- Function: expand-time-value-object ETV
     Given a "special" object that is recognised by the expander as
     holding a precomputed expand-time object: return the actual value.

 -- Function: retrieve-expand-time-value ID
     Given a syntactic identifier return its associated expand-time
     value; if ID is not associated to a expand-time value: return '#f'.

What expand-time values are *not* for
.....................................

We have to understand that the real use of expand-time values is not
actually to precompute values and put them in compiled code; for this we
can just use 'define-inline-constant', which in the end defines a
"normal" syntax transformer as the following:

     (import (vicare))

     (define-syntax obj1
       (let ((const (vector 1 2 3)))
         (lambda (stx)
           (syntax-case stx ()
             (?id
              (identifier? #'?id)
              #`(quote #,const))))))

     obj1    ==> (quote #(1 2 3))

What expand-time values are for
...............................

Let's say we define a record type in a library (it must go in a library
so that we can import it and use it at expand-time in the body of
transformers):

     (library (etv-demo)
       (export that make-that
               that-a that-b that-c)
       (import (vicare))
       (define-record-type that
         (fields a b c)))

now we can instantiate a struct 'that' and push the instance on the
lexical environment, bound to the identifier 'it':

     (import (vicare)
       (for (etv-demo) expand))

     (define-syntax it
       (make-expand-time-value
         (make-that 1 2 3)))

later we retrieve the struct instance, through the identifier 'it', and
use its fields to produce the output of a syntax use:

     (define-syntax get-it
       (lambda (stx)
         (let ((S (retrieve-expand-time-value #'it)))
           (with-syntax
               ((A (that-a S))
                (B (that-b S))
                (C (that-c S)))
             #'(quote #(A B C))))))

     (get-it)        ==> (quote #(1 2 3))


File: vicare-scheme.info,  Node: iklib expander parameters,  Next: iklib expander synonym,  Prev: iklib expander etv,  Up: iklib expander

6.14.9 Expand-time parameters
-----------------------------

Fluid syntaxes and expand-time values can be used to implement a sort of
expand-time parameters, *note Parameters: iklib parameters.  The
following example shows the mechanism by defining a "parameter" 'parm':

     (import (vicare))

     (define-syntax (show-it stx)
       (fprintf (current-error-port)
                "parm ~a: ~a\n"
                (cadr (syntax->datum stx))
                (retrieve-expand-time-value #'parm))
       #f)

     (define-fluid-syntax parm
       (make-expand-time-value #f))

     (show-it "1, expect #f")
     (fluid-let-syntax ((parm (make-expand-time-value #t)))
       (show-it "2, expect #t")
       (fluid-let-syntax ((parm (make-expand-time-value #f)))
         (show-it "3, expect #f"))
       (show-it "4, expect #t"))
     (show-it "5, expect #f")

the output of the program is:

     parm 1, expect #f: #f
     parm 5, expect #f: #f
     parm 2, expect #t: #t
     parm 3, expect #f: #f
     parm 4, expect #t: #t

Using the API described here, the example can be rewritten:

     (import (vicare))

     (define-syntax (show-it stx)
       (fprintf (current-error-port)
                "parm ~a: ~a\n"
                (cadr (syntax->datum stx))
                (syntax-parameter-value #'parm))
       #f)

     (define-syntax-parameter parm #f)

     (show-it "1, expect #f")
     (syntax-parametrise ((parm #t))
       (show-it "2, expect #t")
       (syntax-parametrise ((parm #f))
         (show-it "3, expect #f"))
       (show-it "4, expect #t"))
     (show-it "5, expect #f")

 -- Syntax: define-syntax-parameter ?PARM-ID ?EXPR
     Define a new syntax parameter bound to the identifier ?PARM-ID.
     The parameter is initialised to the result of evaluating the
     expand-time expression ?EXPR.

 -- Syntax: syntax-parametrise ((?PARM-ID ?EXPR) ...) ?BODY0 ?BODY ...
     Bind one or more syntax parameters to new expand-time values and
     while the body forms are expanded.  The arguments ?PARM-ID must be
     identifiers previously bound to expand-time values by
     'define-syntax-parameter'.  The arguments ?EXPR must be
     expressions.

 -- Function: syntax-parameter-value PARM-ID
     Return the syntax parameter value bound to PARM-ID, which must be
     an identifier previously bound by 'define-syntax-parameter'.  This
     function must be called only from the extent of a macro expansion;
     in practice: only by a macro transformer.


File: vicare-scheme.info,  Node: iklib expander synonym,  Prev: iklib expander parameters,  Up: iklib expander

6.14.10 Synonym transformers
----------------------------

Synonym transformers allow the creation of multiple identifiers which
resolve to the same syntactic binding.  Usage examples:

     (import (vicare))

     (define a 1)

     (define-syntax b
       (make-synonym-transformer #'a))

     (list a b)      => (1 1)

     (define-syntax c
       (make-synonym-transformer #'b))

     (list a b c)    => (1 1 1)

     (define-syntax d
       (make-synonym-transformer #'b))

     (set! c 2)

     (list a b c d)  => (2 2 2 2)

   Circular references are detected and cause a syntax violation to be
raised.

   If the identifier ID1 is bound to a synonym transformer with source
identifier ID2: the two identifiers resolve to the same syntactic
binding but are *not* 'free-identifier=?'.  To create an identifier that
is 'free-identifier=?' to another we have to use 'define-alias'.

 -- Function: make-synonym-transformer ID
     Build and return a "special" value that, when used as right-hand
     side of a syntax definition, is recognised by the expander as a
     synonym transformer as opposed to a normal transformer, variable
     transformer or a compile-time value.  ID must be the source
     identifier.

 -- Function: synonym-transformer? OBJ
     Return '#t' if OBJ is recognised by the expander as a synonym
     transformer as opposed to a normal transformer, variable
     transformer or a compile-time value; otherwise return '#f'.

 -- Function: synonym-transformer-identifier OBJ
     If OBJ is recognised by the expander as a synonym transformer:
     return the source identifier, otherwise raise an exception.


File: vicare-scheme.info,  Node: iklib shared,  Next: iklib environment,  Prev: iklib expander,  Up: iklib

6.15 Shared structures graph notation
=====================================

This feature of the reader is derived from the SRFI 38 "External
Representation for Data With Shared Structure":

            <http://srfi.schemers.org/srfi-38/srfi-38.html>

   This graph notation allows the reader to build symbolic expressions
with graph structure including cycles.  *Shared structures must always
be used inside quoted datums*; if we create a cycle in a symbolic
expression passed as code to the expander: the result will be an
infinite loop.  Graph notation is available only when the textual input
port is configured in '#!vicare' mode.

   Graph notation extends the R6RS syntax with these additional cases:

     <lexeme>                -> <r6rs lexeme>
                              | <defining datum>
                              | <defined datum>
     <defining datum>        -> #<indexnum>=<r6rs lexeme>
     <defined datum>         -> #<indexnum>#
     <indexnum>              -> <digit>+

where '<r6rs lexeme>' is the lexeme definition in R6RS.

 -- Parameter: print-graph
 -- Parameter: print-graph #t
 -- Parameter: print-graph #f
     The graph notation is a way of marking and referencing parts of a
     data structure and, consequently, creating shared and cyclic data
     structures at read time instead of resorting to explicit mutation
     at run time.  The default for this parameter is '#f'.

     In a string generated by the Scheme objects writer: the prefix
     '#N=' marks the subsequent data structure with mark N, where N is a
     non-negative integer.  The string '#N#' references the data
     structure marked N. Marks can be assigned and referenced in any
     order but each mark must be assigned to exactly once in an
     expression.

          > (let ([x '#0=(1 2 3)])
              (eq? x '#0#))
          #t
          > (let ([x '#0#] [y '#0=(1 2 3)])
              (eq? x y))
          #t
          > (eq? (cdr '(12 . #1#)) '#1=(1 2 3))
          #t
          > (let ([x '#1=(#1# . #1#)])
              (and (eq? x (car x))
                   (eq? x (cdr x))))
          #t

     The 'print-graph' parameter controls how the writers (e.g.
     'pretty-print' and 'write') handle shared and cyclic data
     structures.  In Vicare, all writers detect cyclic data structures
     and they all terminate on all input, cyclic or otherwise.

     If the value of 'print-graph' is set to '#f', then the writers do
     not attempt to detect shared data structures.  Any part of the
     input that is shared is printed as if no sharing is present.  If
     the value of 'print-graph' is set to '#t', all sharing of data
     structures is marked using the '#n=' and '#n#' notation.

          > (parameterize ((print-graph #f))
              (let ((x (list 1 2 3 4)))
                (pretty-print (list x x x))))
          ((1 2 3 4) (1 2 3 4) (1 2 3 4))

          > (parameterize ((print-graph #t))
              (let ((x (list 1 2 3 4)))
                (pretty-print (list x x x))))
          (#0=(1 2 3 4) #0# #0#)

          > (parameterize ((print-graph #f))
              (let ((x (list 1 2)))
                (let ((y (list x x x x)))
                  (set-car! (last-pair y) y)
                  (pretty-print (list y y)))))
          (#0=((1 2) (1 2) (1 2) #0#) #0#)

          > (parameterize ((print-graph #t))
              (let ((x (list 1 2)))
                (let ((y (list x x x x)))
                  (set-car! (last-pair y) y)
                  (pretty-print (list y y)))))
          (#0=(#1=(1 2) #1# #1# #0#) #0#)


File: vicare-scheme.info,  Node: iklib environment,  Next: iklib eval,  Prev: iklib shared,  Up: iklib

6.16 Environments
=================

The following bindings are exported by the library '(vicare)'.

 -- Function: environment? ENV
     Return '#t' if ENV is a lexical environment object.

 -- Function: non-interaction-lexical-environment? OBJ
     Return '#t' if ENV is a non-interaction lexical environment object
     object.

 -- Function: interaction-lexical-environment? OBJ
     Return '#t' if ENV is an interaction lexical environment object
     object.

 -- Function: interaction-environment
 -- Function: interaction-environment ENV
     When called with no arguments: return an environment object
     representing the environment active at the REPL; to be used as
     argument for 'eval'.

     When called with the argument ENV, which must be an environment
     object: set ENV as interaction environment.

 -- Function: new-interaction-environment
 -- Function: new-interaction-environment LIBNAME
     Build and return a new interaction environment object.  When no
     argument is given: the returned environment is initialised by
     importing the library '(vicare)'.  When LIBNAME is used it must be
     a library name specification: the returned environment is
     initialised with the specified library.

   Notice that it is possible to use interaction environments to have
persistent bindings:

     (begin
       (eval '(define c 3)
             (interaction-environment))
       (eval 'c
             (interaction-environment)))
     => 3

     (begin
       (eval '(begin
                (define a 1)
                (define b 2))
             (interaction-environment))
       (eval '(list a b)
             (interaction-environment)))
     => (1 2)

     (let ((env (new-interaction-environment)))
       (eval '(begin
                (define a 1)
                (define b 2))
             env)
       (eval '(list a b)
             env))
     => (1 2)

and it is also possible to import additional libraries:

     (eval '(import (vicare posix))
            (interaction-environment))

   At the top-level of an interaction environment, it is possible to
redefine syntactic bindings:

     (let ((env (new-interaction-environment '(rnrs base))))
       (eval '(define d 3) env)
       (eval '(define d 4) env)
       (eval 'd env))
     => 4

     (let ((env (new-interaction-environment '(rnrs base))))
       (eval '(begin
                (define x 1)
                (define y 2)
                (define z 3))
             env)
       (eval '(begin
                (define x 10)
                (define y 20)
                (define z 30))
             env)
       (eval '(list x y z)
             env))
     => (10 20 30)

     (let ((env (new-interaction-environment '(rnrs base))))
       (eval '(begin
                (define-syntax x (identifier-syntax 1))
                (define-syntax y (identifier-syntax 2))
                (define-syntax z (identifier-syntax 3)))
             env)
       (eval '(begin
                (define-syntax x (identifier-syntax 10))
                (define-syntax y (identifier-syntax 20))
                (define-syntax z (identifier-syntax 30)))
             env)
       (eval '(list x y z)
             env))
     => (10 20 30)

     (let ((env (new-interaction-environment '(vicare))))
       (eval '(begin
                (define-fluid-syntax x (identifier-syntax 1))
                (define-fluid-syntax y (identifier-syntax 2))
                (define-fluid-syntax z (identifier-syntax 3)))
             env)
       (eval '(begin
                (define-fluid-syntax x (identifier-syntax 10))
                (define-fluid-syntax y (identifier-syntax 20))
                (define-fluid-syntax z (identifier-syntax 30)))
             env)
       (eval '(list x y z)
             env))
     => (10 20 30)

     (let ((env (new-interaction-environment '(vicare))))
       (eval '(begin
                (begin-for-syntax
                  (define a 1)
                  (define a 2))
                (define-syntax doit
                  (lambda (stx) a)))
             env)
       (eval '(doit) env))
     => 2

   At the top-level of an interaction environment, it is possible to
shadow syntactic bindings imported from a library:

     (let ((env (new-interaction-environment '(vicare))))
       (eval '(define display 123) env)
       (eval 'display env))
     => 123

     (let ((env (new-interaction-environment '(vicare))))
       (eval '(begin
                (begin-for-syntax
                  (define display 123))
                (define-syntax doit
                  (lambda (stx) display)))
             env)
       (eval '(doit) env))
     => 123

 -- Function: environment-symbols ENV
     Return a list of symbols representing the names of the bindings
     from ENV, which must be an environment.  The name in position i in
     the returned list is associated to the label in position i in the
     list returned by 'environment-labels'.

     For example, the following program prints all the bindings in the
     library '(vicare language-extensions)':

          #!r6rs
          (import (vicare))
          (for-each pretty-print
            (environment-symbols
             (environment '(vicare language-extensions))))
          (flush-output-port (current-output-port))

 -- Function: environment-labels ENV
     Return a list of symbols representing the labels of the bindings
     from the given non-interaction environment.  The label in position
     i in the returned list is associated to the name in position i in
     the list returned by 'environment-symbols'.

 -- Function: environment-libraries ENV
     Return the list of 'library' records representing the libraries
     forming the non-interaction environment ENV.

 -- Function: environment-binding SYM ENV
     Search the symbol SYM in the non-interaction environment ENV; if
     SYM is the public name of a binding in ENV return 2 values: the
     label associated to the binding, the list of values representing
     the binding.  If SYM is not present in ENV return false and false.

          (environment-binding 'display (environment '(vicare)))
          => #{g870 |/1tY778AJ%G&f2UX|} (core-prim . display)


File: vicare-scheme.info,  Node: iklib eval,  Next: iklib cafe,  Prev: iklib environment,  Up: iklib

6.17 Extended code evaluation
=============================

The following bindings are exported by the library '(vicare)'.

 -- Function: eval SEXP ENVIRONMENT
 -- Function: eval SEXP ENVIRONMENT EXPANDER-OPTIONS COMPILER-OPTIONS
     Extension of 'eval' as defined by R6RS.  The arguments
     EXPANDER-OPTIONS and COMPILER-OPTIONS must be objects returned by
     'expander-options' and 'compiler-options'.

 -- Syntax: expander-options ?SYMBOL ...
     Expand to an object representing the expander options to be used as
     argument to 'eval'.  Supported ?SYMBOL options are:

     'strict-r6rs'
          Adhere more strictly to the behaviour defined by R6RS.  For
          example: report errors at run-time, rather than at
          expand-time.

     'typed-language'
          Turn on the tagged language extensions (*note The typed
          language: (vicare-typed)Top.).

     'default-language'
          This is the R6RS language without strict rules.

 -- Syntax: compiler-options ?SYMBOL ...
     Expand to an object representing the compiler options to be used as
     argument to 'eval'.  Supported ?SYMBOL options are:

     'strict-r6rs'
          Adhere more strictly to the behaviour defined by R6RS.  For
          example: report errors at run-time, rather than at
          compile-time.

     'default-language'
          This is the R6RS language without strict rules.


File: vicare-scheme.info,  Node: iklib cafe,  Next: iklib records,  Prev: iklib eval,  Up: iklib

6.18 Cafe
=========

The following bindings are exported by the library '(vicare)'.

 -- Function: new-cafe
 -- Function: new-cafe EVAL
     Start a new read-eval-print loop (REPL) inside the current cafe (if
     one exists).  It prompts the user for an expression, evaluates it,
     prints the result back, and repeats the process.  If 'new-cafe' is
     called with an argument, EVAL, then that argument must be a
     procedure that takes a single argument; the EVAL procedure will be
     used to evaluate the expressions.

     Every time a new cafe is started, the prompt is changed to reflect
     the depth of the current cafe (i.e.  how many eof objects is takes
     to exit the outermost cafe).

     When the readline interface is *not* used: input is performed from
     the port returned by 'console-input-port'; output is performed
     through the port returned by 'console-output-port)'.  When readline
     support is available and used: the REPL input is performed through
     a readline input port.

     If an error occurs during reading, evaluating, or printing an
     expression, then the error message is printed to the error-port and
     the operations of the cafe resume as normal.

     To exit from a cafe we can write the EOF object.

 -- Parameter: waiter-prompt-string
     The string used as prompt for cafe.

 -- Parameter: cafe-input-port
     A textual input port used by the cafe.


File: vicare-scheme.info,  Node: iklib records,  Next: iklib promises,  Prev: iklib cafe,  Up: iklib

6.19 Extensions to R6RS records
===============================

* Menu:

* iklib records defs::          Extensions to record type definitions.
* iklib records predicates::    Record predicates.
* iklib records fields::        Accessing and mutating fields.
* iklib records final::         Automatic finalisation of records.
* iklib records printer::       Custom record printers.
* iklib records equality::      Equality predicate for records.
* iklib records comparison::    Comparison procedure for records.
* iklib records hash::          Custom record hash functions.
* iklib records rcd::           Record-constructor descriptors.
* iklib records misc::          Miscellaneous functions.


File: vicare-scheme.info,  Node: iklib records defs,  Next: iklib records predicates,  Up: iklib records

6.19.1 Extensions to record type definitions
--------------------------------------------

 -- Syntax: define-record-type ?NAME-SPEC ?RECORD-CLAUSE ...
 -- Auxiliary Syntax: fields ?FIELD-SPEC ...
 -- Auxiliary Syntax: method
 -- Auxiliary Syntax: virtual-method
 -- Auxiliary Syntax: super-protocol ?EXPR
 -- Auxiliary Syntax: destructor-protocol ?EXPR
 -- Auxiliary Syntax: constructor-signature ?SIGNATURE
 -- Auxiliary Syntax: type-predicate ?EXPR
 -- Auxiliary Syntax: custom-printer ?EXPR
 -- Auxiliary Syntax: equality-predicate ?EXPR
 -- Auxiliary Syntax: comparison-procedure ?EXPR
 -- Auxiliary Syntax: hash-function ?EXPR
 -- Auxiliary Syntax: define-type-descriptors
 -- Auxiliary Syntax: strip-angular-parentheses
 -- Auxiliary Syntax: mixins ?MIXIN-NAME ...
 -- Auxiliary Syntax: implements ?INTERFACE-NAME ...
     Defined by R6RS.  Define a new R6RS record type; *note
     define-record-type: stdlib records syntactic layer.  This syntax
     supports some Vicare extensions.

     When the selected language is non-strict R6RS: multiple 'fields'
     clauses are accepted and the field specifications concatenated in
     the order in which they are given.  Example:

          (define-record-type alpha
            (fields a)
            (fields b)
            (fields c))

          (define O
            (make-alpha 1 2 3))

          (alpha-a O)     => 1
          (alpha-b O)     => 2
          (alpha-c O)     => 3

* Menu:

* iklib records defs super-proto:: The super-type protocol.
* iklib records defs destructor::  The destructor protocol.
* iklib records defs consig::      The constructor signature.
* iklib records defs predicate::   The custom predicate.
* iklib records defs printer::     The custom printer.
* iklib records defs equality::    The custom equality predicate.
* iklib records defs comparison::  The custom comparison procedure.
* iklib records defs hash::        The custom hash function.
* iklib records defs methods::     Record-type methods.
* iklib records defs descriptors:: Defining type descriptors.
* iklib records defs angular::     Stripping angular parentheses.
* iklib records defs mixins::      Mixins.
* iklib records defs implements::  Implemented interfaces.


File: vicare-scheme.info,  Node: iklib records defs super-proto,  Next: iklib records defs destructor,  Up: iklib records defs

6.19.1.1 The super-type protocol
................................

In a use of the syntax 'define-record-type', the definition clause:

     (super-protocol ?EXPR)

allows the specification of a constructor protocol to be used by
sub-types of a record-type.  Usually a sub-type make use of the protocol
function built from the constructor protocol specified by the clause
'protocol', but the clause 'super-protocol' overrides it.

   The 'super-protocol' works like 'protocol', its ?EXPR argument must
be an expression evaluating to a protocol function; the protocol
function accepts as single argument the constructor function of its
super-type and it must return the record instance.

   Here is an example in which the record-type 'alpha' is the super-type
of the record-type 'beta':

     (define-record-type alpha
       (fields a b)
       (super-protocol
         (lambda (make-record)
           (lambda (a b)
             (make-record (+ 10 a) (+ 20 b))))))

     (define-record-type beta
       (parent alpha)
       (fields c d))

     (let ((R (make-alpha 1 2)))
       (values (alpha-a R)
               (alpha-b R)))
     => 1 2

     (let ((R (make-beta 1 2 3 4)))
       (values (alpha-a R)
               (alpha-b R)
               (beta-c  R)
               (beta-d  R)))
     => 11 22 3 4

the default constructor function 'make-alpha' builds instances of
'alpha' with the default constructor; the constructor of 'beta' receives
as constructor function the result of calling the 'super-protocol' of
'alpha'.


File: vicare-scheme.info,  Node: iklib records defs destructor,  Next: iklib records defs consig,  Prev: iklib records defs super-proto,  Up: iklib records defs

6.19.1.2 The destructor protocol
................................

In a use of the syntax 'define-record-type', the definition clause:

     (destructor-protocol ?EXPR)

allows the specification of an expression ?EXPR which must evaluate to
the destructor protocol function; this function is used as explained
below to construct a destructor function to be called:

   * Implicitly by the garbage collector when a record of this type is
     collected.

   * Explicitly with the 'delete' syntax.

*note iklib records final:: for further details.

   Here is how the destructor function is built:

   * If this type has a 'destructor-protocol' clause and no parent:
     ?EXPR must evaluate to a closure object accepting no arguments and
     returning a closure object acting as destructor function for
     records of this type.  For example:

          (define-record-type <port>
            (fields port)
            (destructor-protocol
              (lambda ()
                (lambda (record)
                  (close-port (<port>-port record))))))

   * If this type has a 'destructor-protocol' clause and a parent
     specified with the 'parent' or 'parent-rtd' clauses: ?EXPR must
     evaluate to a closure object accepting as single argument the
     parent's destructor function and returning as single value a
     closure object acting as destructor function for records of this
     type.  For example:

          (define-record-type <port>
            (fields port)
            (destructor-protocol
              (lambda ()
                (lambda (record)
                  (close-port (<port>-port record))))))

          (define-record-type <file>
            (parent <port>)
            (fields filename)
            (destructor-protocol
              (lambda (destroy-<port>)
                (lambda (record)
                  (destroy-<port> record)))))

     notice that the destructor of '<file>' is meant to call the
     destructor of its supertype '<port>' at some point; however calling
     the supertype's destructor is optional.

   * If this type has no 'destructor-protocol' clause, it has a parent
     and the parent has a destructor function: the parent's destructor
     function becomes this type's destructor function.

   The destructor function must return zero values (for example using
'(values)' in tail position).


File: vicare-scheme.info,  Node: iklib records defs consig,  Next: iklib records defs predicate,  Prev: iklib records defs destructor,  Up: iklib records defs

6.19.1.3 The constructor signature
..................................

In a use of the syntax 'define-record-type', the definition clause:

     (constructor-signature ?SIGNATURE)

allows the specification of a type signature for the record-type
constructor.  This clause is meant to be used in the context of the
typed language.

   Some usage examples:

     (define-record-type <duo>
       (fields {one <fixnum>}
               {two <string>})
       (constructor-signature
         (lambda (<fixnum> <string>) => (<duo>))))

     (define-record-type <alpha>
       (fields {A <fixnum>}
               {B <string>})
       (protocol
         (lambda (make-record)
           (lambda (A)
             (make-record A (number->string A)))))
       (constructor-signature
         (lambda (<fixnum>) => (<alpha>))))

   This clause is needed because the 'protocol' clause does not allow
the specification of a full type signature for the record-type
constructor.

   When the clause 'constructor-signature' *is not* used, the syntax
'define-record-type' just defines a default type signature as follows:

     (lambda <list> => (?TYPE-NAME))


File: vicare-scheme.info,  Node: iklib records defs predicate,  Next: iklib records defs printer,  Prev: iklib records defs consig,  Up: iklib records defs

6.19.1.4 The custom predicate
.............................

In a use of the syntax 'define-record-type', the definition clause:

     (type-predicate ?EXPR)

allows the specification of an expression ?EXPR which, applied to the
default type predicate, must evaluate to a custom predicate function for
instances of the record-type.

   When the clause 'type-predicate' *is not* used, the syntax
'define-record-type' just defines the default record-type predicate:

     (define-record-type duo
       (fields one two))

     (duo? (make-duo 1 2))   => #t
     (duo? (make-warning))   => #f
     (duo? 123)              => #f

   When the clause 'type-predicate' *is* used, the syntax
'define-record-type' binds to the type predicate's syntactic identifier
the result of applying ?EXPR to the default type predicate.  In the
following example the custom predicate is just the default predicate
itself:

     (define-record-type duo
       (fields one two)
       (type-predicate
         (lambda (duo?)
           duo?)))

     (duo? (make-duo 1 2))   => #t
     (duo? (make-warning))   => #f
     (duo? 123)              => #f

in the following example the custom predicate accepts records wrapped
into lists and vectors:

     (define-record-type duo
       (fields one two)
       (type-predicate
         (lambda (duo?)
           (lambda (obj)
             (or (duo? obj)
                 (and (list? obj)
                      (duo?  (car obj))
                      (null? (cdr obj)))
                 (and (vector? obj)
                      (= 1 (vector-length obj))
                      (duo? (vector-ref obj 0))))))))

     (define O
       (make-duo 1 2))

     (duo? O)                => #t
     (duo? (list O))         => #t
     (duo? (vector O))       => #t
     (duo? (make-warning))   => #f
     (duo? 123)              => #f


File: vicare-scheme.info,  Node: iklib records defs printer,  Next: iklib records defs equality,  Prev: iklib records defs predicate,  Up: iklib records defs

6.19.1.5 The custom printer
...........................

In a use of the syntax 'define-record-type', the definition clause:

     (custom-printer ?EXPR)

allows the specification of an expression ?EXPR which must evaluate to a
custom printer function for instances of the record-type; *note iklib
records printer::, for details on record's custom printers.

   Usage example:

     (define-record-type duo
       (fields one two)
       (custom-printer
         (lambda (record port sub-printer)
           (display "#{record duo one=" port)
           (display (duo-one record) port)
           (display " two=" port)
           (display (duo-two record) port)
           (display "}" port))))

     (display (make-duo 1 2))
     -| #{record duo one=1 two=2}


File: vicare-scheme.info,  Node: iklib records defs equality,  Next: iklib records defs comparison,  Prev: iklib records defs printer,  Up: iklib records defs

6.19.1.6 The custom equality predicate
......................................

In a use of the syntax 'define-record-type', the definition clause:

     (equality-predicate ?EXPR)

allows the specification of an expression ?EXPR which must evaluate to a
custom equality-predicate protocol-function for instances of the
record-type; *note iklib records equality::, for the API that
manipulates record's equality predicates.

   If the record-type has a parent: the protocol function is applied to
the equality predicate of the parent (or '#f' if the parent has no
equality predicate) and the resulting value must be a function, which
becomes the equality predicate of the record-type.

   If the record-type has no parent: the protocol function is called as
a thunk and the resulting value must be a function, which becomes the
equality predicate of the record-type.

   The equality predicate is used when comparing records of the same
record-type with 'equal?', but *not* with 'eqv?'.

   In the following example, we define a custom equality predicate that
just compares all the fields; the only difference between the default
equality predicate 'record=?' and this implementation, is that this one
compares the fields using '=' rather than 'equal?':

     (define-record-type <duo>
       (fields one two)
       (equality-predicate
         (lambda ()
           (lambda (A B)
             (and (= (<duo>-one A)
                     (<duo>-one B))
                  (= (<duo>-two A)
                     (<duo>-two B)))))))

     (equal? (make-<duo> 1 2) (make-<duo> 1 2))      => #t
     (equal? (make-<duo> 1 2) (make-<duo> 1 99))     => #f

   In the following example, we define a custom equality predicate that
compares only some of the fields:

     (define-record-type <duo>
       (fields one two)
       (equality-predicate
         (lambda ()
           (lambda (A B)
             (= (<duo>-one A)
                (<duo>-one B))))))

     (equal? (make-<duo> 1 2) (make-<duo> 1 99))     => #t
     (equal? (make-<duo> 1 2) (make-<duo> 99 2))     => #f

this kind of equality predicate is especially useful, for example, when
some fields are used to memoise values.


File: vicare-scheme.info,  Node: iklib records defs comparison,  Next: iklib records defs hash,  Prev: iklib records defs equality,  Up: iklib records defs

6.19.1.7 The custom comparison procedure
........................................

In a use of the syntax 'define-record-type', the definition clause:

     (comparison-procedure ?EXPR)

allows the specification of an expression ?EXPR which must evaluate to a
custom comparison procedure protocol for instances of the record-type;
*note iklib records comparison::, for details on record's comparison
procedures.

   If the record-type has a parent: the protocol function is applied to
the comparison procedure of the parent (or '#f' if the parent has no
comparison procedure) and the resulting value must be a function, which
becomes the comparison procedure of the record-type.

   If the record-type has no parent: the protocol function is called as
a thunk and the resulting value must be a function, which becomes the
comparison procedure of the record-type.


File: vicare-scheme.info,  Node: iklib records defs hash,  Next: iklib records defs methods,  Prev: iklib records defs comparison,  Up: iklib records defs

6.19.1.8 The custom hash function
.................................

In a use of the syntax 'define-record-type', the definition clause:

     (hash-function ?EXPR)

allows the specification of an expression ?EXPR which must evaluate to a
custom hash function protocol for instances of the record-type; *note
iklib records hash::, for details on record's hash functions.

   If the record-type has a parent: the protocol function is applied to
the hash function of the parent (or '#f' if the parent has no hash
function) and the resulting value must be a function, which becomes the
hash function of the record-type.

   If the record-type has no parent: the protocol function is called as
a thunk and the resulting value must be a function, which becomes the
hash function of the record-type.

   As example using the typed language, the following record-type has no
parent:

     (define-record-type duo
       (fields one two)
       (hash-function
         (lambda ()
           (lambda ({O duo})
             (fx+ (fixnum-hash (.one O))
                  (fixnum-hash (.two O)))))))

     (hash (new duo 1 2))    => 3

the following record-type has a parent defining a hash function:

     (define-record-type alpha
       (fields a)
       (hash-function
         (lambda ()
           (lambda ({O alpha})
             (.a O)))))

     (define-record-type beta
       (fields b)
       (hash-function
         (lambda (alpha-hash)
           (lambda ({O beta})
             (fx+ (alpha-hash O) (.b O))))))

     (hash (new beta 1 2))) => 3

   The 'hash' syntax can always compute a hash value for records; when
the record-type has no custom has function, the core primitive
'record-hash' is used *note record-hash: iklib hashtables hashfun.


File: vicare-scheme.info,  Node: iklib records defs methods,  Next: iklib records defs descriptors,  Prev: iklib records defs hash,  Up: iklib records defs

6.19.1.9 Record-type methods
............................

The syntactic bindings 'method' and 'virtual-method' are used as clause
keywords in 'define-record-type' to define methods and virtual methods
for a record-type; they can be used any number of times in the same
'define-record-type' macro use.  These clauses are accepted by
'define-record-type' only when the typed language is used, *note Methods
and virtual methods: (vicare-typed)methods.


File: vicare-scheme.info,  Node: iklib records defs descriptors,  Next: iklib records defs angular,  Prev: iklib records defs methods,  Up: iklib records defs

6.19.1.10 Defining type descriptors
...................................

In a use of the syntax 'define-record-type', the definition clause:

     (define-type-descriptors)

defines two additional syntactic bindings: one to access the record-type
descriptor, the other to access the default constructor descriptor.

   The syntactic identifier bound to the record-type descriptor has name
equal to the record-type name with '-rtd' appended.  The syntactic
identifier bound to the constructor descriptor has name equal to the
record-type name with '-rcd' appended.  Example:

     (define-record-type alpha
       (define-type-descriptors))

     alpha-rtd       => #<record-type-descriptor>
     alpha-rcd       => #<record-constructor-descriptor>


File: vicare-scheme.info,  Node: iklib records defs angular,  Next: iklib records defs mixins,  Prev: iklib records defs descriptors,  Up: iklib records defs

6.19.1.11 Stripping angular parentheses
.......................................

In a use of the syntax 'define-record-type', the definition clause:

     (strip-angular-parentheses)

causes angular parentheses to be stripped from the record-type name when
automatically generating other syntactic identifiers related to the
record-type.  With a standard definition we get:

     (define-record-type <alpha>)
     (<alpha>? (make-<alpha>))       => #t

and using 'strip-angular-parentheses':

     (define-record-type <alpha>
       (strip-angular-parentheses))
     (alpha? (make-alpha))           => #t

   Similarly for field accessors and mutators, with a standard
definitions:

     (define-record-type <alpha>
       (strip-angular-parentheses)
       (fields (mutable a)
               (mutable b)
               (mutable c)))

     (define O
       (make-<alpha> 1 2 3))

     (<alpha>-a-set! O 10)
     (<alpha>-b-set! O 20)
     (<alpha>-c-set! O 30)
     (<alpha>-a O)   => 10
     (<alpha>-b O)   => 20
     (<alpha>-c O)   => 30

and using 'strip-angular-parentheses':

     (define-record-type <alpha>
       (strip-angular-parentheses)
       (fields (mutable a)
               (mutable b)
               (mutable c)))

     (define O
       (make-alpha 1 2 3))

     (alpha-a-set! O 10)
     (alpha-b-set! O 20)
     (alpha-c-set! O 30)
     (alpha-a O)     => 10
     (alpha-b O)     => 20
     (alpha-c O)     => 30


File: vicare-scheme.info,  Node: iklib records defs mixins,  Next: iklib records defs implements,  Prev: iklib records defs angular,  Up: iklib records defs

6.19.1.12 Mixins
................

In a use of the syntax 'define-record-type', the definition clause:

     (mixins ?MIXIN-NAME0 ?MIXIN-NAME ...)

causes the listed mixins to be included in the record-type definition,
*note Sharing object-type definition clauses: (vicare-typed)mixins.  The
clause 'implements' is accepted by 'define-record-type' when the
non-strict or typed languages are selected.


File: vicare-scheme.info,  Node: iklib records defs implements,  Prev: iklib records defs mixins,  Up: iklib records defs

6.19.1.13 Implemented interfaces
................................

In a use of the syntax 'define-record-type', the definition clause:

     (implements ?INTERFACE-NAME ...)

causes the listed interface names to be included in the list of
interfaces implemented by this record-type's, *note Interface types:
(vicare-typed)interfaces.  The clause 'implements' is accepted by
'define-record-type' when the typed language is selected.

   A record-type implements an interface when it implements a method for
each method prototype included in the interface-type definition; the
record-type can miss the implementation of interface-type methods having
a default implementation.  A record-type method matches an
interface-type method prototype when: record-type method's type
signature is a sub-type of the method prototype.

   The 'implements' clause causes a validation of the record-type's
implemented methods against the interface's method prototypes: if a
mismatch occurs, or a method is missing, an exception is raised at
expand-time.

   Here is a simple example in which the record-type '<blue>' implements
the interface '<IOne>'; the function 'fun' can be applied to any object
whose type implements the interface '<IOne>':

     (define-interface-type <IOne>
       (method-prototype ione-doit
         (lambda () => (<number>))))

     (define-record-type <blue>
       (implements <IOne>)
       (fields val)
       (method ({ione-doit <number>})
         (+ 10 (.val this))))

     (define (fun {O <IOne>})
       (.ione-doit O))

     (fun (new <blue> 1)))
     => 11

   Another example in which the record-type '<duo>' implements the
interface-type '<Stringer>' which has a method 'to-string' with default
implementation:

     (define-interface-type <Stringer>
       (method (to-string)
         (with-output-to-string
           (lambda ()
             (display this)))))

     (define-record-type <duo>
       (implements <Stringer>)
       (fields one two)
       (custom-printer
         (lambda ({this <duo>} port sub-printer)
           (display "#[duo "    port)
           (display (.one this) port)
           (display #\space     port)
           (display (.two this) port)
           (display #\]         port))))

     (define (fun {O <Stringer>})
       (.to-string O))

     (fun (new <duo> 1 2)))
     => "#[duo 1 2]"


File: vicare-scheme.info,  Node: iklib records predicates,  Next: iklib records fields,  Prev: iklib records defs,  Up: iklib records

6.19.2 Record predicates
------------------------

 -- Function: record-and-rtd? RECORD RTD
     Return '#t' if RECORD is a record instance of the type described by
     RTD or a record instance of a subtype of RTD; otherwise return
     '#f'.  This procedure does *not* care if RTD is an opaque record
     type.

 -- Syntax: record-type-and-record? ?TYPE-NAME ?RECORD
     Return '#t' if ?RECORD is an expression evaluating to a record
     instance of type ?TYPE-NAME or a record instance of a subtype of
     ?TYPE-NAME; otherwise return '#f'.  This syntax does *not* care if
     ?TYPE-NAME is an opaque record type.

     This syntax allows to test the type of a record instance through
     the type name identifier, without the need to export the predicate
     identifier out of libraries.  It performs the same operation of the
     more generic 'is-a?', but will raise an exception if ?TYPE-NAME is
     not the identifier of a record type.


File: vicare-scheme.info,  Node: iklib records fields,  Next: iklib records final,  Prev: iklib records predicates,  Up: iklib records

6.19.3 Accessing and mutating fields
------------------------------------

 -- Function: record-accessor RTD INDEX/NAME
 -- Function: record-accessor RTD INDEX/NAME ACCESSOR-WHO
     As defined by R6RS, this function accepts only two arguments and
     the second is a relative field index; *note record-accessor: stdlib
     records procedural layer.  Vicare extends this function.

     The argument INDEX/NAME can be either a relative field index, as
     specified by R6RS, or a symbol representing a field name.  In the
     second case RTD and its parents are searched for the first matching
     field specification, so fields of the sub-types take precedence.

     The optional third argument ACCESSOR-WHO must be a symbol
     representing the name of the returned accessor function; it is used
     for descriptive error reporting.

     Here is an example with the field name argument being a symbol:

          (import (vicare))
          (define-record-type alpha
            (fields a b c))
          (define alpha-rtd
            (record-type-descriptor alpha))
          (define R
            (make-alpha 1 2 3))
          ((record-accessor alpha-rtd 'a) R)      => 1
          ((record-accessor alpha-rtd 'b) R)      => 2
          ((record-accessor alpha-rtd 'c) R)      => 3

     Below is another example with record type inheritance; notice that
     both the record types have a field named 'C' and the sub-type takes
     precedence:

          (import (vicare))
          (define-record-type alpha
            (fields a b C))
          (define-record-type beta
            (parent alpha)
            (fields C d e))
          (define beta-rtd
            (record-type-descriptor beta))
          (define R
            (make-beta 1 2 3 4 5 6))
          ((record-accessor beta-rtd 'a) R)       => 1
          ((record-accessor beta-rtd 'b) R)       => 2
          ((record-accessor beta-rtd 'C) R)       => 4
          ((record-accessor beta-rtd 'd) R)       => 5
          ((record-accessor beta-rtd 'e) R)       => 6

 -- Function: record-mutator RTD INDEX/NAME
 -- Function: record-mutator RTD INDEX/NAME MUTATOR-WHO
     As defined by R6RS, this function accepts only two arguments and
     the second is a relative field index; *note record-mutator: stdlib
     records procedural layer.  Vicare extends this function.

     The argument INDEX/NAME can be either a relative field index, as
     specified by R6RS, or a symbol representing a field name.  In the
     second case RTD and its parents are searched for the first matching
     field specification, so fields of the sub-types take precedence.

     The optional third argument MUTATOR-WHO must be a symbol
     representing the name of the returned mutator function; it is used
     for descriptive error reporting.

     Here is an example with the field name argument being a symbol:

          (import (vicare))
          (define-record-type alpha
            (fields a b c))
          (define alpha-rtd
            (record-type-descriptor alpha))
          (define R
            (make-alpha 1 2 3))
          ((record-mutator alpha-rtd 'a) R 19)
          ((record-mutator alpha-rtd 'b) R 29)
          ((record-mutator alpha-rtd 'c) R 39)
          ((record-accessor alpha-rtd 'a) R)      => 1
          ((record-accessor alpha-rtd 'b) R)      => 2
          ((record-accessor alpha-rtd 'c) R)      => 3

     and another example with record type inheritance; notice that both
     the record types have a field named 'C' and the sub-type takes
     precedence:

          (import (vicare))
          (define-record-type alpha
            (fields a b C))
          (define-record-type beta
            (parent alpha)
            (fields C d e))
          (define beta-rtd
            (record-type-descriptor beta))
          (define R
            (make-beta 1 2 3 4 5 6))
          ((record-mutator beta-rtd 'a) R 19)
          ((record-mutator beta-rtd 'b) R 29)
          ((record-mutator beta-rtd 'C) R 49)
          ((record-mutator beta-rtd 'd) R 59)
          ((record-mutator beta-rtd 'e) R 69)
          ((record-accessor beta-rtd 'a) R)       => 19
          ((record-accessor beta-rtd 'b) R)       => 29
          ((record-accessor beta-rtd 'C) R)       => 49
          ((record-accessor beta-rtd 'd) R)       => 59
          ((record-accessor beta-rtd 'e) R)       => 69

 -- Function: unsafe-record-accessor RTD INDEX/NAME
 -- Function: unsafe-record-accessor RTD INDEX/NAME ACCESSOR-WHO
     Like 'record-accessor', but return an unsafe field accessor that
     will not validate its arguments.

 -- Function: unsafe-record-mutator RTD INDEX/NAME
 -- Function: unsafe-record-mutator RTD INDEX/NAME MUTATOR-WHO
     Like 'record-mutator', but return an unsafe field mutator that will
     not validate its arguments.

 -- Function: record-ref RECO INDEX
     Return the value of the field at absolute index INDEX for the
     record RECO.


File: vicare-scheme.info,  Node: iklib records final,  Next: iklib records printer,  Prev: iklib records fields,  Up: iklib records

6.19.4 Automatic finalisation of records
----------------------------------------

Vicare allows records to be finalised either explicitly or automatically
by the garbage collector, by applying a destruction function to them;
here is how automatic finalisation works:

     #!r6rs
     (import (vicare))

     (define-record-type <alpha>
       (fields a b c))

     (define (<alpha>-destructor rec)
       (fprintf (current-error-port) "finalising ~s\n" rec))

     (record-type-destructor-set! (record-type-descriptor <alpha>)
                                  <alpha>-destructor)

     (pretty-print (make-<alpha> 1 2 3) (current-error-port))
     -| (record <alpha> (a 1) (b 2) (c 3))

     (collect)
     -| finalising #[record <alpha> a=1 b=2 c=3]

   A destructor function is associated to a record-type by registering
it in the record-type descriptor.  After a destructor is set in the
descriptor: new instances of the record-type are registered, upon
creation, into an internal guardian, *note iklib guardians:: for
details; whenever such records are garbage collected: the guardian
applies the destructor to them.

   When the destructor is called by the garbage collector: exceptions
raised by it are catched with 'guard' and discarded; destructor
functions should take care of exceptions by themselves.

   It is possible for a destructor function to be applied multiple times
to the same record: once a destructor is set in the descriptor, it can
be explicitly applied to records and later applied again by the garbage
collector.  Destructor functions must be written in such a way that
multiple applications are not a problem.  For example, it is usually
possible, upon destruction, to reset some record fields to the void
object: when the destructor detects a field set to void, it knows that
the record has already been finalised.

 -- Function: record-type-destructor-set! RTD DESTRUCTOR
     Select the procedure DESTRUCTOR as destructor for R6RS records of
     type RTD; return unspecified values.  The destructor accepts a
     single argument being the record to finalise; the destructor can
     return unspecified values.

 -- Function: record-type-destructor RTD
     Return the function set in RTD as instance destructor; return '#f'
     if no destructor is set in RTD.

 -- Function: record-destructor RECORD
     Return the current destructor for the record RECORD: '#f' or a
     function.

 -- Parameter: record-guardian-logger
     Select a record destruction logging mode for debugging purposes.
     When a record is finalised by the garbage collector, using the
     destructor registered in the RTD:

        * If this parameter is set to '#f': no additional actions are
          performed.

        * If this parameter is set to '#t': the function
          'record-guardian-log' is used to log the operations to the
          textual output port returned by 'current-error-port'.

        * If this parameter is set to a procedure: such procedure is
          used to log the operations in a user selected way.

     See the documentation of 'record-guardian-log' for the calling
     protocol of the logger functions.

 -- Function: record-guardian-log RECORD EXCEPTION ACTION
     Built in logger function to be used to log record finalisation
     operations by the garbage collector.  RECORD is the record to be
     finalised; EXCEPTION is '#f' or an object raised by the record
     destructor; ACTION is one of the symbols: 'before-destruction',
     'after-destruction', 'exception'.

     When this function is used as value for the parameter
     'record-guardian-logger':

        * The function is called whenever a record is registered for
          destruction with ACTION set to the symbol 'registration' and
          EXCEPTION set to '#f'.

        * The function is called just before the record is finalised
          with ACTION set to the symbol 'before-destruction' and
          EXCEPTION set to '#f'.

        * The function is called right after the record has been
          finalised with ACTION set to the symbol 'after-destruction'
          and EXCEPTION set to '#f'.

        * If an exception is raised by the destructor: such exception is
          catched and this function is called with ACTION set to
          'exception' and EXCEPTION set to the raised object.

     The current implementation is the following:

          (define (record-guardian-log S E action)
            (case action
              ((registration)
               (fprintf (current-error-port)
                 "*** Vicare debug: record guardian: registered record:\n\
                  ***\t~s\n" S))
              ((before-destruction)
               (fprintf (current-error-port)
                 "*** Vicare debug: record guardian: before destruction:\n\
                  ***\t~s\n" S))
              ((after-destruction)
               (fprintf (current-error-port)
                 "*** Vicare debug: record guardian: after destruction:\n\
                  ***\t~s\n" S))
              ((exception)
               (fprintf (current-error-port)
                 "*** Vicare debug: record guardian: exception:\n\
                  ***\t~s\n\
                  ***\t~s\n" S E))
              (else
               (assertion-violation 'record-guardian-log
                 "invalid action in record destruction process" S action))))


File: vicare-scheme.info,  Node: iklib records printer,  Next: iklib records equality,  Prev: iklib records final,  Up: iklib records

6.19.5 Custom record printers
-----------------------------

Vicare's built-in Scheme objects writer can print records just fine,
handling cyclic references and shared objects:

     (import (vicare))
     (print-graph #t)
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define-record-type duo
       (fields one two))

     ;; simple record
     (display (make-duo 1 2))
     -| #[record duo one=1 two=2]

     ;; record with shared object
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (display B))
     -| #[record duo one=#0=#[record duo one=1 two=2] two=#0#]

     ;; record with cyclic reference to itself
     (let ((A (make-duo 1 (void))))
       (duo-two-set! A A)
       (display A))
     -| #0=#[record duo one=1 two=#0#]

   The Scheme objects writer is able to differentiate between 'display',
'write' and 'pretty-print' printing.  When printing records, the
built-in writer makes *no* difference between printing with 'display'
and 'write'; it does it differently when printing with 'pretty-print':

     (import (vicare))
     (print-graph #t)
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define-record-type duo
       (fields one two))

     ;; simple record
     (pretty-print (make-duo 1 2))
     -| (record duo (one 1) (two 2))

     ;; record with shared object
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (pretty-print B))
     -| (record duo (one #0=(record duo (one 1) (two 2))) (two #0#))

     ;; record with cyclic reference to itself
     (let ((A (make-duo 1 (void))))
       (duo-two-set! A A)
       (pretty-print A))
     -| #0=(record duo (one 1) (two #0#))

Custom printers
...............

Sometimes, we need to print a record with a customised representation.
For every record type it is possible to set a custom printer function;
it accepts 3 arguments: the record to be printed; a textual output port
into which to write a string representation of the record in the style
of 'display', 'write' or 'pretty-print'; a sub-printer function to be
optionally used to print component objects.  The sub-printer function
accepts as single argument the object to print; it allows us to
interface with the shared objects printer that handles shared and cyclic
references.

   As example, the following code defines a custom printer, making use
of the parameter 'printer-printing-style' to differentiate the style:

     (import (vicare))
     (print-graph #t)
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode none))

     (define-record-type duo
       (fields one two))

     (define (duo-printer stru port sub-printer)
       (case (printer-printing-style)
         ((display)
          (display "#{duo " port)
          (sub-printer (duo-one stru))
          (display " " port)
          (sub-printer (duo-two stru))
          (display "}" port))
         ((write)
          (display "(" port)
          ;;By using the sub-printer: we make this sexp shared too.
          (sub-printer '(record-constructor
                           (record-constructor-descriptor duo)))
          (display " " port)
          (sub-printer (duo-one stru))
          (display " " port)
          (sub-printer (duo-two stru))
          (display ")" port))
         ((pretty-print)
          (sub-printer `(record duo
                                #:one ,(duo-one stru)
                                #:two ,(duo-two stru))))))

     (record-type-printer-set! (record-type-descriptor duo)
                               duo-printer)

     (define O
       (make-duo 1 2))

     (display O)
     -| #{duo 1 2}"

     (write O)
     -| ((record-constructor (record-constructor-descriptor duo)) 1 2)

     (pretty-print O)
     -| (record duo #:one 1 #:two 2)

     ;; shared object, display
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (display B))
     -| #{duo #0=#{duo 1 2} #0#}

     ;; shared object, write
     (let* ((A (make-duo 1 2))
            (B (make-duo A A)))
       (write B))
     -| (#0=(record-constructor (record-constructor-descriptor duo)) \
       #1=(#0# 1 2) #1#)

 -- Function: record-type-printer-set! RTD PRINTER
     Select the procedure PRINTER as printer for records of type RTD; if
     PRINTER is '#f', instances of type RTD make use of the built-in
     Scheme objects printer.  Return the old printer function or '#f' if
     no printer function was set for this RTD.

 -- Function: record-type-printer RTD
     Return the function set as custom printer for records of type RTD;
     return '#f' if RTD has no custom printer.

 -- Function: record-printer RECORD
     Return '#f' or the function being the custom record printer for the
     record RECORD.


File: vicare-scheme.info,  Node: iklib records equality,  Next: iklib records comparison,  Prev: iklib records printer,  Up: iklib records

6.19.6 Equality predicate for records
-------------------------------------

A record-type's equality predicate is a function accepting as arguments
two instances of a record-type; the return value is: '#t' if the two
objects are the same and '#f' otherwise.

 -- Function: record-type-equality-predicate-set! RTD EQUAL-PRED
     Select the procedure EQUAL-PRED as equality predicate for records
     of type RTD; if EQUAL-PRED is '#f', instances of type RTD make use
     of the built-in Scheme objects equality predicate.

 -- Function: record-type-equality-predicate RTD
     Return the function set as custom equality predicate for records of
     type RTD; return '#f' if RTD has no custom equality predicate.

 -- Function: record-equality-predicate RECORD
     Return '#f' or the function being the custom equality predicate for
     the record RECORD.


File: vicare-scheme.info,  Node: iklib records comparison,  Next: iklib records hash,  Prev: iklib records equality,  Up: iklib records

6.19.7 Comparison procedure for records
---------------------------------------

A record-type's comparison procedure is a function accepting as
arguments two instances of a record-type; the return value is: '-1',
'0', or '+1' if the first object precedes the second, is equal to the
second, or follows the second, respectively.

 -- Function: record-type-comparison-procedure-set! RTD COMPAR-PROC
     Select the procedure COMPAR-PROC as comparison procedure for
     records of type RTD; if COMPAR-PROC is '#f', instances of type RTD
     make use of the built-in Scheme objects comparison procedure.

 -- Function: record-type-comparison-procedure RTD
     Return the function set as custom comparison procedure for records
     of type RTD; return '#f' if RTD has no custom comparison procedure.

 -- Function: record-comparison-procedure RECORD
     Return '#f' or the function being the custom comparison procedure
     for the record RECORD.


File: vicare-scheme.info,  Node: iklib records hash,  Next: iklib records rcd,  Prev: iklib records comparison,  Up: iklib records

6.19.8 Custom record hash functions
-----------------------------------

A record-type's hash function is a function accepting as single argument
an instance of the record-type; the return value is a non-negative
fixnum representing the hash value of the record.

   When a record-type does not have a custom hash function: we can
always use the core primitive 'record-hash', *note record-hash: iklib
hashtables hashfun.

 -- Function: record-type-hash-function-set! RTD HASH-FUNC
     Select the procedure HASH-FUNC as hash function for records of type
     RTD; if HASH-FUNC is '#f', instances of type RTD make use of the
     built-in Scheme objects hash function.

 -- Function: record-type-hash-function RTD
     Return the function set as custom hash function for records of type
     RTD; return '#f' if RTD has no custom hash function.

 -- Function: record-hash-function RECORD
     Return '#f' or the function being the custom record hash function
     for the record RECORD.


File: vicare-scheme.info,  Node: iklib records rcd,  Next: iklib records misc,  Prev: iklib records hash,  Up: iklib records

6.19.9 Record-constructor descriptors
-------------------------------------

 -- Function: record-constructor-descriptor? OBJ
     Return '#t' if OBJ is a record-constructor descriptor; otherwise
     return '#f'.

 -- Function: rcd-rtd RCD
     Given a record-constructor descriptor return its record-type
     descriptor.

 -- Function: rcd-parent-rcd RCD
     Given a record-constructor descriptor return its parent
     record-constructor descriptor or '#f' if RCD has no parent.


File: vicare-scheme.info,  Node: iklib records misc,  Prev: iklib records rcd,  Up: iklib records

6.19.10 Miscellaneous functions
-------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: record=? STRU ...
     All the arguments must be records.  Return '#t' if all the
     arguments have the same RTD and equal field values according to
     'equal?'.  When applied to a single argument: return '#t'.  Note
     that this function also works when applied to R6RS records.

 -- Function: record!=? STRU ...
     All the arguments must be records.  Return '#t' if the arguments
     are all different: no two arguments are equal according to
     'equal?'; otherwise return '#f'.  When applied to a single
     argument: return '#f'.

 -- Function: record-reset! RECORD
     Reset to void all the fields of a record, whatever its type.

 -- Function: record-object? OBJ
     Return '#t' if OBJ is an R6RS record, otherwise return '#f'.  This
     procedure does *not* care if the associated record-type is opaque.

 -- Function: record-type-all-field-names RTD
     Return a vector holding one Scheme symbol for each field of RTD,
     including fields of the parents; the order of the symbols is the
     same of the order of the fields in the RTD definition.

     If we need to couple the field names to the field values, we can do
     it as follows:

          (import (vicare))

          (define-record-type alpha
            (fields a b c))

          (define-record-type beta
            (parent alpha)
            (fields d e f))

          (define-record-type gamma
            (parent beta)
            (fields g h i))

          (define fields
            (record-type-all-field-names (record-type-descriptor gamma)))

          (define O
            (make-gamma 1 2 3 4 5 6 7 8 9))

          (let recur ((len (vector-length fields))
                      (i   0))
            (if (fx<? i len)
                (cons (list (vector-ref fields i)
                            (struct-ref O i))
                      (recur len (fxadd1 i)))
              '())))
          => ((a 1) (b 2) (c 3) (d 4) (e 5) (f 6) (g 7) (h 8) (i 9))

 -- Function: record-type-uids-list RTD
     Return a list of symbols representing the hierarchy of the
     record-type RTD.

          (define-record-type duo
            (nongenerative user:duo)
            (fields one two))

          (record-type-uids-list (record-type-descriptor duo))
          => (user:duo
              vicare:scheme-type:<record>
              vicare:scheme-type:<struct>
              vicare:scheme-type:<top>)


File: vicare-scheme.info,  Node: iklib promises,  Next: iklib booleans,  Prev: iklib records,  Up: iklib

6.20 Delay, force and promises
==============================

The following bindings are exported by the library '(vicare)'.

 -- Function: promise? OBJ
     Return '#t' if OBJ is a promise object returned by 'delay', else
     return '#f'.


File: vicare-scheme.info,  Node: iklib booleans,  Next: iklib chars,  Prev: iklib promises,  Up: iklib

6.21 Additional boolean functions
=================================

The following bindings are exported by the library '(vicare)'.

Predicates
..........

 -- Function: true? OBJ
 -- Function: false? OBJ
     Return '#t' if OBJ is, respectively, '#t' or '#f'; otherwise return
     '#f'.  It is not an error if OBJ is not a boolean value.

 -- Function: list-of-booleans? OBJ
     Return '#t' if OBJ is null or a proper list of booleans; otherwise
     return '#f'.

Comparison
..........

 -- Function: boolean!=? BOOL0 BOOL ...
     The arguments must be booleans.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.

 -- Procedure: boolean<? BOOL0 ...
 -- Procedure: boolean>? BOOL0 ...
 -- Procedure: boolean<=? BOOL0 ...
 -- Procedure: boolean>=? BOOL0 ...
     Compare the boolean arguments according to the artificial
     comparison definition:

          #t == #t
          #f == #f
          #f <  #t

     When applied to a single argument: return '#t'.

 -- Function: boolean-min BOOL0 BOOL ...
 -- Function: boolean-max BOOL0 BOOL ...
     Return the minimal or maximal boolean among the arguments.


File: vicare-scheme.info,  Node: iklib chars,  Next: iklib keywords,  Prev: iklib booleans,  Up: iklib

6.22 Additional character functions
===================================

* Menu:

* iklib chars predicates::      Additional character predicates.
* iklib chars comparison::      Additional character comparisons.
* iklib chars unicode::         Unicode characters handling.


File: vicare-scheme.info,  Node: iklib chars predicates,  Next: iklib chars comparison,  Up: iklib chars

6.22.1 Additional character predicates
--------------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: list-of-chars? OBJ
     Return '#t' if OBJ is null or a proper list of chars; otherwise
     return '#f'.

 -- Function: char-in-ascii-range? OBJ
     Evaluate to '#t' if ?OBJ is a character and its Unicode code point
     is in the range [0, 127].

 -- Function: fixnum-in-character-range? OBJ
     Return '#t' if OBJ is a fixnum and its value is in one of the
     ranges acceptable by Unicode code points; otherwise return '#f'.

 -- Function: unicode-printable-char? CH
     Return '#t' if CH is a character and it is printable; if CH is not
     printable: return '#f'; if CH is not a character: raise an
     exception.


File: vicare-scheme.info,  Node: iklib chars comparison,  Next: iklib chars unicode,  Prev: iklib chars predicates,  Up: iklib chars

6.22.2 Additional character comparisons
---------------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Procedure: char!=? CHAR0 CHAR ...
     The arguments must be characters.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.

 -- Procedure: char-ci!=? CHAR0 ...
     Like 'char!=?' but operate on the case-folded versions of the
     arguments.

 -- Function: chmin CH0 CH ...
 -- Function: chmax CH0 CH ...
     Return the minimum or maximum character among the arguments.


File: vicare-scheme.info,  Node: iklib chars unicode,  Prev: iklib chars comparison,  Up: iklib chars

6.22.3 Unicode characters handling
----------------------------------

The library '(vicare unsafe unicode)' exports macros to handle:
Unicode's code points; the encodings UTF-8, UTF-16, UTF-32; the Latin-1
encoding; the ASCII encoding.

* Menu:

* iklib chars unicode intro::   Introduction to Unicode.
* iklib chars unicode utf8::    Unicode's UTF-8 encoding.
* iklib chars unicode utf16::   Unicode's UTF-16 encoding.
* iklib chars unicode utf32::   Unicode's UTF-32 encoding.
* iklib chars unicode ascii::   ASCII encoding.
* iklib chars unicode latin1::  Latin-1 encoding.


File: vicare-scheme.info,  Node: iklib chars unicode intro,  Next: iklib chars unicode utf8,  Up: iklib chars unicode

6.22.3.1 Introduction to Unicode
................................

The mandatory starting points to learn about Unicode are the following
URLs:

               <http://www.unicode.org/faq/utf_bom.html>
        <http://en.wikipedia.org/wiki/Universal_Character_Set>
                <http://en.wikipedia.org/wiki/Unicode>
            <http://en.wikipedia.org/wiki/Byte_order_mark>
                 <http://en.wikipedia.org/wiki/UTF-8>
                 <http://en.wikipedia.org/wiki/UTF-16>
                 <http://en.wikipedia.org/wiki/UTF-32>

here we give only a brief overview of the main definitions, drawing text
from those pages.  Let's not forget the main source:

                       <http://www.unicode.org/>

   The "Universal Character Set" (UCS) is a standard set of characters
upon which many character encodings are based; it contains abstract
characters, each identified by an unambiguous name and an integer number
called its "code point".

   "Unicode" is a computing industry standard for the consistent
encoding, representation and handling of text expressed in most of the
world's writing systems.

   UCS and Unicode have an identical repertoire and numbers: the same
characters with the same numbers exist in both standards.  UCS is a
simple character map, Unicode adds rules for collation, normalization of
forms, and the bidirectional algorithm for scripts.

   The Unicode Consortium, the non-profit organization that coordinates
Unicode's development, has the goal of eventually replacing existing
character encoding schemes with Unicode and its standard "Unicode
Transformation Format" alias "UCS Transformation Format" (UTF) schemes.

   By convention a Unicode code point is referred to by writing 'U+'
followed by its hexadecimal number with at least 4 digits ('U+0044' is
fine, 'U+12' is not).

   In practice, Unicode code points are exact integers in the range '[0,
#x10FFFF]', but outside the range '[#xD800, #xDFFF]' which has special
meaning in UTF schemes.  A code point can be stored in 21 bits:

     (string-length (number->string #x10FFFF 2)) => 21

R6RS defines fixnums to have at least 24 bits, so a fixnum is wide
enough to hold a code point:

     (fixnum? #x10FFFF) => #t

and indeed Scheme characters are a disjoint type of value holding such
fixnums:

     (integer->char #x10FFFF) => #\x10FFFF


File: vicare-scheme.info,  Node: iklib chars unicode utf8,  Next: iklib chars unicode utf16,  Prev: iklib chars unicode intro,  Up: iklib chars unicode

6.22.3.2 Unicode's UTF-8 encoding
.................................

UTF-8 is a multioctet character encoding for Unicode which can represent
every character in the Unicode set: it can represent every code point in
the ranges '[0, #xD800)' and '(#xDFFF, #x10FFFF]'.

   A stream of UTF-8 encoded characters is meant to be stored octet by
octet in fixed order (and so without the need to specify the endianness
of words).

   The encoding scheme uses sequences of 1, 2, 3 or 4 octets to encode
each code point as shown in the following table; the first octet in a
sequence has a unique bit pattern in the most significant bits and so it
allows the determination of the sequence length; every octet contains a
number of payload bits which must be concatenated (bitwise inclusive OR)
to reconstruct the integer representation of a code point:

     # of octets | 1st octet  | 2nd octet  | 3rd octet  | 4th octet  |
     ------------+------------+------------+------------+------------|
          1        #b0xxxxxxx
          2        #b110xxxxx   #b10xxxxxx
          3        #b1110xxxx   #b10xxxxxx   #b10xxxxxx
          4        #b11110xxx   #b10xxxxxx   #b10xxxxxx   #b10xxxxxx

      # of octets | # of payload bits  |       hex range
     -------------+--------------------+----------------------
          1                          7     [#x0000,   #x007F]
          2                 5 + 6 = 11     [#x0080,   #x07FF]
          3             4 + 6 + 6 = 16     [#x0800,   #xFFFF]
          4         3 + 6 + 6 + 6 = 21   [#x010000, #x10FFFF]

   Note that octets '#xFE' ('#b11111110') and '#xFF' ('#b11111111')
cannot appear in a valid stream of UTF-8 encoded characters.

   The sequence of 3 octets is the one that could encode (but must not)
the forbidden range '[#xD800, #xDFFF]' which are not Unicode code
points.  So the table of valid encoded code points is:

      # of octets |  # of payload bits |    code point range
     -------------+--------------------+----------------------
          1       |                  7 |   [#x0000,   #x007F]
          2       |        5 + 6 = 11  |   [#x0080,   #x07FF]
          3       |     4 + 6 + 6 = 16 |   [#x0800,   #xD7FF]
          3       |     4 + 6 + 6 = 16 |   [#xE000,   #xFFFF]
          4       | 3 + 6 + 6 + 6 = 21 | [#x010000, #x10FFFF]

   The first 128 characters of the Unicode character set correspond
one-to-one with ASCII and are encoded using a single octet with the same
binary value as the corresponding ASCII character, making valid ASCII
text valid UTF-8 encoded Unicode text as well.  Such encoded octets have
the Most Significant Bit (MSB) set to zero.

   Although the standard does not define it, many programs start a UTF-8
stream with a Byte Order Mark (BOM) composed of the 3 octets: '#xEF',
'#xBB', '#xBF'.

   The following syntactic bindings are exported by the library '(vicare
unsafe unicode)'.  All the macros are unsafe: no validation on the type
of the arguments is performed.  For all the macros: the argument OCTET
is meant to be a fixnum representing 1 octet (in the range '[0, 255]');
the argument CODE-POINT is meant to be a fixnum representing a Unicode
code point (in the range '[0, #x10FFFF]', but outside the range
'[#xD800, #xDFFF]').

 -- Syntax: utf-8-invalid-octet? OCTET
     Evaluate to '#t' if OCTET has a value that must never appear in a
     valid UTF-8 stream; otherwise evaluate to '#f'.

Decoding 1-octet UTF-8 to code points
.....................................

 -- Syntax: utf-8-single-octet? OCTET
     Evaluate to '#t' if OCTET is valid as 1-octet UTF-8 encoding of a
     Unicode character; otherwise evaluate to '#f'.

 -- Syntax: utf-8-decode-single-octet OCTET
     Decode the code point of a Unicode character from a 1-octet UTF-8
     encoding.

 -- Syntax: utf-8-valid-code-point-from-1-octet? CODE-POINT
     Evaluate to true if CODE-POINT is a valid fixnum representation for
     a code point decoded from a 2-octets UTF-8 sequence.

Decoding 2-octets UTF-8 to code points
......................................

 -- Syntax: utf-8-first-of-two-octets? OCTET0
     Evaluate to '#t' if OCTET0 is valid as first of 2-octets UTF-8
     encoding of a Unicode character.

 -- Syntax: utf-8-second-of-two-octets? OCTET1
     Evaluate to true if OCTET1 is valid as second of 2-octets UTF-8
     encoding of a Unicode character.

 -- Syntax: utf-8-decode-two-octets OCTET0 OCTET1
     Decode the code point of a Unicode character from a 2-octets UTF-8
     encoding.

 -- Syntax: utf-8-valid-code-point-from-2-octets? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a valid fixnum representation for
     a code point decoded from a 2-octets UTF-8 sequence.

Decoding 3-octets UTF-8 to code points
......................................

 -- Syntax: utf-8-first-of-three-octets? OCTET0
     Evaluate to '#t' if OCTET0 is valid as first of 3-octets UTF-8
     encoding of a Unicode character; otherwise evaluate to '#f'.

 -- Syntax: utf-8-second-and-third-of-three-octets? OCTET1 OCTET2
     Evaluate to '#t' if OCTET1 and OCTET2 are valid as second and third
     of 3-octets UTF-8 encoding of a Unicode character.

 -- Syntax: utf-8-decode-three-octets OCTET0 OCTET1 OCTET2
     Decode the code point of a Unicode character from a 3-octets UTF-8
     encoding.

 -- Syntax: utf-8-valid-code-point-from-3-octets? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a valid integer representation
     for a code point decoded from a 3-octets UTF-8 sequence.

Decoding 4-octets UTF-8 to code points
......................................

 -- Syntax: utf-8-first-of-four-octets? OCTET0
     Evaluate to '#t' if OCTET0 is valid as first of 4-octets UTF-8
     encoding of a Unicode character.

 -- Syntax: utf-8-second-third-and-fourth-of-four-octets? OCTET1 OCTET2
          OCTET3
     Evaluate to true if OCTET1, OCTET2 and OCTET3 are valid as second,
     third and fourth of 4-octets UTF-8 encoding of a Unicode character.

 -- Syntax: utf-8-decode-four-octets OCTET0 OCTET1 OCTET2 OCTET3
     Decode the code point of a Unicode character from a 4-octets UTF-8
     encoding.

 -- Syntax: utf-8-valid-code-point-from-4-octets? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a valid integer representation
     for a code point decoded from a 4-octets UTF-8 sequence.

Encoding code points to 1-octet UTF-8
.....................................

 -- Syntax: utf-8-single-octet-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a Unicode code point
     representable as 1-octet UTF-8 encoding; otherwise evaluate to
     '#f'.

 -- Syntax: utf-8-encode-single-octet CODE-POINT
     Encode the code point of a Unicode character to a 1-octet UTF-8
     encoding.

Encoding code points to 2-octet UTF-8
.....................................

 -- Syntax: utf-8-two-octets-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a Unicode code point
     representable as 2-octet UTF-8 encoding; otherwise evaluate to
     '#f'.

 -- Syntax: utf-8-encode-first-of-two-octets CODE-POINT
     Encode the code point of a Unicode character to the first octet in
     a 2-octet UTF-8 encoding.

 -- Syntax: utf-8-encode-second-of-two-octets CODE-POINT
     Encode the code point of a Unicode character to the second octet in
     a 2-octet UTF-8 encoding.

Encoding code points to 3-octet UTF-8
.....................................

 -- Syntax: utf-8-three-octets-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a Unicode code point
     representable as 3-octet UTF-8 encoding; otherwise evaluate to
     '#f'.

 -- Syntax: utf-8-encode-first-of-three-octets CODE-POINT
     Encode the code point of a Unicode character to the first octet in
     a 3-octet UTF-8 encoding.

 -- Syntax: utf-8-encode-second-of-three-octets CODE-POINT
     Encode the code point of a Unicode character to the second octet in
     a 3-octet UTF-8 encoding.

 -- Syntax: utf-8-encode-third-of-three-octets CODE-POINT
     Encode the code point of a Unicode character to the fourth octet in
     a 3-octet UTF-8 encoding.

Encoding code points to 4-octet UTF-8
.....................................

 -- Syntax: utf-8-four-octets-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a Unicode code point
     representable as 4-octet UTF-8 encoding; otherwise evaluate to
     '#f'.

 -- Syntax: utf-8-encode-first-of-four-octets CODE-POINT
     Encode the code point of a Unicode character to the first octet in
     a 4-octet UTF-8 encoding.

 -- Syntax: utf-8-encode-second-of-four-octets CODE-POINT
     Encode the code point of a Unicode character to the second octet in
     a 4-octet UTF-8 encoding.

 -- Syntax: utf-8-encode-third-of-four-octets CODE-POINT
     Encode the code point of a Unicode character to the third octet in
     a 4-octet UTF-8 encoding.

 -- Syntax: utf-8-encode-fourth-of-four-octets CODE-POINT
     Encode the code point of a Unicode character to the fourth octet in
     a 4-octet UTF-8 encoding.


File: vicare-scheme.info,  Node: iklib chars unicode utf16,  Next: iklib chars unicode utf32,  Prev: iklib chars unicode utf8,  Up: iklib chars unicode

6.22.3.3 Unicode's UTF-16 encoding
..................................

UTF-16 is a multioctet character encoding for Unicode which can
represent every character in the Unicode set: it can represent every
code point in the ranges '[0, #xD800)' and '(#xDFFF, #x10FFFF]'.

   Code points in the range '[0, #x10000)' are encoded with a single
UTF-16 16-bit word; code points in the range '[#x10000, #x10FFFF]' are
encoded in a surrogate pair of 2 16-bit words.

   Given a 16-bit word in a UTF-16 stream, represented in Scheme as a
fixnum in the range '[#x0000, #xFFFF]', we can classify it on the
following axis:

     0000        D7FF D800    DBFF DC00      DFFF E000       FFFF
      |-------------||-----------||-------------||------------|
       single word    first in     second in      single word
       character      pair         pair           character

or the following logic:

     word in [#x0000, #xD7FF] => single word character
     word in [#xD800, #xDBFF] => first in surrogate pair
     word in [#xDC00, #xDFFF] => second in surrogate pair
     word in [#xE000, #xFFFF] => single word character

   A UTF-16 stream may start with a Byte Order Mark (BOM).  A UTF-16 BOM
is either:

   * A sequence of bytes '#xFE', '#xFF' specifying "big endianness" and
     UTF-16BE encoding.

   * A sequence of bytes '#xFF', '#xFE' specifying "little endianness"
     and UTF-16LE encoding.

   The following syntactic bindings are exported by the library '(vicare
unsafe unicode)'.  The following macros assume the WORD arguments are
fixnums representing 16-bit words: they must be in the range '[0,
#xFFFF]'; while the CODE-POINT arguments are fixnums representing
Unicode code points (they are in the range '[0, #x10FFFF]', but outside
the range '[#xD800, #xDFFF]').

1-word decoding
...............

 -- Syntax: utf-16-single-word? WORD0
     Evaluate to '#t' if WORD0 is valid as single 16-bit word UTF-16
     encoding of a Unicode character; otherwise evaluate to '#f'.

 -- Syntax: utf-16-decode-single-word WORD0
     Decode the integer representation of a Unicode character from a
     16-bit single word UTF-16 encoding.

2-words decoding
................

 -- Syntax: utf-16-first-of-two-words? WORD0
     Evaluate to '#t' if WORD0 is valid as first 16-bit word in a
     surrogate pair UTF-16 encoding of a Unicode character; otherwise
     evaluate to '#f'.

 -- Syntax: utf-16-second-of-two-words? WORD1
     Evaluate to '#t' if WORD1 is valid as second 16-bit word in a
     surrogate pair UTF-16 encoding of a Unicode character; otherwise
     evaluate to '#f'.

 -- Syntax: utf-16-decode-surrogate-pair WORD0 WORD2
     Decode the integer representation of a Unicode character from a
     surrogate pair UTF-16 encoding.

1-word encoding
...............

 -- Syntax: utf-16-single-word-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is the fixnum representation of a
     Unicode code point representable as single 16-bit word UTF-16
     encoding; otherwise evaluate to '#f'.

 -- Syntax: utf-16-encode-single-word CODE-POINT
     Encode CODE-POINT as single 16-bit word UTF-16 encoding.

2-word encoding
...............

 -- Syntax: utf-16-two-words-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is the fixnum representation of a
     Unicode code point representable as surrogate pair of two 16-bit
     words UTF-16 encoding; otherwise evaluate to '#f'.

 -- Syntax: utf-16-encode-first-of-two-words CODE-POINT
     Encode CODE-POINT as first 16-bit word in a surrogate pair UTF-16
     encoding.

 -- Syntax: utf-16-encode-second-of-two-words CODE-POINT
     Encode CODE-POINT as second 16-bit word in a surrogate pair UTF-16
     encoding.


File: vicare-scheme.info,  Node: iklib chars unicode utf32,  Next: iklib chars unicode ascii,  Prev: iklib chars unicode utf16,  Up: iklib chars unicode

6.22.3.4 Unicode's UTF-32 encoding
..................................

UTF-32, also called UCS 4, is a multioctet character encoding for
Unicode which can represent every character in the Unicode set: it can
represent every code point in the ranges '[0, #xD800)' and '(#xDFFF,
#x10FFFF]'.  It uses exactly 32 bits per Unicode code point.

   This makes UTF-32 a fixed-length encoding, in contrast to all other
Unicode Transformation Formats which are variable-length encodings.  The
UTF-32 form of a character is a direct representation of its code point.

   The following syntactic bindings are exported by the library '(vicare
unsafe unicode)'.  The following macros assume the WORD arguments are
fixnums representing 32-bit words: they must be in the range '[0,
#xFFFFFFFF]'; while the CODE-POINT arguments are fixnums representing
Unicode code points (they are in the range '[0, #x10FFFF]', but outside
the range '[#xD800, #xDFFF]').

Encoding
........

 -- Syntax: utf-32-code-point? CODE-POINT
     Evaluate to '#t' if CODE-POINT is a Unicode code point
     representable in UTF-32 encoding.

 -- Syntax: utf-32-encode CODE-POINT
     Encode a Unicode code point as UTF-32 encoding.

Decoding
........

 -- Syntax: utf-32-word? WORD
     Evaluate to '#t' if WORD is valid as 32-bit word UTF-32 encoding of
     a Unicode character; otherwise evaluate to '#f'.

 -- Syntax: utf-32-decode WORD
     Encode a valid UTF-32 encoding word into the corresponding Unicode
     code point.


File: vicare-scheme.info,  Node: iklib chars unicode ascii,  Next: iklib chars unicode latin1,  Prev: iklib chars unicode utf32,  Up: iklib chars unicode

6.22.3.5 ASCII encoding
.......................

The following syntactic bindings are exported by the library '(vicare
unsafe unicode)'.  In the following macros the argument OCTET is meant
to be a fixnum representing an ASCII code point; while the argument
CODE-POINT is meant to be a fixnum representing a Unicode code point.

Encoding
........

 -- Syntax: ascii-code-point? CODE-POINT
     Assume CODE-POINT is a fixnum representation of a Unicode code
     point.  Return '#t' if CODE-POINT is in the range accepted by the
     ASCII encoding.

 -- Syntax: ascii-encode CODE-POINT
     Assume CODE-POINT is a fixnum representation of a Unicode code
     point in the range representable with ASCII encoding.  Return its
     encoding in ASCII format.

Decoding
........

 -- Syntax: ascii-octet? OCTET
     Assume OCTET is a fixnum representing an octet.  Return '#t' if
     OCTET is in the range accepted by the ASCII encoding; otherwise
     return '#f'.

 -- Syntax: ascii-decode OCTET
     Assume OCTET is the fixnum representation of an ASCII encoded
     character.  Return its associated Unicode code point.


File: vicare-scheme.info,  Node: iklib chars unicode latin1,  Prev: iklib chars unicode ascii,  Up: iklib chars unicode

6.22.3.6 ISO/IEC 8859-1 also known as Latin-1 encoding
......................................................

Latin-1 encoding uses 1 octet per character.  For an itroduction to
Latin-1 see:

             <http://en.wikipedia.org/wiki/ISO/IEC_8859-1>

and for Unicode's "C1 Controls and Latin-1 Supplement" see:

<https://en.wikipedia.org/wiki/Latin-1_Supplement_%28Unicode_block%29>
             <http://www.unicode.org/charts/PDF/U0080.pdf>

   Strictly speaking, the Latin-1 encoding only defines code points in
the ranges '[#x20, #x7E]' and '[#xA0, #xFF]'; notice that the control
characters are excluded.

   In the range '[#x20, #x7E]' the Latin-1 code points are equal to the
corresponding ASCII code points.

   In both the ranges '[#x20, #x7E]' and '[#xA0, #xFF]': Latin-1's code
points are equal to Unicode's code points, when we take into account
Unicode's "C1 Controls and Latin-1 Supplement".

   Notice that:

   * Unicode's "C0 Controls and Basic Latin" specifies the code points
     in the range '[#x00, #x7F]' so that they are equal to ASCII's
     control characters in the same range.  This Unicode block includes
     the range of control characters '[#x00, #x1F]' which is left
     undefined by Latin-1.

   * Unicode's "C1 Controls and Latin-1 Supplement" specifies code
     points in the range '[#x80, #x9F]'.  This range is left undefined
     by Latin-1.

   This library defines an *extended* Latin-1 encoding spanning the
whole '[#x00, #xFF]' range with the following blocks:

     [#x00, #x1F]    C0 Controls
     [#x20, #x7E]    Latin-1 code points
     #x7F            C0 Controls
     [#x80, #x9F]    C1 Controls
     [#xA0, #xFF]    Latin-1 code points

   The following syntactic bindings are exported by the library '(vicare
unsafe unicode)'.  In the following macros the argument
LATIN-1-CODE-POINT is meant to be a fixnum representing a Latin-1 code
point; while the argument UNICODE-CODE-POINT is meant to be a fixnum
representing a Unicode code point.

Encoding Unicode code points as Latin-1 code points
...................................................

 -- Syntax: unicode-code-point-representable-as-latin-1-code-point?
          UNICODE-CODE-POINT
     Evaluate to '#t' if UNICODE-CODE-POINT is a Unicode code point in a
     range that can be encoded in Latin-1; otherwise evaluate to '#f'.

 -- Syntax: latin-1-encode UNICODE-CODE-POINT
     Encode a Unicode code point into a Latin-1 code point.

Decoding Unicode code points from Latin-1 code points
.....................................................

 -- Syntax: latin-1-code-point? OCTET
     Assum OCTET is the fixnum representation of an octet.  Evaluate to
     '#t' if OCTET a valid Latin-1 code point; otherwise evaluate to
     '#f'.

 -- Syntax: latin-1-decode LATIN-1-CODE-POINT
     Decode a Latin-1 code point to a Unicode code point.

Classification
..............

 -- Syntax: latin-1-C0-control? LATIN-1-CODE-POINT
     Evaluate to '#t' if the argument is a Latin-1 code point in the
     range of C0 Control characters.

 -- Syntax: latin-1-C1-control? LATIN-1-CODE-POINT
     Evaluate to '#t' if the argument is a Latin-1 code point in the
     range of C1 Control characters.

 -- Syntax: latin-1-control? LATIN-1-CODE-POINT
     Evaluate to '#t' if the argument is a Latin-1 code point in the
     range of C0 Control or C1 Control characters.

 -- Syntax: latin-1-graphic? LATIN-1-CODE-POINT
     Evaluate to '#t' if the argument is a Latin-1 code point in the
     range of graphics (non-control) characters.


File: vicare-scheme.info,  Node: iklib keywords,  Next: iklib ipairs,  Prev: iklib chars,  Up: iklib

6.23 Keyword objects
====================

Keyword objects are struct instances embedding a Scheme symbol; keyword
objects are a disjoint type; keyword objects are *not* interned.

   Keyword objects can be compared with 'eq?', 'eqv?' and 'equal?'; a
keyword object is 'eq?' only to itself.  Keyword objects can also be
compared with the 'keyword=?' predicate which is faster than 'eqv?' and
'equal?' and slower than 'eq?' for symbols.

   The reader supports a special syntax to read keyword objects, *note
Miscellaneous additional syntaxes: iklib reader misc.

   The following bindings are exported by the library '(vicare)'.

 -- Function: symbol->keyword SYMBOL
 -- Function: keyword->symbol KEYWORD
     Convert between a symbol and a keyword.

 -- Function: keyword->string KEYWORD
     Return the string representation of a keyword.

          (keyword->string #:ciao)        => "#:ciao"

 -- Function: string->keyword STRING
     Build a new keyword object having STRING as name.

          (string->keyword "ciao")        => #:ciao

 -- Function: keyword? OBJ
     Return '#t' if OBJ is a keyword object, else return '#f'.

 -- Function: keyword=? KEYWORD1 KEYWORD2
     The arguments KEYWORD1 and KEYWORD2 must be keyword objects,
     otherwise an exception is raised.  Return '#t' if the arguments are
     equal.  A keyword object is equal to itself; two distinct keyword
     objects are equal if they have the same symbol.

 -- Function: keyword-hash KEYWORD
     Return an exact integer suitable to be used as hash value for
     KEYWORD used as key for hash tables.


File: vicare-scheme.info,  Node: iklib ipairs,  Next: iklib lists,  Prev: iklib keywords,  Up: iklib

6.24 Immutable pairs
====================

Vicare defines immutable pairs as a built-in disjoint type; only basic
functions are implemented by '(vicare)', the bulk of the utilities is
implemented by SRFI-116, in the library '(srfi :116)', *note SRFI-116
immutable lists: (vicare-libs)srfi ilists.

   Notice that 'syntax-rules' and 'syntax-case' patterns do *not*
recognise immutable pairs.

 -- Function: ipair OBJ1 OBJ2
     Build and return a new immutable pair object, using OBJ1 as car and
     OBJ2 as cdr.

 -- Function: ikpair? OBJ
     Return '#t' if OBJ is an immutable pair; otherwise return '#f'.

 -- Function: icar IPAIR
 -- Function: icdr IPAIR
     Return the car and cdr of the immutable pair IPAIR.  It is an error
     if IPAIR is not an immutable pair.


File: vicare-scheme.info,  Node: iklib lists,  Next: iklib bytevectors,  Prev: iklib ipairs,  Up: iklib

6.25 Additional list functions
==============================

* Menu:

* iklib lists weak::            Weak pairs.
* iklib lists queue::           Queues of items.
* iklib lists misc::            Miscellaneous functions.


File: vicare-scheme.info,  Node: iklib lists weak,  Next: iklib lists queue,  Up: iklib lists

6.25.1 Weak pairs
-----------------

Weak references do not cause the referenced value to be considered used
by the garbage collector.  The following bindings are exported by the
library '(vicare)'.

 -- Function: weak-cons A D
     Like 'cons' build and return a new pair, but holding weak
     references to A; notice that the reference to D is not weak.  This
     function allows to build a non-weak list spine holding weak
     references to values.

 -- Function: weak-pair? OBJ
     Return true if OBJ is a weak pair.

 -- Function: bwp-object
     Return the BWP object.  BWP stands for "broken weak pointer".

 -- Function: bwp-object? OBJ
     Return true if OBJ is a weak reference to a value which has been
     already garbage collected.  Example:

          vicare> (define x (weak-cons (cons 1 2) #f))
          vicare> x
          ((1 . 2) . #f)
          vicare> (bwp-object? (car x))
          #f
          vicare> (collect)
          vicare> x
           (#!bwp . #f)
          vicare> (bwp-object? (car x))
          #t


File: vicare-scheme.info,  Node: iklib lists queue,  Next: iklib lists misc,  Prev: iklib lists weak,  Up: iklib lists

6.25.2 Queues of items
----------------------

Queues are object containers that allow constructing a first-in
first-out sequence.  The following bindings are exported by the library
'(vicare)'.

 -- Function: make-queue-procs
 -- Function: make-queue-procs INIT-VALUES
     Build a queue of items and return 3 values:

       1. A predicate thunk returning '#t' if the queue is empty.

       2. A function which, applied to a single argument, enqueues it as
          last item.

       3. A thunk extracting and returning the first item from the
          queue.  If the queue is empty an error is raised.

     The optional INIT-VALUES must be null or the list of initial
     values.

     Usage examples:

          #!r6rs
          (import (vicare))

          (let-values (((empty? enqueue! dequeue!)
                        (make-queue-procs)))
            (empty?))
          => #t

          (let-values (((empty? enqueue! dequeue!)
                        (make-queue-procs)))
            (enqueue! 1)
            (empty?))
          => #f

          (let-values (((empty? enqueue! dequeue!)
                        (make-queue-procs)))
            (enqueue! 1)
            (empty?)      => #f
            (dequeue!)    => 1
            (empty?))
          => #t

          (let-values (((empty? enqueue! dequeue!)
                        (make-queue-procs)))
            (enqueue! 1)
            (enqueue! 2)
            (enqueue! 3)
            (dequeue!)    => 1
            (dequeue!)    => 2
            (dequeue!)    => 3
            (empty?))
          => #t


File: vicare-scheme.info,  Node: iklib lists misc,  Prev: iklib lists queue,  Up: iklib lists

6.25.3 Miscellaneous functions
------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: circular-list? OBJ
     Return '#t' if OBJ is a circular list; otherwise return '#f'.

 -- Function: list-of-single-item? OBJ
     Return '#t' if OBJ is a list with a single item, otherwise return
     '#f'.  In other words: return '#t' if OBJ is a pair whose cdr is
     null.

 -- Function: make-list LEN
 -- Function: make-list LEN FILL
     Build and return a new list of LEN elements.  FILL is used to
     initialise the the list pairs; when not given: it defaults to the
     return value of '(void)'.

 -- Function: last-pair PAIR
     Return the last pair in the non-empty, finite list PAIR.

          (last-pair '(a b c))    => (c)

 -- Function: for-each-in-order PROC LIST0 LIST ...
     Like 'for-each' from '(rnrs base (6))' but guarantees that PROC is
     applied starting from the head of the lists.

 -- Function: andmap PROC ELL
 -- Function: andmap PROC ELL1 ELL2
     Iterate in order the list arguments, applying PROC to the items in
     the lists, left to right.  If PROC returns '#f': 'andmap' stops the
     iteration and returns false.  If PROC returns a non-false value for
     all the items from the list arguments: 'andmap' returns the result
     of the last PROC application.  If all the list arguments are null:
     the return value is '#t'.

     When applied to two arguments: PROC must be a function accepting a
     single argument and returning a single value; ELL must be proper
     list (possibly empty).

     When applied to three arguments: PROC must be a function accepting
     a two arguments and returning a single value; ELL1 and ELL2 must be
     proper lists of equal length (possibly empty).

          (andmap (lambda (x) x) '())
          => #t

          (andmap (lambda (x) x) '(1 2 3))
          => 3

          (andmap (lambda (x) x) '(1 #f 3))
          => #f

          (andmap (lambda (x y) (and x y))
                  '() '())
          => #t

          (andmap (lambda (x y) (and x y))
                  '(1 2) '(3 4))
          => 4

          (andmap (lambda (x y) (and x y))
                  '(1 2) '(3 #f))
          => #f

 -- Function: ormap PROC ELL
     Iterate in order the list arguments, applying PROC to the items in
     the list argument ELL.  If PROC returns non-false: 'ormap' stops
     the iteration and returns the non-false value.  If PROC returns
     '#f' for all the items in ELL: 'ormap' returns '#f'.  If ELL is
     null: the return value is '#f'.

     PROC must be a function accepting a single argument and returning a
     single value; ELL must be proper list (possibly empty).

          (ormap (lambda (x) x) '())
          => #f

          (ormap (lambda (x) x) '(#f #f #f))
          => #f

          (ormap (lambda (x) x) '(#f 123 #f))
          => 123

          (ormap (lambda (x) (or x 123)) '())
          => #f

          (ormap (lambda (x) (or x 123)) '(1 2 3))
          => 1

          (ormap (lambda (x) (or x 123)) '(#f #f 1))
          => 123


File: vicare-scheme.info,  Node: iklib bytevectors,  Next: iklib strings,  Prev: iklib lists,  Up: iklib

6.26 Additional bytevector functions
====================================

The description of bytevectors uses the term _byte_ for an exact integer
object in the inclusive interval (-128, ..., 127) and the term _octet_
for an exact integer object in the inclusive interval (0, ..., 255).  A
byte corresponds to its two's complement representation as an octet.

* Menu:

* iklib bytevectors predicates::  Predicate functions.
* iklib bytevectors comparison::  Comparing bytevectors.
* iklib bytevectors conversion::  Converting bytevectors.
* iklib bytevectors valpred::     Validation predicates for bytevector.
* iklib bytevectors sub::         Building subbytevectors.
* iklib bytevectors generic::     Generic bytevector operations.


File: vicare-scheme.info,  Node: iklib bytevectors predicates,  Next: iklib bytevectors comparison,  Up: iklib bytevectors

6.26.1 Predicate functions
--------------------------

 -- Function: list-of-bytevectors? OBJ
     Return '#t' if OBJ is null or a proper list of bytevectors;
     otherwise return '#f'.

 -- Function: empty-bytevector? OBJ
     Return '#t' if OBJ is a bytevector and it is empty; otherwise
     return '#f'.

 -- Function: nebytevector? OBJ
     Return '#t' if OBJ is a bytevector and it is non-empty; otherwise
     return '#f'.


File: vicare-scheme.info,  Node: iklib bytevectors comparison,  Next: iklib bytevectors conversion,  Prev: iklib bytevectors predicates,  Up: iklib bytevectors

6.26.2 Comparing bytevectors
----------------------------

 -- Function: bytevector!=? BV0 BV ...
     The arguments must be bytevectors.  Return '#t' if the arguments
     are all different: no two arguments are equal; otherwise return
     '#f'.  When applied to a single argument: return '#f'.

 -- Procedure: bytevector-u8<? BV0 ...
 -- Procedure: bytevector-u8>? BV0 ...
 -- Procedure: bytevector-u8<=? BV0 ...
 -- Procedure: bytevector-u8>=? BV0 ...
     These procedures are the extensions to bytevectors of the
     corresponding orderings on unsigned fixnums; the bytevectors are
     compared octet by octet.

 -- Procedure: bytevector-s8<? BV0 ...
 -- Procedure: bytevector-s8>? BV0 ...
 -- Procedure: bytevector-s8<=? BV0 ...
 -- Procedure: bytevector-s8>=? BV0 ...
     These procedures are the extensions to bytevectors of the
     corresponding orderings on signed fixnums; the bytevectors are
     compared byte by byte.

 -- Function: bytevector-u8-max BV0 BV ...
 -- Function: bytevector-u8-min BV0 BV ...
     Return the maximal or minimal bytevector argument according to
     'bytevector-u8<?'.

 -- Function: bytevector-s8-max BV0 BV ...
 -- Function: bytevector-s8-min BV0 BV ...
     Return the maximal or minimal bytevector argument according to
     'bytevector-s8<?'.


File: vicare-scheme.info,  Node: iklib bytevectors conversion,  Next: iklib bytevectors valpred,  Prev: iklib bytevectors comparison,  Up: iklib bytevectors

6.26.3 Converting bytevectors
-----------------------------

These conversion functions work like 'bytevector->u8-list' and
'u8-list->bytevector'.  The following bindings are exported by the
library '(vicare)'.

 -- Function: utf8->string-length BV
 -- Function: utf8->string-length BV HANDLING-MODE
     Given a bytevector representing a string in UTF-8 encoding: compute
     and return the length of the Scheme string required to hold the
     characters.

     The optional HANDLING-MODE must be an error handling mode as
     validated by the standard syntax 'error-handling-mode'; when not
     given: it defaults to 'raise'.  This argument has the same meaning
     it has for 'utf8->string' (*note utf8->string: stdlib bytevector
     strings.).

 -- Function: utf16->string-length BYTEVECTOR ENDIANNESS
 -- Function: utf16->string-length BYTEVECTOR ENDIANNESS
          ENDIANNESS-MANDATORY
 -- Function: utf16->string-length BYTEVECTOR ENDIANNESS
          ENDIANNESS-MANDATORY HANDLING-MODE
     Given a bytevector representing a string in UTF-16 encoding:
     compute the length of the Scheme string required to hold the
     characters and return it as non-negative fixnum.

     All the arguments have the same meaning they have for
     'utf16->string' (*note utf16->string: stdlib bytevector strings.).

 -- Function: utf32->string-length BYTEVECTOR ENDIANNESS
 -- Function: utf32->string-length BYTEVECTOR ENDIANNESS
          ENDIANNESS-MANDATORY
 -- Function: utf32->string-length BYTEVECTOR ENDIANNESS
          ENDIANNESS-MANDATORY HANDLING-MODE
     Given a bytevector representing a string in UTF-32 encoding:
     compute the length of the Scheme string required to hold the
     characters and return it as non-negative fixnum.

     All the arguments have the same meaning they have for
     'utf32->string' (*note utf32->string: stdlib bytevector strings.).

 -- Function: bytevector->s8-list BYTEVECTOR
 -- Function: s8-list->bytevector LIST
     Convert between a list of signed bytes and a bytevector.

 -- Function: s16l-list->bytevector LIST
 -- Function: s16b-list->bytevector LIST
 -- Function: s16n-list->bytevector LIST
 -- Function: u16l-list->bytevector LIST
 -- Function: u16b-list->bytevector LIST
 -- Function: u16n-list->bytevector LIST
 -- Function: bytevector->s16l-list BYTEVECTOR
 -- Function: bytevector->s16b-list BYTEVECTOR
 -- Function: bytevector->s16n-list BYTEVECTOR
 -- Function: bytevector->u16l-list BYTEVECTOR
 -- Function: bytevector->u16b-list BYTEVECTOR
 -- Function: bytevector->u16n-list BYTEVECTOR
     Convert between a list of signed or unsigned 16-bit words and a
     bytevector in which the words are stored in little, big or native
     endianness.

 -- Function: s32l-list->bytevector LIST
 -- Function: s32b-list->bytevector LIST
 -- Function: s32n-list->bytevector LIST
 -- Function: u32l-list->bytevector LIST
 -- Function: u32b-list->bytevector LIST
 -- Function: u32n-list->bytevector LIST
 -- Function: bytevector->s32l-list BYTEVECTOR
 -- Function: bytevector->s32b-list BYTEVECTOR
 -- Function: bytevector->s32n-list BYTEVECTOR
 -- Function: bytevector->u32l-list BYTEVECTOR
 -- Function: bytevector->u32b-list BYTEVECTOR
 -- Function: bytevector->u32n-list BYTEVECTOR
     Convert between a list of signed or unsigned 32-bit words and a
     bytevector in which the words are stored in little, big or native
     endianness.

 -- Function: s64l-list->bytevector LIST
 -- Function: s64b-list->bytevector LIST
 -- Function: s64n-list->bytevector LIST
 -- Function: u64l-list->bytevector LIST
 -- Function: u64b-list->bytevector LIST
 -- Function: u64n-list->bytevector LIST
 -- Function: bytevector->s64l-list BYTEVECTOR
 -- Function: bytevector->s64b-list BYTEVECTOR
 -- Function: bytevector->s64n-list BYTEVECTOR
 -- Function: bytevector->u64l-list BYTEVECTOR
 -- Function: bytevector->u64b-list BYTEVECTOR
 -- Function: bytevector->u64n-list BYTEVECTOR
     Convert between a list of signed or unsigned 64-bit words and a
     bytevector in which the words are stored in little, big or native
     endianness.

 -- Function: f4l-list->bytevector LIST
 -- Function: f4b-list->bytevector LIST
 -- Function: f4n-list->bytevector LIST
 -- Function: bytevector->f4l-list BYTEVECTOR
 -- Function: bytevector->f4b-list BYTEVECTOR
 -- Function: bytevector->f4n-list BYTEVECTOR
     Convert between a list of single-precision flonums and a bytevector
     in which the flonums are stored in little, big or native
     endianness.

 -- Function: f8l-list->bytevector LIST
 -- Function: f8b-list->bytevector LIST
 -- Function: f8n-list->bytevector LIST
 -- Function: bytevector->f8l-list BYTEVECTOR
 -- Function: bytevector->f8b-list BYTEVECTOR
 -- Function: bytevector->f8n-list BYTEVECTOR
     Convert between a list of double-precision flonums and a bytevector
     in which the flonums are stored in little, big or native
     endianness.

 -- Function: c4l-list->bytevector LIST
 -- Function: c4b-list->bytevector LIST
 -- Function: c4n-list->bytevector LIST
 -- Function: bytevector->c4l-list BYTEVECTOR
 -- Function: bytevector->c4b-list BYTEVECTOR
 -- Function: bytevector->c4n-list BYTEVECTOR
     Convert between a list of single-precision cflonums and a
     bytevector in which the cflonums are stored in little, big or
     native endianness, real part first.

 -- Function: c8l-list->bytevector LIST
 -- Function: c8b-list->bytevector LIST
 -- Function: c8n-list->bytevector LIST
 -- Function: bytevector->c8l-list BYTEVECTOR
 -- Function: bytevector->c8b-list BYTEVECTOR
 -- Function: bytevector->c8n-list BYTEVECTOR
     Convert between a list of double-precision cflonums and a
     bytevector in which the flonums are stored in little, big or native
     endianness, real part first.

 -- Function: octets-encoded-bytevector? BYTEVECTOR
     Return '#t' if BYTEVECTOR is a bytevector object.

 -- Function: ascii-encoded-bytevector? BYTEVECTOR
     Return '#t' if BYTEVECTOR can be interpreted as an ASCII encoded
     string, otherwise return '#f'.  An octet CHI is considered an ASCII
     code point if:

          (<= #x00 chi #x7F)      => #t

 -- Function: latin1-encoded-bytevector? BYTEVECTOR
     Return '#t' if BYTEVECTOR can be interpreted as a Latin1 encoded
     string, otherwise return '#f'.  *note iklib chars unicode latin1::
     for the definition of Latin-1 encoding used by Vicare.

 -- Function: hex->bytevector BYTEVECTOR
 -- Function: bytevector->hex BYTEVECTOR
     Convert to and from a Scheme bytevector containing octets and a
     Scheme bytevector containing the ASCII hexadecimal representation
     of the octets.

     The input hex bytevector contains the uppercase or lowercase
     hexadecimal representation of the octets.  The output hex
     bytevector contains the uppercase hexadecimal representation of
     octets.

     If an error occurs in the conversion: the return value is '#f'.

 -- Function: base64->bytevector BYTEVECTOR
 -- Function: bytevector->base64 BYTEVECTOR
     Convert to and from a Scheme bytevector containing octets and a
     Scheme bytevector containing the ASCII Base64 representation of the
     octets.

     If an error occurs in the conversion: the return value is '#f'.

 -- Function: uri-encode BYTEVECTOR
 -- Function: uri-decode BYTEVECTOR
 -- Function: percent-encode BYTEVECTOR
 -- Function: percent-decode BYTEVECTOR
     Encode or decode a bytevector according to RFC 3986 URI percent
     encoding; return a bytevector.  All the octets are encoded except
     the ones having the following ASCII representation:

          ABCDEFGHIJKLMNOPQRSTUVWXYZ
          abcdefghijklmnopqrstuvwxyz
          0123456789
          -._~

 -- Function: normalise-uri-encoding BYTEVECTOR
 -- Function: normalise-percent-encoding BYTEVECTOR
     Given a bytevector encoded according to to RFC 3986 URI percent
     encoding: return an encoded and normalised bytevector, octets that
     are encoded but should not are decoded.

 -- Function: uri-encoded-bytevector? BV
 -- Function: percent-encoded-bytevector? BV
     Return '#t' if the argument is a correctly percent-encoded
     bytevector according to RFC 3986.  This means every octet
     represents either one of the following characters in ASCII
     encoding:

          ABCDEFGHIJKLMNOPQRSTUVWXYZ
          abcdefghijklmnopqrstuvwxyz
          0123456789
          -._~

     or it is part of a percent-encoded sequence defined by the
     following grammar:

          pct-encoded   = "%" HEXDIG HEXDIG
          HEXDIG        = [0-9a-fA-F]


File: vicare-scheme.info,  Node: iklib bytevectors valpred,  Next: iklib bytevectors sub,  Prev: iklib bytevectors conversion,  Up: iklib bytevectors

6.26.4 Validation predicates for bytevector
-------------------------------------------

 -- Function: bytevector-length? OBJ
     Return '#t' if OBJ is valid as bytevector length: it is a
     non-negative fixnum; otherwise return '#f'.

 -- Function: bytevector-index? OBJ
     Return '#t' if OBJ is a Scheme object valid as bytevector index: it
     is a non-negative fixnum; otherwise return '#f'.  Before being
     used, OBJ needs further validation against a specific bytevector
     and word size.

 -- Function: bytevector-word-size? OBJ
     Return '#t' if OBJ is valid as word size to be accessed in a
     bytevector; otherwise return '#f'.  OBJ must be further validated
     for a specific bytevector word start offset.

 -- Function: bytevector-word-count? OBJ
     Return '#t' if OBJ is valid as word count for bytevector items,
     either a byte count, 16-bit words count, 32-bit words count, ...;
     otherwise return '#f'.  OBJ must be further validated for the
     specific bytevector and word size with which it is to be used.

 -- Function: bytevector-index-for-word? BV IDX WORD-SIZE-IN-BYTES
     Return '#t' if: BV is a bytevector, IDX is a non-negative fixnum,
     WORD-SIZE-IN-BYTES is a non-negative fixnum, IDX is a valid index
     in BV to reference a word whose size is WORD-SIZE-IN-BYTES;
     otherwise return '#f'.  This validation is for getter and setter
     indexes.

 -- Function: bytevector-index-for-word8? BV IDX
 -- Function: bytevector-index-for-word16? BV IDX
 -- Function: bytevector-index-for-word32? BV IDX
 -- Function: bytevector-index-for-word64? BV IDX
 -- Function: bytevector-index-for-single-flonum? BV IDX
 -- Function: bytevector-index-for-double-flonum? BV IDX
     Specialised variants of 'bytevector-index-for-word?' for a specific
     word size in bits.

 -- Function: bytevector-start-index-and-count-for-word? BV IDX
          WORD-SIZE-IN-BYTES COUNT
     Return '#t' if: BV is a bytevector, IDX is a non-negative fixnum,
     COUNT is a non-negative fixnum, WORD-SIZE-IN-BYTES is a
     non-negative fixnum, IDX is a valid index in BV to reference COUNT
     words whose size is WORD-SIZE-IN-BYTES; otherwise return '#f'.
     Notice that if COUNT is zero: it is fine for IDX to be equal to the
     length of BV.  This validation is for getter and setter indexes.

 -- Function: bytevector-start-index-and-count-for-word8? BV IDX
 -- Function: bytevector-start-index-and-count-for-word16? BV IDX
 -- Function: bytevector-start-index-and-count-for-word32? BV IDX
 -- Function: bytevector-start-index-and-count-for-word64? BV IDX
     Specialised variants of
     'bytevector-start-index-and-count-for-word?' for a specific word
     size in bits.


File: vicare-scheme.info,  Node: iklib bytevectors sub,  Next: iklib bytevectors generic,  Prev: iklib bytevectors valpred,  Up: iklib bytevectors

6.26.5 Building subbytevectors
------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: subbytevector-u8 BV START
 -- Function: subbytevector-u8 BV START END
     Build and return a new bytevector holding the bytes in BV from
     index START (inclusive) to index END (exclusive).  The start and
     end indexes must be such that:

          0 <= START <= END <= (bytevector-length BV)

 -- Function: subbytevector-u8/count BV START COUNT
     Build and return a new bytevector holding COUNT bytes in BV from
     index START (inclusive).  The start index and the byte count must
     be such that:

          0 <= START <= START + COUNT <= (bytevector-length BV)

 -- Function: subbytevector-s8 BV START
 -- Function: subbytevector-s8 BV START END
     Build and return a new bytevector holding the bytes in BV from
     index START (inclusive) to index END (exclusive).  The start and
     end indexes must be such that:

          0 <= START <= END <= (bytevector-length BV)

 -- Function: subbytevector-s8/count BV START COUNT
     Build and return a new bytevector holding COUNT bytes in BV from
     index START (inclusive).  The start index and the byte count must
     be such that:

          0 <= START <= START + COUNT <= (bytevector-length BV)


File: vicare-scheme.info,  Node: iklib bytevectors generic,  Prev: iklib bytevectors sub,  Up: iklib bytevectors

6.26.6 Generic bytevector operations
------------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: bytevector-empty? BYTEVECTOR
     Return '#t' if the bytevector BYTEVECTOR has zero length, otherwise
     return '#f'.

 -- Function: bytevector-append BYTEVECTOR ...
     Concatenate the bytevector arguments and return the result.  If no
     arguments are given: return the empty bytevector.

 -- Function: bytevector-concatenate BVS
     Concatenate the list of bytevectors BVS and return the resulting
     bytevector.  It is an error if the sum of the bytevector lengths is
     not in the range of the maximum bytevector length.

 -- Function: bytevector-reverse-and-concatenate BVS
     Reverse the list of bytevectors BVS, concatenate them and return
     the resulting bytevector.  It is an error if the sum of the
     bytevector lengths is not in the range of the maximum bytevector
     length.


File: vicare-scheme.info,  Node: iklib strings,  Next: iklib vectors,  Prev: iklib bytevectors,  Up: iklib

6.27 Additional string functions
================================

* Menu:

* iklib strings predicates::    Predicates about strings.
* iklib strings constructors::  Constructing new strings.
* iklib strings comparison::    Comparison functions.
* iklib strings conversion::    Converting between strings and
                                other objects.
* iklib strings misc::          Miscellaneous string operations.


File: vicare-scheme.info,  Node: iklib strings predicates,  Next: iklib strings constructors,  Up: iklib strings

6.27.1 Predicates about strings
-------------------------------

 -- Function: list-of-strings? OBJ
     Return '#t' if OBJ is null or a proper list of strings; otherwise
     return '#f'.

 -- Function: list-of-nestrings? OBJ
     Return '#t' if OBJ is null or a proper list of non-empty strings;
     otherwise return '#f'.

 -- Function: string-empty? STR
     Return '#t' if the string STR is empty, otherwise return '#f'.  It
     is an error if STR is not a string.

 -- Function: empty-string? OBJ
     Return '#t' if the OBJ is a string and it is empty, otherwise
     return '#f'.

 -- Function: nestring? OBJ
     Return '#t' if the OBJ is a string and it is non-empty, otherwise
     return '#f'.


File: vicare-scheme.info,  Node: iklib strings constructors,  Next: iklib strings comparison,  Prev: iklib strings predicates,  Up: iklib strings

6.27.2 Constructing new strings
-------------------------------

 -- Function: string-copy! SRC.STR SRC.START DST.STR DST.START COUNT
     Copy COUNT characters from SRC.STR starting at SRC.START
     (inclusive) to DST.STR starting at DST.START.  Return unspecified
     values.

 -- Function: string-concatenate STRS
     Concatenate the list of strings STRS and return the resulting
     string.  It is an error if the sum of the string lengths is not in
     the range of the maximum string length.

 -- Function: string-reverse-and-concatenate STRS
     Reverse the list of strings STRS, concatenate them and return the
     resulting string.  It is an error if the sum of the string lengths
     is not in the range of the maximum string length.


File: vicare-scheme.info,  Node: iklib strings comparison,  Next: iklib strings conversion,  Prev: iklib strings constructors,  Up: iklib strings

6.27.3 Comparison functions
---------------------------

 -- Function: string!=? STR0 STR ...
     The arguments must be strings.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.

 -- Function: string-max STR0 STR ...
 -- Function: string-min STR0 STR ...
     Return the maximal or minimal string argument according to
     'string<?'.


File: vicare-scheme.info,  Node: iklib strings conversion,  Next: iklib strings misc,  Prev: iklib strings comparison,  Up: iklib strings

6.27.4 Converting between strings and other objects
---------------------------------------------------

 -- Function: string->utf8-length STR
     Given a string compute and return the length of the bytevector that
     would contain its UTF-8 representation.  If the bytevector length
     would exceed the maximum length of a bytevector: return '#f'.

 -- Function: string->utf16-length STR
     Given a string compute and return the length of the bytevector that
     would contain its UTF-16 representation.  If the bytevector length
     would exceed the maximum length of a bytevector: return '#f'.

 -- Function: string->utf32-length STR
     Given a string compute and return the length of the bytevector that
     would contain its UTF-32 representation.  If the bytevector length
     would exceed the maximum length of a bytevector: return '#f'.

 -- Function: string->octets STRING
 -- Function: octets->string BYTEVECTOR
     Convert to and from a Scheme string and a Scheme bytevector holding
     the raw octets encoding of the characters.  Octets are converted to
     characters with 'integer->char'; characters are converted to octets
     with 'char->integer'.  Raise an exception if the conversion is not
     possible.

 -- Function: string->ascii STRING
 -- Function: ascii->string BYTEVEVCTOR
     Convert to and from a Scheme string and a Scheme bytevector holding
     the ASCII encoding of the characters.

 -- Function: octets-encoded-string? STRING
     Return '#t' if STRING can be interpreted as an octets encoded
     string, otherwise return '#f'.  A character is considered an
     octets-encoded if its integer representation CHI satisfies:

          (<= 0 CHI 255)      => #t

 -- Function: ascii-encoded-string? STRING
     Return '#t' if STRING can be interpreted as an ASCII encoded
     string, otherwise return '#f'.  A character is considered an ASCII
     code point if its integer representation CHI satisfies:

          (<= #x00 CHI #x7F)      => #t

 -- Function: string->latin1 STRING
 -- Function: latin1->string BYTEVEVCTOR
     Convert to and from a Scheme string and a Scheme bytevector holding
     the Latin-1 encoding of the characters.

 -- Function: latin1-encoded-string? STRING
     Return '#t' if STRING can be interpreted as a Latin1 encoded
     string, otherwise return '#f'.  *note iklib chars unicode latin1::
     for the definition of Latin-1 encoding used by Vicare.

 -- Function: string->utf16le STRING
 -- Function: string->utf16be STRING
 -- Function: string->utf16n STRING
     Convert from a Scheme string to a Scheme bytevector holding the
     UTF-16 encoding of the characters under little, big or native
     endianness respectively.

 -- Function: utf16le->string BYTEVECTOR
 -- Function: utf16be->string BYTEVECTOR
 -- Function: utf16n->string BYTEVECTOR
 -- Function: utf16le->string BYTEVECTOR ERROR-HANDLING-MODE
 -- Function: utf16be->string BYTEVECTOR ERROR-HANDLING-MODE
 -- Function: utf16n->string BYTEVECTOR ERROR-HANDLING-MODE
     Convert to a Scheme string from a Scheme bytevector holding the
     UTF-16 encoding of characters under little, big or native
     endianness respectively.

     The optional argument ERROR-HANDLING-MODE has the same values and
     meaning it has for 'utf16->string'.

 -- Function: string-hex->bytevector STRING
 -- Function: bytevector->string-hex BYTEVECTOR
     Convert to and from a Scheme string and a Scheme bytevector.

     The input string contains the uppercase or lowercase hexadecimal
     representation of the octets.  The output string contains the
     uppercase hexadecimal representation of octets.

     If an error occurs in the conversion: the return value is '#f'.

 -- Function: string-base64->bytevector STRING
 -- Function: bytevector->string-base64 BYTEVECTOR
     Convert to and from a Scheme string and a Scheme bytevector.  The
     input string contains the ASCII Base64 representation of the
     octets.  The output string contains the ASCII Base64 representation
     of octets.  If an error occurs in the conversion: an exception is
     raised.

 -- Function: string->uri-encoding STR
 -- Function: string->percent-encoding STR
     Convert the string STR to its UTF-8 representation, then encode
     such representation according to RFC 3986, URI percent encoding.

 -- Function: uri-encoding->string BYTEVECTOR
 -- Function: percent-encoding->string BYTEVECTOR
     Interpret the bytevector as encoded according to RFC 3986, URI
     percent encoding, decode it and interpret the result as the UTF-8
     representation of a string; return the string.

 -- Function: uri-encoded-string? STRING
 -- Function: percent-encoded-string? STRING
     Return '#t' if the argument is correctly percent-encoded string
     according to RFC 3986.  This means every character in the string is
     associated to a character in the ASCII encoding and additionally
     the constraints of RFC 3986 are satisfied.

 -- Function: string-or-symbol->string OBJ
     If OBJ is a string return a copy of it; if it is a symbol return a
     new string object equal to its string name.

 -- Function: string-or-symbol->symbol OBJ
     If OBJ is a symbol return it; if it is a string return a symbol
     having it as string name.


File: vicare-scheme.info,  Node: iklib strings misc,  Prev: iklib strings conversion,  Up: iklib strings

6.27.5 Miscellaneous string operations
--------------------------------------

 -- Function: uuid
     Attempt to build a unique string and return it.  If an internal
     error occurs because of impossible generation: raise an error.


File: vicare-scheme.info,  Node: iklib vectors,  Next: iklib symbols,  Prev: iklib strings,  Up: iklib

6.28 Additional vector functions
================================

* Menu:

* iklib vectors constructors::  Vector constructors.
* iklib vectors predicates::    Vector predicates.
* iklib vectors comparison::    Vector comparison procedures.
* iklib vectors copying::       Copying vectors.
* iklib vectors iteration::     Iterating vectors.
* iklib vectors misc::          Miscellaneous vector operations.


File: vicare-scheme.info,  Node: iklib vectors constructors,  Next: iklib vectors predicates,  Up: iklib vectors

6.28.1 Vector constructors
--------------------------

 -- Function: vector-append VEC ...
     Return a newly allocated vector whose items form the concatenation
     of the given vectors.

 -- Function: vector-resize VEC NEW-LENGTH
 -- Function: vector-resize VEC NEW-LENGTH FILL
     Return a new vector of length NEW-LENGTH whose first slots are
     filled with the items from VEC and whose last slots, if any left,
     are filled with FILL.  When not used: FILL defaults to '#f'.

          (vector-resize '#() 0)          => #()
          (vector-resize '#() 3)          => #(#f #f #f)
          (vector-resize '#(1 2 3) 5)     => #(1 2 3 #f #f)
          (vector-resize '#(1 2 3) 2)     => #(1 2)


File: vicare-scheme.info,  Node: iklib vectors predicates,  Next: iklib vectors comparison,  Prev: iklib vectors constructors,  Up: iklib vectors

6.28.2 Vector predicates
------------------------

 -- Function: vector-empty? VEC
     Return '#t' if the vector VEC has zero length, otherwise return
     '#f'.  It is an error if VEC is not a vector.

 -- Function: empty-vector? OBJ
     Return '#t' if OBJ is a vector and it has zero length, otherwise
     return '#f'.

 -- Function: non-empty-vector? OBJ
 -- Function: nevector? OBJ
     Return '#t' if OBJ is a vector object with non-zero length;
     otherwise return '#f'.  This function does *not* raise an exception
     if OBJ is not a vector object.

 -- Function: list-of-vectors? OBJ
     Return '#t' if OBJ is null or a proper list of vector objects;
     otherwise return '#f'.

 -- Function: vectors-of-same-length? VEC0 VEC ...
     Return '#t' if all the arguments are vectors of the same length;
     otherwise return '#f'.  It is an error if an argument is not a
     vector object.

 -- Function: list-of-vectors-of-same-length? OBJ
     Return '#t' if OBJ is null or a proper list of vector objects, all
     with the same length; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib vectors comparison,  Next: iklib vectors copying,  Prev: iklib vectors predicates,  Up: iklib vectors

6.28.3 Vector comparison procedures
-----------------------------------

 -- Function: vector=? VEC0 VEC ...
     Return '#t' if the vector arguments are equal according to
     'equal?'; otherwise return '#f'.

 -- Function: vector!=? VEC0 VEC ...
     The arguments must be vectors.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.


File: vicare-scheme.info,  Node: iklib vectors copying,  Next: iklib vectors iteration,  Prev: iklib vectors comparison,  Up: iklib vectors

6.28.4 Copying vectors
----------------------

 -- Function: subvector VEC START END
     VEC must be a vector, and START and END must be exact integer
     objects satisfying:

          0 <= START <= END <= (vector-length VEC)

     Return a newly allocated vector formed from the items of VEC
     beginning with index START (inclusive) and ending with index END
     (exclusive).

 -- Function: vector-copy VEC
     Return a newly allocated copy of the given vector.  This is
     "shallow" copy, *not* a "deep" copy: the returned vector holds the
     same items of VEC.

 -- Function: vector-copy! SRC.VEC SRC.START DST.VEC DST.START COUNT
     Copy COUNT items from SRC.VEC starting at SRC.START (inclusive) to
     DST.VEC starting at DST.START.  Return unspecified values.


File: vicare-scheme.info,  Node: iklib vectors iteration,  Next: iklib vectors misc,  Prev: iklib vectors copying,  Up: iklib vectors

6.28.5 Iterating vectors
------------------------

 -- Function: vector-find PROC VEC
     PROC should accept one argument and return a single value.  PROC
     should not mutate VEC.  'vector-find' applies PROC to the elements
     of VEC in order.  If PROC returns a true value for an element,
     'vector-find' immediately returns that element.  If PROC returns
     '#f' for all elements of the vector, 'vector-find' returns '#f'.
     PROC is always called in the same dynamic environment as
     'vector-find' itself.

          (vector-find even? '#(3 1 4 1 5 9))
          => 4

          (vector-find even? '#(3 1 5 1 5 9))
          => #f

 -- Function: vector-for-all PROC VEC1 VEC2 ... VECN
 -- Function: vector-exists PROC VEC1 VEC2 ... VECN
     The VECs should all have the same length, and PROC should accept N
     arguments and return a single value.  PROC should not mutate the
     VEC arguments.

     For natural numbers i = 0, 1, ..., the 'vector-for-all' procedure
     successively applies PROC to arguments x_i^1 ... x_i^N, where x_i^j
     is the i-th element of VECJ, until '#f' is returned.

     If PROC returns true values for all but the last element of VEC1,
     'vector-for-all' performs a tail call of PROC on the k-th elements,
     where k is the length of VEC1.  If PROC returns '#f' on any set of
     elements, 'vector-for-all' returns '#f' after the first such
     application of PROC.  If the VECs are all empty, 'vector-for-all'
     returns '#t'.

          (vector-for-all even? '#())             => #t
          (vector-for-all even? '#(3 1 4 1 5 9))  => #f
          (vector-for-all even? '#(2 4 14))       => #t
          (vector-for-all (lambda (n)
                            (and (even? n) n))
                          '#(2 4 14))
          => 14
          (vector-for-all < '#(1 2 3) '#(2 3 4))  => #t
          (vector-for-all < '#(1 2 4) '#(2 3 4))  => #f

     For natural numbers i = 0, 1, ..., the 'vector-exists' procedure
     applies PROC successively to arguments x_i^1 ... x_i^n, where x_i^j
     is the i-th element of VECJ, until a true value is returned.

     If PROC returns '#f' for all but the last elements of the VECs,
     'vector-exists' performs a tail call of PROC on the k-th elements,
     where k is the length of VEC1.  If PROC returns a true value on any
     set of elements, 'vector-exists' returns that value after the first
     such application of PROC.  If the VECs are all empty,
     'vector-exists' returns '#f'.

          (vector-exists even? '#(3 1 4 1 5 9))   => #t
          (vector-exists even? '#(3 1 1 5 9))     => #f
          (vector-exists even? '#())              => #f
          (vector-exists (lambda (n)
                           (and (even? n) n))
                         '#(2 1 4 14))
          => 2
          (vector-exists < '#(1 2 4) '#(2 3 4))   => #t
          (vector-exists > '#(1 2 3) '#(2 3 4))   => #f

     PROC is always called in the same dynamic environment as
     'vector-for-all' or, respectively, 'vector-exists' itself.

 -- Function: vector-fold-left COMBINE KNIL VEC0 VEC ...
 -- Function: vector-fold-right COMBINE KNIL VEC0 VEC ...
     Fold the function COMBINE over the vector arguments, which must
     have the same length.  The return value is the return value of the
     last evaluated call to COMBINE; if all the vector arguments are
     empty, the return value is KNIL.

     The left-folding variant iterate COMBINE left-to-right over each
     element of equal index in all the vectors; COMBINE is applied as:

          (COMBINE STATE
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            )

     where STATE is the current state value, and it is the *first*
     argument; the current state value begins with KNIL, and becomes
     whatever COMBINE returned at the respective iteration.

     The right-folding variant iterate COMBINE right-to-left over each
     element of equal index in all the vectors; COMBINE is applied as:

          (COMBINE
            (vector-ref VEC0 IDX)
            (vector-ref VEC  IDX)
            
            STATE)

     in which STATE is the *last* argument.


File: vicare-scheme.info,  Node: iklib vectors misc,  Prev: iklib vectors iteration,  Up: iklib vectors

6.28.6 Miscellaneous vector operations
--------------------------------------

 -- Function: vector-reset! VEC
 -- Function: vector-reset! VEC START END
     VEC must be a vector, and START and END must be exact integer
     objects satisfying:

          0 <= START <= END < (vector-length VEC)

     Reset to void the selected range of slots beginning with index
     START (inclusive) and ending with index END (exclusive).  Return
     unspecified values.

 -- Function: sorted-vector-binary-search ITEM< VEC SOUGHT
     Return '#f' or a non-negative fixnum representing the index at
     which SOUGHT is present in the sorted vector VEC.  The procedure
     ITEM< is used to compare the items from VEC and the object SOUGHT.

          (sorted-vector-binary-search < '#(0 1 2 3 4 5 6 7 8 9) 3)
          => 3

          (sorted-vector-binary-search < '#(0 1 2 3 4 5 6 7 8 9) 999)
          => #f

          (sorted-vector-binary-search symbol<?
             '#(a b c d e f g h i l m) 'd)
          => 3


File: vicare-scheme.info,  Node: iklib symbols,  Next: iklib fixnums,  Prev: iklib vectors,  Up: iklib

6.29 Additional symbol functions
================================

* Menu:

* iklib symbols predicates::    Predicates about symbols.
* iklib symbols comparison::    Comparing symbols.
* iklib symbols value::         Symbol values.
* iklib symbols plists::        Property lists.


File: vicare-scheme.info,  Node: iklib symbols predicates,  Next: iklib symbols comparison,  Up: iklib symbols

6.29.1 Predicates about symbols
-------------------------------

 -- Function: list-of-symbols? OBJ
     Return '#t' if OBJ is null or a proper list of symbols; otherwise
     return '#f'.


File: vicare-scheme.info,  Node: iklib symbols comparison,  Next: iklib symbols value,  Prev: iklib symbols predicates,  Up: iklib symbols

6.29.2 Comparing symbols
------------------------

 -- Procedure: symbol<? SYM0 ...
 -- Procedure: symbol>? SYM0 ...
 -- Procedure: symbol<=? SYM0 ...
 -- Procedure: symbol>=? SYM0 ...
     These procedures are the extensions to symbols of the corresponding
     orderings on strings.

          (symbol<? z a)          => #t
          (symbol<? z zz)         => #t
          (symbol<? z Z)          => #f

 -- Function: symbol!=? SYM0 SYM ...
     The arguments must be symbols.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.

 -- Function: symbol-max SYM0 SYM ...
 -- Function: symbol-min SYM0 SYM ...
     Return the maximal or minimal symbol argument according to
     'symbol<?'.


File: vicare-scheme.info,  Node: iklib symbols value,  Next: iklib symbols plists,  Prev: iklib symbols comparison,  Up: iklib symbols

6.29.3 Symbol values
--------------------

Under Vicare, Scheme symbols are data structures having a field 'value'
initialised, at symbol construction time, to the built-in value
'#<unbound-object>'; this field has multiple purposes:

   * When the symbol is the unique identifier of a Vicare data structure
     type: 'value' holds the struct-type descriptor of the data
     structure.

   * When the symbol is the unique identifier of a R6RS record type:
     'value' holds the type-descriptor of the record.

   * When the symbol is the "public name" of a core primitive defined by
     Vicare (for example 'display' or '+'): we have to assume that
     'value' holds a Scheme object for internal use by Vicare.

   * When the symbol is a label gensym associated to a syntactic binding
     exported by the boot image: 'value' holds the syntactic binding
     descriptor.

   * When the symbol is a label gensym associated to a syntactic binding
     imported in the current lexical environment: 'value' holds the
     syntactic binding descriptor.

   * When the symbol is a storage location gensym (loc gensym)
     associated to a lexical syntactic binding: 'value' holds the
     current value of the lexical variable.

   * When the symbol is a fresh symbol returned by a call to 'gensym':
     we can use 'value' for any purpose we want.

   In practise, we should never use the 'value' field of symbols unless
they are gensyms we are using for a specific purpose, in which case the
ability to associate a value with a symbol can be quite useful in
building some form of associative array with distributed storage.

   The following bindings are exported by the library '(vicare)'.

 -- Function: top-level-value LOC
     Expect the argument to be a loc gensym associated to a binding;
     extract the value from the slot 'value' of the symbol object and
     return it.  If the value is the unbound object: raise an exception.

     This is both a primitive function and a core primitive operation.

          *NOTE* In binary code, this function has a specific purpose:
          to retrieve the value of a binding defined in a previously
          evaluated expression in the context of an interaction
          environment; we have to know the internals of the expander to
          understand it.  Let's say we are evaluating expressions at the
          REPL; first we do:

               vicare> (define a 1)

          the expander creates a new top level binding in the
          interaction environment; such interaction environment bindings
          are special in that they have a single gensym to serve both as
          lex gensym and loc gensym; the expander transforms the input
          form into the core language form:

               (set! lex.a 1)

          where 'lex.a' is both the lex gensym and the loc gensym
          associated to the binding; the compiler transforms the core
          language expression into:

               ($init-symbol-value! lex.a 1)

          which, compiled and evaluated, will store the value in the
          'value' field of the gensym 'lex.a'.

          Later we do:

               vicare> a

          the expander finds the binding in the interaction environment
          and transforms the variable reference into the core language
          expression:

               lex.a

          the compiler then transforms the core language variable
          reference into:

               (top-level-value 'lex.a)

          which, compiled and evaluated, will return the binding's
          value.

          The same processing happens when we evaluate multiple
          expressions with 'eval' in the context of the same interaction
          environment.

 -- Function: top-level-bound? LOC
     Return '#t' if the symbol object LOC has a proper value in its
     'value' field; return '#f' if the field 'value' is set to the
     unbound object.

 -- Function: set-top-level-value! LOC VALUE
     This function can be used to set a new object in a LOC gensym, so
     that it can be later retrieved by 'top-level-value'.

 -- Function: reset-symbol-proc! SYM
     SYM is meant to be a location gensym.  If the value currently in
     the field 'value' of SYM is a closure object: store such value also
     in the field 'proc' of SYMX.

          *NOTE* Whenever binary code performs a call to a global
          closure object, it does the following:

             * From the relocation vector of the current code object:
               retrieve the loc gensym of the procedure to call.

             * From the loc gensym: extract the value of the 'proc'
               slot, which is meant to be a closure object.  This is
               done by accessing the gensym object with a low-level
               assembly instruction, *not* by using the primitive
               operation '$symbol-proc'.

             * Actually call the closure object.

 -- Function: set-symbol-value! SYM VALUE
     Store VALUE in the 'value' field of the symbol SYM.

 -- Function: symbol-value SYM
     Return the value in the 'value' field of the symbol SYM.

 -- Function: symbol-bound? SYM
     Return true if SYM is a symbol and its 'value' field is *not* set
     to the built-in '#<unbound-object>' machine word value.

 -- Function: unbound-object
     Return the unbound object.

 -- Function: unbound-object? OBJ
     Return '#t' if OBJ is the unbound object.


File: vicare-scheme.info,  Node: iklib symbols plists,  Prev: iklib symbols value,  Up: iklib symbols

6.29.4 Property lists
---------------------

Property lists are key/value associations that can be attached to any
Scheme symbol.

     #!ikarus
     (import (vicare))

     (putprop 'ciao 'british 'hello)
     (putprop 'ciao 'spanish 'hola)

     (getprop 'ciao 'british)        => hello
     (getprop 'ciao 'spanish)        => hola

     (remprop 'ciao 'british)
     (getprop 'ciao 'british)        => #f

     (property-list 'ciao)           => ((spanish . hola))

   The following bindings are exported by the library '(vicare)'.

 -- Function: putprop SYMBOL KEY VALUE
     Add a new property KEY with VALUE to the property list of SYMBOL.
     KEY must be a symbol, VALUE can be any value.

     If KEY is already set: the old entry is mutated to reference the
     new VALUE.

 -- Function: getprop SYMBOL KEY
     Return the value of the property KEY in the property list of
     SYMBOL; if KEY is not set return false.  KEY must be a symbol.

 -- Function: remprop SYMBOL KEY
     Remove property KEY from the list associated to SYMBOL.

 -- Function: property-list SYMBOL
     Return a new association list representing the property list of
     SYMBOL.  The order of the entries is the same as the property
     creation order.


File: vicare-scheme.info,  Node: iklib fixnums,  Next: iklib flonums,  Prev: iklib symbols,  Up: iklib

6.30 Additional functions on fixnums
====================================

* Menu:

* iklib fixnums predicates::    Predicates.
* iklib fixnums comparison::    Comparison functions.
* iklib fixnums arithmetics::   Arithmetics.
* iklib fixnums conversion::    Conversion functions.


File: vicare-scheme.info,  Node: iklib fixnums predicates,  Next: iklib fixnums comparison,  Up: iklib fixnums

6.30.1 Predicates
-----------------

 -- Function: list-of-fixnums? OBJ
     Return '#t' if OBJ is null or a proper list of fixnums; otherwise
     return '#f'.

 -- Function: fxnonpositive? FX
 -- Function: fxnonnegative? FX
     Return '#t' if FX is, respectively, non-positive or non-negative;
     else return '#f'.

 -- Function: zero-fixnum? OBJ
 -- Function: non-zero-fixnum? OBJ
     Return '#t' if OBJ is a zero or non-zero fixnum; otherwise return
     '#f'.  If OBJ is not a fixnum: return '#f'.

 -- Function: positive-fixnum? OBJ
 -- Function: negative-fixnum? OBJ
 -- Function: non-positive-fixnum? OBJ
 -- Function: non-negative-fixnum? OBJ
     Return '#t' if OBJ is a fixnum respectively: positive, negative,
     non-positive, non-negative; otherwise return '#f'.  If OBJ is not a
     fixnum: return '#f'.

 -- Function: byte-fixnum? OBJ
     Return '#t' if OBJ is a byte value.  A "byte" is a fixnum in the
     range [-128, 127].

 -- Function: zero-byte-fixnum? OBJ
 -- Function: positive-byte-fixnum? OBJ
 -- Function: negative-byte-fixnum? OBJ
     Return '#t' if OBJ is a byte value, respectively: zero, positive,
     negative.

 -- Function: octet-fixnum? OBJ
     Return '#t' if OBJ is an octet value.  An "octet" is a fixnum in
     the range [0, 255].

 -- Function: zero-octet-fixnum? OBJ
 -- Function: positive-octet-fixnum? OBJ
     Return '#t' if OBJ is an octet value, respectively: zero, positive.


File: vicare-scheme.info,  Node: iklib fixnums comparison,  Next: iklib fixnums arithmetics,  Prev: iklib fixnums predicates,  Up: iklib fixnums

6.30.2 Comparison functions
---------------------------

 -- Function: fx= FX1 FX ...
 -- Function: fx< FX1 FX ...
 -- Function: fx> FX1 FX ...
 -- Function: fx<= FX1 FX ...
 -- Function: fx>= FX1 FX ...
     Aliases for 'fx=?', 'fx<?', 'fx>?', 'fx<=?', 'fx>=?'.

 -- Function: fx!=? FX0 FX ...
 -- Function: fx!= FX0 FX ...
     The arguments must be fixnums.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.


File: vicare-scheme.info,  Node: iklib fixnums arithmetics,  Next: iklib fixnums conversion,  Prev: iklib fixnums comparison,  Up: iklib fixnums

6.30.3 Arithmetics
------------------

 -- Function: fxadd1 FX
 -- Function: fxsub1 FX
     Add or subtract '1' to FX.

 -- Function: fxabs FX
     Return the absolute value of the fixnum FX as a fixnum; if FX is
     '(least-fixnum)': its absolute value is a bignum, in which case
     this function raises an implementation restriction violation.

     To compute the general absolute value without overflow we must use
     'abs' or '$abs-fixnum'.

 -- Function: fxsign FX
     Return one of the fixnums '+1', '-1', '0' representing the sign of
     the fixnum FX.

 -- Procedure: fxquotient FX1 FX2
 -- Procedure: fxremainder FX1 FX2
 -- Procedure: fxmodulo FX1 FX2
     These procedures implement number-theoretic (integer) division on
     fixnum arguments.  FX2 must be non-zero.  All three procedures
     return fixnum objects.  If FX1/FX2 is an integer object:

          (fxquotient  FX1 FX2)  => FX1/FX2
          (fxremainder FX1 FX2)  => 0
          (fxmodulo    FX1 FX2)  => 0

     If FX1/FX2 is not an integer object:

          (fxquotient  FX1 FX2)  => N_Q
          (fxremainder FX1 FX2)  => N_R
          (fxmodulo    FX1 FX2)  => N_M

     where N_Q is FX1/FX2 rounded towards zero,

          0 < |N_R| < |FX2|
          0 < |N_M| < |FX2|

     N_R and N_M differ from FX1 by a multiple of FX2, N_R has the same
     sign as FX1, and N_M has the same sign as FX2.

     Consequently, for integer objects FX1 and FX2 with FX2 not equal to
     0,

          (= FX1 (+ (* FX2 (fxquotient  FX1 FX2))
                           (fxremainder FX1 FX2)))
          => #t

     provided all number object involved in that computation are exact.

          (fxmodulo 13 4)           =>  1
          (fxremainder 13 4)        =>  1

          (fxmodulo -13 4)          =>  3
          (fxremainder -13 4)       =>  -1

          (fxmodulo 13 -4)          =>  -3
          (fxremainder 13 -4)       =>  1

          (fxmodulo -13 -4)         =>  -1
          (fxremainder -13 -4)      =>  -1


File: vicare-scheme.info,  Node: iklib fixnums conversion,  Prev: iklib fixnums arithmetics,  Up: iklib fixnums

6.30.4 Conversion functions
---------------------------

 -- Function: fixnum->char FX
 -- Function: char->fixnum CH
     Convert a fixnum to and from a character.

 -- Function: fixnum->string FX
 -- Function: fixnum->string FX BASE
     Return a string representation of FX.  BASE must be one among 2, 8,
     10, 16; when not given it defaults to 10.


File: vicare-scheme.info,  Node: iklib flonums,  Next: iklib numerics,  Prev: iklib fixnums,  Up: iklib

6.31 Additional functions on flonums
====================================

The following bindings are exported by the library '(vicare)'.

Predicates
..........

 -- Function: list-of-flonums? OBJ
     Return '#t' if OBJ is null or a proper list of flonums; otherwise
     return '#f'.

 -- Function: flnonpositive? FL
 -- Function: flnonnegative? FL
     Return '#t' if FL is, respectively, non-positive or non-negative;
     else return '#f'.

 -- Function: zero-flonum? OBJ
 -- Function: positive-zero-flonum? OBJ
 -- Function: negative-zero-flonum? OBJ
     Return '#t' if OBJ is a flonum representing zero, positive zero or
     negative zero; otherwise return '#f'.  If OBJ is not a flonum:
     return '#f'.

 -- Function: positive-flonum? OBJ
 -- Function: negative-flonum? OBJ
 -- Function: non-positive-flonum? OBJ
 -- Function: non-negative-flonum? OBJ
     Return '#t' if OBJ is a flonum respectively: positive, negative,
     non-positive, non-negative; otherwise return '#f'.  If OBJ is not a
     flonum: return '#f'.

     Notice the following behaviour with zero:

          (positive-flonum? +0.0)         => #f
          (positive-flonum? -0.0)         => #f

          (negative-flonum? +0.0)         => #f
          (negative-flonum? -0.0)         => #f

          (non-positive-flonum? +0.0)     => #t
          (non-positive-flonum? -0.0)     => #t

          (non-negative-flonum? +0.0)     => #t
          (non-negative-flonum? -0.0)     => #t

Comparison
..........

 -- Function: fl!=? FL0 FL ...
     The arguments must be flonums.  Return '#t' if the arguments are
     all different: no two arguments are equal; otherwise return '#f'.
     When applied to a single argument: return '#f'.

String conversion
.................

 -- Function: flzero?/positive FL
 -- Function: flzero?/negative FL
     Return true if the operand is '+0.0' or '-0.0', respectively.
     Notice that 'flzero?' does *not* make this distinction.

String conversion
.................

 -- Function: string->flonum FL
 -- Function: flonum->string STR
     Convert between a flonum and its string representation.

Exponents and logarithms
........................

 -- Function: fllog1p FL
     Return a flonum equivalent to log(1 + FL).

 -- Function: flexpm1 FL
     Return a flonum equivalent to exp(FL) - 1.

 -- Function: flhypot FL1 FL2
     Compute the Euclidean distance function: \sqrt(X*X+Y*Y). *note
     hypot: (libc)Exponents and Logarithms.

Hyperbolic functions
....................

 -- Function: flsinh FL
 -- Function: flcosh FL
 -- Function: fltanh FL
     Compute the hyperbolic functions.  Return flonum objects.

 -- Function: flasinh FL
 -- Function: flacosh FL
 -- Function: flatanh FL
     Compute the inverse hyperbolic functions.  Return flonum objects.

Power functions
...............

 -- Function: flsquare FL
     Return the square of FL, that is FL multiplied by itself.

 -- Function: flcube FL
     Return the cube of FL, that is FL times FL times FL.

 -- Function: flcbrt FL
     Return the real cube root function of FL.

Miscellaneous functions
.......................

 -- Function: flonum-bytes FL
     Return 8 values being fixnums representing octects from the binary
     representation of FL.

 -- Function: flonum-parts FL
     Return 3 values begin: a boolean, true if FL is positive; a fixnum
     representing the exponent's 11 bits; an exact integer representing
     the mantissa's 53 bits.

          (flonum-parts 2.0)
          => #t #b10000000000 #b0

          (flonum-parts 4.0)
          => #t #b10000000001 #b0

          (flonum-parts +0.0)
          => #t #b00000000000 #b0

          (flonum-parts -0.0)
          => #f #b00000000000 #b0


File: vicare-scheme.info,  Node: iklib numerics,  Next: iklib enumerations,  Prev: iklib flonums,  Up: iklib

6.32 Additional functions on numbers
====================================

* Menu:

* iklib numerics constants::    Numeric constants.
* iklib numerics compar::       Additional comparison functions.
* iklib numerics preds::        Additional numeric predicates.
* iklib numerics bignums::      Additional bignum functions.
* iklib numerics ratnums::      Additional ratnum functions.
* iklib numerics math::         Additional math functions.
* iklib numerics bitwise::      Additional bitwise functions.


File: vicare-scheme.info,  Node: iklib numerics constants,  Next: iklib numerics compar,  Up: iklib numerics

6.32.1 Numeric constants
------------------------

The following bindings are exported by the library '(vicare numerics
constants)'.  Notice that under GNU Emacs it is easy to display the
symbol 'greek-pi' with the Unicode glyph for the greek letter adding the
following to the Scheme hook:

     (defun my-pretty-chars-scheme-pi ()
       (interactive)
       (font-lock-add-keywords
        nil '(("\\(\\<[-+]?\\(greek-pi\\)\\)"
               (0 (progn
                    (compose-region (match-beginning 2)
                                    (match-end 2)
                                    ?\u03C0)
                    nil))))))

 -- Constant: greek-pi
 -- Constant: +greek-pi
 -- Constant: -greek-pi
     Evaluate to a constant flonum object representing plus or minus pi.

 -- Constant: greek-pi/2
 -- Constant: +greek-pi/2
 -- Constant: -greek-pi/2
     Evaluate to a constant flonum object representing plus or minus pi
     divided by 2.

 -- Constant: greek-pi/3
 -- Constant: +greek-pi/3
 -- Constant: -greek-pi/3
     Evaluate to a constant flonum object representing plus or minus pi
     divided by 3.

 -- Constant: greek-pi/4
 -- Constant: +greek-pi/4
 -- Constant: -greek-pi/4
     Evaluate to a constant flonum object representing plus or minus pi
     divided by 4.

 -- Constant: greek-pi/6
 -- Constant: +greek-pi/6
 -- Constant: -greek-pi/6
     Evaluate to a constant flonum object representing plus or minus pi
     divided by 6.

 -- Constant: greek-pi*2
 -- Constant: +greek-pi*2
 -- Constant: -greek-pi*2
     Evaluate to a constant flonum object representing plus or minus pi
     multiplied by 2.

 -- Constant: greek-pi*2/3
 -- Constant: +greek-pi*2/3
 -- Constant: -greek-pi*2/3
     Evaluate to a constant flonum object representing plus or minus pi
     multiplied by 2/3.

 -- Constant: greek-pi*3/4
 -- Constant: +greek-pi*3/4
 -- Constant: -greek-pi*3/4
     Evaluate to a constant flonum object representing plus or minus pi
     multiplied by 3/4.


File: vicare-scheme.info,  Node: iklib numerics compar,  Next: iklib numerics preds,  Prev: iklib numerics constants,  Up: iklib numerics

6.32.2 Additional comparison functions
--------------------------------------

 -- Function: != Z1 Z2 Z3 ...
     The arguments must be numbers according to 'number?'.  Return '#t'
     if the arguments are all different: no two arguments are equal;
     otherwise return '#f'.  When applied to a single argument: return
     '#f'.


File: vicare-scheme.info,  Node: iklib numerics preds,  Next: iklib numerics bignums,  Prev: iklib numerics compar,  Up: iklib numerics

6.32.3 Additional numeric predicates
------------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: bignum? OBJ
     Return '#t' if OBJ is an exact integer represented by a big number;
     otherwise return '#f'.

 -- Function: ratnum? OBJ
     Return '#t' if OBJ is an exact rational number; otherwise return
     '#f'.

 -- Function: cflonum? OBJ
     Return '#t' if OBJ is a complex number having flonums as both real
     and imaginary parts; otherwise return '#f'.

 -- Function: compnum? OBJ
     Return '#t' if OBJ is a complex number having any possible
     combination of number representations as real and imaginary parts,
     but not both flonums; otherwise return '#f'.

 -- Function: exact-integer? OBJ
     Return '#t' if OBJ is a fixnum or bignum; otherwise return '#f'.

 -- Function: exact-compnum? OBJ
     Return '#t' if OBJ is a compnum having exact real *and* imaginary
     parts; otherwise return '#f'.

 -- Function: inexact-compnum? OBJ
     Return '#t' if OBJ is a compnum having inexact real *or* imaginary
     parts; otherwise return '#f'.

 -- Function: zero-compnum? OBJ
     Return '#t' if OBJ is a compnum having both real and imaginary
     parts equal to zero; otherwise return '#f'.

     Remembering that a compnum with exact zero as imaginary part is
     converted to a real number by 'make-rectangular':

          1+0i                    => 1
          (make-rectangular 1 0)  => 1

     the compnums of type '<zero-compnum>' are the following:

             0+0.0i    0-0.0i
          +0.0+0.0i -0.0+0.0i
          +0.0-0.0i -0.0-0.0i

     with the imaginary part always inexact.

 -- Function: non-zero-compnum? OBJ
     Return '#t' if OBJ is a compnum having either the real part or
     imaginary part different from zero; otherwise return '#f'.

 -- Function: non-zero-inexact-compnum? OBJ
     Return '#t' if OBJ is a compnum having: either the real part or
     imaginary part inexact; either the real part or imaginary part
     different from zero.  Otherwise return '#f'.

 -- Function: zero-cflonum? OBJ
     Return '#t' if OBJ is a cflonum having both real and imaginary
     parts equal to zero; otherwise return '#f'.

 -- Function: non-zero-cflonum? OBJ
     Return '#t' if OBJ is a cflonum having either the real part or
     imaginary part different from zero; otherwise return '#f'.

 -- Function: non-positive? X
 -- Function: non-negative? X
     Return '#t' if X is a real number object and it is, respectively,
     non-positive or non-negative.

 -- Function: zero-exact-integer? OBJ
     Return '#t' if OBJ is an exact integer whose value is zero,
     otherwise return '#f'; only fixnums can be zero.  If OBJ is not a
     number object: return '#f'.

 -- Function: positive-exact-integer? OBJ
 -- Function: negative-exact-integer? OBJ
     Return '#t' if OBJ is a positive or negative exact integer;
     otherwise return '#f'.  If OBJ is not a number object: return '#f'.

 -- Function: non-positive-exact-integer? OBJ
 -- Function: non-negative-exact-integer? OBJ
     Return '#t' if OBJ is a non-positive or non-negative exact integer;
     otherwise return '#f'.  If OBJ is not a number object: return '#f'.


File: vicare-scheme.info,  Node: iklib numerics bignums,  Next: iklib numerics ratnums,  Prev: iklib numerics preds,  Up: iklib numerics

6.32.4 Additional bignum functions
----------------------------------

 -- Function: bignum-positive? BN
 -- Function: bignum-negative? BN
 -- Function: bignum-non-negative? BN
 -- Function: bignum-non-positive? BN
     The argument must be a bignum.  Return '#t' if BN is, respectively:
     positive, negative, non-positive, non-negative; otherwise return
     '#f'.

 -- Function: positive-bignum? OBJ
 -- Function: negative-bignum? OBJ
 -- Function: non-positive-bignum? OBJ
 -- Function: non-negative-bignum? OBJ
     The argument can be any value.  Return '#t' if OBJ is a bignum and
     it is, respectively: positive, negative, non-positive,
     non-negative; otherwise return '#f'.

 -- Function: bignum-odd? BN
     The argument must be a bignum.  Return '#t' if it is odd, otherwise
     return '#f'.

 -- Function: bignum-even? BN
     The argument must be a bignum.  Return '#t' if it is even,
     otherwise return '#f'.

 -- Function: least-positive-bignum
     Return the smallest positive bignum.

 -- Function: greatest-negative-bignum
     Return the greatest negative bignum.


File: vicare-scheme.info,  Node: iklib numerics ratnums,  Next: iklib numerics math,  Prev: iklib numerics bignums,  Up: iklib numerics

6.32.5 Additional ratnum functions
----------------------------------

 -- Function: ratnum-positive? RN
 -- Function: ratnum-negative? RN
 -- Function: ratnum-non-negative? RN
 -- Function: ratnum-non-positive? RN
     The argument must be a ratnum.  Return '#t' if RN is, respectively:
     positive, negative, non-positive, non-negative; otherwise return
     '#f'.

 -- Function: positive-ratnum? OBJ
 -- Function: negative-ratnum? OBJ
 -- Function: non-positive-ratnum? OBJ
 -- Function: non-negative-ratnum? OBJ
     The argument can be any value.  Return '#t' if OBJ is a ratnum and
     it is, respectively: positive, negative, non-positive,
     non-negative; otherwise return '#f'.


File: vicare-scheme.info,  Node: iklib numerics math,  Next: iklib numerics bitwise,  Prev: iklib numerics ratnums,  Up: iklib numerics

6.32.6 Additional math functions
--------------------------------

The following bindings are exported by the library '(vicare)'.

Arithmetic functions
....................

 -- Function: add1 NUM
 -- Function: sub1 NUM
     Add or subtract '1' to NUM, which can be any number.

 -- Function: square NUM
     Return the square of NUM: NUM times NUM.

 -- Function: cube NUM
     Return the cube of NUM: NUM times NUM times NUM.

 -- Function: cbrt NUM
     Return the cubic root of NUM.

 -- Function: quotient N1 N2
 -- Function: remainder N1 N2
 -- Function: quotient+remainder N1 N2
     'quotient+remainder' returns two values: the quotient and the
     remainder of the number-theoretic integer division between the
     operands; 'quotient' returns the quotient; 'remainder' returns the
     remainder.  N1 and N2 must be exact or inexact integers (fixnums,
     bignums, flonums); N2 must be non-zero.

     The operations are defined as for 'quotient' and 'remainder' from
     '(rnrs r5rs (6))'.

     Note that considering:

          (quotient+remainder X Y)

     according to R6RS:

          (define (sign n)
            (cond ((negative? n) -1)
                  ((positive? n) 1)
                  (else 0)))

          (define (quotient n1 n2)
            (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

          (define (remainder n1 n2)
            (* (sign n1) (mod (abs n1) (abs n2))))

          (define (modulo n1 n2)
            (* (sign n2) (mod (* (sign n2) n1) (abs n2))))

     so we have:

          sign(quotient)  = sign(X) * sign(Y)
          sign(remainder) = sign(X)

 -- Function: sign X
     Return a number object representing the sign of X, which must be a
     real number.  When X is a:

     *fixnum*
     *bignum*
          Return a fixnum representing the sign of X: '+1' for positive,
          '-1' for negative, '0' for zero.

     *flonum*
          Return a flonum representing the sign of X: '+1.0' for
          positive, including '+0.0' and '+inf.0'; '-1' for negative,
          including '-0.0' and '-inf.0'; '+nan.0' for not-a-number.

     *ratnum*
          Return a fixnum representing the sign of the numerator of RN:
          '+1' for positive, '-1' for negative, '0' for zero.

 -- Function: factorial I
     Return the factorial of the non-negative integer I (which can be
     exact or inexact).

Hyperbolic functions
....................

The NUM operand must be a real or complex number.

 -- Function: sinh NUM
 -- Function: cosh NUM
 -- Function: tanh NUM
     Hyperbolic functions.

 -- Function: asinh NUM
 -- Function: acosh NUM
 -- Function: atanh NUM
     Inverse hyperbolic functions.

Complex number functions
........................

 -- Function: complex-conjugate NUM
     Return the complex conjugate of the number object NUM.


File: vicare-scheme.info,  Node: iklib numerics bitwise,  Prev: iklib numerics math,  Up: iklib numerics

6.32.7 Additional bitwise functions
-----------------------------------

The following bindings are exported by the library '(vicare)'.

 -- Function: sra INTEGER OFFSET
     An alias for 'bitwise-arithmetic-shift-right'.

 -- Function: sll INTEGER OFFSET
     An alias for 'bitwise-arithmetic-shift-left'.


File: vicare-scheme.info,  Node: iklib enumerations,  Next: iklib hashtables,  Prev: iklib numerics,  Up: iklib

6.33 Additional functions on enumerations
=========================================

The following bindings are exported by the library '(vicare)'.

 -- Function: enum-set? OBJ
     Return '#t' if OBJ is an enumeration set object, else return '#f'.


File: vicare-scheme.info,  Node: iklib hashtables,  Next: iklib load,  Prev: iklib enumerations,  Up: iklib

6.34 Additional functions on hash tables
========================================

* Menu:

* iklib hashtables pred::       Predicates on hash tables.
* iklib hashtables iterators::  Hash table iterators.
* iklib hashtables hashfun::    Additional hash functions.
* iklib hashtables tcbuckets::  Tail-conc objects.


File: vicare-scheme.info,  Node: iklib hashtables pred,  Next: iklib hashtables iterators,  Up: iklib hashtables

6.34.1 Predicates on hash tables
--------------------------------

 -- Function: mutable-hashtable? OBJ
     Return '#t' if OBJ is a hash table and it is mutable; return '#f'
     otherwise.  This function is different from the standard
     'hashtable-mutable?' because it does *not* raise an error if OBJ is
     not a hash table.

 -- Function: hashtable-eq? OBJ
 -- Function: hashtable-eqv? OBJ
 -- Function: hashtable-equiv? OBJ
     Return '#t' if OBJ is a hashtable object and it has, as equivalence
     function, respectively: 'eq?', 'eqv?', a user supplied function.


File: vicare-scheme.info,  Node: iklib hashtables iterators,  Next: iklib hashtables hashfun,  Prev: iklib hashtables pred,  Up: iklib hashtables

6.34.2 Hash table iterators
---------------------------

Ghuloum and Dybvig explain in the paper:

     Ghuloum, Dybvig.  "Generation-Friendly Eq Hash Tables".
     Proceedings of the 2007 Workshop on Scheme and Functional
     Programming.

why it is not possible to iterate a hash table by visiting the buckets:
there's a problem with rehashing entries that are moved by the garbage
collector.  The iterators always use 'hashtable-keys' and
'hashtable-entries', which is slow and memory consuming, but it is safe.

 -- Function: hashtable-map-keys PROC TABLE
     Build and return a new hash table with the same hash function and
     equivalence function of TABLE; add associations to the new table by
     applying PROC to every key in TABLE, in unspecified order, and
     using the returned value as association value.

          (let* ((A '((a . 1) (b . 2) (c . 3)))
                 (T (alist->hashtable! (make-eq-hashtable) A))
                 (M (hashtable-map-keys
                        (lambda (key) 123)
                      T)))
            (hashtable->alist M (lambda (s1 s2)
                                  (string<? (symbol->string s1)
                                            (symbol->string s2)))))
          => ((a . 123) (b . 123) (c . 123))

 -- Function: hashtable-map-entries PROC TABLE
     Build and return a new hash table with the same hash function and
     equivalence function of TABLE; add associations to the new table by
     applying PROC to every key and value in TABLE, in unspecified
     order, and using the returned value as association value.

          (let* ((A '((a . 1) (b . 2) (c . 3)))
                 (T (alist->hashtable! (make-eq-hashtable) A))
                 (M (hashtable-map-entries
                        (lambda (key val)
                          (* 10 val))
                      T)))
            (hashtable->alist M (lambda (s1 s2)
                                  (string<? (symbol->string s1)
                                            (symbol->string s2)))))
          => ((a . 10) (b . 20) (c . 30))

 -- Function: hashtable-for-each-key PROC TABLE
     Apply PROC to every key in table, in unspecified order, and discard
     the results.  It is implemented as follows:

          (vector-for-each proc (hashtable-keys table))

 -- Function: hashtable-for-each-entry PROC TABLE
     Apply PROC to every key and value in table, in unspecified order,
     and discard the results.  It is implemented as follows:

          (receive (keys vals)
              (hashtable-entries table)
            (vector-for-each proc keys vals))

 -- Function: hashtable-for-all-keys PRED TABLE
     Apply PRED to every key in TABLE, in unspecified order, stopping at
     the first key for which PRED returns '#f'.

        * If PRED returns non-false for every key: the return value is
          the return value of the last call to PRED.

        * If PRED returns '#f' for a key: the return value is '#f'.

     It is implemented as follows:

          (vector-for-all pred (hashtable-keys table))

 -- Function: hashtable-for-all-entries PRED TABLE
     Apply PRED to every key and value in TABLE, in unspecified order,
     stopping at the first application for which PRED returns '#f'.

        * If PRED returns non-false for every key and value: the return
          value is the return value of the last call to PRED.

        * If PRED returns '#f' for a key and value: the return value is
          '#f'.

     It is implemented as follows:

          (receive (keys vals)
              (hashtable-entries table)
            (vector-for-all pred keys vals))

 -- Function: hashtable-exists-key PROC TABLE
     Apply PROC to every key in TABLE in unspecified order.

        * If PROC returns '#f' for every key: the return value is '#f'.

        * If PROC returns non-false for a key: the return value is the
          value returned by PROC.

          (vector-exists proc (hashtable-keys table)))

 -- Function: hashtable-exists-entry PROC TABLE
     Apply PROC to every key and value in TABLE in unspecified order.

        * If PROC returns '#f' for every key and value: the return value
          is '#f'.

        * If PROC returns non-false for a key and value: the return
          value is the value returned by PROC.

          (receive (keys vals)
              (hashtable-entries table)
            (vector-exists proc keys vals))

 -- Function: hashtable-find-key PROC TABLE
     Apply PROC to every key in TABLE in unspecified order.

        * If PROC returns '#f' for every key: the return value is '#f'.

        * If PROC returns non-false for a key: the return value is that
          key.

          (vector-find pred (hashtable-keys table)))

 -- Function: hashtable-find-entry PROC TABLE
     Apply PROC to every key and value in TABLE in unspecified order.

        * If PROC returns '#f' for every key and value: the return value
          is '#f'.

        * If PROC returns non-false for a key and value: the return
          value is a pair having that key as car and that value as cdr.

 -- Function: hashtable-fold-keys PROC NIL TABLE
     Apply PROC to every key in TABLE, in unspecified order; the second
     argument of the first PROC application is NIL, then it is the
     return value of the previous application.  Return the return value
     of the last PROC application.

     It is implemented as follows:

          (vector-fold-right proc nil (hashtable-keys table))

     To build an list of keys we do:

          (hashtable-fold-keys
              (lambda (key nil)
                (cons key nil))
            '() table)

 -- Function: hashtable-fold-entries PROC NIL TABLE
     Apply PROC to every key and value in TABLE, in unspecified order;
     the third argument of the first PROC application is NIL, then it is
     the return value of the previous application.  Return the return
     value of the last PROC application.

     It is implemented as follows:

          (receive (keys vals)
              (hashtable-entries table)
            (vector-fold-right proc nil keys vals))

     To build an alist from a table we do:

          (hashtable-fold-entries
              (lambda (key val nil)
                (cons (cons key val) nil))
            '() table)

 -- Function: hashtable->alist TABLE
 -- Function: hashtable->alist TABLE COMPAR
     Build and return an alist holding the keys and values of TABLE.
     This function is mostly useful for debugging.

     If the optional argument COMPAR is the boolean '#f': just return
     the alist; if it is a procedure: sort the resulting alist with the
     standard 'list-sort' using COMPAR as comparison predicate for the
     keys.

 -- Function: alist->hashtable! TABLE AL
     Fill TABLE with the entries of the alist AL.  Return TABLE itself.


File: vicare-scheme.info,  Node: iklib hashtables hashfun,  Next: iklib hashtables tcbuckets,  Prev: iklib hashtables iterators,  Up: iklib hashtables

6.34.3 Additional hash functions
--------------------------------

 -- Function: bytevector-hash BV
 -- Function: bytevector-hash BV MAX-LEN
     Return a non-negative fixnum representing the hash value for BV,
     based on its current contents.  When creating hash tables using
     bytevectors as keys: this hash function is suitable for use with
     'bytevector=?' as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of bytes to use to compute the hash value, starting
          from the beginning of BV.  If the length of BV is greater than
          MAX-LEN: only the first MAX-LEN bytes are used.  If the length
          of BV is less than or equal to MAX-LEN: all the bytes in BV
          are used.

        * When MAX-LEN is '#f' or not present: if the length of BV is
          greater than 256 bytes, only the first 256 bytes are used to
          compute the hash.

        * When MAX-LEN is '#t': all the bytes in BV are used.

     *NOTE* When the hash value is computed using a number of bytes N
     less than the bytevector length: applications *must not* assume
     that two bytevectors having the first N bytes equal will have the
     same hash value.

 -- Function: vector-hash VEC
 -- Function: vector-hash VEC MAX-LEN
     Return a non-negative fixnum representing the hash value for VEC,
     based on its current contents.  When creating hash tables using
     vectors as keys: this hash function is suitable for use with
     'vector=?' as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of items to use to compute the hash value, starting
          from the beginning of VEC.  If the length of VEC is greater
          than MAX-LEN: only the first MAX-LEN items are used.  If the
          length of VEC is less than or equal to MAX-LEN: all the items
          in VEC are used.

        * When MAX-LEN is '#f' or not present: if the length of VEC is
          greater than 3 items, only the first 3 items are used to
          compute the hash.

        * When MAX-LEN is '#t': all the items in VEC are used.

     *NOTE* When the hash value is computed using a number of items N
     less than the vector length: applications *must not* assume that
     two vectors having the first N items equal will have the same hash
     value.

 -- Function: list-hash ELL
 -- Function: list-hash ELL MAX-LEN
     Return a non-negative fixnum representing the hash value for ELL,
     based on its current contents.  When creating hash tables using
     lists as keys: this hash function is suitable for use with 'equal?'
     as an equivalence function.

     About the MAX-LEN argument:

        * When MAX-LEN is a non-negative fixnum: it is the maximum
          number of items to use to compute the hash value, starting
          from the beginning of ELL.  If the length of ELL is greater
          than MAX-LEN: only the first MAX-LEN items are used.  If the
          length of ELL is less than or equal to MAX-LEN: all the items
          in ELL are used.

        * When MAX-LEN is '#f' or not present: if the length of ELL is
          greater than 3 items, only the first 3 items are used to
          compute the hash.

        * When MAX-LEN is '#t': all the items in ELL are used.

     *NOTE* When the hash value is computed using a number of items N
     less than the list length: applications *must not* assume that two
     lists having the first N items equal will have the same hash value.

 -- Function: pair-hash PAIR
 -- Function: ipair-hash IPAIR
     Hash functions for pairs and immutable pairs.

 -- Function: char-hash CH
 -- Function: char-ci-hash CH
     Hash function for characters.  'char-ci-hash' first applies
     'char-foldcase' to CH.

 -- Function: boolean-hash BOOL
     Hash function for booleans.

 -- Function: fixnum-hash FX
     Hash function for fixnums.

 -- Function: bignum-hash BN
     Hash function for bignums.

 -- Function: exact-integer-hash N
     Hash function for exact integers, fixnums and bignums.

 -- Function: flonum-hash FL
     Hash function for flonums.

 -- Function: ratnum-hash RN
     Hash function for ratnums.

 -- Function: cflonum-hash CFL
     Hash function for cflonums.

 -- Function: flonum-hash FL
     Hash function for flonums.

 -- Function: compnum-hash Z
     Hash function for compnum objects.

 -- Function: struct-hash STRU
     Hash function for Vicare structs.  This is a very low quality hash
     function.

          *NOTE* The result returned by this hash function depends on
          the values in the struct fields, so: it will change if the
          struct is mutated.

 -- Function: record-hash RECO
     Hash function for R6RS records.  This is a very low quality hash
     function.  Notice that it does *not* use the custom hash function
     of RECO (if any).

          *NOTE* The result returned by this hash function depends on
          the values in the record fields, so: it will change if the
          record is mutated.

 -- Function: enum-set-hash ES
     Hash function for enumeration sets.

 -- Function: pointer-hash PTR
     Return a fixnum representing the hash value of PTR.

 -- Function: promise-hash PROM
     Hash function for promise objects.

 -- Function: void-hash OBJ
 -- Function: eof-object-hash OBJ
 -- Function: would-block-hash OBJ
 -- Function: sentinel-hash OBJ
     Ignore OBJ and return a non-negative exact integer representing the
     hash value for '(void)', '(eof-object)', '(would-block-object)' and
     '(sentinel)'.

 -- Function: object-hash OBJ
     Hash function for any Scheme object.  For some object types: this
     is a very low quality hash function.

     When OBJ is a record whose record-type defines a custom hash
     function: 'object-hash' makes use of such custom function;
     otherwise 'record-hash' is used.

 -- Function: pointer-value OBJ
     This is used by 'eq?' hashtables to obtain a fixnum from references
     to objects that are meant to be compared with 'eq?'.


File: vicare-scheme.info,  Node: iklib hashtables tcbuckets,  Prev: iklib hashtables hashfun,  Up: iklib hashtables

6.34.4 Tail-conc objects
------------------------

Objects of type '<tcbucket>' are used in the implementation of
hashtables; when performing common hashtable operations: we do not have
access to such objects.  *note Components or hashtables: objects
tcbuckets.

 -- Function: tcbucket? OBJ
     Return '#t' if OBJ is an object of type '<tcbucket>'; otherwise
     return '#f'.


File: vicare-scheme.info,  Node: iklib load,  Next: iklib modules,  Prev: iklib hashtables,  Up: iklib

6.35 Loading source files
=========================

Loading of source files can be done explicitly or by requesting a
library with the 'import' form.  Here we see how to load files by
specifying their pathname on the file system.

 -- Function: load PATHNAME
 -- Function: load PATHNAME EVAL-PROC
     Read and evaluate the file selected by the string PATHNAME.

     If EVAL-PROC is given: it must be a procedure that takes a single
     argument, an annotated form, and evaluates it.  The default
     EVAL-PROC looks like this:

          (define (load-handler x)
            (eval x (interaction-environment)))

     The format of the annotated source is the one which is
     comprehensible by 'eval'.


File: vicare-scheme.info,  Node: iklib modules,  Next: iklib parameters,  Prev: iklib load,  Up: iklib

6.36 Local modules
==================

Modules are somewhat like libraries in that they define a set of
syntactic bindings in a "private namespace"; syntactic bindings can be
exported from a module and imported into other modules and libraries.
The main difference between modules and R6RS libraries is that modules
are defined in a single form nested into a library; so, in a way, they
are sub-libraries.

* Menu:

* iklib modules api::           Defining modules.
* iklib modules examples::      Usage examples for modules.


File: vicare-scheme.info,  Node: iklib modules api,  Next: iklib modules examples,  Up: iklib modules

6.36.1 Defining modules
-----------------------

Modules are defined with the 'module' syntax and named modules are
imported in the local context with the 'import' syntax.

 -- Syntax: module ?INTERFACE ?DEFINITION ... ?EXPRESSION ...
 -- Syntax: module ?NAME ?INTERFACE ?DEFINITION ... ?EXPRESSION ...
     Define a new local module.  The first form defines an _anonymous_
     module, while the second form defines a _named_ module called
     ?NAME, which must be an identifier.

     ?INTERFACE is a list of identifiers selecting syntactic bindings
     from this module to be exported; every listed identifier must be
     bound in this module's ?DEFINITION, otherwise an error is raised.

     ?DEFINITION is a set of syntactic binding definitions like the one
     that may appear at the beginning of a 'let' body, with the addition
     of 'import' forms that may import syntactic bindings from libraries
     and other modules.  ?EXPRESSION is a set of expressions that is
     evaluated at module's definition time.  At run-time: the
     ?EXPRESSION forms are always evaluated right after the right-hand
     sides of the ?DEFINITION forms and before everything that comes
     after the module definition.

     Modules "exist" only in the enclosing region, bindings exported
     from a module are not accessible outside of the enclosing region.
     Modules can be nested and import/export relations are possible
     according to the regions nesting hierarchy.

     Bindings in the ?INTERFACE declared by anonymous modules are
     imported by default in the enclosing region: there is no need to
     use 'import'.  Bindings in the ?INTERFACE declared by named modules
     are visible only in regions that 'import' the module; all the
     renaming facilities of the 'import' syntax are available for
     modules.


File: vicare-scheme.info,  Node: iklib modules examples,  Prev: iklib modules api,  Up: iklib modules

6.36.2 Usage examples for modules
---------------------------------

* Menu:

* iklib modules examples anonymous::  Anonymous modules examples.
* iklib modules examples named::      Named modules examples.
* iklib modules examples import::     Importing named modules examples.
* iklib modules examples utilities::  Utilities examples.


File: vicare-scheme.info,  Node: iklib modules examples anonymous,  Next: iklib modules examples named,  Up: iklib modules examples

6.36.2.1 Anonymous modules examples
...................................

The following example defines an anonymous module, without expressions,
and invokes its functions from the enclosing region (which is a
top-level program):

     (import (vicare))

     (module (one two three)
       (define (one)       'one)
       (define (two)       'two)
       (define (three)     (cons 'three (hidden)))
       (define (hidden)    'hidden))

     (fprintf (current-error-port)
       "calling anonymous: ~s ~s ~s\n" (one) (two) (three))

the output of the program is:

     calling anonymous: one two (three . hidden)

notice that the 'hidden' function is visible inside the module but not
in the enclosing region.

   The following example defines a module, with expressions, and invokes
its functions from the enclosing region (which is a top-level program):

     (import (vicare))

     (module (one two three)
       (define (one)       'one)
       (define (two)       'two)
       (define (three)     (cons 'three (hidden)))
       (define (hidden)    'hidden)

       (fprintf (current-error-port)
         "defining an anonymous module\n"))

     (fprintf (current-error-port)
       "calling anonymous: ~s ~s ~s\n" (one) (two) (three))

the output of the program is:

     defining an anonymous module
     calling anonymous: one two (three . hidden)

notice how the expressions at the end of a module are evaluated *before*
the expressions at the end of the top-level program.

   When a module definition is present at the top-level of a program:
trailing expressions at the end of the module definitions are handled
like top-level expressions mixed between top-level definitions.  We can
verify this with the following program:

     (import (vicare))

     (define a
       (begin
         (fprintf (current-error-port) "before\n")
         (void)))

     (module ()
       (fprintf (current-error-port) "module\n"))

     (define b
       (begin
         (fprintf (current-error-port) "after\n")
         (void)))

whose output is:

     before
     module
     after

   Let's see, instead, what happens when the module definition is at the
top-level of a library, which does not allow mixed definitions and
expressions.  The following program defines a library using the
'library' syntax:

     (import (vicare))

     (library (the-demo)
       (export a)
       (import (vicare))
       (define a
         (begin
           (fprintf (current-error-port) "before\n")
           123))

       (module ()
         (fprintf (current-error-port) "module\n"))

       (define b
         (begin
           (fprintf (current-error-port) "after\n")
           (void)))

       (fprintf (current-error-port) "library: ~a\n" a)
       #| end of library |# )

     (import (the-demo))
     (fprintf (current-error-port) "program: ~a\n" a)

the output is:

     before
     module
     after
     library: 123
     program: 123

here the module's trailing expressions are evaluated *after* all the
module's definitions and before the following library's definitions and
expressions.


File: vicare-scheme.info,  Node: iklib modules examples named,  Next: iklib modules examples import,  Prev: iklib modules examples anonymous,  Up: iklib modules examples

6.36.2.2 Named modules examples
...............................

The following example defines a module named 'blue' and invokes
functions from it in the top level region:

     (import (vicare))

     (module BLUE
         (blue-one blue-two blue-three)
       (define (blue-one)          'blue-one)
       (define (blue-two)          'blue-two)
       (define (blue-three)        (cons 'blue-three (hidden)))
       (define (hidden)            'blue-hidden))

     (import BLUE)
     (fprintf (current-error-port)
              "calling blue: ~s ~s ~s\n"
              (blue-one) (blue-two) (blue-three))

notice that bindings from a named module are accessible only if imported
in the enclosing region.

   The following example defines two modules named 'green' and 'red',
then it imports their bindings in different regions:

     (import (vicare))

     (internal-body

       (module GREEN (one two three)
         (define (one)       'green-one)
         (define (two)       'green-two)
         (define (three)     (cons 'green-three (hidden)))
         (define (hidden)    'green-hidden))

       (module RED (one two three)
         (define (one)       'red-one)
         (define (two)       'red-two)
         (define (three)     (cons 'red-three (hidden)))
         (define (hidden)    'red-hidden))

       (import GREEN)

       (internal-body
         (import RED)
         (fprintf (current-error-port)
           "calling red: ~s ~s ~s\n" (one) (two) (three)))

       (fprintf (current-error-port)
         "calling green: ~s ~s ~s\n" (one) (two) (three)))

   The following example shows that modules in the same enclosing region
can import their bindings:

     (import (vicare))

     (internal-body

       (module green (one two)
         (define (one)       'one)
         (define (two)       'two))

       (module red (f g)
         (import green)
         (define (f)         (cons 'f (one)))
         (define (g)         (cons 'g (two))))

       (import red)
       (fprintf (current-error-port)
         "calling red: ~s ~s\n" (f) (g)))

while the following example shows that bindings from an anonymous module
are automatically available in modules defined in the same enclosing
region:

     (import (vicare))

     (internal-body

       (module (one two)
         (define (one)       'one)
         (define (two)       'two))

       (module red (f g)
         (define (f)         (cons 'f (one)))
         (define (g)         (cons 'g (two))))

       (import red)
       (fprintf (current-error-port)
         "calling red: ~s ~s\n" (f) (g)))

and the following example shows that the order of module definitions
does not matter in determining visibility of bindings from *anonymous*
modules:

     (import (vicare))

     (internal-body

       (module red (f g)
         (define (f)         (cons 'f (one)))
         (define (g)         (cons 'g (two))))

       (module (one two)
         (define (one)       'one)
         (define (two)       'two))

       (import red)
       (fprintf (current-error-port)
         "calling red: ~s ~s\n" (f) (g)))

the following is an *error* because it tries to import bindings from a
*named* module before its definition:

     (import (vicare))

     (internal-body

       (module red (f g)
         (import green) ;; error here!!!
         (define (f)         (cons 'f (one)))
         (define (g)         (cons 'g (two))))

       (module green (one two)
         (define (one)       'one)
         (define (two)       'two))

       (import red)
       (fprintf (current-error-port)
         "calling red: ~s ~s\n" (f) (g)))


File: vicare-scheme.info,  Node: iklib modules examples import,  Next: iklib modules examples utilities,  Prev: iklib modules examples named,  Up: iklib modules examples

6.36.2.3 Importing named modules examples
.........................................

Import a named module with prefix:

     (import (vicare))

     (module CIAO
       (hello salut)
       (define (hello) 'hello)
       (define (salut) 'salut))

     (import (prefix CIAO ciao::))
     (ciao::hello)   => hello
     (ciao::salut)   => salut

   Import a named module with prefix then deprefix:

     (import (vicare))

     (module CIAO
       (hello salut)
       (define (hello) 'hello)
       (define (salut) 'salut))

     (import (deprefix (prefix CIAO hey-ciao::) hey-))
     (ciao::hello)   => hello
     (ciao::salut)   => salut

   Import a named module with renaming:

     (import (vicare))

     (module CIAO
       (hello salut)
       (define (hello) 'hello)
       (define (salut) 'salut))

     (import (rename CIAO
                     (hello  Hello)
                     (salut  Salut)))
     (Hello)         => hello
     (Salut)         => salut


File: vicare-scheme.info,  Node: iklib modules examples utilities,  Prev: iklib modules examples import,  Up: iklib modules examples

6.36.2.4 Utilities examples
...........................

The following example shows how syntactic abstractions can be used to
access definitions in a module without explicitly using the 'import'
form:

     (import (vicare))

     (define-syntax in-module
       (syntax-rules ()
         ((_ ?module ?expr ...)
          (internal-body (import ?module) ?expr ...))))

     (module red (one two)
       (define (one arg)   (cons 'red-one arg))
       (define (two arg)   (cons 'red-two arg)))

     (module green (one two)
       (define (one arg)   (cons 'green-one arg))
       (define (two arg)   (cons 'green-two arg)))

     (fprintf (current-error-port)
              "calling ones: ~s ~s\n"
              ((in-module red one)   123)
              ((in-module green one) 456))


File: vicare-scheme.info,  Node: iklib parameters,  Next: iklib gensym,  Prev: iklib modules,  Up: iklib

6.37 Parameters
===============

Parameters in Vicare are intended for customizing the behavior of a
procedure during the dynamic execution of some piece of code.
Parameters are first class entities (represented as procedures) that
hold the parameter value.  We can think of a parameter function as:

     (let ((the-value ?INIT-VALUE)
           (guard     ?GUARD-FUNC))
       (case-lambda
         (()
          the-value)
         ((new-value)
          (set! the-value (guard new-value)))
         ((new-value guard?)
          (if guard?
              (set! the-value (guard new-value))
            (set! the-value new-value)))))

where ?INIT-VALUE is the parameter's initialisation value and
?GUARD-FUNC is a function accepting one argument and returning one
value.  The behaviour is as follows:

   * When applied to no arguments: the parameter function returns the
     current value of the parameter.

   * When applied to a single argument: the parameter function sets the
     current value of the parameter to the return value of the guard
     function applied to the argument.  Return zero values.

   * When applied to two arguments: the parameter function sets the
     current value of the parameter to either the return value of the
     guard function applied to the first argument or directly to the
     first argument without applying the guard function.  Return zero
     values.

   Parameter functions are created by 'make-parameter'; the parameter's
initialisation value is *not* automatically passed through the guard
function by 'make-parameter'.  About guarding or not the initialisation
value there are pros and cons for both the choices; Vicare does not
guard the initialisation value because a parameter can be used to hold
"complex" objects and it is not always desirable to create one of those
at program start time.  When needed it is possible to validate the value
by explicitly writing the required predicate.

     As example, consider a parameter used to hold the "current database
     connection"; we may not want to connect to a database right at
     program start time.  With a validating parameter: we should create
     a "null" connection object for the only purpose of initialising the
     parameter and then test for it; with a non-validating parameter: we
     just initialise the parameter to '#f'.

   Parameters replace the older concept of using starred '*global*'
customization variables.  For example, instead of writing:

     (define *screen-width* 72)

and then mutating the variable '*screen-width*' with 'set!', we could
wrap the variable '*screen-width*' with a 'screen-width' parameter as
follows:

     (define *screen-width* 72)
     (define screen-width
        (case-lambda
          (()  *screen-width*)
          ((x) (set! *screen-width* x))))

the value of 'screen-width' can now be passed as argument, returned as a
value, and exported from libraries.  With parameters we can write this
code succinctly as:

     (define screen-width (make-parameter 72))

   Typical uses of the guard function include checking some constraints
on the passed argument or converting it to a different data type.  The
'screen-width' parameter may be constructed more robustly as:

     (define screen-width
       (make-parameter 72
         (lambda (w)
           (assert (and (integer? w) (exact? w)))
           (max w 1))))

this definition ensures, through 'assert', that the argument passed is
an exact integer; it also ensures, through 'max' that the assigned value
is always positive.

 -- Procedure: make-parameter INIT
 -- Procedure: make-parameter INIT GUARD
     Build and return a new parameter function using INIT as
     initialisation value and GUARD as guard function.

 -- Syntax: parametrise ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
 -- Syntax: parameterize ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
 -- Syntax: parameterise ((?LHS ?RHS) ...) ?BODY0 ?BODY ...
     Parameters can be assigned to by simply calling the parameter
     procedure with a single argument.  The 'parameterize' syntax is
     used to set the value of a parameter within the dynamic extent of
     the 'body body* ...' expressions.

     The 'lhs* ...' are expressions, each of which must evaluate to a
     parameter.  Such parameters are not necessarily constructed by
     'make-parameter'--any procedure that follows the parameters
     protocol works.

     The advantage of using 'parameterize' over explicitly assigning to
     parameters (same argument applies to global variables) is that
     you're guaranteed that whenever control exits the body of a
     'parameterize' expression, the value of the parameter is reset back
     to what it was before the body expressions were entered.  This is
     true even in the presence of 'call/cc', errors, and exceptions.

     The following example shows how to set the text property of a
     terminal window.  The parameter 'terminal-property' sends an ANSI
     escape sequence to the terminal whenever the parameter value is
     changed.  The use of 'terminal-property' within 'parameterize'
     changes the property before '(display "RED!")' is called and resets
     it back to normal when the body returns.

          (define terminal-property
            (make-parameter "0"
              (lambda (x)
                (display "\x1b;[")
                (display x)
                (display "m")
                x)))

          (display "Normal and ")
          (parameterize ((terminal-property "41;37"))
            (display "RED!"))
          (newline)

     Notice that this syntax applies the parameters' guard functions
     when setting new values, but does *not* apply them when restoring
     the original value.


File: vicare-scheme.info,  Node: iklib gensym,  Next: iklib printing,  Prev: iklib parameters,  Up: iklib

6.38 Gensyms
============

Gensym stands for _generated symbol_--a fresh symbol that is generated
at run time and is guaranteed to be _not_ 'eq?' to any other symbol
present in the system.  Gensyms are useful in many applications
including expanders, compilers, and interpreters when generating an
arbitrary number of unique names is needed.

   Vicare is similar to Chez Scheme in that the readers (including the
'read' procedure) and writers (including 'write' and 'pretty-print')
maintain the read/write invariance on gensyms.  When a gensym is written
to an output port, the system automatically generates a random unique
identifier for the gensym.  When the gensym is read back though the
'#{gensym}' read syntax, a new gensym is _not_ regenerated, but instead,
it is looked up in the global symbol table.

   A gensym's name is composed of two parts: a _pretty_ string and a
_unique_ string.  The Scheme procedure 'symbol->string' returns the
pretty string of the gensym and not its unique string.  Gensyms are
printed by default as '#{pretty-string unique-string}'.

   The reader supports special syntaxes to generate symbols, *note iklib
reader misc::.

 -- Procedure: gensym
 -- Procedure: gensym STRING
 -- Procedure: gensym SYMBOL
     Construct a new gensym.  If passed no arguments, construct a gensym
     with no pretty name.  The pretty name is constructed when and if
     the pretty name of the resulting gensym is needed.  If 'gensym' is
     passed a string, that string is used as the pretty name.  If
     'gensym' is passed a symbol, the pretty name of the symbol is used
     as the pretty name of the returned gensym.  See 'gensym-prefix' and
     'gensym-count' for details.

          > (gensym)
          #{g0 |y0zf>GlFvcTJE0xw|}
          > (gensym)
          #{g1 |U%X&sF6kX!YC8LW=|}
          > (eq? (gensym) (gensym))
          #f

     '(gensym string)' constructs a new gensym with STRING as its pretty
     name.  Similarly, '(gensym symbol)' constructs a new gensym with
     the pretty name of SYMBOL, if it has one, as its pretty name.

          > (gensym "foo")
          #{foo |>VgOllCM&$dSvRN=|}
          > (gensym 'foo)
          #{foo |!TqQLmtw2hoEYfU>|}
          > (gensym (gensym 'foo))
          #{foo |N2C>5O0>C?OROUBU|}

 -- Procedure: gensym? X
     Return '#t' if its argument is a gensym, return '#f' otherwise.

          > (gensym? (gensym))
          #t
          > (gensym? 'foo)
          #f
          > (gensym? 12)
          #f

 -- Procedure: gensym->unique-string GENSYM
     Return the unique name associated with the gensym argument.

          > (gensym->unique-string (gensym))
          "YukrolLMgP?%ElcR"

An example
..........

The '(rnrs syntax-case)' library provides a 'generate-temporaries'
procedure, which takes a syntax object (representing a list of things)
and returns a list of fresh identifiers.  Using 'gensym', that procedure
can be defined as follows:

     (define (generate-temporaries* stx)
       (syntax-case stx ()
         [(x* ...)
          (map (lambda (x)
                 (datum->syntax #'unimportant
                   (gensym
                     (if (identifier? x)
                         (syntax->datum x)
                         't))))
               #'(x* ...))]))

   The above definition works by taking the input STX and destructuring
it into the list of syntax objects 'x* ...'.  The inner procedure maps
each X into a new syntax object (constructed with 'datum->syntax').  The
datum is a gensym, whose name is the same name as X if X is an
identifier, or the symbol 't' if X is not an identifier.  The output of
'generate-temporaries*' generates names similar to their input
counterpart:

     > (print-gensym #f)
     > (generate-temporaries* #'(x y z 1 2))
     (#<syntax x> #<syntax y> #<syntax z> #<syntax t> #<syntax t>)


File: vicare-scheme.info,  Node: iklib printing,  Next: iklib timing,  Prev: iklib gensym,  Up: iklib

6.39 Printing
=============

* Menu:

* iklib printing formatting::   Formatting and printing strings.
* iklib printing pretty::       Pretty printing Scheme objects.
* iklib printing debug::        Printing for debugging.


File: vicare-scheme.info,  Node: iklib printing formatting,  Next: iklib printing pretty,  Up: iklib printing

6.39.1 Formatting and printing strings
--------------------------------------

 -- Function: format TEMPLATE ARG ...
     Build and return a new string formatted according to the template
     in the string TEMPLATE and the supplied arguments.  The template
     string contains markers in which the string representation of each
     argument is placed.  The markers include:

     '~s'
          Instructs the formatter to place the next argument as if the
          procedure 'write' has printed it; if the argument contains a
          string, the string will be quoted and all quotes and
          backslashes in the string will be escaped; similarly,
          characters will be printed using the '#\x' notation.

     '~a'
          Instructs the formatter to place the next argument as if the
          procedure 'display' has printed it; strings and characters are
          placed as they are in the output.

     '~b'
          Instructs the formatter to convert the next argument to its
          binary (base 2) representation; the argument must be an exact
          number.

     '~o'
          Similar to '~b' except that the number is printed in octal
          (base 8).

     '~x'
          Similar to '~b' except that the number is printed in
          hexadecimal (base 16).

     '~d'
          Outputs the next argument, which can be an exact or inexact
          number, in its decimal (base 10) representation.

     '~~'
          Instructs the formatter to place a tilde character, '~', in
          the output without consuming an argument.

     '~%'
          Instructs the formatter to place a newline character in the
          output without consuming an argument.

     Note that the '#b', '#o', and '#x' numeric prefixes are not added
     to the output when '~b', '~o', and '~x' are used.

          > (format "message: ~s, ~s, and ~s" 'symbol "string" #\c)
          "message: symbol, \"string\", and #\\c"

          > (format "message: ~a, ~a, and ~a" 'symbol "string" #\c)
          "message: symbol, string, and c"

 -- Function: printf TEMPLATE ARG ...
     Similar to 'format' except that the output is sent to the
     'current-output-port' instead of being collected in a string.

          > (let ([n (+ (expt 2 32) #b11001)])
              (printf "~d = #b~b = #x~x\n" n n n))
          4294967321 = #b100000000000000000000000000011001 = #x100000019

 -- Function: fprintf OUTPUT-PORT TEMPLATE ARG ...
     Similar to 'printf' except that the textual output port to which
     the output is sent is specified as the first argument.


File: vicare-scheme.info,  Node: iklib printing pretty,  Next: iklib printing debug,  Prev: iklib printing formatting,  Up: iklib printing

6.39.2 Pretty printing Scheme objects
-------------------------------------

 -- Function: pretty-print DATUM
 -- Function: pretty-print DATUM OUTPUT-PORT
     Printi Scheme data, typically Scheme programs, in a format close to
     how a Scheme programmer would write it.  Unlike 'write', which
     writes its input all in one line, 'pretty-print' inserts spaces and
     new lines in order to produce more pleasant output.

          (define fact-code
            '(letrec ([fact (lambda (n)
                              (if (zero? n)
                                  1
                                (* n (fact (- n 1)))))])
               (fact 5)))

          > (pretty-print fact-code)
          (letrec ((fact
                    (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))))
            (fact 5))

     The second argument to 'pretty-print', if supplied, must be an open
     textual output port.  If not supplied, the 'current-output-port' is
     used.

 -- Function: pretty-print* DATUM OUTPUT-PORT START-COLUMN
          ENDING-NEWLINE?
     Like 'pretty-print' but accepts the additional arguments:

     START-COLUMN
          A non-negative fixnum.  The zero-based column offset at which
          the first line is displayed.  When printing a multiline
          symbolic expression, the column offset of the first line
          depends upon what has been already printed on such line; this
          argument allows us to correctly align the second and
          subsequent lines.  For example the following program:

               #!r6rs
               (import (vicare))

               (pretty-width 10)
               (set-port-buffer-mode! (current-output-port)
                                      (buffer-mode none))

               (display "01234")
               (pretty-print  '("56789" "8 7 6 5"))

               (newline)

               (display "01234")
               (pretty-print* '("56789" "8 7 6 5")
                              (current-output-port) 5 #t)

          prints:

               01234("56789"
                 "8 7 6 5")

               01234("56789"
                      "8 7 6 5")

     ENDING-NEWLINE?
          Interpreted as boolean value.  If true: a newline character is
          output after the symbolic expression.

 -- Parameter: pretty-width
 -- Parameter: pretty-width N
     The parameter 'pretty-width' controls the number of characters
     after which the 'pretty-print' starts breaking long lines into
     multiple lines.  The initial value of 'pretty-width' is set to 60
     characters, which is suitable for most terminals and printed
     material.

          > (parameterize ([pretty-width 40])
               (pretty-print fact-code))
          (letrec ((fact
                    (lambda (n)
                      (if (zero? n)
                          1
                          (* n (fact (- n 1)))))))
            (fact 5))

     Note that 'pretty-width' does not guarantee that the output will
     not extend beyond the specified number.  Very long symbols, for
     examples, cannot be split into multiple lines and may force the
     printer to go beyond the value of 'pretty-width'.

 -- Function: pretty-format OBJ
     Still undocumented.

 -- Parameter: print-unicode
 -- Parameter: print-unicode #t
 -- Parameter: print-unicode #f
     If set to true: print Scheme Unicode characters outside of the
     printable ASCII range in hex format, else print them using the
     encoding of the output port.  This parameter is initialised to
     '#f'.

 -- Parameter: printer-integer-radix
     The radix used to print exact integers (fixnums and bignums) with
     'write', 'display' and similar functions.  Initialised to '10', it
     must hold a value usable as second argument to 'string->number'.

 -- Parameter: print-gensym
 -- Parameter: print-gensym #t
 -- Parameter: print-gensym #f
 -- Parameter: print-gensym 'pretty
     Control how gensyms are printed by the various writers.

        * If the value is '#f': gensym syntax is suppressed by the
          writers and only the gensyms' pretty names are printed.

        * If the value is '#t': the full '#{pretty unique}' syntax is
          printed.

        * If the value is the symbol 'pretty': then gensyms are printed
          using the '#:pretty' notation.

     This parameter is initialised to '#t'.  Examples:

          > (parametrise ((print-gensym #f))
              (pretty-print (list (gensym) (gensym))))
          (g0 g1)

          > (parametrise ((print-gensym #t))
              (pretty-print (list (gensym) (gensym))))
          (#{g2 |KR1M2&CTt1<B0n/m|} #{g3 |FBAb&7NC6&=c82!O|})

          > (parametrise ((print-gensym 'pretty))
              (pretty-print (list (gensym) (gensym))))
          (#:g4 #:g5)

 -- Parameter: gensym-prefix
 -- Parameter: gensym-prefix STRING
     Specify the string to be used as the prefix to generated pretty
     names.  The initialisation value is the string 'g', which causes
     generated strings to have pretty names in the sequence 'g0', 'g1',
     'g2', etc.

          > (parametrise ((gensym-prefix "var")
                          (print-gensym  #f))
              (pretty-print (list (gensym) (gensym) (gensym))))
          (var0 var1 var2)

     This parameter controls how pretty names are generated, and has
     nothing to do with how 'gensym' constructs a new gensym; in
     particular, knowing that it is 'pretty-print' that generates the
     pretty names, notice the difference between the output in the first
     example with the output of the examples below:

          > (pretty-print
              (parametrise ((gensym-prefix "var")
                            (print-gensym  #f))
                (list (gensym) (gensym) (gensym))))
          (g3 g4 g5)

          > (let ((ls (list (gensym) (gensym) (gensym))))
              (parametrise ((gensym-prefix "var")
                            (print-gensym  #f))
                (pretty-print ls)))
          (var5 var6 var7)

 -- Parameter: gensym-count
 -- Parameter: gensym-count N
     Determine the number which is attached to the 'gensym-prefix' when
     gensyms' pretty names are generated.  The initialisation value is
     '0' and it is incremented every time a pretty name is generated.
     It might be set to any non-negative integer value.

          > (let ((x (gensym)))
              (parametrise ((gensym-count 100)
                            (print-gensym #f))
                (pretty-print (list (gensym) x (gensym)))))
          (g100 g101 g102)

   Notice from all the examples so far that pretty names are generated
in the order at which the gensyms are printed, not in the order in which
gensyms were created.


File: vicare-scheme.info,  Node: iklib printing debug,  Prev: iklib printing pretty,  Up: iklib printing

6.39.3 Printing for debugging
-----------------------------

 -- Function: debug-print . ARGS
     Print the given arguments on the current error port using
     'pretty-print'.  This is a convenience function, useful while
     debugging code.  Return '#f'.

 -- Parameter: debug-print-enabled?
     When set to true, 'debug-print*' will print its arguments.  It is
     initialised to '#f'.  We can set this parameter to any value,
     internally the value is normalised to '#t' or '#f'.

 -- Function: debug-print* . ARGS
     Like 'debug-print', but print arguments only when the parameter
     'debug-print-enabled?' is set to true.  Return '#f'.


File: vicare-scheme.info,  Node: iklib timing,  Next: iklib gc,  Prev: iklib printing,  Up: iklib

6.40 Timing
===========

This section describes some of Vicare's timing facilities which may be
useful for benchmarking and performance tuning.

 -- Syntax: time EXPRESSION
     The 'time' macro performs the following: it evaluates EXPRESSION,
     then prints a summary of the run time statistics, then returns the
     values returned by EXPRESSION.  The run-time summary includes the
     number of bytes allocated, the number of garbage collection runs,
     and the time spent in both the mutator and the collector.

          > (let ()                                   ;;; 10 million
              (define ls (time (vector->list (make-vector 10000000))))
              (time (append ls ls))
              (values))
          running stats for (vector->list (make-vector 10000000)):
              3 collections
              672 ms elapsed cpu time, including 547 ms collecting
              674 ms elapsed real time, including 549 ms collecting
              120012328 bytes allocated
          running stats for (append ls ls):
              4 collections
              1536 ms elapsed cpu time, including 1336 ms collecting
              1538 ms elapsed real time, including 1337 ms collecting
              160000040 bytes allocated

          _Note:_ The output listed above is _just a sample_ that was
          taken at some point on some machine.  The output on your
          machine at the time you read this may vary.

 -- Function: Procedure time-it THUNK
 -- Function: Procedure time-it MESSAGE THUNK
     The procedure 'time-it' takes a datum denoting the name of the
     computation and a thunk (i.e.  a procedure with no arguments),
     invokes the thunk, prints the stats, and returns the values
     obtained from invoking the thunk.  If the value of MESSAGE is true,
     MESSAGE is used when displaying the run-time statistics; if the
     value of MESSAGE is '#f', then no name for the computation is
     displayed; when not given MESSAGE defaults to '#f'.

          > (time-it "a very fast computation"
              (lambda () (values 1 2 3)))
          running stats for a very fast computation:
              no collections
              0 ms elapsed cpu time, including 0 ms collecting
              0 ms elapsed real time, including 0 ms collecting
              24 bytes allocated
          1
          2
          3

          > (time-it #f (lambda () 12))
          running stats:
              no collections
              0 ms elapsed cpu time, including 0 ms collecting
              0 ms elapsed real time, including 0 ms collecting
              0 bytes allocated
          12

 -- Function: time-and-gather GATHER THUNK
     Like 'time-it' evaluate the procedure THUNK timing its execution;
     return the return values of THUNK.  Build two objects of type
     '<stats>' and apply the procedure GATHER to them: the first
     represents the statistics before THUNK evaluation, the second
     represents the statistics after THUNK evaluation.

 -- Parameter: verbose-timer
     When set to non-false: print more informations as result of
     'time-it' and 'time-and-gather'.

 -- Object Type: <stats>
     Type name identifier for disjoint objects representing evaluation
     statistics.  It has the following fields:

     'user-secs'
          The user seconds.

     'user-usecs'
          The user microseconds.

     'sys-secs'
          The system seconds.

     'sys-usecs'
          The system microseconds.

     'real-secs'
          The real seconds.

     'real-usecs'
          The real microseconds.

     'collection-id'
          The garbage collection identifier.

     'gc-user-secs'
          The garbage collection user seconds.

     'gc-user-usecs'
          The garbage collection user microseconds.

     'gc-sys-secs'
          The garbage collection system seconds.

     'gc-sys-usecs'
          The garbage collection system microseconds.

     'gc-real-secs'
          The garbage collection real seconds.

     'gc-real-usecs'
          The garbage collection real microseconds.

     'bytes-minor'
          The garbage collection bytes minor.

     'bytes-major'
          The garbage collection bytes major.

 -- Function: stats? OBJ
     Return true if OBJ is an object of type '<stats>'.

 -- Function: stats-user-secs STATS
     Return the user seconds field of STATS.

 -- Function: stats-user-usecs STATS
     Return the user microseconds field of STATS.

 -- Function: stats-sys-secs STATS
     Return the system seconds field of STATS.

 -- Function: stats-sys-usecs STATS
     Return the system microseconds field of STATS.

 -- Function: stats-real-secs STATS
     Return the real seconds field of STATS.

 -- Function: stats-real-usecs STATS
     Return the real microseconds field of STATS.

 -- Function: stats-collection-id STATS
     Return the collection identifier field of STATS.

 -- Function: stats-gc-user-secs STATS
     Return the garbage collection user seconds field of STATS.

 -- Function: stats-gc-user-usecs STATS
     Return the garbage collection user microseconds field of STATS.

 -- Function: stats-gc-sys-secs STATS
     Return the garbage collection system seconds field of STATS.

 -- Function: stats-gc-sys-usecs STATS
     Return the garbage collection system microseconds field of STATS.

 -- Function: stats-gc-real-secs STATS
     Return the garbage collection real seconds field of STATS.

 -- Function: stats-gc-real-usecs STATS
     Return the garbage collection real microseconds field of STATS.

 -- Function: stats-bytes-minor STATS
     Return the garbage collection bytes minor field of STATS.

 -- Function: stats-bytes-major STATS
     Return the garbage collection bytes major field of STATS.


File: vicare-scheme.info,  Node: iklib gc,  Next: iklib guardians,  Prev: iklib timing,  Up: iklib

6.41 Interfacing with garbage collection
========================================

 -- Function: collect
 -- Function: collect REQUESTED-GENERATION
     Explicitly run the garbage collector.  If post-garbage collection
     hooks are registered, they are run.  This function does *not* care
     if automatic garbage collection is disabled.

     The optional argument REQUESTED-GENERATION represents the oldest
     objects generation to collect: when '#f' the generation is
     determined internally; when a fixnum between '0' inclusive and '4'
     inclusive the fixnum represents the generation, where '0' is the
     youngest generation and '4' is the oldest generation.  The symbol
     'fastest' is equivalent to '0', the symbol 'fullest' is equivalent
     to '4'.

 -- Function: automatic-collect
 -- Function: automatic-collect REQUESTED-GENERATION
     Like 'collect', but *does* care if automatic garbage collection is
     disabled.  This function exists mostly for debugging purposes, to
     track what happens when automatic garbage collection is disabled
     and the collector is invoked.

 -- Function: automatic-garbage-collection
 -- Function: automatic-garbage-collection OBJ
     When called with one argument: if OBJ is '#f', disable automatic
     garbage collection; otherwise enable it.  Return a boolean: '#t' if
     automatic garbage collection is enabled; '#f' otherwise.

     When called without arguments, return a boolean: '#t' if automatic
     garbage collection is enabled, '#f' otherwise.

     When automatic garbage collection is disabled: every memory
     allocation for Scheme objects is performed by enlarging, when
     needed, the Scheme heap's nursery.

     We must use with care this function, possibly in conjunction with
     'collect': explicitly calling 'collect' will still perform garbage
     collection even when the automatic one is disabled.

     Strictly speaking, this function is not a parameter, but its API is
     compatible with the one of parameters; so it is possible to use it
     in a 'parametrise' syntax:

          (parametrise ((automatic-garbage-collection #f))
            ?BODY)

Avoiding garbage collection of objects
......................................

The following API allows us to register objects in the internal state of
Vicare so that they are not garbage collected even though we may loose
all the Scheme references to them.

   This mechanism is useful when we create a Scheme object and register
it in a data structure controlled by a foreign library (for example when
interfacing with C language libraries); we can loose the Scheme
references to such object without having it garbage collected, and later
we retrieve the object reference and use it.

             *This API is to be considered experimental.*

 -- Function: register-to-avoid-collecting OBJ
     Register OBJ in the internal state of Vicare so that it is not
     garbage collected even when we loose all the Scheme references to
     it; return a pointer object which can be used to uniquely identify
     the collected OBJ.

     If OBJ is the return value of '(void)': the returned value is a
     'NULL' pointer.

 -- Function: forget-to-avoid-collecting POINTER
     Remove the Scheme object associated to POINTER from the internal
     state of Vicare, so that it is garbage collected when we loose all
     the Scheme references to it; return the referenced object.  POINTER
     must be the return value of a previous call to
     'register-to-avoid-collecting'.

     If POINTER is 'NULL': nothing happens and the returned value is
     '(void)'.

 -- Function: retrieve-to-avoid-collecting POINTER
     Return the Scheme object associated to POINTER in the internal
     state of Vicare.  POINTER must be the return value of a previous
     call to 'register-to-avoid-collecting'.

     If POINTER is 'NULL': nothing happens and the returned value is
     '(void)'.

 -- Function: replace-to-avoid-collecting POINTER NEW-OBJ
     Replace the Scheme object associated to POINTER in the internal
     state of Vicare with NEW-OBJ; return the previously registered
     object.  POINTER must be the return value of a previous call to
     'register-to-avoid-collecting'.

     If POINTER is 'NULL': nothing happens and the returned value is
     '(void)'.

 -- Function: collection-avoidance-list
     Return the list of objects that where registered to avoid
     collection by 'register-to-avoid-collecting'; it can be the empty
     list.

 -- Function: purge-collection-avoidance-list
     Reset to empty the list of objects registered to avoid collection
     with 'register-to-avoid-collecting'.  Use with care.


File: vicare-scheme.info,  Node: iklib guardians,  Next: iklib engines,  Prev: iklib gc,  Up: iklib

6.42 Guardians and garbage collection
=====================================

Guardians are available in the '(vicare)' library; quoting '[DYBGUA]':

     Guardians provide a means to protect objects from destruction by
     the garbage collector.  A guardian is an object with which objects
     can be registered for preservation and from which objects actually
     saved from destruction can be retrieved, one at a time, at the
     convenience of the program.

* Menu:

* iklib guardians examples::    Usage examples for guardians.
* iklib guardians api::         Guardians programming interface.


File: vicare-scheme.info,  Node: iklib guardians examples,  Next: iklib guardians api,  Up: iklib guardians

6.42.1 Usage examples for guardians
-----------------------------------

Let's say that we use the Vicare FFI to handle some memory block (*note
ffi:: for details on the FFI); memory blocks allocated with 'malloc' are
not released by the Vicare garbage collector: we have to explicitly
apply 'free' to the pointer value referencing them.

   If we use the blocks synchronously with the evaluation of forms, we
do (assuming we do not use continuations, so this use of 'dynamic-wind'
is fine):

     (import (vicare)
       (vicare ffi))

     (define (do-something-with . args)
       (display args)
       (newline))

     (let ((p        #f)
           (size     4096))
       (dynamic-wind
           (lambda ()
             (set! p (malloc size))
             (unless p (error #f "memory allocation")))
           (lambda ()
             (do-something-with p))
           (lambda ()
             (free p))))

and we can define a syntax for it:

     (import (vicare)
       (vicare ffi))

     (define (do-something-with . args)
       (display args)
       (newline))

     (define-syntax with-block
       (syntax-rules ()
         ((_ ?pointer ?size ?body ...)
          (let ((?pointer    #f))
            (dynamic-wind
                (lambda ()
                  (set! ?pointer (malloc ?size))
                  (unless ?pointer (error #f "memory allocation")))
                (lambda ()
                  ?body ...)
                (lambda ()
                  (free ?pointer)))))))

     (with-block p 2048
       (do-something-with p))

     (with-block p 4096
       (do-something-with p))

     (with-block p 8192
       (do-something-with p))

   If we need the block in an event driven program: we will probably
need to use it asynchronously with the evaluation of forms.  For
example, we store the pointer value that references a block in a thunk
(a closure that takes no arguments):

     (import (vicare)
       (vicare ffi))

     (define *event-source* '())

     (define (enqueue-event event)
       (set! *event-source*
             (reverse (cons event (reverse *event-source*)))))

     (define (pop-event)
       (if (null? *event-source*)
           #f
         (let ((event (car *event-source*)))
           (set! *event-source* (cdr *event-source*))
           event)))

     ;; Usage:

     (define (do-something-with . args)
       (display args)
       (newline))

     (let ((p (malloc 4096)))
       (unless p (error #f "memory allocation"))
       (enqueue-event (lambda ()
                        (do-something-with p)))
       (enqueue-event (lambda ()
                        (do-something-with 123)))
       (enqueue-event (lambda ()
                        (do-something-with p))))

     (do ((event (pop-event) (pop-event)))
         ((not event))
       (event))

once the thunks have been evaluated, the pointer value is garbage
collected, but the allocated memory block becomes leaked memory.  We
need a way to be notified of the pointer value garbage collection, so
that we can apply 'free' to it; this is the job for guardians.

   The following script shows the usage of a guardian to free a memory
block:

     (import (vicare)
       (vicare ffi))

     (define g (make-guardian))

     (let ((a (malloc (expt 2 20))))
       (unless p (error #f "memory allocation"))
       (g a)
       (printf "value ~s~%" a))

     (printf "value from guardian ~s~%" (g))

     ;; This triggers a garbage collection.
     (collect)

     (let ((p (g)))
       (printf "value from guardian ~s~%" p)
       (free p))

   In an event driven program what we have to do is to register the
pointer into the guardian, and then periodically enqueue as event a call
to the guardian:

     (import (vicare)
       (vicare ffi))

     ;; Event source handling.

     (define *event-source* '())

     (define (enqueue-event event)
       (set! *event-source*
             (reverse (cons event (reverse *event-source*)))))

     (define (pop-event)
       (if (null? *event-source*)
           #f
         (let ((event (car *event-source*)))
           (set! *event-source* (cdr *event-source*))
           event)))

     ;; Block guardian.

     (define block-guardian (make-guardian))

     (define (run-block-guardian)
       (do ((p (block-guardian) (block-guardian)))
           ((not p))
         (printf "collecting ~s~%" p)
         (free p)))

     ;; Application follows.

     (define (do-something-with . args)
       (display args)
       (newline))

     (let ((p (malloc (expt 2 20))))
       (unless p (error #f "memory allocation"))
       (block-guardian p)
       (enqueue-event (lambda () (do-something-with p)))
       (enqueue-event (lambda () (do-something-with 123)))
       (enqueue-event (lambda () (do-something-with p)))
       (enqueue-event (lambda () (do-something-with 456))))

     (do ((event (pop-event) (pop-event))
          (i 1 (+ i 1)))
         ((= i 20))
       (when event
         (event))
       (when (= 0 (modulo i 10))
         (collect)
         (enqueue-event run-block-guardian)))


File: vicare-scheme.info,  Node: iklib guardians api,  Prev: iklib guardians examples,  Up: iklib guardians

6.42.2 Guardians programming interface
--------------------------------------

 -- Function: make-guardian
     Build and return a new guardian object: a closure that can be
     called with one or zero arguments, and that is interfaced with the
     garbage collector of Vicare in a non-portable way.

     The guardian work like this:

        * When the closure is called with one argument: it adds the
          argument to an internal set of "guarded values", accessible to
          the garbage collector; the return value if the argument
          itself.

        * When the garbage collector detects no other references to a
          value in the set of guarded values: the guardian removes it
          from the set and appends it to an internal queue (FIFO).

        * When the closure is called with zero arguments: it removes the
          first value from the internal queue and returns it; if no
          values are in the queue it returns '#f'.

     After an object has been returned by the guardian, it is no more
     "guarded" so it will be garbage collected when it will become
     inaccessible (unless it is again registered in a guardian).

          *NOTE* It is possible to register an object in more than one
          guardian; when the object is found inaccessible all the
          guardian closures that have it will return it to the caller.
          This may lead to invalid finalisation operations, it is the
          responsibility of the programmer to avoid this.

          *NOTE* It is possible to register an object multiple times in
          the same guardian; when the object is found inaccessible the
          guardian closure that has it will return it to the caller
          multiple times.  This may lead to invalid finalisation
          operations, it is the responsibility of the programmer to
          avoid this.

 -- Parameter: post-gc-hooks
     Hold a list of thunks evaluated after each garbage collection run.
     It can be used to run a guardian cleanup function like this (using
     the example in the previous section):

          (define (run-block-guardian)
            (do ((p (block-guardian) (block-guardian)))
                ((not p))
              (free p)))

          (post-gc-hooks
           (cons run-block-guardian
            (post-gc-hooks)))


File: vicare-scheme.info,  Node: iklib engines,  Next: iklib io,  Prev: iklib guardians,  Up: iklib

6.43 Engines
============

 -- Parameter: interrupt-handler
     Still undocumented.

 -- Parameter: engine-handler
     Still undocumented.


File: vicare-scheme.info,  Node: iklib io,  Next: iklib pointers,  Prev: iklib engines,  Up: iklib

6.44 Input/output library
=========================

Vicare extends the input/output facilities defined by R6RS.

* Menu:

* iklib io pathnames::          String and bytevector pathnames
                                handling.
* iklib io codecs::             Transcoders and additional codecs.
* iklib io non-blocking::       Handling non-blocking devices.
* iklib io binary::             Additional binary port features.
* iklib io textual::            Additional textual port features.
* iklib io buffer::             Buffer size customisation.
* iklib io plists::             Port property lists.
* iklib io misc::               Miscellaneous port functions.

