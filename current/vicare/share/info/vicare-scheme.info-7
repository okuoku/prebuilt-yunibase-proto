This is vicare-scheme.info, produced by makeinfo version 6.5 from
vicare-scheme.texi.

This document describes version 0.4.1-devel.3 of Vicare Scheme, an R6RS
compliant native compiler for the Scheme language, producing single
threaded programs running on Intel x86 32-bit and 64-bit processors.
_Vicare_ is pronounced the etruscan way.

   The package, including its documentation, is distributed under the
terms of the GNU General Public License (GPL) and can be downloaded
from:

      <https://bitbucket.org/marcomaggi/vicare-scheme/downloads>

the home page of the project is at:

               <http://marcomaggi.github.io/vicare.html>

development takes place at:

                <http://github.com/marcomaggi/vicare/>

and, as a backup, at:

           <https://bitbucket.org/marcomaggi/vicare-scheme/>

Copyright (C) 2010-2017 by Marco Maggi.
Copyright (C) 2006-2010 by Abdulaziz Ghuloum.
Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

   This document is derived from the original Ikarus documentation by
the Vicare Scheme contributors, see the "History" appendix for details.

   The documentation of IrRegex is Copyright (C) 2005-2012 Alex Shinn.
All rights reserved.

   The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

   The documentation of the library '(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005, 2009-2013
Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License version
     3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   Trademarks used herein are the property of their respective owners.
INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* vicare-scheme: (vicare-scheme).  Vicare Scheme.
END-INFO-DIR-ENTRY


File: vicare-scheme.info,  Node: objects integers,  Next: objects ratnums,  Prev: objects bignums,  Up: objects

13.14 Exact integer objects
===========================

An exact integer is either a fixnum or a bignum.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_INTEGER (ikptr_t OBJ)
     Evaluate to true if OBJ is either a fixnum or a bignum.

Operations on exact integers
............................

 -- Function: int ik_is_bignum (ikptr_t OBJ)
     Return true if OBJ is a bignum.

 -- Function: ikptr_t ika_integer_from_int (ikpcb_t * PCB, int N)
 -- Function: ikptr_t ika_integer_from_long (ikpcb_t * PCB, long N)
 -- Function: ikptr_t ika_integer_from_llong (ikpcb_t * PCB, ik_llong N)
 -- Function: ikptr_t ika_integer_from_uint (ikpcb_t * PCB, ik_uint N)
 -- Function: ikptr_t ika_integer_from_ulong (ikpcb_t * PCB, ik_ulong N)
 -- Function: ikptr_t ika_integer_from_ullong (ikpcb_t * PCB, ik_ullong
          N)
     Build and return a new exact integer object from the given C
     language value.

 -- Function: ikptr_t ika_integer_from_sint8 (ikpcb_t * PCB, int8_t N)
 -- Function: ikptr_t ika_integer_from_sint16 (ikpcb_t * PCB, int16_t N)
 -- Function: ikptr_t ika_integer_from_sint32 (ikpcb_t * PCB, int32_t N)
 -- Function: ikptr_t ika_integer_from_sint64 (ikpcb_t * PCB, int64_t N)
 -- Function: ikptr_t ika_integer_from_uint8 (ikpcb_t * PCB, uint8_t N)
 -- Function: ikptr_t ika_integer_from_uint16 (ikpcb_t * PCB, uint16_t
          N)
 -- Function: ikptr_t ika_integer_from_uint32 (ikpcb_t * PCB, uint32_t
          N)
 -- Function: ikptr_t ika_integer_from_uint64 (ikpcb_t * PCB, uint64_t
          N)
     Build and return a new exact integer object from the given C
     language value.

 -- Function: ikptr_t ika_integer_from_off_t (ikpcb_t * PCB, off_t N)
 -- Function: ikptr_t ika_integer_from_ssize_t (ikpcb_t * PCB, ssize_t
          N)
 -- Function: ikptr_t ika_integer_from_size_t (ikpcb_t * PCB, size_t N)
 -- Function: ikptr_t ika_integer_from_ptrdiff_t (ikpcb_t * PCB,
          ptrdiff_t N)
     Build and return a new exact integer object from the given C
     language value.

 -- Function: ikptr_t ika_integer_from_sword (ikpcb_t * PCB, iksword_t
          W)
 -- Function: ikptr_t ika_integer_from_uword (ikpcb_t * PCB, ikuword_t
          W)
     Build and return a new exact integer object from the given C
     language value.

 -- Function: int ik_integer_to_int (ikptr_t X)
 -- Function: long ik_integer_to_long (ikptr_t X)
 -- Function: ik_llong ik_integer_to_llong (ikptr_t X)
 -- Function: ik_uint ik_integer_to_uint (ikptr_t X)
 -- Function: ik_ulong ik_integer_to_ulong (ikptr_t X)
 -- Function: ik_ullong ik_integer_to_ullong (ikptr_t X)
     Return a C language number from a Scheme exact integer object.  The
     object X must be in the correct range for the requested conversion.

 -- Function: int8_t ik_integer_to_sint8 (ikptr_t X)
 -- Function: int16_t ik_integer_to_sint16 (ikptr_t X)
 -- Function: int32_t ik_integer_to_sint32 (ikptr_t X)
 -- Function: int64_t ik_integer_to_sint64 (ikptr_t X)
 -- Function: uint8_t ik_integer_to_uint8 (ikptr_t X)
 -- Function: uint16_t ik_integer_to_uint16 (ikptr_t X)
 -- Function: uint32_t ik_integer_to_uint32 (ikptr_t X)
 -- Function: uint64_t ik_integer_to_uint64 (ikptr_t X)
     Return a C language number from a Scheme exact integer object.  The
     object X must be in the correct range for the requested conversion.

 -- Function: off_t ik_integer_to_off_t (ikptr_t X)
 -- Function: size_t ik_integer_to_size_t (ikptr_t X)
 -- Function: ssize_t ik_integer_to_ssize_t (ikptr_t X)
 -- Function: ptrdiff_t ik_integer_to_ptrdiff_t (ikptr_t X)
     Return a C language number from a Scheme exact integer object.  The
     object X must be in the correct range for the requested conversion.

 -- Function: iksword_t ika_integer_from_sword (ikpcb_t * PCB, ikptr_t
          X)
 -- Function: ikuword_t ika_integer_from_uword (ikpcb_t * PCB, ikptr_t
          X)
     Return a C language number from a Scheme exact integer object.  The
     object X must be in the correct range for the requested conversion.


File: vicare-scheme.info,  Node: objects ratnums,  Next: objects flonums,  Prev: objects integers,  Up: objects

13.15 Ratnum objects
====================

Ratnums are exact rational numbers, having a fixnum or bignum as
numerator and a fixnum or bignum as denominator; the numerator is always
non-zero; the denominator is always strictly positive, the sign of a
ratnum is the sign of the numerator.

   A ratnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a ratnum block is tagged
has ratnum in its least significant bits and it has the most significant
bits set to zero.

     |------------------------|-------------| reference to ratnum
           heap pointer         vector tag

     |------------------------|-------------| ratnum first word
        all set to zero         ratnum tag

   A ratnum memory block is 4 words wide; a reference to the numerator
is stored in the second word and a reference to the denominator is
stored in the third word:

        1st word     2nd word     3rd word     4th word
     |------------|------------|------------|------------|
      tagged word   numerator   denominator     unused

Basic operations
................

Ratnums are allocated on the Scheme heap as follows:

     ikpcb_t * pcb   = ik_the_pcb();
     ikptr_t   s_rn;

     s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
     IK_RATNUM_TAG(s_rn) = ratnum_tag;

after allocation we must always initialise the numerator and denominator
fields to some correct value before running the next garbage collection.
A full allocation and initialisation is as follows:

     ikpcb_t * pcb   = ik_the_pcb();
     ikptr_t   s_num = the_numerator;
     ikptr_t   s_den = the_denominator;
     ikptr_t   s_rn;

     pcb->root9 = &s_num;
     pcb->root8 = &s_den;
     {
       s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
     }
     pcb->root8 = NULL;
     pcb->root9 = NULL;

     IK_RATNUM_TAG(s_rn) = ratnum_tag;
     IK_RATNUM_NUM(s_rn) = s_num;
     IK_RATNUM_DEN(s_rn) = s_den;

notice that, as in this example, when a new ratnum object is allocated
after the allocation of the numerator and denominator objects: we do not
need to call 'ik_signal_dirt_in_page_of_pointer()' for S_RN because the
ratnum is on the Scheme heap's nursery, so it will for sure be scanned
at the next garbage collection.

   If we allocate the ratnum object first, then the numerator and
denominator objects, we want to follow this pattern:

     ikpcb_t *  pcb  = ik_the_pcb();
     iksword_t  num  = the_numerator;
     iksword_t  den  = the_denominator;
     ikptr_t    s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
     IK_RATNUM_TAG(s_rn) = ratnum_tag;

     pcb->root9 = &s_rn;
     {
       IK_ASS(IK_RATNUM_NUM(s_rn), \
          ika_integer_from_sword(pcb, num));
       IK_SIGNAL_DIRT(pcb, IK_RATNUM_NUM_PTR(s_rn));

       IK_ASS(IK_RATNUM_DEN(s_rn), \
          ika_integer_from_sword(pcb, den));
       IK_SIGNAL_DIRT(pcb, IK_RATNUM_DEN_PTR(s_rn));
     }
     pcb->root9 = NULL;

   To set or retrieve the numerator and denominator we do:

     ikptr_t  s_rn = the_ratnum;
     ikptr_t  s_num;
     ikptr_t  s_den;

     s_num = IK_RATNUM_NUM(s_rn);
     s_den = IK_RATNUM_DEN(s_rn);

     IK_RATNUM_NUM(s_rn) = s_num;
     IK_SIGNAL_DIRT(pcb, IK_RATNUM_NUM_PTR(s_rn));

     IK_RATNUM_DEN(s_rn) = s_den;
     IK_SIGNAL_DIRT(pcb, IK_RATNUM_DEN_PTR(s_rn));

 -- Preprocessor Symbol: ratnum_size
     The number of bytes to allocate to hold a ratnum memory block.

 -- Preprocessor Symbol: ratnum_tag
     The tag of 'ikptr_t' values used as first words in ratnum memory
     blocks.

 -- Preprocessor Symbol: disp_ratnum_tag
     Displacement of secondary tag word.  The number of bytes to add to
     an untagged pointer to ratnum to get the pointer to the first byte
     in the word holding the ratnum tag.

 -- Preprocessor Symbol: disp_ratnum_num
 -- Preprocessor Symbol: disp_ratnum_den
     Displacements of numerator and denominator.  The number of bytes to
     add to an untagged pointer to ratnum to get the pointer to the
     first byte of the reference to the numerator or denominator.

 -- Preprocessor Symbol: off_ratnum_tag
     An integer to add to add to a tagged 'ikptr_t' pointer to ratnum to
     get the pointer to the first byte in the word holding the ratnum
     tag.

 -- Preprocessor Symbol: off_ratnum_num
 -- Preprocessor Symbol: off_ratnum_den
     An integer to add to a tagged 'ikptr_t' pointer to ratnum to get
     the pointer to the first byte of the words referencing the
     numerator or denominator.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_RATNUM (ikptr_t OBJ)
     Evaluate to true if OBJ is a ratnum object; otherwise evaluate to
     false.

 -- Preprocessor Macro: ikptr_t IK_RATNUM_TAG (ikptr_t X)
     Evaluate to the location of the first word in the ratnum memory
     block; X must be a tagged pointer to a ratnum object.  A use of
     this macro can appear both as operand and as left-side of an
     assignment.

 -- Preprocessor Macro: ikptr_t IK_RATNUM_NUM (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_RATNUM_DEN (ikptr_t X)
     Evaluate to the location of the numerator or denominator in the
     ratnum memory block; X must be a tagged pointer to a ratnum object.
     A use of these macros can appear both as operand and as left-side
     of an assignment:

          ikptr_t  s_rn  = the_ratnum;
          ikptr_t  s_num;
          ikptr_t  s_den;

          s_num = IK_RATNUM_NUM(s_rn);
          s_den = IK_RATNUM_NUM(s_rn);

          IK_RATNUM_NUM(s_rn) = s_num;
          IK_SIGNAL_DIRT(pcb, IK_RATNUM_NUM_PTR(s_rn));

          IK_RATNUM_DEN(s_rn) = s_den;
          IK_SIGNAL_DIRT(pcb, IK_RATNUM_DEN_PTR(s_rn));

 -- Preprocessor Macro: ikptr_t * IK_RATNUM_NUM_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t * IK_RATNUM_DEN_PTR (ikptr_t X)
     Evaluate to a pointer to the location of the numerator and
     denominator objects in X, which must be a tagged pointer to a
     ratnum object.  These macros are useful to build the second
     argument for calls to 'ik_signal_dirt_in_page_of_pointer()'.

Operations on ratnums
.....................

 -- Function: int ik_is_ratnum (ikptr_t OBJ)
     Return true if OBJ is a ratnum object.

 -- Function: ikptr_t ika_ratnum_alloc_no_init (ikpcb_t * PCB)
     Allocate a new ratnum object using 'ik_safe_alloc()' and return a
     tagged reference to it.  The fields are left uninitialised.

 -- Function: ikptr_t ika_ratnum_alloc_and_init (ikpcb_t * PCB)
     Allocate a new ratnum object using 'ik_safe_alloc()' and return a
     tagged reference to it.  Both the fields are set to the fixnum
     zero.


File: vicare-scheme.info,  Node: objects flonums,  Next: objects compnums,  Prev: objects ratnums,  Up: objects

13.16 Flonum objects
====================

Flonums are double-precision floating point numbers (8 bytes wide)
implemented as specified by IEEE 754 on the hosting platform.  A flonum
is a fixed length memory block referenced by machine words tagged as
vectors.  The first machine word of a flonum block is tagged has flonum
in its least significant bits and it has the most significant bits set
to zero.

     |------------------------|-------------| reference to flonum
           heap pointer         vector tag

     |------------------------|-------------| flonum first word
        all set to zero         flonum tag

   To allow for the same binary layout: a flonum memory block is 16
bytes wide on both 32-bit and 64-bit platforms; on a 32-bit platform the
actual number is stored in the last two words:

        1st word     2nd word     3rd word     4th word
     |------------|------------|------------|------------|
      tagged word     unused           data words
                               |.........................|
                                         flonum

on a 64-bit platform the actual number is stored in the second word:

               1st word                 2nd word
     |-------------------------|-------------------------|
              tagged word               data word
                               |.........................|
                                         flonum

Basic operations
................

Flonums are allocated on the heap as follows:

     ikpcb_t * pcb  = ik_the_pcb();
     ikptr_t   s_fl;

     s_fl = ik_safe_alloc(pcb, flonum_size) | vector_tag;
     IK_FLONUM_TAG(s_fl) = flonum_tag;

to extract the double number we do:

     ikptr_t  s_fl = the_flonum;
     double   data = IK_FLONUM_DATA(s_fl);

to obtain a pointer to the data area we do:

     ikptr_t   s_fl = the_flonum;
     double *  data = IK_FLONUM_VOIDP(s_fl);

 -- Preprocessor Symbol: flonum_size
     The number of bytes to allocate to hold a flonum memory block.

 -- Preprocessor Symbol: flonum_tag
     The tag of 'ikptr_t' values used as first words in bignum memory
     blocks.

 -- Preprocessor Symbol: disp_flonum_tag
     Displacement of secondary tag word.  The number of bytes to add to
     an untagged pointer to flonum to get the pointer to the first byte
     in the word holding the flonum tag.

 -- Preprocessor Symbol: disp_flonum_data
     Displacement of data area.  The number of bytes to add to an
     untagged pointer to flonum to get the pointer to the first byte in
     the data area holding the actual 'double' value.

 -- Preprocessor Symbol: off_flonum_tag
     An integer to add to add to a tagged 'ikptr_t' pointer to flonum to
     get the pointer to the first byte in the word holding the flonum
     tag.

 -- Preprocessor Symbol: off_flonum_data
     An integer to add to a tagged 'ikptr_t' pointer to flonum to get
     the pointer to the first byte in the data area holding the actual
     'double' value.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_FLONUM (ikptr_t OBJ)
     Return true if OBJ is a flonum object; otherwise return false.

 -- Preprocessor Macro: ikptr_t IK_FLONUM_TAG (ikptr_t FL)
     Evaluate to the location of the first word in a flonum block.  FL
     must be a tagged pointer to flonum object.  A use of this macro can
     appear both as operand or left-side of assignment.

 -- Preprocessor Macro: double IK_FLONUM_DATA (ikptr_t FL)
     Set or retrieve the floating point number; FL must be a tagged
     pointer to flonum object.  A use of this macro can appear both as
     operand or left-side of assignment:

          ikptr_t  s_fl = the_flonum;
          double num;

          IK_FLONUM_DATA(s_fl) = 1.2;
          num = IK_FLONUM_DATA(s_fl);

 -- Preprocessor Macro: void * IK_FLONUM_VOIDP (ikptr_t FL)
     Evaluate to a pointer to the data area of a flonum object.  FL must
     be a tagged pointer to flonum object.

Operations on flonums
.....................

 -- Function: int ik_is_flonum (ikptr_t OBJ)
     Return non-zero if OBJ is a flonum object; otherwise return zero.

 -- Function: ikptr_t iku_flonum_alloc (ikpcb_t * PCB, double N)
     Allocate and return a new flonum object, using 'ik_unsafe_alloc()',
     intialised with N.

 -- Function: ikptr_t ika_flonum_from_double (ikpcb_t * PCB, double N)
     Allocate and return a new flonum object, using 'ik_safe_alloc()',
     intialised with N.


File: vicare-scheme.info,  Node: objects compnums,  Next: objects cflonums,  Prev: objects flonums,  Up: objects

13.17 Compnum objects
=====================

Compnums are complex numbers having a fixnum, bignum, ratnum or flonum
as real part and a fixnum, bignum, ratnum or flonum as imaginary part,
but *not* both flonums.  The imaginary part of a compnum object is never
the exact zero.

   A compnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a compnum block is tagged
has compnum in its least significant bits and it has the most
significant bits set to zero.

     |------------------------|-------------| reference to compnum
           heap pointer         vector tag

     |------------------------|-------------| compnum first word
        all set to zero         compnum tag

   A compnum memory block is 4 words wide; a reference to the real part
is stored in the second word and a reference to the imaginary part is
stored in the third word

        1st word     2nd word     3rd word     4th word
     |------------|------------|------------|------------|
      tagged word   real part    imag part     unused

Basic operations
................

Compnums are allocated on the Scheme heap as follows:

     ikpcb_t * pcb   = ik_the_pcb();
     ikptr_t   s_cn;

     s_cn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
     IK_COMPNUM_TAG(s_cn) = compnum_tag;

after allocation we must always initialise the real and imaginary parts
to some correct value before running the next garbage collection; a full
allocation and initialisation is as follows:

     ikpcb_t * pcb  = ik_the_pcb();
     ikptr_t   s_re = the_real;
     ikptr_t   s_im = the_imag;
     ikptr_t   s_cn;

     pcb->root9 = &s_re;
     pcb->root8 = &s_im;
     {
       s_rn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
     }
     pcb->root8 = NULL;
     pcb->root9 = NULL;

     IK_COMPNUM_TAG(s_cn)  = compnum_tag;
     IK_COMPNUM_REAL(s_cn) = s_re;
     IK_COMPNUM_IMAG(s_cn) = s_im;

notice that, as in this example, when a new compnum object is allocated
after the allocation of the real and imaginary objects: we do not need
to call 'ik_signal_dirt_in_page_of_pointer()' for S_CN because the
compnum is on the Scheme heap's nursery, so it will for sure be scanned
at the next garbage collection.

   If we allocate the compnum object first, then the real and imaginary
objects, we want to follow this pattern:

     ikpcb_t *  pcb  = ik_the_pcb();
     iksword_t  rep  = the_real_part;
     iksword_t  imp  = the_imag_part;
     ikptr_t    s_cn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
     IK_COMPNUM_TAG(s_cn) = compnum_tag;

     pcb->root9 = &s_cn;
     {
       IK_ASS(IK_COMPNUM_REAL(s_cn), \
          ika_integer_from_sword(pcb, rep));
       IK_SIGNAL_DIRT(pcb, IK_COMPNUM_REAL_PTR(s_cn));

       IK_ASS(IK_COMPNUM_IMAG(s_cn), \
          ika_integer_from_sword(pcb, imp));
       IK_SIGNAL_DIRT(pcb, IK_COMPNUM_IMAG_PTR(s_cn));
     }
     pcb->root9 = NULL;

   To set or retrieve the real and imaginary parts we do:

     ikptr_t  s_cn = the_compnum;
     ikptr_t  s_re;
     ikptr_t  s_im;

     s_re = IK_COMPNUM_REAL(s_cn);
     s_im = IK_COMPNUM_IMAG(s_cn);

     IK_COMPNUM_REAL(s_cn) = s_re;
     IK_SIGNAL_DIRT(pcb, IK_COMPNUM_REAL_PTR(s_cn));

     IK_COMPNUM_IMAG(s_cn) = s_im;
     IK_SIGNAL_DIRT(pcb, IK_COMPNUM_IMAG_PTR(s_cn));

 -- Preprocessor Symbol: compnum_size
     The number of bytes to allocate to hold a compnum memory block.

 -- Preprocessor Symbol: compnum_tag
     The tag of 'ikptr_t' values used as first words in compnum memory
     blocks.

 -- Preprocessor Symbol: disp_compnum_tag
     Displacement of secondary tag word.  The number of bytes to add to
     an untagged pointer to compnum to get the pointer to the first byte
     in the word holding the compnum tag.

 -- Preprocessor Symbol: disp_compnum_real
 -- Preprocessor Symbol: disp_compnum_imag
     Displacements of real and imaginary parts.  The number of bytes to
     add to an untagged pointer to compnum to get the pointer to the
     first byte of the reference to the real or imaginary part.

 -- Preprocessor Symbol: off_compnum_tag
     An integer to add to add to a tagged 'ikptr_t' pointer to compnum
     to get the pointer to the first byte in the word holding the
     compnum tag.

 -- Preprocessor Symbol: off_compnum_real
 -- Preprocessor Symbol: off_compnum_imag
     An integer to add to a tagged 'ikptr_t' pointer to compnum to get
     the pointer to the first byte of the words referencing the real or
     imaginary part.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_COMPNUM (ikptr_t OBJ)
     Return true if OBJ is a compnum object; otherwise return false.

 -- Preprocessor Macro: ikptr_t IK_COMPNUM_TAG (ikptr_t X)
     Evaluate to the location of the first word in the compnum memory
     block; X must be a tagged pointer referencing a compnum object.  A
     use of this macro can appear both as operand and as left-side of an
     assignment.

 -- Preprocessor Macro: ikptr_t IK_COMPNUM_REAL (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_COMPNUM_IMAG (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_COMPNUM_REP (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_COMPNUM_IMP (ikptr_t X)
     Evaluate to the location of the real and imaginary parts in the
     compnum memory block; X must be a tagged pointer referencing a
     compnum object.  A use of these macros can appear both as operand
     and as left-side of an assignment:

          ikptr_t  s_cn = the_compnum;
          ikptr_t  s_re;

          s_re = IK_COMPNUM_REAL(s_cn);

          IK_COMPNUM_REAL(s_cn) = s_re;
          IK_SIGNAL_DIRT(pcb, s_cn);

 -- Preprocessor Macro: ikptr_t * IK_COMPNUM_REAL_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t * IK_COMPNUM_IMAG_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t * IK_COMPNUM_REP_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t * IK_COMPNUM_IMP_PTR (ikptr_t X)
     Evaluate to a pointer to the real and imaginary parts in the
     compnum memory block; X must be a tagged pointer referencing a
     compnum object.  These macros are useful in building the second
     argument for calls to 'ik_signal_dirt_in_page_of_pointer()'.

Operations on compnums
......................

 -- Function: int ik_is_compnum (ikptr_t OBJ)
     Return true if OBJ is a compnum object.

 -- Function: ikptr_t ika_compnum_alloc_no_init (ikpcb_t * PCB)
     Allocate a new compnum object using 'ik_safe_alloc()' and return a
     tagged reference to it.  The fields are left uninitialised.

 -- Function: ikptr_t ika_compnum_alloc_and_init (ikpcb_t * PCB)
     Allocate a new compnum object using 'ik_safe_alloc()' and return a
     tagged reference to it.  Both the fields are set to the fixnum
     zero.


File: vicare-scheme.info,  Node: objects cflonums,  Next: objects ports,  Prev: objects compnums,  Up: objects

13.18 Cflonum objects
=====================

Cflonums are complex numbers having a flonum as real part and flonum as
imaginary part.  A cflonum is a fixed length memory block referenced by
machine words tagged as vectors.  The first machine word of a cflonum
block is tagged has cflonum in its least significant bits and it has the
most significant bits set to zero.

     |------------------------|-------------| reference to cflonum
           heap pointer         vector tag

     |------------------------|-------------| cflonum first word
        all set to zero         cflonum tag

   A cflonum memory block is 4 words wide; a reference to the real part
is stored in the second word and a reference to the imaginary part is
stored in the third word

        1st word     2nd word     3rd word     4th word
     |------------|------------|------------|------------|
      tagged word   real part    imag part     unused

Basic operations
................

Cflonums are allocated on the Scheme heap as follows:

     ikpcb_t * pcb   = ik_the_pcb();
     ikptr_t   s_cf;

     s_cf = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
     IK_CFLONUM_TAG(s_cf) = cflonum_tag;

after allocation we must always initialise the real and imaginary parts
to some correct value before running the next garbage collection; a full
allocation and initialisation is as follows:

     ikpcb_t * pcb  = ik_the_pcb();
     ikptr_t   s_re = the_real;
     ikptr_t   s_im = the_imag;
     ikptr_t   s_cf;

     pcb->root9 = &s_re;
     pcb->root8 = &s_im;
     {
       s_rn = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
     }
     pcb->root8 = NULL;
     pcb->root9 = NULL;

     IK_CFLONUM_TAG(s_cf) = cflonum_tag;
     IK_CFLONUM_REP(s_cf) = s_re;
     IK_CFLONUM_IMP(s_cf) = s_im;

notice that, as in this example, when a new cflonum object is allocated
after the allocation of the real and imaginary objects: we do not need
to call 'ik_signal_dirt_in_page_of_pointer()' for S_CF because the
cflonum is on the Scheme heap's nursery, so it will for sure be scanned
at the next garbage collection.

   If we allocate the cflonum object first, then the real and imaginary
objects, we want to follow this pattern:

     ikpcb_t *  pcb  = ik_the_pcb();
     double     rep  = the_real_part;
     double     imp  = the_imag_part;
     ikptr_t    s_cf = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
     IK_CFLONUM_TAG(s_cf) = cflonum_tag;

     pcb->root9 = &s_cf;
     {
       IK_ASS(IK_CFLONUM_REAL(s_cf), \
          ika_flonum_from_double(pcb, rep));
       IK_SIGNAL_DIRT(pcb, IK_CFLONUM_REAL_PTR(s_cf));

       IK_ASS(IK_CFLONUM_IMAG(s_cf), \
          ika_flonum_from_double(pcb, imp));
       IK_SIGNAL_DIRT(pcb, IK_CFLONUM_IMAG_PTR(s_cf));
     }
     pcb->root9 = NULL;

or:

     ikpcb_t *  pcb  = ik_the_pcb();
     double     rep  = the_real_part;
     double     imp  = the_imag_part;
     ikptr_t    s_cf = ika_cflonum_from_doubles(pcb, rep, imp);

   To set or retrieve the real and imaginary parts we do:

     ikptr_t  s_cf = the_cflonum;
     ikptr_t  s_re;
     ikptr_t  s_im;

     s_re = IK_CFLONUM_REAL(s_cf);
     s_im = IK_CFLONUM_IMAG(s_cf);

     IK_CFLONUM_REAL(s_cf) = s_re;
     IK_SIGNAL_DIRT(pcb, IK_CFLONUM_REAL_PTR(s_cf));

     IK_CFLONUM_IMAG(s_cf) = s_im;
     IK_SIGNAL_DIRT(pcb, IK_CFLONUM_IMAG_PTR(s_cf));

 -- Preprocessor Symbol: cflonum_size
     The number of bytes to allocate to hold a cflonum memory block.

 -- Preprocessor Symbol: cflonum_tag
     The tag of 'ikptr_t' values used as first words in cflonum memory
     blocks.

 -- Preprocessor Symbol: disp_cflonum_tag
     Displacement of secondary tag word.  The number of bytes to add to
     an untagged pointer to cflonum to get the pointer to the first byte
     in the word holding the cflonum tag.

 -- Preprocessor Symbol: disp_cflonum_real
 -- Preprocessor Symbol: disp_cflonum_imag
     Displacements of real and imaginary parts.  The number of bytes to
     add to an untagged pointer to cflonum to get the pointer to the
     first byte of the reference to the real or imaginary part.

 -- Preprocessor Symbol: off_cflonum_tag
     An integer to add to add to a tagged 'ikptr_t' pointer to cflonum
     to get the pointer to the first byte in the word holding the
     cflonum tag.

 -- Preprocessor Symbol: off_cflonum_real
 -- Preprocessor Symbol: off_cflonum_imag
     An integer to add to a tagged 'ikptr_t' pointer to cflonum to get
     the pointer to the first byte of the words referencing the real or
     imaginary part.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_CFLONUM (ikptr_t OBJ)
     Return true if OBJ is a cflonum object; otherwise return false.

 -- Preprocessor Macro: ikptr_t IK_CFLONUM_REAL (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_CFLONUM_IMAG (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_CFLONUM_REP (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_CFLONUM_IMP (ikptr_t X)
     Evaluate to the location of the real and imaginary parts in the
     cflonum memory block; X must be a tagged pointer to cflonum object.
     A use of these macros can appear both as operand and as left-side
     of an assignment:

          ikptr_t  s_cf = the_cflonum;
          ikptr_t  s_re;

          s_re = IK_CFLONUM_REAL(s_cf);

          IK_CFLONUM_REAL(s_cf) = s_re;
          IK_SIGNAL_DIRT(pcb, s_cf);

 -- Preprocessor Macro: ikptr_t IK_CFLONUM_REAL_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_CFLONUM_IMAG_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_CFLONUM_REP_PTR (ikptr_t X)
 -- Preprocessor Macro: ikptr_t IK_CFLONUM_IMP_PTR (ikptr_t X)
     Evaluate to a pointer to the real and imaginary parts in the
     cflonum memory block; X must be a tagged pointer to cflonum object.
     These macros are useful to build the second argument to calls to
     'ik_signal_dirt_in_page_of_pointer()'.

Operations on cflonums
......................

 -- Function: int ik_is_cflonum (ikptr_t OBJ)
     Return true if OBJ is a cflonum object.

 -- Function: ikptr_t iku_cflonum_alloc_and_init (ikpcb_t * PCB, double
          RE, double IM)
     Allocate a cflonum and its flonum components using
     'ik_unsafe_alloc()' and return a tagged reference to it.  No
     garbage collection is run while this function is evaluating.

 -- Function: ikptr_t ika_cflonum_from_doubles (ikpcb_t * PCB, double
          RE, double IM)
     Allocate a cflonum and its flonum components using
     'ik_safe_alloc()' and return a tagged reference to it.  This
     function makes use of 'pcb->root9'.

     This function takes care of calling
     'ik_signal_dirt_in_page_of_pointer()' when appropriate.


File: vicare-scheme.info,  Node: objects ports,  Next: objects transcoders,  Prev: objects cflonums,  Up: objects

13.19 Port objects
==================

A port object is a fixed-length memory block referenced by machine words
tagged as vectors; the first word of the vector is the bitwise OR
between a port tag and a bitvector of port attributes.

     |----------------|----------| reference to port
       heap pointer    vector tag

     |----------------|----------| 1st word of memory block
      port attributes   port tag

   At present the port tag is 6 bits wide, so we have:

   * On 32-bit platforms: 32 - 6 = 24 bits available for attributes.

   * On 64-bit platforms: 64 - 6 = 58 bits available for attributes.

   Port objects are handled at the Scheme level.  See the source code in
'ikarus.io.sls' for a more comprehensive documentation.


File: vicare-scheme.info,  Node: objects transcoders,  Next: objects pointers,  Prev: objects ports,  Up: objects

13.20 Transcoder objects
========================

A transcoder is a machine word tagged to make it of a disjoint type.
The transcoder data (codec, EOL style, error handling) is encoded in the
most significant bits of this word:

     |---------------------------|------------| transcoder
            payload bits          transcoder-tag

the payload of this word is an 8-bit vector whose format is as follows:

     765 432 10
      |   |   |
      |   |    -- error handling mode
      |    ------ end of line style
       ---------- codec

   See the source code in the file 'ikarus.codecs.sls' for more details.


File: vicare-scheme.info,  Node: objects pointers,  Next: objects tcbuckets,  Prev: objects transcoders,  Up: objects

13.21 Pointer objects
=====================

A pointer is a fixed length memory block, two words wide, referenced by
machine words tagged as vectors.  The first machine word of a pointer
block is tagged has pointer in its least significant bits and it has the
most significant bits set to zero.  The second machine word of a pointer
block holds the actual pointer value.

     |------------------------|-------------| reference to pointer
           heap pointer         vector tag

     |------------------------|-------------| pointer first word
        all set to zero         pointer tag

     |--------------------------------------| pointer second word
                 pointer value

Basic operations
................

Pointers are allocated on the Scheme heap as follows:

     ikpcb_t * pcb   = ik_the_pcb();
     ikptr_t   s_ptr;

     s_ptr = ik_safe_alloc(pcb, pointer_size) | vector_tag;
     IK_POINTER_TAG(s_ptr) = pointer_tag;

   To set or retrieve the pointer value we do:

     ikptr_t  s_ptr = the_pointer;
     void * ptr;

     ptr = IK_POINTER_DATA_VOIDP(X);
     IK_POINTER_DATA_VOIDP(X) = ptr;

 -- Preprocessor Symbol: pointer_size
     The number of bytes to allocate to hold a pointer memory block.

 -- Preprocessor Symbol: pointer_tag
     The tag of 'ikptr_t' values used as first words in pointer memory
     blocks.

 -- Preprocessor Symbol: disp_pointer_tag
     Displacement of secondary tag word.  The number of bytes to add to
     an untagged pointer to pointer object to get the pointer to the
     first byte in the word holding the pointer tag.

 -- Preprocessor Symbol: disp_pointer_data
     Displacement of data area.  The number of bytes to add to an
     untagged pointer to pointer object to get the pointer to the first
     byte of the data area.

 -- Preprocessor Symbol: off_pointer_tag
     An integer to add to add to a tagged 'ikptr_t' pointer to pointer
     object to get the pointer to the first byte in the word holding the
     pointer tag.

 -- Preprocessor Symbol: off_pointer_data
     An integer to add to a tagged 'ikptr_t' pointer to pointer object
     to get the pointer to the first byte of the word holding the
     pointer value.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_POINTER (ikptr_t X)
     Evaluate to true if X is a pointer object.

 -- Preprocessor Macro: ikptr_t IK_POINTER_TAG (ikptr_t X)
     Evaluate to the location of the first word in a pointer object; X
     must be a tagged pointer referencing a pointer object.

 -- Preprocessor Macro: ikptr_t IK_POINTER_DATA (ikptr_t X)
     Return the value of the pointer as 'ikptr_t'; X must be a tagged
     pointer referencing a pointer object.

 -- Preprocessor Macro: void * IK_POINTER_DATA_VOIDP (ikptr_t X)
 -- Preprocessor Macro: char * IK_POINTER_DATA_CHARP (ikptr_t X)
 -- Preprocessor Macro: uint8_t * IK_POINTER_DATA_UINT8P (ikptr_t X)
 -- Preprocessor Macro: long * IK_POINTER_DATA_LONG (ikptr_t X)
 -- Preprocessor Macro: ik_llong * IK_POINTER_DATA_LLONG (ikptr_t X)
 -- Preprocessor Macro: ik_ulong * IK_POINTER_DATA_ULONG (ikptr_t X)
 -- Preprocessor Macro: ik_ullong * IK_POINTER_DATA_ULLONG (ikptr_t X)
     Return the value of the pointer cast to a specific type; X must be
     a tagged pointer referencing a pointer object.

 -- Preprocessor Macro: ikptr_t IK_POINTER_SET (ikptr_t X, void * PTR)
     Reset to PTR the value of the pointer X; X must be a tagged pointer
     referencing a pointer object.

 -- Preprocessor Macro: ikptr_t IK_POINTER_SET_NULL (ikptr_t X)
     Reset to 'NULL' the value of the pointer; X must be a tagged
     pointer referencing a pointer object.

 -- Preprocessor Macro: int IK_POINTER_IS_NULL (ikptr_t X)
     Evaluate to true if the pointer value is 'NULL'; X must be a tagged
     pointer referencing a pointer object.

Operations on pointers
......................

 -- Function: int ik_is_pointer (ikptr_t X)
     Return true if X is a pointer object.

 -- Function: ikptr_t ikrt_is_pointer (ikptr_t X)
     Return 'IK_TRUE_OBJECT' if X is a pointer object, else return
     'IK_FALSE_OBJECT'.

 -- Function: ikptr_t ika_pointer_alloc (ikpcb_t * PCB, ikuword_t
          MEMORY)
     Allocate a pointer object using 'ik_safe_alloc()' and return a
     tagged reference to it.  The pointer is initialised to MEMORY.

 -- Function: ikptr_t iku_pointer_alloc (ikpcb_t* pcb, ikuword_t MEMORY)
     Allocate a pointer object using 'ik_unsafe_alloc()' and return a
     tagged reference to it.  The pointer is initialised to MEMORY.


File: vicare-scheme.info,  Node: objects tcbuckets,  Next: objects codes,  Prev: objects pointers,  Up: objects

13.22 Components for hashtables
===============================

Tcbuckets are used only to store values in a hashtable: each tcbucket
represents an entry in the table.  Vicare's hash tables are implemented
as explained in the paper:

     Ghuloum, Dybvig.  "Generation-Friendly Eq Hash Tables".
     Proceedings of the 2007 Workshop on Scheme and Functional
     Programming.

   A "tcbucket" (tconc bucket, tail-concatenation bucket) is a
fixed-length memory block referenced by machine words tagged as vectors;
the first word in the memory block is a pair.  Quoting the paper:

     A tconc is a pair whose car points to the first pair in a non-empty
     list and whose cdr points to the last pair in that list.  Element
     are enqueued by extending the list destructively through the
     last-pair pointer and dequeued through the first-pair pointer.  The
     queue is empty when both pointers point to the same pair.

tconc objects allow to enqueue objects faster than ordinary lists.

   References to tcbuckets have the following format:

     |------------------------|-------------| reference to tcbucket
           heap pointer         vector tag

the memory layout of a tcbucket is as follows:

     |-----|-----|-----|-----| tcbucket memory block
      tconc  key   val  next

references to tcbucket are tagged as vectors and reference a word tagged
as pair.

   Tcbuckets are organised in chains, similarly to pairs in lists.  Hash
tables are Scheme vectors whose elements are chains of tcbuckets:

     buckets vector
     --
     | 0
     --
     | --> |tcbucket| --> |tcbucket| --> 1
     --
     | 2
     --
     | --> |tcbucket| --> |tcbucket| --> |tcbucket| --> 3
     --
     | --> |tcbucket| --> 4
     --

If a buckets vector's slot is empty: it is set to a fixnum representing
its own index in the vector.  Every chain of tcbuckets is a "bucket" in
traditional hash tables terminology.  When a new tcbucket is added to a
bucket: it is prepended to the chain.

   The meaning of a tcbucket's fields is as follows:

'tconc'
     A tconc pair.  It is a structure used to efficiently handle hash
     tables using 'eq?' as equivalence function.

'key'
     A Scheme object representing the key of the hash table entry.

'val'
     A Scheme object representing the value of the hash table entry.

'next'
     If this tcbucket *is not* the last in its chain: a reference to the
     next tcbucket in the chain.  If this tcbucket *is* the last in its
     chain: a non-negative fixnum representing the index of this chain
     in the table's buckets vector.

Basic operations
................

 -- Preprocessor Symbol: disp_tcbucket_tconc
 -- Preprocessor Symbol: disp_tcbucket_key
 -- Preprocessor Symbol: disp_tcbucket_val
 -- Preprocessor Symbol: disp_tcbucket_next
     Displacement of fields.  The number of bytes to add to an
     *untagged* pointer to tcbucket to get the pointer to the first byte
     in the word of the tcbucket's field.

 -- Preprocessor Symbol: off_tcbucket_tconc
 -- Preprocessor Symbol: off_tcbucket_key
 -- Preprocessor Symbol: off_tcbucket_val
 -- Preprocessor Symbol: off_tcbucket_next
     An integer to add to a tagged 'ikptr_t' reference to retrieve the
     pointer to the first byte of the word in the tcbucket's field.


File: vicare-scheme.info,  Node: objects codes,  Next: objects closures,  Prev: objects tcbuckets,  Up: objects

13.23 Code objects
==================

Code objects contain compiled binary code ready to be executed by the
host's processor.

* Menu:

* objects codes layout::        Memory layout of code objects.
* objects codes ops::           Operations on code objects.
* objects codes reloc::         The relocation vector.
* objects codes gc::            Memory and garbage collection.


File: vicare-scheme.info,  Node: objects codes layout,  Next: objects codes ops,  Up: objects codes

13.23.1 Memory layout of code objects
-------------------------------------

A code object is a memory block, of variable size, referenced by machine
words tagged as vectors; the memory is allocated with 'mmap()' and is
given read, write and execution protection.  The layout of a code object
is as follows:

     |-----------|-----------------------------------| code object
       meta data                 data area

the data area is filled with executable machine code.

   The first machine word of a code memory block is tagged has code in
its least significant bits and it has the most significant bits set to
zero.

     |------------------------|-------------| reference to code
         memory pointer         vector tag

     |------------------------|-------------| code first word
        all set to zero          code tag

Boot image code objects
.......................

Scheme code objects which are part of the boot image are of 2
categories:

  1. Small code objects whose size fits in a single Vicare page.  Small
     code objects are allocated in the "current code page" while the
     boot image is loaded: a Vicare page marked as used "for code", in
     which code objects are stored one after the other, with size
     aligned to exact multiples of 16 bytes:

                              current code page
          |..........................................................|

            code object   code object   code object       free
          |.............|.............|.............|++++++++++++++++|
          |----------------------------------------------------------|

     the free room at the end of the sequence of code objects is lost.

  2. Large code objects whose size fits in a sequence of adjacent Vicare
     pages.

              page        page        page        page        page
          |...........|...........|...........|...........|...........|

                          large code object                     free
          |---------------------------------------------------|+++++++|

     the free room at the end of the sequence of pages is lost.  Large
     code objects are *never* moved by the garbage collector.

Meta data in a code memory block
................................

The first words of a code memory block hold meta data:

  1. The first word contains the secondary tag needed to recognise a
     Scheme object as code object.

  2. The second word contains a non-negative fixnum representing the
     number of used bytes in the data area.

  3. The third word contains the reference to a Scheme vector used as
     relocation vector.

  4. The fourth word contains a non-negative fixnum representing the
     number of free variables in the contained code.  If such value is
     zero: the code is a thunk, otherwise it is a closure.

  5. The fifth word contains a code annotation; it is initialised to
     '#f'.

  6. The sixth word is currently unused; it is initialised to the fixnum
     zero.

the subsequent words in the memory block are the code object's data
area.


File: vicare-scheme.info,  Node: objects codes ops,  Next: objects codes reloc,  Prev: objects codes layout,  Up: objects codes

13.23.2 Operations on code objects
----------------------------------

 -- Preprocessor Symbol: code_primary_mask
     A bitmask that can be used to extract the primary tag of code
     objects from tagged pointers.

 -- Preprocessor Symbol: code_primary_tag
     The tag of 'ikptr_t' values used as references to code objects.
     The primary tag of code objects is equal to the vector tag.

 -- Preprocessor Symbol: code_tag
     The tag of 'ikptr_t' values used as first words in pointer memory
     blocks.

   We can determine if a 'ikptr_t' references a code object as follows:

     ikptr_t  s_obj = ...;

     if ((code_primary_tag == (code_primary_mask & s_obj)) && \
         (code_tag         == IK_REF(s_obj, off_code_tag)))
       is_code_object();
     else
       it_is_not();

 -- Preprocessor Symbol: disp_code_tag
 -- Preprocessor Symbol: disp_code_code_size
 -- Preprocessor Symbol: disp_code_reloc_vector
 -- Preprocessor Symbol: disp_code_freevars
 -- Preprocessor Symbol: disp_code_annotation
 -- Preprocessor Symbol: disp_code_unused
     Displacement of fields.  The number of bytes to add to an
     *untagged* pointer to code to get the pointer to the first byte in
     the word of the code's field.

 -- Preprocessor Symbol: off_code_tag
 -- Preprocessor Symbol: off_code_code_size
 -- Preprocessor Symbol: off_code_reloc_vector
 -- Preprocessor Symbol: off_code_freevars
 -- Preprocessor Symbol: off_code_annotation
 -- Preprocessor Symbol: off_code_unused
     An integer to add to a tagged 'ikptr_t' reference to retrieve the
     pointer to the first byte of the word in the code's field.

 -- Preprocessor Macro: int IK_IS_CODE (ikptr_t X)
     Evaluate to true if X is a reference to code object.

 -- Preprocessor Macro: ikptr_t IK_CODE_ENTRY_POINT (ikptr_t CODE)
     Given a tagged pointer to code object: evaluate to a pointer to the
     first octet in the data area.  This pointer is the entry point in
     the machine code.


File: vicare-scheme.info,  Node: objects codes reloc,  Next: objects codes gc,  Prev: objects codes ops,  Up: objects codes

13.23.3 The relocation vector
-----------------------------

The "relocation vector" is a Scheme vector referenced by the meta data
of a code object.  In this documentation we refer to the code object
associated to a relocation vector as the "subject code object".  The
relocation vector can be empty.  The relocation vector is divided into
records, each some words long:

        0     1     2     3     4     5     6     7
     |-----|-----|-----|-----|-----|-----|-----|-----| reloc vector
     |...........|.................|.................|
      1st record      2nd record        3rd record

the first word in each record contains a fixnum which must be
interpreted as bit field (this fixnum is never zero).  The layout of the
first machine word in a record is:

   * On 32-bit platforms:

               bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
          ... |----|----|----|----|----|----|----|----|
          ........................|.........|.........| 1st word
            number of bytes        record tag fixnum tag

   * On 64-bit platforms:

               bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
          ... |----|----|----|----|----|----|----|----|
          ...................|.........|..............| 1st word
            number of bytes   record tag   fixnum tag

The 2 least significant bits of the fixnum's data represent a type tag
for the record:

'#b00'
     Record referencing a vanilla Scheme object.

'#b01'
     Record referencing the address of a C function.

'#b10'
     Record referencing an offset in the memory block of a Scheme
     object.

'#b11'
     Record referencing an entry point in a code object.

the remaining most significant bits of the fixnum's data area represent
a number of bytes, a displacement in the data area of the subject code
object selecting a target word:

      meta data        machine code
     |---------|----------------+---+-------| code object
               |................|...|
                  displacement   target word

   The purpose of each record in the relocation vector is to provide
operands from which a value for the target word can be computed and
stored in the middle of machine code; this way the machine code can
easily use it.  When the subject code object is created: the values must
be computed and stored.  Every time the garbage collector moves the
subject code object: the values must be recomputed and updated.
Whenever the subject code object is serialised into a FASL file: the
relocation vector is serialised along with the code.

   To allow inspection and comprehension of the records, the function
'code-reloc-vector->sexp' transforms a relocation vector into a human
readable symbolic expression (*note code-reloc-vector->sexp: syslib
codes.).

* Menu:

* objects codes reloc vanilla:: Records of type: vanilla object.
* objects codes reloc foreign:: Records of type: foreign address.
* objects codes reloc offset::  Records of type: offset in object.
* objects codes reloc jump::    Records of type: jump to label-offset.


File: vicare-scheme.info,  Node: objects codes reloc vanilla,  Next: objects codes reloc foreign,  Up: objects codes reloc

13.23.3.1 Records of type: vanilla object
.........................................

These records are composed of 2 words: the second word contains a tagged
pointer to a Scheme object.  When these records are processed: the
tagged pointer is stored into the target word in the data area of the
subject code object.

        meta data         data area
       |.........|..........................|

     s_code   p_data
       v         v
       |---------|--------------|---|-------| code object
                 |..............|...|target word
           ------->displacement   ^
          |                       |
          |     ------------------
          |    |
       |----|----| vanilla object record
        1st  2nd

   Records of this type are used when the code object uses a generic
Scheme object.  Some notable examples:

   * The code object representing the implementation of the function:

          (define (doit)
            '(1 2 3))

     contains a reference to the list '(1 2 3)' in its relocation
     vector.

   * The code object representing the implementation of the function:

          (define (doit x)
            (display x))

     contains a reference to the storage location gensym of 'display' in
     its relocation vector.


File: vicare-scheme.info,  Node: objects codes reloc foreign,  Next: objects codes reloc offset,  Prev: objects codes reloc vanilla,  Up: objects codes reloc

13.23.3.2 Records of type: foreign address
..........................................

These records are composed of 2 words: the second word contains a tagged
pointer referencing a bytevector object holding the C string
representation of a foreign object name, in the format suitable to be
handed to 'dlsym()'.  When these records are processed: 'dlsym()' is
used to retrieve the address of the foreign object (which must be
present in the global namespace), then the address is stored directly in
the target word in the data area of the subject code object.

        meta data         data area
       |.........|..........................|

     s_code   p_data
       v         v
       |---------|--------------|---|-------| code object
                 |..............|...|target word
           ------->displacement   ^
          |                       |
          |     --- dlsym() ------
          |    |
          |    |
       |----|----| foreign object record
        1st  2nd

   Records of this type are used when the code performs a call to a C
function, *not* using the foreign-functions interface.  For example,
let's consider this code:

     (define (f x)
       (foreign-call "ikrt_glibc_csin" x))

the relocation vector references a bytevector containing the ASCIIZ
representation of 'ikrt_glibc_csin'.

   Examples of C functions used in this way are: the C functions
exported by the executable program 'vicare' to be called from Scheme;
the C functions exported by shared libraries when using extensions like
Vicare/SQLite and Vicare/cURL. The foreign-functions interface does
*not* make use of this mechanism.


File: vicare-scheme.info,  Node: objects codes reloc offset,  Next: objects codes reloc jump,  Prev: objects codes reloc foreign,  Up: objects codes reloc

13.23.3.3 Records of type: offset in object
...........................................

These records are composed of 3 words: the second word contains a fixnum
which, unpacked to 'iksword_t', represents a byte offset; the third word
contains the tagged pointer to a subordinate Scheme object.  When these
records are processed: the tagged pointer is added to the offset in
bytes and the result is stored in the target word in the data area of
the subject code object:

        meta data         data area
       |.........|..........................|

     s_code   p_data
       v         v
       |---------|--------------|---|-------| code object
                 |..............|...|target word
           ------->displacement   ^
          |                       |
          |       ----------------
          |      |
          |  off + obj
       |----|----|----| offset in object record
        1st  2nd  3rd

   Records of this type are used when the subject code object uses a
pointer to a word in the code block of the subordinate Scheme object:

           pointer ---
                      |
                      v
     |--------------|---|----------| subordinate Scheme object
     |..............|...|
       displacement  word

the pointer to the word is the sum between:

  1. The tagged pointer to the subordinate code object.

  2. A constant that untags the tagged pointer to the subordinate code
     object.

  3. A constant representing the displacement of the word in the memory
     block of the subordinate Scheme object.

the offset stored in the relocation vector is the sum between the latter
two constants.

Example: common routines
........................

Every Scheme function makes use of some common machine code routines: to
validate the number of arguments, to validate the number of returned
values, as implementation of 'call-with-values' and other operations.
Such routines are compiled into code objects.

   When the subject code object calls such routines, it does it by
jumping directly to the entry point in the machine code; for each
routine used by the subject code object, a relocation vector record is
added containing:

  1. A tagged pointer to the code object implementing the routine.

  2. A fixnum which, unpacked to 'iksword_t', represents the constant
     'off_code_tag'.

adding 'off_code_tag' to the tagged pointer yields the address of the
machine code entry point.


File: vicare-scheme.info,  Node: objects codes reloc jump,  Prev: objects codes reloc offset,  Up: objects codes reloc

13.23.3.4 Records of type: jump to label-offset
...............................................

     *NOTE* This record type is currently not used.  Is it really
     needed?  Can its use allow operations not possible with records of
     type "offset in object"?

   These records are composed of 3 words: the second word contains a
fixnum which, unpacked to 'iksword_t', represents a byte offset; the
third word contains the tagged pointer to a subordinate Scheme code
object.  When these records are processed: a 32-bit byte offset is
computed and stored in the target word in the data area of the subject
code object:

        meta data         data area
       |.........|..........................|

     s_code   p_data
       v         v
       |---------|--------------|---|-------| code object
                 |..............|...|target word
           ------->displacement   ^
          |                       |
          |    -----+-------------
          |   |     |
          |  off   obj
       |----|----|----| jump label offset record
        1st  2nd  3rd

   Let's imagine the following scenario in Assembly language, in which a
'jmp' instruction is used to jump directly to another entry point by
specifying the target address as an immediate value:

        ...
        jmp L_target
        ...

        ...
     L_target:
        ...

such operation can be implemented also as:

        ...
        jmp-pc-relative (L_target - L_after_jmp)
     L_after_jmp:
        ...

        ...
     L_target:
        ...

in which the jump is to the address at a computable offset from the
'jmp-pc-relative' instruction; the target address is computed at
run-time, by the CPU executing the 'jmp-pc-relative' instruction, by
adding the constant offset 'L_target - L_after_jmp' to the value of the
Instruction Pointer Register (or Program Counter Register).

   The "jump to label-offset" records are used to implement this
scenario, in which: the 'jmp-pc-relative' instruction is in the subject
code object; the target label is in the subordinate code object.  The
third word in the record contains the tagged pointer to the subordinate
Scheme code object.  The second word in the record contains a fixnum
which, unpacked to 'iksword_t', represents the constant to add to a
tagged pointer to the subordinate code object to obtain the offset of
the target label:

      meta data        machine code
     |---------|--------------|---|-----| subject code object
                                  ^ L_after_jmp
               |..............|...|
                 displacement  32-bit


      meta data     machine code
     |---------|------------|-----------| subordinate code object
                            ^ L_target
     |......................|
      offset - code_primary_tag

   At present, the code handles only 32-bit offsets.


File: vicare-scheme.info,  Node: objects codes gc,  Prev: objects codes reloc,  Up: objects codes

13.23.4 Memory and garbage collection
-------------------------------------

Code objects are *not* allocated on the heap like other common objects
(pairs, vectors, ...); rather they are allocated in specially memory
mapped regions which receive execution protection.

   Whenever the garbage collector encounters a reference to a code
object: it moves the code object itself into a new location to reduce
fragmentation.


File: vicare-scheme.info,  Node: objects closures,  Next: objects continuations,  Prev: objects codes,  Up: objects

13.24 Closure objects
=====================

Closure objects are actual procedures: closure objects are the ones for
which the 'procedure?' predicate returns '#t'.  A closure object is a
fixed length memory block referenced by machine words tagged as
closures; each closure object is associated to either a code object that
implements the procedure or a routine directly coded in assembly.  The
memory layout of a closure object is as follows:

     |------------------------|-------------| reference to closure
           heap pointer         closure tag

                            0   1   2   3   4   5
     |--------------------|---|---|---|---|---|---| memory block
       raw memory pointer    one slot for every
       to binary code        free variable

the first word in the memory block holds a raw memory pointer
referencing the first byte in the code object implementing the closure;
the subsequent words (if any) are slots associated to the free variables
referenced by the closure's code.

Inspecting a closure's free variables
.....................................

We can take a look at the free variables referenced by a closure with
the facilities of the library '(vicare system $codes)'.  In a normal
application: we must *not* mess with the internals of closure and code
objects.

   We start by noticing that in the following example: the function 'f'
has no "true" free variables, because it accesses only global variables:

     #!r6rs
     (import (rnrs)
       (vicare system $codes))
     (define a 123)
     (define (f)
       a)
     ($code-freevars ($closure-code f))      => 0

   In the following example: the function 'f' is the only one
referencing the free variable 'a', so such variable is stored directly
in the closure's slot:

     #!r6rs
     (import (rnrs)
       (vicare system $codes))
     (define f
       (let ((a 123))
         (lambda () a)))
     ($code-freevars ($closure-code f))      => 1
     ($cpref f 0)                            => 123

when there are two such variables:

     #!r6rs
     (import (vicare)
       (vicare system $codes))

     (define f
       (let ((a 123)
             (b 456))
         (lambda ()
           (list a b))))
     ($code-freevars ($closure-code f))      => 2
     ($cpref f 0)                            => 456
     ($cpref f 1)                            => 123

   When more than one closure references the same free variable, the
storage of the variable is inside a Scheme vector and such vector is
referenced by the slots of the closures:

     #!r6rs
     (import (rnrs)
       (vicare system $codes))
     (define f #f)
     (define g #f)
     (let ((a 123))
       (set! f (lambda () a))
       (set! g (lambda (x)
                 (set! a x)
                 a)))
     ($code-freevars ($closure-code f))      => 1
     ($cpref f 0)                            => #(123)
     ($code-freevars ($closure-code g))      => 1
     ($cpref g 0)                            => #(123)

Basic operations
................

Closure objects are allocated on the heap; to perform the allocation and
initialisation for a closure object without free variables we do:

     ikptr_t   p_closure;
     ikptr_t   s_closure;
     ikptr_t   s_code = ...;

     p_closure = ik_safe_alloc(pcb, IK_ALIGN(disp_closure_data));
     s_closure = p_closure | closure_tag;
     IK_REF(s_closure, off_closure_code) = s_code + off_code_data;

'ik_safe_alloc()' returns an 'ikptr_t' value representing the aligned
pointer, having the 3 least significant bits set to zero; we add to it
the closure tag (an integer value fitting in 3 bits) which allows to
recognise closures among all the other built in objects.

 -- Preprocessor Symbol: closure_tag
     An integer used to tag 'ikptr_t' references to closure memory
     blocks.

 -- Preprocessor Symbol: closure_mask
     An integer representing the bitmask used to extract (with a bitwise
     logic AND) the tag from 'ikptr_t' references to closure objects.

 -- Preprocessor Symbol: disp_closure_code
     Displacement of code pointer.  The number of bytes to add to an
     *untagged* pointer to closure to get a pointer to the word in the
     memory block holding the binary code entry point.

 -- Preprocessor Symbol: disp_closure_data
     Displacement of free variables.  The number of bytes to add to an
     *untagged* pointer to closure to get a pointer to the first word in
     the data area of the memory block.

 -- Preprocessor Symbol: off_closure_code
     An integer to add to a tagged 'ikptr_t' closure reference to get a
     pointer to the word in the memory block holding the binary code
     entry point.

 -- Preprocessor Symbol: off_closure_data
     An integer to add to a tagged 'ikptr_t' closure reference to get a
     pointer to the first word in the data area of the memory block.

Convenience preprocessor macros
...............................

 -- Preprocessor Macro: int IK_IS_CLOSURE (ikptr_t X)
     Evaluate to true if X is a reference to closure object.

 -- Preprocessor Macro: ikptr_t IK_CLOSURE_ENTRY_POINT (X)
     Given a reference to closure object: return the address of the
     binary code entry point.

 -- Preprocessor Macro: ikptr_t IK_CLOSURE_CODE_OBJECT (X)
     Given a reference to closure object: return a reference to the
     associated code object.  *Only works for closures associated to
     code objects.*

 -- Preprocessor Macro: int IK_CLOSURE_NUMBER_OF_FREE_VARS (X)
     Given a reference to closure object: return the number of free
     variables.

 -- Preprocessor Macro: ikptr_t IK_CLOSURE_FREE_VAR (X, IDX)
     Given a reference to closure object: return a reference to value of
     the free variable at index IDX in the data area.  IDX must be less
     than the number of free variables in this closure object.


File: vicare-scheme.info,  Node: objects continuations,  Next: objects misc,  Prev: objects closures,  Up: objects

13.25 Continuation objects
==========================

There are two kinds of continuation objects:

*Scheme continuations*
     Represent a Scheme continuation as defined by R6RS, a portion of
     Scheme stack whose frames are freezed.  Scheme continuations are
     expliticly created by 'call/cc', but also used to represent a
     Scheme stack segment that has run out of space making the frames
     overflow into another stack segment.

*System continuations*
     Represent a C language continuation, a portion of the C language
     stack.  They are used by the FFI to save the C execution context
     just before calling back to Scheme from C code, *note Foreign
     functions interface: ffi.

* Menu:

* objects continuations intro::   Introduction to continuations.
* objects continuations scheme::  Scheme continuation objects.
* objects continuations system::  System continuation objects.


File: vicare-scheme.info,  Node: objects continuations intro,  Next: objects continuations scheme,  Up: objects continuations

13.25.1 Introduction to continuations
-------------------------------------

Continuation objects are memory blocks referenced by machine words
tagged as vectors, whose first word is tagged as continuation:

     |----------------|----------| reference to continuation
       heap pointer    vector tag

     |----------------|----------| first word of continuation
      all set to zero  continuation tag

the layout of a continuation memory block is:

     |-----|-----|-----|-----|
       tag   top  size  next

   Continuation objects are collected in linked lists handled as stacks;
all such linked lists share a common tail.  The meaning of the fields
is:

'tag'
     A machine word containing only the secondary tag for continuation
     objects and all the other bits set to zero.

'top'
     A machine word representing the memory address of the machine word
     at the top (lowest address) of the stack portion referenced by the
     continuation.

'size'
     The size of the stack portion expressed in number of bytes.

'next'
     A machine word being 'NULL' or a reference (tagged pointer) to the
     next continuation object in the linked list.

Basic operations
................

To test if a value of type 'ikptr_t' is a reference to a continuation
object, we should do:

     ikptr_t   X;

     if (continuation_primary_tag == (continuation_primary_mask & X))
       {
         if (continuation_tag == IK_REF(X, 0))
           it_is_a_scheme_continuation();
         else if (system_continuation_tag == IK_REF(X, 0))
           it_is_a_system_continuation();
         it_is_not();
       }
     else
       it_is_not();

   A Scheme continuation object is usually allocated as follows:

     ikpcb_t *  pcb = ...;
     ikptr_t    s_kont;
     ikcont *   kont;

     kont   = (ikcont*)ik_unsafe_alloc(pcb,
                          IK_ALIGN(continuation_size));
     s_rest = (ikptr_t)((long)kont) | continuation_primary_tag;

     IK_REF(s_kont, off_continuation_tag)  = continuation_tag;
     IK_REF(s_kont, off_continuation_top)  = pcb->frame_pointer;
     IK_REF(s_kont, off_continuation_size) = \
        pcb->frame_base - pcb->frame_pointer - wordsize;
     IK_REF(s_kont, off_continuation_next) = pcb->next_k;
     IK_SIGNAL_DIRT(pcb, s_kont);
     pcb->next_k = s_kont;

 -- Preprocessor Symbol: continuation_primary_tag
     The tag of an 'ikptr_t' machine words referencing the memory block
     of a Scheme or system continuation object.

 -- Preprocessor Symbol: continuation_primary_mask
     A bit pattern used to isolate the tag bits in an 'ikptr_t' machine
     words referencing the memory block of a Scheme or system
     continuation object.

 -- Preprocessor Symbol: continuation_tag
 -- Preprocessor Symbol: system_continuation_tag
     Integer values used to tag and recognise the first word in
     continuation memory blocks.

 -- Preprocessor Symbol: continuation_size
 -- Preprocessor Symbol: system_continuation_size
     The number of bytes needed to hold a continuation memory block.

 -- Preprocessor Symbol: disp_continuation_tag
 -- Preprocessor Symbol: disp_continuation_top
 -- Preprocessor Symbol: disp_continuation_size
 -- Preprocessor Symbol: disp_continuation_next
     Scheme continuation field displacements.  The number of bytes to
     add to an untagged pointer to Scheme continuation to get the
     pointer to the first byte in the word holding the specified field.

 -- Preprocessor Symbol: disp_system_continuation_tag
 -- Preprocessor Symbol: disp_system_continuation_top
 -- Preprocessor Symbol: disp_system_continuation_size
 -- Preprocessor Symbol: disp_system_continuation_next
     System continuation field displacements.  The number of bytes to
     add to an untagged pointer to system continuation to get the
     pointer to the first byte in the word holding the specified field.

 -- Preprocessor Symbol: off_continuation_tag
 -- Preprocessor Symbol: off_continuation_top
 -- Preprocessor Symbol: off_continuation_size
 -- Preprocessor Symbol: off_continuation_next
     Scheme continuation field offsets.  The number of bytes to add to a
     tagged pointer to Scheme continuation to get the pointer to the
     first byte in the word holding the specified field.

 -- Preprocessor Symbol: off_system_continuation_tag
 -- Preprocessor Symbol: off_system_continuation_top
 -- Preprocessor Symbol: off_system_continuation_size
 -- Preprocessor Symbol: off_system_continuation_next
     System continuation field offsets.  The number of bytes to add to a
     tagged pointer to system continuation to get the pointer to the
     first byte in the word holding the specified field.

 -- Preprocessor Macro: int IK_IS_CONTINUATION (X)
     Evaluate to true if X is a reference to Scheme continuation object.

 -- Preprocessor Macro: int IK_IS_SYSTEM_CONTINUATION (X)
     Evaluate to true if X is a reference to system continuation object.

 -- Preprocessor Macro: int IK_IS_ANY_CONTINUATION (X)
     Evaluate to true if X is a reference to Scheme or system
     continuation object.


File: vicare-scheme.info,  Node: objects continuations scheme,  Next: objects continuations system,  Prev: objects continuations intro,  Up: objects continuations

13.25.2 Scheme continuation objects
-----------------------------------

To understand the contents of a continuation object, we have to recall
how the Scheme stack is used, *note Continuations implementation:
machinery continuations.  We also need to remember that stack segments
are consumed starting from the highest memory addresses, growing towards
the lowest memory addresses.

   Whenever a Scheme stack segment is allocated, the fields of the PCB
structure are initialised such that: 'stack_base' references the lowest
machine word in the segment, 'frame_base' references the highest word
right after the end of the segment, 'frame_pointer' references the
highest word of the segment which is initialised to the memory address
of the assembly routine 'ik_underflow_handler'; *note objects
continuations scheme: fig:kont_empty_stack.

           high memory
     |                      |
     |----------------------|
     |                      | <-- pcb->frame_base
     |----------------------|                         --
     | ik_underflow_handler | <-- pcb->frame_pointer  .
     |----------------------|                         .
               ...                                    .
     |----------------------|                         . stack
     |                      | <-- pcb->frame_redline  . segment
     |----------------------|                         .
               ...                                    .
     |----------------------|                         .
     |                      | <-- pcb->stack_base     .
     |----------------------|                         --
     |                      |
           low memory

Figure 13.1: Empty Scheme stack segment as it appears right after
allocation and initialisation.

   Whenever Scheme functions are called, and they perform nested calls:
stack frames are created, starting from the highest machine words; let's
say there are 2 of them, *note objects continuations scheme:
fig:kont_two_frames.  The CPU's Frame Pointer Register (FPR) references
the return address in the topmost stack frame (while executing Scheme
code FPR gets out of sync with 'pcb->frame_pointer').

           high memory
     |                        |
     |------------------------|
     |                        | <-- pcb->frame_base
     |------------------------|                       --
     |  ik_underflow_handler  |                       .
     |------------------------|        --             .
     |   local value frame 1  |        .              .
     |------------------------|        .              .
     |   local value frame 1  |        . framesize 1  .
     |------------------------|        .              .
     | return address frame 1 |        .              .
     |------------------------|        --             .
     |   local value frame 0  |        .              .
     |------------------------|        .              . stack
     |   local value frame 0  |        . framesize 0  . segment
     |------------------------|        .              .
     | return address frame 0 | <- FPR .              .
     |------------------------|        --             .
     |     call argument      |                       .
     |------------------------|                       .
     |     call argument      |                       .
     |------------------------|                       .
                ...                                   .
     |------------------------|                       .
     |                        | <-- pcb->stack_base   .
     |------------------------|                        --
     |                        |
           low memory

Figure 13.2: 2 frames on the Scheme stack.

   If a continuation object is created now: it "freezes" (or "seals")
all the stack frames in the stack segment, so that they will never be
mutated again; in practice the portion of the Scheme stack referenced by
the continuation is no more part of the Scheme stack itself, rather the
stack segment is resized to reference only the portion of memory still
unused, *note objects continuations scheme: fig:kont_freezed_frames.

           high memory
     |                        |
     |------------------------|
     |  ik_underflow_handler  |
     |------------------------|                       --
     |   local value frame 1  |                       .
     |------------------------|                       .
     |   local value frame 1  |                       .
     |------------------------|                       .
     | return address frame 1 |                       . continuation
     |------------------------|                       . size
     |   local value frame 0  |                       .
     |------------------------|                       .
     |   local value frame 0  |                       .
     |------------------------|                       .
     | return address frame 0 | <- pcb->frame_base    .
     |------------------------|                       --
     |  ik_underflow_handler  | <- FPR                .
     |------------------------|                       .
     |     call argument      |                       .
     |------------------------|                       . stack
     |     call argument      |                       . segment
     |------------------------|                       .
                ...                                   .
     |------------------------|                       .
     |                        | <-- pcb->stack_base   .
     |------------------------|                       --
     |                        |
           low memory

Figure 13.3: freezed stack frames and resized stack segment.

   The field 'top' of the continuation object is an untagged memory
pointer referencing the return address in the topmost freezed frame
('frame 0' in the pictures); such machine word is the address of the
code execution return point of this continuation, in other words: the
address of the next assembly instruction to execute when returning to
this continuation.

   The field 'size' of the continuation object is the number of bytes in
all the freezed stack frames this continuation references: the sum
between the all frame sizes.

   Notice that the single continuation object referencing all the
freezed frames is equivalent to two continuation objects each
referencing a single freezed frame, provided that the continuation
object of 'frame 0' has the continuation object of 'frame 1' as 'next',
*note objects continuations scheme: fig:kont_split_frames.

           high memory
     |                        |
     |------------------------|
     |  ik_underflow_handler  |
     |------------------------|           --
     |   local value frame 1  |           .
     |------------------------|           . continuation
     |   local value frame 1  |           . size 1
     |------------------------|           .
     | return address frame 1 | <- top 1  .
     |------------------------|           --
     |   local value frame 0  |           .
     |------------------------|           . continuation
     |   local value frame 0  |           . size 0
     |------------------------|           .
     | return address frame 0 | <- top 0  .
     |------------------------|           --
     |                        |
           low memory

          next_k
     |...|------|...| PCB structure
            |
            v
           tag  top  size next
          |----|----|----|----| continuation object 0
                           |
                    -------
                   v
                  tag  top  size next
                 |----|----|----|----| continuation object 1
                                 NULL

Figure 13.4: 2 chained continuation objects equivalent to the single
continuation object.


File: vicare-scheme.info,  Node: objects continuations system,  Prev: objects continuations scheme,  Up: objects continuations

13.25.3 System continuation objects
-----------------------------------

Vicare is written in both the C language and the Scheme language; the
runtime system performing heap and stack memory allocation and garbage
collection is written in the C language.  Vicare starts with C code and
enters Scheme code when running a Scheme program:

     C code --> Scheme code

when the last Scheme function returns: Vicare knowns that it has to
return to C code because the Scheme stack is initialised with a return
address to a special routine (the underflow handler) that does it.

   It is clear that, while running a Scheme program, every now and then
Vicare must switch between portions of code written in C and portions of
code written in Scheme; such portions make different use of the CPU.

   Whenever Vicare leaves C code execution to enter Scheme code
execution: it saves the current state of the C stack; in practice it
saves the pointer to the top of the stack in the PCB structure.
Whenever Vicare leaves Scheme code execution to return to C code
execution: it saves the current state of the Scheme stack in the PCB and
restores the state of the C stack from the PCB.

   While running Scheme code we can call a C function through the
primitive, low-level operation 'foreign-call' (when using the FFI
callout mechanism we are still using 'foreign-call'):

     C code --> Scheme code (--> foreign-call) --> C code

when leaving Scheme code: the status of the Scheme stack is saved in the
PCB; the C stack creates no problems: we just retrieve the top of the C
stack from the PCB and use the stack region below it, *note objects
continuations system: fig:kont_cstack_reenter.


         --------- stack growing direction ------->

      C stack   C stack  C stack   C stack    C stack
      frame     frame    frame     frame      frame
     |---------|--------|--------|----------|----------|
                                 ^                     ^
                            saved top            current top

     |...........................|.....................|
        C stack before entering     C stack after
        Scheme code                 reentering C code

Figure 13.5: The C stack portions used before entering Scheme code and
after reentering C code with 'foreign-call'.

   Now let's say that, after entering nested C code, we enter nested
Scheme code:

     C code 1 --> Scheme code 1 --> C code 2 --> Scheme code 2

at the transition from 'C code 2' to 'Scheme code 2' we must save the
state of the C stack, but the dedicated fields in the PCB are already
busy with the status of 'C code 1'.  Vicare solves this problem with
continuation objects; at the transition from 'C code 2' to 'Scheme code
2':

  1. A Scheme continuation object is created to hold the status of
     'Scheme code 1' previously saved in the PCB.

  2. A system continuation object is created to hold the status of 'C
     code 1' previously saved in the PCB.

  3. The status of 'C code 2' is saved in the PCB.

  4. Execution of 'Scheme code 2' is entered in a clean Scheme stack
     segment.

whenever 'Scheme code 2' goes back to 'C code 2':

  1. The Scheme stack segment used by 'Scheme code 2' is abandoned.

  2. The status of 'C code 2' is restored from the system continuation
     object.

  3. The execution enters 'C code 2'.

  4. The status of 'Scheme code 1' is restored from the Scheme
     continuation object.

  5. The execution enters 'Scheme code 1'.

   In a system continuation object:

   * The field 'top' is an untagged memory pointer referencing the C
     language stack last saved upon exiting C code and entering Scheme
     code; it is the content of the field 'pcb->system_stack' at the
     time this system continuation object was created.

   * The field 'size' of a system continuation object is unused.

   Upon creation, both Scheme and system continuation objects are
prepended to the linked list referenced by the field 'next_k' of the PCB
structure.


File: vicare-scheme.info,  Node: objects misc,  Next: objects callbacks,  Prev: objects continuations,  Up: objects

13.26 Miscellaneous functions and preprocessor macros
=====================================================

* Menu:

* objects misc mblock::         Macros handling 'memory-block'.
* objects misc voidp::          Macros extracting 'void *'.
* objects misc charp::          Macros extracting 'char *'.
* objects misc cbuffers::       Generalised C buffers.
* objects misc func::           Miscellaneous functions.


File: vicare-scheme.info,  Node: objects misc mblock,  Next: objects misc voidp,  Up: objects misc

13.26.1 Macros handling 'memory-block'
--------------------------------------

 -- Preprocessor Macro: ikptr_t IK_MBLOCK_POINTER (ikptr_t OBJ)
     Given an instance of 'memory-block', return a pointer object being
     the value of its 'pointer' field.

 -- Preprocessor Macro: ikptr_t IK_MBLOCK_SIZE (ikptr_t OBJ)
     Given an instance of 'memory-block', return an exact integer being
     the value of its 'size' field.  Notice that the returned value can
     be either a fixnum or a bignum.

 -- Preprocessor Macro: size_t IK_MBLOCK_SIZE_T (ikptr_t OBJ)
     Given an instance of 'memory-block', return the value of the 'size'
     field as 'size_t'.

 -- Preprocessor Macro: void * IK_MBLOCK_DATA_VOIDP (ikptr_t OBJ)
     Given an instance of 'memory-block', return a 'void *' pointer
     referencing the first byte of data.

 -- Preprocessor Macro: char * IK_MBLOCK_DATA_CHARP (ikptr_t OBJ)
     Given an instance of 'memory-block', return a 'charp *' pointer
     referencing the first byte of data.


File: vicare-scheme.info,  Node: objects misc voidp,  Next: objects misc charp,  Prev: objects misc mblock,  Up: objects misc

13.26.2 Macros extracting 'void *'
----------------------------------

 -- Preprocessor Macro: void * IK_POINTER_FROM_POINTER_OR_FALSE (ikptr_t
          OBJ)
 -- Preprocessor Macro: void * IK_VOIDP_FROM_POINTER_OR_FALSE (ikptr_t
          OBJ)
     Given '#f' or a pointer object return a 'void *' pointer
     referencing the data; when OBJ is '#f': the returned value is
     'NULL'.

 -- Preprocessor Macro: ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_FALSE
          (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_FALSE
          (ikptr_t OBJ)
     Given '#f' or a bytevector object return a 'void *' pointer
     referencing the data; when OBJ is '#f': the returned value is
     'NULL'.

 -- Preprocessor Macro: ikptr_t IK_POINTER_FROM_MBLOCK_OR_FALSE (ikptr_t
          OBJ)
 -- Preprocessor Macro: ikptr_t IK_VOIDP_FROM_MBLOCK_OR_FALSE (ikptr_t
          OBJ)
     Given '#f' or a 'memory-block' object return a 'void *' pointer
     referencing the data; when OBJ is '#f': the returned value is
     'NULL'.

 -- Preprocessor Macro: ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_POINTER
          (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER
          (ikptr_t OBJ)
     Given a bytevector object or a pointer object return a 'void *'
     pointer referencing the data.

 -- Preprocessor Macro: ikptr_t
          IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t
          IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t OBJ)
     Given '#f' or a bytevector object or a pointer object return a
     'void *' pointer referencing the data; when OBJ is '#f': the
     returned value is 'NULL'.

 -- Preprocessor Macro: ikptr_t IK_POINTER_FROM_POINTER_OR_MBLOCK
          (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t IK_VOIDP_FROM_POINTER_OR_MBLOCK (ikptr_t
          OBJ)
     Given a pointer object or 'memory-block' object return a 'void *'
     pointer referencing the data.

 -- Preprocessor Macro: ikptr_t
          IK_POINTER_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t IK_VOIDP_FROM_POINTER_OR_MBLOCK_OR_FALSE
          (ikptr_t OBJ)
     Given '#f' or a pointer object or a 'memory-block' object return a
     'void *' pointer referencing the data; when OBJ is '#f': the
     returned value is 'NULL'.

 -- Preprocessor Macro: ikptr_t
          IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t
          IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t OBJ)
     Given a bytevector object or a pointer object or a 'memory-block'
     object return a 'void *' pointer referencing the data.

 -- Preprocessor Macro: ikptr_t
          IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE
          (ikptr_t OBJ)
 -- Preprocessor Macro: ikptr_t
          IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE
          (ikptr_t OBJ)
     Given '#f' or a bytevector object or a pointer object or a
     'memory-block' object return a 'void *' pointer referencing the
     data; when OBJ is '#f': the returned value is 'NULL'.


File: vicare-scheme.info,  Node: objects misc charp,  Next: objects misc cbuffers,  Prev: objects misc voidp,  Up: objects misc

13.26.3 Macros extracting 'char *'
----------------------------------

 -- Preprocessor Macro: char * IK_POINTER_FROM_POINTER_OR_FALSE (ikptr_t
          OBJ)
 -- Preprocessor Macro: char * IK_CHARP_FROM_POINTER_OR_FALSE (ikptr_t
          OBJ)
     Given '#f' or a pointer object return a 'char *' pointer
     referencing the data; when OBJ is '#f': the returned value is
     'NULL'.

 -- Preprocessor Macro: void * IK_POINTER_FROM_BYTEVECTOR_OR_FALSE
          (ikptr_t OBJ)
 -- Preprocessor Macro: char * IK_CHARP_FROM_BYTEVECTOR_OR_FALSE
          (ikptr_t OBJ)
     Given '#f' or a bytevector object return a 'char *' pointer
     referencing the data; when OBJ is '#f': the returned value is
     'NULL'.

 -- Preprocessor Macro: void * IK_POINTER_FROM_MBLOCK_OR_FALSE (ikptr_t
          OBJ)
 -- Preprocessor Macro: charp * IK_CHARP_FROM_MBLOCK_OR_FALSE (ikptr_t
          OBJ)
     Given '#f' or a 'memory-block' object return a 'char *' pointer
     referencing the data; when OBJ is '#f': the returned value is
     'NULL'.

 -- Preprocessor Macro: void * IK_POINTER_FROM_BYTEVECTOR_OR_POINTER
          (ikptr_t OBJ)
 -- Preprocessor Macro: char * IK_CHARP_FROM_BYTEVECTOR_OR_POINTER
          (ikptr_t OBJ)
     Given a bytevector object or a pointer object return a 'char *'
     pointer referencing the data.

 -- Preprocessor Macro: void *
          IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t OBJ)
 -- Preprocessor Macro: char *
          IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t OBJ)
     Given '#f' or a bytevector object or a pointer object return a
     'char *' pointer referencing the data; when OBJ is '#f': the
     returned value is 'NULL'.

 -- Preprocessor Macro: void * IK_POINTER_FROM_POINTER_OR_MBLOCK
          (ikptr_t OBJ)
 -- Preprocessor Macro: char * IK_CHARP_FROM_POINTER_OR_MBLOCK (ikptr_t
          OBJ)
     Given a pointer object or 'memory-block' object return a 'void *'
     pointer referencing the data.

 -- Preprocessor Macro: void *
          IK_POINTER_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t OBJ)
 -- Preprocessor Macro: char * IK_CHARP_FROM_POINTER_OR_MBLOCK_OR_FALSE
          (ikptr_t OBJ)
     Given '#f' or a pointer object or a 'memory-block' object return a
     'char *' pointer referencing the data; when OBJ is '#f': the
     returned value is 'NULL'.

 -- Preprocessor Macro: void *
          IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t OBJ)
 -- Preprocessor Macro: char *
          IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t OBJ)
     Given a bytevector object or a pointer object or a 'memory-block'
     object return a 'char *' pointer referencing the data.

 -- Preprocessor Macro: void *
          IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE
          (ikptr_t OBJ)
 -- Preprocessor Macro: char *
          IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE
          (ikptr_t OBJ)
     Given '#f' or a bytevector object or a pointer object or a
     'memory-block' object return a 'char *' pointer referencing the
     data; when OBJ is '#f': the returned value is 'NULL'.


File: vicare-scheme.info,  Node: objects misc cbuffers,  Next: objects misc func,  Prev: objects misc charp,  Up: objects misc

13.26.4 Generalised C buffers
-----------------------------

When interfacing a C language foreign library with Vicare, it is often
needed to convert Scheme objects to raw memory blocks, possibly
containing ASCIIZ strings.  Generalised C buffers are meant to be used
in interfaces to foreign C language libraries, when a pointer to raw
data is required as argument.  *note Introduction to generalised C
buffers: (vicare-libs)cbuffers buffers. for details.

   Notice that at the C language level only general C buffers exist:
Scheme strings should be converted to bytevectors at the Scheme level.

 -- Function: size_t ik_generalised_c_buffer_len (ikptr_t BUFFER,
          ikptr_t BUFFER_LEN)
     Return the number of bytes in a generalised C buffer object.

     BUFFER must be a bytevector, pointer object or 'memory-block'
     struct instance.

     When BUFFER is a pointer object: BUFFER_LEN must be an exact
     integer (in the range of the C language type 'size_t') representing
     the number of bytes available in the referenced memory block.
     Otherwise BUFFER_LEN is ignored.

 -- Preprocessor Macro: void * IK_GENERALISED_C_BUFFER (ikptr_t OBJ)
 -- Preprocessor Macro: void * IK_GENERALISED_C_BUFFER_OR_FALSE (ikptr_t
          OBJ)
     Given a bytevector object or a pointer object or a 'memory-block'
     object return a 'void *' pointer referencing the data.  The second
     macro accepts also '#f' as value and returns 'NULL'.

 -- Preprocessor Macro: void * IK_GENERALISED_C_STICKY_BUFFER (ikptr_t
          OBJ)
 -- Preprocessor Macro: void * IK_GENERALISED_C_STICKY_BUFFER_OR_FALSE
          (ikptr_t OBJ)
     Given a pointer object or a 'memory-block' object return a 'void *'
     pointer referencing the data.  The second macro accepts also '#f'
     as value and returns 'NULL'.

 -- Preprocessor Macro: char * IK_GENERALISED_C_STRING (ikptr_t OBJ)
 -- Preprocessor Macro: char * IK_GENERALISED_C_STRING_OR_FALSE (ikptr_t
          OBJ)
     Given a bytevector object or a pointer object or a 'memory-block'
     object return a 'char *' pointer referencing the data.  The second
     macro accepts also '#f' as value and returns 'NULL'.


File: vicare-scheme.info,  Node: objects misc func,  Prev: objects misc cbuffers,  Up: objects misc

13.26.5 Miscellaneous functions
-------------------------------

 -- Function: ikptr_t ikrt_general_copy (ikptr_t DST, ikptr_t DST_START,
          ikptr_t SRC, ikptr_t SRC_START, ikptr_t COUNT, ikpcb_t PCB)
     Copy COUNT items from SRC starting at offset SRC_START, to DST
     starting at offset DST_START; SRC_START, DST_START and COUNT must
     be non-negative fixnums.  Return unspecified values.

     Both DST and SRC can be one among: a bytevector, a pointer, a
     string.  For bytevectors and pointers: bytes are moved and
     SRC_START, DST_START and COUNT are in byte units.  For strings:
     32-bit values representing Unicode code points are moved and
     SRC_START, DST_START and COUNT are in character units.


File: vicare-scheme.info,  Node: objects callbacks,  Prev: objects misc,  Up: objects

13.27 Notes on calling Scheme code from C
=========================================

While writing C language code interfacing with Scheme, if we call a C
language function which calls back a Scheme function we have to save and
restore the current system continuation:

     ikpcb_t * pcb = the_pcb;

     ik_enter_c_function(pcb);
     {
       /* place here C code that calls Scheme code */
     }
     ik_leave_c_function(pcb);

else, upon returning from the Scheme code, the execution flow will go to
the wrong continuation and undefined behaviour ensues.

 -- Function: void ik_enter_c_function (ikpcb_t * PCB)
     Save the current Scheme continuation followed by the current system
     continuation.  A call to this function must be matched by a call to
     'ik_leave_c_function()'.

 -- Function: void ik_leave_c_function (ikpcb_t * PCB)
     Restore the previously saved Scheme continuation.  A call to this
     function must be matched by a call to 'ik_enter_c_function()'.

   Notice that when Scheme calls C then C calls Scheme: garbage
collections can happen in the nested Scheme code, so the C code cannot
rely on the Scheme values to keep their location.  Also, nested C code
invocations can happen, so the C code calling out to Scheme *cannot* use
the 'pcb->root' fields to preserve Scheme values.


File: vicare-scheme.info,  Node: debug int,  Next: expander,  Prev: objects,  Up: Top

14 Internals: debug mode
************************

* Menu:

* debug int intro::             Introduction to debug mode.


File: vicare-scheme.info,  Node: debug int intro,  Up: debug int

14.1 Introduction to debug mode
===============================

Debug mode is driven with the following options:

'-d'
'--debug'
     Turn on debugging mode.  The parameter 'generate-debug-calls' is
     set to true.

'-nd'
'--no-debug'
     Turn off debugging mode.  The parameter 'generate-debug-calls' is
     set to false.

   The implementation is mostly in 'ikarus.debugger.sls' and
'ikarus.compiler.sls'.

 -- Parameter: generate-debug-calls
     Set to true when debug mode is turned on.  Defined in
     'ikarus.compiler.sls', configured in 'ikarus.main.sls'.

 -- Function: guarded-start PROC
     Evaluate the procedure PROC under the debugging infrastructure.  It
     is used in the '(ikarus main)' library ('ikarus.main.sls') to start
     the execution of a program and all the other execution modes.

     PROC is evaluated under the installation of an exception handler
     displaying the stack trace and offering the continuation
     alternatives.


File: vicare-scheme.info,  Node: expander,  Next: machinery,  Prev: debug int,  Up: Top

15 Expander internals
*********************

Vicare's expander is a development of the expander library 'psyntax'
written by Abdulaziz Ghuloum and Kent Dybvig and released to the public
under a very liberal license (*note references expander:: for the
bibliography on the expansion process).

   The library '(vicare expander)' exports bindings that allow
inspection of the expander operations.  To avoid collisions between
syntactic binding names, it is suggested to import it with prefix
'xp::':

     (import (prefix (vicare expander) xp::))

* Menu:

* expander intro::              Introduction to the expansion process.
* expander options::            Initialisation and general configuration.
* expander lexenv::             The lexical environment.
* expander utils::              Miscellaneous utilities.
* expander clauses::            Syntax clauses helpers.
* expander system-labels::      Retrieving syntactic binding labels.
* expander system-identifiers:: Retrieving syntactic binding identifiers.
* expander examples::           Expansion and expander inspection
                                examples.
* expander specs::              Object-type specifications.


File: vicare-scheme.info,  Node: expander intro,  Next: expander options,  Up: expander

15.1 Introduction to the expansion process
==========================================

First some notes on "languages" in Vicare's jargon:

   * The "expanded language" is a low level Scheme-like language which
     is the result of the expansion process: expanding a Scheme library
     or program means to transform the input language into a symbolic
     expression in the expanded language.

   * The "core language" is a low level Scheme-like language which is
     the input recognised by the compiler.

at present the expanded language and the core language are equal, but
this might change in the future.

   While discussing the expander operations, we will always refer to
source code in the form of libraries.  R6RS also defines top level
programs; however, under Vicare:

   * The process of expanding programs is almost equal to the process of
     expanding libraries.  The differences are: a program does not
     export syntactic bindings; the top level body of a program
     intermixes definitions and expressions, while the top level body of
     a library separates definitions and expressions.

   * The result of expanding a library is equal to the result of
     expanding a program.

   * The output of the expander is the input of the compiler, and such
     input is equal when compiling a library and when compiling a
     program.

so if we understand how libraries are expanded, we also understand how
programs are expanded.

* Menu:

* expander intro macros::       Core macros, non-core macros,
                                user-defined macros.
* expander intro times::        Evaluation times.
* expander intro bindings::     Syntactic bindings.
* expander intro lex::          Lexical variables, labels,
                                location gensyms.


File: vicare-scheme.info,  Node: expander intro macros,  Next: expander intro times,  Up: expander intro

15.1.1 Primitive core macros, primitive non-core macros, user-defined macros
----------------------------------------------------------------------------

A big portion of what the expander does is processing macros; converting
input syntactic forms with format:

     (?KEYWORD ?SUBFORM ...)

into some output syntactic forms.  What kind of macros are implemented?
And which part of the expander's source code implements them?

Primitive core macros
.....................

These are basic syntaxes into which all the other macros are expanded;
despite being called "core", they are neither part of the expanded
language nor of the core language.  Core macros are split into three
groups, those that can appear in definition-context only:

     define             define-syntax
     define-alias       define-fluid-syntax
     module             library
     begin              import
     export             set!
     stale-when         begin-for-syntax

and maybe others; those that can appear in expression-context only:

     foreign-call             quote
     syntax-case              syntax
     letrec                   letrec*
     if                       lambda
     case-lambda              fluid-let-syntax
     struct-type-descriptor   struct-type-and-struct?
     record-type-descriptor   record-constructor-descriptor
     type-descriptor          is-a?
     splice-first-expand
     predicate-procedure-argument-validation
     predicate-return-value-validation

and maybe others; those that can appear in both definition-context and
expression-context:

     let-syntax               letrec-syntax

   Which part of the expander's source code implements core macros?

   * The implementation of core macros that appear in definition-context
     is integrated in the function 'chi-body*'.  The implementation is
     sophisticated because, in a body, syntactic bindings defined by
     'define-syntax' must be processed before syntactic bindings defined
     by 'define', so multiple passes are required.

   * The implementation of core macros that appear in expression-context
     consists of proper transformer functions selected by the function
     'core-macro-transformer'.  Such transformers are applied to input
     forms by the function 'chi-expr'.

     A core transformer function accepts as arguments: a syntax object
     representing the input form; values representing the lexical
     context in which the input form is present.  A core transformer
     function returns an instance of type '<psi>' representing an
     expanded language expression.

   * Macros that can appear in both definition context and expression
     context have double implementation: one in the function 'chi-body*'
     and one in the function 'chi-expr'.

   Core macros can establish new syntactic bindings by direct access to
the data structures representing the lexical environment.

Primitive non-core macros
.........................

These are macros that expand themselves into uses of core macros or
other non-core macros; they have a proper transformer function
accepting, as single argument, a syntax object representing the input
form and returning, as single value, a syntax object representing the
output form.  The only difference between a non-core macro and a
user-defined macro is that the former is integrated in the expander.

   Non-core macro transformers are selected by the function
'non-core-macro-transformer'.  The transformers are applied to input
forms by the function 'chi-expr'.

User-defined macros
...................

These are macros defined by 'define-syntax', 'let-syntax',
'letrec-syntax', 'define-fluid-syntax' and their derivatives.  Such
syntaxes expand themselves into uses of core or non-core macros.  Their
transformer functions accept, as single argument, a syntax object
representing the input form and return, as single value, a syntax object
representing the output form.


File: vicare-scheme.info,  Node: expander intro times,  Next: expander intro bindings,  Prev: expander intro macros,  Up: expander intro

15.1.2 Evaluation times
-----------------------

Throughout the code there are several references to different code
evaluation times.  The following library from '[exp1]' allows us to
explore what those times mean.

     (library (times-demo)
       (export
         call-time invoke-time expand-time visit-time compile-time)
       (import (vicare)
         (prefix (srfi :19) srfi.))

       (define call-time
         (lambda ()
           (receive-and-return (S)
               (srfi.date->string (srfi.current-date))
             (printf "call time: ~a\n" S))))

       (define invoke-time
         (let ((t (receive-and-return (S)
                      (srfi.date->string (srfi.current-date))
                    (printf "invoke time: ~a\n" S))))
           (lambda () t)))

       (define-syntax expand-time
         (lambda (stx)
           (receive-and-return (S)
               (srfi.date->string (srfi.current-date))
             (printf "expand time: ~a\n" S))))

       (define-syntax visit-time
         (let ((t (receive-and-return (S)
                      (srfi.date->string (srfi.current-date))
                    (printf "visit time: ~a\n" S))))
           (lambda (stx) t)))

       (define-syntax compile-time
         (lambda (stx)
           (let-syntax ((t (lambda (stx)
                             (receive-and-return (S)
                                 (srfi.date->string (srfi.current-date))
                               (printf "compile time: ~a\n" S)))))
             (t))))

       #| end of library |# )


File: vicare-scheme.info,  Node: expander intro bindings,  Next: expander intro lex,  Prev: expander intro times,  Up: expander intro

15.1.3 Syntactic bindings
-------------------------

A syntactic binding is an association between an identifier and the
result of evaluating an expression; there are different kinds:

"primitive syntax bindings"
     Syntactic forms built into the language, they are called primitive
     core macros and primitive non-core macros.  They are 'lambda',
     'define', 'let' and similar, 'define-syntax', 'letrec-syntax',
     'if', 'and', 'or' and all the rest.

"variable bindings"
     Associations between identifiers and expressions evaluated at
     run-time.  They are established by 'define', 'let', 'letrec' and
     similar.

"keyword bindings"
     Associations between identifiers and expressions evaluated at
     expand-time.  The identifiers in this role are called "syntactic
     keywords" (not to be confused with keyword objects like '#:hello').
     Examples of keyword bindings are "user-defined macros" (also named
     "user-defined syntaxes").

Identifiers in binding position and reference position
......................................................

Let's consider the following syntactic form:

     (let ((a 1))
       a)

the 'let' syntax defines a variable binding whose name is 'a'; a
variable binding is an association between a name and the result of
evaluating an expression at run-time.

   Let's consider the following form:

     (let-syntax ((a (identifier-syntax 1)))
       a)

'let-syntax' defines a keyword binding whose name is 'a'; a keyword
binding is an association between a name and the result of evaluating an
expression at expand-time.

   The identifiers 'a' in the first argument of 'let' and 'let-syntax'
are in "binding position"; the identifiers in the bodies of 'let' and
'let-syntax' are in "reference position".  The identifier in reference
position is a reference to the identifier in binding position: we say
that the identifier in reference position is "captured" by the
identifier in binding position.

Lexical environment
...................

The expansion process proceeds from the outer forms to the inner forms.
Given the syntactic form:

     (let ((a 1))
       (let ((b 2))
         (+ a b)))

first the outer 'let' is processed and the syntactic binding for 'a' is
established; then the inner 'let' is processed and the syntactic binding
for 'b' is established; finally the expression '(+ a b)' is processed in
a lexical context in which the syntactic bindings exist.

   The region of the syntactic binding 'a' is the inner 'let' form;
notice that the binding for 'a' is not visible in the right-hand side of
its definition.  The region of the syntactic binding 'b' is the internal
expression.

   During the expansion process: syntactic bindings are added to an
internal data structure that collects the associations, keeping track of
nested regions of visibility: the "lexical environment".  The lexical
environment is somewhat handled like a stack: while entering internal
expressions, syntactic binding descriptors are pushed on the stack.

Initial environment, top level bindings, local bindings
.......................................................

Let's consider the following library:

     (library (demo)
       (export)
       (import (rnrs (6)))

       (define var 1)

       (define (fun a)
         (let ((b 2))
           (let-syntax ((c (identifier-syntax 3)))
             (display (+ a b c))
             (newline))))

       (define-syntax syn
         (syntax-rules ()
           ((_ ?obj)
            (display ?obj))))

       (import (prefix (vicare posix) px.))
       (display (px.getenv "PATH"))
       (newline)

       #| end of library |# )

we introduce the definitions:

"initial lexical environment"
     The syntactic bindings imported by the 'import' clause of the
     'library' form and by the 'import' syntax in the body of the
     library, constitute the initial lexical environment for the
     expansion process of the library.

     In the example: the initial environment is the set of bindings
     exported by the libraries '(rnrs (6))' and '(vicare posix)'.

          *NOTE* An 'import' syntax that appears in an internal body as
          in:

               (lambda ()
                 (import (srfi :19))
                 (do-something))

          does *not* add bindings to the initial environment: it adds
          them to the local lexical environment.

"top level syntactic bindings"
     Syntactic bindings defined in the body of the library with 'define'
     and 'define-syntax'; the ones defined by 'define' are variable
     bindings, the ones defined by 'define-syntax' are keyword bindings.

     Top level bindings are visible in the whole library body: their
     region is the whole body.  Top level bindings have indefinite
     extent: their values are never garbage collected, they exists for
     the whole life of the 'vicare' process.

     In the example: 'var' and 'fun' are top level variables; 'syn' is a
     top level keyword.

     Every identifier in reference position that is not captured by a
     syntactic binding definition in the library itself must be captured
     by a binding in the initial environment; otherwise an exception is
     raised with condition object of type '&undefined'.

"local syntactic bindings"
     Syntactic bindings defined by a syntax that limits their region of
     visibility to a subform of the library body.  Bindings defined by
     'let' and similar syntaxes are local variable bindings, as well as
     those defined by 'define' in an internal body.  Bindings defined by
     'let-syntax' and similar syntaxes are local keyword bindings, as
     well as those defined by 'define-syntax' in an internal body.

     In the example: 'a' and 'b' are local variable bindings; 'c' is a
     local keyword binding.


File: vicare-scheme.info,  Node: expander intro lex,  Prev: expander intro bindings,  Up: expander intro

15.1.4 Lexical variables, labels, location gensyms
--------------------------------------------------

Let's consider the library:

     (library (demo)
       (export this)
       (import (rnrs (6)))
       (define this 8)
       (define that 9)
       (let ((a 1))
         (let ((a 2))
           (list a this that))))

and concentrate on the body:

     (define this 8)
     (define that 9)
     (let ((a 1))
       (let ((a 2))
         (list a this that)))

   This code defines 4 syntactic bindings: 'this' and 'that' as top
level variable bindings, of which 'this' is also exported; outer 'a' as
local variable binding; inner 'a' as local variable binding.

   The purpose of the expansion process is to transform the input code
into output code expressed in the core language.  After the expansion
process, every syntactic binding is renamed so that its name is unique
in the whole library body.  For example, we can imagine this
pseudo-code:

     (define lex.this 8)
     (define lex.that 9)
     (let ((lex.a.1 1))
       (let ((lex.a.2 2))
         ((primitive list) lex.a.2 lex.this lex.that)))

notice that the original identifier 'list', in reference position, has
been replaced by the symbolic expression '(primitive list)' because it
is captured by the core primitive binding of the initial lexical
environment.  The code undergoes the following lexical variable name
substitutions:

original name   lexical variable name
----------------------------------------
this            lex.this
that            lex.that
outer a         lex.a.1
inner a         lex.a.2

where the 'lex.*' symbols are gensyms; such gensyms are named "lexical
gensyms" or "lex gensyms".  They uniquely identify a syntactic binding
established in the library.

   Renaming bindings is one of the core purposes of the expansion
process; it is performed while visiting the source code as a tree in
breadth-first order.

Lexical contours and 'rib' objects
..................................

To distinguish among different bindings with the same name (like the two
local bindings both named 'a' in the example) we must distinguish among
different "lexical contours": different regions of visibility for a set
of syntactic bindings.

   Every 'let' syntax defines a new lexical contour; lexical contours
can be nested by nesting 'let' syntaxes; the library body is a lexical
contour itself.

     *NOTE* For simplicity, here we ignore the fact that 'let', in
     truth, defines 2 lexical contours: one for the bindings established
     by its first argument and one for the internal definitions.  In the
     example there are no internal definitions, so the internal contour
     is not used.

      -------------------------------------------------
     | (define this 8)              ;top-level contour |
     | (define that 9)                                 |
     | (let ((a 1))                                    |
     |  -----------------------------------------      |
     | |                            ;contour 1   |     |
     | | (let ((a 2))                            |     |
     | |  -------------------------------------  |     |
     | | |                          ;contour 2 | |     |
     | | | (list a this that)                  | |     |
     | |  -------------------------------------  |     |
     | |   )                                     |     |
     |  -----------------------------------------      |
     |   )                                             |
      -------------------------------------------------

Figure 15.1: Picture of lexical contours.

   An 'eq?'-unique object is assigned to each lexical contour; such
objects are called "marks".  In practise each syntactic binding is
associated to the mark representing its visibility region.  So the
original code is accompanied by the associations:

original name   lexical contour mark
---------------------------------------
this            src-mark
that            src-mark
outer a         1-mark
inner a         2-mark

which are registered in a component of the lexical environment: a record
of type 'rib'.  Every lexical contour is described by a 'rib'; the 'rib'
for the top level contour holds the associations:

original name   lexical contour mark
---------------------------------------
this            src-mark
that            src-mark

the 'rib' of the outer 'let' holds the associations:

original name   lexical contour mark
---------------------------------------
outer a         1-mark

the 'rib' of the inner 'let' holds the associations:

original name   lexical contour mark
---------------------------------------
inner a         2-mark

Syntax objects and syntax identifiers
.....................................

While the code is being visited by the expander: data structures called
"syntax objects" are created to keep track of the lexical contours.

  1. At first, the whole code is in a syntax object referencing the top
     'rib' structure:

          #<syntax-object
             expr=(begin
                    (define this 8)
                    (define that 9)
                    (let ((a 1))
                      (let ((a 2))
                        (list a this that))))
             rib=#<rib mark=src-mark>>

     syntactic bindings established in this contour will get the
     src-mark; expressions in the right-hand sides of binding
     definitions are expanded in the context of the src-mark.

  2. After the outer contour has been processed, the outer 'let' is in a
     syntax object:

          #<syntax-object
             expr=(let ((a 1))
                    (let ((a 2))
                      (list a this that)))
             rib=#<rib mark=1-mark>>

     syntactic bindings established in this contour will get the 1-mark;
     expressions in the right-hand sides of binding definitions are
     expanded in the context of the src-mark.

  3. After the outer 'let' has been processed, the inner 'let' is in a
     syntax object:

          #<syntax-object
             expr=(let ((a 2))
                    (list a this that))
             rib=#<rib mark=2-mark>>

     syntactic bindings established in this contour will get the 2-mark;
     expressions in the right-hand sides of binding definitions are
     expanded in the context of the 1-mark.

  4. After the inner 'let' has been processed, the expression is in a
     syntax object:

          #<syntax-object
             expr=(list a this that)
             rib=#<rib mark=2-mark>>

     the expression is expanded in the context of the 2-mark.

   A syntax object having a syntactic binding name as source code
expression is called "syntactic identifiers"; an identifier is a data
structure holding the mark of its visibility region/lexical contour
among its fields.

Label gensyms and 'rib' objects
...............................

An 'eq?'-unique object is assigned to each syntactic binding: a gensym
indicated as "label gensym" or just "label"; such associations are also
stored in the 'rib' representing a lexical contour:

original name   lexical contour mark   label
-----------------------------------------------
this            src-mark               lab.this
that            src-mark               lab.that
outer a         1-mark                 lab.a.1
inner a         2-mark                 lab.a.2

where the symbols 'lab.*' are gensyms.

Lexical variable gensyms and the LEXENV
.......................................

The fact that the lex gensyms in the expanded code are syntactic
bindings representing variables is registered in a portion of the
lexical environment indicated as LEXENV.  So the expanded code is
accompanied by the association:

label      lexical variables
-------------------------------
lab.this   lex.this
lab.that   lex.that
lab.a.1    lex.a.1
lab.a.2    lex.a.2

   Notice that, after the expansion: the original names of the internal
bindings (those defined by 'let') do not matter anymore; the original
names of the non-exported top level bindings do not matter anymore; only
the original name of the exported top level bindings is still important.

Storage location gensyms and GLOBAL-ENV
.......................................

About the value of syntactic bindings:

   * The value of local variables goes on the Scheme stack and it exists
     only while the code is being evaluated.

   * The value of local keywords goes on the Scheme stack and it exists
     only while the code is being expanded.

   * The value of top level bindings must be stored in some persistent
     location, because it must exist for the whole time the library is
     loaded in a running Vicare process.

   But where is a top level binding value stored?  The answer is:
gensyms are created for the sole purpose of acting as storage locations
for top level bindings; such gensyms are indicated as "location gensyms"
or "loc gensyms".  Under Vicare, symbols are data structures having a
'value' slot: such slot has 'symbol-value' as accessor and
'set-symbol-value!' as mutator and it is used as storage location.

   So the expanded code is accompanied by the following association:

label      location gensym
-----------------------------
lab.this   loc.this
lab.that   loc.that

where the 'loc.*' symbols are gensyms.  To represent the association
between the top level binding labels (both the exported ones and the
non-exported ones) and their storage location gensyms, the expander
builds a data structure indicated as GLOBAL-ENV.

Exported bindings and EXPORT-SUBST
..................................

Not all the top level syntactic bindings are exported by a library.  To
list those that are, a data structure is built and indicated as
EXPORT-SUBST; such data structure associates the external name of
exported bindings to their label gensym.  For the example library, the
EXPORT-SUBST represents the association:

label      external name
---------------------------
lab.this   this

   If the 'export' clause of the 'library' form renames a binding as in:

     (export (rename this external-this))

then the EXPORT-SUBST represents the association:

label      external name
---------------------------
lab.this   external-this


File: vicare-scheme.info,  Node: expander options,  Next: expander lexenv,  Prev: expander intro,  Up: expander

15.2 Initialisation and general configuration
=============================================

 -- Function: initialise-expander
     Initialise expander's internal tables.  It is automatically called
     by the functions in the public API.


File: vicare-scheme.info,  Node: expander lexenv,  Next: expander utils,  Prev: expander options,  Up: expander

15.3 The lexical environment
============================

The lexical environment is a compound data structure with the purpose of
associating syntactic identifiers to label gensyms and label gensyms to
syntactic binding descriptors.  The components are:

*Lexical context 'rib' objects*
     Objects of type 'rib' that map syntactic identifiers to label
     gensyms, keeping track of lexical contours.

*Primitive syntactic binding's labels*
     A set of label gensyms associated to the syntactic bindings
     established by the boot image; each label references its syntactic
     binding's descriptor.

*Imported syntactic binding's labels*
     A set of label gensyms associated to the syntactic bindings
     established by imported libraries; each label references its
     syntactic binding's descriptor.  The boot image's syntactic
     bindings are a subset of the imported syntactic bindings.

*Internal syntactic binding's labels, LEXENV*
     A set of label gensyms associated to the syntactic bindings
     established by the library being expanded; these labels are used as
     keys in an association list mapping labels to their syntactic
     binding's descriptor.  This alist is called LEXENV.

* Menu:

* expander lexenv rib::         Lexical contours and 'rib' objects.
* expander lexenv stx::         Wrapped and unwrapped syntax objects.
* expander lexenv descriptors:: Syntactic binding's descriptors.
* expander lexenv prim::        Primitive syntactic bindings.
* expander lexenv imported::    Imported syntactic bindings.
* expander lexenv internal::    Internal syntactic bindings.
* expander lexenv fluids::      How fluid syntaxes work.
* expander lexenv synonyms::    How synonym syntaxes work.
* expander lexenv inspection::  Lexical environment inspection.


File: vicare-scheme.info,  Node: expander lexenv rib,  Next: expander lexenv stx,  Up: expander lexenv

15.3.1 Lexical contours and 'rib' objects
-----------------------------------------

A 'rib' is an object constructed at every lexical contour in the source
code to hold informations about the syntactic bindings introduced in
that contour; "lexical contours" are, for example, 'let' and similar
syntaxes that can introduce bindings.

   The purpose of 'rib' objects is to map syntactic binding's source
names (the symbols as they appear in the source code) to the associated
label gensyms; this map is used when establishing if a syntax object
identifier in reference position is captured by an existing syntactic
binding.

* Menu:

* expander lexenv rib type::       The 'rib' object type.
* expander lexenv rib extending::  Extending 'rib' objects.
* expander lexenv rib sealing::    Sealing 'rib' objects.


File: vicare-scheme.info,  Node: expander lexenv rib type,  Next: expander lexenv rib extending,  Up: expander lexenv rib

15.3.1.1 The 'rib' object type
..............................

 -- Object Type: rib
     Disjoint object type representing lexical contours in the expansion
     process.  'rib' objects associate the source name of syntactic
     bindings to their label gensyms.

     Objects of type 'rib' have the following fields:

     'name*'
          List of symbols representing the source name of syntactic
          bindings.  When the 'rib' is sealed: the list is converted to
          a vector.

     'mark**'
          List of sublists of marks; there is a sublist of marks for
          every item in 'name*'.  When the 'rib' is sealed: the list is
          converted to a vector.

     'label*'
          List of label gensyms uniquely identifying syntactic bindings;
          there is a label for each item in 'name*'.  When the 'rib' is
          sealed: the list is converted to a vector.

     'sealed/freq'
          '#f' or vector of exact integers.  When '#f': this 'rib' is
          extensible: new syntactic bindings can be added to it.  When a
          vector: this 'rib' is sealed.  See below for an explanation of
          the frequency vector.


File: vicare-scheme.info,  Node: expander lexenv rib extending,  Next: expander lexenv rib sealing,  Prev: expander lexenv rib type,  Up: expander lexenv rib

15.3.1.2 Extending 'rib' objects
................................

A non-sealed 'rib' object is extensible: new syntactic bindings can be
added to it.  This happens every time the expander processes internal
definitions in a top-level body or internal body; examples are: the
top-level body of a program; the top-level body of a library; the
'internal-body' syntax; the internal body of 'lambda'; the internal body
of 'let' and its variants.

   Adding an identifier-to-label mapping to an extensible 'rib' is
achieved by prepending items to the field's lists.

   For example, an empty extensible 'rib' has fields:

     name*  = ()
     mark** = ()
     label* = ()

adding a syntactic binding to it with source name 'ciao', marks '(src)'
and label 'lab.ciao' means mutating the fields to:

     name*  = (ciao)
     mark** = ((src))
     label* = (lab.ciao)

we can think of this operation as "pushing the syntactic binding's
tuple":

     { ciao, (src), lab.ciao }

on the 'rib'.  Adding another binding with source name 'hello', marks
'(src)' and label 'lab.hello' means to push the tuple.

     { hello, (src), lab.hello }

that is to mutate the fields to:

     name*  = (hello     ciao)
     mark** = ((src)     (src))
     label* = (lab.hello lab.ciao)

   As further example, let's consider the syntactic form:

     (internal-body
       (define a 1)
       (define b 2)
       (list a b))

when starting to expand the internal body: a new 'rib' is created and
added to the metadata of the syntax object representing the body itself;
when each internal definition is encountered, a new entry for the
identifier is added (via side effect) to the 'rib':

     name*  = (b       a)
     mark** = ((src)   (src))
     label* = (lab.b   lab.a)

   The order in which the syntactic binding's tuples appear in the 'rib'
does not matter: two tuples are different when both the source name's
symbol and the marks are different and it is an error to add twice a
tuple to the same 'rib'.

Redefining or shadowing syntactic bindings
..........................................

While it is an error to add twice a syntactic binding's tuple to the
same 'rib', when expanding syntactic forms at the top-level of an
interaction environment: it is possible to redefine a previously defined
syntactic binding and to shadow a previously imported syntactic binding.

   Interaction environment objects (*note iklib environment::) hold a
'rib' object representing their top-level lexical contour; such 'rib'
holds tuples representing both the syntactic bindings imported from
libraries and the syntactic bindings defined when expanding expressions
at the top-level.

   Let's say we are expanding syntactic forms read from the REPL (which
uses an interaction environment); if we type:

     vicare> (define a 1)
     vicare> (define a 2)

after the first 'define' is expanded the tuples in the 'rib'
representing the top-level lexical contour are:

     name*  = (a)
     mark** = ((src))
     label* = (lab.a.1)

and after the second 'define' is expanded the tuples are:

     name*  = (a)
     mark** = ((src))
     label* = (lab.a.2)

we see that the old label gensym has been replaced with a new label
gensym: this causes the syntactic binding to be redefined.


File: vicare-scheme.info,  Node: expander lexenv rib sealing,  Prev: expander lexenv rib extending,  Up: expander lexenv rib

15.3.1.3 Sealing 'rib' objects
..............................

A non-empty 'rib' can be "sealed" once all bindings are inserted.  This
happens every time a syntax creates a lexical contour with a number of
syntactic bindings that is immediately known; examples are: 'lambda',
'let' and its variants.

   To seal a 'rib', we convert the lists 'name*', 'mark**' and 'label*'
to vectors and insert a frequency vector in the 'sealed/freq' field.

   The frequency vector is a Scheme vector of fixnums: an optimisation
that allows the 'rib' to reorganise itself by moving frequently used
tuples towards the beginning of the vectors.  This is possible because
the order in which the tuples appear in a 'rib' does not matter.

   Let's see how it works.  An unsealed 'rib' holding two syntactic
bindings with source names 'a' and 'b' and the 'src' mark, looks as
follows:

     name*       = (b       a)
     mark**      = ((src)   (src))
     label*      = (lab.b   lab.a)
     sealed/freq = #f

and right after sealing it:

     name*       = #(b       a)
     mark**      = #((src)   (src))
     label*      = #(lab.b   lab.a)
     sealed/freq = #(0       0)

the access frequencies in the 'sealed/freq' field are initialised to
zero; after accessing once the binding of 'b' in the sealed 'rib', its
frequency is incremented:

     name*       = #(b       a)
     mark**      = #((src)   (src))
     label*      = #(lab.b   lab.a)
     sealed/freq = #(1       0)

and after accessing twice the binding of 'a' in the sealed 'rib', the
tuples are swapped:

     name*       = #(a       b)
     mark**      = #((src)   (src))
     label*      = #(lab.a   lab.b)
     sealed/freq = #(2       1)

   Let's see what happens when there are multiple syntactic bindings
with the same access frequency.  If the scenario before the access is:

     name*       = #(f e d c b a)
     sealed/freq = #(1 1 1 0 0 0)

and we access 'a': first we want the tuple of 'a' to be moved in the
leftmost position in the group of tuples with frequency equal to zero:

     name*       = #(f e d a b c)
     sealed/freq = #(1 1 1 0 0 0)

we do this by swapping tuples in the vectors, in this case we swap the
tuple of 'a' with the tuple of 'c'; then we increment its access
frequency, the scenario after the access is:

     name*       = #(f e d a b c)
     sealed/freq = #(1 1 1 1 0 0)


File: vicare-scheme.info,  Node: expander lexenv stx,  Next: expander lexenv descriptors,  Prev: expander lexenv rib,  Up: expander lexenv

15.3.2 Wrapped and unwrapped syntax objects
-------------------------------------------

Under Vicare, we adopt the following definitions:

"Wrapped syntax object"
     An object of type '<stx>'.

"Unwrapped syntax object"
     A compound object holding: nulls, pairs, vectors, numbers, strings,
     bytevectors, chars, booleans, keywords, would-block objects,
     unbound objects, EOF objects, broken weak pointer objects, objects
     of type '<stx>'.

   An unwrapped symbol object *cannot* be part of an unwrapped syntax
object: an attempt to use an unwrapped syntax object holding an
unwrapped symbol will, sooner or later, cause an exception to be raised.

 -- Object Type: <stx>
     Disjoint object type representing wrapped syntax objects: source
     code expressions associated to meta data representing their lexical
     contour.

     Objects of type '<stx>' have the following fields:

     'expr'
          A symbolic expression representing source code, possibly
          annotated; these expressions are the ones produced by the
          Scheme source code reader.  They can be raw source code
          expressions or nested hierarchies of 'annotation' objects
          returned by 'get-annotated-datum' (*note iklib reader
          annotations::).

     'mark*'
          Null or a proper list of 'eq?'-unique objects, including the
          symbol 'src', used to distinguish between identifiers
          introduced by the source code and identifiers introduced by
          applications of macro transformers.  Each of these marks can
          be either a generated mark or an anti-mark.

          Two marks must be 'eq?'-comparable, so, by default, we use
          empty strings as marks and '#f' as anti-mark: their generation
          is fast.

     'rib*'
          Null or a proper list of 'rib' objects or 'shift' symbols.
          Every 'rib' represents a nested lexical contour; a 'shift'
          represents the return from a macro transformer application.

          While expanding source code: upon entering a syntactic form
          representing a lexical contour, a new 'rib' is added to the
          syntax object representing the syntactic form itself, to allow
          syntactic identifiers in the form to be captured by the
          bindings introduced in that contour.

     'annotated-expr*'
          Null or a proper list of annotated expressions: '#f' or input
          forms of macro transformer calls.  This field is used to trace
          the transformations a form undergoes when it is processed as
          macro use.  The '#f' items are inserted when this instance is
          processed as input form of a macro call, but is later
          discarded.

   The following bindings are exported by the library '(vicare
expander)'.

 -- Function: syntax-object? STX
     Return '#t' if STX is a wrapped or unwrapped syntax object;
     otherwise return '#f'.

 -- Function: stx? STX
     Return '#t' if STX is a wrapped syntax object; else return '#f'.

 -- Field accessor on '<stx>': stx-expr STX
     Return a symbolic expression, possibly annotated.

 -- Field accessor on '<stx>': stx-mark* STX
     Return null or a proper list of 'eq?'-unique objects acting as
     lexical contour marks, including the symbol 'src'.

 -- Field accessor on '<stx>': stx-rib* STX
     Return null or a proper list of 'rib' instances or 'shift' symbols.

 -- Field accessor on '<stx>': stx-annotated-expr* STX
     Return null or a proper list of annotated expressions: '#f' or
     input forms of macro transformer calls.

What are syntax objects
.......................

All the syntactic identifiers are '<stx>' objects with a symbol in their
'expr' field; other objects such as pairs and vectors may be wrapped or
unwrapped.  A wrapped pair is an '<stx>' whose 'expr' field is a pair:

     (syntax (a . b))

an unwrapped pair is a pair whose car and cdr fields are themselves
syntax objects (wrapped or unwrapped):

     ((syntax a) . (syntax b))

   It makes sense to associate lexical contour informations to syntactic
identifiers, while associating them to datums is useless from the point
of view of expanding source code.  For example, in the following code
the identifiers 'var' belong to different lexical contours, and so have
different meanings, while the datum '123' is always the same in all the
lexical contours:

     (let ((var 123))
       (let ((var 123))
         var))

   We can create a syntax object holding a raw expression as follows:

     (import (vicare))
     (define X 1)
     (begin-for-syntax
       (datum->syntax #'X 'ciao))
     => #<syntactic-identifier expr=ciao mark*=(src)>

and we can create a syntax object holding an annotated expression as
follows:

     (import (vicare))
     (define X 1)
     (begin-for-syntax
       (let* ((port   (open-string-input-port "(list X)"))
              (datum  (get-annotated-datum port))
              (stx    (datum->syntax #'X datum)))
         datum
         => #[annotation
                  expression=#<omitted>
                  stripped=(list X)
                  textual-position=#[r6rs-record: &source-position
                                        port-id="*string-input-port*"
                                        byte=0
                                        character=0
                                        line=1
                                        column=1]]
         stx)
         => #<syntax
                  expr=(list X)
                  mark*=(src)
                  line=1 column=1 source=*string-input-port*>

we can unwrap a syntax object by using 'syntax-case':

     (import (vicare))
     (define X 1)
     (begin-for-syntax
       (let* ((port   (open-string-input-port "(list X)"))
              (datum  (get-annotated-datum port))
              (stx    (datum->syntax #'X datum))
              (stx    (syntax-case stx ()
                        ((?head ?tail)
                         (list #'?head #'?tail)))))
         stx)
     => (#<syntactic-identifier expr=list mark*=(src)>
         #<syntactic-identifier expr=X mark*=(src)>)


File: vicare-scheme.info,  Node: expander lexenv descriptors,  Next: expander lexenv prim,  Prev: expander lexenv stx,  Up: expander lexenv

15.3.3 Syntactic binding's descriptors
--------------------------------------

A syntactic binding's descriptor is a pair with the format:

     (?BINDING-TYPE . ?BINDING-VALUE)

where ?BINDING-TYPE is a symbol and the format of ?BINDING-VALUE depends
on the binding type.

   Every syntactic binding has a unique label gensym associated to it;
during the expansion process, no matter the current lexical context,
given a label gensym we can retrieve the associated binding descriptor.

   Under Vicare, symbol objects are data structures with a slot named
'value', accessor 'symbol-value' and mutator 'set-symbol-value!'.  This
slot is usually initialised to the built-in object returned by
'(unbound-object)'; we can inspect the state of the slot with
'symbol-bound?'.  The expander makes use of this slot in label gensyms:

   * Syntactic bindings imported from libraries, including those
     established by the boot image, have the binding descriptor
     referenced by the 'value' slot of their label gensym.

   * Syntactic bindings established by the library being expanded, have
     the association between label gensyms and binding descriptors
     stored in the LEXENV component of the lexical environment.  The
     'value' slot of these gensyms is set to the return value of
     '(unbound-object)'.

   Given a label gensym we can determine if it is associated to an
imported syntactic binding by inspecting its 'value' slot: if
'symbol-bound?' applied to the label returns '#t', the binding is
imported; otherwise it was established by the code being expanded.


File: vicare-scheme.info,  Node: expander lexenv prim,  Next: expander lexenv imported,  Prev: expander lexenv descriptors,  Up: expander lexenv

15.3.4 Primitive syntactic bindings
-----------------------------------

The syntactic bindings established by the boot image are all those
exported by the library '(psyntax system $all)'; this is an internal
library that should not be used for normal operations.  Partitions of
these bindings are also exported by the library '(vicare)' and all those
in the hierarchies '(vicare ---)' and '(rnrs ---)'.

   The syntactic bindings established by the boot image have descriptors
built by Vicare's package building infrastructure.  Every boot image's
syntactic binding has a label gensym associated to it: the binding's
descriptor is stored in the 'value' slot of the label.

* Menu:

* expander lexenv prim inspect::     Inspecting descriptors.
* expander lexenv prim names::       Public names and labels.
* expander lexenv prim integrated::  Integrated syntaxes.
* expander lexenv prim cmacros::     Core macros.
* expander lexenv prim ncmacros::    Non-core macros.
* expander lexenv prim primitives::  Core primitive functions
                                     and operations.
* expander lexenv prim bio::         Core object-type names.
* expander lexenv prim btd::         Core object-type descriptors.
* expander lexenv prim records::     Core record-type names.
* expander lexenv prim conditions::  Core condition-object
                                     record-type names.
* expander lexenv prim rtd::         Core record-type descriptors.
* expander lexenv prim rcd::         Core record-constructor
                                     descriptors.
* expander lexenv prim fluids::      Fluid syntaxes.
* expander lexenv prim labels::      Core label-type names.


File: vicare-scheme.info,  Node: expander lexenv prim inspect,  Next: expander lexenv prim names,  Up: expander lexenv prim

15.3.4.1 Inspecting syntactic binding's descriptors
...................................................

We must remember that a syntactic binding's descriptor is a pair with
format:

     (?BINDING-TYPE . ?BINDING-VALUE)

first let's create an 'environment' object with the system library:

     (define env (environment '(psyntax system $all)))

then let's look at some descriptors:

   * Primitive function 'display':

          (define-values (label descriptor)
            (environment-binding 'display env))
          descriptor              => (core-prim . display)
          (symbol-value label)    => (core-prim . display)
          (eq? descriptor (symbol-value label))
          => #t

     in the descriptor: ?BINDING-TYPE is the symbol 'core-prim' and
     ?BINDING-VALUE is the symbol 'display', which is the public name of
     the primitive function.

   * Core primitive syntax 'lambda':

          (define-values (label descriptor)
            (environment-binding 'lambda env))
          descriptor              => (core-macro . lambda)
          (symbol-value label)    => (core-macro . lambda)
          (eq? descriptor (symbol-value label))
          => #t

     in the descriptor: ?BINDING-TYPE is the symbol 'core-macro' and
     ?BINDING-VALUE is the symbol 'lambda', which is the public name of
     the primitive syntax.

   * Non-core primitive syntax 'let':

          (define-values (label descriptor)
            (environment-binding 'let env))
          descriptor              => (macro . let)
          (symbol-value label)    => (macro . let)
          (eq? descriptor (symbol-value label))
          => #t

     in the descriptor: ?BINDING-TYPE is the symbol 'macro' and
     ?BINDING-VALUE is the symbol 'let', which is the public name of the
     primitive syntax.

   * Condition object type '&condition', which is implemented as R6RS
     record type:

          (define-values (label descriptor)
            (environment-binding '&condition env))
          descriptor
          => (core-object-type-name . (#<record-type-spec> .
            (&condition &condition-rtd &condition-rcd <condition>
               make-simple-condition condition? ())))

          (symbol-value label)
          => (core-object-type-name . (#<record-type-spec> .
            (&condition &condition-rtd &condition-rcd <condition>
               make-simple-condition condition? ())))

          (eq? descriptor (symbol-value label))
          => #t

     in the descriptor: ?BINDING-TYPE is the symbol
     'core-object-type-name' and ?BINDING-VALUE is the list:

          (#<record-type-spec> .
            (&condition &condition-rtd &condition-rcd <condition>
               make-simple-condition condition? ()))

     we can further inspect '&condition-rtd' and '&condition-rcd':

          (receive (label descriptor)
              (environment-binding '&condition-rtd env)
            descriptor)
          => ($core-rtd . &condition-rtd)

          (receive (label descriptor)
              (environment-binding '&condition-rcd env)
            descriptor)
          => ($core-rcd . &condition-rcd)


File: vicare-scheme.info,  Node: expander lexenv prim names,  Next: expander lexenv prim integrated,  Prev: expander lexenv prim inspect,  Up: expander lexenv prim

15.3.4.2 Public names and labels
................................

If we know the public name of a primitive syntactic binding ('display',
'lambda', 'let', '&condition', ...) we can retrieve the binding's label
using 'system-label' (*note expander system-labels::) and given the
label we can retrieve the binding descriptor using 'symbol-value' (*note
iklib symbols value::).  Examples:

     (symbol-value (system-label 'display))
     => (core-prim . display)

     (symbol-value (system-label 'lambda))
     => (core-macro . lambda)

     (symbol-value (system-label 'let))
     => (core-macro . let)

     (symbol-value (system-label '&condition))
     => (core-object-type-name . ---)

     (symbol-value (system-label '__who__))
     => ($fluid . fluid-label.__who__)

   For core primitive functions, record-type descriptors and
record-constructor descriptors:

   * Given the primitive's public name we can retrieve the binding type,
     the storage location gensym and so the system value, *note System
     values bound to symbols: compiler sysval.

   * Given the primitive's label gensym we can retrieve the binding
     type, the public name and so the storage location gensym and the
     system value, *note Retrieving syntactic binding labels: expander
     system-labels.

   Core primitive syntaxes and non-core primitive syntaxes have
implementation integrated in the expander:

   * Given the primitive's public name we can retrieve the binding type
     and the label gensym.

   * Given the primitive's label gensym we can retrieve the binding type
     and the public name.


File: vicare-scheme.info,  Node: expander lexenv prim integrated,  Next: expander lexenv prim cmacros,  Prev: expander lexenv prim names,  Up: expander lexenv prim

15.3.4.3 Primitive syntactic bindings: integrated syntax
........................................................

Some syntaxes are built into the expander and do not even have an
internal transformer function.  A syntactic binding representing an
integrated syntax has descriptor with format:

     (integrated-macro . ?NAME)

where: ?BINDING-TYPE is the symbol 'integrated-macro'; ?BINDING-VALUE is
?NAME, a symbol representing the public name of the syntax; null.

   Some of these core language syntaxes are: 'define-syntax',
'define-alias', 'define-fluid-syntax', 'module', 'library', 'begin',
'import', 'export', 'set!', 'let-syntax', 'letrec-syntax', 'stale-when',
'begin-for-syntax'.


File: vicare-scheme.info,  Node: expander lexenv prim cmacros,  Next: expander lexenv prim ncmacros,  Prev: expander lexenv prim integrated,  Up: expander lexenv prim

15.3.4.4 Primitive syntactic bindings: core macros
..................................................

A syntactic binding representing a core syntax with transformer function
implemented by the expander has descriptor with format:

     (core-macro . ?NAME)

where ?NAME is a symbol representing the public name of the syntax.

   The core syntax transformer functions are implemented by the expander
in the module exporting the function 'core-macro-transformer', which is
used to map core syntax names to transformer functions.

   The implementation of core syntaxes cannot be decomposed into uses of
other syntaxes.  Some of these syntaxes are: 'quote', 'lambda',
'case-lambda', 'let', 'letrec', 'letrec*', 'if', 'foreign-call',
'syntax-case', 'syntax', 'fluid-let-syntax', 'internal-body'.


File: vicare-scheme.info,  Node: expander lexenv prim ncmacros,  Next: expander lexenv prim primitives,  Prev: expander lexenv prim cmacros,  Up: expander lexenv prim

15.3.4.5 Primitive syntactic bindings: non-core macros
......................................................

A syntactic binding representing a non-core syntax with transformer
function implemented by the expander has descriptor with format:

     (macro . ?NAME)

where ?NAME is a symbol representing the public name of the syntax.  The
non-core syntax transformer functions are implemented by the expander in
the module exporting the function 'non-core-macro-transformer', which is
used to map non-core syntax names to transformer functions.

   The implementation of non-core syntaxes can be decomposed into uses
of other syntaxes.  Some of these syntaxes are:

     define-struct define-record-type define-condition-type
     define-enumeration
     or and xor
     cond case
     let* let-values let*-values syntax-rules
     quasiquote quasisyntax with-syntax identifier-syntax
     let*-syntax
     define-syntax-rule define-auxiliary-syntaxes define-syntax*
     do when unless while until for returnable
     case-define define* case-define* lambda* case-lambda*
     define-values receive receive-and-return begin0
     include
     assert try with-unwind-protection guard


File: vicare-scheme.info,  Node: expander lexenv prim primitives,  Next: expander lexenv prim bio,  Prev: expander lexenv prim ncmacros,  Up: expander lexenv prim

15.3.4.6 Primitive syntactic bindings: core primitive functions and operations
..............................................................................

A syntactic binding representing a core primitive function, or core
primitive operation, or core primitive record-type descriptor, or core
primitive record-constructor descriptor has syntactic binding's
descriptor with format:

     (core-prim . ?NAME)

where ?NAME is a symbol representing the public name of the core
primitive.


File: vicare-scheme.info,  Node: expander lexenv prim bio,  Next: expander lexenv prim btd,  Prev: expander lexenv prim primitives,  Up: expander lexenv prim

15.3.4.7 Primitive syntactic bindings: core object-type names
.............................................................

A syntactic binding representing the built-in Scheme object-types
defined by the boot image has descriptor with format:

     ($core-type-name
       . #(?TYPE-NAME ?UID-SYMBOL ?PARENT-NAME
           ?CONSTRUCTOR-NAME ?TYPE-PREDICATE-NAME
           ?EQUALITY-PREDICATE-NAME ?COMPARISON-PROCEDURE-NAME
           ?HASH-FUNCTION-NAME
           ?TYPE-DESCRIPTOR-NAME ?METHODS-AVECTOR))

where the values are:

?TYPE-NAME
     A symbol representing the type name.  For example '<fixnum>'.

?UID-SYMBOL
     A unique symbol associated with this object-type.

?PARENT-NAME
     A symbol representing the parent type of this type, or '#f' if this
     type has no parent.

?CONSTRUCTOR-NAME
     Either: a symbol representing the public name of this object-type's
     constructor function (for example '<vector>' has 'vector' as
     constructor); '#f' if this object-type has no constructor; '#t' if
     this object-type has no constructor but the syntax 'new' is used to
     validate an already built value:

          (new <fixnum> 1)        => 1
          (new <fixnum> "ciao")   error-> invalid value

?TYPE-PREDICATE-NAME
     A symbol representing the public name of the object-type's type
     predicate function, or '#f' if this type has no type predicate.

?EQUALITY-PREDICATE-NAME
     A symbol representing the public name of the object-type's equality
     predicate function, or '#f' if this type has no equality predicate.

?COMPARISON-PROCEDURE-NAME
     A symbol representing the public name of the object-type's equality
     procedure, or '#f' if this type has no equality procedure.

?HASH-FUNCTION-NAME
     A symbol representing the public name of the object-type's hash
     function, or '#f' if this type has no hash function.

?TYPE-DESCRIPTOR-NAME
     A symbol representing the public name of the object-type's run-time
     type descriptor; for example '<fixnum>' has '<fixnum>-ctd' (where
     'ctd' stands for _Core Type Descriptor_).

?METHODS-AVECTOR
     An association vector having symbols as both keys and values:

          #((?METHOD-NAME . ?METHOD-IMPLEMENTATION-PROCEDURE) ...)

     where each key is the name of an object-type's method and each
     value is the public name of the method's implementation procedure.


File: vicare-scheme.info,  Node: expander lexenv prim btd,  Next: expander lexenv prim records,  Prev: expander lexenv prim bio,  Up: expander lexenv prim

15.3.4.8 Primitive syntactic bindings: core object-type descriptors
...................................................................

A syntactic binding representing a core Scheme object-type descriptor
name has syntactic binding's descriptor with format:

     ($core-type-descriptor . ?NAME)

where ?NAME is a symbol representing the public name of the object-type
descriptor.

   These objects are run-time descriptors for the built-in Scheme object
types; the type '<fixnum>' has a run-time descriptor named
'<fixnum>-type-descriptor', which is used (for example) for late
bindings of method calls.


File: vicare-scheme.info,  Node: expander lexenv prim records,  Next: expander lexenv prim conditions,  Prev: expander lexenv prim btd,  Up: expander lexenv prim

15.3.4.9 Primitive Syntactic bindings: core record-type names
.............................................................

A syntactic binding representing R6RS's record-type name defined by the
boot image has descriptor with format:

     ($core-record-type-name
       . #(?TYPE-NAME ?UID
           ?RTD-NAME ?RCD-NAME
           ?PARENT-NAME
           ?CONSTRUCTOR-NAME ?TYPE-PREDICATE-NAME
           ?EQUALITY-PREDICATE ?COMPARISON-PROCEDURE ?HASH-FUNCTION
           ?METHODS-AVECTOR))

where the values are:

?TYPE-NAME
     A symbol representing the public name of the type.

?UID
     A symbol representing a unique identifier for the type.

?RTD-NAME
     A symbol representing the public name of the syntactic identifier
     to which the record-type descriptor is bound.

?RCD-NAME
     A symbol representing the public name of the syntactic identifier
     to which the default record-constructor descriptor is bound.

?PARENT-NAME
     '#f' or a symbol representing the public name of the syntactic
     identifier bound to the parent's record-type.

?CONSTRUCTOR-NAME
     A symbol representing the public name of the syntactic identifier
     to which the default constructor is bound.

?TYPE-PREDICATE-NAME
     A symbol representing the public name of the syntactic identifier
     to which the type predicate is bound.

?EQUALITY-PREDICATE
     A symbol representing the public name of the syntactic identifier
     to which the equality predicate is bound.

?COMPARISON-PROCEDURE
     A symbol representing the public name of the syntactic identifier
     to which the comparison procedure is bound.

?HASH-FUNCTION
     A symbol representing the public name of the syntactic identifier
     to which the hash function is bound.

?METHODS-AVECTOR
     An assocition vector having: as keys symbols representing method
     names; as values symbols representing the public name of the
     syntactic identifier to which the method is bound.


File: vicare-scheme.info,  Node: expander lexenv prim conditions,  Next: expander lexenv prim rtd,  Prev: expander lexenv prim records,  Up: expander lexenv prim

15.3.4.10 Primitive syntactic bindings: core condition-object record-type names
...............................................................................

A syntactic binding representing R6RS's condition object record-type
name defined by the boot image has descriptor with one of the formats:

     ($core-condition-object-type-name
       . #(?TYPE-NAME ?UID
           ?RTD-NAME ?RCD-NAME
           ?PARENT-NAME
           ?CONSTRUCTOR-NAME ?TYPE-PREDICATE-NAME
           ?ACCESSORS-AVECTOR))

where the values are:

?TYPE-NAME
     A symbol representing the public name of the type.

?UID
     A symbol representing a unique identifier for the type.

?RTD-NAME
     A symbol representing the public name of the syntactic identifier
     to which the record-type descriptor is bound.

?RCD-NAME
     A symbol representing the public name of the syntactic identifier
     to which the default record-constructor descriptor is bound.

?PARENT-NAME
     '#f' or a symbol representing the public name of the syntactic
     identifier bound to the parent's record-type.

?CONSTRUCTOR-NAME
     A symbol representing the public name of the syntactic identifier
     to which the default constructor is bound.

?TYPE-PREDICATE-NAME
     A symbol representing the public name of the syntactic identifier
     to which the type predicate is bound.

?ACCESSORS-AVECTOR
     An association vector having: as keys symbols representing field
     names; as values symbols representing the public name of the
     syntactic identifier to which the safe field accessor is bound.

   As example, for the definition:

     (define-condition-type &who
         &condition
       make-who-condition who-condition?
       (who condition-who))

the following descriptor is generated:

     ($core-condition-object-type-name
       . #(&who vicare:scheme-type:&who
           &who-rtd &who-rcd &condition
           make-who-condition who-condition?
           #((who . condition-who))))


File: vicare-scheme.info,  Node: expander lexenv prim rtd,  Next: expander lexenv prim rcd,  Prev: expander lexenv prim conditions,  Up: expander lexenv prim

15.3.4.11 Primitive syntactic bindings: core record-type descriptors
....................................................................

A syntactic binding representing a core record-type descriptor name has
syntactic binding's descriptor with format:

     ($core-rtd . ?NAME)

where ?NAME is a symbol representing the public name of the record-type
descriptor.


File: vicare-scheme.info,  Node: expander lexenv prim rcd,  Next: expander lexenv prim fluids,  Prev: expander lexenv prim rtd,  Up: expander lexenv prim

15.3.4.12 Primitive syntactic bindings: core record-constructor descriptors
...........................................................................

A syntactic binding representing a core record-constructor descriptor
name has syntactic binding's descriptor with format:

     ($core-rcd . ?NAME)

where ?NAME is a symbol representing the public name of the
record-constructor descriptor.


File: vicare-scheme.info,  Node: expander lexenv prim fluids,  Next: expander lexenv prim labels,  Prev: expander lexenv prim rcd,  Up: expander lexenv prim

15.3.4.13 Primitive syntactic bindings: fluid syntaxes
......................................................

A syntactic binding representing a fluid syntax defined by the boot
image has descriptor with format:

     ($fluid . ?FLUID-LABEL)

where ?FLUID-LABEL is a further label gensym used to redefine the
keyword binding; *note How fluid syntaxes work: expander lexenv fluids.

   Some of the fluid syntaxes are: '__who__', 'return', 'continue',
'break', 'with', 'brace', '<>'.


File: vicare-scheme.info,  Node: expander lexenv prim labels,  Prev: expander lexenv prim fluids,  Up: expander lexenv prim

15.3.4.14 Core label-type names
...............................

A syntactic binding representing a label-type name defined by the boot
image has descriptor with format:

     ($core-label-type-name
       . #(?TYPE-NAME ?UID
           ?PARENT-ANNOTATION
           ?CONSTRUCTOR-NAME ?DESTRUCTOR-NAME ?TYPE-PREDICATE-NAME
           ?EQUALITY-PREDICATE ?COMPARISON-PROCEDURE ?HASH-FUNCTION
           ?METHODS-AVECTOR))

where the values are:

?TYPE-NAME
     A symbol representing the public name of the type.

?UID
     A symbol representing a unique identifier for the type.

?PARENT-ANNOTATION
     A symbolic expression representing the parent's type annotation.

?CONSTRUCTOR-NAME
     '#f' or a symbol representing the public name of the syntactic
     identifier to which the constructor is bound.

?DESTRUCTOR-NAME
     '#f' or a symbol representing the public name of the syntactic
     identifier to which the destructor is bound.

?TYPE-PREDICATE-NAME
     '#f' or a symbol representing the public name of the syntactic
     identifier to which the type predicate is bound.

?EQUALITY-PREDICATE
     '#f' or a symbol representing the public name of the syntactic
     identifier to which the equality predicate is bound.

?COMPARISON-PROCEDURE
     '#f' or a symbol representing the public name of the syntactic
     identifier to which the comparison procedure is bound.

?HASH-FUNCTION
     '#f' or a symbol representing the public name of the syntactic
     identifier to which the hash function is bound.

?METHODS-AVECTOR
     An association vector: as keys symbols representing method names;
     as values symbols representing the public name of the syntactic
     identifier to which the method procedure is bound.


File: vicare-scheme.info,  Node: expander lexenv imported,  Next: expander lexenv internal,  Prev: expander lexenv prim,  Up: expander lexenv

15.3.5 Imported syntactic bindings
----------------------------------

The data describing syntactic bindings established by a library is
stored in a 'library' object:

   * If no 'rename' clause is used in the 'import' clause: the imported
     name equals the exported name and it is taken from the
     'export-subst' field of the 'library' object.  The 'export-subst'
     maps exported names to label gensyms; it is an alist whose entries
     have format:

          (?EXPORTED-NAME . ?LABEL)

   * The syntactic binding's descriptors are taken from the 'global-env'
     field of the 'library' object.  The 'global-env' maps label gensyms
     to their binding descriptors; it is an alist whose entries have
     format:

          (?LABEL . ?BINDING-DESCRIPTOR)

   * When the library is interned: a 'library' object is created and the
     fields 'export-subst' and 'global-env' are used to build the label
     gensyms by storing the descriptors in the 'value' slots of the
     gensyms.

   * When a library is imported: the imported names of syntactic
     bindings are associated to their label gensyms in the 'rib' object
     representing the current lexical context.

* Menu:

* expander lexenv imported inspect::    Inspecting descriptors.
* expander lexenv imported variables::  Global variables.
* expander lexenv imported nvmacros::   Non-variable macros.
* expander lexenv imported vmacros::    Variable macros.
* expander lexenv imported etv::        Expand-time values.
* expander lexenv imported stn::        Struct-type names.
* expander lexenv imported rtn::        Record-type names.
* expander lexenv imported modules::    Module interfaces.
* expander lexenv imported fluids::     Fluid syntaxes.
* expander lexenv imported synonyms::   Synonym syntaxes.
* expander lexenv imported examples::   Example library.


File: vicare-scheme.info,  Node: expander lexenv imported inspect,  Next: expander lexenv imported variables,  Up: expander lexenv imported

15.3.5.1 Inspecting descriptors
...............................

We must remember that a syntactic binding's descriptor is a pair with
format:

     (?BINDING-TYPE . ?BINDING-VALUE)

first let's create a library:

     (library (demo)
       (export var)
       (import (vicare))
       (define var "ciao"))

then let's create an 'environment' object with the '(demo)' library:

     (define env (environment '(demo)))

finally let's look at the descriptor:

     (define-values (label descriptor)
       (environment-binding 'var env))

     (define lex/loc-gensym
       (cddr descriptor))

     (print-gensym #f)

     descriptor
     => (global . (#<library (demo)> . lex/loc.var))

     (symbol-value label)
     => (global . (#<library (demo)> . lex/loc.var))

     (eq? descriptor (symbol-value label))
     => #t

     (symbol-value lex/loc-gensym)
     => "ciao"

where 'lex/loc.var' is both the lexical gensym and the storage location
gensym of the exported variable; we can also import the library and try
to expand some code:

     (import (demo))
     (print-gensym #f)
     (expansion-of var)
     => lex/loc.var


File: vicare-scheme.info,  Node: expander lexenv imported variables,  Next: expander lexenv imported nvmacros,  Prev: expander lexenv imported inspect,  Up: expander lexenv imported

15.3.5.2 Imported syntactic bindings: global variables
......................................................

A syntactic binding representing an imported variable binding has
descriptor with format:

     (global . (?LIBRARY . ?LEX/LOC))

where: ?LIBRARY is the 'library' object from which the binding is
imported; ?LEX/LOC is the storage location gensym containing the
variable's value in its 'value' field.


File: vicare-scheme.info,  Node: expander lexenv imported nvmacros,  Next: expander lexenv imported vmacros,  Prev: expander lexenv imported variables,  Up: expander lexenv imported

15.3.5.3 Imported syntactic bindings: non-variable macros
.........................................................

A syntactic binding representing an imported keyword binding with a
non-variable transformer has descriptor with format:

     (global-macro . (?LIBRARY . ?LOC))

where: ?LIBRARY is a record of type 'library' describing the library
from which the macro is exported; ?LOC is the storage location gensym
containing the transformer function in its 'value' field.

   Syntactic bindings of this type are established by 'define-syntax',
'let-syntax' and similar when the result of evaluating their right-hand
side expression is a function.


File: vicare-scheme.info,  Node: expander lexenv imported vmacros,  Next: expander lexenv imported etv,  Prev: expander lexenv imported nvmacros,  Up: expander lexenv imported

15.3.5.4 Imported syntactic bindings: variable macros
.....................................................

A syntactic binding representing an imported keyword binding with
variable transformer has descriptor with format:

     (global-macro! . (?LIBRARY . ?LOC))

where: ?LIBRARY is a record of type 'library' describing the library
from which the macro is exported; ?LOC is the storage location gensym
containing the transformer function in its 'value' field.

   Syntactic bindings of this type are established by 'define-syntax',
'let-syntax' and similar when the result of evaluating their right-hand
side expression is the return value of a call to
'make-variable-transformer'.


File: vicare-scheme.info,  Node: expander lexenv imported etv,  Next: expander lexenv imported stn,  Prev: expander lexenv imported vmacros,  Up: expander lexenv imported

15.3.5.5 Imported syntactic bindings: expand-time values
........................................................

A syntactic binding representing an imported keyword binding associated
to an expand-time value has descriptor with format:

     (global-etv . (?LIBRARY . ?LOC))

where: ?LIBRARY is a record of type 'library' describing the library
from which the binding is imported; ?LOC is the gensym containing the
actual object in its 'value' field (but only after the library has been
visited).

   Syntactic bindings of this type are established by 'define-syntax',
'let-syntax' and similar when the result of evaluating their right-hand
side expression is the return value of a call to
'make-expand-time-value'.


File: vicare-scheme.info,  Node: expander lexenv imported stn,  Next: expander lexenv imported rtn,  Prev: expander lexenv imported etv,  Up: expander lexenv imported

15.3.5.6 Imported syntactic bindings: struct-type names
.......................................................

A syntactic binding representing an imported keyword binding associated
to a Vicare's struct-type name has descriptor with format:

     ($struct-type-name . ?STRUCT-TYPE-SPEC)

where ?STRUCT-TYPE-DESCRIPTOR is an instance of '<struct-type-spec>'.


File: vicare-scheme.info,  Node: expander lexenv imported rtn,  Next: expander lexenv imported modules,  Prev: expander lexenv imported stn,  Up: expander lexenv imported

15.3.5.7 Imported syntactic bindings: record-type names
.......................................................

A syntactic binding representing a keyword binding imported from a
library, but not established by the boot image, associated to a R6RS's
record-type name has syntactic binding descriptor with one of the
formats:

     ($record-type-name . ?RECORD-TYPE-SPEC)

where ?RECORD-TYPE-SPEC is a record of type '<r6rs-record-type-spec>'.
This record references the syntactic identifiers bound to the
record-type descriptor, the record-constructor descriptor and other
values.


File: vicare-scheme.info,  Node: expander lexenv imported modules,  Next: expander lexenv imported fluids,  Prev: expander lexenv imported rtn,  Up: expander lexenv imported

15.3.5.8 Imported syntactic bindings: module interfaces
.......................................................

A syntactic binding representing an imported keyword binding associated
to the interface of a 'module' syntax has descriptor with format:

     ($module . ?MODULE-INTERFACE)

where ?MODULE-INTERFACE is a struct of type 'module-interface'.

   Syntactic bindings of this type are established by uses of the syntax
'module'.


File: vicare-scheme.info,  Node: expander lexenv imported fluids,  Next: expander lexenv imported synonyms,  Prev: expander lexenv imported modules,  Up: expander lexenv imported

15.3.5.9 Imported syntactic bindings: fluid syntaxes
....................................................

A syntactic binding representing an imported keyword binding associated
to a fluid syntax has descriptor with format:

     ($fluid . ?FLUID-LABEL)

where ?FLUID-LABEL is a further label gensym used to redefine the
keyword binding; *note How fluid syntaxes work: expander lexenv fluids.

   Syntactic bindings of this type are established by uses of the syntax
'define-fluid-syntax'.


File: vicare-scheme.info,  Node: expander lexenv imported synonyms,  Next: expander lexenv imported examples,  Prev: expander lexenv imported fluids,  Up: expander lexenv imported

15.3.5.10 Imported syntactic bindings: synonym syntaxes
.......................................................

A syntactic binding representing an imported keyword binding associated
to a synonym syntax has descriptor with format:

     ($synonym . ?SYNONYM-LABEL)

where ?SYNONYM-LABEL is the label gensym associated to the aliased
syntax; *note How synonym syntaxes work: expander lexenv synonyms.

   Syntactic bindings of this type are established by 'define-syntax',
'let-syntax' and similar when the result of evaluating their right-hand
side expression is the return value of a call to
'make-synonym-transformer'.


File: vicare-scheme.info,  Node: expander lexenv imported examples,  Prev: expander lexenv imported synonyms,  Up: expander lexenv imported

15.3.5.11 Example library
.........................

We can use the following example library to toy with imported syntactic
bindings:

     (library (demo)
       (export var macro var-macro macro-id
               etv color <color> da-module fluid synonym)
       (import (vicare))

       (define var "ciao")

       (define-syntax macro
         (lambda (stx) "hello"))

       (define-syntax macro-id
         (identifier-syntax "hello"))

       (define-syntax var-macro
         (make-variable-transformer (lambda (stx) "ohayo")))

       (define-syntax etv
         (make-expand-time-value 123))

       (define-struct color
         (red green blue))

       (define-record-type <color>
         (fields red green blue))

       (module da-module
           (inner)
         (define inner 123))

       (define-fluid-syntax fluid
         (lambda (stx) "da fluid"))

       (define-syntax synonym
         (make-synonym-transformer #'var))

       #| end of library |# )


File: vicare-scheme.info,  Node: expander lexenv internal,  Next: expander lexenv fluids,  Prev: expander lexenv imported,  Up: expander lexenv

15.3.6 Internal syntactic bindings
----------------------------------

The internal syntactic bindings are the ones established by the code
being expanded, both at the top level and in a local context.  The
association between their label gensyms and their descriptors is
maintained in the LEXENV.

   A LEXENV is an alist managed somewhat like a stack; while the
expansion proceeds, visiting the code in breadth-first order: the LEXENV
is updated by pushing new entries on the stack.  A LEXENV entry has the
following format:

     (?LABEL . ?SYNTACTIC-BINDING-DESCRIPTOR)

where: ?LABEL is a label gensym uniquely associated to a syntactic
binding; ?SYNTACTIC-BINDING-DESCRIPTOR is a syntactic binding
descriptor.

 -- Function: current-inferior-lexenv
     Return an alist representing the current LEXENV used at the
     inferior expansion level; mutating the returned value leads to
     undefined behaviour.  It is to be used from the body of a macro
     transformer.

     As example, to just print the LEXENV we can do:

          (import (vicare))

          (define-syntax (print-lexenv stx)
            (import (prefix (vicare expander) xp::))
            (print-gensym #f)
            (pretty-print (xp::current-inferior-lexenv)
                          (current-error-port))
            #'(void))

          (define a 1)

          (print-lexenv)

     and we will see two entries:

          ((lab.a            . (lexical . (lex.a . #f)))
           (lab.print-lexenv . (local-macro . (#<procedure> . ?SEXP))))

     where ?SEXP is the symbolic expression representing the transformer
     function of 'print-lexenv' fully expanded to the core language.

   Top level and local syntactic bindings are represented in the same
way in the LEXENV; the difference between them is that top level
syntactic bindings have the association between the source name and the
label gensym stored in the top level 'rib' object.

* Menu:

* expander lexenv internal variables::  Lexical variables.
* expander lexenv internal nvmacro::    Non-variable macros.
* expander lexenv internal vmacros::    Variable macros.
* expander lexenv internal etv::        Expand-time values.
* expander lexenv internal modules::    Module interfaces.
* expander lexenv internal pvars::      Pattern variables.
* expander lexenv internal stn::        Struct-type names.
* expander lexenv internal rtn::        Record-type names.
* expander lexenv internal fluids::     Fluid syntaxes.
* expander lexenv internal synonym::    Synonym syntaxes.
* expander lexenv internal bfs::        'begin-for-syntax' code.
* expander lexenv internal displaced::  Displaced syntactic bindings.


File: vicare-scheme.info,  Node: expander lexenv internal variables,  Next: expander lexenv internal nvmacro,  Up: expander lexenv internal

15.3.6.1 Internal syntactic bindings: lexical variables
.......................................................

A syntactic binding representing a variable binding as created by 'let'
and similar syntaxes, 'lambda', 'case-lambda' or 'define', has
descriptor with format:

     (lexical . (?LEXVAR . ?ASSIGNED))

where: ?LEXVAR is a lexical gensym representing the name of the lexical
variable binding in the expanded code; ?ASSIGNED is a boolean, true if
somewhere in the code the variable is assigned (that is: its value is
mutated).

   We want to keep track of assigned variables because we do not want to
export from a library a mutable variable.


File: vicare-scheme.info,  Node: expander lexenv internal nvmacro,  Next: expander lexenv internal vmacros,  Prev: expander lexenv internal variables,  Up: expander lexenv internal

15.3.6.2 Internal syntactic bindings: non-variable macros
.........................................................

A syntactic binding representing a keyword binding with non-variable
transformer has descriptor with format:

     (local-macro . (?TRANSFORMER . ?EXPANDED-EXPR))

where: ?TRANSFORMER is a function implementing the macro transformer;
?EXPANDED-EXPR is the expression in fully expanded code representing the
right-hand side of the syntax definition.  ?TRANSFORMER is the result of
compiling and evaluating ?EXPANDED-EXPR.

   For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

     (set! ?LOC ?EXPANDED-CODE)

where ?LOC is the storage location gensym of the macro.

   These syntactic bindings are established by 'define-syntax',
'let-syntax' and similar, when their right-hand side evaluates to a
function.


File: vicare-scheme.info,  Node: expander lexenv internal vmacros,  Next: expander lexenv internal etv,  Prev: expander lexenv internal nvmacro,  Up: expander lexenv internal

15.3.6.3 Internal syntactic bindings: variable macros
.....................................................

A syntactic binding representing a keyword binding with variable
transformer has descriptor with format:

     (local-macro! . (?TRANSFORMER . ?EXPANDED-EXPR))

where: ?TRANSFORMER is a function implementing the macro transformer;
?EXPANDED-EXPR is the expression in fully expanded code representing the
right-hand side of the syntax definition.  ?TRANSFORMER is the result of
compiling and evaluating ?EXPANDED-EXPR.

   For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

     (set! ?LOC ?EXPANDED-CODE)

where ?LOC is the storage location gensym of the macro.

   These syntactic bindings are established by 'define-syntax',
'let-syntax' and similar, when their right-hand side evaluates to the
return value of 'make-variable-transformer'.


File: vicare-scheme.info,  Node: expander lexenv internal etv,  Next: expander lexenv internal modules,  Prev: expander lexenv internal vmacros,  Up: expander lexenv internal

15.3.6.4 Internal syntactic bindings: expand-time values
........................................................

A syntactic binding representing a keyword binding associated to an
expand-time value has descriptor with format:

     (local-etv . (?OBJECT . ?EXPANDED-EXPR))

where: ?OBJECT is the actual value computed at expand time;
?EXPANDED-EXPR is the result of fully expanding the right-hand side of
the syntax definition.  ?OBJECT is the result of compiling and
evaluating ?EXPANDED-EXPR.

   For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

     (set! ?LOC ?EXPANDED-CODE)

where ?LOC is the storage location gensym of the macro.

   These syntactic bindings are established by 'define-syntax',
'let-syntax' and similar, when their right-hand side evaluates to the
return value of 'make-expand-time-value'.


File: vicare-scheme.info,  Node: expander lexenv internal modules,  Next: expander lexenv internal pvars,  Prev: expander lexenv internal etv,  Up: expander lexenv internal

15.3.6.5 Internal syntactic bindings: module interfaces
.......................................................

A syntactic binding representing a keyword binding associated to the
interface of a 'module' syntax has descriptor with format:

     ($module . ?MODULE-INTERFACE)

where ?MODULE-INTERFACE is a record of type 'module-interface'.

   Syntactic bindings of this type are established by uses of the syntax
'module'.


File: vicare-scheme.info,  Node: expander lexenv internal pvars,  Next: expander lexenv internal stn,  Prev: expander lexenv internal modules,  Up: expander lexenv internal

15.3.6.6 Internal syntactic bindings: pattern variables
.......................................................

A syntactic binding representing a keyword binding associated to a
pattern variable, as created by 'syntax-case' and 'syntax-rules', has
descriptor with format:

     (pattern-variable . (?NAME . ?LEVEL))

where: ?NAME is the lexical gensym representing the name of the pattern
variable; ?LEVEL is a non-negative exact integer representing the
ellipsis nesting level.

   The 'syntax-case' patterns below will generate the displayed
syntactic binding descriptors:

     ?a                      ->  (pattern-variable . (?a . 0))
     (?a)                    ->  (pattern-variable . (?a . 0))
     (((?a)))                ->  (pattern-variable . (?a . 0))
     (?a ...)                ->  (pattern-variable . (?a . 1))
     ((?a) ...)              ->  (pattern-variable . (?a . 1))
     ((((?a))) ...)          ->  (pattern-variable . (?a . 1))
     ((?a ...) ...)          ->  (pattern-variable . (?a . 2))
     (((?a ...) ...) ...)    ->  (pattern-variable . (?a . 3))


File: vicare-scheme.info,  Node: expander lexenv internal stn,  Next: expander lexenv internal rtn,  Prev: expander lexenv internal pvars,  Up: expander lexenv internal

15.3.6.7 Internal syntactic bindings: struct-type names
.......................................................

A syntactic binding representing a keyword binding associated to a
Vicare's struct-type name has descriptor with format:

     ($struct-type-name . ?STRUCT-TYPE-SPEC)

where ?STRUCT-TYPE-SPEC is an instance of '<struct-type-spec>'.

   These bindings are established by uses of the syntax 'define-struct'.


File: vicare-scheme.info,  Node: expander lexenv internal rtn,  Next: expander lexenv internal fluids,  Prev: expander lexenv internal stn,  Up: expander lexenv internal

15.3.6.8 Internal syntactic bindings: record-type names
.......................................................

A syntactic binding representing a keyword binding associated to a
R6RS's record-type name has descriptor with one of the formats:

     ($record-type-name . ?RECORD-TYPE-SPEC)

where ?RECORD-TYPE-SPEC is a record of type '<r6rs-record-type-spec>'.
This record references the syntactic identifiers bound to the
record-type descriptor, the record-constructor descriptor and other
values.

   These syntactic bindings are established by uses of the syntax
'define-record-type', 'define-condition-type' and similar.


File: vicare-scheme.info,  Node: expander lexenv internal fluids,  Next: expander lexenv internal synonym,  Prev: expander lexenv internal rtn,  Up: expander lexenv internal

15.3.6.9 Internal syntactic bindings: fluid syntaxes
....................................................

A syntactic binding representing a keyword binding associated to a fluid
syntax has descriptor with format:

     ($fluid . ?FLUID-LABEL)

where ?FLUID-LABEL is the label gensym associated to the fluid syntax.


File: vicare-scheme.info,  Node: expander lexenv internal synonym,  Next: expander lexenv internal bfs,  Prev: expander lexenv internal fluids,  Up: expander lexenv internal

15.3.6.10 Internal syntactic bindings: synonym syntaxes
.......................................................

A syntactic binding representing a keyword binding associated to a
synonym syntax has descriptor with format:

     ($synonym . ?SYNONYM-LABEL)

where ?SYNONYM-LABEL is the label gensym associated to the aliased
syntax; *note How synonym syntaxes work: expander lexenv synonyms.


File: vicare-scheme.info,  Node: expander lexenv internal bfs,  Next: expander lexenv internal displaced,  Prev: expander lexenv internal synonym,  Up: expander lexenv internal

15.3.6.11 Internal syntactic bindings: 'begin-for-syntax' code
..............................................................

Each use of 'begin-for-syntax' generates expand-time code; when this
code is defined at the top level: it must become visit code to be added
to compiled libraries.  Whenever a 'begin-for-syntax' use is expanded
the following entry is pushed on the LEXENV:

     (?UNUSED-LABEL . (begin-for-syntax . ?VISIT-CODE))

where: ?UNUSED-LABEL is a dummy label gensym which is not bound in the
current 'rib'; ?VISIT-CODE is a full core language expression
representing the expanded contents of the 'begin-for-syntax' use.


File: vicare-scheme.info,  Node: expander lexenv internal displaced,  Prev: expander lexenv internal bfs,  Up: expander lexenv internal

15.3.6.12 Internal syntactic bindings: displaced syntactic bindings
...................................................................

These pairs have a format similar to a LEXENV entry representing a
syntactic binding, but they are used to represent a failed search into a
LEXENV.

   The following special value represents an unbound label:

     (displaced-lexical . #f)

this is an "identifier out of context" error.

   The following special value represents the result of a lexical
environment query with invalid label value (not a symbol):

     (displaced-lexical . ())


File: vicare-scheme.info,  Node: expander lexenv fluids,  Next: expander lexenv synonyms,  Prev: expander lexenv internal,  Up: expander lexenv

15.3.7 How fluid syntaxes work
------------------------------

When a fluid syntax's syntactic binding is established by
'define-fluid-syntax' in the source code of a library or program:

     (define-fluid-syntax ?LHS ?RHS)

an identifier ?LHS is associated to a main label ?LABEL in the current
'rib'; an entry is pushed on the LEXENV:

     (?LABEL . ($fluid . ?FLUID-LABEL))

when querying the LEXENV for the binding descriptor associated to
?LABEL: the descriptor with type '$fluid' is always returned, qualifying
the binding as fluid syntax.

   At the same time, 'define-fluid-syntax' pushes another entry on the
LEXENV:

     (?FLUID-LABEL . ?SYNTACTIC-BINDING)

where ?SYNTACTIC-BINDING is the concrete binding descriptor created by
expanding and evaluating ?RHS then interpreting its return value.

   Given the identifier ?LHS: we can retrieve the associated ?LABEL and
so the ?FLUID-LABEL; then we can "follow through" ?FLUID-LABEL to
retrieve the actual binding descriptor.

   The fluid syntax can be redefined any number of times by using
'fluid-let-syntax':

     (fluid-let-syntax ((?LHS ?INNER-RHS)) . ?BODY)

causing other entries associated to ?FLUID-LABEL to be pushed on the
LEXENV:

     (?FLUID-LABEL . ?INNER-SYNTACTIC-BINDING)

where ?INNER-SYNTACTIC-BINDING is the binding descriptor resulting from
expanding and evaluating ?INNER-RHS then interpreting its return value.

   When searching the LEXENV for a syntactic binding descriptor matching
the label ?FLUID-LABEL: the topmost entry is found, so the binding
appears to be redefined.

Primitive fluid syntaxes
........................

This is *not* what happens for the primitive fluid syntaxes exported by
the boot image like 'return', 'break' and 'continue'.  For these
syntaxes the lexical environment of the boot image includes only the
entries:

     (?RETURN-LABEL   . ($fluid .   ?RETURN-FLUID-LABEL))
     (?BREAK-LABEL    . ($fluid .    ?BREAK-FLUID-LABEL))
     (?CONTINUE-LABEL . ($fluid . ?CONTINUE-FLUID-LABEL))

and there are no entries for the fluid labels ?RETURN-FLUID-LABEL,
?BREAK-FLUID-LABEL and ?CONTINUE-FLUID-LABEL.  The keywords of these
fluid syntaxes are bound in the environment, but they are bound to
"nothing"; trying to follow through the fluid labels to the concrete
binding descriptors will result in the binding descriptor:

     (displaced-lexical . #f)

which is interpreted as the error "keyword identifier out of context".

   Such half-defined fluid syntaxes are fully usable as auxiliary
syntaxes and can be redefined with 'fluid-let-syntax'.  There are *no*
transformer functions for 'return', 'break', 'continue' and similar
syntaxes.


File: vicare-scheme.info,  Node: expander lexenv synonyms,  Next: expander lexenv inspection,  Prev: expander lexenv fluids,  Up: expander lexenv

15.3.8 How synonym syntaxes work
--------------------------------

When an synonym syntax binding is established:

     (define-syntax ?LHS (make-synonym-transformer ?ID))

an identifier ?LHS is associated to a main label ?LABEL in the current
'rib'; an entry is pushed on the LEXENV:

     (?LABEL . ($synonym . ?SYNONYM-LABEL))

where ?SYNONYM-LABEL is the label bound to the identifier ?ID.  Given
the identifier ?LHS: we can retrieve the associated ?LABEL and so the
?SYNONYM-LABEL; then we can "follow through" ?SYNONYM-LABEL to retrieve
the actual binding descriptor associated to ?ID.


File: vicare-scheme.info,  Node: expander lexenv inspection,  Prev: expander lexenv synonyms,  Up: expander lexenv

15.3.9 Lexical environment inspection
-------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Function: syntactic-identifier->label ID
     Given the syntactic identifier ID search its sequence of 'rib' for
     a syntactic binding having the same source-name and marks.  If
     successful: return the syntactic binding's label gensym; otherwise
     return '#f'.

          (import (vicare) (prefix (vicare expander) xp::))

          (xp::syntactic-identifier->label #'display)
          => #{lab.display |PeEZ8c2>r<R&lTRg|}

 -- Function: label->syntactic-binding-descriptor LABEL LEXENV
     Look up the symbol LABEL in the LEXENV as well as in the global
     environment.  If an entry with key LABEL is found: return the
     associated syntactic binding descriptor; if no matching entry is
     found, return one of the special descriptors:

     '(displaced-lexical . #f)'
          If the LABEL is unbound in LEXENV.

     '(displaced-lexical . ())'
          If the argument LABEL is invalid.

     If the binding descriptor represents a fluid syntax or synonym
     syntax: follow through and return the innermost redefinition of the
     binding.

          (import (vicare) (prefix (vicare expander) xp::))

          (begin-for-syntax
            (xp::label->syntactic-binding-descriptor
                (xp::syntactic-identifier->label #'display)
                (xp::current-inferior-lexenv)))
          => (core-prim . display)

          (begin-for-syntax
            (xp::label->syntactic-binding-descriptor
                'label
                (xp::current-inferior-lexenv)))
          => (displaced-lexical . #f)

          (begin-for-syntax
            (xp::label->syntactic-binding-descriptor
                123
                (xp::current-inferior-lexenv)))
          => (displaced-lexical . ())

 -- Function: label->syntactic-binding-descriptor/no-indirection
     Like 'label->syntactic-binding-descriptor', but if the binding
     descriptor represents a fluid syntax or a synonym syntax: do *not*
     follow through; instead return the binding descriptor of the fluid
     or synonym syntax definition.

          (import (vicare)
             (prefix (vicare expander) xp::))

          (define-fluid-syntax flu
            (identifier-syntax 123))

          (begin-for-syntax
            (xp::label->syntactic-binding-descriptor
              (xp::syntactic-identifier->label #'flu)
              (xp::current-inferior-lexenv)))
          => (local-macro . (?procedure . ?sexp))

          (begin-for-syntax
            (xp::label->syntactic-binding-descriptor/no-indirection
              (xp::syntactic-identifier->label #'flu)
              (xp::current-inferior-lexenv)))
          => ($fluid . lab.flu)


File: vicare-scheme.info,  Node: expander utils,  Next: expander clauses,  Prev: expander lexenv,  Up: expander

15.4 Miscellaneous utilities
============================

* Menu:

* expander utils intro::        Introduction to utility functions.
* expander utils id::           Identifiers processing: generic functions.
* expander utils records::      Generating identifiers for records API.
* expander utils structs::      Generating identifiers for structs API.
* expander utils pairs::        Pairs processing.
* expander utils vectors::      Vectors processing.
* expander utils special::      Special processors.
* expander utils unwrap::       Unwrapping syntax objects.
* expander utils inspect::      Inspecting syntax objects.
* expander utils compar::       Comparing syntax objects.
* expander utils expanding::    Expanding forms.


File: vicare-scheme.info,  Node: expander utils intro,  Next: expander utils id,  Up: expander utils

15.4.1 Introduction to utility functions
----------------------------------------

Some functions accept an optional argument SYNNER: when used, it must be
a function accepting 1 or 2 arguments, the first argument being a string
error message and the optional second argument being a subform; SYNNER
must raise a compound condition object with components: '&who',
'&message', '&syntax'.  The SYNNER argument is meant to be used as
follows:

     (define-syntax (my-macro stx)
       (case-define synner
         ((message)
          (synner message #f))
         ((message subform)
          (syntax-violation 'my-macro message stx subform)))
       (syntax-case stx ()
         (pattern body)
         (_
          (synner "invalid syntax"))))


File: vicare-scheme.info,  Node: expander utils id,  Next: expander utils records,  Prev: expander utils intro,  Up: expander utils

15.4.2 Identifiers processing: generic functions
------------------------------------------------

 -- Function: identifier-bound? ID
     Return '#t' if the identifier ID is lexically bound; otherwise
     return '#f'.

          (identifier-bound? #'woppa-woppa-woppa)
          => #f

          (let ((ciao 123))
            (define-syntax (doit stx)
              (identifier-bound? #'ciao))
            (doit))
          => #t

          (let ((ciao 123))
            (define-syntax (doit stx)
              (syntax-case stx ()
                ((_ ?id)
                 (identifier-bound? #'?id))))
            (doit ciao))
          => #t

          (let ()
            (define ciao 123)
            (define-syntax (doit stx)
              (syntax-case stx ()
                ((_ ?id)
                 (identifier-bound? #'?id))))
            (doit ciao))
          => #t

          (let ()
            (let-syntax ((ciao (identifier-syntax 123)))
              (define-syntax (doit stx)
                (syntax-case stx ()
                  ((_ ?id)
                   (identifier-bound? #'?id))))
              (doit ciao)))
          => #t

 -- Function: identifier->string ID
     Return a string representing the name of the identifier ID.

 -- Function: string->identifier CTX STR
     Build and return a new identifier, in the same lexical context of
     CTX, having the string STR as name.

 -- Function: identifier-prefix PREFIX ID
     Build and return a new identifier, in the same lexical context of
     the identifier ID, whose string name is the concatenation of PREFIX
     and ID.  PREFIX can be a string, symbol or identifier.

          (import (vicare))

          (bound-identifier=? (identifier-prefix "this-" #'that)
                              #'this-that)
          => #t

 -- Function: identifier-suffix ID SUFFIX
     Build and return a new identifier, in the same lexical context of
     the identifier ID, whose string name is the concatenation of ID and
     SUFFIX.  SUFFIX can be a string, symbol or identifier.

          (bound-identifier=? (identifier-suffix #'this "-that")
                              #'this-that)
          => #t

 -- Function: identifier-append CTX ITEM ...
     Build and return a new identifier, in the same lexical context of
     the identifier CTX, whose string name is the concatenation of the
     arguments ITEM.  Each ITEM can be a string, symbol or identifier.

          (bound-identifier=? (identifier-append #'this "-that" '-those)
                              #'this-that-those)
          => #t

 -- Function: identifier-format CTX TEMPLATE ITEM ...
     Build and return a new identifier, in the same lexical context of
     the identifier CTX, whose string name is the result of formatting
     the string TEMPLATE with the arguments ITEM.  TEMPLATE can be a
     string including the same escape sequences of 'format' from
     '(vicare)' (*note format: iklib printing.).  Each ITEM can be a
     string, symbol or identifier.

          (bound-identifier=?
           (identifier-format #'here "~a-~a-~a" #'this "that" 'those)
           #'this-that-those)
          => #t

 -- Function: duplicate-identifiers? IDS
 -- Function: duplicate-identifiers? IDS IDENTIFIER=
     Search the list of identifiers IDS for duplicate identifiers; at
     the first duplicate found, return it; return '#f' if no
     duplications are found.

     The optional argument IDENTIFIER= must be the predicate function
     used to compare identifiers; when not given it defaults to
     'free-identifier=?'.

 -- Function: delete-duplicate-identifiers IDS
 -- Function: delete-duplicate-identifiers IDS IDENTIFIER=
     Given the list of identifiers IDS remove the duplicate identifiers
     and return a proper list of unique identifiers.

     The optional argument IDENTIFIER= must be the predicate function
     used to compare identifiers; when not given it defaults to
     'free-identifier=?'.

 -- Function: identifier-memq ID IDS
 -- Function: identifier-memq ID IDS IDENTIFIER=
     Search the list of identifiers IDS for one that matches ID and
     return the sublist starting with it; return '#f' if ID is not
     present.

     The optional argument IDENTIFIER= must be the predicate function
     used to compare identifiers; when not given it defaults to
     'free-identifier=?'.

 -- Syntax: with-implicits ((?CTX ?SYMBOL ...) ...) . ?BODY
     Wrapper for 'with-syntax' which defines the identifiers ?SYMBOL
     with the same context of ?CTX.  ?CTX must be an expression
     evaluating to an identifier; it is evaluated only once.  ?SYMBOL
     must be Scheme symbols.

     For example:

          (syntax-case stx ()
            ((id)
             (identifier? #'id)
             (with-implicits ((#'id x y))
               #'(list x y))))

     is equivalent to:

          (syntax-case stx ()
            ((id)
             (identifier? #'id)
             (with-syntax ((x (datum->syntax #'id 'x))
                           (y (datum->syntax #'id 'y)))
               #'(list x y))))

          *NOTE* This macro is derived from the one documented in the
          Chez Scheme User's Guide.


File: vicare-scheme.info,  Node: expander utils records,  Next: expander utils structs,  Prev: expander utils id,  Up: expander utils

15.4.3 Generating identifiers for records API
---------------------------------------------

 -- Function: identifier-record-constructor TYPE-ID
     Assume TYPE-ID is an identifier representing the name of a R6RS
     record type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default constructor name for
     such record type.

          (bound-identifier=?
           (identifier-record-constructor #'alpha)
           #'make-alpha)
          => #t

 -- Function: identifier-record-predicate TYPE-ID
     Assume TYPE-ID is an identifier representing the name of a R6RS
     record type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default predicate name for
     such record type.

          (bound-identifier=?
           (identifier-record-predicate #'alpha)
           #'alpha?)
          => #t

 -- Function: identifier-record-field-accessor TYPE-ID FIELD-NAME
     Assume TYPE-ID is an identifier representing the name of a R6RS
     record type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default accessor name for the
     field FIELD-NAME of such record type.  FIELD-NAME can be a string,
     symbol or identifier.

          (bound-identifier=?
           (identifier-record-field-accessor #'alpha "one")
           #'alpha-one)
          => #t

 -- Function: identifier-record-field-mutator TYPE-ID FIELD-NAME
     Assume TYPE-ID is an identifier representing the name of a R6RS
     record type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default mutator name for the
     field FIELD-NAME of such record type.  FIELD-NAME can be a string,
     symbol or identifier.

          (bound-identifier=?
           (identifier-record-field-mutator #'alpha "one")
           #'alpha-one-set!)
          => #t


File: vicare-scheme.info,  Node: expander utils structs,  Next: expander utils pairs,  Prev: expander utils records,  Up: expander utils

15.4.4 Generating identifiers for structs API
---------------------------------------------

 -- Function: identifier-struct-constructor TYPE-ID
     Assume TYPE-ID is an identifier representing the name of a Vicare
     struct type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default constructor name for
     such struct type.

          (bound-identifier=?
           (identifier-struct-constructor #'alpha)
           #'make-alpha)
          => #t

 -- Function: identifier-struct-predicate TYPE-ID
     Assume TYPE-ID is an identifier representing the name of a Vicare
     struct type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default predicate name for
     such struct type.

          (bound-identifier=?
           (identifier-struct-predicate #'alpha)
           #'alpha?)
          => #t

 -- Function: identifier-struct-field-accessor TYPE-ID FIELD-NAME
     Assume TYPE-ID is an identifier representing the name of a Vicare
     struct type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default accessor name for the
     field FIELD-NAME of such struct type.  FIELD-NAME can be a string,
     symbol or identifier.

          (bound-identifier=?
           (identifier-struct-field-accessor #'alpha "one")
           #'alpha-one)
          => #t

 -- Function: identifier-struct-field-mutator TYPE-ID FIELD-NAME
     Assume TYPE-ID is an identifier representing the name of a Vicare
     struct type: build and return a new identifer, in the same lexical
     context of TYPE-ID, representing the default mutator name for the
     field FIELD-NAME of such struct type.  FIELD-NAME can be a string,
     symbol or identifier.

          (bound-identifier=?
           (identifier-struct-field-mutator #'alpha "one")
           #'set-alpha-one!)
          => #t


File: vicare-scheme.info,  Node: expander utils pairs,  Next: expander utils vectors,  Prev: expander utils structs,  Up: expander utils

15.4.5 Pairs processing
-----------------------

 -- Function: syntax-car STX
 -- Function: syntax-car STX SYNNER
     Expect STX to be a syntax object holding pair; return a syntax
     object representing the car of STX.

          (bound-identifier=? (syntax-car #'(display . write))
                              #'display)
          => #t

 -- Function: syntax-cdr STX
 -- Function: syntax-cdr STX SYNNER
     Expect STX to be a syntax object holding pair; return a syntax
     object representing the cdr of STX.

          (bound-identifier=? (syntax-cdr #'(display . write))
                              #'write)
          => #t

 -- Function: syntax->list STX
 -- Function: syntax->list STX SYNNER
     Expect STX to be a syntax object holding a proper list of items;
     return a proper list holding the individual item syntax objects.

          (for-all (lambda (obj1 obj2)
                     (if (identifier? obj2)
                         (bound-identifier=? obj1 obj2)
                       (equal? obj1 obj2)))
            (syntax->list #'(display 123 write))
            (list #'display 123 #'write))
          => #t

 -- Function: identifiers->list STX
 -- Function: identifiers->list STX SYNNER
     Expect STX to be a syntax object holding a proper list of
     identifiers; return a proper list holding the individual
     identifiers.

          (for-all bound-identifier=?
            (identifiers->list #'(display write))
            (list #'display #'write))
          => #t

 -- Function: all-identifiers? STX
     Return '#t' if STX is a syntax object representing the empty list
     or a proper list of identifiers, otherwise return '#f'.


File: vicare-scheme.info,  Node: expander utils vectors,  Next: expander utils special,  Prev: expander utils pairs,  Up: expander utils

15.4.6 Vectors processing
-------------------------

 -- Function: syntax->vector STX
 -- Function: syntax->vector STX SYNNER
     Expect STX to be a syntax object holding a vector of items; return
     a proper list holding the individual item syntax objects.

          (vector-for-all
              (lambda (obj1 obj2)
                (if (identifier? obj2)
                    (bound-identifier=? obj1 obj2)
                  (equal? obj1 obj2)))
            (syntax->vector #'#(display 123 write))
            (vector #'display 123 #'write))
          => #t


File: vicare-scheme.info,  Node: expander utils special,  Next: expander utils unwrap,  Prev: expander utils vectors,  Up: expander utils

15.4.7 Special processors
-------------------------

 -- Function: parse-logic-predicate-syntax STX
 -- Function: parse-logic-predicate-syntax STX TAIL-PROC
     Given a syntax object STX parse it as logic predicate expression
     with expected format:

          STX = (and ?EXPR0 ?EXPR ...)
              | (or  ?EXPR0 ?EXPR ...)
              | (xor ?EXPR0 ?EXPR ...)
              | (not ?EXPR)
              | ?EXPR

     where 'and', 'or', 'xor', 'not' are the identifiers exported by
     '(vicare)'.  If a standalone ?EXPR is found: apply the procedure
     TAIL-PROC to it gather its single return value; TAIL-PROC defaults
     to the identity function.

     Return a syntax object representing the logic predicate with the
     standalone expressions replaced by the return values of TAIL-PROC.

          (define (tail-proc stx)
            (syntax-case stx ()
              ((?expr0 ?expr ...)
               #`(or #,@(map (lambda (expr)
                               (parse-logic-predicate-syntax
                                  expr tail-proc))
                          (syntax->list #'(?expr0 ?expr ...)))))
              (_
               (list #'here stx))))

          (define-syntax-rule (doit ?input)
            (parse-logic-predicate-syntax (syntax ?input) tail-proc))

          (doit (and 1 2))
          => #'(and (here 1) (here 2))

          (doit (or 1 2))
          => #'(or (here 1) (here 2))

          (doit (xor 1 2)
          => #'(xor (here 1) (here 2))

          (doit (not 1))
          => (not (here 1))

          (doit (and (xor (not 1) 2)
                     (or  (not 3) 4)))
          => #'(and (xor (not (here 1)) (here 2))
                    (or  (not (here 3)) (here 4)))

          (doit (1 2))
          => #'(or (here 1) (here 2))


File: vicare-scheme.info,  Node: expander utils unwrap,  Next: expander utils inspect,  Prev: expander utils special,  Up: expander utils

15.4.8 Unwrapping syntax objects
--------------------------------

 -- Function: syntax-unwrap STX
     Given a syntax object STX decompose it and return the corresponding
     symbolic expression holding datums and identifiers.  Take care of
     returning a proper list when the input is a syntax object holding a
     proper list.

 -- Function: syntax-replace-id STX SRC DST
     Replace every occurrence of the identifier SRC in STX with the
     identifier DST.  Return the resulting fully unwrapped syntax
     object.


File: vicare-scheme.info,  Node: expander utils inspect,  Next: expander utils compar,  Prev: expander utils unwrap,  Up: expander utils

15.4.9 Inspecting syntax objects
--------------------------------


File: vicare-scheme.info,  Node: expander utils compar,  Next: expander utils expanding,  Prev: expander utils inspect,  Up: expander utils

15.4.10 Comparing syntax objects
--------------------------------

 -- Function: syntax=? STX1 STX2
     Recursively visit the internals of the given syntax objects and
     return '#t' if they are equal; return '#f' otherwise.  Identifiers
     are compared with 'free-identifier=?'.

 -- Function: identifier=symbol? ID SYM
     Return true if the symbol SYM is equal to the symbol name of the
     identifier ID.


File: vicare-scheme.info,  Node: expander utils expanding,  Prev: expander utils compar,  Up: expander utils

15.4.11 Expanding forms
-----------------------

The following bindings are exported by the library '(vicare expander)'.

 -- Function: expand-form-to-core-language SEXP ENV
     Interface to the internal expression expander, it is the expansion
     engine used by R6RS's 'eval' function.

     SEXP must be a symbolic expression representing a Scheme form; ENV
     must be an evaluation environment.

     Return two values: the result of the expansion as symbolic
     expression in the core language; a list of libraries that must be
     invoked before evaluating the returned expression.

     Example:

          (import (vicare)
            (prefix (vicare expander) xp::))

          (receive (code libs)
               (xp::expand-form-to-core-language
                  '(define (doit x)
                     (if (null? x)
                         #f
                       (doit (cdr x))))
                  (environment '(vicare)))
            code)
          => (set! loc.doit
               (annotated-case-lambda doit
                 ((lex.x)
                  (if (annotated-call (null? x)
                        (primitive null?) lex.x)
                      '#f
                  (annotated-call (doit (cdr x))
                    loc.doit
                    (annotated-call (cdr x) (primitive cdr) lex.x))))))


File: vicare-scheme.info,  Node: expander clauses,  Next: expander system-labels,  Prev: expander utils,  Up: expander

15.5 Syntax clauses helpers
===========================

When writing definition macros similar to 'define-record-type' it is
quite useful to include in the syntax "clauses" that optionally specify
the behaviour of the defined thing.  A list of clauses is a syntax
object with the format:

     ((?IDENTIFIER ?THING ...) ...)

in which ?IDENTIFIER is meant to be an auxiliary syntax (as defined by
'define-auxiliary-syntaxes' or 'define-syntax') and the optional ?THING
arguments can represent any symbolic expression.  The functions
documented in this section help in validating and processing such
clauses.

* Menu:

* expander clauses intro::    Introduction to clauses functions.
* expander clauses utils::    Syntax clauses utilities.
* expander clauses constr::   Syntax clauses constraints.
* expander clauses objects::  Clause specification objects.


File: vicare-scheme.info,  Node: expander clauses intro,  Next: expander clauses utils,  Up: expander clauses

15.5.1 Introduction to clauses functions
----------------------------------------

Some functions accept an optional argument SYNNER: when used, it must be
a function accepting 1 or 2 arguments, the first argument being a string
error message and the optional second argument being a subform; SYNNER
must raise a compound condition object with components: '&who',
'&message', '&syntax'.  The SYNNER argument is meant to be used as
follows:

     (define-syntax (my-macro stx)
       (case-define synner
         ((message)
          (synner message #f))
         ((message subform)
          (syntax-violation 'my-macro message stx subform)))
       (syntax-case stx ()
         (pattern body)
         (_
          (synner "invalid syntax"))))


File: vicare-scheme.info,  Node: expander clauses utils,  Next: expander clauses constr,  Prev: expander clauses intro,  Up: expander clauses

15.5.2 Syntax clauses utilities
-------------------------------

 -- Function: syntax-clauses-unwrap CLAUSES
 -- Function: syntax-clauses-unwrap CLAUSES SYNNER
     Scan the syntax object CLAUSES expecting it to represent a list of
     clauses; return a new syntax object representing CLAUSES fully
     unwrapped.  The function SYNNER is invoked if the structure of
     CLAUSES is invalid.

 -- Function: syntax-clauses-filter KEYWORDS UNWRAPPED-CLAUSES
     Given a fully unwrapped syntax object UNWRAPPED-CLAUSES holding a
     list of clauses (for example the return value of
     'syntax-clauses-unwrap') select the ones having ?IDENTIFIER being
     'free-identifier=?' to an identifier in the list KEYWORDS and
     return the selected clauses in a fully unwrapped syntax object
     holding the list of them; return null if no matching clause is
     found.

 -- Function: syntax-clauses-remove KEYWORDS UNWRAPPED-CLAUSES
     Given a fully unwrapped syntax object UNWRAPPED-CLAUSES holding a
     list of clauses (for example the return value of
     'syntax-clauses-unwrap') remove the ones having ?IDENTIFIER being
     'free-identifier=?' to an identifier in the list KEYWORDS and
     return the selected clauses in a fully unwrapped syntax object
     holding the list of them; return null if no matching clause is
     found.

 -- Function: syntax-clauses-partition KEYWORDS UNWRAPPED-CLAUSES
     Given a fully unwrapped syntax object UNWRAPPED-CLAUSES holding a
     list of clauses (for example the return value of
     'syntax-clauses-unwrap') partition it into: a list of clauses
     having ?IDENTIFIER being 'free-identifier=?' to an identifier in
     the list KEYWORDS, a list of non-matching clauses.  Return the two
     lists.

     This function can be used to check that a list of clauses only
     contains clauses with selected identifiers.

 -- Function: syntax-clauses-collapse UNWRAPPED-CLAUSES
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap'): collapse
     the clauses having equal ?IDENTIFIER into a single clause and
     return the resulting unwrapped syntax object.  Example:

          (syntax-clauses-collapse ((#'fields #'a #'b #'c)
                                    (#'fields #'d #'e #'f)))
          => ((#'fields #'a #'b #'c #'d #'e #'f))


File: vicare-scheme.info,  Node: expander clauses constr,  Next: expander clauses objects,  Prev: expander clauses utils,  Up: expander clauses

15.5.3 Syntax clauses constraints
---------------------------------

 -- Function: syntax-clauses-verify-at-least-once KEYWORDS
          UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-verify-at-least-once KEYWORDS
          UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify
     that all the identifiers in the list KEYWORDS are present at least
     once as clause identifiers.  If successful return unspecified
     values, else call SYNNER or raise a '&syntax' violation exception.

 -- Function: syntax-clauses-verify-at-most-once KEYWORDS
          UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-verify-at-most-once KEYWORDS
          UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify
     that all the identifiers in the list KEYWORDS are present at most
     once as clause identifiers.  If successful return unspecified
     values, else call SYNNER or raise a '&syntax' violation exception.

 -- Function: syntax-clauses-verify-exactly-once KEYWORDS
          UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-verify-exactly-once KEYWORDS
          UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify
     that all the identifiers in the list KEYWORDS are present exactly
     once as clause identifiers.  If successful return unspecified
     values, else call SYNNER or raise a '&syntax' violation exception.

 -- Function: syntax-clauses-verify-mutually-inclusive KEYWORDS
          UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-verify-mutually-inclusive KEYWORDS
          UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify
     that if one of the identifiers in the list KEYWORDS is present at
     least once as clause identifier, then all the others are present
     too.  If successful return unspecified values, else call SYNNER or
     raise a '&syntax' violation exception.

 -- Function: syntax-clauses-verify-mutually-exclusive KEYWORDS
          UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-verify-mutually-exclusive KEYWORDS
          UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify
     that if one of the identifiers in the list KEYWORDS is present at
     least once as clause identifier, then all the others are *not*
     present.  If successful return unspecified values, else call SYNNER
     or raise a '&syntax' violation exception.


File: vicare-scheme.info,  Node: expander clauses objects,  Prev: expander clauses constr,  Up: expander clauses

15.5.4 Clause specification objects
-----------------------------------

Clause specification objects are opaque objects, disjoint from all the
other Scheme object types, representing the constraints enforceable on a
syntax clause.

 -- Object Type: <syntax-clause-spec>
     Type of objects representing a syntax clause specification.

 -- Function: make-syntax-clause-spec KEYWORD MIN-OCCUR MAX-OCCUR
          MIN-ARGS MAX-ARGS MUTUALLY-INCLUSIVE MUTUALLY-EXCLUSIVE
 -- Function: make-syntax-clause-spec KEYWORD MIN-OCCUR MAX-OCCUR
          MIN-ARGS MAX-ARGS MUTUALLY-INCLUSIVE MUTUALLY-EXCLUSIVE
          CUSTOM-DATA
     Build and return a new syntax clause specification object.  The
     arguments are:

     KEYWORD
          An identifier representing the keyword for this clause.

     MIN-OCCUR
          A non-negative real number representing the allowed minimum
          number of occurrences for this clause.  '0' means the clause
          is optional; '1' means the clause is mandatory.

     MAX-OCCUR
          A non-negative real number representing the allowed maximum
          number of occurrences for this clause.  '0' means the clause
          is forbidden; '1' means the clause must appear at most once;
          '+inf.0' means the clause can appear any number of times.

     MIN-ARGS
          A non-negative real number representing the allowed minimum
          number of arguments for this clause.  '0' means the clause can
          have no arguments; '1' means the clause must have at least one
          argument.

     MAX-ARGS
          A non-negative real number representing the allowed maximum
          number of arguments for this clause.  '0' means the clause has
          no arguments; '1' means the clause must have at most one
          arguments; '+inf.0' means the clause can have any number of
          arguments.

     MUTUALLY-INCLUSIVE
          A list identifiers representing clauses keywords that must
          appear along with this one.

     MUTUALLY-EXCLUSIVE
          A list identifiers representing clauses keywords that must not
          appear along with this one.

     CUSTOM-DATA
          Optional free value available for the user.  It is initialised
          to '#f'.

 -- Function: syntax-clause-spec? OBJ
     Return '#t' if OBJ is a syntax clause specification object,
     otherwise return '#f'.

 -- Function: syntax-clause-spec-keyword SPEC
 -- Function: syntax-clause-spec-min-number-of-occurrences SPEC
 -- Function: syntax-clause-spec-max-number-of-occurrences SPEC
 -- Function: syntax-clause-spec-min-number-of-arguments SPEC
 -- Function: syntax-clause-spec-max-number-of-arguments SPEC
 -- Function: syntax-clause-spec-mutually-inclusive SPEC
 -- Function: syntax-clause-spec-mutually-exclusive SPEC
 -- Function: syntax-clause-spec-custom-data SPEC
     Accessors for the fields of syntax clause specification objects.

 -- Function: syntax-clauses-single-spec SPEC UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-single-spec SPEC UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify if
     there are clauses conforming to the given specification SPEC.

     If successful return a (possibly empty) vector of vectors of syntax
     objects; else call SYNNER or raise a '&syntax' exception.  The
     length of the returned vector is the number of clauses from
     UNWRAPPED-CLAUSES conforming to SPEC.  Each nested vector
     represents the cdr of a clause matching SPEC:

        * If a clause has no arguments: the corresponding nested vector
          is empty.

        * If a clause has 1 argument: the corresponding nested vector
          has 1 item being the syntax object representing the argument.

        * If a clause has N arguments: the corresponding nested vector
          has N items being the syntax objects representing the
          arguments.

     Examples:

          (import (vicare))

          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 1 1 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 456)
                                       (d 789))))
          => #(#(456))

          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b)
                                       (d 789))))
          => #(#())

          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4 5 6)
                                       (d 789))))
          => #(#(4 5 6))

          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4)
                                       (b 5)
                                       (b 6)
                                       (d 789))))
          => #(#(4) #(5) #(6))

          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4 4.1)
                                       (b 5 5.1)
                                       (d 789))))
          => #(#(4 4.1) #(5 5.1))

          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4 ciao 6)
                                       (d 789))))
          => #(#(4 #<syntax-object expr=ciao> 6))

 -- Function: syntax-clauses-fold-specs COMBINE KNIL SPECS
          UNWRAPPED-CLAUSES
 -- Function: syntax-clauses-fold-specs COMBINE KNIL SPECS
          UNWRAPPED-CLAUSES SYNNER
     Given a fully unwrapped syntax object holding a list of clauses
     (for example the return value of 'syntax-clauses-unwrap') verify
     that the clauses conform to the given SPECS, which must be a list
     of syntax clause specification objects.

     Combine the clause arguments with the given KNIL in a 'fold-left'
     fashion, if successful return the resulting KNIL; if an invalid
     clause is found call SYNNER or raise a '&syntax' object.

     The operation is conceptually as follows:

          (fold-left
              (lambda (knil spec)
                (let ((args (syntax-clauses-single-spec spec
                               UNWRAPPED-CLAUSES SYNNER)))
                  (if (fxzero? (vector-length args))
                      knil
                    (COMBINE knil spec args))))
            KNIL
            SPECS)

     notice that COMBINE is called only if a clause from SPECS is
     present in UNWRAPPED-CLAUSES; COMBINE must return the new value for
     KNIL.

 -- Function: syntax-clauses-validate-specs LIST-OF-SPECS
     Given a list of 'syntax-clause-spec' objects: perform some
     validations among them.  If successful return LIST-OF-SPECS itself,
     otherwise raise an assertion violation.

     The following checks are performed:

        * For every identifier listed in the 'mutually-inclusive' field
          of every 'syntax-clause-spec': check that such identifier is
          equal, according to 'free-identifier=?', to an identifier in
          the 'keyword' field of another 'syntax-clause-spec' object.

        * For every identifier listed in the 'mutually-exclusive' field
          of every 'syntax-clause-spec': check that such identifier is
          equal, according to 'free-identifier=?', to an identifier in
          the 'keyword' field of another 'syntax-clause-spec' object.


File: vicare-scheme.info,  Node: expander system-labels,  Next: expander system-identifiers,  Prev: expander clauses,  Up: expander

15.6 Retrieving syntactic binding labels
========================================

Every core primitive has a name that is considered part of Vicare's core
language; such primitive name is the actual public name of the binding
exported by the boot image.  The name of the function 'display' is the
symbol 'display'; the name of the record-type descriptor
'&condition-rtd' is the symbol '&condition-rtd'.

   Every core primitive syntactic binding has a unique "label" gensym
associated to it; the label is used to map core primitive's syntactic
identifiers to syntactic binding's decriptors in the lexical
environment.

   The property list of the name contains a special entry whose value is
the label gensym of the core primitive syntactic binding; we can easily
inspect such situation as follows:

     (import (vicare)
       (prefix (vicare expander) xp::))

     (getprop 'display (xp::system-label-gensym))
     => lab.display

     ;; extract the lexical environment entry describing DISPLAY
     (symbol-value (getprop 'display (xp::system-label-gensym)))
     => (core-prim . display)

     (xp::system-label 'display)
     => lab.display

   We see that the property list contains an entry with key set to the
symbol returned by 'system-label-gensym'; notice that this key is
different every time we rebuild the boot image.

 -- Function: system-label SYMBOL
     Attempt to extract from SYMBOL the core primitive syntactic binding
     label of which SYMBOL is the name; if successful return the label,
     else return '#f'.

 -- Function: system-label-gensym
     Return a special gensym used internally to map core primitive names
     to their syntactic binding label gensym.


File: vicare-scheme.info,  Node: expander system-identifiers,  Next: expander examples,  Prev: expander system-labels,  Up: expander

15.7 Retrieving syntactic binding identifiers
=============================================

Every core primitive has a name that is considered part of Vicare's core
language; such primitive name is the actual public name of the binding
exported by the boot image.  The name of the function 'display' is the
symbol 'display'; the name of the record-type descriptor
'&condition-rtd' is the symbol '&condition-rtd'.

   Some internal operations generate a syntactic identifier bound to a
core primitive and store it in the property list of the public primitive
name; we can easily inspect such situation as follows:

     (import (vicare)
       (prefix (vicare expander) xp::))

     (getprop 'procedure? (xp::system-id-gensym))
     => #<syntax expr=procedure? ...>

     (xp::system-id 'procedure?)
     => #<syntax expr=procedure? ...>

   We see that the property list contains an entry with key set to the
return value of 'system-id-gensym'; notice that this key is different
every time we rebuild the boot image.

 -- Function: system-id SYMBOL
     Attempt to extract from SYMBOL the bound identifier of which SYMBOL
     is the name; if successful return the label, else return '#f'.

 -- Function: system-id-gensym
     Return a special gensym used internally to map core primitive names
     to their syntactic binding identifiers.


File: vicare-scheme.info,  Node: expander examples,  Next: expander specs,  Prev: expander system-identifiers,  Up: expander

15.8 Expansion and expander inspection examples
===============================================

* Menu:

* expander examples intro::     Introduction, prelude and postlude.
* expander examples top-level:: The top-level lexical environment.
* expander examples contours::  Lexical contours inspection.
* expander examples phases::    Expansion and evaluation phases.


File: vicare-scheme.info,  Node: expander examples intro,  Next: expander examples top-level,  Up: expander examples

15.8.1 Prelude and postlude
---------------------------

All the examples are given as executable code, but when the output of
the pretty printer is shown: it is edited for readability.

   Unless otherwise specified, all the examples are R6RS programs,
starting with the prelude:

     (import (vicare)
       (prefix (vicare expander) xp::))

     (begin-for-syntax

       (define (id->label id)
         (xp::syntactic-identifier->label id))

       (define (label->descriptor lab)
         (xp::label->syntactic-binding-descriptor lab
           (xp::current-inferior-lexenv)))

       (define (id->descriptor id)
         (label->descriptor (id->label id)))

       (define (id-rib*/no-top id)
         (reverse (cdr (reverse (xp::stx-rib* id)))))

       (define (eq-ribs? id1 id2)
         (eq? (xp::stx-rib* id1) (xp::stx-rib* id2)))

       #| end of BEGIN-FOR-SYNTAX |# )

and ending with the postlude:

     (begin-for-syntax
       (flush-output-port (current-output-port)))
     (flush-output-port (current-output-port))


File: vicare-scheme.info,  Node: expander examples top-level,  Next: expander examples contours,  Prev: expander examples intro,  Up: expander examples

15.8.2 The top-level lexical environment
----------------------------------------

The syntactic bindings established by the 'import' clause of programs
and libraries are stored in a 'rib' object; this 'rib' represents the
"top-level environment" and it is referred to as "top-level 'rib'".  The
descriptors of top-level syntactic bindings are stored in the 'value'
field of their label gensyms.

   We can look at a syntactic identifier as follows:

     (begin-for-syntax
       (pretty-print #'display))
     -| #<syntactic-identifier expr=display mark*=(src)>

we see that: the source-name symbol is 'display'; the list of marks is
'(src)'; the list of 'rib' objects is not displayed, because it is too
long.  We can inspect the list of 'rib' objects too:

     (begin-for-syntax
       (pretty-print (xp::stx-rib* #'display)))
     -| (#<rib name*=(...) mark**=(...) label*=(...) sealed/freq=#f>)

we do not show the full output, because it is really long: the list of
ribs contains a single item being the top-level 'rib' of the program;
this top 'rib' contains a tuple for every syntactic binding imported in
the program.

   We can retrieve the elements of syntactic bindings from the top
'rib':

     (begin-for-syntax
       (pretty-print (id->label #'display)))
     -| lab.display

     (begin-for-syntax
       (pretty-print (id->descriptor #'display)))
     -| (core-prim . display)

   If we define a lexical variable at the top-level of the program, we
can then query its syntactic binding:

     (define A 1)

     (begin-for-syntax
       (pretty-print (id->label      #'A))
       (pretty-print (id->descriptor #'A)))
     -| lab.A
     -| (lexical . (lex.A . #f))

   In the following examples: we avoid defining top-level bindings
because printing the top 'rib' is annoying; for this reason we use the
function 'id-rib*/no-top' which cuts out the top 'rib' from a list of
'rib' objects (the top 'rib' is always the last item in a list of ribs).


File: vicare-scheme.info,  Node: expander examples contours,  Next: expander examples phases,  Prev: expander examples top-level,  Up: expander examples

15.8.3 Lexical contours inspection
----------------------------------

We will inspect the fields of '<stx>' objects and 'rib' objects to
understand how the lexical environment's data structures are used to
represent lexical contours.

   We will examine the expansion of nested 'internal-body' uses: these
syntaxes are the simplest because they create a single lexical contour.
We will inspect the syntactic identifiers and 'rib' objects from the
body of a 'begin-for-syntax' use.

* Menu:

* expander examples contours single::  Single internal body.
* expander examples contours double::  Double internal body.
* expander examples contours datum::   What 'datum->syntax' does.


File: vicare-scheme.info,  Node: expander examples contours single,  Next: expander examples contours double,  Up: expander examples contours

15.8.3.1 Single internal body
.............................

Let's create a single lexical contour with the syntax 'internal-body'
and compare a top-level binding with a local binding:

     (define A 1)
     (internal-body
       (define B 2)
       (begin-for-syntax
         (pretty-print (syntax A))
         (pretty-print (syntax B))
         (pretty-print (eq-ribs? (syntax A) (syntax B))))
       (void))
     -| #<syntactic-identifier expr=A mark*=(src)>
     -| #<syntactic-identifier expr=B mark*=(src)>
     -| #t

we see that the syntactic identifiers created by 'syntax' in the
'begin-for-syntax' have the same list of marks and the same list of
'rib' objects.

   Let's see the 'rib' objects:

     (define A 1)
     (internal-body
       (define B 2)
       (begin-for-syntax
         (let ((ribs (xp::stx-rib* #'A)))
           (pretty-print (length ribs))
           (pretty-print ribs)))
       (void))
     -| 2
     -| (#<rib name*=(B)     mark**=((src))     label*=(lab.B)>
         #<rib name*=(A ...) mark**=((src) ...) label*=(lab.A ...)>)

the list of 'rib' objects in the identifier '(syntax A)' has two items:
the first is the 'rib' associated to 'internal-body'; the second is the
top 'rib'.  We see the internal 'rib' holds a single tuple describing
the syntactic binding for 'B'; the syntactic binding for 'A' is in the
top 'rib'.

   With this layout we can understand what the function 'id->label' does
in the call:

     (define A 1)
     (internal-body
       (begin-for-syntax
         (pretty-print (id->label #'A)))
       (void))
     -| lab.A

it extracts from its argument the symbol source-name 'A', the list of
marks '(src)' and the list of 'rib' objects, then it scans the list of
'rib' objects left-to-right looking for a tuple whose source-name is
'eq?' to 'A' and whose list of marks is 'equal?' to '(src)'; it finds
one in the top 'rib'.

   This action of looking for a 'rib''s tuple with the same source-name
and the same marks is the "syntactic identifier resolution", and we say
that the tuple "captures" the identifier.

   This is not the whole story: to handle macro expansion we need more
than this; but for lexical contours: building a list of 'rib' objects
and using a single mark is enough.


File: vicare-scheme.info,  Node: expander examples contours double,  Next: expander examples contours datum,  Prev: expander examples contours single,  Up: expander examples contours

15.8.3.2 Double internal body
.............................

Let's create two nested lexical contours with the syntax 'internal-body'
and inspect the 'rib' objects:

     (internal-body
       (define A 1)
       (internal-body
         (define B 2)
         (begin-for-syntax
           (pretty-print #'A)
           (pretty-print #'B)
           (pretty-print (eq-ribs? #'A #'B))
           (pretty-print (length (xp::stx-rib* #'A)))
           (pretty-print (id-rib*/no-top #'A)))
         (void)))
     -| #<syntactic-identifier expr=A mark*=(src)>
     -| #<syntactic-identifier expr=B mark*=(src)>
     -| #t
     -| 3
     -| (#<rib name*=(B) mark**=((src)) label*=(lab.B)>
         #<rib name*=(A) mark**=((src)) label*=(lab.A)>)

we see that:

   * Both '#'A' and '#'B' have the same marks and 'rib' objects.

   * '#'A' and '#'B' build identifiers whose list of 'rib' objects has 3
     items: the 'rib' of the internal 'internal-body'; the 'rib' of the
     external 'internal-body'; the top 'rib', which we have cut out
     using 'id-rib*/no-top'.

   * The 'rib' of the internal 'internal-body' comes first in the list
     of 'rib' objects and it has the tuple of 'B'.

   * The 'rib' of the external 'internal-body' comes second in the list
     of 'rib' objects and it has the tuple of 'A'.

   It is simple to resolve the identifiers:

     (internal-body
       (define A 1)
       (internal-body
         (define B 2)
         (begin-for-syntax
           (pretty-print (id->label #'A))
           (pretty-print (id->label #'B))
           (pretty-print (id->descriptor #'A))
           (pretty-print (id->descriptor #'B)))
         (void)))
     -| lab.A
     -| lab.B
     -| (lexical . (lex.A . #f))
     -| (lexical . (lex.B . #f))

   Now let's create two syntactic bindings with the same source name:

     (internal-body
       (define A 1)
       (internal-body
         (define A 2)
         (begin-for-syntax
           (pretty-print #'A)
           (pretty-print (length (xp::stx-rib* #'A)))
           (pretty-print (id-rib*/no-top #'A)))
         (void)))
     -| #<syntactic-identifier expr=A mark*=(src)>
     -| 3
     -| (#<rib name*=(A) mark**=((src)) label*=(lab.A.2)>
         #<rib name*=(A) mark**=((src)) label*=(lab.A.1)>)

we see that both the 'rib' objects in the list of '#'A' have a tuple
with source-name 'A' and marks '(src)', but the 'rib' of the internal
'internal-body' comes first; so the internal syntactic binding for 'A'
is the one that captures the identifier:

     (internal-body
       (define A 1)
       (internal-body
         (define A 2)
         (begin-for-syntax
           (pretty-print (id->label #'A)))
         (void)))
     -| lab.A.2

   Without describing how macros work, let's see how we can introduce in
the internal body a syntactic identifier that is captured by the
external syntactic binding:

     (internal-body
       (define A 1)
       (define-syntax (doit stx)
         #'A)
       (internal-body
         (define A 2)
         (pretty-print (doit))))
     -| 1


File: vicare-scheme.info,  Node: expander examples contours datum,  Prev: expander examples contours double,  Up: expander examples contours

15.8.3.3 What 'datum->syntax' does
..................................

Armed with our understanding of lists of 'rib' objects as representation
of nested lexical contours, we can understand what the standard
procedure 'datum->syntax' does (*note datum->syntax: stdlib syntax-case
conversion.).  Let's see this example:

     (internal-body
       (define A 1)
       (begin-for-syntax
         (define B.id (datum->syntax #'A 'B))
         (pretty-print #'A)
         (pretty-print B.id)
         (pretty-print (eq-ribs? #'A B.id)))
       (void))
     -| #<syntactic-identifier expr=A mark*=(src)>
     -| #<syntactic-identifier expr=B mark*=(src)>
     -| #t

'datum->syntax' builds a new '<stx>' using its DATUM argument as
symbolic expression and the marks and 'rib' list of its TEMPLATE-ID
argument as wraps.

   'datum->syntax' does not care if it generates a syntax objects with
unbound identifiers in reference position:

     (internal-body
       (define A 1)
       (begin-for-syntax
         (define B.id (datum->syntax #'A 'B))
         (pretty-print (id->label      B.id))
         (pretty-print (id->descriptor B.id)))
       (void))
     -| #f
     -| (displaced-lexical . ())

it is only if we use the generated syntax object as part of the output
form of a macro use that the "boundness" matters.


File: vicare-scheme.info,  Node: expander examples phases,  Prev: expander examples contours,  Up: expander examples

15.8.4 Expansion and evaluation phases
--------------------------------------

* Menu:

* expander examples phases single::  Single internal body and
                                     different phases.


File: vicare-scheme.info,  Node: expander examples phases single,  Up: expander examples phases

15.8.4.1 Single internal body and different phases
..................................................

Let's consider the syntactic form:

     (internal-body
       (begin-for-syntax
         (void))
       (void))

the 'internal-body' is expanded at phase 1 and evaluated at phase 0; the
'begin-for-syntax' is expanded at phase 2 and evaluated at phase 1.  The
code in 'begin-for-syntax' is evaluated when the code in 'internal-body'
is expanded.

   Let's compare two syntactic identifiers captured by syntactic
bindings established at different expansion phases:

     (internal-body
       (define A 1)
       (begin-for-syntax
         (define B 1)
         (pretty-print #'A)
         (pretty-print #'B)
         (printf "same ribs? ~a\n" (eq-ribs? #'A #'B))
         (pretty-print (id-rib*/no-top #'A)))
       (void))
     -| #<syntactic-identifier expr=A mark*=(src)>
     -| #<syntactic-identifier expr=B mark*=(src)>
     -| same ribs? #t
     -| (#<rib name*=(B A) mark**=((src) (src)) label*=(lab.B lab.A)>)

let's acknowledge that:

   * The syntactic binding 'A' is established when 'internal-body' is
     expanded: at phase 1.

   * The syntactic binding 'B' is established when 'begin-for-syntax' is
     expanded: at phase 2.

   * The '<stx>' objects representing the syntactic identifiers '(syntax
     A)' and '(syntax B)' have the same marks and 'rib' objects.

   * The 'rib' of 'internal-body' has tuples for both 'A' and 'B'.

so the expansion/evaluation phases are *not* distinguished in the
'<stx>' objects and the 'rib' objects.  Under Vicare: phase 0 has its
LEXENV; phase 1 and the other phases have their LEXENV.

   Let's try to resolve the identifiers using the inferior LEXENV from
the 'begin-for-syntax':

     (internal-body
       (define A 1)
       (begin-for-syntax
         (define B 1)
         (pretty-print (id->label      #'A))
         (pretty-print (id->label      #'B))
         (pretty-print (id->descriptor #'A))
         (pretty-print (id->descriptor #'B)))
       (void))
     -| lab.A
     -| lab.B
     -| (lexical . (lab.A . #f))
     -| (displaced-lexical . #f)

we see that the labels are retrieved correctly from the 'rib' object;
the descriptor of 'A' is retrieved from the inferior LEXENV, while the
label of 'B' appears unbound.

   To retrieve the descriptor of 'B' we do:

     (internal-body
       (begin-for-syntax
         (define B 1)
         (begin-for-syntax
           (pretty-print (id->label      #'B))
           (pretty-print (id->descriptor #'B))))
       (void))
     -| lab.B
     -| (lexical . (lab.B . #f))

let's acknowledge that:

   * The code in the external 'begin-for-syntax' is expanded at phase 2
     and evaluated at phase 1.  If we evaluate 'current-inferior-lexenv'
     in the body of the external 'begin-for-syntax': we retrieve the
     LEXENV holding descriptors for phase 1.

   * The code in the internal 'begin-for-syntax' is expanded at phase 3
     and evaluated at phase 2.  If we evaluate 'current-inferior-lexenv'
     in the body of the internal 'begin-for-syntax': we retrieve the
     LEXENV holding descriptors for phase 2.

for this reason: from the internal 'begin-for-syntax' we are able to
retrieve the descriptor of 'B'.


File: vicare-scheme.info,  Node: expander specs,  Prev: expander examples,  Up: expander

15.9 Object-type specifications
===============================

Type specifications are expand-time objects that describe the
characteristics of object-types.  Type specifications are part of the
lexical environment and are contained in syntactic binding's
descriptors.

   Every type annotation has an internal representation as type
specification, *note Type annotations: (vicare-typed)annotations.  The
type specifications API is exposed mostly for debugging purposes: in
normal operations we are not meant to use it directly.

* Menu:

* expander specs intro::        Introduction to type specifications.
* expander specs retrieving::   Retrieving type specifications.
* expander specs object::       Base object-type specifications.
* expander specs core::         Core object-type specifications.
* expander specs struct::       Struct object-type specifications.
* expander specs record::       Record object-type specifications.
* expander specs pair::         Pair type specifications.
* expander specs pair-of::      Pair-of type specifications.
* expander specs list::         List type specifications.
* expander specs list-of::      List-of type specifications.
* expander specs vector::       Vector type specifications.
* expander specs vector-of::    Vector-of type specifications.
* expander specs condobj::      Condition-object type specifications.
* expander specs enum::         Enumeration type specifications.
* expander specs hashtable::    Hashtable type specifications.
* expander specs alist::        Association list type specifications.
* expander specs closure::      Closure object type specifications.
* expander specs union::        Union type specifications.
* expander specs intersection:: Intersection type specifications.
* expander specs complement::   Complement type specifications.
* expander specs ancestor::     Ancestor-of type specifications.
* expander specs label::        Label type specifications.
* expander specs interface::    Interface type specifications.
* expander specs signatures::   Type specification signatures.


File: vicare-scheme.info,  Node: expander specs intro,  Next: expander specs retrieving,  Up: expander specs

15.9.1 Introduction to type specifications
------------------------------------------

The internal representation of object-types is as hierarchy of
record-types having the type '<object-type-spec>' as base.  The
hierarchy of record-types is:

     <object-type-spec>
        |
        +--> <core-type-spec>
        |
        +--> <struct-type-spec>
        |
        +--> <record-type-spec>
        |
        +--> <closure-type-spec>
        |
        +--> <compound-condition-type-spec>
        |
        +--> <union-type-spec>
        |
        +--> <intersection-type-spec>
        |
        +--> <complement-type-spec>
        |
        +--> <ancestor-of-type-spec>
        |
        +--> <pair-type-spec>
        |
        +--> <pair-of-type-spec>
        |
        +--> <list-type-spec>
        |
        +--> <list-of-type-spec> --> <alist-type-spec>
        |
        +--> <vector-type-spec>
        |
        +--> <vector-of-type-spec>
        |
        +--> <hashtable-type-spec>
        |
        +--> <enumeration-type-spec>
        |
        +--> <label-type-spec>
        |
         --> <interface-type-spec>

   At present, all the record-types exposed by the library '(vicare
expander)' are sealed: they cannot be sub-typed by user code.

   The type '<object-type-spec>' has a field 'parent-ots' that is used
to represent the hierarchy of Scheme-level object-types.

   All the built-in Scheme object types are represented by instances of
'<core-type-spec>'; so '<top>', '<fixnum>', '<string>', '<list>' et
cetera are represented by instances of '<core-type-spec>'.

Hierarchy of list types
.......................

The hierarchy of list types is as follows:

     <list>
        |
        +--> <null>
        |
        +--> (list-of ?TYPE) --> <null>
        |
         --> <nelist> --> (list ?TYPE0 ?TYPE ...)

notice how '<null>' is considered a sub-type of both '<list>' and
'(list-of ?TYPE)' annotations, but *not* of '(list ?TYPE0 ?TYPE ...)';
this special handling is implemented in the function
'object-type-spec.matching-super-and-sub?'.

   The type annotations '(list-of ?TYPE)' are represented by instances
of '<list-of-type-spec>'.  '(list ?TYPE0 ?TYPE ...)' annotations are
represented by instances of '<list-type-spec>', and represent non-empty
lists.

Hierarchy of vector types
.........................

The hierarchy of vector types is as follows:

     <vector>
        |
        +---> <empty-vector>
        |
        +---> (vector-of ?TYPE) ---> <empty-vector>
        |
         ---> <nevector> ----------> (vector ?TYPE0 ?TYPE ...)

notice how '<empty-vector>' is considered a sub-type of both '<vector>'
and '(vector-of ?TYPE)' annotations, but *not* of '(vector ?TYPE0 ?TYPE
...)' annotations; this special handling is implemented in the function
'object-type-spec.matching-super-and-sub?'.

   The type annotation '(vector-of ?TYPE)' annotations are represented
by instances of '<vector-of-type-spec>'.  '(vector ?TYPE0 ?TYPE ...)'
annotations are represented by instances of '<vector-type-spec>', and
represent non-empty vectors.


File: vicare-scheme.info,  Node: expander specs retrieving,  Next: expander specs object,  Prev: expander specs intro,  Up: expander specs

15.9.2 Retrieving type specifications
-------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Function: make-type-specification ANNOTATION
     Build and return a new object-type specification object.
     ANNOTATION must be a syntax object representing the type
     annotation.  This function allows us to define type annotations as
     follows:

          (import (only (psyntax expander)
                        make-type-specification))

          (define ots
            (make-type-specification #'<string>))


File: vicare-scheme.info,  Node: expander specs object,  Next: expander specs core,  Prev: expander specs retrieving,  Up: expander specs

15.9.3 Base object-type specifications
--------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <object-type-spec>
     Record-type name of the base type for all the object-type
     specifications.  In this documentation, instances of this type used
     as arguments to function are indicated as OTS.

 -- Function: object-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<object-type-spec>',
     otherwise return '#f'.

 -- Function: object-type-spec.name OTS
 -- Function: object-type-spec.type-annotation OTS
     Return a syntax object representing the name or the type annotation
     of the object-type specification OTS.

     For some types the type name and the type annotation are equal, for
     example the core type names '<fixnum>', '<string>', et cetera are
     both type names and type annotations.  For other types they are
     distinguished, for example if we define the type:

          (define-type <list-of-fixnums>
            (list-of <fixnum>))

     the type name is '<list-of-fixnums>' while the type annotation is
     '(list-of <fixnum>)'.

 -- Function: object-type-spec.uids-list OTS
     Return a list of symbols uniquely identifying this type
     specification.  The head of the list is a symbol associated to this
     object-type; the second item in the list is associated to the
     parent; and so on.

 -- Function: object-type-spec.parent-ots
     Return '#f' or an instance of '<object-type-spec>' representing the
     parent of this object-type.

 -- Function: object-type-spec.constructor-stx OTS
     Return a boolean value or a syntax object representing a Scheme
     expression that, expanded and evaluated at run-time, returns the
     default constructor function.

        * When the return value is '#f': this object-type has no
          constructor, so trying to use the syntax 'new' will cause an
          expand-time exception.

        * When the return value is '#t': this object-type has no
          constructor, but requires the object to be supplied in its
          already-built form to the syntax 'new'.  For example:

               (new <fixnum> 123)

          must expand to an equivalent of:

               (assert-signature-and-return (<fixnum>) 123)

        * When this field is a syntax object: the constructor is meant
          to be used as:

               (?constructor ?arg ...)

          and called explicitly with the syntax 'new'.

          The constructor can be a syntax or core operation like
          '$make-clean-vector' or a closure object like 'vector' or the
          maker of record-types.

 -- Function: object-type-spec.destructor-stx OTS
     Return '#f' or a syntax object representing a Scheme expression
     that, expanded and evaluated at run-time, returns a destructor
     function.  The destructor is meant to be used as:

          (?destructor ?instance)

     and called explicitly with the 'delete' syntax.

 -- Function: object-type-spec.type-predicate-stx OTS
     Return '#f' or a syntax object representing a Scheme expression
     that, expanded and evaluated at run-time, returns a type predicate
     for the object-type OTS.

     The predicate is meant to be used as:

          (?PREDICATE ?OBJECT)

     and called explicitly with the 'is-a?' syntax.

     The type predicate can be a syntax or core operation or a closure
     object like 'vector?' or the predicate of record-types.

 -- Function: object-type-spec.equality-predicate OTS
     Return '#f' or a syntax object which, expanded and evaluated at
     run-time, returns the equality predicate for this type.

 -- Function: object-type-spec.comparison-procedure OTS
     Return '#f' or a syntax object which, expanded and evaluated at
     run-time, returns the comparison procedure for this type.

 -- Function: object-type-spec.applicable-hash-function OTS
     Return '#f' or a syntax object representing a Scheme expression
     which, expanded and evaluated, returns the hash function for this
     type.

 -- Function: object-type-spec.implemented-interfaces OTS
     A (possibly empty) proper list of '<interface-type-spec>' instances
     representing the implemented interfaces.

 -- Function: object-type-spec.applicable-method-stx OTS METHOD-NAME
     OTS must an object-type specification record.  METHOD-NAME must be
     a symbol representing a method name in the object-type
     specification.

     If METHOD-NAME is 'eq?' to:

        * The name of a public method for OTS.

        * The name of a public method for OTS's parent.

     return a syntax object representing a Scheme expression which,
     expanded and evaluated at run-time, returns the method's
     applicable; otherwise return '#f'.

 -- Function: object-type-spec=? OTS0 OTS ...
     Return '#t' if all the '<object-type-spec>' instances given as
     operands are equal to each other; otherwise return '#f'.

 -- Function: object-type-spec.ancestor-ots* OTS
     Return the, possibly empty, list of '<object-type-spec>' instances
     representing the ancestors list of OTS.  OTS itself is *not*
     included in the list.

     As example, when applied to the object-type specification of
     '&condition', the return value is the list of specifications for:

          (<record> <struct> <top>)

 -- Function: object-type-spec.common-ancestor OTS1 OTS2
     Search the hierarchies of OTS1 and OTS2 looking for a common
     ancestor.  Return an instance of '<object-type-spec>' representing
     the ancestor's '<ots>'.  If no ancestor is found: return the
     specification of '<top>'.

 -- Function: object-type-spec.matching-super-and-sub? OTS1 OTS2
     Return '#t' if the specifications given as operands are matching
     super-type and sub-type; otherwise return '#f'.

     The object-type specifications OTS1 OTS2 are matching super-type
     and sub-type when OTS1 can be interpreted as super-type of OTS2.
     For example:

        * When OTS1 is a parent of OTS2.

        * When both OTS1 and OTS2 represent pair compounds whose car and
          cdr are matching super-type and sub-type.

        * When both OTS1 and OTS2 represent list compounds whose car and
          cdr are matching super-type and sub-type.

        * When both OTS1 and OTS2 represent vector compounds whose car
          and cdr are matching super-type and sub-type.

 -- Function: object-type-spec.compatible-super-and-sub? OTS1 OTS2
     Return '#t' if the specifications given as operands are compatible
     super-type and sub-type; otherwise return '#f'.  This function is
     meant to be used when we have already applied
     'object-type-spec.matching-super-and-sub?' to the same operands and
     the result was '#f'.

     The operands OTS1 and OTS2 are compatible as super-type and
     sub-type when OTS2 is a matching super-type of OTS1.  Whenever OTS1
     is the type specification of an expected argument and OTS2 is the
     type specification of a given operand: it makes sense to consider
     them "matching" at expand-time, but to perform a further values
     validation at run-time.

 -- Function: object-type-spec.procedure? OTS
     Return '#t' if OTS represents the object-type specification of a
     closure object; otherwise return '#f'.  This means OTS is either an
     instance of '<closure-type-spec>' or it is the specification of
     '<procedure>'.

 -- Function: object-type-spec.list-sub-type? OTS
     Return '#t' if OTS represents the object-type specification of a
     list object; otherwise return '#f'.

 -- Function: object-type-spec.vector-sub-type? OTS
     Return '#t' if OTS represents the object-type specification of a
     vector object; otherwise return '#f'.


File: vicare-scheme.info,  Node: expander specs core,  Next: expander specs struct,  Prev: expander specs object,  Up: expander specs

15.9.4 Core object-type specifications
--------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <core-type-spec>
     Name of type specifications for core Scheme objects.  Instances of
     this type are the object-type specifications for: '<fixnum>',
     '<flonum>', '<string>', '<list>', et cetera.  There may be multiple
     instances of this type representing the same Scheme object-type.

     Instances of this type are internally generated and cannot be built
     by user code.

 -- Function: core-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<core-type-spec>'; otherwise
     return '#f'.

 -- Function: core-type-spec.type-descriptor-id OTS
     Return a syntactic identifier bound to the instance of
     '<core-type-descriptor>' describing run-time features of the
     object-type.

 -- Function: core-type-spec.parent-and-child? OTS1 OTS2
     Return '#t' if OTS1 and OTS2 represent parent and child
     object-types (respectively); otherwise return '#f'.  Return '#f' if
     the operands represent the same object-type.


File: vicare-scheme.info,  Node: expander specs struct,  Next: expander specs record,  Prev: expander specs core,  Up: expander specs

15.9.5 Struct object-type specifications
----------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <struct-type-spec>
     Name of type specifications for Vicare's struct objects.  Instances
     of this type are generated by the syntax 'define-struct'.

 -- Function: struct-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<struct-type-spec>';
     otherwise return '#f'.

 -- Function: struct-type-spec.std OTS
     Return the struct-type descriptor object.


File: vicare-scheme.info,  Node: expander specs record,  Next: expander specs pair,  Prev: expander specs struct,  Up: expander specs

15.9.6 Record object-type specifications
----------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <record-type-spec>
     Name of type specifications for record-type.  Instances of this
     type are generated by the syntax 'define-record-type'.

 -- Function: record-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<record-type-spec>';
     otherwise return '#f'.

 -- Function: record-type-spec.rtd-id OTS
 -- Function: record-type-spec.rcd-id OTS
     Return the syntactic identifier bound to the record-type descriptor
     or record-type constructor descriptor.

 -- Function: record-type-spec.parent-and-child? OTS1 OTS2
     Return '#t' if OTS1 and OTS2 represent parent and child
     object-types (respectively); otherwise return '#f'.  Return '#f' if
     the operands represent the same object-type.


File: vicare-scheme.info,  Node: expander specs pair,  Next: expander specs pair-of,  Prev: expander specs record,  Up: expander specs

15.9.7 Pair type specifications
-------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <pair-type-spec>
     Name of type specifications for pairs of heterogeneous values.

 -- Function: make-pair-type-spec CAR-OTS CDR-OTS
     Build and return a new instance of '<pair-type-spec>'.  The
     arguments CAR-OTS and CDR-OTS must be instances of
     '<object-type-spec>' representing the car and cdr specifications,
     respectively.

 -- Function: pair-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<pair-type-spec>'; otherwise
     return '#f'.

 -- Function: pair-type-spec.car-ots OTS
 -- Function: pair-type-spec.cdr-ots OTS
     Return instances of '<object-type-spec>' representing the car and
     cdr specifications, respectively.


File: vicare-scheme.info,  Node: expander specs pair-of,  Next: expander specs list,  Prev: expander specs pair,  Up: expander specs

15.9.8 Pair-of type specifications
----------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <pair-of-type-spec>
     Name of type specifications for pairs of homogeneous values.

 -- Function: make-pair-of-type-spec ITEM-OTS
     Build and return a new instance of '<pair-of-type-spec>'.  The
     argument ITEM-OTS must be an instance of '<object-type-spec>'
     representing the type specification of both the car and cdr.

 -- Function: pair-of-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<pair-of-type-spec>';
     otherwise return '#f'.

 -- Function: pair-of-type-spec.item-ots DES
     Return an instance of '<object-type-spec>' representing the type
     specification of both the car and cdr.


File: vicare-scheme.info,  Node: expander specs list,  Next: expander specs list-of,  Prev: expander specs pair-of,  Up: expander specs

15.9.9 List type specifications
-------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <list-type-spec>
     Name of type specifications for lists of heterogeneous values.

 -- Function: make-list-type-spec ITEM-OTS*
     Build and return a new instance of '<list-type-spec>'.  The
     argument ITEM-OTS* must be a proper, non-empty list of
     '<object-type-spec>' instances representing the type specifications
     of the items in the list.

 -- Function: list-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<list-type-spec>'; otherwise
     return '#f'.

 -- Function: list-type-spec.item-ots* OTS
     Return a proper, non-empty list of '<object-type-spec>' instances
     representing the type specifications of the items in the list.

 -- Function: list-type-spec.length OTS
     Return the length of the list, a non-negative exact integer.


File: vicare-scheme.info,  Node: expander specs list-of,  Next: expander specs vector,  Prev: expander specs list,  Up: expander specs

15.9.10 List-of type specifications
-----------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <list-of-type-spec>
     Name of type specifications for lists of homogeneous values.

 -- Function: make-list-of-type-spec ITEM-OTS
     Build and return a new instance of '<list-of-type-spec>'.  The
     argument ITEM-OTS must be an instance of '<object-type-spec>'
     representing the type specification of all the items.

 -- Function: list-of-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<list-of-type-spec>';
     otherwise return '#f'.

 -- Function: list-of-type-spec.item-ots OTS
     Return an instance of '<object-type-spec>' representing the type
     specification of all the items.


File: vicare-scheme.info,  Node: expander specs vector,  Next: expander specs vector-of,  Prev: expander specs list-of,  Up: expander specs

15.9.11 Vector type specifications
----------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <vector-type-spec>
     Name of type specifications for vectors of heterogeneous values.

 -- Function: make-vector-type-spec ITEM-OTS*
     Build and return a new instance of '<vector-type-spec>'.  The
     argument ITEM-OTS* must be a proper, non-empty list of
     '<object-type-spec>' instances representing the type specifications
     of the items in the vector.

 -- Function: vector-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<vector-type-spec>';
     otherwise return '#f'.

 -- Function: vector-type-spec.item-ots* OTS
     Return a proper, non-empty list of '<object-type-spec>' instances
     representing the type specifications of the items in the vector.

 -- Function: vector-type-spec.length OTS
     Return the length of the vector, a non-negative exact integer.


File: vicare-scheme.info,  Node: expander specs vector-of,  Next: expander specs condobj,  Prev: expander specs vector,  Up: expander specs

15.9.12 Vector-of type specifications
-------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <vector-of-type-spec>
     Name of type specifications for vectors of homogeneous values.

 -- Function: make-vector-of-type-spec ITEM-OTS
     Build and return a new instance of '<vector-of-type-spec>'.  The
     argument ITEM-OTS must be an instance of '<object-type-spec>'
     representing the type specification of all the items.

 -- Function: vector-of-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<vector-of-type-spec>';
     otherwise return '#f'.

 -- Function: vector-of-type-spec.item-ots OTS
     Return an instance of '<object-type-spec>' representing the type
     specification of all the items.


File: vicare-scheme.info,  Node: expander specs condobj,  Next: expander specs enum,  Prev: expander specs vector-of,  Up: expander specs

15.9.13 Condition-object type specifications
--------------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <compound-condition-type-spec>
     Name of type specifications for compound condition objects.

 -- Function: make-compound-condition-type-spec COMPONENT-OTS*
     Build and return a new instance of
     '<compound-condition-type-spec>'.  The argument COMPONENT-OTS* must
     be a non-empty proper list of '<object-type-spec>' instances
     representing the type specifications of the component
     condition-objects.

 -- Function: compound-condition-type-spec? OBJ
     Return '#t' if OBJ is an instance of
     '<compound-condition-type-spec>'; otherwise return '#f'.

 -- Function: compound-condition-type-spec.component-ots* OTS
     Return a non-empty proper list of '<object-type-spec>' instances
     representing the type specifications of the component
     condition-objects.


File: vicare-scheme.info,  Node: expander specs enum,  Next: expander specs hashtable,  Prev: expander specs condobj,  Up: expander specs

15.9.14 Enumeration type specifications
---------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <enumeration-type-spec>
     Name of type specifications for symbols enumerations.

 -- Function: make-enumeration-type-spec SYMBOLS
     Build and return a new instance of '<enumeration-type-spec>'.  The
     argument SYMBOLS must be a non-empty proper list of symbols
     representing the items in the enumeration.

 -- Function: enumeration-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<enumeration-type-spec>';
     otherwise return '#f'.

 -- Function: enumeration-type-spec.symbol* OTS
     Return a non-empty proper list of symbols representing the items in
     the enumeration.

 -- Function: enumeration-type-spec.member? OTS SYM
     Return '#t' if the symbol SYM is a member of the enumeration OTS;
     otherwise return '#f'.


File: vicare-scheme.info,  Node: expander specs hashtable,  Next: expander specs alist,  Prev: expander specs enum,  Up: expander specs

15.9.15 Hashtable type specifications
-------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <hashtable-type-spec>
     Name of type specifications for hashtables.

 -- Function: make-hashtable-type-spec KEY-OTS VAL-OTS
     Build and return a new instance of '<hashtable-type-spec>'.  The
     arguments KEY-OTS and VAL-OTS must be instances of
     '<object-type-spec>' representing the type specifications of keys
     and values, respectively.

 -- Function: hashtable-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<hashtable-type-spec>';
     otherwise return '#f'.

 -- Function: hashtable-type-spec.key-ots OTS
 -- Function: hashtable-type-spec.val-ots OTS
     Return instances of '<object-type-spec>' representing the type
     specifications of keys and values, respectively.


File: vicare-scheme.info,  Node: expander specs alist,  Next: expander specs closure,  Prev: expander specs hashtable,  Up: expander specs

15.9.16 Association list type specifications
--------------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <alist-type-spec>
     Name of type specifications for association lists.

 -- Function: make-alist-type-spec KEY-OTS VAL-OTS
     Build and return a new instance of '<alist-type-spec>'.  The
     arguments KEY-OTS and VAL-OTS must be instances of
     '<object-type-spec>' representing the type specifications of keys
     and values, respectively.

 -- Function: alist-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<alist-type-spec>'; otherwise
     return '#f'.

 -- Function: alist-type-spec.key-ots OTS
 -- Function: alist-type-spec.val-ots OTS
     Return instances of '<object-type-spec>' representing the type
     specifications of keys and values, respectively.


File: vicare-scheme.info,  Node: expander specs closure,  Next: expander specs union,  Prev: expander specs alist,  Up: expander specs

15.9.17 Closure object type specifications
------------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <closure-type-spec>
     Name of type specifications for closure objects.

 -- Function: make-closure-type-spec SIGNATURE
     Build and return a new instance of '<closure-type-spec>'.  The
     argument SIGNATURE must be an instance of '<case-lambda-signature>'
     representing the type signatures of the closure's clauses.

 -- Function: closure-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<closure-type-spec>';
     otherwise return '#f'.

 -- Function: closure-type-spec.signature DES
     Return an instance of '<case-lambda-signature>' representing the
     type signatures of the closure's clauses.


File: vicare-scheme.info,  Node: expander specs union,  Next: expander specs intersection,  Prev: expander specs closure,  Up: expander specs

15.9.18 Union type specifications
---------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <union-type-spec>
     Name of type specifications for unions of type specifications.

 -- Function: union-of-type-specs OTS0 OTS ...
     Build and return a new instance of '<object-type-spec>'
     representing the union between the given type specifications.  The
     returned value may or may not be an instance of
     '<union-type-spec>'.

 -- Function: union-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<union-type-spec>'; otherwise
     return '#f'.

 -- Function: union-type-spec.item-ots* OTS
     Return a non-empty proper list of '<object-type-spec>' instances
     representing the optional type specifications.


File: vicare-scheme.info,  Node: expander specs intersection,  Next: expander specs complement,  Prev: expander specs union,  Up: expander specs

15.9.19 Intersection type specifications
----------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <intersection-type-spec>
     Name of type specifications for intersections of type
     specifications.

 -- Function: intersection-of-type-specs COMPONENT-OTS*
     Build and return a new instance of '<object-type-spec>'
     representing the intersection between the given type
     specifications.  The returned value may or may not be an instance
     of '<intersection-type-spec>'.

     The argument COMPONENT-OTS* must be a non-empty proper list of
     '<object-type-spec>' instances representing the type
     specifications.

 -- Function: intersection-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<intersection-type-spec>';
     otherwise return '#f'.

 -- Function: intersection-type-spec.item-ots* OTS
     Return a non-empty proper list of '<object-type-spec>' instances
     representing the mandatory type specifications.


File: vicare-scheme.info,  Node: expander specs complement,  Next: expander specs ancestor,  Prev: expander specs intersection,  Up: expander specs

15.9.20 Complement type specifications
--------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <complement-type-spec>
     Name of type specifications for the complement of a type
     specification.

 -- Function: make-complement-type-spec ITEM-OTS
     Build and return a new instance of '<complement-type-spec>'.  The
     argument ITEM-OTS must be an instance of '<object-type-spec>'
     representing the type specification to be complemented.

 -- Function: complement-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<complement-type-spec>';
     otherwise return '#f'.

 -- Function: complement-type-spec.item-ots DES
     Return an instance of '<object-type-spec>' representing the type
     specification to be complemented.


File: vicare-scheme.info,  Node: expander specs ancestor,  Next: expander specs label,  Prev: expander specs complement,  Up: expander specs

15.9.21 Ancestor-of type specifications
---------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <ancestor-of-type-spec>
     Name of type specifications representing the ancestors of a type
     specification.

 -- Function: make-ancestor-of-type-spec OTS
     Build and return a new instance of '<ancestor-of-type-spec>'.  The
     argument OTS must be an instance of '<object-type-spec>'
     representing the type specification of which we want to describe
     the ancestors.

 -- Function: ancestor-of-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<ancestor-of-type-spec>';
     otherwise return '#f'.

 -- Function: ancestor-of-type-spec.item-ots OTS
     Return the type specification of which OTS describes the ancestors.

 -- Function: ancestor-of-type-spec.ancestor-ots* OTS
     Return a list of type specifications representing the ancestors.
     The head of the list is the parent type specification.


File: vicare-scheme.info,  Node: expander specs label,  Next: expander specs interface,  Prev: expander specs ancestor,  Up: expander specs

15.9.22 Label type specifications
---------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <label-type-spec>
     Name of type specifications representing a label-type specification

 -- Function: label-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<label-type-spec>'; otherwise
     return '#f'.


File: vicare-scheme.info,  Node: expander specs interface,  Next: expander specs signatures,  Prev: expander specs label,  Up: expander specs

15.9.23 Interface type specifications
-------------------------------------

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <interface-type-spec>
     Name of type specifications representing interface type
     specifications.

 -- Function: interface-type-spec? OBJ
     Return '#t' if OBJ is an instance of '<interface-type-spec>';
     otherwise return '#f'.


File: vicare-scheme.info,  Node: expander specs signatures,  Prev: expander specs interface,  Up: expander specs

15.9.24 Type specification signatures
-------------------------------------

* Menu:

* expander specs signatures type::         Type signatures.
* expander specs signatures lambda::       Lambda signature specifications.
* expander specs signatures case-lambda::  Case-lambda signature specifications.


File: vicare-scheme.info,  Node: expander specs signatures type,  Next: expander specs signatures lambda,  Up: expander specs signatures

15.9.24.1 Type signatures
.........................

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <type-signature>
     Type name of objects representing the type of lambda formals.

 -- Function: make-type-signature SPECS
     Build and return a new instance of '<type-signature>'.  The
     argument SPECS must be a proper or improper list of
     '<object-type-spec>' instances representing the signatures of
     lambda formals.

 -- Function: type-signature? OBJ
     Return '#t' if OBJ is an instance of '<type-signature>'; otherwise
     return '#f'.

 -- Function: type-signature.object-type-specs DES
     Return a proper or improper list of '<object-type-spec>' instances
     representing the signatures of lambda formals.


File: vicare-scheme.info,  Node: expander specs signatures lambda,  Next: expander specs signatures case-lambda,  Prev: expander specs signatures type,  Up: expander specs signatures

15.9.24.2 Lambda signature specifications
.........................................

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <lambda-signature>
     Type name of objects representing the type signature of single
     lambda clauses.

 -- Function: make-lambda-signature RETVALS ARGVALS
     Build and return a new instance of '<lambda-signature>'.

     The argument RETVALS must be an instance of '<type-signature>'
     representing the types of values returned by this lambda clause.

     The argument ARGVALS must be an instance of '<type-signature>'
     representing the types of arguments expected by this lambda clause.

 -- Function: lambda-signature? OBJ
     Return '#t' if OBJ is an instance of '<lambda-signature>';
     otherwise return '#f'.

 -- Function: lambda-signature.retvals DES
     Return an instance of '<type-signature>' representing the types of
     values returned by this lambda clause.

 -- Function: lambda-signature.argvals DES
     Return an instance of '<type-signature>' representing the types of
     arguments expected by this lambda clause.


File: vicare-scheme.info,  Node: expander specs signatures case-lambda,  Prev: expander specs signatures lambda,  Up: expander specs signatures

15.9.24.3 Case-lambda signature specifications
..............................................

The following syntactic bindings are exported by the library '(vicare
expander)'.

 -- Record Type: <case-lambda-signature>
     Type name of objects representing the type signature of a tuple of
     lambda clauses.

 -- Function: make-case-lambda-signature CLAUSE-SIGNATURE*
     Build and return a new instance of '<case-lambda-signature>'.  The
     argument CLAUSE-SIGNATURE* must be a non-empty list of
     '<lambda-signature>' representing the type specifications of the
     single lambda clauses.

 -- Function: case-lambda-signature? OBJ
     Return '#t' if OBJ is an instance of '<case-lambda-signature>';
     otherwise return '#f'.

 -- Function: case-lambda-signature.clause-signature* DES
     Return a non-empty list of '<lambda-signature>' representing the
     type specifications of the single lambda clauses.


File: vicare-scheme.info,  Node: machinery,  Next: compiler,  Prev: expander,  Up: Top

16 Introduction to execution machinery
**************************************

The execution machinery of compiled Scheme code is a bit intricated when
compared with the execution of, say, "normal" compiled C code; this is
because the following features must be implemented:

*Closures*
     Scheme functions are not just blocks of machine code: they are
     allowed to reference variable values captured at run time.
     Multiple closures (referencing different instances of the same
     semantic variables) can share the same block of machine code.
     Multiple closures (referencing different blocks of machine code)
     can share the same variable values.  *note Closure objects: objects
     closures.

*Tail calls*
     Whenever a Scheme function call happens in tail position: it must
     be implemented in such a way that *no* new stack frame is created
     for the callee function; rather the stack frame of the caller is
     destroyed and reused as callee's frame.  This allows the use of
     tail calls as proper idiom to implement all the execution loops,
     even when such loops have an "infinite" number of iterations,
     without the risk of overflowing the Scheme stack.

*Continuations*
     Scheme code is allowed to save the current continuation and resume
     it later any number of times.

* Menu:

* machinery simplifications::   Simplification assumptions.
* machinery registers::         Special CPU registers.
* machinery scheme stack::      Basics of the Scheme stack.
* machinery call frames::       Basics of function call frames.
* machinery continuations::     The current continuation.
* machinery stack overflow::    Scheme stack overflow.
* machinery call arguments::    Function call arguments.
* machinery call retvals::      Function call return values.
* machinery tail calls::        Tail calls optimisation.
* machinery locals::            Local variables.


File: vicare-scheme.info,  Node: machinery simplifications,  Next: machinery registers,  Up: machinery

16.1 Simplification assumptions
===============================

To make it easy to explain the run time behaviour of Vicare, we will
assume the validity of the following simplifications:

  1. At the start of a user program execution: the Scheme stack is
     empty.  This is false because, at Vicare launch time, the boot
     image is loaded and initialised, executing a lot of compiled Scheme
     code.  But starting with an empty stack makes reasoning simpler.

  2. No expressions and function calls are inlined.  This is false
     because the compiler precomputes some expressions, inlines some
     function calls and removes bindings whenever possible; this makes
     the executed code different from the original Scheme code.  But we
     want to show sample Scheme code as close as possible to the one
     that gets executed.

  3. Unless otherwise specified: no tail call optimisation (TCO) is
     performed.  This is false because, whenever it recognises a
     function call in tail position, Vicare always performs the call in
     such a way that the new stack frame overwrites the old one.  But we
     want to show simple functions that create new stack frames.

  4. The function 'call/cc' is implemented without subordinate function
     calls.  This is depends upon the function call integration
     optimisations performed by the compiler.  But reasoning about
     simple function call is simpler.

  5. There is no dynamic environment to be captured by continuations.
     This is false because whenever 'dynamic-wind' is used stacks of
     in-guard and out-guard functions are created and captured by
     continuations; the continuation escape function, created by
     'call/cc', does invoke such guard functions to keep the dynamic
     environment synchronised with the execution flow.  But learning
     about continuations alone already introduces enough complications.

  6. When discussing sample programs we assume that only the code we see
     is executed.  This is false because whenever a user program is run:
     the code is loaded and compiled, then some initialisation is
     performed before running it.  Rather when dissussing the execution
     of:

          (import (rnrs))
          (define (one a)
            (+ a 1))
          (one 2)

     we assume that the first executed code is the expression '(one 2)'.


File: vicare-scheme.info,  Node: machinery registers,  Next: machinery scheme stack,  Prev: machinery simplifications,  Up: machinery

16.2 Special CPU registers
==========================

While running Scheme code Vicare assigns a special role to some CPU
registers.

*Accumulator and Arguments count Register, AAR, 'AA-REGISTER'*
     It is used to hold:

        * The result of Assembly instructions.

        * A fixnum representing the negated number of arguments to the
          function call that is about to happen.

        * The return value from a function call that just returned, when
          such function returns a single value.

        * A fixnum representing the negated number of return values from
          a function call that just returned, when such function returns
          0, 2 or more values.

     it is also used as general purpose register.  On a 32-bit i686 CPU
     it is the register 'EAX'.

*Allocation Pointer Register, APR, 'AP-REGISTER'*
     Holds the address of the first free machine word in the memory
     segment of the Scheme heap nursery.  On a 32-bit i686 CPU it is the
     register 'EBP'.

*Closure Pointer Register, CPR, 'CP-REGISTER'*
     Holds the tagged address of a machine word in the Scheme heap,
     representing the reference to the closure object being executed;
     when no closure is being executed: it is set to zero.  It is used
     to enter the execution of the closure code and to access the free
     variables the closure is closed upon.  On a 32-bit i686 CPU it is
     the register 'EDI'.

*Frame Pointer Register, FPR, 'FP-REGISTER'*
     Holds the address of the machine word in the memory segment of the
     Scheme stack holding the return address of the last performed
     function call.  It is used to access the machine words on the stack
     containing function arguments and local variables.  On a 32-bit
     i686 CPU it is the register 'ESP'.

*Process Control Register, PCR, 'PC-REGISTER'*
     Holds the raw address of a machine word in the C language heap;
     such address references the first word in the PCB data structure.
     On a 32-bit i686 CPU it is the register 'ESI'.


File: vicare-scheme.info,  Node: machinery scheme stack,  Next: machinery call frames,  Prev: machinery registers,  Up: machinery

16.3 Basics of the Scheme stack
===============================

We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, *note Simplification assumptions:
machinery simplifications.

   When running C code: the state of the Scheme stack is represented by
the fields of the PCB data structure.  When running Scheme code: the
state of the Scheme stack is represented by the Frame Pointer Register
(FPR) and some fields of the PCB data structure.

   When the execution flow moves from C language code to Scheme language
code or from Scheme code to C code: Assembly language routines are
executed to perform some low-level operations.  Such Assembly code takes
care of synchronising the PCB fields with the CPU registers.

   Let's start by taking a look at an empty Scheme stack segment, *note
machinery call frames: fig:MSS_stack_size.  The stack memory segment
begins at the machine word referenced by the PCB field 'stack_base'
(included) and ends at the machine word referenced by the PCB field
'frame_base' (excluded).  'stack_base' changes only when the stack
overflows, 'frame_base' changes when the stack overflows and every time
a continuation object is created.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|                     --
                .                                 .
                .                                 . stack
                .                                 . segment
     |----------------------|                     . size
     |                      | <- pcb->stack_base  .
     |----------------------|                     --
     |                      |
            low memory

Figure 16.1: Size of the Scheme stack segment.

   The stack space is consumed starting from the high memory addresses
towards the low memory addresses; the first used word on the Scheme
stack is right below the machine word referenced by 'frame_base'.

   Upon creation: the first machine word on the stack is initialised to
the address of the Assembly routine 'ik_underflow_handler'; when the
execution flow of Scheme code returns to such address: the routine takes
care of switching from Scheme code to C code and itself returns to a C
function.

   When running C code: the machine word holding the address of the
underflow handler is referenced by the PCB field 'frame_pointer', *note
machinery call frames: fig:MSS_empty_stack_C. When running Scheme code:
the machine word holding the address of the underflow handler is
referenced by the FPR register, *note machinery call frames:
fig:MSS_empty_stack_Scheme.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler | <- pcb->frame_pointer
     |----------------------|
                 .
                 .
                 .
     |----------------------|
     |                      | <- pcb->stack_base
     |----------------------|
     |                      |
            low memory

Figure 16.2: Empty Scheme stack as represented in the PCB structure
while running C code.

           high memory
     |                      |
     |----------------------|
     |                      | <- pcb->frame_base
     |----------------------|
     | ik_underflow_handler | <- Frame Pointer Register (FPR)
     |----------------------|
                 .
                 .
                 .
     |----------------------|
     |                      | <- pcb->stack_base
     |----------------------|
     |                      |
            low memory

Figure 16.3: Empty Scheme stack as represented in the CPU registers and
the PCB structure while running Scheme code.

